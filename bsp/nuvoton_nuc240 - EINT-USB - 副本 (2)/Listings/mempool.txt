; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\mempool.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\mempool.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I.\Libraries\Device\Nuvoton -I..\..\components\finsh -I.\Libraries\CMSIS\Include -I.\Libraries\StdDriver\inc -I..\..\include -I.\APP -I.\Drivers -I..\..\components\drivers\include -I..\..\components\drivers\include\drivers -I..\nuvoton_nuc240 -I.\Libraries\Device\Nuvoton\NUC230_240\Include -I..\..\include -I..\..\components\drivers\usb\usbdevice\class -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=521 --omf_browse=.\objects\mempool.crf ..\..\src\mempool.c]
                          THUMB

                          AREA ||i.rt_list_isempty||, CODE, READONLY, ALIGN=1

                  rt_list_isempty PROC
;;;102     */
;;;103    rt_inline int rt_list_isempty(const rt_list_t *l)
000000  6801              LDR      r1,[r0,#0]
;;;104    {
;;;105        return l->next == l;
000002  4281              CMP      r1,r0
000004  d101              BNE      |L1.10|
000006  2001              MOVS     r0,#1
;;;106    }
000008  4770              BX       lr
                  |L1.10|
00000a  2000              MOVS     r0,#0                 ;105
00000c  4770              BX       lr
;;;107    
                          ENDP


                          AREA ||i.rt_mp_alloc||, CODE, READONLY, ALIGN=1

                  rt_mp_alloc PROC
;;;320     */
;;;321    void *rt_mp_alloc(rt_mp_t mp, rt_int32_t time)
000000  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;322    {
000002  b083              SUB      sp,sp,#0xc
000004  4604              MOV      r4,r0
;;;323        rt_uint8_t *block_ptr;
;;;324        register rt_base_t level;
;;;325        struct rt_thread *thread;
;;;326        rt_uint32_t before_sleep = 0;
000006  2700              MOVS     r7,#0
;;;327    
;;;328        /* get current thread */
;;;329        thread = rt_thread_self();
000008  f7fffffe          BL       rt_thread_self
00000c  4605              MOV      r5,r0
;;;330    
;;;331        /* disable interrupt */
;;;332        level = rt_hw_interrupt_disable();
00000e  f7fffffe          BL       rt_hw_interrupt_disable
000012  2600              MOVS     r6,#0
;;;333    
;;;334        while (mp->block_free_count == 0)
000014  9000              STR      r0,[sp,#0]
000016  e044              B        |L2.162|
                  |L2.24|
;;;335        {
;;;336            /* memory block is unavailable. */
;;;337            if (time == 0)
000018  9804              LDR      r0,[sp,#0x10]
00001a  2800              CMP      r0,#0
00001c  d02b              BEQ      |L2.118|
;;;338            {
;;;339                /* enable interrupt */
;;;340                rt_hw_interrupt_enable(level);
;;;341    
;;;342                rt_set_errno(-RT_ETIMEOUT);
;;;343    
;;;344                return RT_NULL;
;;;345            }
;;;346    
;;;347            RT_DEBUG_NOT_IN_INTERRUPT;
;;;348    
;;;349            thread->error = RT_EOK;
;;;350    
;;;351            /* need suspend thread */
;;;352            rt_thread_suspend(thread);
00001e  4628              MOV      r0,r5
000020  632e              STR      r6,[r5,#0x30]
000022  f7fffffe          BL       rt_thread_suspend
;;;353            rt_list_insert_after(&(mp->suspend_thread), &(thread->tlist));
000026  4628              MOV      r0,r5
000028  6ae2              LDR      r2,[r4,#0x2c]
00002a  3014              ADDS     r0,r0,#0x14
00002c  6050              STR      r0,[r2,#4]
00002e  6ae2              LDR      r2,[r4,#0x2c]
000030  4621              MOV      r1,r4
000032  616a              STR      r2,[r5,#0x14]
000034  312c              ADDS     r1,r1,#0x2c
000036  62e0              STR      r0,[r4,#0x2c]
;;;354            mp->suspend_thread_count++;
000038  61a9              STR      r1,[r5,#0x18]
00003a  6b60              LDR      r0,[r4,#0x34]
00003c  1c40              ADDS     r0,r0,#1
;;;355    
;;;356            if (time > 0)
00003e  6360              STR      r0,[r4,#0x34]
000040  9804              LDR      r0,[sp,#0x10]
000042  2800              CMP      r0,#0
000044  dd0c              BLE      |L2.96|
;;;357            {
;;;358                /* get the start tick of timer */
;;;359                before_sleep = rt_tick_get();
000046  f7fffffe          BL       rt_tick_get
00004a  4607              MOV      r7,r0
;;;360    
;;;361                /* init thread timer and start it */
;;;362                rt_timer_control(&(thread->thread_timer),
00004c  4628              MOV      r0,r5
00004e  304c              ADDS     r0,r0,#0x4c
000050  aa04              ADD      r2,sp,#0x10
000052  2100              MOVS     r1,#0
000054  9001              STR      r0,[sp,#4]
000056  f7fffffe          BL       rt_timer_control
;;;363                                 RT_TIMER_CTRL_SET_TIME,
;;;364                                 &time);
;;;365                rt_timer_start(&(thread->thread_timer));
00005a  9801              LDR      r0,[sp,#4]
00005c  f7fffffe          BL       rt_timer_start
                  |L2.96|
;;;366            }
;;;367    
;;;368            /* enable interrupt */
;;;369            rt_hw_interrupt_enable(level);
000060  9800              LDR      r0,[sp,#0]
000062  f7fffffe          BL       rt_hw_interrupt_enable
;;;370    
;;;371            /* do a schedule */
;;;372            rt_schedule();
000066  f7fffffe          BL       rt_schedule
;;;373    
;;;374            if (thread->error != RT_EOK)
00006a  6b28              LDR      r0,[r5,#0x30]
00006c  2800              CMP      r0,#0
00006e  d00a              BEQ      |L2.134|
                  |L2.112|
;;;375                return RT_NULL;
000070  2000              MOVS     r0,#0
                  |L2.114|
;;;376    
;;;377            if (time > 0)
;;;378            {
;;;379                time -= rt_tick_get() - before_sleep;
;;;380                if (time < 0)
;;;381                    time = 0;
;;;382            }
;;;383            /* disable interrupt */
;;;384            level = rt_hw_interrupt_disable();
;;;385        }
;;;386    
;;;387        /* memory block is available. decrease the free block counter */
;;;388        mp->block_free_count--;
;;;389    
;;;390        /* get block from block list */
;;;391        block_ptr = mp->block_list;
;;;392        RT_ASSERT(block_ptr != RT_NULL);
;;;393    
;;;394        /* Setup the next free node. */
;;;395        mp->block_list = *(rt_uint8_t **)block_ptr;
;;;396    
;;;397        /* point to memory pool */
;;;398        *(rt_uint8_t **)block_ptr = (rt_uint8_t *)mp;
;;;399    
;;;400        /* enable interrupt */
;;;401        rt_hw_interrupt_enable(level);
;;;402    
;;;403        RT_OBJECT_HOOK_CALL(rt_mp_alloc_hook,
;;;404                            (mp, (rt_uint8_t *)(block_ptr + sizeof(rt_uint8_t *))));
;;;405    
;;;406        return (rt_uint8_t *)(block_ptr + sizeof(rt_uint8_t *));
;;;407    }
000072  b005              ADD      sp,sp,#0x14
000074  bdf0              POP      {r4-r7,pc}
                  |L2.118|
000076  9800              LDR      r0,[sp,#0]            ;340
000078  f7fffffe          BL       rt_hw_interrupt_enable
00007c  2001              MOVS     r0,#1                 ;342
00007e  43c0              MVNS     r0,r0                 ;342
000080  f7fffffe          BL       rt_set_errno
000084  e7f4              B        |L2.112|
                  |L2.134|
000086  9804              LDR      r0,[sp,#0x10]         ;377
000088  2800              CMP      r0,#0                 ;377
00008a  dd07              BLE      |L2.156|
00008c  f7fffffe          BL       rt_tick_get
000090  9904              LDR      r1,[sp,#0x10]         ;379
000092  1bc0              SUBS     r0,r0,r7              ;379
000094  1a08              SUBS     r0,r1,r0              ;379
000096  9004              STR      r0,[sp,#0x10]         ;380
000098  d500              BPL      |L2.156|
00009a  9604              STR      r6,[sp,#0x10]         ;381
                  |L2.156|
00009c  f7fffffe          BL       rt_hw_interrupt_disable
0000a0  9000              STR      r0,[sp,#0]            ;384
                  |L2.162|
0000a2  6aa0              LDR      r0,[r4,#0x28]         ;334
0000a4  2800              CMP      r0,#0                 ;334
0000a6  d0b7              BEQ      |L2.24|
0000a8  1e40              SUBS     r0,r0,#1              ;334
0000aa  62a0              STR      r0,[r4,#0x28]         ;391
0000ac  6a25              LDR      r5,[r4,#0x20]         ;395
0000ae  6828              LDR      r0,[r5,#0]            ;395
0000b0  6220              STR      r0,[r4,#0x20]         ;398
0000b2  602c              STR      r4,[r5,#0]            ;401
0000b4  9800              LDR      r0,[sp,#0]            ;401
0000b6  f7fffffe          BL       rt_hw_interrupt_enable
0000ba  1d28              ADDS     r0,r5,#4              ;406
0000bc  e7d9              B        |L2.114|
;;;408    RTM_EXPORT(rt_mp_alloc);
                          ENDP


                          AREA ||i.rt_mp_create||, CODE, READONLY, ALIGN=1

                  rt_mp_create PROC
;;;196     */
;;;197    rt_mp_t rt_mp_create(const char *name,
000000  b570              PUSH     {r4-r6,lr}
;;;198                         rt_size_t   block_count,
;;;199                         rt_size_t   block_size)
;;;200    {
000002  460e              MOV      r6,r1
;;;201        rt_uint8_t *block_ptr;
;;;202        struct rt_mempool *mp;
;;;203        register rt_base_t offset;
;;;204    
;;;205        RT_DEBUG_NOT_IN_INTERRUPT;
;;;206    
;;;207        /* allocate object */
;;;208        mp = (struct rt_mempool *)rt_object_allocate(RT_Object_Class_MemPool, name);
000004  4601              MOV      r1,r0
000006  4615              MOV      r5,r2                 ;200
000008  2006              MOVS     r0,#6
00000a  f7fffffe          BL       rt_object_allocate
00000e  1e04              SUBS     r4,r0,#0
;;;209        /* allocate object failed */
;;;210        if (mp == RT_NULL)
000010  d01b              BEQ      |L3.74|
000012  1ced              ADDS     r5,r5,#3
;;;211            return RT_NULL;
;;;212    
;;;213        /* initialize memory pool */
;;;214        block_size     = RT_ALIGN(block_size, RT_ALIGN_SIZE);
000014  08a8              LSRS     r0,r5,#2
000016  0080              LSLS     r0,r0,#2
;;;215        mp->block_size = block_size;
000018  61e0              STR      r0,[r4,#0x1c]
00001a  1d00              ADDS     r0,r0,#4
;;;216        mp->size       = (block_size + sizeof(rt_uint8_t *)) * block_count;
00001c  4605              MOV      r5,r0
00001e  4370              MULS     r0,r6,r0
;;;217    
;;;218        /* allocate memory */
;;;219        mp->start_address = rt_malloc((block_size + sizeof(rt_uint8_t *)) *
000020  61a0              STR      r0,[r4,#0x18]
000022  f7fffffe          BL       rt_malloc
;;;220                                      block_count);
;;;221        if (mp->start_address == RT_NULL)
000026  6160              STR      r0,[r4,#0x14]
000028  2800              CMP      r0,#0
00002a  d00a              BEQ      |L3.66|
;;;222        {
;;;223            /* no memory, delete memory pool object */
;;;224            rt_object_delete(&(mp->parent));
;;;225    
;;;226            return RT_NULL;
;;;227        }
;;;228    
;;;229        mp->block_total_count = block_count;
;;;230        mp->block_free_count  = mp->block_total_count;
;;;231    
;;;232        /* initialize suspended thread list */
;;;233        rt_list_init(&(mp->suspend_thread));
00002c  4620              MOV      r0,r4
00002e  302c              ADDS     r0,r0,#0x2c
000030  6266              STR      r6,[r4,#0x24]         ;230
000032  6320              STR      r0,[r4,#0x30]         ;230
;;;234        mp->suspend_thread_count = 0;
000034  2300              MOVS     r3,#0
;;;235    
;;;236        /* initialize free block list */
;;;237        block_ptr = (rt_uint8_t *)mp->start_address;
000036  62a6              STR      r6,[r4,#0x28]
000038  6363              STR      r3,[r4,#0x34]
00003a  62e0              STR      r0,[r4,#0x2c]
;;;238        for (offset = 0; offset < mp->block_total_count; offset ++)
00003c  4618              MOV      r0,r3
00003e  6961              LDR      r1,[r4,#0x14]
000040  e00b              B        |L3.90|
                  |L3.66|
000042  4620              MOV      r0,r4                 ;224
000044  f7fffffe          BL       rt_object_delete
000048  2000              MOVS     r0,#0                 ;226
                  |L3.74|
;;;239        {
;;;240            *(rt_uint8_t **)(block_ptr + offset * (block_size + sizeof(rt_uint8_t *)))
;;;241                = block_ptr + (offset + 1) * (block_size + sizeof(rt_uint8_t *));
;;;242        }
;;;243    
;;;244        *(rt_uint8_t **)(block_ptr + (offset - 1) * (block_size + sizeof(rt_uint8_t *)))
;;;245            = RT_NULL;
;;;246    
;;;247        mp->block_list = block_ptr;
;;;248    
;;;249        return mp;
;;;250    }
00004a  bd70              POP      {r4-r6,pc}
                  |L3.76|
00004c  1c42              ADDS     r2,r0,#1              ;240
00004e  436a              MULS     r2,r5,r2              ;240
000050  4606              MOV      r6,r0                 ;240
000052  1852              ADDS     r2,r2,r1              ;240
000054  436e              MULS     r6,r5,r6              ;240
000056  518a              STR      r2,[r1,r6]            ;240
000058  1c40              ADDS     r0,r0,#1              ;240
                  |L3.90|
00005a  6a62              LDR      r2,[r4,#0x24]         ;238
00005c  4282              CMP      r2,r0                 ;238
00005e  d8f5              BHI      |L3.76|
000060  1e40              SUBS     r0,r0,#1              ;238
000062  4368              MULS     r0,r5,r0              ;244
000064  500b              STR      r3,[r1,r0]            ;244
000066  4620              MOV      r0,r4                 ;249
000068  6221              STR      r1,[r4,#0x20]         ;249
00006a  bd70              POP      {r4-r6,pc}
;;;251    RTM_EXPORT(rt_mp_create);
                          ENDP


                          AREA ||i.rt_mp_delete||, CODE, READONLY, ALIGN=1

                  rt_mp_delete PROC
;;;259     */
;;;260    rt_err_t rt_mp_delete(rt_mp_t mp)
000000  b5f8              PUSH     {r3-r7,lr}
;;;261    {
;;;262        struct rt_thread *thread;
;;;263        register rt_ubase_t temp;
;;;264    
;;;265        RT_DEBUG_NOT_IN_INTERRUPT;
;;;266    
;;;267        /* parameter check */
;;;268        RT_ASSERT(mp != RT_NULL);
;;;269    
;;;270        /* wake up all suspended threads */
;;;271        while (!rt_list_isempty(&(mp->suspend_thread)))
;;;272        {
;;;273            /* disable interrupt */
;;;274            temp = rt_hw_interrupt_disable();
;;;275    
;;;276            /* get next suspend thread */
;;;277            thread = rt_list_entry(mp->suspend_thread.next, struct rt_thread, tlist);
;;;278            /* set error code to RT_ERROR */
;;;279            thread->error = -RT_ERROR;
000002  2600              MOVS     r6,#0
000004  43f6              MVNS     r6,r6
000006  4607              MOV      r7,r0                 ;271
000008  4604              MOV      r4,r0                 ;261
00000a  372c              ADDS     r7,r7,#0x2c           ;271
00000c  e00d              B        |L4.42|
                  |L4.14|
00000e  f7fffffe          BL       rt_hw_interrupt_disable
000012  4605              MOV      r5,r0                 ;274
000014  6ae0              LDR      r0,[r4,#0x2c]
000016  61c6              STR      r6,[r0,#0x1c]
000018  3814              SUBS     r0,r0,#0x14
;;;280    
;;;281            /*
;;;282             * resume thread
;;;283             * In rt_thread_resume function, it will remove current thread from
;;;284             * suspend list
;;;285             */
;;;286            rt_thread_resume(thread);
00001a  f7fffffe          BL       rt_thread_resume
;;;287    
;;;288            /* decrease suspended thread count */
;;;289            mp->suspend_thread_count --;
00001e  6b60              LDR      r0,[r4,#0x34]
000020  1e40              SUBS     r0,r0,#1
;;;290    
;;;291            /* enable interrupt */
;;;292            rt_hw_interrupt_enable(temp);
000022  6360              STR      r0,[r4,#0x34]
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       rt_hw_interrupt_enable
                  |L4.42|
00002a  4638              MOV      r0,r7
00002c  f7fffffe          BL       rt_list_isempty
000030  2800              CMP      r0,#0                 ;271
000032  d0ec              BEQ      |L4.14|
;;;293        }
;;;294    
;;;295    #if defined(RT_USING_MODULE) && defined(RT_USING_SLAB)
;;;296        /* the mp object belongs to an application module */
;;;297        if (mp->parent.flag & RT_OBJECT_FLAG_MODULE)
;;;298            rt_module_free(mp->parent.module_id, mp->start_address);
;;;299        else
;;;300    #endif
;;;301    
;;;302        /* release allocated room */
;;;303        rt_free(mp->start_address);
000034  6960              LDR      r0,[r4,#0x14]
000036  f7fffffe          BL       rt_free
;;;304    
;;;305        /* detach object */
;;;306        rt_object_delete(&(mp->parent));
00003a  4620              MOV      r0,r4
00003c  f7fffffe          BL       rt_object_delete
;;;307    
;;;308        return RT_EOK;
000040  2000              MOVS     r0,#0
;;;309    }
000042  bdf8              POP      {r3-r7,pc}
;;;310    RTM_EXPORT(rt_mp_delete);
                          ENDP


                          AREA ||i.rt_mp_detach||, CODE, READONLY, ALIGN=1

                  rt_mp_detach PROC
;;;145     */
;;;146    rt_err_t rt_mp_detach(struct rt_mempool *mp)
000000  b5f8              PUSH     {r3-r7,lr}
;;;147    {
;;;148        struct rt_thread *thread;
;;;149        register rt_ubase_t temp;
;;;150    
;;;151        /* parameter check */
;;;152        RT_ASSERT(mp != RT_NULL);
;;;153    
;;;154        /* wake up all suspended threads */
;;;155        while (!rt_list_isempty(&(mp->suspend_thread)))
;;;156        {
;;;157            /* disable interrupt */
;;;158            temp = rt_hw_interrupt_disable();
;;;159    
;;;160            /* get next suspend thread */
;;;161            thread = rt_list_entry(mp->suspend_thread.next, struct rt_thread, tlist);
;;;162            /* set error code to RT_ERROR */
;;;163            thread->error = -RT_ERROR;
000002  2600              MOVS     r6,#0
000004  43f6              MVNS     r6,r6
000006  4607              MOV      r7,r0                 ;155
000008  4604              MOV      r4,r0                 ;147
00000a  372c              ADDS     r7,r7,#0x2c           ;155
00000c  e00d              B        |L5.42|
                  |L5.14|
00000e  f7fffffe          BL       rt_hw_interrupt_disable
000012  4605              MOV      r5,r0                 ;158
000014  6ae0              LDR      r0,[r4,#0x2c]
000016  61c6              STR      r6,[r0,#0x1c]
000018  3814              SUBS     r0,r0,#0x14
;;;164    
;;;165            /*
;;;166             * resume thread
;;;167             * In rt_thread_resume function, it will remove current thread from
;;;168             * suspend list
;;;169             */
;;;170            rt_thread_resume(thread);
00001a  f7fffffe          BL       rt_thread_resume
;;;171    
;;;172            /* decrease suspended thread count */
;;;173            mp->suspend_thread_count --;
00001e  6b60              LDR      r0,[r4,#0x34]
000020  1e40              SUBS     r0,r0,#1
;;;174    
;;;175            /* enable interrupt */
;;;176            rt_hw_interrupt_enable(temp);
000022  6360              STR      r0,[r4,#0x34]
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       rt_hw_interrupt_enable
                  |L5.42|
00002a  4638              MOV      r0,r7
00002c  f7fffffe          BL       rt_list_isempty
000030  2800              CMP      r0,#0                 ;155
000032  d0ec              BEQ      |L5.14|
;;;177        }
;;;178    
;;;179        /* detach object */
;;;180        rt_object_detach(&(mp->parent));
000034  4620              MOV      r0,r4
000036  f7fffffe          BL       rt_object_detach
;;;181    
;;;182        return RT_EOK;
00003a  2000              MOVS     r0,#0
;;;183    }
00003c  bdf8              POP      {r3-r7,pc}
;;;184    RTM_EXPORT(rt_mp_detach);
                          ENDP


                          AREA ||i.rt_mp_free||, CODE, READONLY, ALIGN=1

                  rt_mp_free PROC
;;;414     */
;;;415    void rt_mp_free(void *block)
000000  b570              PUSH     {r4-r6,lr}
;;;416    {
;;;417        rt_uint8_t **block_ptr;
;;;418        struct rt_mempool *mp;
;;;419        struct rt_thread *thread;
;;;420        register rt_base_t level;
;;;421    
;;;422        /* get the control block of pool which the block belongs to */
;;;423        block_ptr = (rt_uint8_t **)((rt_uint8_t *)block - sizeof(rt_uint8_t *));
000002  1f05              SUBS     r5,r0,#4
;;;424        mp        = (struct rt_mempool *)*block_ptr;
;;;425    
;;;426        RT_OBJECT_HOOK_CALL(rt_mp_free_hook, (mp, block));
;;;427    
;;;428        /* disable interrupt */
;;;429        level = rt_hw_interrupt_disable();
000004  682c              LDR      r4,[r5,#0]
000006  f7fffffe          BL       rt_hw_interrupt_disable
00000a  4606              MOV      r6,r0
;;;430    
;;;431        /* increase the free block count */
;;;432        mp->block_free_count ++;
00000c  6aa0              LDR      r0,[r4,#0x28]
00000e  1c40              ADDS     r0,r0,#1
;;;433    
;;;434        /* link the block into the block list */
;;;435        *block_ptr = mp->block_list;
000010  62a0              STR      r0,[r4,#0x28]
000012  6a20              LDR      r0,[r4,#0x20]
;;;436        mp->block_list = (rt_uint8_t *)block_ptr;
000014  6028              STR      r0,[r5,#0]
;;;437    
;;;438        if (mp->suspend_thread_count > 0)
000016  6225              STR      r5,[r4,#0x20]
000018  6b60              LDR      r0,[r4,#0x34]
00001a  2800              CMP      r0,#0
00001c  d00e              BEQ      |L6.60|
;;;439        {
;;;440            /* get the suspended thread */
;;;441            thread = rt_list_entry(mp->suspend_thread.next,
;;;442                                   struct rt_thread,
;;;443                                   tlist);
;;;444    
;;;445            /* set error */
;;;446            thread->error = RT_EOK;
00001e  6ae0              LDR      r0,[r4,#0x2c]
000020  2100              MOVS     r1,#0
000022  61c1              STR      r1,[r0,#0x1c]
000024  3814              SUBS     r0,r0,#0x14
;;;447    
;;;448            /* resume thread */
;;;449            rt_thread_resume(thread);
000026  f7fffffe          BL       rt_thread_resume
;;;450    
;;;451            /* decrease suspended thread count */
;;;452            mp->suspend_thread_count --;
00002a  6b60              LDR      r0,[r4,#0x34]
00002c  1e40              SUBS     r0,r0,#1
;;;453    
;;;454            /* enable interrupt */
;;;455            rt_hw_interrupt_enable(level);
00002e  6360              STR      r0,[r4,#0x34]
000030  4630              MOV      r0,r6
000032  f7fffffe          BL       rt_hw_interrupt_enable
;;;456    
;;;457            /* do a schedule */
;;;458            rt_schedule();
000036  f7fffffe          BL       rt_schedule
;;;459    
;;;460            return;
;;;461        }
;;;462    
;;;463        /* enable interrupt */
;;;464        rt_hw_interrupt_enable(level);
;;;465    }
00003a  bd70              POP      {r4-r6,pc}
                  |L6.60|
00003c  4630              MOV      r0,r6                 ;464
00003e  f7fffffe          BL       rt_hw_interrupt_enable
000042  bd70              POP      {r4-r6,pc}
;;;466    RTM_EXPORT(rt_mp_free);
                          ENDP


                          AREA ||i.rt_mp_init||, CODE, READONLY, ALIGN=1

                  rt_mp_init PROC
;;;90      */
;;;91     rt_err_t rt_mp_init(struct rt_mempool *mp,
000000  b5f8              PUSH     {r3-r7,lr}
;;;92                         const char        *name,
;;;93                         void              *start,
;;;94                         rt_size_t          size,
;;;95                         rt_size_t          block_size)
;;;96     {
000002  4616              MOV      r6,r2
;;;97         rt_uint8_t *block_ptr;
;;;98         register rt_base_t offset;
;;;99     
;;;100        /* parameter check */
;;;101        RT_ASSERT(mp != RT_NULL);
;;;102    
;;;103        /* initialize object */
;;;104        rt_object_init(&(mp->parent), RT_Object_Class_MemPool, name);
000004  460a              MOV      r2,r1
000006  461f              MOV      r7,r3                 ;96
000008  4604              MOV      r4,r0                 ;96
00000a  2106              MOVS     r1,#6
00000c  9d06              LDR      r5,[sp,#0x18]
00000e  f7fffffe          BL       rt_object_init
;;;105    
;;;106        /* initialize memory pool */
;;;107        mp->start_address = start;
;;;108        mp->size = RT_ALIGN_DOWN(size, RT_ALIGN_SIZE);
000012  1ced              ADDS     r5,r5,#3
;;;109    
;;;110        /* align the block size */
;;;111        block_size = RT_ALIGN(block_size, RT_ALIGN_SIZE);
000014  08a9              LSRS     r1,r5,#2
000016  0089              LSLS     r1,r1,#2
;;;112        mp->block_size = block_size;
000018  6166              STR      r6,[r4,#0x14]
00001a  08b8              LSRS     r0,r7,#2              ;108
00001c  61e1              STR      r1,[r4,#0x1c]
00001e  0080              LSLS     r0,r0,#2              ;108
000020  460d              MOV      r5,r1                 ;111
000022  61a0              STR      r0,[r4,#0x18]
000024  1d09              ADDS     r1,r1,#4
;;;113    
;;;114        /* align to align size byte */
;;;115        mp->block_total_count = mp->size / (mp->block_size + sizeof(rt_uint8_t *));
000026  f7fffffe          BL       __aeabi_uidivmod
;;;116        mp->block_free_count  = mp->block_total_count;
00002a  6260              STR      r0,[r4,#0x24]
;;;117    
;;;118        /* initialize suspended thread list */
;;;119        rt_list_init(&(mp->suspend_thread));
00002c  62a0              STR      r0,[r4,#0x28]
00002e  4620              MOV      r0,r4
000030  302c              ADDS     r0,r0,#0x2c
;;;120        mp->suspend_thread_count = 0;
000032  2600              MOVS     r6,#0
000034  6320              STR      r0,[r4,#0x30]
;;;121    
;;;122        /* initialize free block list */
;;;123        block_ptr = (rt_uint8_t *)mp->start_address;
000036  6366              STR      r6,[r4,#0x34]
000038  62e0              STR      r0,[r4,#0x2c]
;;;124        for (offset = 0; offset < mp->block_total_count; offset ++)
00003a  4632              MOV      r2,r6
00003c  1d29              ADDS     r1,r5,#4              ;115
00003e  6960              LDR      r0,[r4,#0x14]
000040  e006              B        |L7.80|
                  |L7.66|
;;;125        {
;;;126            *(rt_uint8_t **)(block_ptr + offset * (block_size + sizeof(rt_uint8_t *))) =
000042  1c53              ADDS     r3,r2,#1
000044  434b              MULS     r3,r1,r3
000046  4615              MOV      r5,r2
000048  181b              ADDS     r3,r3,r0
00004a  434d              MULS     r5,r1,r5
00004c  5143              STR      r3,[r0,r5]
00004e  1c52              ADDS     r2,r2,#1
                  |L7.80|
000050  6a63              LDR      r3,[r4,#0x24]         ;124
000052  4293              CMP      r3,r2                 ;124
000054  d8f5              BHI      |L7.66|
000056  1e52              SUBS     r2,r2,#1              ;124
;;;127                (rt_uint8_t *)(block_ptr + (offset + 1) * (block_size + sizeof(rt_uint8_t *)));
;;;128        }
;;;129    
;;;130        *(rt_uint8_t **)(block_ptr + (offset - 1) * (block_size + sizeof(rt_uint8_t *))) =
000058  434a              MULS     r2,r1,r2
00005a  5086              STR      r6,[r0,r2]
;;;131            RT_NULL;
;;;132    
;;;133        mp->block_list = block_ptr;
;;;134    
;;;135        return RT_EOK;
00005c  6220              STR      r0,[r4,#0x20]
00005e  2000              MOVS     r0,#0
;;;136    }
000060  bdf8              POP      {r3-r7,pc}
;;;137    RTM_EXPORT(rt_mp_init);
                          ENDP

