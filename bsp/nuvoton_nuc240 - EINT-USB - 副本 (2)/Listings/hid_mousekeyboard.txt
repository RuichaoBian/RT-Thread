; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\hid_mousekeyboard.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\hid_mousekeyboard.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I.\Libraries\Device\Nuvoton -I..\..\components\finsh -I.\Libraries\CMSIS\Include -I.\Libraries\StdDriver\inc -I..\..\include -I.\APP -I.\Drivers -I..\..\components\drivers\include -I..\..\components\drivers\include\drivers -I..\nuvoton_nuc240 -I.\Libraries\Device\Nuvoton\NUC230_240\Include -I..\..\include -I..\..\components\drivers\usb\usbdevice\class -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=521 --omf_browse=.\objects\hid_mousekeyboard.crf Libraries\StdDriver\src\hid_mousekeyboard.c]
                          THUMB

                          AREA ||i.EP2_Handler||, CODE, READONLY, ALIGN=2

                  EP2_Handler PROC
;;;135    
;;;136    void EP2_Handler(void)  /* Interrupt IN handler */
000000  4901              LDR      r1,|L1.8|
;;;137    {
;;;138        g_u8EP2Ready = 1;
000002  2001              MOVS     r0,#1
000004  7088              STRB     r0,[r1,#2]
;;;139    }
000006  4770              BX       lr
;;;140    
                          ENDP

                  |L1.8|
                          DCD      ||.data||

                          AREA ||i.EP3_Handler||, CODE, READONLY, ALIGN=2

                  EP3_Handler PROC
;;;140    
;;;141    void EP3_Handler(void)  /* Interrupt IN handler */
000000  4901              LDR      r1,|L2.8|
;;;142    {
;;;143        g_u8EP3Ready = 1;
000002  2001              MOVS     r0,#1
000004  70c8              STRB     r0,[r1,#3]
;;;144    }
000006  4770              BX       lr
;;;145    
                          ENDP

                  |L2.8|
                          DCD      ||.data||

                          AREA ||i.HID_ClassRequest||, CODE, READONLY, ALIGN=2

                  HID_ClassRequest PROC
;;;187    
;;;188    void HID_ClassRequest(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;189    {
;;;190        uint8_t buf[8];
;;;191    
;;;192        USBD_GetSetupPacket(buf);
000002  4668              MOV      r0,sp
000004  f7fffffe          BL       USBD_GetSetupPacket
;;;193    
;;;194        if (buf[0] & 0x80) { /* request data transfer direction */
000008  4668              MOV      r0,sp
00000a  7800              LDRB     r0,[r0,#0]
00000c  0600              LSLS     r0,r0,#24
00000e  d408              BMI      |L3.34|
;;;195            // Device to host
;;;196            switch (buf[1])
;;;197            {
;;;198                case GET_REPORT:
;;;199                case GET_IDLE:
;;;200                case GET_PROTOCOL:
;;;201                default:
;;;202                {
;;;203                    /* Setup error, stall the device */
;;;204                    USBD_SetStall(0);
;;;205                    break;
;;;206                }
;;;207            }
;;;208        }
;;;209        else {
;;;210            // Host to device
;;;211            switch (buf[1])
000010  4668              MOV      r0,sp
000012  7840              LDRB     r0,[r0,#1]
000014  2300              MOVS     r3,#0
;;;212            {
;;;213                case SET_REPORT: {
;;;214                    if (buf[3] == 3) {
;;;215                        /* Request Type = Feature */
;;;216                        USBD_SET_DATA1(EP1);
000016  4912              LDR      r1,|L3.96|
000018  2280              MOVS     r2,#0x80
00001a  2809              CMP      r0,#9                 ;211
00001c  d005              BEQ      |L3.42|
00001e  280a              CMP      r0,#0xa               ;211
000020  d019              BEQ      |L3.86|
                  |L3.34|
;;;217                        USBD_SET_PAYLOAD_LEN(EP1, 0);
;;;218                    }
;;;219                    else if(buf[3] == 2)
;;;220                    {
;;;221                        /* Request Type = Output */
;;;222                        USBD_SET_DATA1(EP1);
;;;223                        USBD_SET_PAYLOAD_LEN(EP1, buf[6]);
;;;224    
;;;225                        /* Status stage */
;;;226                        USBD_PrepareCtrlIn(0, 0);
;;;227                    }
;;;228                    break;
;;;229                }
;;;230                case SET_IDLE: {
;;;231                    /* Status stage */
;;;232                    USBD_SET_DATA1(EP0);
;;;233                    USBD_SET_PAYLOAD_LEN(EP0, 0);
;;;234                    break;
;;;235                }
;;;236                case SET_PROTOCOL:
;;;237    //          {
;;;238    //              break;
;;;239    //          }
;;;240                default: {
;;;241                    // Stall
;;;242                    /* Setup error, stall the device */
;;;243                    USBD_SetStall(0);
000022  2000              MOVS     r0,#0
000024  f7fffffe          BL       USBD_SetStall
                  |L3.40|
;;;244                    break;
;;;245                }
;;;246            }
;;;247        }
;;;248    }
000028  bd1c              POP      {r2-r4,pc}
                  |L3.42|
00002a  4668              MOV      r0,sp                 ;214
00002c  78c0              LDRB     r0,[r0,#3]            ;214
00002e  2803              CMP      r0,#3                 ;214
000030  d00c              BEQ      |L3.76|
000032  2802              CMP      r0,#2                 ;219
000034  d1f8              BNE      |L3.40|
000036  6988              LDR      r0,[r1,#0x18]         ;222
000038  4310              ORRS     r0,r0,r2              ;222
00003a  6188              STR      r0,[r1,#0x18]         ;222
00003c  4668              MOV      r0,sp                 ;223
00003e  7980              LDRB     r0,[r0,#6]            ;223
000040  6148              STR      r0,[r1,#0x14]         ;223
000042  2100              MOVS     r1,#0                 ;226
000044  4608              MOV      r0,r1                 ;226
000046  f7fffffe          BL       USBD_PrepareCtrlIn
00004a  bd1c              POP      {r2-r4,pc}
                  |L3.76|
00004c  6988              LDR      r0,[r1,#0x18]         ;216
00004e  4310              ORRS     r0,r0,r2              ;216
000050  6188              STR      r0,[r1,#0x18]         ;216
000052  614b              STR      r3,[r1,#0x14]         ;217
000054  bd1c              POP      {r2-r4,pc}
                  |L3.86|
000056  6888              LDR      r0,[r1,#8]            ;232
000058  4310              ORRS     r0,r0,r2              ;232
00005a  6088              STR      r0,[r1,#8]            ;232
00005c  604b              STR      r3,[r1,#4]            ;233
00005e  bd1c              POP      {r2-r4,pc}
;;;249    
                          ENDP

                  |L3.96|
                          DCD      0x40060500

                          AREA ||i.HID_Init||, CODE, READONLY, ALIGN=2

                  HID_Init PROC
;;;152      */
;;;153    void HID_Init(void)
000000  490c              LDR      r1,|L4.52|
;;;154    {
;;;155        /* Init setup packet buffer */
;;;156        /* Buffer range for setup packet -> [0 ~ 0x7] */
;;;157        USBD->STBUFSEG = SETUP_BUF_BASE;
000002  2000              MOVS     r0,#0
000004  6188              STR      r0,[r1,#0x18]
;;;158    
;;;159        /*****************************************************/
;;;160        /* EP0 ==> control IN endpoint, address 0 */
;;;161        USBD_CONFIG_EP(EP0, USBD_CFG_CSTALL | USBD_CFG_EPMODE_IN | 0);
000006  2109              MOVS     r1,#9
000008  480b              LDR      r0,|L4.56|
00000a  0189              LSLS     r1,r1,#6
00000c  6081              STR      r1,[r0,#8]
;;;162        /* Buffer range for EP0 */
;;;163        USBD_SET_EP_BUF_ADDR(EP0, EP0_BUF_BASE);
00000e  2108              MOVS     r1,#8
000010  6001              STR      r1,[r0,#0]
;;;164    
;;;165        /* EP1 ==> control OUT endpoint, address 0 */
;;;166        USBD_CONFIG_EP(EP1, USBD_CFG_CSTALL | USBD_CFG_EPMODE_OUT | 0);
000012  2211              MOVS     r2,#0x11
000014  0152              LSLS     r2,r2,#5
000016  6182              STR      r2,[r0,#0x18]
;;;167        /* Buffer range for EP1 */
;;;168        USBD_SET_EP_BUF_ADDR(EP1, EP1_BUF_BASE);
000018  6101              STR      r1,[r0,#0x10]
;;;169    
;;;170        /*****************************************************/
;;;171        /* EP2 ==> Interrupt IN endpoint, address 1 */
;;;172        USBD_CONFIG_EP(EP2, USBD_CFG_EPMODE_IN | HID_MOUSE_EP_NUM);
00001a  2141              MOVS     r1,#0x41
00001c  6281              STR      r1,[r0,#0x28]
;;;173        /* Buffer range for EP2 */
;;;174        USBD_SET_EP_BUF_ADDR(EP2, EP2_BUF_BASE);
00001e  2110              MOVS     r1,#0x10
000020  6201              STR      r1,[r0,#0x20]
;;;175    	
;;;176        /*****************************************************/
;;;177        /* EP3 ==> Interrupt IN endpoint, address 2 */
;;;178        USBD_CONFIG_EP(EP3, USBD_CFG_EPMODE_IN | HID_KB_EP_NUM);
000022  2142              MOVS     r1,#0x42
000024  6381              STR      r1,[r0,#0x38]
;;;179        /* Buffer range for EP3 */
;;;180        USBD_SET_EP_BUF_ADDR(EP3, EP3_BUF_BASE);
000026  2118              MOVS     r1,#0x18
000028  6301              STR      r1,[r0,#0x30]
;;;181    
;;;182        /* Start to send IN data */
;;;183        g_u8EP2Ready = 1;
00002a  4804              LDR      r0,|L4.60|
00002c  2101              MOVS     r1,#1
00002e  7081              STRB     r1,[r0,#2]
;;;184        g_u8EP3Ready = 1;
000030  70c1              STRB     r1,[r0,#3]
;;;185    
;;;186    }
000032  4770              BX       lr
;;;187    
                          ENDP

                  |L4.52|
                          DCD      0x40060000
                  |L4.56|
                          DCD      0x40060500
                  |L4.60|
                          DCD      ||.data||

                          AREA ||i.HID_UpdateKbData||, CODE, READONLY, ALIGN=2

                  HID_UpdateKbData PROC
;;;280    
;;;281    void HID_UpdateKbData(int num)
000000  b5f8              PUSH     {r3-r7,lr}
;;;282    {
;;;283        int32_t i;
;;;284        uint8_t *buf;
;;;285        uint32_t key = 0xF;
;;;286        static uint32_t preKey;
;;;287    		g_u8EP2Ready = 1;
000002  4b24              LDR      r3,|L5.148|
000004  2001              MOVS     r0,#1
000006  7098              STRB     r0,[r3,#2]
;;;288    		buf = (uint8_t *)(USBD_BUF_BASE + USBD_GET_EP_BUF_ADDR(EP3));
000008  4c23              LDR      r4,|L5.152|
00000a  6b20              LDR      r0,[r4,#0x30]
00000c  4f23              LDR      r7,|L5.156|
;;;289    	if(PE4 == 0)
00000e  4e24              LDR      r6,|L5.160|
000010  19c1              ADDS     r1,r0,r7              ;288
000012  6930              LDR      r0,[r6,#0x10]
;;;290    	{
;;;291    		preKey = PE4;
;;;292    		buf[2] = 0x05; /* Key 'b' */
;;;293    		//buf[3] = 0x15; /* Key 'r' */
;;;294    		//buf[4] = 0x06; /* Key 'c' */
;;;295    		//buf[5] = 0x23; /* Key '6' */
;;;296    		buf[3] = 0x58; /* Key enter */
;;;297    		USBD_SET_PAYLOAD_LEN(EP3, 8);
000014  2508              MOVS     r5,#8
000016  2200              MOVS     r2,#0
000018  2800              CMP      r0,#0                 ;289
;;;298    	}
;;;299    	else if(PE4 == 1)
00001a  6930              LDR      r0,[r6,#0x10]
00001c  d002              BEQ      |L5.36|
00001e  2801              CMP      r0,#1
000020  d006              BEQ      |L5.48|
000022  e00f              B        |L5.68|
                  |L5.36|
000024  6098              STR      r0,[r3,#8]            ;292  ; preKey
000026  2005              MOVS     r0,#5                 ;292
000028  7088              STRB     r0,[r1,#2]            ;292
00002a  2058              MOVS     r0,#0x58              ;296
00002c  70c8              STRB     r0,[r1,#3]            ;296
00002e  e008              B        |L5.66|
                  |L5.48|
;;;300    	{
;;;301    		for(i = 0; i < 8; i++)
000030  2000              MOVS     r0,#0
                  |L5.50|
;;;302        {
;;;303    			buf[i] = 0;
000032  540a              STRB     r2,[r1,r0]
000034  1c40              ADDS     r0,r0,#1
000036  2808              CMP      r0,#8                 ;301
000038  dbfb              BLT      |L5.50|
;;;304    		}
;;;305    		if(PE4 != preKey)
00003a  6930              LDR      r0,[r6,#0x10]
00003c  6899              LDR      r1,[r3,#8]  ; preKey
00003e  4288              CMP      r0,r1
000040  d000              BEQ      |L5.68|
                  |L5.66|
;;;306    			USBD_SET_PAYLOAD_LEN(EP3, 8);
000042  6365              STR      r5,[r4,#0x34]
                  |L5.68|
;;;307    	}
;;;308    		
;;;309    		
;;;310        if(g_u8EP3Ready == 0)
000044  4813              LDR      r0,|L5.148|
000046  78c0              LDRB     r0,[r0,#3]  ; g_u8EP3Ready
000048  2800              CMP      r0,#0
00004a  d121              BNE      |L5.144|
;;;311        {
;;;312            buf = (uint8_t *)(USBD_BUF_BASE + USBD_GET_EP_BUF_ADDR(EP3));
00004c  6b20              LDR      r0,[r4,#0x30]
00004e  19c6              ADDS     r6,r0,r7
;;;313    
;;;314            /* If PB.15 = 0, just report it is key 'a' */
;;;315            key = (PE->PIN & (1 << 4)) ? 0 : 1;
000050  4814              LDR      r0,|L5.164|
000052  6900              LDR      r0,[r0,#0x10]
000054  06c0              LSLS     r0,r0,#27
000056  17c7              ASRS     r7,r0,#31
000058  1c7f              ADDS     r7,r7,#1
;;;316    			  //key = 1;
;;;317            if(key == 0)    //按键没按下
00005a  d00f              BEQ      |L5.124|
;;;318            {
;;;319    					//rt_kprintf("USB_no\n");
;;;320                for(i = 0; i < 8; i++)
;;;321                {
;;;322                    buf[i] = 0;
;;;323                }
;;;324    
;;;325                if(key != preKey)
;;;326                {
;;;327                    /* Trigger to note key release */
;;;328                    USBD_SET_PAYLOAD_LEN(EP3, 8);
;;;329                }			
;;;330            }
;;;331            else
;;;332            {	
;;;333    					 rt_kprintf("USB_input\n");
00005c  a012              ADR      r0,|L5.168|
00005e  f7fffffe          BL       rt_kprintf
;;;334                preKey = key;
000062  480c              LDR      r0,|L5.148|
;;;335                buf[2] = 0x05; /* Key 'b' */
000064  6087              STR      r7,[r0,#8]  ; preKey
000066  2005              MOVS     r0,#5
000068  70b0              STRB     r0,[r6,#2]
;;;336    						buf[3] = 0x15; /* Key 'r' */
00006a  2015              MOVS     r0,#0x15
00006c  70f0              STRB     r0,[r6,#3]
;;;337    						buf[4] = 0x06; /* Key 'c' */
00006e  2006              MOVS     r0,#6
000070  7130              STRB     r0,[r6,#4]
;;;338    						buf[5] = 0x23; /* Key '6' */
000072  2023              MOVS     r0,#0x23
000074  7170              STRB     r0,[r6,#5]
;;;339    						//buf[6] = 0x23; /* Key '6' */
;;;340    						buf[6] = 0x58; /* Key enter */
000076  2058              MOVS     r0,#0x58
000078  71b0              STRB     r0,[r6,#6]
;;;341                USBD_SET_PAYLOAD_LEN(EP3, 8);
00007a  e008              B        |L5.142|
                  |L5.124|
00007c  2000              MOVS     r0,#0                 ;320
                  |L5.126|
00007e  5432              STRB     r2,[r6,r0]            ;322
000080  1c40              ADDS     r0,r0,#1              ;322
000082  2808              CMP      r0,#8                 ;320
000084  dbfb              BLT      |L5.126|
000086  4803              LDR      r0,|L5.148|
000088  6880              LDR      r0,[r0,#8]            ;325  ; preKey
00008a  4287              CMP      r7,r0                 ;325
00008c  d000              BEQ      |L5.144|
                  |L5.142|
00008e  6365              STR      r5,[r4,#0x34]         ;328
                  |L5.144|
;;;342            }
;;;343    				
;;;344        }
;;;345    }
000090  bdf8              POP      {r3-r7,pc}
                          ENDP

000092  0000              DCW      0x0000
                  |L5.148|
                          DCD      ||.data||
                  |L5.152|
                          DCD      0x40060500
                  |L5.156|
                          DCD      0x40060100
                  |L5.160|
                          DCD      0x50004300
                  |L5.164|
                          DCD      0x50004100
                  |L5.168|
0000a8  5553425f          DCB      "USB_input\n",0
0000ac  696e7075
0000b0  740a00  
0000b3  00                DCB      0

                          AREA ||i.HID_UpdateMouseData||, CODE, READONLY, ALIGN=2

                  HID_UpdateMouseData PROC
;;;249    
;;;250    void HID_UpdateMouseData(void)
000000  b570              PUSH     {r4-r6,lr}
;;;251    {
;;;252        uint8_t *buf;
;;;253    
;;;254        if (g_u8EP2Ready) {
000002  4a17              LDR      r2,|L6.96|
000004  7890              LDRB     r0,[r2,#2]  ; g_u8EP2Ready
000006  2800              CMP      r0,#0
000008  d029              BEQ      |L6.94|
;;;255            buf = (uint8_t *)(USBD_BUF_BASE + USBD_GET_EP_BUF_ADDR(EP2));
00000a  4e16              LDR      r6,|L6.100|
00000c  6a30              LDR      r0,[r6,#0x20]
00000e  4916              LDR      r1,|L6.104|
;;;256            mouse_mode ^= 1;
000010  2301              MOVS     r3,#1
000012  1840              ADDS     r0,r0,r1              ;255
000014  7851              LDRB     r1,[r2,#1]  ; mouse_mode
000016  4059              EORS     r1,r1,r3
000018  2300              MOVS     r3,#0
00001a  7051              STRB     r1,[r2,#1]
;;;257    
;;;258            if (mouse_mode) {
00001c  2900              CMP      r1,#0
00001e  d014              BEQ      |L6.74|
;;;259                if (move_len > 14) {
000020  7911              LDRB     r1,[r2,#4]  ; move_len
000022  290e              CMP      r1,#0xe
000024  d915              BLS      |L6.82|
;;;260                    /* Update new report data */
;;;261                    buf[0] = 0x00;
000026  7003              STRB     r3,[r0,#0]
;;;262                    buf[1] = mouse_table[mouse_idx & 0x07];
000028  7811              LDRB     r1,[r2,#0]  ; mouse_idx
00002a  4615              MOV      r5,r2
00002c  074c              LSLS     r4,r1,#29
00002e  0f64              LSRS     r4,r4,#29
000030  350c              ADDS     r5,r5,#0xc
000032  5d2c              LDRB     r4,[r5,r4]
000034  7044              STRB     r4,[r0,#1]
;;;263                    buf[2] = mouse_table[(mouse_idx + 2) & 0x07];
000036  1c8c              ADDS     r4,r1,#2
000038  0764              LSLS     r4,r4,#29
00003a  0f64              LSRS     r4,r4,#29
00003c  5d2c              LDRB     r4,[r5,r4]
00003e  7084              STRB     r4,[r0,#2]
;;;264                    buf[3] = 0x00;
000040  70c3              STRB     r3,[r0,#3]
000042  1c49              ADDS     r1,r1,#1
;;;265                    mouse_idx++;
000044  7011              STRB     r1,[r2,#0]
;;;266                    move_len = 0;
000046  7113              STRB     r3,[r2,#4]
000048  e003              B        |L6.82|
                  |L6.74|
;;;267                }
;;;268            }
;;;269            else {
;;;270                buf[0] = buf[1] = buf[2] = buf[3] = 0;
00004a  70c3              STRB     r3,[r0,#3]
00004c  7083              STRB     r3,[r0,#2]
00004e  7043              STRB     r3,[r0,#1]
000050  7003              STRB     r3,[r0,#0]
                  |L6.82|
;;;271            }
;;;272            move_len++;
000052  7910              LDRB     r0,[r2,#4]  ; move_len
000054  1c40              ADDS     r0,r0,#1
000056  7110              STRB     r0,[r2,#4]
;;;273            g_u8EP2Ready = 0;
000058  7093              STRB     r3,[r2,#2]
;;;274            /* Set transfer length and trigger IN transfer */
;;;275            USBD_SET_PAYLOAD_LEN(EP2, 4);
00005a  2004              MOVS     r0,#4
00005c  6270              STR      r0,[r6,#0x24]
                  |L6.94|
;;;276        }
;;;277    }
00005e  bd70              POP      {r4-r6,pc}
;;;278    
                          ENDP

                  |L6.96|
                          DCD      ||.data||
                  |L6.100|
                          DCD      0x40060500
                  |L6.104|
                          DCD      0x40060100

                          AREA ||i.USBD_IRQHandler||, CODE, READONLY, ALIGN=2

                  USBD_IRQHandler PROC
;;;22     
;;;23     void USBD_IRQHandler(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;24     {
;;;25     	
;;;26         uint32_t u32IntSts;
;;;27         uint32_t u32State;
;;;28     		rt_interrupt_enter();
000002  f7fffffe          BL       rt_interrupt_enter
;;;29     		u32IntSts = USBD_GET_INT_FLAG();
000006  4d37              LDR      r5,|L7.228|
000008  686c              LDR      r4,[r5,#4]
;;;30     		u32State = USBD_GET_BUS_STATE();
00000a  6928              LDR      r0,[r5,#0x10]
00000c  0706              LSLS     r6,r0,#28
00000e  0f36              LSRS     r6,r6,#28
;;;31     //------------------------------------------------------------------
;;;32         if (u32IntSts & USBD_INTSTS_FLDET) {
000010  0760              LSLS     r0,r4,#29
000012  d50b              BPL      |L7.44|
;;;33             // Floating detect
;;;34             USBD_CLR_INT_FLAG(USBD_INTSTS_FLDET);
000014  2004              MOVS     r0,#4
000016  6068              STR      r0,[r5,#4]
;;;35     
;;;36             if (USBD_IS_ATTACHED()) {
000018  6968              LDR      r0,[r5,#0x14]
00001a  07c0              LSLS     r0,r0,#31
;;;37                 /* USB Plug In */
;;;38                 USBD_ENABLE_USB();
;;;39             }
;;;40             else {
;;;41                 /* USB Un-plug */
;;;42                 USBD_DISABLE_USB();
00001c  6928              LDR      r0,[r5,#0x10]
00001e  d002              BEQ      |L7.38|
000020  2190              MOVS     r1,#0x90              ;38
000022  4308              ORRS     r0,r0,r1              ;38
000024  e001              B        |L7.42|
                  |L7.38|
000026  2180              MOVS     r1,#0x80
000028  4388              BICS     r0,r0,r1
                  |L7.42|
00002a  6128              STR      r0,[r5,#0x10]         ;38
                  |L7.44|
;;;43             }
;;;44         }
;;;45     
;;;46     //------------------------------------------------------------------
;;;47         if (u32IntSts & USBD_INTSTS_BUS) {
00002c  07e0              LSLS     r0,r4,#31
;;;48             /* Clear event flag */
;;;49             USBD_CLR_INT_FLAG(USBD_INTSTS_BUS);
00002e  2701              MOVS     r7,#1
000030  2800              CMP      r0,#0                 ;47
000032  d014              BEQ      |L7.94|
000034  606f              STR      r7,[r5,#4]
;;;50     
;;;51             if (u32State & USBD_STATE_USBRST) {
000036  07f0              LSLS     r0,r6,#31
000038  d005              BEQ      |L7.70|
;;;52                 /* Bus reset */
;;;53                 USBD_ENABLE_USB();
00003a  6928              LDR      r0,[r5,#0x10]
00003c  2190              MOVS     r1,#0x90
00003e  4308              ORRS     r0,r0,r1
000040  6128              STR      r0,[r5,#0x10]
;;;54                 USBD_SwReset();
000042  f7fffffe          BL       USBD_SwReset
                  |L7.70|
;;;55             }
;;;56             if (u32State & USBD_STATE_SUSPEND) {
000046  07b0              LSLS     r0,r6,#30
000048  d503              BPL      |L7.82|
;;;57                 /* Enable USB but disable PHY */
;;;58                 USBD_DISABLE_PHY();
00004a  6928              LDR      r0,[r5,#0x10]
00004c  2110              MOVS     r1,#0x10
00004e  4388              BICS     r0,r0,r1
000050  6128              STR      r0,[r5,#0x10]
                  |L7.82|
;;;59             }
;;;60             if (u32State & USBD_STATE_RESUME) {
000052  0770              LSLS     r0,r6,#29
000054  d503              BPL      |L7.94|
;;;61                 /* Enable USB and enable PHY */
;;;62                 USBD_ENABLE_USB();
000056  6928              LDR      r0,[r5,#0x10]
000058  2190              MOVS     r1,#0x90
00005a  4308              ORRS     r0,r0,r1
00005c  6128              STR      r0,[r5,#0x10]
                  |L7.94|
;;;63             }
;;;64         }
;;;65     
;;;66     //------------------------------------------------------------------
;;;67         if (u32IntSts & USBD_INTSTS_USB) {
00005e  07a0              LSLS     r0,r4,#30
000060  d53c              BPL      |L7.220|
;;;68             // USB event
;;;69             if (u32IntSts & USBD_INTSTS_SETUP) {
000062  2c00              CMP      r4,#0
000064  da0b              BGE      |L7.126|
;;;70                 // Setup packet
;;;71                 /* Clear event flag */
;;;72                 USBD_CLR_INT_FLAG(USBD_INTSTS_SETUP);
000066  2001              MOVS     r0,#1
000068  07c0              LSLS     r0,r0,#31
00006a  6068              STR      r0,[r5,#4]
;;;73     
;;;74                 /* Clear the data IN/OUT ready flag of control end-points */
;;;75                 USBD_STOP_TRANSACTION(EP0);
00006c  481e              LDR      r0,|L7.232|
00006e  68c1              LDR      r1,[r0,#0xc]
000070  4339              ORRS     r1,r1,r7
000072  60c1              STR      r1,[r0,#0xc]
;;;76                 USBD_STOP_TRANSACTION(EP1);
000074  69c1              LDR      r1,[r0,#0x1c]
000076  4339              ORRS     r1,r1,r7
000078  61c1              STR      r1,[r0,#0x1c]
;;;77     
;;;78                 USBD_ProcessSetupPacket();
00007a  f7fffffe          BL       USBD_ProcessSetupPacket
                  |L7.126|
;;;79             }
;;;80     
;;;81             // EP events
;;;82             if (u32IntSts & USBD_INTSTS_EP0) {
00007e  03e0              LSLS     r0,r4,#15
000080  d504              BPL      |L7.140|
;;;83                 /* Clear event flag */
;;;84                 USBD_CLR_INT_FLAG(USBD_INTSTS_EP0);
000082  2001              MOVS     r0,#1
000084  0400              LSLS     r0,r0,#16
000086  6068              STR      r0,[r5,#4]
;;;85                 // control IN
;;;86                 USBD_CtrlIn();
000088  f7fffffe          BL       USBD_CtrlIn
                  |L7.140|
;;;87             }
;;;88     
;;;89             if (u32IntSts & USBD_INTSTS_EP1) {
00008c  03a0              LSLS     r0,r4,#14
00008e  d504              BPL      |L7.154|
;;;90                 /* Clear event flag */
;;;91                 USBD_CLR_INT_FLAG(USBD_INTSTS_EP1);
000090  2001              MOVS     r0,#1
000092  0440              LSLS     r0,r0,#17
000094  6068              STR      r0,[r5,#4]
;;;92     
;;;93                 // control OUT
;;;94                 USBD_CtrlOut();
000096  f7fffffe          BL       USBD_CtrlOut
                  |L7.154|
00009a  4814              LDR      r0,|L7.236|
;;;95             }
;;;96     
;;;97             if (u32IntSts & USBD_INTSTS_EP2) {
00009c  0361              LSLS     r1,r4,#13
00009e  d503              BPL      |L7.168|
;;;98                 /* Clear event flag */
;;;99                 USBD_CLR_INT_FLAG(USBD_INTSTS_EP2);
0000a0  2101              MOVS     r1,#1
0000a2  0489              LSLS     r1,r1,#18
0000a4  6069              STR      r1,[r5,#4]
0000a6  7087              STRB     r7,[r0,#2]
                  |L7.168|
;;;100                // Interrupt IN
;;;101                EP2_Handler();
;;;102            }
;;;103    
;;;104            if (u32IntSts & USBD_INTSTS_EP3) {
0000a8  0321              LSLS     r1,r4,#12
0000aa  d503              BPL      |L7.180|
;;;105                /* Clear event flag */
;;;106                USBD_CLR_INT_FLAG(USBD_INTSTS_EP3);
0000ac  2101              MOVS     r1,#1
0000ae  04c9              LSLS     r1,r1,#19
0000b0  6069              STR      r1,[r5,#4]
0000b2  70c7              STRB     r7,[r0,#3]
                  |L7.180|
;;;107                // Interrupt IN
;;;108                EP3_Handler();
;;;109            }
;;;110    
;;;111            if (u32IntSts & USBD_INTSTS_EP4) {
0000b4  02e0              LSLS     r0,r4,#11
0000b6  d502              BPL      |L7.190|
;;;112                /* Clear event flag */
;;;113                USBD_CLR_INT_FLAG(USBD_INTSTS_EP4);
0000b8  2001              MOVS     r0,#1
0000ba  0500              LSLS     r0,r0,#20
0000bc  6068              STR      r0,[r5,#4]
                  |L7.190|
;;;114            }
;;;115    
;;;116            if (u32IntSts & USBD_INTSTS_EP5) {
0000be  02a0              LSLS     r0,r4,#10
0000c0  d502              BPL      |L7.200|
;;;117                /* Clear event flag */
;;;118                USBD_CLR_INT_FLAG(USBD_INTSTS_EP5);
0000c2  2001              MOVS     r0,#1
0000c4  0540              LSLS     r0,r0,#21
0000c6  6068              STR      r0,[r5,#4]
                  |L7.200|
;;;119            }
;;;120    
;;;121            if (u32IntSts & USBD_INTSTS_EP6) {
0000c8  0260              LSLS     r0,r4,#9
0000ca  d502              BPL      |L7.210|
;;;122                /* Clear event flag */
;;;123                USBD_CLR_INT_FLAG(USBD_INTSTS_EP6);
0000cc  2001              MOVS     r0,#1
0000ce  0580              LSLS     r0,r0,#22
0000d0  6068              STR      r0,[r5,#4]
                  |L7.210|
;;;124            }
;;;125    
;;;126            if (u32IntSts & USBD_INTSTS_EP7) {
0000d2  0220              LSLS     r0,r4,#8
0000d4  d502              BPL      |L7.220|
;;;127                /* Clear event flag */
;;;128                USBD_CLR_INT_FLAG(USBD_INTSTS_EP7);
0000d6  2001              MOVS     r0,#1
0000d8  05c0              LSLS     r0,r0,#23
0000da  6068              STR      r0,[r5,#4]
                  |L7.220|
;;;129            }
;;;130        }
;;;131        /* clear unknown event */
;;;132        USBD_CLR_INT_FLAG(u32IntSts);
0000dc  606c              STR      r4,[r5,#4]
;;;133    		rt_interrupt_leave();
0000de  f7fffffe          BL       rt_interrupt_leave
;;;134    }
0000e2  bdf8              POP      {r3-r7,pc}
;;;135    
                          ENDP

                  |L7.228|
                          DCD      0x40060000
                  |L7.232|
                          DCD      0x40060500
                  |L7.236|
                          DCD      ||.data||

                          AREA ||i.USBD_SetStall||, CODE, READONLY, ALIGN=2

                  USBD_SetStall PROC
;;;545      */
;;;546    static __INLINE void USBD_SetStall(uint8_t epnum)
000000  4b0a              LDR      r3,|L8.44|
;;;547    {
;;;548        uint32_t u32CfgAddr;
;;;549        uint32_t u32Cfg;
;;;550        int i;
;;;551    
;;;552        for(i = 0; i < USBD_MAX_EP; i++)
000002  2100              MOVS     r1,#0
                  |L8.4|
;;;553        {
;;;554            u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&USBD->EP[0].CFG; /* USBD_CFG0 */
000004  010a              LSLS     r2,r1,#4
000006  18d2              ADDS     r2,r2,r3
;;;555            u32Cfg = *((__IO uint32_t *)(u32CfgAddr));
000008  6812              LDR      r2,[r2,#0]
;;;556    
;;;557            if((u32Cfg & 0xf) == epnum)
00000a  0712              LSLS     r2,r2,#28
00000c  0f12              LSRS     r2,r2,#28
00000e  4282              CMP      r2,r0
000010  d108              BNE      |L8.36|
;;;558            {
;;;559                u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&USBD->EP[0].CFGP; /* USBD_CFGP0 */
000012  0108              LSLS     r0,r1,#4
000014  4905              LDR      r1,|L8.44|
000016  1d09              ADDS     r1,r1,#4
000018  1840              ADDS     r0,r0,r1
;;;560                u32Cfg = *((__IO uint32_t *)(u32CfgAddr));
00001a  6801              LDR      r1,[r0,#0]
;;;561    
;;;562                *((__IO uint32_t *)(u32CfgAddr)) = (u32Cfg | USBD_CFGP_SSTALL);
00001c  2202              MOVS     r2,#2
00001e  4311              ORRS     r1,r1,r2
000020  6001              STR      r1,[r0,#0]
;;;563                break;
;;;564            }
;;;565        }
;;;566    }
000022  4770              BX       lr
                  |L8.36|
000024  1c49              ADDS     r1,r1,#1
000026  2908              CMP      r1,#8                 ;552
000028  dbec              BLT      |L8.4|
00002a  4770              BX       lr
;;;567    
                          ENDP

                  |L8.44|
                          DCD      0x40060508

                          AREA ||.data||, DATA, ALIGN=2

                  mouse_idx
000000  00                DCB      0x00
                  mouse_mode
000001  01                DCB      0x01
                  g_u8EP2Ready
000002  00                DCB      0x00
                  g_u8EP3Ready
000003  00                DCB      0x00
                  move_len
000004  00000000          DCB      0x00,0x00,0x00,0x00
                  preKey
                          DCD      0x00000000
                  mouse_table
00000c  f0f0f000          DCB      0xf0,0xf0,0xf0,0x00
000010  10101000          DCB      0x10,0x10,0x10,0x00

;*** Start embedded assembler ***

#line 1 "Libraries\\StdDriver\\src\\hid_mousekeyboard.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_hid_mousekeyboard_c_5c9d84fc____REV16|
#line 118 ".\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___19_hid_mousekeyboard_c_5c9d84fc____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_hid_mousekeyboard_c_5c9d84fc____REVSH|
#line 132
|__asm___19_hid_mousekeyboard_c_5c9d84fc____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
