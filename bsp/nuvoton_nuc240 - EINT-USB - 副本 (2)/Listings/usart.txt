; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\usart.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\usart.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I.\Libraries\Device\Nuvoton -I..\..\components\finsh -I.\Libraries\CMSIS\Include -I.\Libraries\StdDriver\inc -I..\..\include -I.\APP -I.\Drivers -I..\..\components\drivers\include -I..\..\components\drivers\include\drivers -I..\nuvoton_nuc240 -I.\Libraries\Device\Nuvoton\NUC230_240\Include -I..\..\include -I..\..\components\drivers\usb\usbdevice\class -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=521 --omf_browse=.\objects\usart.crf Drivers\usart.c]
                          THUMB

                          AREA ||i.UART02_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART02_IRQHandler PROC
;;;98     uint16_t i;
;;;99     void UART02_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;100    {
;;;101    	
;;;102    	/*******************************************************/
;;;103    	uint8_t u8InChar = 0xFF;
;;;104        /* enter interrupt */
;;;105        rt_interrupt_enter();
000002  f7fffffe          BL       rt_interrupt_enter
;;;106    		UART_ClearIntFlag(UART0 , UART_IER_RDA_IEN_Msk);
000006  2101              MOVS     r1,#1
000008  4814              LDR      r0,|L1.92|
00000a  f7fffffe          BL       UART_ClearIntFlag
;;;107    	
;;;108    		u8InChar = nuc240_getc(&serial0);	
00000e  4814              LDR      r0,|L1.96|
000010  f7fffffe          BL       nuc240_getc
;;;109    		 if(num>=80)
000014  4c13              LDR      r4,|L1.100|
000016  b2c1              UXTB     r1,r0                 ;108
000018  8820              LDRH     r0,[r4,#0]  ; num
00001a  2500              MOVS     r5,#0
00001c  2850              CMP      r0,#0x50
00001e  d304              BCC      |L1.42|
;;;110    			 {
;;;111    			  nuc240_putc(&serial0, 'E');
000020  2145              MOVS     r1,#0x45
000022  480f              LDR      r0,|L1.96|
000024  f7fffffe          BL       nuc240_putc
;;;112    				num=0;
000028  e016              B        |L1.88|
                  |L1.42|
;;;113    			 }
;;;114    			else if(u8InChar=='\n')
;;;115    			 {
;;;116    				i=0;
;;;117    				while(i!=num) 
;;;118    				{
;;;119    				nuc240_putc(&serial0, rev_buf[i]);
00002a  4e0d              LDR      r6,|L1.96|
00002c  3e50              SUBS     r6,r6,#0x50
00002e  290a              CMP      r1,#0xa               ;114
000030  d005              BEQ      |L1.62|
;;;120    				i++;
;;;121    				}
;;;122    				num=0;
;;;123    			 }		
;;;124    		 else
;;;125    		 rev_buf[num++] =u8InChar;      
000032  5431              STRB     r1,[r6,r0]
000034  1c40              ADDS     r0,r0,#1
000036  8020              STRH     r0,[r4,#0]
                  |L1.56|
;;;126    /***************************************
;;;127    		 
;;;128    							R C
;;;129    		 
;;;130    ******************************************/		 
;;;131       // if (UART_IS_RX_READY(UART0)) {
;;;132         //   rt_hw_serial_isr(&serial0, RT_SERIAL_EVENT_RX_IND);
;;;133       // }
;;;134        /* leave interrupt */
;;;135        rt_interrupt_leave();
000038  f7fffffe          BL       rt_interrupt_leave
;;;136    }
00003c  bd70              POP      {r4-r6,pc}
                  |L1.62|
00003e  8065              STRH     r5,[r4,#2]            ;116
000040  e006              B        |L1.80|
                  |L1.66|
000042  5c31              LDRB     r1,[r6,r0]            ;119
000044  4806              LDR      r0,|L1.96|
000046  f7fffffe          BL       nuc240_putc
00004a  8860              LDRH     r0,[r4,#2]            ;120  ; i
00004c  1c40              ADDS     r0,r0,#1              ;120
00004e  8060              STRH     r0,[r4,#2]            ;120
                  |L1.80|
000050  8860              LDRH     r0,[r4,#2]            ;117  ; i
000052  8821              LDRH     r1,[r4,#0]            ;117  ; num
000054  4288              CMP      r0,r1                 ;117
000056  d1f4              BNE      |L1.66|
                  |L1.88|
000058  8025              STRH     r5,[r4,#0]            ;122
00005a  e7ed              B        |L1.56|
;;;137    #endif /* RT_USING_UART0 */
                          ENDP

                  |L1.92|
                          DCD      0x40050000
                  |L1.96|
                          DCD      ||.bss||+0x50
                  |L1.100|
                          DCD      ||.data||

                          AREA ||i.nuc240_configure||, CODE, READONLY, ALIGN=2

                  nuc240_configure PROC
;;;11     
;;;12     static rt_err_t nuc240_configure(struct rt_serial_device *serial,struct serial_configure *cfg)
000000  b570              PUSH     {r4-r6,lr}
;;;13     {
;;;14     	UART_T* uart;
;;;15     	
;;;16     	uart = (UART_T*)serial->parent.user_data;
;;;17     #if defined(RT_USING_UART0)
;;;18     	if(uart == UART0){
000002  4c12              LDR      r4,|L2.76|
000004  6bc2              LDR      r2,[r0,#0x3c]
000006  460d              MOV      r5,r1                 ;13
000008  42a2              CMP      r2,r4
00000a  d11d              BNE      |L2.72|
;;;19     		//enable clock
;;;20     		CLK_EnableModuleClock(UART0_MODULE);
00000c  4e10              LDR      r6,|L2.80|
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       CLK_EnableModuleClock
;;;21     		/* Select UART module clock source */
;;;22         CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART_S_PLL, CLK_CLKDIV_UART(1));
000014  2101              MOVS     r1,#1
000016  2200              MOVS     r2,#0
000018  0609              LSLS     r1,r1,#24
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       CLK_SetModuleClock
;;;23     		
;;;24     		/* Set GPB multi-function pins for UART0 RXD and TXD */
;;;25         SYS->GPB_MFP &= ~(SYS_GPB_MFP_PB0_Msk | SYS_GPB_MFP_PB1_Msk);
000020  0322              LSLS     r2,r4,#12
000022  6b50              LDR      r0,[r2,#0x34]
000024  0880              LSRS     r0,r0,#2
000026  0080              LSLS     r0,r0,#2
000028  6350              STR      r0,[r2,#0x34]
;;;26     
;;;27         SYS->GPB_MFP |= (SYS_GPB_MFP_PB0_UART0_RXD | SYS_GPB_MFP_PB1_UART0_TXD);
00002a  6b50              LDR      r0,[r2,#0x34]
00002c  2103              MOVS     r1,#3
00002e  4308              ORRS     r0,r0,r1
000030  6350              STR      r0,[r2,#0x34]
;;;28     		
;;;29     		 /* Reset UART0 module */
;;;30         SYS_ResetModule(UART0_RST);
000032  4808              LDR      r0,|L2.84|
000034  f7fffffe          BL       SYS_ResetModule
;;;31     
;;;32         /* Configure UART0 and set UART0 Baudrate */
;;;33         UART_Open(UART0, cfg->baud_rate);
000038  4620              MOV      r0,r4
00003a  6829              LDR      r1,[r5,#0]
00003c  f7fffffe          BL       UART_Open
;;;34     		
;;;35     	  /* Enable Interrupt */
;;;36         UART_EnableInt(UART0, UART_IER_RDA_IEN_Msk);
000040  2101              MOVS     r1,#1
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       UART_EnableInt
                  |L2.72|
;;;37     	}
;;;38     #endif
;;;39     
;;;40     	return RT_EOK;
000048  2000              MOVS     r0,#0
;;;41     }
00004a  bd70              POP      {r4-r6,pc}
;;;42     
                          ENDP

                  |L2.76|
                          DCD      0x40050000
                  |L2.80|
                          DCD      0x57803d10
                  |L2.84|
                          DCD      0x04000010

                          AREA ||i.nuc240_control||, CODE, READONLY, ALIGN=1

                  nuc240_control PROC
;;;42     
;;;43     static rt_err_t nuc240_control(struct rt_serial_device *serial,int cmd,void *arg){
000000  b510              PUSH     {r4,lr}
;;;44     	UART_T* uart;
;;;45     	uart = (UART_T *)serial->parent.user_data;
000002  6bc0              LDR      r0,[r0,#0x3c]
;;;46     	
;;;47     	switch(cmd)
000004  2910              CMP      r1,#0x10
000006  d005              BEQ      |L3.20|
000008  2911              CMP      r1,#0x11
00000a  d106              BNE      |L3.26|
;;;48     	{
;;;49     		case RT_DEVICE_CTRL_CLR_INT:{
;;;50     			//disable interrupt
;;;51     			UART_DisableInt(uart,UART_IER_RDA_IEN_Msk);
00000c  2101              MOVS     r1,#1
00000e  f7fffffe          BL       UART_DisableInt
;;;52     			break;
000012  e002              B        |L3.26|
                  |L3.20|
;;;53     		}
;;;54     		case RT_DEVICE_CTRL_SET_INT:{
;;;55     			UART_EnableInt(uart,UART_IER_RDA_IEN_Msk);
000014  2101              MOVS     r1,#1
000016  f7fffffe          BL       UART_EnableInt
                  |L3.26|
;;;56     			break;
;;;57     		}
;;;58     	}
;;;59     	return RT_EOK;
00001a  2000              MOVS     r0,#0
;;;60     }
00001c  bd10              POP      {r4,pc}
;;;61     
                          ENDP


                          AREA ||i.nuc240_getc||, CODE, READONLY, ALIGN=1

                  nuc240_getc PROC
;;;74     
;;;75     static int nuc240_getc(struct rt_serial_device *serial)
000000  4601              MOV      r1,r0
;;;76     {
;;;77         int ch = -1;
;;;78         UART_T* uart;
;;;79         uart = (UART_T *)serial->parent.user_data;
000002  6bc9              LDR      r1,[r1,#0x3c]
000004  2000              MOVS     r0,#0                 ;77
;;;80     
;;;81         if (UART_IS_RX_READY(uart))
000006  69ca              LDR      r2,[r1,#0x1c]
000008  43c0              MVNS     r0,r0                 ;77
00000a  07d2              LSLS     r2,r2,#31
00000c  d000              BEQ      |L4.16|
;;;82             ch = UART_READ(uart);
00000e  6808              LDR      r0,[r1,#0]
                  |L4.16|
;;;83         return ch;
;;;84     }
000010  4770              BX       lr
;;;85     
                          ENDP


                          AREA ||i.nuc240_putc||, CODE, READONLY, ALIGN=1

                  nuc240_putc PROC
;;;62     
;;;63     static int nuc240_putc(struct rt_serial_device *serial, char c)
000000  6bc0              LDR      r0,[r0,#0x3c]
;;;64     {
;;;65         UART_T* uart;
;;;66         uart = (UART_T *)serial->parent.user_data;
;;;67         if (UART_IS_TX_FULL(uart)) {
000002  6982              LDR      r2,[r0,#0x18]
000004  0212              LSLS     r2,r2,#8
000006  d502              BPL      |L5.14|
                  |L5.8|
;;;68             UART_WAIT_TX_EMPTY(uart);
000008  6982              LDR      r2,[r0,#0x18]
00000a  00d2              LSLS     r2,r2,#3
00000c  d5fc              BPL      |L5.8|
                  |L5.14|
;;;69             
;;;70         }
;;;71         UART_WRITE(uart, c);
00000e  6001              STR      r1,[r0,#0]
;;;72         return 1;
000010  2001              MOVS     r0,#1
;;;73     }
000012  4770              BX       lr
;;;74     
                          ENDP


                          AREA ||i.rt_hw_usart_init||, CODE, READONLY, ALIGN=2

                  rt_hw_usart_init PROC
;;;138    
;;;139    void rt_hw_usart_init(void)
000000  b510              PUSH     {r4,lr}
;;;140    {
;;;141    #ifdef RT_USING_UART0
;;;142        struct serial_configure config = RT_SERIAL_CONFIG_DEFAULT;//配置串口波特率等一些配置
000002  4809              LDR      r0,|L6.40|
;;;143        config.baud_rate = BAUD_RATE_115200;
;;;144        serial0.ops    = &NUC240_uart_ops;     //
000004  4b09              LDR      r3,|L6.44|
000006  6842              LDR      r2,[r0,#4]  ; <Data2>
000008  3008              ADDS     r0,r0,#8
;;;145        serial0.config = config;
00000a  6418              STR      r0,[r3,#0x40]  ; serial0
00000c  4618              MOV      r0,r3
00000e  3030              ADDS     r0,r0,#0x30
;;;146    
;;;147        /* register UART0 device */
;;;148        rt_hw_serial_register(&serial0, "uart0",
000010  6182              STR      r2,[r0,#0x18]  ; serial0
000012  21e1              MOVS     r1,#0xe1              ;143
000014  0249              LSLS     r1,r1,#9              ;143
000016  6141              STR      r1,[r0,#0x14]  ; serial0
000018  22ff              MOVS     r2,#0xff
00001a  4b05              LDR      r3,|L6.48|
00001c  3204              ADDS     r2,#4
00001e  a105              ADR      r1,|L6.52|
000020  3830              SUBS     r0,r0,#0x30
000022  f7fffffe          BL       rt_hw_serial_register
;;;149                              RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_INT_RX,
;;;150                              UART0);
;;;151    #endif /* RT_USING_UART0 */
;;;152     return;
;;;153    }
000026  bd10              POP      {r4,pc}
;;;154    
                          ENDP

                  |L6.40|
                          DCD      ||.constdata||
                  |L6.44|
                          DCD      ||.bss||+0x50
                  |L6.48|
                          DCD      0x40050000
                  |L6.52|
000034  75617274          DCB      "uart0",0
000038  3000    
00003a  00                DCB      0
00003b  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  rev_buf
                          %        80
                  serial0
                          %        84

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x0001c200
000004  08000100          DCB      0x08,0x00,0x01,0x00
                  NUC240_uart_ops
                          DCD      nuc240_configure
                          DCD      nuc240_control
                          DCD      nuc240_putc
                          DCD      nuc240_getc
                          DCD      0x00000000

                          AREA ||.data||, DATA, ALIGN=1

                  num
000000  0000              DCB      0x00,0x00
                  i
000002  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "Drivers\\usart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_usart_c_9d14be4d____REV16|
#line 118 ".\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___7_usart_c_9d14be4d____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_usart_c_9d14be4d____REVSH|
#line 132
|__asm___7_usart_c_9d14be4d____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
