; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\mem.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\mem.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I.\Libraries\Device\Nuvoton -I..\..\components\finsh -I.\Libraries\CMSIS\Include -I.\Libraries\StdDriver\inc -I..\..\include -I.\APP -I.\Drivers -I..\..\components\drivers\include -I..\..\components\drivers\include\drivers -I..\nuvoton_nuc240 -I.\Libraries\Device\Nuvoton\NUC230_240\Include -I..\..\include -I..\..\components\drivers\usb\usbdevice\class -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=521 --omf_browse=.\objects\mem.crf ..\..\src\mem.c]
                          THUMB

                          AREA ||i.list_mem||, CODE, READONLY, ALIGN=2

                  list_mem PROC
;;;577    
;;;578    void list_mem(void)
000000  b510              PUSH     {r4,lr}
;;;579    {
;;;580        rt_kprintf("total memory: %d\n", mem_size_aligned);
000002  4c07              LDR      r4,|L1.32|
000004  a007              ADR      r0,|L1.36|
000006  68e1              LDR      r1,[r4,#0xc]  ; mem_size_aligned
000008  f7fffffe          BL       rt_kprintf
;;;581        rt_kprintf("used memory : %d\n", used_mem);
00000c  a00a              ADR      r0,|L1.56|
00000e  6921              LDR      r1,[r4,#0x10]  ; used_mem
000010  f7fffffe          BL       rt_kprintf
;;;582        rt_kprintf("maximum allocated memory: %d\n", max_mem);
000014  a00d              ADR      r0,|L1.76|
000016  6961              LDR      r1,[r4,#0x14]  ; max_mem
000018  f7fffffe          BL       rt_kprintf
;;;583    }
00001c  bd10              POP      {r4,pc}
;;;584    FINSH_FUNCTION_EXPORT(list_mem, list memory usage information)
                          ENDP

00001e  0000              DCW      0x0000
                  |L1.32|
                          DCD      ||.data||
                  |L1.36|
000024  746f7461          DCB      "total memory: %d\n",0
000028  6c206d65
00002c  6d6f7279
000030  3a202564
000034  0a00    
000036  00                DCB      0
000037  00                DCB      0
                  |L1.56|
000038  75736564          DCB      "used memory : %d\n",0
00003c  206d656d
000040  6f727920
000044  3a202564
000048  0a00    
00004a  00                DCB      0
00004b  00                DCB      0
                  |L1.76|
00004c  6d617869          DCB      "maximum allocated memory: %d\n",0
000050  6d756d20
000054  616c6c6f
000058  63617465
00005c  64206d65
000060  6d6f7279
000064  3a202564
000068  0a00    
00006a  00                DCB      0
00006b  00                DCB      0

                          AREA ||i.plug_holes||, CODE, READONLY, ALIGN=2

                  plug_holes PROC
;;;135    
;;;136    static void plug_holes(struct heap_mem *mem)
000000  b530              PUSH     {r4,r5,lr}
;;;137    {
;;;138        struct heap_mem *nmem;
;;;139        struct heap_mem *pmem;
;;;140    
;;;141        RT_ASSERT((rt_uint8_t *)mem >= heap_ptr);
;;;142        RT_ASSERT((rt_uint8_t *)mem < (rt_uint8_t *)heap_end);
;;;143        RT_ASSERT(mem->used == 0);
;;;144    
;;;145        /* plug hole forward */
;;;146        nmem = (struct heap_mem *)&heap_ptr[mem->next];
000002  4c14              LDR      r4,|L2.84|
000004  6841              LDR      r1,[r0,#4]
000006  6822              LDR      r2,[r4,#0]  ; heap_ptr
;;;147        if (mem != nmem &&
;;;148            nmem->used == 0 &&
;;;149            (rt_uint8_t *)nmem != (rt_uint8_t *)heap_end)
;;;150        {
;;;151            /* if mem->next is unused and not end of heap_ptr,
;;;152             * combine mem and mem->next
;;;153             */
;;;154            if (lfree == nmem)
;;;155            {
;;;156                lfree = mem;
;;;157            }
;;;158            mem->next = nmem->next;
;;;159            ((struct heap_mem *)&heap_ptr[nmem->next])->prev = (rt_uint8_t *)mem - heap_ptr;
000008  4613              MOV      r3,r2
00000a  1889              ADDS     r1,r1,r2              ;146
00000c  3308              ADDS     r3,r3,#8
00000e  4288              CMP      r0,r1                 ;147
000010  d00e              BEQ      |L2.48|
000012  884d              LDRH     r5,[r1,#2]            ;148
000014  2d00              CMP      r5,#0                 ;148
000016  d10b              BNE      |L2.48|
000018  6865              LDR      r5,[r4,#4]            ;149  ; heap_end
00001a  42a9              CMP      r1,r5                 ;149
00001c  d008              BEQ      |L2.48|
00001e  68a5              LDR      r5,[r4,#8]            ;154  ; lfree
000020  428d              CMP      r5,r1                 ;154
000022  d100              BNE      |L2.38|
000024  60a0              STR      r0,[r4,#8]            ;156  ; lfree
                  |L2.38|
000026  684d              LDR      r5,[r1,#4]            ;158
000028  6045              STR      r5,[r0,#4]
00002a  6849              LDR      r1,[r1,#4]
00002c  1a85              SUBS     r5,r0,r2
00002e  50cd              STR      r5,[r1,r3]
                  |L2.48|
;;;160        }
;;;161    
;;;162        /* plug hole backward */
;;;163        pmem = (struct heap_mem *)&heap_ptr[mem->prev];
000030  6881              LDR      r1,[r0,#8]
000032  1889              ADDS     r1,r1,r2
;;;164        if (pmem != mem && pmem->used == 0)
000034  4281              CMP      r1,r0
000036  d00b              BEQ      |L2.80|
000038  884d              LDRH     r5,[r1,#2]
00003a  2d00              CMP      r5,#0
00003c  d108              BNE      |L2.80|
;;;165        {
;;;166            /* if mem->prev is unused, combine mem and mem->prev */
;;;167            if (lfree == mem)
00003e  68a5              LDR      r5,[r4,#8]  ; lfree
000040  4285              CMP      r5,r0
000042  d100              BNE      |L2.70|
;;;168            {
;;;169                lfree = pmem;
000044  60a1              STR      r1,[r4,#8]  ; lfree
                  |L2.70|
;;;170            }
;;;171            pmem->next = mem->next;
000046  6844              LDR      r4,[r0,#4]
;;;172            ((struct heap_mem *)&heap_ptr[mem->next])->prev = (rt_uint8_t *)pmem - heap_ptr;
000048  604c              STR      r4,[r1,#4]
00004a  6840              LDR      r0,[r0,#4]
00004c  1a89              SUBS     r1,r1,r2
00004e  50c1              STR      r1,[r0,r3]
                  |L2.80|
;;;173        }
;;;174    }
000050  bd30              POP      {r4,r5,pc}
;;;175    
                          ENDP

000052  0000              DCW      0x0000
                  |L2.84|
                          DCD      ||.data||

                          AREA ||i.rt_calloc||, CODE, READONLY, ALIGN=1

                  rt_calloc PROC
;;;481     */
;;;482    void *rt_calloc(rt_size_t count, rt_size_t size)
000000  b570              PUSH     {r4-r6,lr}
;;;483    {
;;;484        void *p;
;;;485    
;;;486        RT_DEBUG_NOT_IN_INTERRUPT;
;;;487    
;;;488        /* allocate 'count' objects of size 'size' */
;;;489        p = rt_malloc(count * size);
000002  4348              MULS     r0,r1,r0
000004  4604              MOV      r4,r0
000006  f7fffffe          BL       rt_malloc
00000a  0005              MOVS     r5,r0
;;;490    
;;;491        /* zero the memory */
;;;492        if (p)
00000c  d003              BEQ      |L3.22|
00000e  4622              MOV      r2,r4
;;;493            rt_memset(p, 0, count * size);
000010  2100              MOVS     r1,#0
000012  f7fffffe          BL       rt_memset
                  |L3.22|
;;;494    
;;;495        return p;
000016  4628              MOV      r0,r5
;;;496    }
000018  bd70              POP      {r4-r6,pc}
;;;497    RTM_EXPORT(rt_calloc);
                          ENDP


                          AREA ||i.rt_free||, CODE, READONLY, ALIGN=2

                  rt_free PROC
;;;504     */
;;;505    void rt_free(void *rmem)
000000  b570              PUSH     {r4-r6,lr}
;;;506    {
;;;507        struct heap_mem *mem;
;;;508    
;;;509        RT_DEBUG_NOT_IN_INTERRUPT;
;;;510    
;;;511        if (rmem == RT_NULL)
000002  2800              CMP      r0,#0
000004  d023              BEQ      |L4.78|
;;;512            return;
;;;513        RT_ASSERT((((rt_uint32_t)rmem) & (RT_ALIGN_SIZE-1)) == 0);
;;;514        RT_ASSERT((rt_uint8_t *)rmem >= (rt_uint8_t *)heap_ptr &&
;;;515                  (rt_uint8_t *)rmem < (rt_uint8_t *)heap_end);
;;;516    
;;;517        RT_OBJECT_HOOK_CALL(rt_free_hook, (rmem));
;;;518    
;;;519        if ((rt_uint8_t *)rmem < (rt_uint8_t *)heap_ptr ||
000006  4d12              LDR      r5,|L4.80|
000008  6829              LDR      r1,[r5,#0]  ; heap_ptr
00000a  4288              CMP      r0,r1
00000c  d31f              BCC      |L4.78|
;;;520            (rt_uint8_t *)rmem >= (rt_uint8_t *)heap_end)
00000e  6869              LDR      r1,[r5,#4]  ; heap_end
000010  4288              CMP      r0,r1
000012  d21c              BCS      |L4.78|
;;;521        {
;;;522            RT_DEBUG_LOG(RT_DEBUG_MEM, ("illegal memory\n"));
;;;523    
;;;524            return;
;;;525        }
;;;526    
;;;527        /* Get the corresponding struct heap_mem ... */
;;;528        mem = (struct heap_mem *)((rt_uint8_t *)rmem - SIZEOF_STRUCT_MEM);
000014  4604              MOV      r4,r0
;;;529    
;;;530        RT_DEBUG_LOG(RT_DEBUG_MEM,
;;;531                     ("release memory 0x%x, size: %d\n",
;;;532                      (rt_uint32_t)rmem,
;;;533                      (rt_uint32_t)(mem->next - ((rt_uint8_t *)mem - heap_ptr))));
;;;534    
;;;535    
;;;536        /* protect the heap from concurrent access */
;;;537        rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
000016  2100              MOVS     r1,#0
000018  3c0c              SUBS     r4,r4,#0xc            ;528
00001a  43c9              MVNS     r1,r1
00001c  480d              LDR      r0,|L4.84|
00001e  f7fffffe          BL       rt_sem_take
;;;538    
;;;539        /* ... which has to be in a used state ... */
;;;540        RT_ASSERT(mem->used);
;;;541        RT_ASSERT(mem->magic == HEAP_MAGIC);
;;;542        /* ... and is now unused. */
;;;543        mem->used  = 0;
000022  2000              MOVS     r0,#0
000024  8060              STRH     r0,[r4,#2]
;;;544        mem->magic = HEAP_MAGIC;
000026  20f5              MOVS     r0,#0xf5
000028  0140              LSLS     r0,r0,#5
00002a  8020              STRH     r0,[r4,#0]
;;;545    
;;;546        if (mem < lfree)
00002c  68a8              LDR      r0,[r5,#8]  ; lfree
00002e  4284              CMP      r4,r0
000030  d200              BCS      |L4.52|
;;;547        {
;;;548            /* the newly freed struct is now the lowest */
;;;549            lfree = mem;
000032  60ac              STR      r4,[r5,#8]  ; lfree
                  |L4.52|
;;;550        }
;;;551    
;;;552    #ifdef RT_MEM_STATS
;;;553        used_mem -= (mem->next - ((rt_uint8_t*)mem - heap_ptr));
000034  6829              LDR      r1,[r5,#0]  ; heap_ptr
000036  6860              LDR      r0,[r4,#4]
000038  1a61              SUBS     r1,r4,r1
00003a  1a40              SUBS     r0,r0,r1
00003c  6929              LDR      r1,[r5,#0x10]  ; used_mem
00003e  1a08              SUBS     r0,r1,r0
;;;554    #endif
;;;555    
;;;556        /* finally, see if prev or next are free also */
;;;557        plug_holes(mem);
000040  6128              STR      r0,[r5,#0x10]  ; used_mem
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       plug_holes
;;;558        rt_sem_release(&heap_sem);
000048  4802              LDR      r0,|L4.84|
00004a  f7fffffe          BL       rt_sem_release
                  |L4.78|
;;;559    }
00004e  bd70              POP      {r4-r6,pc}
;;;560    RTM_EXPORT(rt_free);
                          ENDP

                  |L4.80|
                          DCD      ||.data||
                  |L4.84|
                          DCD      ||.bss||

                          AREA ||i.rt_malloc||, CODE, READONLY, ALIGN=2

                  rt_malloc PROC
;;;245     */
;;;246    void *rt_malloc(rt_size_t size)
000000  b5f8              PUSH     {r3-r7,lr}
;;;247    {
;;;248        rt_size_t ptr, ptr2;
;;;249        struct heap_mem *mem, *mem2;
;;;250    
;;;251        RT_DEBUG_NOT_IN_INTERRUPT;
;;;252    
;;;253        if (size == 0)
000002  2800              CMP      r0,#0
000004  d007              BEQ      |L5.22|
000006  1cc0              ADDS     r0,r0,#3              ;247
;;;254            return RT_NULL;
;;;255    
;;;256        if (size != RT_ALIGN(size, RT_ALIGN_SIZE))
;;;257            RT_DEBUG_LOG(RT_DEBUG_MEM, ("malloc size %d, but align to %d\n",
;;;258                                        size, RT_ALIGN(size, RT_ALIGN_SIZE)));
;;;259        else
;;;260            RT_DEBUG_LOG(RT_DEBUG_MEM, ("malloc size %d\n", size));
;;;261    
;;;262        /* alignment size */
;;;263        size = RT_ALIGN(size, RT_ALIGN_SIZE);
;;;264    
;;;265        if (size > mem_size_aligned)
000008  4e35              LDR      r6,|L5.224|
00000a  0885              LSRS     r5,r0,#2              ;263
00000c  68f0              LDR      r0,[r6,#0xc]  ; mem_size_aligned
00000e  00ad              LSLS     r5,r5,#2              ;263
000010  4285              CMP      r5,r0
000012  d901              BLS      |L5.24|
                  |L5.20|
;;;266        {
;;;267            RT_DEBUG_LOG(RT_DEBUG_MEM, ("no memory\n"));
;;;268    
;;;269            return RT_NULL;
000014  2000              MOVS     r0,#0
                  |L5.22|
;;;270        }
;;;271    
;;;272        /* every data block must be at least MIN_SIZE_ALIGNED long */
;;;273        if (size < MIN_SIZE_ALIGNED)
;;;274            size = MIN_SIZE_ALIGNED;
;;;275    
;;;276        /* take memory semaphore */
;;;277        rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
;;;278    
;;;279        for (ptr = (rt_uint8_t *)lfree - heap_ptr;
;;;280             ptr < mem_size_aligned - size;
;;;281             ptr = ((struct heap_mem *)&heap_ptr[ptr])->next)
;;;282        {
;;;283            mem = (struct heap_mem *)&heap_ptr[ptr];
;;;284    
;;;285            if ((!mem->used) && (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size)
;;;286            {
;;;287                /* mem is not used and at least perfect fit is possible:
;;;288                 * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */
;;;289    
;;;290                if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >=
;;;291                    (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED))
;;;292                {
;;;293                    /* (in addition to the above, we test if another struct heap_mem (SIZEOF_STRUCT_MEM) containing
;;;294                     * at least MIN_SIZE_ALIGNED of data also fits in the 'user data space' of 'mem')
;;;295                     * -> split large block, create empty remainder,
;;;296                     * remainder must be large enough to contain MIN_SIZE_ALIGNED data: if
;;;297                     * mem->next - (ptr + (2*SIZEOF_STRUCT_MEM)) == size,
;;;298                     * struct heap_mem would fit in but no data between mem2 and mem2->next
;;;299                     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
;;;300                     *       region that couldn't hold data, but when mem->next gets freed,
;;;301                     *       the 2 regions would be combined, resulting in more free memory
;;;302                     */
;;;303                    ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
;;;304    
;;;305                    /* create mem2 struct */
;;;306                    mem2       = (struct heap_mem *)&heap_ptr[ptr2];
;;;307                    mem2->magic = HEAP_MAGIC;
;;;308                    mem2->used = 0;
;;;309                    mem2->next = mem->next;
;;;310                    mem2->prev = ptr;
;;;311    
;;;312                    /* and insert it between mem and mem->next */
;;;313                    mem->next = ptr2;
;;;314                    mem->used = 1;
;;;315    
;;;316                    if (mem2->next != mem_size_aligned + SIZEOF_STRUCT_MEM)
;;;317                    {
;;;318                        ((struct heap_mem *)&heap_ptr[mem2->next])->prev = ptr2;
;;;319                    }
;;;320    #ifdef RT_MEM_STATS
;;;321                    used_mem += (size + SIZEOF_STRUCT_MEM);
;;;322                    if (max_mem < used_mem)
;;;323                        max_mem = used_mem;
;;;324    #endif
;;;325                }
;;;326                else
;;;327                {
;;;328                    /* (a mem2 struct does no fit into the user data space of mem and mem->next will always
;;;329                     * be used at this point: if not we have 2 unused structs in a row, plug_holes should have
;;;330                     * take care of this).
;;;331                     * -> near fit or excact fit: do not split, no mem2 creation
;;;332                     * also can't move mem->next directly behind mem, since mem->next
;;;333                     * will always be used at this point!
;;;334                     */
;;;335                    mem->used = 1;
;;;336    #ifdef RT_MEM_STATS
;;;337                    used_mem += mem->next - ((rt_uint8_t*)mem - heap_ptr);
;;;338                    if (max_mem < used_mem)
;;;339                        max_mem = used_mem;
;;;340    #endif
;;;341                }
;;;342                /* set memory block magic */
;;;343                mem->magic = HEAP_MAGIC;
;;;344    
;;;345                if (mem == lfree)
;;;346                {
;;;347                    /* Find next free block after mem and update lowest free pointer */
;;;348                    while (lfree->used && lfree != heap_end)
;;;349                        lfree = (struct heap_mem *)&heap_ptr[lfree->next];
;;;350    
;;;351                    RT_ASSERT(((lfree == heap_end) || (!lfree->used)));
;;;352                }
;;;353    
;;;354                rt_sem_release(&heap_sem);
;;;355                RT_ASSERT((rt_uint32_t)mem + SIZEOF_STRUCT_MEM + size <= (rt_uint32_t)heap_end);
;;;356                RT_ASSERT((rt_uint32_t)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM) % RT_ALIGN_SIZE == 0);
;;;357                RT_ASSERT((((rt_uint32_t)mem) & (RT_ALIGN_SIZE-1)) == 0);
;;;358    
;;;359                RT_DEBUG_LOG(RT_DEBUG_MEM,
;;;360                             ("allocate memory at 0x%x, size: %d\n",
;;;361                              (rt_uint32_t)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM),
;;;362                              (rt_uint32_t)(mem->next - ((rt_uint8_t *)mem - heap_ptr))));
;;;363    
;;;364                RT_OBJECT_HOOK_CALL(rt_malloc_hook,
;;;365                                    (((void *)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM)), size));
;;;366    
;;;367                /* return the memory data except mem struct */
;;;368                return (rt_uint8_t *)mem + SIZEOF_STRUCT_MEM;
;;;369            }
;;;370        }
;;;371    
;;;372        rt_sem_release(&heap_sem);
;;;373    
;;;374        return RT_NULL;
;;;375    }
000016  bdf8              POP      {r3-r7,pc}
                  |L5.24|
000018  2d0c              CMP      r5,#0xc               ;273
00001a  d200              BCS      |L5.30|
00001c  250c              MOVS     r5,#0xc               ;274
                  |L5.30|
00001e  2100              MOVS     r1,#0                 ;277
000020  43c9              MVNS     r1,r1                 ;277
000022  4830              LDR      r0,|L5.228|
000024  f7fffffe          BL       rt_sem_take
000028  68b0              LDR      r0,[r6,#8]            ;279  ; lfree
00002a  6831              LDR      r1,[r6,#0]            ;279  ; heap_ptr
00002c  68f2              LDR      r2,[r6,#0xc]          ;265
00002e  4686              MOV      lr,r0                 ;279
000030  1a40              SUBS     r0,r0,r1              ;279
000032  4694              MOV      r12,r2                ;265
000034  1b53              SUBS     r3,r2,r5              ;280
000036  e04c              B        |L5.210|
                  |L5.56|
000038  180c              ADDS     r4,r1,r0              ;283
00003a  8862              LDRH     r2,[r4,#2]            ;285
00003c  2a00              CMP      r2,#0                 ;285
00003e  d147              BNE      |L5.208|
000040  6862              LDR      r2,[r4,#4]            ;285
000042  1a12              SUBS     r2,r2,r0              ;285
000044  3a0c              SUBS     r2,r2,#0xc            ;285
000046  42aa              CMP      r2,r5                 ;285
000048  d342              BCC      |L5.208|
00004a  6862              LDR      r2,[r4,#4]            ;290
00004c  1a13              SUBS     r3,r2,r0              ;290
00004e  462a              MOV      r2,r5                 ;290
000050  3218              ADDS     r2,r2,#0x18           ;290
000052  3b0c              SUBS     r3,r3,#0xc            ;290
000054  4293              CMP      r3,r2                 ;290
000056  d32d              BCC      |L5.180|
000058  1943              ADDS     r3,r0,r5              ;303
00005a  330c              ADDS     r3,r3,#0xc            ;303
00005c  27f5              MOVS     r7,#0xf5              ;307
00005e  18ca              ADDS     r2,r1,r3              ;306
000060  017f              LSLS     r7,r7,#5              ;307
000062  8017              STRH     r7,[r2,#0]            ;307
000064  2700              MOVS     r7,#0                 ;308
000066  8057              STRH     r7,[r2,#2]            ;308
000068  6867              LDR      r7,[r4,#4]            ;309
00006a  6057              STR      r7,[r2,#4]            ;313
00006c  6090              STR      r0,[r2,#8]            ;313
00006e  2001              MOVS     r0,#1                 ;314
000070  6063              STR      r3,[r4,#4]            ;314
000072  8060              STRH     r0,[r4,#2]            ;314
000074  6850              LDR      r0,[r2,#4]            ;316
000076  4662              MOV      r2,r12                ;316
000078  320c              ADDS     r2,r2,#0xc            ;316
00007a  4290              CMP      r0,r2                 ;316
00007c  d002              BEQ      |L5.132|
00007e  460a              MOV      r2,r1                 ;318
000080  3208              ADDS     r2,r2,#8              ;318
000082  5083              STR      r3,[r0,r2]            ;318
                  |L5.132|
000084  6930              LDR      r0,[r6,#0x10]         ;321  ; used_mem
000086  1940              ADDS     r0,r0,r5              ;321
000088  300c              ADDS     r0,r0,#0xc            ;321
                  |L5.138|
00008a  6130              STR      r0,[r6,#0x10]         ;338  ; used_mem
00008c  6972              LDR      r2,[r6,#0x14]         ;338  ; max_mem
00008e  4282              CMP      r2,r0                 ;338
000090  d200              BCS      |L5.148|
000092  6170              STR      r0,[r6,#0x14]         ;339  ; max_mem
                  |L5.148|
000094  20f5              MOVS     r0,#0xf5              ;343
000096  0140              LSLS     r0,r0,#5              ;343
000098  8020              STRH     r0,[r4,#0]            ;343
00009a  4574              CMP      r4,lr                 ;345
00009c  d112              BNE      |L5.196|
00009e  68b0              LDR      r0,[r6,#8]            ;348  ; lfree
                  |L5.160|
0000a0  8842              LDRH     r2,[r0,#2]            ;348
0000a2  2a00              CMP      r2,#0                 ;348
0000a4  d00e              BEQ      |L5.196|
0000a6  6872              LDR      r2,[r6,#4]            ;348  ; heap_end
0000a8  4290              CMP      r0,r2                 ;348
0000aa  d00b              BEQ      |L5.196|
0000ac  6840              LDR      r0,[r0,#4]            ;349
0000ae  1840              ADDS     r0,r0,r1              ;349
0000b0  60b0              STR      r0,[r6,#8]            ;349  ; lfree
0000b2  e7f5              B        |L5.160|
                  |L5.180|
0000b4  2001              MOVS     r0,#1                 ;335
0000b6  8060              STRH     r0,[r4,#2]            ;335
0000b8  6860              LDR      r0,[r4,#4]            ;337
0000ba  1a62              SUBS     r2,r4,r1              ;337
0000bc  1a80              SUBS     r0,r0,r2              ;337
0000be  6932              LDR      r2,[r6,#0x10]         ;337  ; used_mem
0000c0  1880              ADDS     r0,r0,r2              ;337
0000c2  e7e2              B        |L5.138|
                  |L5.196|
0000c4  4807              LDR      r0,|L5.228|
0000c6  f7fffffe          BL       rt_sem_release
0000ca  4620              MOV      r0,r4                 ;368
0000cc  300c              ADDS     r0,r0,#0xc            ;368
0000ce  bdf8              POP      {r3-r7,pc}
                  |L5.208|
0000d0  6860              LDR      r0,[r4,#4]            ;281
                  |L5.210|
0000d2  4283              CMP      r3,r0                 ;280
0000d4  d8b0              BHI      |L5.56|
0000d6  4803              LDR      r0,|L5.228|
0000d8  f7fffffe          BL       rt_sem_release
0000dc  e79a              B        |L5.20|
;;;376    RTM_EXPORT(rt_malloc);
                          ENDP

0000de  0000              DCW      0x0000
                  |L5.224|
                          DCD      ||.data||
                  |L5.228|
                          DCD      ||.bss||

                          AREA ||i.rt_memory_info||, CODE, READONLY, ALIGN=2

                  rt_memory_info PROC
;;;562    #ifdef RT_MEM_STATS
;;;563    void rt_memory_info(rt_uint32_t *total,
000000  b510              PUSH     {r4,lr}
;;;564                        rt_uint32_t *used,
;;;565                        rt_uint32_t *max_used)
;;;566    {
;;;567        if (total != RT_NULL)
;;;568            *total = mem_size_aligned;
000002  4b07              LDR      r3,|L6.32|
000004  2800              CMP      r0,#0                 ;567
000006  d001              BEQ      |L6.12|
000008  68dc              LDR      r4,[r3,#0xc]  ; mem_size_aligned
00000a  6004              STR      r4,[r0,#0]
                  |L6.12|
;;;569        if (used  != RT_NULL)
00000c  2900              CMP      r1,#0
00000e  d001              BEQ      |L6.20|
;;;570            *used = used_mem;
000010  6918              LDR      r0,[r3,#0x10]  ; used_mem
000012  6008              STR      r0,[r1,#0]
                  |L6.20|
;;;571        if (max_used != RT_NULL)
000014  2a00              CMP      r2,#0
000016  d001              BEQ      |L6.28|
;;;572            *max_used = max_mem;
000018  6958              LDR      r0,[r3,#0x14]  ; max_mem
00001a  6010              STR      r0,[r2,#0]
                  |L6.28|
;;;573    }
00001c  bd10              POP      {r4,pc}
;;;574    
                          ENDP

00001e  0000              DCW      0x0000
                  |L6.32|
                          DCD      ||.data||

                          AREA ||i.rt_realloc||, CODE, READONLY, ALIGN=2

                  rt_realloc PROC
;;;385     */
;;;386    void *rt_realloc(void *rmem, rt_size_t newsize)
000000  b5f8              PUSH     {r3-r7,lr}
;;;387    {
;;;388        rt_size_t size;
;;;389        rt_size_t ptr, ptr2;
;;;390        struct heap_mem *mem, *mem2;
;;;391        void *nmem;
;;;392    
;;;393        RT_DEBUG_NOT_IN_INTERRUPT;
;;;394    
;;;395        /* alignment size */
;;;396        newsize = RT_ALIGN(newsize, RT_ALIGN_SIZE);
;;;397        if (newsize > mem_size_aligned)
000002  4e2d              LDR      r6,|L7.184|
000004  4605              MOV      r5,r0                 ;387
000006  1cc9              ADDS     r1,r1,#3              ;387
000008  088c              LSRS     r4,r1,#2              ;396
00000a  68f0              LDR      r0,[r6,#0xc]  ; mem_size_aligned
00000c  00a4              LSLS     r4,r4,#2              ;396
00000e  4284              CMP      r4,r0
000010  d901              BLS      |L7.22|
;;;398        {
;;;399            RT_DEBUG_LOG(RT_DEBUG_MEM, ("realloc: out of memory\n"));
;;;400    
;;;401            return RT_NULL;
000012  2000              MOVS     r0,#0
;;;402        }
;;;403    
;;;404        /* allocate a new memory block */
;;;405        if (rmem == RT_NULL)
;;;406            return rt_malloc(newsize);
;;;407    
;;;408        rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
;;;409    
;;;410        if ((rt_uint8_t *)rmem < (rt_uint8_t *)heap_ptr ||
;;;411            (rt_uint8_t *)rmem >= (rt_uint8_t *)heap_end)
;;;412        {
;;;413            /* illegal memory */
;;;414            rt_sem_release(&heap_sem);
;;;415    
;;;416            return rmem;
;;;417        }
;;;418    
;;;419        mem = (struct heap_mem *)((rt_uint8_t *)rmem - SIZEOF_STRUCT_MEM);
;;;420    
;;;421        ptr = (rt_uint8_t *)mem - heap_ptr;
;;;422        size = mem->next - ptr - SIZEOF_STRUCT_MEM;
;;;423        if (size == newsize)
;;;424        {
;;;425            /* the size is the same as */
;;;426            rt_sem_release(&heap_sem);
;;;427    
;;;428            return rmem;
;;;429        }
;;;430    
;;;431        if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE < size)
;;;432        {
;;;433            /* split memory block */
;;;434    #ifdef RT_MEM_STATS
;;;435            used_mem -= (size - newsize);
;;;436    #endif
;;;437    
;;;438            ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
;;;439            mem2 = (struct heap_mem *)&heap_ptr[ptr2];
;;;440            mem2->magic= HEAP_MAGIC;
;;;441            mem2->used = 0;
;;;442            mem2->next = mem->next;
;;;443            mem2->prev = ptr;
;;;444            mem->next = ptr2;
;;;445            if (mem2->next != mem_size_aligned + SIZEOF_STRUCT_MEM)
;;;446            {
;;;447                ((struct heap_mem *)&heap_ptr[mem2->next])->prev = ptr2;
;;;448            }
;;;449    
;;;450            plug_holes(mem2);
;;;451    
;;;452            rt_sem_release(&heap_sem);
;;;453    
;;;454            return rmem;
;;;455        }
;;;456        rt_sem_release(&heap_sem);
;;;457    
;;;458        /* expand memory */
;;;459        nmem = rt_malloc(newsize);
;;;460        if (nmem != RT_NULL) /* check memory */
;;;461        {
;;;462            rt_memcpy(nmem, rmem, size < newsize ? size : newsize);
;;;463            rt_free(rmem);
;;;464        }
;;;465    
;;;466        return nmem;
;;;467    }
000014  bdf8              POP      {r3-r7,pc}
                  |L7.22|
000016  2d00              CMP      r5,#0                 ;405
000018  d017              BEQ      |L7.74|
00001a  2100              MOVS     r1,#0                 ;408
00001c  43c9              MVNS     r1,r1                 ;408
00001e  4827              LDR      r0,|L7.188|
000020  f7fffffe          BL       rt_sem_take
000024  6832              LDR      r2,[r6,#0]            ;410  ; heap_ptr
000026  4295              CMP      r5,r2                 ;410
000028  d30a              BCC      |L7.64|
00002a  6870              LDR      r0,[r6,#4]            ;411  ; heap_end
00002c  4285              CMP      r5,r0                 ;411
00002e  d207              BCS      |L7.64|
000030  4629              MOV      r1,r5                 ;419
000032  390c              SUBS     r1,r1,#0xc            ;419
000034  6848              LDR      r0,[r1,#4]            ;422
000036  1a8b              SUBS     r3,r1,r2              ;421
000038  1ac7              SUBS     r7,r0,r3              ;422
00003a  3f0c              SUBS     r7,r7,#0xc            ;422
00003c  42a7              CMP      r7,r4                 ;423
00003e  d108              BNE      |L7.82|
                  |L7.64|
000040  481e              LDR      r0,|L7.188|
000042  f7fffffe          BL       rt_sem_release
000046  4628              MOV      r0,r5                 ;428
000048  bdf8              POP      {r3-r7,pc}
                  |L7.74|
00004a  4620              MOV      r0,r4                 ;406
00004c  f7fffffe          BL       rt_malloc
000050  bdf8              POP      {r3-r7,pc}
                  |L7.82|
000052  4620              MOV      r0,r4                 ;431
000054  3018              ADDS     r0,r0,#0x18           ;431
000056  42b8              CMP      r0,r7                 ;431
000058  d219              BCS      |L7.142|
00005a  1b38              SUBS     r0,r7,r4              ;435
00005c  6937              LDR      r7,[r6,#0x10]         ;435  ; used_mem
00005e  191c              ADDS     r4,r3,r4              ;438
000060  1a38              SUBS     r0,r7,r0              ;435
000062  340c              ADDS     r4,r4,#0xc            ;438
000064  6130              STR      r0,[r6,#0x10]         ;439  ; used_mem
000066  27f5              MOVS     r7,#0xf5              ;440
000068  1910              ADDS     r0,r2,r4              ;439
00006a  017f              LSLS     r7,r7,#5              ;440
00006c  8007              STRH     r7,[r0,#0]            ;440
00006e  2700              MOVS     r7,#0                 ;441
000070  8047              STRH     r7,[r0,#2]            ;441
000072  684f              LDR      r7,[r1,#4]            ;442
000074  6047              STR      r7,[r0,#4]            ;444
000076  6083              STR      r3,[r0,#8]            ;444
000078  604c              STR      r4,[r1,#4]            ;445
00007a  68f3              LDR      r3,[r6,#0xc]          ;445  ; mem_size_aligned
00007c  6841              LDR      r1,[r0,#4]            ;445
00007e  330c              ADDS     r3,r3,#0xc            ;445
000080  4299              CMP      r1,r3                 ;445
000082  d001              BEQ      |L7.136|
000084  3208              ADDS     r2,r2,#8              ;445
000086  508c              STR      r4,[r1,r2]            ;447
                  |L7.136|
000088  f7fffffe          BL       plug_holes
00008c  e7d8              B        |L7.64|
                  |L7.142|
00008e  480b              LDR      r0,|L7.188|
000090  f7fffffe          BL       rt_sem_release
000094  4620              MOV      r0,r4                 ;459
000096  f7fffffe          BL       rt_malloc
00009a  0006              MOVS     r6,r0                 ;459
00009c  d009              BEQ      |L7.178|
00009e  42a7              CMP      r7,r4                 ;462
0000a0  d200              BCS      |L7.164|
0000a2  463c              MOV      r4,r7                 ;462
                  |L7.164|
0000a4  4622              MOV      r2,r4                 ;462
0000a6  4629              MOV      r1,r5                 ;462
0000a8  f7fffffe          BL       rt_memcpy
0000ac  4628              MOV      r0,r5                 ;463
0000ae  f7fffffe          BL       rt_free
                  |L7.178|
0000b2  4630              MOV      r0,r6                 ;466
0000b4  bdf8              POP      {r3-r7,pc}
;;;468    RTM_EXPORT(rt_realloc);
                          ENDP

0000b6  0000              DCW      0x0000
                  |L7.184|
                          DCD      ||.data||
                  |L7.188|
                          DCD      ||.bss||

                          AREA ||i.rt_system_heap_init||, CODE, READONLY, ALIGN=2

                  rt_system_heap_init PROC
;;;183     */
;;;184    void rt_system_heap_init(void *begin_addr, void *end_addr)
000000  460a              MOV      r2,r1
;;;185    {
;;;186        struct heap_mem *mem;
;;;187        rt_uint32_t begin_align = RT_ALIGN((rt_uint32_t)begin_addr, RT_ALIGN_SIZE);
000002  1cc1              ADDS     r1,r0,#3
000004  0889              LSRS     r1,r1,#2
;;;188        rt_uint32_t end_align = RT_ALIGN_DOWN((rt_uint32_t)end_addr, RT_ALIGN_SIZE);
000006  0893              LSRS     r3,r2,#2
000008  b510              PUSH     {r4,lr}               ;185
00000a  0089              LSLS     r1,r1,#2              ;187
00000c  009b              LSLS     r3,r3,#2
;;;189    
;;;190        RT_DEBUG_NOT_IN_INTERRUPT;
;;;191    
;;;192        /* alignment addr */
;;;193        if ((end_align > (2 * SIZEOF_STRUCT_MEM)) &&
00000e  2b18              CMP      r3,#0x18
000010  d920              BLS      |L8.84|
;;;194            ((end_align - 2 * SIZEOF_STRUCT_MEM) >= begin_align))
000012  461c              MOV      r4,r3
000014  3c18              SUBS     r4,r4,#0x18
000016  428c              CMP      r4,r1
000018  d31c              BCC      |L8.84|
;;;195        {
;;;196            /* calculate the aligned memory size */
;;;197            mem_size_aligned = end_align - begin_align - 2 * SIZEOF_STRUCT_MEM;
00001a  1a5a              SUBS     r2,r3,r1
00001c  4c10              LDR      r4,|L8.96|
00001e  3a18              SUBS     r2,r2,#0x18
;;;198        }
;;;199        else
;;;200        {
;;;201            rt_kprintf("mem init, error begin address 0x%x, and end address 0x%x\n",
;;;202                       (rt_uint32_t)begin_addr, (rt_uint32_t)end_addr);
;;;203    
;;;204            return;
;;;205        }
;;;206    
;;;207        /* point to begin address of heap */
;;;208        heap_ptr = (rt_uint8_t *)begin_align;
;;;209    
;;;210        RT_DEBUG_LOG(RT_DEBUG_MEM, ("mem init, heap begin address 0x%x, size %d\n",
;;;211                                    (rt_uint32_t)heap_ptr, mem_size_aligned));
;;;212    
;;;213        /* initialize the start of the heap */
;;;214        mem        = (struct heap_mem *)heap_ptr;
;;;215        mem->magic = HEAP_MAGIC;
000020  60e2              STR      r2,[r4,#0xc]  ; mem_size_aligned
000022  23f5              MOVS     r3,#0xf5
000024  015b              LSLS     r3,r3,#5
000026  6021              STR      r1,[r4,#0]  ; heap_ptr
000028  800b              STRH     r3,[r1,#0]
00002a  320c              ADDS     r2,r2,#0xc
;;;216        mem->next  = mem_size_aligned + SIZEOF_STRUCT_MEM;
;;;217        mem->prev  = 0;
00002c  2000              MOVS     r0,#0
;;;218        mem->used  = 0;
00002e  604a              STR      r2,[r1,#4]
000030  6088              STR      r0,[r1,#8]
000032  8048              STRH     r0,[r1,#2]
;;;219    
;;;220        /* initialize the end of the heap */
;;;221        heap_end        = (struct heap_mem *)&heap_ptr[mem->next];
000034  1850              ADDS     r0,r2,r1
;;;222        heap_end->magic = HEAP_MAGIC;
000036  6060              STR      r0,[r4,#4]  ; heap_end
000038  8003              STRH     r3,[r0,#0]
;;;223        heap_end->used  = 1;
00003a  2101              MOVS     r1,#1
00003c  8041              STRH     r1,[r0,#2]
;;;224        heap_end->next  = mem_size_aligned + SIZEOF_STRUCT_MEM;
;;;225        heap_end->prev  = mem_size_aligned + SIZEOF_STRUCT_MEM;
00003e  6042              STR      r2,[r0,#4]
;;;226    
;;;227        rt_sem_init(&heap_sem, "heap", 1, RT_IPC_FLAG_FIFO);
000040  6082              STR      r2,[r0,#8]
000042  460a              MOV      r2,r1
000044  2300              MOVS     r3,#0
000046  a107              ADR      r1,|L8.100|
000048  4808              LDR      r0,|L8.108|
00004a  f7fffffe          BL       rt_sem_init
;;;228    
;;;229        /* initialize the lowest-free pointer to the start of the heap */
;;;230        lfree = (struct heap_mem *)heap_ptr;
00004e  6820              LDR      r0,[r4,#0]  ; heap_ptr
000050  60a0              STR      r0,[r4,#8]            ;197  ; lfree
;;;231    }
000052  bd10              POP      {r4,pc}
                  |L8.84|
000054  4601              MOV      r1,r0                 ;201
000056  a006              ADR      r0,|L8.112|
000058  f7fffffe          BL       rt_kprintf
00005c  bd10              POP      {r4,pc}
;;;232    
                          ENDP

00005e  0000              DCW      0x0000
                  |L8.96|
                          DCD      ||.data||
                  |L8.100|
000064  68656170          DCB      "heap",0
000068  00      
000069  00                DCB      0
00006a  00                DCB      0
00006b  00                DCB      0
                  |L8.108|
                          DCD      ||.bss||
                  |L8.112|
000070  6d656d20          DCB      "mem init, error begin address 0x%x, and end address 0x%"
000074  696e6974
000078  2c206572
00007c  726f7220
000080  62656769
000084  6e206164
000088  64726573
00008c  73203078
000090  25782c20
000094  616e6420
000098  656e6420
00009c  61646472
0000a0  65737320
0000a4  307825  
0000a7  780a00            DCB      "x\n",0
0000aa  00                DCB      0
0000ab  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  heap_sem
                          %        32

                          AREA ||.data||, DATA, ALIGN=2

                  heap_ptr
                          DCD      0x00000000
                  heap_end
                          DCD      0x00000000
                  lfree
                          DCD      0x00000000
                  mem_size_aligned
                          DCD      0x00000000
                  used_mem
                          DCD      0x00000000
                  max_mem
                          DCD      0x00000000

                          AREA ||.rodata.name||, DATA, READONLY, ALIGN=0

                  __fsym_list_mem_name
000000  6c697374          DCB      0x6c,0x69,0x73,0x74
000004  5f6d656d          DCB      0x5f,0x6d,0x65,0x6d
000008  00                DCB      0x00

                          AREA ||area_number.14||, DATA, READONLY, ALIGN=0

                          EXPORTAS ||area_number.14||, ||.rodata.name||
                  __fsym_list_mem_desc
000000  6c697374          DCB      0x6c,0x69,0x73,0x74
000004  206d656d          DCB      0x20,0x6d,0x65,0x6d
000008  6f727920          DCB      0x6f,0x72,0x79,0x20
00000c  75736167          DCB      0x75,0x73,0x61,0x67
000010  6520696e          DCB      0x65,0x20,0x69,0x6e
000014  666f726d          DCB      0x66,0x6f,0x72,0x6d
000018  6174696f          DCB      0x61,0x74,0x69,0x6f
00001c  6e00              DCB      0x6e,0x00

                          AREA FSymTab, DATA, READONLY, ALIGN=2

                  __fsym_list_mem
                          DCD      __fsym_list_mem_name
                          DCD      __fsym_list_mem_desc
                          DCD      list_mem
