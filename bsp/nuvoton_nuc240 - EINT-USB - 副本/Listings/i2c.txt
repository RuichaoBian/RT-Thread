; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\i2c.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\i2c.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I.\Libraries\Device\Nuvoton -I..\..\components\finsh -I.\Libraries\CMSIS\Include -I.\Libraries\StdDriver\inc -I..\..\include -I.\APP -I.\Drivers -I..\..\components\drivers\include -I..\..\components\drivers\include\drivers -I..\nuvoton_nuc240 -I.\Libraries\Device\Nuvoton\NUC230_240\Include -I..\..\include -I..\..\components\drivers\usb\usbdevice\class -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=521 -DRT_DEBUG --omf_browse=.\objects\i2c.crf Libraries\StdDriver\src\i2c.c]
                          THUMB

                          AREA ||i.I2C_ClearTimeoutFlag||, CODE, READONLY, ALIGN=1

                  I2C_ClearTimeoutFlag PROC
;;;90       */
;;;91     void I2C_ClearTimeoutFlag(I2C_T *i2c)
000000  6941              LDR      r1,[r0,#0x14]
;;;92     {
;;;93         i2c->I2CTOC |= I2C_I2CTOC_TIF_Msk;
000002  2201              MOVS     r2,#1
000004  4311              ORRS     r1,r1,r2
000006  6141              STR      r1,[r0,#0x14]
;;;94     }
000008  4770              BX       lr
;;;95     
                          ENDP


                          AREA ||i.I2C_Close||, CODE, READONLY, ALIGN=2

                  I2C_Close PROC
;;;62     
;;;63     void I2C_Close(I2C_T *i2c)
000000  4a0b              LDR      r2,|L2.48|
;;;64     {
;;;65         /* Reset I2C Controller */
;;;66         if((uint32_t)i2c == I2C0_BASE)
;;;67         {
;;;68             SYS->IPRSTC2 |= SYS_IPRSTC2_I2C0_RST_Msk;
000002  2105              MOVS     r1,#5
000004  0709              LSLS     r1,r1,#28
000006  4290              CMP      r0,r2                 ;66
000008  d102              BNE      |L2.16|
00000a  68cb              LDR      r3,[r1,#0xc]
00000c  1582              ASRS     r2,r0,#22
;;;69             SYS->IPRSTC2 &= ~SYS_IPRSTC2_I2C0_RST_Msk;
00000e  e004              B        |L2.26|
                  |L2.16|
;;;70         }
;;;71         else if((uint32_t)i2c == I2C1_BASE)
000010  4a08              LDR      r2,|L2.52|
000012  4290              CMP      r0,r2
000014  d106              BNE      |L2.36|
;;;72         {
;;;73             SYS->IPRSTC2 |= SYS_IPRSTC2_I2C1_RST_Msk;
000016  68cb              LDR      r3,[r1,#0xc]
000018  1542              ASRS     r2,r0,#21
                  |L2.26|
00001a  4313              ORRS     r3,r3,r2
00001c  60cb              STR      r3,[r1,#0xc]
;;;74             SYS->IPRSTC2 &= ~SYS_IPRSTC2_I2C1_RST_Msk;
00001e  68cb              LDR      r3,[r1,#0xc]
000020  4393              BICS     r3,r3,r2
000022  60cb              STR      r3,[r1,#0xc]
                  |L2.36|
;;;75         }
;;;76     
;;;77         /* Disable I2C */
;;;78         i2c->I2CON &= ~I2C_I2CON_ENS1_Msk;
000024  6801              LDR      r1,[r0,#0]
000026  2240              MOVS     r2,#0x40
000028  4391              BICS     r1,r1,r2
00002a  6001              STR      r1,[r0,#0]
;;;79     }
00002c  4770              BX       lr
;;;80     
                          ENDP

00002e  0000              DCW      0x0000
                  |L2.48|
                          DCD      0x40020000
                  |L2.52|
                          DCD      0x40120000

                          AREA ||i.I2C_DisableInt||, CODE, READONLY, ALIGN=1

                  I2C_DisableInt PROC
;;;135      */
;;;136    void I2C_DisableInt(I2C_T *i2c)
000000  6801              LDR      r1,[r0,#0]
;;;137    {
;;;138        i2c->I2CON &= ~I2C_I2CON_EI_Msk;
000002  2280              MOVS     r2,#0x80
000004  4391              BICS     r1,r1,r2
000006  6001              STR      r1,[r0,#0]
;;;139    }
000008  4770              BX       lr
;;;140    
                          ENDP


                          AREA ||i.I2C_DisableTimeout||, CODE, READONLY, ALIGN=1

                  I2C_DisableTimeout PROC
;;;346     */
;;;347    void I2C_DisableTimeout(I2C_T *i2c)
000000  6941              LDR      r1,[r0,#0x14]
;;;348    {
;;;349        i2c->I2CTOC &= ~I2C_I2CTOC_ENTI_Msk;
000002  2204              MOVS     r2,#4
000004  4391              BICS     r1,r1,r2
000006  6141              STR      r1,[r0,#0x14]
;;;350    }
000008  4770              BX       lr
;;;351    
                          ENDP


                          AREA ||i.I2C_DisableWakeup||, CODE, READONLY, ALIGN=1

                  I2C_DisableWakeup PROC
;;;376     */
;;;377    void I2C_DisableWakeup(I2C_T *i2c)
000000  6bc1              LDR      r1,[r0,#0x3c]
;;;378    {
;;;379        i2c->I2CWKUPCON &= ~I2C_I2CWKUPCON_WKUPEN_Msk;
000002  0849              LSRS     r1,r1,#1
000004  0049              LSLS     r1,r1,#1
000006  63c1              STR      r1,[r0,#0x3c]
;;;380    }
000008  4770              BX       lr
;;;381    
                          ENDP


                          AREA ||i.I2C_EnableInt||, CODE, READONLY, ALIGN=1

                  I2C_EnableInt PROC
;;;150      */
;;;151    void I2C_EnableInt(I2C_T *i2c)
000000  6801              LDR      r1,[r0,#0]
;;;152    {
;;;153        i2c->I2CON |= I2C_I2CON_EI_Msk;
000002  2280              MOVS     r2,#0x80
000004  4311              ORRS     r1,r1,r2
000006  6001              STR      r1,[r0,#0]
;;;154    }
000008  4770              BX       lr
;;;155    
                          ENDP


                          AREA ||i.I2C_EnableTimeout||, CODE, READONLY, ALIGN=1

                  I2C_EnableTimeout PROC
;;;326     */
;;;327    void I2C_EnableTimeout(I2C_T *i2c, uint8_t u8LongTimeout)
000000  2202              MOVS     r2,#2
;;;328    {
;;;329        if(u8LongTimeout)
000002  2900              CMP      r1,#0
;;;330            i2c->I2CTOC |= I2C_I2CTOC_DIV4_Msk;
;;;331        else
;;;332            i2c->I2CTOC &= ~I2C_I2CTOC_DIV4_Msk;
000004  6941              LDR      r1,[r0,#0x14]
000006  d001              BEQ      |L7.12|
000008  4311              ORRS     r1,r1,r2              ;330
00000a  e000              B        |L7.14|
                  |L7.12|
00000c  4391              BICS     r1,r1,r2
                  |L7.14|
00000e  6141              STR      r1,[r0,#0x14]
;;;333    
;;;334        i2c->I2CTOC |= I2C_I2CTOC_ENTI_Msk;
000010  6941              LDR      r1,[r0,#0x14]
000012  2204              MOVS     r2,#4
000014  4311              ORRS     r1,r1,r2
000016  6141              STR      r1,[r0,#0x14]
;;;335    }
000018  4770              BX       lr
;;;336    
                          ENDP


                          AREA ||i.I2C_EnableWakeup||, CODE, READONLY, ALIGN=1

                  I2C_EnableWakeup PROC
;;;361     */
;;;362    void I2C_EnableWakeup(I2C_T *i2c)
000000  6bc1              LDR      r1,[r0,#0x3c]
;;;363    {
;;;364        i2c->I2CWKUPCON |= I2C_I2CWKUPCON_WKUPEN_Msk;
000002  2201              MOVS     r2,#1
000004  4311              ORRS     r1,r1,r2
000006  63c1              STR      r1,[r0,#0x3c]
;;;365    }
000008  4770              BX       lr
;;;366    
                          ENDP


                          AREA ||i.I2C_GetBusClockFreq||, CODE, READONLY, ALIGN=2

                  I2C_GetBusClockFreq PROC
;;;164     */
;;;165    uint32_t I2C_GetBusClockFreq(I2C_T *i2c)
000000  b510              PUSH     {r4,lr}
;;;166    {
;;;167        uint32_t u32Divider = i2c->I2CLK;
000002  6900              LDR      r0,[r0,#0x10]
;;;168    
;;;169        return (SystemCoreClock / ((u32Divider + 1) << 2));
000004  0081              LSLS     r1,r0,#2
000006  4803              LDR      r0,|L9.20|
000008  1d09              ADDS     r1,r1,#4
00000a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000c  f7fffffe          BL       __aeabi_uidivmod
;;;170    }
000010  bd10              POP      {r4,pc}
;;;171    
                          ENDP

000012  0000              DCW      0x0000
                  |L9.20|
                          DCD      SystemCoreClock

                          AREA ||i.I2C_GetData||, CODE, READONLY, ALIGN=1

                  I2C_GetData PROC
;;;228     */
;;;229    uint8_t I2C_GetData(I2C_T *i2c)
000000  6880              LDR      r0,[r0,#8]
;;;230    {
;;;231        return (i2c->I2CDAT);
000002  b2c0              UXTB     r0,r0
;;;232    }
000004  4770              BX       lr
;;;233    
                          ENDP


                          AREA ||i.I2C_GetIntFlag||, CODE, READONLY, ALIGN=1

                  I2C_GetIntFlag PROC
;;;200     */
;;;201    uint32_t I2C_GetIntFlag(I2C_T *i2c)
000000  6800              LDR      r0,[r0,#0]
;;;202    {
;;;203        return ((i2c->I2CON & I2C_I2CON_SI_Msk) == I2C_I2CON_SI_Msk ? 1 : 0);
000002  0700              LSLS     r0,r0,#28
000004  0fc0              LSRS     r0,r0,#31
;;;204    }
000006  4770              BX       lr
;;;205    
                          ENDP


                          AREA ||i.I2C_GetStatus||, CODE, READONLY, ALIGN=1

                  I2C_GetStatus PROC
;;;214     */
;;;215    uint32_t I2C_GetStatus(I2C_T *i2c)
000000  68c0              LDR      r0,[r0,#0xc]
;;;216    {
;;;217        return (i2c->I2CSTATUS);
;;;218    }
000002  4770              BX       lr
;;;219    
                          ENDP


                          AREA ||i.I2C_Open||, CODE, READONLY, ALIGN=2

                  I2C_Open PROC
;;;38       */
;;;39     uint32_t I2C_Open(I2C_T *i2c, uint32_t u32BusClock)
000000  b570              PUSH     {r4-r6,lr}
;;;40     {
;;;41         uint32_t u32Div;
;;;42     
;;;43         u32Div = (uint32_t)(((SystemCoreClock * 10) / (u32BusClock * 4) + 5) / 10 - 1); /* Compute proper divider for I2C clock */
000002  4d0c              LDR      r5,|L13.52|
000004  4604              MOV      r4,r0                 ;40
000006  6828              LDR      r0,[r5,#0]  ; SystemCoreClock
000008  220a              MOVS     r2,#0xa
00000a  0089              LSLS     r1,r1,#2
00000c  4350              MULS     r0,r2,r0
00000e  f7fffffe          BL       __aeabi_uidivmod
000012  210a              MOVS     r1,#0xa
000014  1d40              ADDS     r0,r0,#5
000016  f7fffffe          BL       __aeabi_uidivmod
00001a  1e40              SUBS     r0,r0,#1
;;;44         i2c->I2CLK = u32Div;
00001c  6120              STR      r0,[r4,#0x10]
;;;45     
;;;46         /* Enable I2C */
;;;47         i2c->I2CON |= I2C_I2CON_ENS1_Msk;
00001e  6821              LDR      r1,[r4,#0]
000020  2240              MOVS     r2,#0x40
000022  4311              ORRS     r1,r1,r2
000024  6021              STR      r1,[r4,#0]
;;;48     
;;;49         return (SystemCoreClock / ((u32Div + 1) << 2));
000026  0081              LSLS     r1,r0,#2
000028  1d09              ADDS     r1,r1,#4
00002a  6828              LDR      r0,[r5,#0]  ; SystemCoreClock
00002c  f7fffffe          BL       __aeabi_uidivmod
;;;50     }
000030  bd70              POP      {r4-r6,pc}
;;;51     
                          ENDP

000032  0000              DCW      0x0000
                  |L13.52|
                          DCD      SystemCoreClock

                          AREA ||i.I2C_SetBusClockFreq||, CODE, READONLY, ALIGN=2

                  I2C_SetBusClockFreq PROC
;;;181     */
;;;182    uint32_t I2C_SetBusClockFreq(I2C_T *i2c, uint32_t u32BusClock)
000000  b570              PUSH     {r4-r6,lr}
;;;183    {
000002  4604              MOV      r4,r0
;;;184        uint32_t u32Div;
;;;185    
;;;186        u32Div = (uint32_t)(((SystemCoreClock * 10) / (u32BusClock * 4) + 5) / 10 - 1); /* Compute proper divider for I2C clock */
000004  4809              LDR      r0,|L14.44|
000006  220a              MOVS     r2,#0xa
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000a  0089              LSLS     r1,r1,#2
00000c  4605              MOV      r5,r0
00000e  4350              MULS     r0,r2,r0
000010  f7fffffe          BL       __aeabi_uidivmod
000014  210a              MOVS     r1,#0xa
000016  1d40              ADDS     r0,r0,#5
000018  f7fffffe          BL       __aeabi_uidivmod
00001c  1e40              SUBS     r0,r0,#1
;;;187        i2c->I2CLK = u32Div;
00001e  6120              STR      r0,[r4,#0x10]
;;;188    
;;;189        return (SystemCoreClock / ((u32Div + 1) << 2));
000020  0081              LSLS     r1,r0,#2
000022  4628              MOV      r0,r5
000024  1d09              ADDS     r1,r1,#4
000026  f7fffffe          BL       __aeabi_uidivmod
;;;190    }
00002a  bd70              POP      {r4-r6,pc}
;;;191    
                          ENDP

                  |L14.44|
                          DCD      SystemCoreClock

                          AREA ||i.I2C_SetData||, CODE, READONLY, ALIGN=1

                  I2C_SetData PROC
;;;243     */
;;;244    void I2C_SetData(I2C_T *i2c, uint8_t u8Data)
000000  6081              STR      r1,[r0,#8]
;;;245    {
;;;246        i2c->I2CDAT = u8Data;
;;;247    }
000002  4770              BX       lr
;;;248    
                          ENDP


                          AREA ||i.I2C_SetSlaveAddr||, CODE, READONLY, ALIGN=1

                  I2C_SetSlaveAddr PROC
;;;262     */
;;;263    void I2C_SetSlaveAddr(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddr, uint8_t u8GCMode)
000000  0052              LSLS     r2,r2,#1
;;;264    {
;;;265        switch(u8SlaveNo)
;;;266        {
;;;267            case 1:
;;;268                i2c->I2CADDR1  = (u8SlaveAddr << 1) | u8GCMode;
000002  431a              ORRS     r2,r2,r3
000004  2901              CMP      r1,#1                 ;265
000006  d005              BEQ      |L16.20|
000008  2902              CMP      r1,#2                 ;265
00000a  d005              BEQ      |L16.24|
00000c  2903              CMP      r1,#3                 ;265
00000e  d005              BEQ      |L16.28|
;;;269                break;
;;;270            case 2:
;;;271                i2c->I2CADDR2  = (u8SlaveAddr << 1) | u8GCMode;
;;;272                break;
;;;273            case 3:
;;;274                i2c->I2CADDR3  = (u8SlaveAddr << 1) | u8GCMode;
;;;275                break;
;;;276            case 0:
;;;277            default:
;;;278                i2c->I2CADDR0  = (u8SlaveAddr << 1) | u8GCMode;
000010  6042              STR      r2,[r0,#4]
;;;279                break;
;;;280        }
;;;281    }
000012  4770              BX       lr
                  |L16.20|
000014  6182              STR      r2,[r0,#0x18]         ;268
000016  4770              BX       lr
                  |L16.24|
000018  61c2              STR      r2,[r0,#0x1c]         ;271
00001a  4770              BX       lr
                  |L16.28|
00001c  6202              STR      r2,[r0,#0x20]         ;274
00001e  4770              BX       lr
;;;282    
                          ENDP


                          AREA ||i.I2C_SetSlaveAddrMask||, CODE, READONLY, ALIGN=1

                  I2C_SetSlaveAddrMask PROC
;;;294     */
;;;295    void I2C_SetSlaveAddrMask(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddrMask)
000000  0052              LSLS     r2,r2,#1
;;;296    {
;;;297        switch(u8SlaveNo)
000002  2901              CMP      r1,#1
000004  d005              BEQ      |L17.18|
000006  2902              CMP      r1,#2
000008  d005              BEQ      |L17.22|
00000a  2903              CMP      r1,#3
00000c  d005              BEQ      |L17.26|
;;;298        {
;;;299            case 1:
;;;300                i2c->I2CADM1  = u8SlaveAddrMask << 1;
;;;301                break;
;;;302            case 2:
;;;303                i2c->I2CADM2  = u8SlaveAddrMask << 1;
;;;304                break;
;;;305            case 3:
;;;306                i2c->I2CADM3  = u8SlaveAddrMask << 1;
;;;307                break;
;;;308            case 0:
;;;309            default:
;;;310                i2c->I2CADM0  = u8SlaveAddrMask << 1;
00000e  6242              STR      r2,[r0,#0x24]
;;;311                break;
;;;312        }
;;;313    }
000010  4770              BX       lr
                  |L17.18|
000012  6282              STR      r2,[r0,#0x28]         ;300
000014  4770              BX       lr
                  |L17.22|
000016  62c2              STR      r2,[r0,#0x2c]         ;303
000018  4770              BX       lr
                  |L17.26|
00001a  6302              STR      r2,[r0,#0x30]         ;306
00001c  4770              BX       lr
;;;314    
                          ENDP


                          AREA ||i.I2C_Trigger||, CODE, READONLY, ALIGN=1

                  I2C_Trigger PROC
;;;109      */
;;;110    void I2C_Trigger(I2C_T *i2c, uint8_t u8Start, uint8_t u8Stop, uint8_t u8Si, uint8_t u8Ack)
000000  b530              PUSH     {r4,r5,lr}
;;;111    {
;;;112        uint32_t u32Reg = 0;
000002  2400              MOVS     r4,#0
;;;113    
;;;114        if(u8Start)
000004  9d03              LDR      r5,[sp,#0xc]
000006  2900              CMP      r1,#0
000008  d000              BEQ      |L18.12|
;;;115            u32Reg |= I2C_I2CON_STA;
00000a  2420              MOVS     r4,#0x20
                  |L18.12|
;;;116        if(u8Stop)
00000c  2a00              CMP      r2,#0
00000e  d001              BEQ      |L18.20|
;;;117            u32Reg |= I2C_I2CON_STO;
000010  2110              MOVS     r1,#0x10
000012  430c              ORRS     r4,r4,r1
                  |L18.20|
;;;118        if(u8Si)
000014  2b00              CMP      r3,#0
000016  d001              BEQ      |L18.28|
;;;119            u32Reg |= I2C_I2CON_SI;
000018  2108              MOVS     r1,#8
00001a  430c              ORRS     r4,r4,r1
                  |L18.28|
;;;120        if(u8Ack)
00001c  2d00              CMP      r5,#0
00001e  d001              BEQ      |L18.36|
;;;121            u32Reg |= I2C_I2CON_AA;
000020  2104              MOVS     r1,#4
000022  430c              ORRS     r4,r4,r1
                  |L18.36|
;;;122    
;;;123        i2c->I2CON = (i2c->I2CON & ~0x3C) | u32Reg;
000024  6801              LDR      r1,[r0,#0]
000026  223c              MOVS     r2,#0x3c
000028  4391              BICS     r1,r1,r2
00002a  4321              ORRS     r1,r1,r4
00002c  6001              STR      r1,[r0,#0]
;;;124    }
00002e  bd30              POP      {r4,r5,pc}
;;;125    
                          ENDP


;*** Start embedded assembler ***

#line 1 "Libraries\\StdDriver\\src\\i2c.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_i2c_c_I2C_Open____REV16|
#line 118 ".\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___5_i2c_c_I2C_Open____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_i2c_c_I2C_Open____REVSH|
#line 132
|__asm___5_i2c_c_I2C_Open____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
