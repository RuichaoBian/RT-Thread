; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\mempool.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\mempool.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I.\Libraries\Device\Nuvoton -I..\..\components\finsh -I.\Libraries\CMSIS\Include -I.\Libraries\StdDriver\inc -I..\..\include -I.\APP -I.\Drivers -I..\..\components\drivers\include -I..\..\components\drivers\include\drivers -I..\nuvoton_nuc240 -I.\Libraries\Device\Nuvoton\NUC230_240\Include -I..\..\include -I..\..\components\drivers\usb\usbdevice\class -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=521 -DRT_DEBUG --omf_browse=.\objects\mempool.crf ..\..\src\mempool.c]
                          THUMB

                          AREA ||i.rt_list_isempty||, CODE, READONLY, ALIGN=1

                  rt_list_isempty PROC
;;;102     */
;;;103    rt_inline int rt_list_isempty(const rt_list_t *l)
000000  6801              LDR      r1,[r0,#0]
;;;104    {
;;;105        return l->next == l;
000002  4281              CMP      r1,r0
000004  d101              BNE      |L1.10|
000006  2001              MOVS     r0,#1
;;;106    }
000008  4770              BX       lr
                  |L1.10|
00000a  2000              MOVS     r0,#0                 ;105
00000c  4770              BX       lr
;;;107    
                          ENDP


                          AREA ||i.rt_mp_alloc||, CODE, READONLY, ALIGN=2

                  rt_mp_alloc PROC
;;;320     */
;;;321    void *rt_mp_alloc(rt_mp_t mp, rt_int32_t time)
000000  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;322    {
000002  b083              SUB      sp,sp,#0xc
000004  4604              MOV      r4,r0
;;;323        rt_uint8_t *block_ptr;
;;;324        register rt_base_t level;
;;;325        struct rt_thread *thread;
;;;326        rt_uint32_t before_sleep = 0;
000006  2700              MOVS     r7,#0
;;;327    
;;;328        /* get current thread */
;;;329        thread = rt_thread_self();
000008  f7fffffe          BL       rt_thread_self
00000c  4605              MOV      r5,r0
;;;330    
;;;331        /* disable interrupt */
;;;332        level = rt_hw_interrupt_disable();
00000e  f7fffffe          BL       rt_hw_interrupt_disable
000012  2600              MOVS     r6,#0
;;;333    
;;;334        while (mp->block_free_count == 0)
000014  9000              STR      r0,[sp,#0]
000016  e058              B        |L2.202|
                  |L2.24|
;;;335        {
;;;336            /* memory block is unavailable. */
;;;337            if (time == 0)
000018  9804              LDR      r0,[sp,#0x10]
00001a  2800              CMP      r0,#0
00001c  d03f              BEQ      |L2.158|
;;;338            {
;;;339                /* enable interrupt */
;;;340                rt_hw_interrupt_enable(level);
;;;341    
;;;342                rt_set_errno(-RT_ETIMEOUT);
;;;343    
;;;344                return RT_NULL;
;;;345            }
;;;346    
;;;347            RT_DEBUG_NOT_IN_INTERRUPT;
00001e  f7fffffe          BL       rt_hw_interrupt_disable
000022  9001              STR      r0,[sp,#4]
000024  f7fffffe          BL       rt_interrupt_get_nest
000028  2800              CMP      r0,#0
00002a  d009              BEQ      |L2.64|
00002c  4932              LDR      r1,|L2.248|
00002e  a033              ADR      r0,|L2.252|
000030  f7fffffe          BL       rt_kprintf
000034  22ff              MOVS     r2,#0xff
000036  325c              ADDS     r2,r2,#0x5c
000038  492f              LDR      r1,|L2.248|
00003a  a039              ADR      r0,|L2.288|
00003c  f7fffffe          BL       rt_assert_handler
                  |L2.64|
000040  9801              LDR      r0,[sp,#4]
000042  f7fffffe          BL       rt_hw_interrupt_enable
;;;348    
;;;349            thread->error = RT_EOK;
;;;350    
;;;351            /* need suspend thread */
;;;352            rt_thread_suspend(thread);
000046  4628              MOV      r0,r5
000048  632e              STR      r6,[r5,#0x30]
00004a  f7fffffe          BL       rt_thread_suspend
;;;353            rt_list_insert_after(&(mp->suspend_thread), &(thread->tlist));
00004e  4628              MOV      r0,r5
000050  6ae2              LDR      r2,[r4,#0x2c]
000052  3014              ADDS     r0,r0,#0x14
000054  6050              STR      r0,[r2,#4]
000056  6ae2              LDR      r2,[r4,#0x2c]
000058  4621              MOV      r1,r4
00005a  616a              STR      r2,[r5,#0x14]
00005c  312c              ADDS     r1,r1,#0x2c
00005e  62e0              STR      r0,[r4,#0x2c]
;;;354            mp->suspend_thread_count++;
000060  61a9              STR      r1,[r5,#0x18]
000062  6b60              LDR      r0,[r4,#0x34]
000064  1c40              ADDS     r0,r0,#1
;;;355    
;;;356            if (time > 0)
000066  6360              STR      r0,[r4,#0x34]
000068  9804              LDR      r0,[sp,#0x10]
00006a  2800              CMP      r0,#0
00006c  dd0c              BLE      |L2.136|
;;;357            {
;;;358                /* get the start tick of timer */
;;;359                before_sleep = rt_tick_get();
00006e  f7fffffe          BL       rt_tick_get
000072  4607              MOV      r7,r0
;;;360    
;;;361                /* init thread timer and start it */
;;;362                rt_timer_control(&(thread->thread_timer),
000074  4628              MOV      r0,r5
000076  304c              ADDS     r0,r0,#0x4c
000078  aa04              ADD      r2,sp,#0x10
00007a  2100              MOVS     r1,#0
00007c  9001              STR      r0,[sp,#4]
00007e  f7fffffe          BL       rt_timer_control
;;;363                                 RT_TIMER_CTRL_SET_TIME,
;;;364                                 &time);
;;;365                rt_timer_start(&(thread->thread_timer));
000082  9801              LDR      r0,[sp,#4]
000084  f7fffffe          BL       rt_timer_start
                  |L2.136|
;;;366            }
;;;367    
;;;368            /* enable interrupt */
;;;369            rt_hw_interrupt_enable(level);
000088  9800              LDR      r0,[sp,#0]
00008a  f7fffffe          BL       rt_hw_interrupt_enable
;;;370    
;;;371            /* do a schedule */
;;;372            rt_schedule();
00008e  f7fffffe          BL       rt_schedule
;;;373    
;;;374            if (thread->error != RT_EOK)
000092  6b28              LDR      r0,[r5,#0x30]
000094  2800              CMP      r0,#0
000096  d00a              BEQ      |L2.174|
                  |L2.152|
;;;375                return RT_NULL;
000098  2000              MOVS     r0,#0
                  |L2.154|
;;;376    
;;;377            if (time > 0)
;;;378            {
;;;379                time -= rt_tick_get() - before_sleep;
;;;380                if (time < 0)
;;;381                    time = 0;
;;;382            }
;;;383            /* disable interrupt */
;;;384            level = rt_hw_interrupt_disable();
;;;385        }
;;;386    
;;;387        /* memory block is available. decrease the free block counter */
;;;388        mp->block_free_count--;
;;;389    
;;;390        /* get block from block list */
;;;391        block_ptr = mp->block_list;
;;;392        RT_ASSERT(block_ptr != RT_NULL);
;;;393    
;;;394        /* Setup the next free node. */
;;;395        mp->block_list = *(rt_uint8_t **)block_ptr;
;;;396    
;;;397        /* point to memory pool */
;;;398        *(rt_uint8_t **)block_ptr = (rt_uint8_t *)mp;
;;;399    
;;;400        /* enable interrupt */
;;;401        rt_hw_interrupt_enable(level);
;;;402    
;;;403        RT_OBJECT_HOOK_CALL(rt_mp_alloc_hook,
;;;404                            (mp, (rt_uint8_t *)(block_ptr + sizeof(rt_uint8_t *))));
;;;405    
;;;406        return (rt_uint8_t *)(block_ptr + sizeof(rt_uint8_t *));
;;;407    }
00009a  b005              ADD      sp,sp,#0x14
00009c  bdf0              POP      {r4-r7,pc}
                  |L2.158|
00009e  9800              LDR      r0,[sp,#0]            ;340
0000a0  f7fffffe          BL       rt_hw_interrupt_enable
0000a4  2001              MOVS     r0,#1                 ;342
0000a6  43c0              MVNS     r0,r0                 ;342
0000a8  f7fffffe          BL       rt_set_errno
0000ac  e7f4              B        |L2.152|
                  |L2.174|
0000ae  9804              LDR      r0,[sp,#0x10]         ;377
0000b0  2800              CMP      r0,#0                 ;377
0000b2  dd07              BLE      |L2.196|
0000b4  f7fffffe          BL       rt_tick_get
0000b8  9904              LDR      r1,[sp,#0x10]         ;379
0000ba  1bc0              SUBS     r0,r0,r7              ;379
0000bc  1a08              SUBS     r0,r1,r0              ;379
0000be  9004              STR      r0,[sp,#0x10]         ;380
0000c0  d500              BPL      |L2.196|
0000c2  9604              STR      r6,[sp,#0x10]         ;381
                  |L2.196|
0000c4  f7fffffe          BL       rt_hw_interrupt_disable
0000c8  9000              STR      r0,[sp,#0]            ;384
                  |L2.202|
0000ca  6aa0              LDR      r0,[r4,#0x28]         ;334
0000cc  2800              CMP      r0,#0                 ;334
0000ce  d0a3              BEQ      |L2.24|
0000d0  1e40              SUBS     r0,r0,#1              ;334
0000d2  62a0              STR      r0,[r4,#0x28]         ;391
0000d4  6a25              LDR      r5,[r4,#0x20]         ;392
0000d6  2d00              CMP      r5,#0                 ;392
0000d8  d105              BNE      |L2.230|
0000da  22ff              MOVS     r2,#0xff              ;392
0000dc  3289              ADDS     r2,r2,#0x89           ;392
0000de  4906              LDR      r1,|L2.248|
0000e0  a010              ADR      r0,|L2.292|
0000e2  f7fffffe          BL       rt_assert_handler
                  |L2.230|
0000e6  6828              LDR      r0,[r5,#0]            ;395
0000e8  6220              STR      r0,[r4,#0x20]         ;398
0000ea  602c              STR      r4,[r5,#0]            ;401
0000ec  9800              LDR      r0,[sp,#0]            ;401
0000ee  f7fffffe          BL       rt_hw_interrupt_enable
0000f2  1d28              ADDS     r0,r5,#4              ;406
0000f4  e7d1              B        |L2.154|
;;;408    RTM_EXPORT(rt_mp_alloc);
                          ENDP

0000f6  0000              DCW      0x0000
                  |L2.248|
                          DCD      ||.constdata||+0x32
                  |L2.252|
0000fc  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
000100  74696f6e
000104  5b25735d
000108  20736861
00010c  6c6c206e
000110  6f742075
000114  73656420
000118  696e2049
00011c  53520a00
                  |L2.288|
000120  3000              DCB      "0",0
000122  00                DCB      0
000123  00                DCB      0
                  |L2.292|
000124  626c6f63          DCB      "block_ptr != RT_NULL",0
000128  6b5f7074
00012c  7220213d
000130  2052545f
000134  4e554c4c
000138  00      
000139  00                DCB      0
00013a  00                DCB      0
00013b  00                DCB      0

                          AREA ||i.rt_mp_create||, CODE, READONLY, ALIGN=2

                  rt_mp_create PROC
;;;196     */
;;;197    rt_mp_t rt_mp_create(const char *name,
000000  b5f8              PUSH     {r3-r7,lr}
;;;198                         rt_size_t   block_count,
;;;199                         rt_size_t   block_size)
;;;200    {
000002  4615              MOV      r5,r2
000004  460e              MOV      r6,r1
000006  4604              MOV      r4,r0
;;;201        rt_uint8_t *block_ptr;
;;;202        struct rt_mempool *mp;
;;;203        register rt_base_t offset;
;;;204    
;;;205        RT_DEBUG_NOT_IN_INTERRUPT;
000008  f7fffffe          BL       rt_hw_interrupt_disable
00000c  4607              MOV      r7,r0
00000e  f7fffffe          BL       rt_interrupt_get_nest
000012  2800              CMP      r0,#0
000014  d008              BEQ      |L3.40|
000016  491f              LDR      r1,|L3.148|
000018  a01f              ADR      r0,|L3.152|
00001a  f7fffffe          BL       rt_kprintf
00001e  22cd              MOVS     r2,#0xcd
000020  491c              LDR      r1,|L3.148|
000022  a026              ADR      r0,|L3.188|
000024  f7fffffe          BL       rt_assert_handler
                  |L3.40|
000028  4638              MOV      r0,r7
00002a  f7fffffe          BL       rt_hw_interrupt_enable
;;;206    
;;;207        /* allocate object */
;;;208        mp = (struct rt_mempool *)rt_object_allocate(RT_Object_Class_MemPool, name);
00002e  4621              MOV      r1,r4
000030  2006              MOVS     r0,#6
000032  f7fffffe          BL       rt_object_allocate
000036  1e04              SUBS     r4,r0,#0
;;;209        /* allocate object failed */
;;;210        if (mp == RT_NULL)
000038  d01b              BEQ      |L3.114|
00003a  1ced              ADDS     r5,r5,#3
;;;211            return RT_NULL;
;;;212    
;;;213        /* initialize memory pool */
;;;214        block_size     = RT_ALIGN(block_size, RT_ALIGN_SIZE);
00003c  08a8              LSRS     r0,r5,#2
00003e  0080              LSLS     r0,r0,#2
;;;215        mp->block_size = block_size;
000040  61e0              STR      r0,[r4,#0x1c]
000042  1d00              ADDS     r0,r0,#4
;;;216        mp->size       = (block_size + sizeof(rt_uint8_t *)) * block_count;
000044  4605              MOV      r5,r0
000046  4370              MULS     r0,r6,r0
;;;217    
;;;218        /* allocate memory */
;;;219        mp->start_address = rt_malloc((block_size + sizeof(rt_uint8_t *)) *
000048  61a0              STR      r0,[r4,#0x18]
00004a  f7fffffe          BL       rt_malloc
;;;220                                      block_count);
;;;221        if (mp->start_address == RT_NULL)
00004e  6160              STR      r0,[r4,#0x14]
000050  2800              CMP      r0,#0
000052  d00a              BEQ      |L3.106|
;;;222        {
;;;223            /* no memory, delete memory pool object */
;;;224            rt_object_delete(&(mp->parent));
;;;225    
;;;226            return RT_NULL;
;;;227        }
;;;228    
;;;229        mp->block_total_count = block_count;
;;;230        mp->block_free_count  = mp->block_total_count;
;;;231    
;;;232        /* initialize suspended thread list */
;;;233        rt_list_init(&(mp->suspend_thread));
000054  4620              MOV      r0,r4
000056  302c              ADDS     r0,r0,#0x2c
000058  6266              STR      r6,[r4,#0x24]         ;230
00005a  6320              STR      r0,[r4,#0x30]         ;230
;;;234        mp->suspend_thread_count = 0;
00005c  2300              MOVS     r3,#0
;;;235    
;;;236        /* initialize free block list */
;;;237        block_ptr = (rt_uint8_t *)mp->start_address;
00005e  62a6              STR      r6,[r4,#0x28]
000060  6363              STR      r3,[r4,#0x34]
000062  62e0              STR      r0,[r4,#0x2c]
;;;238        for (offset = 0; offset < mp->block_total_count; offset ++)
000064  4618              MOV      r0,r3
000066  6961              LDR      r1,[r4,#0x14]
000068  e00b              B        |L3.130|
                  |L3.106|
00006a  4620              MOV      r0,r4                 ;224
00006c  f7fffffe          BL       rt_object_delete
000070  2000              MOVS     r0,#0                 ;226
                  |L3.114|
;;;239        {
;;;240            *(rt_uint8_t **)(block_ptr + offset * (block_size + sizeof(rt_uint8_t *)))
;;;241                = block_ptr + (offset + 1) * (block_size + sizeof(rt_uint8_t *));
;;;242        }
;;;243    
;;;244        *(rt_uint8_t **)(block_ptr + (offset - 1) * (block_size + sizeof(rt_uint8_t *)))
;;;245            = RT_NULL;
;;;246    
;;;247        mp->block_list = block_ptr;
;;;248    
;;;249        return mp;
;;;250    }
000072  bdf8              POP      {r3-r7,pc}
                  |L3.116|
000074  1c42              ADDS     r2,r0,#1              ;240
000076  436a              MULS     r2,r5,r2              ;240
000078  1856              ADDS     r6,r2,r1              ;240
00007a  4602              MOV      r2,r0                 ;240
00007c  436a              MULS     r2,r5,r2              ;240
00007e  508e              STR      r6,[r1,r2]            ;240
000080  1c40              ADDS     r0,r0,#1              ;240
                  |L3.130|
000082  6a62              LDR      r2,[r4,#0x24]         ;238
000084  4282              CMP      r2,r0                 ;238
000086  d8f5              BHI      |L3.116|
000088  1e40              SUBS     r0,r0,#1              ;238
00008a  4368              MULS     r0,r5,r0              ;244
00008c  500b              STR      r3,[r1,r0]            ;244
00008e  4620              MOV      r0,r4                 ;249
000090  6221              STR      r1,[r4,#0x20]         ;249
000092  bdf8              POP      {r3-r7,pc}
;;;251    RTM_EXPORT(rt_mp_create);
                          ENDP

                  |L3.148|
                          DCD      ||.constdata||+0x18
                  |L3.152|
000098  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
00009c  74696f6e
0000a0  5b25735d
0000a4  20736861
0000a8  6c6c206e
0000ac  6f742075
0000b0  73656420
0000b4  696e2049
0000b8  53520a00
                  |L3.188|
0000bc  3000              DCB      "0",0
0000be  00                DCB      0
0000bf  00                DCB      0

                          AREA ||i.rt_mp_delete||, CODE, READONLY, ALIGN=2

                  rt_mp_delete PROC
;;;259     */
;;;260    rt_err_t rt_mp_delete(rt_mp_t mp)
000000  b5f8              PUSH     {r3-r7,lr}
;;;261    {
000002  4604              MOV      r4,r0
;;;262        struct rt_thread *thread;
;;;263        register rt_ubase_t temp;
;;;264    
;;;265        RT_DEBUG_NOT_IN_INTERRUPT;
000004  f7fffffe          BL       rt_hw_interrupt_disable
000008  4605              MOV      r5,r0
00000a  f7fffffe          BL       rt_interrupt_get_nest
00000e  2800              CMP      r0,#0
000010  d009              BEQ      |L4.38|
000012  491a              LDR      r1,|L4.124|
000014  a01a              ADR      r0,|L4.128|
000016  f7fffffe          BL       rt_kprintf
00001a  22ff              MOVS     r2,#0xff
00001c  320a              ADDS     r2,r2,#0xa
00001e  4917              LDR      r1,|L4.124|
000020  a020              ADR      r0,|L4.164|
000022  f7fffffe          BL       rt_assert_handler
                  |L4.38|
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       rt_hw_interrupt_enable
;;;266    
;;;267        /* parameter check */
;;;268        RT_ASSERT(mp != RT_NULL);
00002c  2c00              CMP      r4,#0
00002e  d105              BNE      |L4.60|
000030  22ff              MOVS     r2,#0xff
000032  320d              ADDS     r2,r2,#0xd
000034  4911              LDR      r1,|L4.124|
000036  a01c              ADR      r0,|L4.168|
000038  f7fffffe          BL       rt_assert_handler
                  |L4.60|
;;;269    
;;;270        /* wake up all suspended threads */
;;;271        while (!rt_list_isempty(&(mp->suspend_thread)))
;;;272        {
;;;273            /* disable interrupt */
;;;274            temp = rt_hw_interrupt_disable();
;;;275    
;;;276            /* get next suspend thread */
;;;277            thread = rt_list_entry(mp->suspend_thread.next, struct rt_thread, tlist);
;;;278            /* set error code to RT_ERROR */
;;;279            thread->error = -RT_ERROR;
00003c  2600              MOVS     r6,#0
00003e  43f6              MVNS     r6,r6
000040  4627              MOV      r7,r4                 ;271
000042  372c              ADDS     r7,r7,#0x2c           ;271
                  |L4.68|
000044  4638              MOV      r0,r7                 ;271
000046  f7fffffe          BL       rt_list_isempty
00004a  2800              CMP      r0,#0                 ;271
00004c  d007              BEQ      |L4.94|
;;;280    
;;;281            /*
;;;282             * resume thread
;;;283             * In rt_thread_resume function, it will remove current thread from
;;;284             * suspend list
;;;285             */
;;;286            rt_thread_resume(thread);
;;;287    
;;;288            /* decrease suspended thread count */
;;;289            mp->suspend_thread_count --;
;;;290    
;;;291            /* enable interrupt */
;;;292            rt_hw_interrupt_enable(temp);
;;;293        }
;;;294    
;;;295    #if defined(RT_USING_MODULE) && defined(RT_USING_SLAB)
;;;296        /* the mp object belongs to an application module */
;;;297        if (mp->parent.flag & RT_OBJECT_FLAG_MODULE)
;;;298            rt_module_free(mp->parent.module_id, mp->start_address);
;;;299        else
;;;300    #endif
;;;301    
;;;302        /* release allocated room */
;;;303        rt_free(mp->start_address);
00004e  6960              LDR      r0,[r4,#0x14]
000050  f7fffffe          BL       rt_free
;;;304    
;;;305        /* detach object */
;;;306        rt_object_delete(&(mp->parent));
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       rt_object_delete
;;;307    
;;;308        return RT_EOK;
00005a  2000              MOVS     r0,#0
;;;309    }
00005c  bdf8              POP      {r3-r7,pc}
                  |L4.94|
00005e  f7fffffe          BL       rt_hw_interrupt_disable
000062  4605              MOV      r5,r0                 ;274
000064  6ae0              LDR      r0,[r4,#0x2c]         ;279
000066  61c6              STR      r6,[r0,#0x1c]         ;279
000068  3814              SUBS     r0,r0,#0x14           ;279
00006a  f7fffffe          BL       rt_thread_resume
00006e  6b60              LDR      r0,[r4,#0x34]         ;289
000070  1e40              SUBS     r0,r0,#1              ;289
000072  6360              STR      r0,[r4,#0x34]         ;292
000074  4628              MOV      r0,r5                 ;292
000076  f7fffffe          BL       rt_hw_interrupt_enable
00007a  e7e3              B        |L4.68|
;;;310    RTM_EXPORT(rt_mp_delete);
                          ENDP

                  |L4.124|
                          DCD      ||.constdata||+0x25
                  |L4.128|
000080  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
000084  74696f6e
000088  5b25735d
00008c  20736861
000090  6c6c206e
000094  6f742075
000098  73656420
00009c  696e2049
0000a0  53520a00
                  |L4.164|
0000a4  3000              DCB      "0",0
0000a6  00                DCB      0
0000a7  00                DCB      0
                  |L4.168|
0000a8  6d702021          DCB      "mp != RT_NULL",0
0000ac  3d205254
0000b0  5f4e554c
0000b4  4c00    
0000b6  00                DCB      0
0000b7  00                DCB      0

                          AREA ||i.rt_mp_detach||, CODE, READONLY, ALIGN=2

                  rt_mp_detach PROC
;;;145     */
;;;146    rt_err_t rt_mp_detach(struct rt_mempool *mp)
000000  b5f8              PUSH     {r3-r7,lr}
;;;147    {
000002  0004              MOVS     r4,r0
000004  d104              BNE      |L5.16|
;;;148        struct rt_thread *thread;
;;;149        register rt_ubase_t temp;
;;;150    
;;;151        /* parameter check */
;;;152        RT_ASSERT(mp != RT_NULL);
000006  2298              MOVS     r2,#0x98
000008  4910              LDR      r1,|L5.76|
00000a  a011              ADR      r0,|L5.80|
00000c  f7fffffe          BL       rt_assert_handler
                  |L5.16|
;;;153    
;;;154        /* wake up all suspended threads */
;;;155        while (!rt_list_isempty(&(mp->suspend_thread)))
;;;156        {
;;;157            /* disable interrupt */
;;;158            temp = rt_hw_interrupt_disable();
;;;159    
;;;160            /* get next suspend thread */
;;;161            thread = rt_list_entry(mp->suspend_thread.next, struct rt_thread, tlist);
;;;162            /* set error code to RT_ERROR */
;;;163            thread->error = -RT_ERROR;
000010  2600              MOVS     r6,#0
000012  43f6              MVNS     r6,r6
000014  4627              MOV      r7,r4                 ;155
000016  372c              ADDS     r7,r7,#0x2c           ;155
                  |L5.24|
000018  4638              MOV      r0,r7                 ;155
00001a  f7fffffe          BL       rt_list_isempty
00001e  2800              CMP      r0,#0                 ;155
000020  d004              BEQ      |L5.44|
;;;164    
;;;165            /*
;;;166             * resume thread
;;;167             * In rt_thread_resume function, it will remove current thread from
;;;168             * suspend list
;;;169             */
;;;170            rt_thread_resume(thread);
;;;171    
;;;172            /* decrease suspended thread count */
;;;173            mp->suspend_thread_count --;
;;;174    
;;;175            /* enable interrupt */
;;;176            rt_hw_interrupt_enable(temp);
;;;177        }
;;;178    
;;;179        /* detach object */
;;;180        rt_object_detach(&(mp->parent));
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       rt_object_detach
;;;181    
;;;182        return RT_EOK;
000028  2000              MOVS     r0,#0
;;;183    }
00002a  bdf8              POP      {r3-r7,pc}
                  |L5.44|
00002c  f7fffffe          BL       rt_hw_interrupt_disable
000030  4605              MOV      r5,r0                 ;158
000032  6ae0              LDR      r0,[r4,#0x2c]         ;163
000034  61c6              STR      r6,[r0,#0x1c]         ;163
000036  3814              SUBS     r0,r0,#0x14           ;163
000038  f7fffffe          BL       rt_thread_resume
00003c  6b60              LDR      r0,[r4,#0x34]         ;173
00003e  1e40              SUBS     r0,r0,#1              ;173
000040  6360              STR      r0,[r4,#0x34]         ;176
000042  4628              MOV      r0,r5                 ;176
000044  f7fffffe          BL       rt_hw_interrupt_enable
000048  e7e6              B        |L5.24|
;;;184    RTM_EXPORT(rt_mp_detach);
                          ENDP

00004a  0000              DCW      0x0000
                  |L5.76|
                          DCD      ||.constdata||+0xb
                  |L5.80|
000050  6d702021          DCB      "mp != RT_NULL",0
000054  3d205254
000058  5f4e554c
00005c  4c00    
00005e  00                DCB      0
00005f  00                DCB      0

                          AREA ||i.rt_mp_free||, CODE, READONLY, ALIGN=1

                  rt_mp_free PROC
;;;414     */
;;;415    void rt_mp_free(void *block)
000000  b570              PUSH     {r4-r6,lr}
;;;416    {
;;;417        rt_uint8_t **block_ptr;
;;;418        struct rt_mempool *mp;
;;;419        struct rt_thread *thread;
;;;420        register rt_base_t level;
;;;421    
;;;422        /* get the control block of pool which the block belongs to */
;;;423        block_ptr = (rt_uint8_t **)((rt_uint8_t *)block - sizeof(rt_uint8_t *));
000002  1f05              SUBS     r5,r0,#4
;;;424        mp        = (struct rt_mempool *)*block_ptr;
;;;425    
;;;426        RT_OBJECT_HOOK_CALL(rt_mp_free_hook, (mp, block));
;;;427    
;;;428        /* disable interrupt */
;;;429        level = rt_hw_interrupt_disable();
000004  682c              LDR      r4,[r5,#0]
000006  f7fffffe          BL       rt_hw_interrupt_disable
00000a  4606              MOV      r6,r0
;;;430    
;;;431        /* increase the free block count */
;;;432        mp->block_free_count ++;
00000c  6aa0              LDR      r0,[r4,#0x28]
00000e  1c40              ADDS     r0,r0,#1
;;;433    
;;;434        /* link the block into the block list */
;;;435        *block_ptr = mp->block_list;
000010  62a0              STR      r0,[r4,#0x28]
000012  6a20              LDR      r0,[r4,#0x20]
;;;436        mp->block_list = (rt_uint8_t *)block_ptr;
000014  6028              STR      r0,[r5,#0]
;;;437    
;;;438        if (mp->suspend_thread_count > 0)
000016  6225              STR      r5,[r4,#0x20]
000018  6b60              LDR      r0,[r4,#0x34]
00001a  2800              CMP      r0,#0
00001c  d00e              BEQ      |L6.60|
;;;439        {
;;;440            /* get the suspended thread */
;;;441            thread = rt_list_entry(mp->suspend_thread.next,
;;;442                                   struct rt_thread,
;;;443                                   tlist);
;;;444    
;;;445            /* set error */
;;;446            thread->error = RT_EOK;
00001e  6ae0              LDR      r0,[r4,#0x2c]
000020  2100              MOVS     r1,#0
000022  61c1              STR      r1,[r0,#0x1c]
000024  3814              SUBS     r0,r0,#0x14
;;;447    
;;;448            /* resume thread */
;;;449            rt_thread_resume(thread);
000026  f7fffffe          BL       rt_thread_resume
;;;450    
;;;451            /* decrease suspended thread count */
;;;452            mp->suspend_thread_count --;
00002a  6b60              LDR      r0,[r4,#0x34]
00002c  1e40              SUBS     r0,r0,#1
;;;453    
;;;454            /* enable interrupt */
;;;455            rt_hw_interrupt_enable(level);
00002e  6360              STR      r0,[r4,#0x34]
000030  4630              MOV      r0,r6
000032  f7fffffe          BL       rt_hw_interrupt_enable
;;;456    
;;;457            /* do a schedule */
;;;458            rt_schedule();
000036  f7fffffe          BL       rt_schedule
;;;459    
;;;460            return;
;;;461        }
;;;462    
;;;463        /* enable interrupt */
;;;464        rt_hw_interrupt_enable(level);
;;;465    }
00003a  bd70              POP      {r4-r6,pc}
                  |L6.60|
00003c  4630              MOV      r0,r6                 ;464
00003e  f7fffffe          BL       rt_hw_interrupt_enable
000042  bd70              POP      {r4-r6,pc}
;;;466    RTM_EXPORT(rt_mp_free);
                          ENDP


                          AREA ||i.rt_mp_init||, CODE, READONLY, ALIGN=2

                  rt_mp_init PROC
;;;90      */
;;;91     rt_err_t rt_mp_init(struct rt_mempool *mp,
000000  b5ff              PUSH     {r0-r7,lr}
;;;92                         const char        *name,
;;;93                         void              *start,
;;;94                         rt_size_t          size,
;;;95                         rt_size_t          block_size)
;;;96     {
000002  b081              SUB      sp,sp,#4
000004  9d0a              LDR      r5,[sp,#0x28]
000006  461f              MOV      r7,r3
000008  4616              MOV      r6,r2
00000a  0004              MOVS     r4,r0
00000c  d104              BNE      |L7.24|
;;;97         rt_uint8_t *block_ptr;
;;;98         register rt_base_t offset;
;;;99     
;;;100        /* parameter check */
;;;101        RT_ASSERT(mp != RT_NULL);
00000e  2265              MOVS     r2,#0x65
000010  4918              LDR      r1,|L7.116|
000012  a019              ADR      r0,|L7.120|
000014  f7fffffe          BL       rt_assert_handler
                  |L7.24|
;;;102    
;;;103        /* initialize object */
;;;104        rt_object_init(&(mp->parent), RT_Object_Class_MemPool, name);
000018  2106              MOVS     r1,#6
00001a  4620              MOV      r0,r4
00001c  9a02              LDR      r2,[sp,#8]
00001e  f7fffffe          BL       rt_object_init
;;;105    
;;;106        /* initialize memory pool */
;;;107        mp->start_address = start;
;;;108        mp->size = RT_ALIGN_DOWN(size, RT_ALIGN_SIZE);
000022  1ced              ADDS     r5,r5,#3
;;;109    
;;;110        /* align the block size */
;;;111        block_size = RT_ALIGN(block_size, RT_ALIGN_SIZE);
000024  08a9              LSRS     r1,r5,#2
000026  0089              LSLS     r1,r1,#2
;;;112        mp->block_size = block_size;
000028  6166              STR      r6,[r4,#0x14]
00002a  08b8              LSRS     r0,r7,#2              ;108
00002c  61e1              STR      r1,[r4,#0x1c]
00002e  0080              LSLS     r0,r0,#2              ;108
000030  460d              MOV      r5,r1                 ;111
000032  61a0              STR      r0,[r4,#0x18]
000034  1d09              ADDS     r1,r1,#4
;;;113    
;;;114        /* align to align size byte */
;;;115        mp->block_total_count = mp->size / (mp->block_size + sizeof(rt_uint8_t *));
000036  f7fffffe          BL       __aeabi_uidivmod
;;;116        mp->block_free_count  = mp->block_total_count;
00003a  6260              STR      r0,[r4,#0x24]
;;;117    
;;;118        /* initialize suspended thread list */
;;;119        rt_list_init(&(mp->suspend_thread));
00003c  62a0              STR      r0,[r4,#0x28]
00003e  4620              MOV      r0,r4
000040  302c              ADDS     r0,r0,#0x2c
;;;120        mp->suspend_thread_count = 0;
000042  2600              MOVS     r6,#0
000044  6320              STR      r0,[r4,#0x30]
;;;121    
;;;122        /* initialize free block list */
;;;123        block_ptr = (rt_uint8_t *)mp->start_address;
000046  6366              STR      r6,[r4,#0x34]
000048  62e0              STR      r0,[r4,#0x2c]
;;;124        for (offset = 0; offset < mp->block_total_count; offset ++)
00004a  4630              MOV      r0,r6
00004c  1d29              ADDS     r1,r5,#4              ;115
00004e  6962              LDR      r2,[r4,#0x14]
000050  e006              B        |L7.96|
                  |L7.82|
;;;125        {
;;;126            *(rt_uint8_t **)(block_ptr + offset * (block_size + sizeof(rt_uint8_t *))) =
000052  1c43              ADDS     r3,r0,#1
000054  434b              MULS     r3,r1,r3
000056  189d              ADDS     r5,r3,r2
000058  4603              MOV      r3,r0
00005a  434b              MULS     r3,r1,r3
00005c  50d5              STR      r5,[r2,r3]
00005e  1c40              ADDS     r0,r0,#1
                  |L7.96|
000060  6a63              LDR      r3,[r4,#0x24]         ;124
000062  4283              CMP      r3,r0                 ;124
000064  d8f5              BHI      |L7.82|
000066  1e40              SUBS     r0,r0,#1              ;124
;;;127                (rt_uint8_t *)(block_ptr + (offset + 1) * (block_size + sizeof(rt_uint8_t *)));
;;;128        }
;;;129    
;;;130        *(rt_uint8_t **)(block_ptr + (offset - 1) * (block_size + sizeof(rt_uint8_t *))) =
000068  4348              MULS     r0,r1,r0
00006a  5016              STR      r6,[r2,r0]
;;;131            RT_NULL;
;;;132    
;;;133        mp->block_list = block_ptr;
;;;134    
;;;135        return RT_EOK;
00006c  6222              STR      r2,[r4,#0x20]
00006e  2000              MOVS     r0,#0
;;;136    }
000070  b005              ADD      sp,sp,#0x14
000072  bdf0              POP      {r4-r7,pc}
;;;137    RTM_EXPORT(rt_mp_init);
                          ENDP

                  |L7.116|
                          DCD      ||.constdata||
                  |L7.120|
000078  6d702021          DCB      "mp != RT_NULL",0
00007c  3d205254
000080  5f4e554c
000084  4c00    
000086  00                DCB      0
000087  00                DCB      0

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  72745f6d          DCB      0x72,0x74,0x5f,0x6d
000004  705f696e          DCB      0x70,0x5f,0x69,0x6e
000008  697400            DCB      0x69,0x74,0x00
                  |symbol_number.24|
00000b  72                DCB      0x72
00000c  745f6d70          DCB      0x74,0x5f,0x6d,0x70
000010  5f646574          DCB      0x5f,0x64,0x65,0x74
000014  61636800          DCB      0x61,0x63,0x68,0x00
                  |symbol_number.25|
000018  72745f6d          DCB      0x72,0x74,0x5f,0x6d
00001c  705f6372          DCB      0x70,0x5f,0x63,0x72
000020  65617465          DCB      0x65,0x61,0x74,0x65
000024  00                DCB      0x00
                  |symbol_number.26|
000025  72745f            DCB      0x72,0x74,0x5f
000028  6d705f64          DCB      0x6d,0x70,0x5f,0x64
00002c  656c6574          DCB      0x65,0x6c,0x65,0x74
000030  6500              DCB      0x65,0x00
                  |symbol_number.27|
000032  7274              DCB      0x72,0x74
000034  5f6d705f          DCB      0x5f,0x6d,0x70,0x5f
000038  616c6c6f          DCB      0x61,0x6c,0x6c,0x6f
00003c  6300              DCB      0x63,0x00
