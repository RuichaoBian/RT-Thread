; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\hid_mousekeyboard.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\hid_mousekeyboard.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I.\Libraries\Device\Nuvoton -I..\..\components\finsh -I.\Libraries\CMSIS\Include -I.\Libraries\StdDriver\inc -I..\..\include -I.\APP -I.\Drivers -I..\..\components\drivers\include -I..\..\components\drivers\include\drivers -I..\nuvoton_nuc240 -I.\Libraries\Device\Nuvoton\NUC230_240\Include -I..\..\include -I..\..\components\drivers\usb\usbdevice\class -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=521 -DRT_DEBUG --omf_browse=.\objects\hid_mousekeyboard.crf Libraries\StdDriver\src\hid_mousekeyboard.c]
                          THUMB

                          AREA ||i.EP2_Handler||, CODE, READONLY, ALIGN=2

                  EP2_Handler PROC
;;;135    
;;;136    void EP2_Handler(void)  /* Interrupt IN handler */
000000  4901              LDR      r1,|L1.8|
;;;137    {
;;;138        g_u8EP2Ready = 1;
000002  2001              MOVS     r0,#1
000004  7088              STRB     r0,[r1,#2]
;;;139    }
000006  4770              BX       lr
;;;140    
                          ENDP

                  |L1.8|
                          DCD      ||.data||

                          AREA ||i.EP3_Handler||, CODE, READONLY, ALIGN=2

                  EP3_Handler PROC
;;;140    
;;;141    void EP3_Handler(void)  /* Interrupt IN handler */
000000  4901              LDR      r1,|L2.8|
;;;142    {
;;;143        g_u8EP3Ready = 1;
000002  2001              MOVS     r0,#1
000004  70c8              STRB     r0,[r1,#3]
;;;144    }
000006  4770              BX       lr
;;;145    
                          ENDP

                  |L2.8|
                          DCD      ||.data||

                          AREA ||i.HID_ClassRequest||, CODE, READONLY, ALIGN=2

                  HID_ClassRequest PROC
;;;187    
;;;188    void HID_ClassRequest(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;189    {
;;;190        uint8_t buf[8];
;;;191    
;;;192        USBD_GetSetupPacket(buf);
000002  4668              MOV      r0,sp
000004  f7fffffe          BL       USBD_GetSetupPacket
;;;193    
;;;194        if (buf[0] & 0x80) { /* request data transfer direction */
000008  4668              MOV      r0,sp
00000a  7800              LDRB     r0,[r0,#0]
00000c  0600              LSLS     r0,r0,#24
00000e  d408              BMI      |L3.34|
;;;195            // Device to host
;;;196            switch (buf[1])
;;;197            {
;;;198                case GET_REPORT:
;;;199                case GET_IDLE:
;;;200                case GET_PROTOCOL:
;;;201                default:
;;;202                {
;;;203                    /* Setup error, stall the device */
;;;204                    USBD_SetStall(0);
;;;205                    break;
;;;206                }
;;;207            }
;;;208        }
;;;209        else {
;;;210            // Host to device
;;;211            switch (buf[1])
000010  4668              MOV      r0,sp
000012  7840              LDRB     r0,[r0,#1]
000014  2300              MOVS     r3,#0
;;;212            {
;;;213                case SET_REPORT: {
;;;214                    if (buf[3] == 3) {
;;;215                        /* Request Type = Feature */
;;;216                        USBD_SET_DATA1(EP1);
000016  4912              LDR      r1,|L3.96|
000018  2280              MOVS     r2,#0x80
00001a  2809              CMP      r0,#9                 ;211
00001c  d005              BEQ      |L3.42|
00001e  280a              CMP      r0,#0xa               ;211
000020  d019              BEQ      |L3.86|
                  |L3.34|
;;;217                        USBD_SET_PAYLOAD_LEN(EP1, 0);
;;;218                    }
;;;219                    else if(buf[3] == 2)
;;;220                    {
;;;221                        /* Request Type = Output */
;;;222                        USBD_SET_DATA1(EP1);
;;;223                        USBD_SET_PAYLOAD_LEN(EP1, buf[6]);
;;;224    
;;;225                        /* Status stage */
;;;226                        USBD_PrepareCtrlIn(0, 0);
;;;227                    }
;;;228                    break;
;;;229                }
;;;230                case SET_IDLE: {
;;;231                    /* Status stage */
;;;232                    USBD_SET_DATA1(EP0);
;;;233                    USBD_SET_PAYLOAD_LEN(EP0, 0);
;;;234                    break;
;;;235                }
;;;236                case SET_PROTOCOL:
;;;237    //          {
;;;238    //              break;
;;;239    //          }
;;;240                default: {
;;;241                    // Stall
;;;242                    /* Setup error, stall the device */
;;;243                    USBD_SetStall(0);
000022  2000              MOVS     r0,#0
000024  f7fffffe          BL       USBD_SetStall
                  |L3.40|
;;;244                    break;
;;;245                }
;;;246            }
;;;247        }
;;;248    }
000028  bd1c              POP      {r2-r4,pc}
                  |L3.42|
00002a  4668              MOV      r0,sp                 ;214
00002c  78c0              LDRB     r0,[r0,#3]            ;214
00002e  2803              CMP      r0,#3                 ;214
000030  d00c              BEQ      |L3.76|
000032  2802              CMP      r0,#2                 ;219
000034  d1f8              BNE      |L3.40|
000036  6988              LDR      r0,[r1,#0x18]         ;222
000038  4310              ORRS     r0,r0,r2              ;222
00003a  6188              STR      r0,[r1,#0x18]         ;222
00003c  4668              MOV      r0,sp                 ;223
00003e  7980              LDRB     r0,[r0,#6]            ;223
000040  6148              STR      r0,[r1,#0x14]         ;223
000042  2100              MOVS     r1,#0                 ;226
000044  4608              MOV      r0,r1                 ;226
000046  f7fffffe          BL       USBD_PrepareCtrlIn
00004a  bd1c              POP      {r2-r4,pc}
                  |L3.76|
00004c  6988              LDR      r0,[r1,#0x18]         ;216
00004e  4310              ORRS     r0,r0,r2              ;216
000050  6188              STR      r0,[r1,#0x18]         ;216
000052  614b              STR      r3,[r1,#0x14]         ;217
000054  bd1c              POP      {r2-r4,pc}
                  |L3.86|
000056  6888              LDR      r0,[r1,#8]            ;232
000058  4310              ORRS     r0,r0,r2              ;232
00005a  6088              STR      r0,[r1,#8]            ;232
00005c  604b              STR      r3,[r1,#4]            ;233
00005e  bd1c              POP      {r2-r4,pc}
;;;249    
                          ENDP

                  |L3.96|
                          DCD      0x40060500

                          AREA ||i.HID_Init||, CODE, READONLY, ALIGN=2

                  HID_Init PROC
;;;152      */
;;;153    void HID_Init(void)
000000  490c              LDR      r1,|L4.52|
;;;154    {
;;;155        /* Init setup packet buffer */
;;;156        /* Buffer range for setup packet -> [0 ~ 0x7] */
;;;157        USBD->STBUFSEG = SETUP_BUF_BASE;
000002  2000              MOVS     r0,#0
000004  6188              STR      r0,[r1,#0x18]
;;;158    
;;;159        /*****************************************************/
;;;160        /* EP0 ==> control IN endpoint, address 0 */
;;;161        USBD_CONFIG_EP(EP0, USBD_CFG_CSTALL | USBD_CFG_EPMODE_IN | 0);
000006  2109              MOVS     r1,#9
000008  480b              LDR      r0,|L4.56|
00000a  0189              LSLS     r1,r1,#6
00000c  6081              STR      r1,[r0,#8]
;;;162        /* Buffer range for EP0 */
;;;163        USBD_SET_EP_BUF_ADDR(EP0, EP0_BUF_BASE);
00000e  2108              MOVS     r1,#8
000010  6001              STR      r1,[r0,#0]
;;;164    
;;;165        /* EP1 ==> control OUT endpoint, address 0 */
;;;166        USBD_CONFIG_EP(EP1, USBD_CFG_CSTALL | USBD_CFG_EPMODE_OUT | 0);
000012  2211              MOVS     r2,#0x11
000014  0152              LSLS     r2,r2,#5
000016  6182              STR      r2,[r0,#0x18]
;;;167        /* Buffer range for EP1 */
;;;168        USBD_SET_EP_BUF_ADDR(EP1, EP1_BUF_BASE);
000018  6101              STR      r1,[r0,#0x10]
;;;169    
;;;170        /*****************************************************/
;;;171        /* EP2 ==> Interrupt IN endpoint, address 1 */
;;;172        USBD_CONFIG_EP(EP2, USBD_CFG_EPMODE_IN | HID_MOUSE_EP_NUM);
00001a  2141              MOVS     r1,#0x41
00001c  6281              STR      r1,[r0,#0x28]
;;;173        /* Buffer range for EP2 */
;;;174        USBD_SET_EP_BUF_ADDR(EP2, EP2_BUF_BASE);
00001e  2110              MOVS     r1,#0x10
000020  6201              STR      r1,[r0,#0x20]
;;;175    	
;;;176        /*****************************************************/
;;;177        /* EP3 ==> Interrupt IN endpoint, address 2 */
;;;178        USBD_CONFIG_EP(EP3, USBD_CFG_EPMODE_IN | HID_KB_EP_NUM);
000022  2142              MOVS     r1,#0x42
000024  6381              STR      r1,[r0,#0x38]
;;;179        /* Buffer range for EP3 */
;;;180        USBD_SET_EP_BUF_ADDR(EP3, EP3_BUF_BASE);
000026  2118              MOVS     r1,#0x18
000028  6301              STR      r1,[r0,#0x30]
;;;181    
;;;182        /* Start to send IN data */
;;;183        g_u8EP2Ready = 1;
00002a  4804              LDR      r0,|L4.60|
00002c  2101              MOVS     r1,#1
00002e  7081              STRB     r1,[r0,#2]
;;;184        g_u8EP3Ready = 1;
000030  70c1              STRB     r1,[r0,#3]
;;;185    
;;;186    }
000032  4770              BX       lr
;;;187    
                          ENDP

                  |L4.52|
                          DCD      0x40060000
                  |L4.56|
                          DCD      0x40060500
                  |L4.60|
                          DCD      ||.data||

                          AREA ||i.HID_UpdateKbData||, CODE, READONLY, ALIGN=2

                  HID_UpdateKbData PROC
;;;279    
;;;280    void HID_UpdateKbData(char num)
000000  b5f8              PUSH     {r3-r7,lr}
;;;281    {
;;;282        int32_t i;
;;;283        uint8_t *buf;
;;;284        uint32_t key = 0xF;
;;;285        static uint32_t preKey;
;;;286    		g_u8EP2Ready = 1;
000002  4c22              LDR      r4,|L5.140|
000004  2001              MOVS     r0,#1
000006  70a0              STRB     r0,[r4,#2]
;;;287    		buf = (uint8_t *)(USBD_BUF_BASE + USBD_GET_EP_BUF_ADDR(EP3));
000008  4b21              LDR      r3,|L5.144|
00000a  6b18              LDR      r0,[r3,#0x30]
00000c  4f21              LDR      r7,|L5.148|
;;;288    /*	
;;;289    	if((num>='a')&&(num<='z'))
;;;290    	{
;;;291    		
;;;292    		preKey = num;
;;;293    		rt_kprintf("preKey:%d,num:%d\n",preKey,num);
;;;294    		buf[2] = 0x04+(num-'a');
;;;295    		USBD_SET_PAYLOAD_LEN(EP3, 8);
;;;296    		data=255;
;;;297    	}
;;;298    	else if((num>='A')&&(num<='Z'))
;;;299    	{
;;;300    		preKey = num;
;;;301    		data=255;
;;;302    		buf[2] = 0x39;
;;;303    		USBD_SET_PAYLOAD_LEN(EP3, 8);
;;;304    		buf[2] = 0x04+(num-'A');
;;;305    		USBD_SET_PAYLOAD_LEN(EP3, 8);
;;;306    		buf[2] = 0x39;
;;;307    		USBD_SET_PAYLOAD_LEN(EP3, 8);
;;;308    	}
;;;309    	else
;;;310    	{
;;;311    		for(i = 0; i < 8; i++)
;;;312        {
;;;313    			buf[i] = 0;
;;;314    		}
;;;315    		if(num != preKey)
;;;316    		{
;;;317    			rt_kprintf("num != preKey\n");
;;;318    			preKey = num;
;;;319    			USBD_SET_PAYLOAD_LEN(EP3, 8);
;;;320    		}
;;;321    	}
;;;322    */
;;;323    	if(PE4 == 0)
00000e  4e22              LDR      r6,|L5.152|
000010  19c1              ADDS     r1,r0,r7              ;287
000012  6930              LDR      r0,[r6,#0x10]
;;;324    	{
;;;325    		preKey = PE4;
;;;326    		//buf[0] = 0x02; /* Key 'shift' */
;;;327    		buf[2] = 0x04; /* Key 'a' */
;;;328    
;;;329    		USBD_SET_PAYLOAD_LEN(EP3, 8);
000014  2508              MOVS     r5,#8
000016  2200              MOVS     r2,#0
000018  2800              CMP      r0,#0                 ;323
;;;330    	}
;;;331    	else if(PE4 == 1)
00001a  6930              LDR      r0,[r6,#0x10]
00001c  d002              BEQ      |L5.36|
00001e  2801              CMP      r0,#1
000020  d004              BEQ      |L5.44|
000022  e00d              B        |L5.64|
                  |L5.36|
000024  60a0              STR      r0,[r4,#8]            ;327  ; preKey
000026  2004              MOVS     r0,#4                 ;327
000028  7088              STRB     r0,[r1,#2]            ;327
00002a  e008              B        |L5.62|
                  |L5.44|
;;;332    	{
;;;333    		for(i = 0; i < 8; i++)
00002c  2000              MOVS     r0,#0
                  |L5.46|
;;;334        {
;;;335    			buf[i] = 0;
00002e  540a              STRB     r2,[r1,r0]
000030  1c40              ADDS     r0,r0,#1
000032  2808              CMP      r0,#8                 ;333
000034  dbfb              BLT      |L5.46|
;;;336    		}
;;;337    		if(PE4 != preKey)
000036  6930              LDR      r0,[r6,#0x10]
000038  68a1              LDR      r1,[r4,#8]  ; preKey
00003a  4288              CMP      r0,r1
00003c  d000              BEQ      |L5.64|
                  |L5.62|
;;;338    			USBD_SET_PAYLOAD_LEN(EP3, 8);
00003e  635d              STR      r5,[r3,#0x34]
                  |L5.64|
;;;339    	}
;;;340    		
;;;341    		
;;;342        if(g_u8EP3Ready == 0)
000040  78e0              LDRB     r0,[r4,#3]  ; g_u8EP3Ready
000042  2800              CMP      r0,#0
000044  d121              BNE      |L5.138|
;;;343        {
;;;344            buf = (uint8_t *)(USBD_BUF_BASE + USBD_GET_EP_BUF_ADDR(EP3));
000046  4812              LDR      r0,|L5.144|
000048  6b00              LDR      r0,[r0,#0x30]
00004a  19c6              ADDS     r6,r0,r7
;;;345    
;;;346            /* If PB.15 = 0, just report it is key 'a' */
;;;347            key = (PE->PIN & (1 << 4)) ? 0 : 1;
00004c  4813              LDR      r0,|L5.156|
00004e  6900              LDR      r0,[r0,#0x10]
000050  06c0              LSLS     r0,r0,#27
000052  17c7              ASRS     r7,r0,#31
000054  1c7f              ADDS     r7,r7,#1
;;;348            if(key == 0)    //按键没按下
000056  d00e              BEQ      |L5.118|
;;;349            {
;;;350    					//rt_kprintf("USB_no\n");
;;;351                for(i = 0; i < 8; i++)
;;;352                {
;;;353                    buf[i] = 0;
;;;354                }
;;;355    
;;;356                if(key != preKey)
;;;357                {
;;;358                    /* Trigger to note key release */
;;;359                    USBD_SET_PAYLOAD_LEN(EP3, 8);
;;;360                }			
;;;361            }
;;;362            else//按键 按下
;;;363            {	
;;;364    					 rt_kprintf("USB_input\n");
000058  a011              ADR      r0,|L5.160|
00005a  f7fffffe          BL       rt_kprintf
;;;365                preKey = key;
;;;366                buf[2] = 0x05; /* Key 'b' */
00005e  2005              MOVS     r0,#5
000060  60a7              STR      r7,[r4,#8]  ; preKey
000062  70b0              STRB     r0,[r6,#2]
;;;367    						buf[3] = 0x15; /* Key 'r' */
000064  2015              MOVS     r0,#0x15
000066  70f0              STRB     r0,[r6,#3]
;;;368    						buf[4] = 0x06; /* Key 'c' */
000068  2006              MOVS     r0,#6
00006a  7130              STRB     r0,[r6,#4]
;;;369    						buf[5] = 0x23; /* Key '6' */
00006c  2023              MOVS     r0,#0x23
00006e  7170              STRB     r0,[r6,#5]
;;;370    						//buf[6] = 0x23; /* Key '6' */
;;;371    						buf[6] = 0x58; /* Key enter */
000070  2058              MOVS     r0,#0x58
000072  71b0              STRB     r0,[r6,#6]
;;;372                USBD_SET_PAYLOAD_LEN(EP3, 8);
000074  e007              B        |L5.134|
                  |L5.118|
000076  2000              MOVS     r0,#0                 ;351
                  |L5.120|
000078  5432              STRB     r2,[r6,r0]            ;353
00007a  1c40              ADDS     r0,r0,#1              ;353
00007c  2808              CMP      r0,#8                 ;351
00007e  dbfb              BLT      |L5.120|
000080  68a0              LDR      r0,[r4,#8]            ;356  ; preKey
000082  4287              CMP      r7,r0                 ;356
000084  d001              BEQ      |L5.138|
                  |L5.134|
000086  4802              LDR      r0,|L5.144|
000088  6345              STR      r5,[r0,#0x34]         ;359
                  |L5.138|
;;;373            }
;;;374    				
;;;375        }
;;;376    }
00008a  bdf8              POP      {r3-r7,pc}
                          ENDP

                  |L5.140|
                          DCD      ||.data||
                  |L5.144|
                          DCD      0x40060500
                  |L5.148|
                          DCD      0x40060100
                  |L5.152|
                          DCD      0x50004300
                  |L5.156|
                          DCD      0x50004100
                  |L5.160|
0000a0  5553425f          DCB      "USB_input\n",0
0000a4  696e7075
0000a8  740a00  
0000ab  00                DCB      0

                          AREA ||i.HID_UpdateMouseData||, CODE, READONLY, ALIGN=2

                  HID_UpdateMouseData PROC
;;;249    
;;;250    void HID_UpdateMouseData(void)
000000  b570              PUSH     {r4-r6,lr}
;;;251    {
;;;252        uint8_t *buf;
;;;253    
;;;254        if (g_u8EP2Ready) {
000002  4a17              LDR      r2,|L6.96|
000004  7890              LDRB     r0,[r2,#2]  ; g_u8EP2Ready
000006  2800              CMP      r0,#0
000008  d029              BEQ      |L6.94|
;;;255            buf = (uint8_t *)(USBD_BUF_BASE + USBD_GET_EP_BUF_ADDR(EP2));
00000a  4e16              LDR      r6,|L6.100|
00000c  6a30              LDR      r0,[r6,#0x20]
00000e  4916              LDR      r1,|L6.104|
;;;256            mouse_mode ^= 1;
000010  2301              MOVS     r3,#1
000012  1840              ADDS     r0,r0,r1              ;255
000014  7851              LDRB     r1,[r2,#1]  ; mouse_mode
000016  4059              EORS     r1,r1,r3
000018  2300              MOVS     r3,#0
00001a  7051              STRB     r1,[r2,#1]
;;;257    
;;;258            if (mouse_mode) {
00001c  2900              CMP      r1,#0
00001e  d014              BEQ      |L6.74|
;;;259                if (move_len > 14) {
000020  7911              LDRB     r1,[r2,#4]  ; move_len
000022  290e              CMP      r1,#0xe
000024  d915              BLS      |L6.82|
;;;260                    /* Update new report data */
;;;261                    buf[0] = 0x00;
000026  7003              STRB     r3,[r0,#0]
;;;262                    buf[1] = mouse_table[mouse_idx & 0x07];
000028  7811              LDRB     r1,[r2,#0]  ; mouse_idx
00002a  4615              MOV      r5,r2
00002c  074c              LSLS     r4,r1,#29
00002e  0f64              LSRS     r4,r4,#29
000030  350c              ADDS     r5,r5,#0xc
000032  5d2c              LDRB     r4,[r5,r4]
000034  7044              STRB     r4,[r0,#1]
;;;263                    buf[2] = mouse_table[(mouse_idx + 2) & 0x07];
000036  1c8c              ADDS     r4,r1,#2
000038  0764              LSLS     r4,r4,#29
00003a  0f64              LSRS     r4,r4,#29
00003c  5d2c              LDRB     r4,[r5,r4]
00003e  7084              STRB     r4,[r0,#2]
;;;264                    buf[3] = 0x00;
000040  70c3              STRB     r3,[r0,#3]
000042  1c49              ADDS     r1,r1,#1
;;;265                    mouse_idx++;
000044  7011              STRB     r1,[r2,#0]
;;;266                    move_len = 0;
000046  7113              STRB     r3,[r2,#4]
000048  e003              B        |L6.82|
                  |L6.74|
;;;267                }
;;;268            }
;;;269            else {
;;;270                buf[0] = buf[1] = buf[2] = buf[3] = 0;
00004a  70c3              STRB     r3,[r0,#3]
00004c  7083              STRB     r3,[r0,#2]
00004e  7043              STRB     r3,[r0,#1]
000050  7003              STRB     r3,[r0,#0]
                  |L6.82|
;;;271            }
;;;272            move_len++;
000052  7910              LDRB     r0,[r2,#4]  ; move_len
000054  1c40              ADDS     r0,r0,#1
000056  7110              STRB     r0,[r2,#4]
;;;273            g_u8EP2Ready = 0;
000058  7093              STRB     r3,[r2,#2]
;;;274            /* Set transfer length and trigger IN transfer */
;;;275            USBD_SET_PAYLOAD_LEN(EP2, 4);
00005a  2004              MOVS     r0,#4
00005c  6270              STR      r0,[r6,#0x24]
                  |L6.94|
;;;276        }
;;;277    }
00005e  bd70              POP      {r4-r6,pc}
;;;278    
                          ENDP

                  |L6.96|
                          DCD      ||.data||
                  |L6.100|
                          DCD      0x40060500
                  |L6.104|
                          DCD      0x40060100

                          AREA ||i.USBD_IRQHandler||, CODE, READONLY, ALIGN=2

                  USBD_IRQHandler PROC
;;;22     extern char data;
;;;23     void USBD_IRQHandler(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;24     {
;;;25     	
;;;26         uint32_t u32IntSts;
;;;27         uint32_t u32State;
;;;28     		rt_interrupt_enter();
000002  f7fffffe          BL       rt_interrupt_enter
;;;29     		u32IntSts = USBD_GET_INT_FLAG();   //获取中断状态
000006  4d37              LDR      r5,|L7.228|
000008  686c              LDR      r4,[r5,#4]
;;;30     		u32State = USBD_GET_BUS_STATE();  //获取USB总线状态
00000a  6928              LDR      r0,[r5,#0x10]
00000c  0706              LSLS     r6,r0,#28
00000e  0f36              LSRS     r6,r6,#28
;;;31     //------------------------------------------------------------------
;;;32         if (u32IntSts & USBD_INTSTS_FLDET) {     // USB浮动检测中断状态
000010  0760              LSLS     r0,r4,#29
000012  d50b              BPL      |L7.44|
;;;33             // Floating detect
;;;34             USBD_CLR_INT_FLAG(USBD_INTSTS_FLDET);
000014  2004              MOVS     r0,#4
000016  6068              STR      r0,[r5,#4]
;;;35     
;;;36             if (USBD_IS_ATTACHED()) {    //检测电缆连接状态  返回1 为已连接    0为未链接
000018  6968              LDR      r0,[r5,#0x14]
00001a  07c0              LSLS     r0,r0,#31
;;;37                 /* USB Plug In */
;;;38                 USBD_ENABLE_USB();   //使能USB
;;;39             }
;;;40             else {
;;;41                 /* USB Un-plug */
;;;42                 USBD_DISABLE_USB();
00001c  6928              LDR      r0,[r5,#0x10]
00001e  d002              BEQ      |L7.38|
000020  2190              MOVS     r1,#0x90              ;38
000022  4308              ORRS     r0,r0,r1              ;38
000024  e001              B        |L7.42|
                  |L7.38|
000026  2180              MOVS     r1,#0x80
000028  4388              BICS     r0,r0,r1
                  |L7.42|
00002a  6128              STR      r0,[r5,#0x10]         ;38
                  |L7.44|
;;;43             }
;;;44         }
;;;45     
;;;46     //------------------------------------------------------------------
;;;47         if (u32IntSts & USBD_INTSTS_BUS) {    //USB总线事件中断状态
00002c  07e0              LSLS     r0,r4,#31
;;;48             /* Clear event flag */
;;;49             USBD_CLR_INT_FLAG(USBD_INTSTS_BUS);
00002e  2701              MOVS     r7,#1
000030  2800              CMP      r0,#0                 ;47
000032  d014              BEQ      |L7.94|
000034  606f              STR      r7,[r5,#4]
;;;50     
;;;51             if (u32State & USBD_STATE_USBRST) {   //USB总线复位
000036  07f0              LSLS     r0,r6,#31
000038  d005              BEQ      |L7.70|
;;;52                 /* Bus reset */
;;;53                 USBD_ENABLE_USB();
00003a  6928              LDR      r0,[r5,#0x10]
00003c  2190              MOVS     r1,#0x90
00003e  4308              ORRS     r0,r0,r1
000040  6128              STR      r0,[r5,#0x10]
;;;54                 USBD_SwReset();
000042  f7fffffe          BL       USBD_SwReset
                  |L7.70|
;;;55             }
;;;56             if (u32State & USBD_STATE_SUSPEND) {   //USB总线挂起
000046  07b0              LSLS     r0,r6,#30
000048  d503              BPL      |L7.82|
;;;57                 /* Enable USB but disable PHY */
;;;58                 USBD_DISABLE_PHY();
00004a  6928              LDR      r0,[r5,#0x10]
00004c  2110              MOVS     r1,#0x10
00004e  4388              BICS     r0,r0,r1
000050  6128              STR      r0,[r5,#0x10]
                  |L7.82|
;;;59             }
;;;60             if (u32State & USBD_STATE_RESUME) {  //USB总线重启
000052  0770              LSLS     r0,r6,#29
000054  d503              BPL      |L7.94|
;;;61                 /* Enable USB and enable PHY */
;;;62                 USBD_ENABLE_USB();
000056  6928              LDR      r0,[r5,#0x10]
000058  2190              MOVS     r1,#0x90
00005a  4308              ORRS     r0,r0,r1
00005c  6128              STR      r0,[r5,#0x10]
                  |L7.94|
;;;63             }
;;;64         }
;;;65     
;;;66     //------------------------------------------------------------------
;;;67         if (u32IntSts & USBD_INTSTS_USB) {    //USB事件中断状态
00005e  07a0              LSLS     r0,r4,#30
000060  d53c              BPL      |L7.220|
;;;68             // USB event
;;;69             if (u32IntSts & USBD_INTSTS_SETUP) {
000062  2c00              CMP      r4,#0
000064  da0b              BGE      |L7.126|
;;;70                 // Setup packet
;;;71                 /* Clear event flag */
;;;72                 USBD_CLR_INT_FLAG(USBD_INTSTS_SETUP);
000066  2001              MOVS     r0,#1
000068  07c0              LSLS     r0,r0,#31
00006a  6068              STR      r0,[r5,#4]
;;;73     
;;;74                 /* Clear the data IN/OUT ready flag of control end-points */
;;;75                 USBD_STOP_TRANSACTION(EP0);
00006c  481e              LDR      r0,|L7.232|
00006e  68c1              LDR      r1,[r0,#0xc]
000070  4339              ORRS     r1,r1,r7
000072  60c1              STR      r1,[r0,#0xc]
;;;76                 USBD_STOP_TRANSACTION(EP1);
000074  69c1              LDR      r1,[r0,#0x1c]
000076  4339              ORRS     r1,r1,r7
000078  61c1              STR      r1,[r0,#0x1c]
;;;77     
;;;78                 USBD_ProcessSetupPacket();
00007a  f7fffffe          BL       USBD_ProcessSetupPacket
                  |L7.126|
;;;79             }
;;;80     
;;;81             // EP events
;;;82             if (u32IntSts & USBD_INTSTS_EP0) {
00007e  03e0              LSLS     r0,r4,#15
000080  d504              BPL      |L7.140|
;;;83                 /* Clear event flag */
;;;84                 USBD_CLR_INT_FLAG(USBD_INTSTS_EP0);
000082  2001              MOVS     r0,#1
000084  0400              LSLS     r0,r0,#16
000086  6068              STR      r0,[r5,#4]
;;;85                 // control IN
;;;86                 USBD_CtrlIn();
000088  f7fffffe          BL       USBD_CtrlIn
                  |L7.140|
;;;87             }
;;;88     
;;;89             if (u32IntSts & USBD_INTSTS_EP1) {
00008c  03a0              LSLS     r0,r4,#14
00008e  d504              BPL      |L7.154|
;;;90                 /* Clear event flag */
;;;91                 USBD_CLR_INT_FLAG(USBD_INTSTS_EP1);
000090  2001              MOVS     r0,#1
000092  0440              LSLS     r0,r0,#17
000094  6068              STR      r0,[r5,#4]
;;;92     
;;;93                 // control OUT
;;;94                 USBD_CtrlOut();
000096  f7fffffe          BL       USBD_CtrlOut
                  |L7.154|
00009a  4814              LDR      r0,|L7.236|
;;;95             }
;;;96     
;;;97             if (u32IntSts & USBD_INTSTS_EP2) {
00009c  0361              LSLS     r1,r4,#13
00009e  d503              BPL      |L7.168|
;;;98                 /* Clear event flag */
;;;99                 USBD_CLR_INT_FLAG(USBD_INTSTS_EP2);
0000a0  2101              MOVS     r1,#1
0000a2  0489              LSLS     r1,r1,#18
0000a4  6069              STR      r1,[r5,#4]
0000a6  7087              STRB     r7,[r0,#2]
                  |L7.168|
;;;100                // Interrupt IN
;;;101                EP2_Handler();
;;;102            }
;;;103    
;;;104            if (u32IntSts & USBD_INTSTS_EP3) {
0000a8  0321              LSLS     r1,r4,#12
0000aa  d503              BPL      |L7.180|
;;;105                /* Clear event flag */
;;;106                USBD_CLR_INT_FLAG(USBD_INTSTS_EP3);
0000ac  2101              MOVS     r1,#1
0000ae  04c9              LSLS     r1,r1,#19
0000b0  6069              STR      r1,[r5,#4]
0000b2  70c7              STRB     r7,[r0,#3]
                  |L7.180|
;;;107                // Interrupt IN
;;;108                EP3_Handler();
;;;109            }
;;;110    
;;;111            if (u32IntSts & USBD_INTSTS_EP4) {
0000b4  02e0              LSLS     r0,r4,#11
0000b6  d502              BPL      |L7.190|
;;;112                /* Clear event flag */
;;;113                USBD_CLR_INT_FLAG(USBD_INTSTS_EP4);
0000b8  2001              MOVS     r0,#1
0000ba  0500              LSLS     r0,r0,#20
0000bc  6068              STR      r0,[r5,#4]
                  |L7.190|
;;;114            }
;;;115    
;;;116            if (u32IntSts & USBD_INTSTS_EP5) {
0000be  02a0              LSLS     r0,r4,#10
0000c0  d502              BPL      |L7.200|
;;;117                /* Clear event flag */
;;;118                USBD_CLR_INT_FLAG(USBD_INTSTS_EP5);
0000c2  2001              MOVS     r0,#1
0000c4  0540              LSLS     r0,r0,#21
0000c6  6068              STR      r0,[r5,#4]
                  |L7.200|
;;;119            }
;;;120    
;;;121            if (u32IntSts & USBD_INTSTS_EP6) {
0000c8  0260              LSLS     r0,r4,#9
0000ca  d502              BPL      |L7.210|
;;;122                /* Clear event flag */
;;;123                USBD_CLR_INT_FLAG(USBD_INTSTS_EP6);
0000cc  2001              MOVS     r0,#1
0000ce  0580              LSLS     r0,r0,#22
0000d0  6068              STR      r0,[r5,#4]
                  |L7.210|
;;;124            }
;;;125    
;;;126            if (u32IntSts & USBD_INTSTS_EP7) {
0000d2  0220              LSLS     r0,r4,#8
0000d4  d502              BPL      |L7.220|
;;;127                /* Clear event flag */
;;;128                USBD_CLR_INT_FLAG(USBD_INTSTS_EP7);
0000d6  2001              MOVS     r0,#1
0000d8  05c0              LSLS     r0,r0,#23
0000da  6068              STR      r0,[r5,#4]
                  |L7.220|
;;;129            }
;;;130        }
;;;131        /* clear unknown event */
;;;132        USBD_CLR_INT_FLAG(u32IntSts);
0000dc  606c              STR      r4,[r5,#4]
;;;133    		rt_interrupt_leave();
0000de  f7fffffe          BL       rt_interrupt_leave
;;;134    }
0000e2  bdf8              POP      {r3-r7,pc}
;;;135    
                          ENDP

                  |L7.228|
                          DCD      0x40060000
                  |L7.232|
                          DCD      0x40060500
                  |L7.236|
                          DCD      ||.data||

                          AREA ||i.USBD_SetStall||, CODE, READONLY, ALIGN=2

                  USBD_SetStall PROC
;;;544      */
;;;545    static __INLINE void USBD_SetStall(uint8_t epnum)
000000  4b0a              LDR      r3,|L8.44|
;;;546    {
;;;547        uint32_t u32CfgAddr;
;;;548        uint32_t u32Cfg;
;;;549        int i;
;;;550    
;;;551        for(i = 0; i < USBD_MAX_EP; i++)
000002  2100              MOVS     r1,#0
                  |L8.4|
;;;552        {
;;;553            u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&USBD->EP[0].CFG; /* USBD_CFG0 */
000004  010a              LSLS     r2,r1,#4
000006  18d2              ADDS     r2,r2,r3
;;;554            u32Cfg = *((__IO uint32_t *)(u32CfgAddr));
000008  6812              LDR      r2,[r2,#0]
;;;555    
;;;556            if((u32Cfg & 0xf) == epnum)
00000a  0712              LSLS     r2,r2,#28
00000c  0f12              LSRS     r2,r2,#28
00000e  4282              CMP      r2,r0
000010  d108              BNE      |L8.36|
;;;557            {
;;;558                u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&USBD->EP[0].CFGP; /* USBD_CFGP0 */
000012  0108              LSLS     r0,r1,#4
000014  4905              LDR      r1,|L8.44|
000016  1d09              ADDS     r1,r1,#4
000018  1840              ADDS     r0,r0,r1
;;;559                u32Cfg = *((__IO uint32_t *)(u32CfgAddr));
00001a  6801              LDR      r1,[r0,#0]
;;;560    
;;;561                *((__IO uint32_t *)(u32CfgAddr)) = (u32Cfg | USBD_CFGP_SSTALL);
00001c  2202              MOVS     r2,#2
00001e  4311              ORRS     r1,r1,r2
000020  6001              STR      r1,[r0,#0]
;;;562                break;
;;;563            }
;;;564        }
;;;565    }
000022  4770              BX       lr
                  |L8.36|
000024  1c49              ADDS     r1,r1,#1
000026  2908              CMP      r1,#8                 ;551
000028  dbec              BLT      |L8.4|
00002a  4770              BX       lr
;;;566    
                          ENDP

                  |L8.44|
                          DCD      0x40060508

                          AREA ||.data||, DATA, ALIGN=2

                  mouse_idx
000000  00                DCB      0x00
                  mouse_mode
000001  01                DCB      0x01
                  g_u8EP2Ready
000002  00                DCB      0x00
                  g_u8EP3Ready
000003  00                DCB      0x00
                  move_len
000004  00000000          DCB      0x00,0x00,0x00,0x00
                  preKey
                          DCD      0x00000000
                  mouse_table
00000c  f0f0f000          DCB      0xf0,0xf0,0xf0,0x00
000010  10101000          DCB      0x10,0x10,0x10,0x00

;*** Start embedded assembler ***

#line 1 "Libraries\\StdDriver\\src\\hid_mousekeyboard.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_hid_mousekeyboard_c_5c9d84fc____REV16|
#line 118 ".\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___19_hid_mousekeyboard_c_5c9d84fc____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_hid_mousekeyboard_c_5c9d84fc____REVSH|
#line 132
|__asm___19_hid_mousekeyboard_c_5c9d84fc____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
