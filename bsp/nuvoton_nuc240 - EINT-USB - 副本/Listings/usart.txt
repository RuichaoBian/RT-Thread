; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\usart.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\usart.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I.\Libraries\Device\Nuvoton -I..\..\components\finsh -I.\Libraries\CMSIS\Include -I.\Libraries\StdDriver\inc -I..\..\include -I.\APP -I.\Drivers -I..\..\components\drivers\include -I..\..\components\drivers\include\drivers -I..\nuvoton_nuc240 -I.\Libraries\Device\Nuvoton\NUC230_240\Include -I..\..\include -I..\..\components\drivers\usb\usbdevice\class -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=521 -DRT_DEBUG --omf_browse=.\objects\usart.crf Drivers\usart.c]
                          THUMB

                          AREA ||i.SendChar||, CODE, READONLY, ALIGN=1

                  SendChar PROC
;;;100     */
;;;101    void SendChar(int ch)
000000  b500              PUSH     {lr}
;;;102    {
;;;103    #if defined(DEBUG_ENABLE_SEMIHOST)
;;;104        g_buf[g_buf_len++] = ch;
;;;105        g_buf[g_buf_len] = '\0';
;;;106        if(g_buf_len + 1 >= sizeof(g_buf) || ch == '\n' || ch == '\0')
;;;107        {
;;;108            /* Send the char */
;;;109            if(SH_DoCommand(0x04, (int)g_buf, NULL) != 0)
;;;110            {
;;;111                g_buf_len = 0;
;;;112                return;
;;;113            }
;;;114            else
;;;115            {
;;;116                int i;
;;;117    
;;;118                for(i = 0; i < g_buf_len; i++)
;;;119                    SendChar_ToUART(g_buf[i]);
;;;120                g_buf_len = 0;
;;;121            }
;;;122        }
;;;123    #else
;;;124        SendChar_ToUART(ch);
000002  f7fffffe          BL       SendChar_ToUART
;;;125    #endif
;;;126    }
000006  bd00              POP      {pc}
;;;127    /**
                          ENDP


                          AREA ||i.SendChar_ToUART||, CODE, READONLY, ALIGN=2

                  SendChar_ToUART PROC
;;;23     
;;;24     void SendChar_ToUART(int ch)
000000  4906              LDR      r1,|L2.28|
                  |L2.2|
;;;25     {
;;;26     
;;;27         while(DEBUG_PORT->FSR & UART_FSR_TX_FULL_Msk);
000002  698a              LDR      r2,[r1,#0x18]
000004  0212              LSLS     r2,r2,#8
000006  d4fc              BMI      |L2.2|
;;;28         DEBUG_PORT->DATA = ch;
000008  6008              STR      r0,[r1,#0]
;;;29         if(ch == '\n')
00000a  280a              CMP      r0,#0xa
00000c  d104              BNE      |L2.24|
                  |L2.14|
;;;30         {
;;;31             while(DEBUG_PORT->FSR & UART_FSR_TX_FULL_Msk);
00000e  6988              LDR      r0,[r1,#0x18]
000010  0200              LSLS     r0,r0,#8
000012  d4fc              BMI      |L2.14|
;;;32             DEBUG_PORT->DATA = '\r';
000014  200d              MOVS     r0,#0xd
000016  6008              STR      r0,[r1,#0]
                  |L2.24|
;;;33         }
;;;34     }
000018  4770              BX       lr
;;;35     
                          ENDP

00001a  0000              DCW      0x0000
                  |L2.28|
                          DCD      0x40050000

                          AREA ||i.UART02_IRQHandler||, CODE, READONLY, ALIGN=2

                  UART02_IRQHandler PROC
;;;236    uint16_t i;
;;;237    void UART02_IRQHandler(void)
000000  b510              PUSH     {r4,lr}
;;;238    {
;;;239    	
;;;240    	/*******************************************************/
;;;241    	uint8_t u8InChar = 0xFF;
;;;242        /* enter interrupt */
;;;243        rt_interrupt_enter();
000002  f7fffffe          BL       rt_interrupt_enter
;;;244    		UART_ClearIntFlag(UART0 , UART_IER_RDA_IEN_Msk);
000006  2101              MOVS     r1,#1
000008  4804              LDR      r0,|L3.28|
00000a  f7fffffe          BL       UART_ClearIntFlag
;;;245    	
;;;246    		u8InChar = nuc240_getc(&serial0);
00000e  4804              LDR      r0,|L3.32|
000010  f7fffffe          BL       nuc240_getc
;;;247    
;;;248    		 /*if(num>=80)
;;;249    			 {
;;;250    			  nuc240_putc(&serial0, 'E');
;;;251    				num=0;
;;;252    			 }
;;;253    			else if(u8InChar=='\n')
;;;254    			 {
;;;255    				i=0;
;;;256    				while(i!=num) 
;;;257    				{
;;;258    				nuc240_putc(&serial0, rev_buf[i]);
;;;259    				i++;
;;;260    				}
;;;261    				num=0;
;;;262    			 }		
;;;263    		 else
;;;264    		 rev_buf[num++] =u8InChar;  */    
;;;265    /***************************************
;;;266    		 
;;;267    							R C
;;;268    		 
;;;269    ******************************************/		 
;;;270       // if (UART_IS_RX_READY(UART0)) {
;;;271         //   rt_hw_serial_isr(&serial0, RT_SERIAL_EVENT_RX_IND);
;;;272       // }
;;;273        /* leave interrupt */
;;;274        rt_interrupt_leave();
000014  f7fffffe          BL       rt_interrupt_leave
;;;275    }
000018  bd10              POP      {r4,pc}
;;;276    #endif /* RT_USING_UART0 */
                          ENDP

00001a  0000              DCW      0x0000
                  |L3.28|
                          DCD      0x40050000
                  |L3.32|
                          DCD      ||area_number.12||

                          AREA ||i.fputc||, CODE, READONLY, ALIGN=1

                  fputc PROC
;;;144    
;;;145    int fputc(int ch, FILE *stream)
000000  b500              PUSH     {lr}
;;;146    {
000002  4603              MOV      r3,r0
000004  f7fffffe          BL       SendChar_ToUART
;;;147        SendChar(ch);
;;;148        return ch;
000008  4618              MOV      r0,r3
;;;149    }
00000a  bd00              POP      {pc}
;;;150    static rt_err_t nuc240_configure(struct rt_serial_device *serial,struct serial_configure *cfg)
                          ENDP


                          AREA ||i.nuc240_configure||, CODE, READONLY, ALIGN=2

                  nuc240_configure PROC
;;;149    }
;;;150    static rt_err_t nuc240_configure(struct rt_serial_device *serial,struct serial_configure *cfg)
000000  b570              PUSH     {r4-r6,lr}
;;;151    {
;;;152    	UART_T* uart;
;;;153    	
;;;154    	uart = (UART_T*)serial->parent.user_data;
;;;155    #if defined(RT_USING_UART0)
;;;156    	if(uart == UART0){
000002  4c12              LDR      r4,|L5.76|
000004  6bc2              LDR      r2,[r0,#0x3c]
000006  460d              MOV      r5,r1                 ;151
000008  42a2              CMP      r2,r4
00000a  d11d              BNE      |L5.72|
;;;157    		//enable clock
;;;158    		CLK_EnableModuleClock(UART0_MODULE);
00000c  4e10              LDR      r6,|L5.80|
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       CLK_EnableModuleClock
;;;159    		/* Select UART module clock source */
;;;160        CLK_SetModuleClock(UART0_MODULE, CLK_CLKSEL1_UART_S_PLL, CLK_CLKDIV_UART(1));
000014  2101              MOVS     r1,#1
000016  2200              MOVS     r2,#0
000018  0609              LSLS     r1,r1,#24
00001a  4630              MOV      r0,r6
00001c  f7fffffe          BL       CLK_SetModuleClock
;;;161    		
;;;162    		/* Set GPB multi-function pins for UART0 RXD and TXD */
;;;163        SYS->GPB_MFP &= ~(SYS_GPB_MFP_PB0_Msk | SYS_GPB_MFP_PB1_Msk);
000020  0322              LSLS     r2,r4,#12
000022  6b50              LDR      r0,[r2,#0x34]
000024  0880              LSRS     r0,r0,#2
000026  0080              LSLS     r0,r0,#2
000028  6350              STR      r0,[r2,#0x34]
;;;164    
;;;165        SYS->GPB_MFP |= (SYS_GPB_MFP_PB0_UART0_RXD | SYS_GPB_MFP_PB1_UART0_TXD);
00002a  6b50              LDR      r0,[r2,#0x34]
00002c  2103              MOVS     r1,#3
00002e  4308              ORRS     r0,r0,r1
000030  6350              STR      r0,[r2,#0x34]
;;;166    		
;;;167    		 /* Reset UART0 module */
;;;168        SYS_ResetModule(UART0_RST);
000032  4808              LDR      r0,|L5.84|
000034  f7fffffe          BL       SYS_ResetModule
;;;169    
;;;170        /* Configure UART0 and set UART0 Baudrate */
;;;171        UART_Open(UART0, cfg->baud_rate);
000038  4620              MOV      r0,r4
00003a  6829              LDR      r1,[r5,#0]
00003c  f7fffffe          BL       UART_Open
;;;172    		
;;;173    	  /* Enable Interrupt */
;;;174        UART_EnableInt(UART0, UART_IER_RDA_IEN_Msk);
000040  2101              MOVS     r1,#1
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       UART_EnableInt
                  |L5.72|
;;;175    	}
;;;176    #endif
;;;177    
;;;178    	return RT_EOK;
000048  2000              MOVS     r0,#0
;;;179    }
00004a  bd70              POP      {r4-r6,pc}
;;;180    
                          ENDP

                  |L5.76|
                          DCD      0x40050000
                  |L5.80|
                          DCD      0x57803d10
                  |L5.84|
                          DCD      0x04000010

                          AREA ||i.nuc240_control||, CODE, READONLY, ALIGN=1

                  nuc240_control PROC
;;;180    
;;;181    static rt_err_t nuc240_control(struct rt_serial_device *serial,int cmd,void *arg){
000000  b510              PUSH     {r4,lr}
;;;182    	UART_T* uart;
;;;183    	uart = (UART_T *)serial->parent.user_data;
000002  6bc0              LDR      r0,[r0,#0x3c]
;;;184    	
;;;185    	switch(cmd)
000004  2910              CMP      r1,#0x10
000006  d005              BEQ      |L6.20|
000008  2911              CMP      r1,#0x11
00000a  d106              BNE      |L6.26|
;;;186    	{
;;;187    		case RT_DEVICE_CTRL_CLR_INT:{
;;;188    			//disable interrupt
;;;189    			UART_DisableInt(uart,UART_IER_RDA_IEN_Msk);
00000c  2101              MOVS     r1,#1
00000e  f7fffffe          BL       UART_DisableInt
;;;190    			break;
000012  e002              B        |L6.26|
                  |L6.20|
;;;191    		}
;;;192    		case RT_DEVICE_CTRL_SET_INT:{
;;;193    			UART_EnableInt(uart,UART_IER_RDA_IEN_Msk);
000014  2101              MOVS     r1,#1
000016  f7fffffe          BL       UART_EnableInt
                  |L6.26|
;;;194    			break;
;;;195    		}
;;;196    	}
;;;197    	return RT_EOK;
00001a  2000              MOVS     r0,#0
;;;198    }
00001c  bd10              POP      {r4,pc}
;;;199    
                          ENDP


                          AREA ||i.nuc240_getc||, CODE, READONLY, ALIGN=1

                  nuc240_getc PROC
;;;212    
;;;213    static int nuc240_getc(struct rt_serial_device *serial)
000000  4601              MOV      r1,r0
;;;214    {
;;;215        int ch = -1;
;;;216        UART_T* uart;
;;;217        uart = (UART_T *)serial->parent.user_data;
000002  6bc9              LDR      r1,[r1,#0x3c]
000004  2000              MOVS     r0,#0                 ;215
;;;218    
;;;219        if (UART_IS_RX_READY(uart))
000006  69ca              LDR      r2,[r1,#0x1c]
000008  43c0              MVNS     r0,r0                 ;215
00000a  07d2              LSLS     r2,r2,#31
00000c  d000              BEQ      |L7.16|
;;;220            ch = UART_READ(uart);
00000e  6808              LDR      r0,[r1,#0]
                  |L7.16|
;;;221        return ch;
;;;222    }
000010  4770              BX       lr
;;;223    
                          ENDP


                          AREA ||i.nuc240_putc||, CODE, READONLY, ALIGN=1

                  nuc240_putc PROC
;;;200    
;;;201    static int nuc240_putc(struct rt_serial_device *serial, char c)
000000  6bc0              LDR      r0,[r0,#0x3c]
;;;202    {
;;;203        UART_T* uart;
;;;204        uart = (UART_T *)serial->parent.user_data;
;;;205        if (UART_IS_TX_FULL(uart)) {
000002  6982              LDR      r2,[r0,#0x18]
000004  0212              LSLS     r2,r2,#8
000006  d502              BPL      |L8.14|
                  |L8.8|
;;;206            UART_WAIT_TX_EMPTY(uart);
000008  6982              LDR      r2,[r0,#0x18]
00000a  00d2              LSLS     r2,r2,#3
00000c  d5fc              BPL      |L8.8|
                  |L8.14|
;;;207            
;;;208        }
;;;209        UART_WRITE(uart, c);
00000e  6001              STR      r1,[r0,#0]
;;;210        return 1;
000010  2001              MOVS     r0,#1
;;;211    }
000012  4770              BX       lr
;;;212    
                          ENDP


                          AREA ||i.rt_hw_usart_init||, CODE, READONLY, ALIGN=2

                  rt_hw_usart_init PROC
;;;277    
;;;278    void rt_hw_usart_init(void)
000000  b510              PUSH     {r4,lr}
;;;279    {
;;;280    #ifdef RT_USING_UART0
;;;281        struct serial_configure config = RT_SERIAL_CONFIG_DEFAULT;//配置串口波特率等一些配置
000002  4808              LDR      r0,|L9.36|
;;;282        config.baud_rate = BAUD_RATE_115200;
;;;283        serial0.ops    = &NUC240_uart_ops;     //
000004  4b08              LDR      r3,|L9.40|
000006  6842              LDR      r2,[r0,#4]  ; <Data2>
000008  3008              ADDS     r0,r0,#8
;;;284        serial0.config = config;
00000a  6418              STR      r0,[r3,#0x40]  ; serial0
00000c  4618              MOV      r0,r3
;;;285    
;;;286        /* register UART0 device */
;;;287        rt_hw_serial_register(&serial0, "uart0",
00000e  6482              STR      r2,[r0,#0x48]  ; serial0
000010  21e1              MOVS     r1,#0xe1              ;282
000012  0249              LSLS     r1,r1,#9              ;282
000014  6441              STR      r1,[r0,#0x44]  ; serial0
000016  22ff              MOVS     r2,#0xff
000018  4b04              LDR      r3,|L9.44|
00001a  3204              ADDS     r2,#4
00001c  a104              ADR      r1,|L9.48|
00001e  f7fffffe          BL       rt_hw_serial_register
;;;288                              RT_DEVICE_FLAG_RDWR | RT_DEVICE_FLAG_INT_RX,
;;;289                              UART0);
;;;290    #endif /* RT_USING_UART0 */
;;;291     return;
;;;292    }
000022  bd10              POP      {r4,pc}
;;;293    
                          ENDP

                  |L9.36|
                          DCD      ||.constdata||
                  |L9.40|
                          DCD      ||area_number.12||
                  |L9.44|
                          DCD      0x40050000
                  |L9.48|
000030  75617274          DCB      "uart0",0
000034  3000    
000036  00                DCB      0
000037  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  rev_buf
                          %        80

                          AREA ||area_number.12||, DATA, NOINIT, ALIGN=2

                          EXPORTAS ||area_number.12||, ||.bss||
                  serial0
                          %        84

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x0001c200
000004  08000100          DCB      0x08,0x00,0x01,0x00
                  NUC240_uart_ops
                          DCD      nuc240_configure
                          DCD      nuc240_control
                          DCD      nuc240_putc
                          DCD      nuc240_getc
                          DCD      0x00000000

                          AREA ||.data||, DATA, ALIGN=1

                  num
000000  0000              DCB      0x00,0x00

                          AREA ||area_number.16||, DATA, ALIGN=1

                          EXPORTAS ||area_number.16||, ||.data||
                  i
000000  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "Drivers\\usart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___7_usart_c_871f546e____REV16|
#line 118 ".\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___7_usart_c_871f546e____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___7_usart_c_871f546e____REVSH|
#line 132
|__asm___7_usart_c_871f546e____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
