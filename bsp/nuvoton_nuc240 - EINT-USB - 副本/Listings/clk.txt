; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\clk.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\clk.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I.\Libraries\Device\Nuvoton -I..\..\components\finsh -I.\Libraries\CMSIS\Include -I.\Libraries\StdDriver\inc -I..\..\include -I.\APP -I.\Drivers -I..\..\components\drivers\include -I..\..\components\drivers\include\drivers -I..\nuvoton_nuc240 -I.\Libraries\Device\Nuvoton\NUC230_240\Include -I..\..\include -I..\..\components\drivers\usb\usbdevice\class -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=521 -DRT_DEBUG --omf_browse=.\objects\clk.crf Libraries\StdDriver\src\clk.c]
                          THUMB

                          AREA ||i.CLK_DisableCKO||, CODE, READONLY, ALIGN=2

                  CLK_DisableCKO PROC
;;;31       */
;;;32     void CLK_DisableCKO(void)
000000  b500              PUSH     {lr}
;;;33     {
;;;34         /* Disable CKO clock source */
;;;35         CLK_DisableModuleClock(FDIV_MODULE);
000002  4802              LDR      r0,|L1.12|
000004  f7fffffe          BL       CLK_DisableModuleClock
;;;36     }
000008  bd00              POP      {pc}
;;;37     
                          ENDP

00000a  0000              DCW      0x0000
                  |L1.12|
                          DCD      0x66200006

                          AREA ||i.CLK_DisableModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_DisableModuleClock PROC
;;;552      */
;;;553    void CLK_DisableModuleClock(uint32_t u32ModuleIdx)
000000  b51f              PUSH     {r0-r4,lr}
;;;554    {
;;;555        uint32_t u32OffsetTbl[4] = {0x0, 0x4, 0x2C, 0x0};
000002  4909              LDR      r1,|L2.40|
000004  c91e              LDM      r1,{r1-r4}
;;;556    
;;;557        *(volatile uint32_t *)((uint32_t)&CLK->AHBCLK + u32OffsetTbl[MODULE_APBCLK(u32ModuleIdx)])  &= ~(1 << MODULE_IP_EN_Pos(u32ModuleIdx));
000006  9403              STR      r4,[sp,#0xc]
000008  466c              MOV      r4,sp
00000a  c40e              STM      r4!,{r1-r3}
00000c  0f81              LSRS     r1,r0,#30
00000e  008a              LSLS     r2,r1,#2
000010  4669              MOV      r1,sp
000012  588a              LDR      r2,[r1,r2]
000014  4905              LDR      r1,|L2.44|
000016  1851              ADDS     r1,r2,r1
000018  684a              LDR      r2,[r1,#4]
00001a  06c3              LSLS     r3,r0,#27
00001c  0edb              LSRS     r3,r3,#27
00001e  2001              MOVS     r0,#1
000020  4098              LSLS     r0,r0,r3
000022  4382              BICS     r2,r2,r0
000024  604a              STR      r2,[r1,#4]
;;;558    }
000026  bd1f              POP      {r0-r4,pc}
;;;559    
                          ENDP

                  |L2.40|
                          DCD      ||.constdata||+0x28
                  |L2.44|
                          DCD      0x50000200

                          AREA ||i.CLK_DisablePLL||, CODE, READONLY, ALIGN=2

                  CLK_DisablePLL PROC
;;;691      */
;;;692    void CLK_DisablePLL(void)
000000  4802              LDR      r0,|L3.12|
;;;693    {
;;;694        CLK->PLLCON |= CLK_PLLCON_PD_Msk;
000002  6a01              LDR      r1,[r0,#0x20]
000004  01c2              LSLS     r2,r0,#7
000006  4311              ORRS     r1,r1,r2
000008  6201              STR      r1,[r0,#0x20]
;;;695    }
00000a  4770              BX       lr
;;;696    
                          ENDP

                  |L3.12|
                          DCD      0x50000200

                          AREA ||i.CLK_DisableSysTick||, CODE, READONLY, ALIGN=2

                  CLK_DisableSysTick PROC
;;;763      */
;;;764    void CLK_DisableSysTick(void) 
000000  4901              LDR      r1,|L4.8|
;;;765    {    
;;;766        /* Set System Tick counter disabled */
;;;767    	SysTick->CTRL = 0;    
000002  2000              MOVS     r0,#0
000004  6108              STR      r0,[r1,#0x10]
;;;768    }
000006  4770              BX       lr
;;;769    
                          ENDP

                  |L4.8|
                          DCD      0xe000e000

                          AREA ||i.CLK_DisableXtalRC||, CODE, READONLY, ALIGN=2

                  CLK_DisableXtalRC PROC
;;;460      */
;;;461    void CLK_DisableXtalRC(uint32_t u32ClkMask)
000000  4902              LDR      r1,|L5.12|
;;;462    {
;;;463        CLK->PWRCON &= ~u32ClkMask;
000002  680a              LDR      r2,[r1,#0]
000004  4382              BICS     r2,r2,r0
000006  600a              STR      r2,[r1,#0]
;;;464    }
000008  4770              BX       lr
;;;465    
                          ENDP

00000a  0000              DCW      0x0000
                  |L5.12|
                          DCD      0x50000200

                          AREA ||i.CLK_EnableCKO||, CODE, READONLY, ALIGN=2

                  CLK_EnableCKO PROC
;;;55       */
;;;56     void CLK_EnableCKO(uint32_t u32ClkSrc, uint32_t u32ClkDiv, uint32_t u32ClkDivBy1En)
000000  b530              PUSH     {r4,r5,lr}
;;;57     {
000002  4604              MOV      r4,r0
;;;58         /* CKO = clock source / 2^(u32ClkDiv + 1) */
;;;59         CLK->FRQDIV = CLK_FRQDIV_DIVIDER_EN_Msk | u32ClkDiv | (u32ClkDivBy1En << CLK_FRQDIV_DIVIDER1_Pos);
000004  0152              LSLS     r2,r2,#5
000006  430a              ORRS     r2,r2,r1
000008  2010              MOVS     r0,#0x10
00000a  4302              ORRS     r2,r2,r0
00000c  4805              LDR      r0,|L6.36|
00000e  6242              STR      r2,[r0,#0x24]
;;;60     
;;;61         /* Enable CKO clock source */
;;;62         CLK_EnableModuleClock(FDIV_MODULE);
000010  4d05              LDR      r5,|L6.40|
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       CLK_EnableModuleClock
;;;63     
;;;64         /* Select CKO clock source */
;;;65         CLK_SetModuleClock(FDIV_MODULE, u32ClkSrc, 0);
000018  2200              MOVS     r2,#0
00001a  4621              MOV      r1,r4
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       CLK_SetModuleClock
;;;66     }
000022  bd30              POP      {r4,r5,pc}
;;;67     
                          ENDP

                  |L6.36|
                          DCD      0x50000200
                  |L6.40|
                          DCD      0x66200006

                          AREA ||i.CLK_EnableModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_EnableModuleClock PROC
;;;505      */
;;;506    void CLK_EnableModuleClock(uint32_t u32ModuleIdx)
000000  b51f              PUSH     {r0-r4,lr}
;;;507    {
;;;508        uint32_t u32OffsetTbl[4] = {0x0, 0x4, 0x2C, 0x0};
000002  4909              LDR      r1,|L7.40|
000004  c91e              LDM      r1,{r1-r4}
;;;509    
;;;510        *(volatile uint32_t *)((uint32_t)&CLK->AHBCLK + u32OffsetTbl[MODULE_APBCLK(u32ModuleIdx)])  |= 1 << MODULE_IP_EN_Pos(u32ModuleIdx);
000006  9403              STR      r4,[sp,#0xc]
000008  466c              MOV      r4,sp
00000a  c40e              STM      r4!,{r1-r3}
00000c  0f81              LSRS     r1,r0,#30
00000e  008a              LSLS     r2,r1,#2
000010  4669              MOV      r1,sp
000012  588a              LDR      r2,[r1,r2]
000014  4905              LDR      r1,|L7.44|
000016  1851              ADDS     r1,r2,r1
000018  684a              LDR      r2,[r1,#4]
00001a  06c3              LSLS     r3,r0,#27
00001c  0edb              LSRS     r3,r3,#27
00001e  2001              MOVS     r0,#1
000020  4098              LSLS     r0,r0,r3
000022  4302              ORRS     r2,r2,r0
000024  604a              STR      r2,[r1,#4]
;;;511    }
000026  bd1f              POP      {r0-r4,pc}
;;;512    
                          ENDP

                  |L7.40|
                          DCD      ||.constdata||+0x18
                  |L7.44|
                          DCD      0x50000200

                          AREA ||i.CLK_EnablePLL||, CODE, READONLY, ALIGN=2

                  CLK_EnablePLL PROC
;;;570      */
;;;571    uint32_t CLK_EnablePLL(uint32_t u32PllClkSrc, uint32_t u32PllFreq)
000000  b5f0              PUSH     {r4-r7,lr}
;;;572    {
000002  0007              MOVS     r7,r0
000004  460c              MOV      r4,r1
;;;573        uint32_t u32PllSrcClk, u32NR, u32NF, u32NO, u32CLK_SRC;
;;;574        uint32_t u32Tmp, u32Tmp2, u32Tmp3, u32Min, u32MinNF, u32MinNR;
;;;575    
;;;576        /* Disable PLL first to avoid unstable when setting PLL. */
;;;577        CLK->PLLCON = CLK_PLLCON_PD_Msk;
000006  4856              LDR      r0,|L8.352|
000008  b085              SUB      sp,sp,#0x14           ;572
00000a  4954              LDR      r1,|L8.348|
00000c  6201              STR      r1,[r0,#0x20]
;;;578    
;;;579        /* PLL source clock is from HXT */
;;;580        if(u32PllClkSrc == CLK_PLLCON_PLL_SRC_HXT)
;;;581        {
;;;582            /* Enable HXT clock */
;;;583            CLK->PWRCON |= CLK_PWRCON_XTL12M_EN_Msk;
;;;584    
;;;585            /* Wait for HXT clock ready */
;;;586            CLK_WaitClockReady(CLK_CLKSTATUS_XTL12M_STB_Msk);
;;;587    
;;;588            /* Select PLL source clock from HXT */
;;;589            u32CLK_SRC = CLK_PLLCON_PLL_SRC_HXT;
;;;590            u32PllSrcClk = __HXT;
00000e  4e55              LDR      r6,|L8.356|
;;;591    
;;;592            /* u32NR start from 2 */
;;;593            u32NR = 2;
;;;594        }
;;;595    
;;;596        /* PLL source clock is from HIRC */
;;;597        else
;;;598        {
;;;599            /* Enable HIRC clock */
;;;600            CLK->PWRCON |= CLK_PWRCON_OSC22M_EN_Msk;
000010  6801              LDR      r1,[r0,#0]
000012  d013              BEQ      |L8.60|
000014  2204              MOVS     r2,#4
000016  4311              ORRS     r1,r1,r2
000018  6001              STR      r1,[r0,#0]
;;;601    
;;;602            /* Wait for HIRC clock ready */
;;;603            CLK_WaitClockReady(CLK_CLKSTATUS_OSC22M_STB_Msk);
00001a  2010              MOVS     r0,#0x10
00001c  f7fffffe          BL       CLK_WaitClockReady
;;;604    
;;;605            /* Select PLL source clock from HIRC */
;;;606            u32CLK_SRC = CLK_PLLCON_PLL_SRC_HIRC;
000020  2001              MOVS     r0,#1
000022  04c0              LSLS     r0,r0,#19
;;;607            u32PllSrcClk = __HIRC;
000024  9002              STR      r0,[sp,#8]
000026  4850              LDR      r0,|L8.360|
;;;608    
;;;609            /* u32NR start from 4 when FIN = 22.1184MHz to avoid calculation overflow */
;;;610            u32NR = 4;
000028  2504              MOVS     r5,#4
00002a  9003              STR      r0,[sp,#0xc]
                  |L8.44|
;;;611        }
;;;612    
;;;613        /* Select "NO" according to request frequency */
;;;614        if((u32PllFreq <= FREQ_200MHZ) && (u32PllFreq > FREQ_100MHZ))
00002c  484f              LDR      r0,|L8.364|
00002e  4950              LDR      r1,|L8.368|
000030  1820              ADDS     r0,r4,r0
000032  4288              CMP      r0,r1
000034  d80d              BHI      |L8.82|
;;;615        {
;;;616            u32NO = 0;
000036  2000              MOVS     r0,#0
000038  9004              STR      r0,[sp,#0x10]
00003a  e01c              B        |L8.118|
                  |L8.60|
00003c  2201              MOVS     r2,#1                 ;583
00003e  4311              ORRS     r1,r1,r2              ;583
000040  6001              STR      r1,[r0,#0]            ;583
000042  4610              MOV      r0,r2                 ;586
000044  f7fffffe          BL       CLK_WaitClockReady
000048  2000              MOVS     r0,#0                 ;589
00004a  2502              MOVS     r5,#2                 ;593
00004c  9603              STR      r6,[sp,#0xc]          ;593
00004e  9002              STR      r0,[sp,#8]            ;593
000050  e7ec              B        |L8.44|
                  |L8.82|
;;;617        }
;;;618        else if((u32PllFreq <= FREQ_100MHZ) && (u32PllFreq > FREQ_50MHZ))
000052  4848              LDR      r0,|L8.372|
000054  4948              LDR      r1,|L8.376|
000056  1820              ADDS     r0,r4,r0
000058  4288              CMP      r0,r1
00005a  d803              BHI      |L8.100|
;;;619        {
;;;620            u32NO = 1;
00005c  2001              MOVS     r0,#1
;;;621            u32PllFreq = u32PllFreq << 1;
00005e  0064              LSLS     r4,r4,#1
000060  9004              STR      r0,[sp,#0x10]
000062  e008              B        |L8.118|
                  |L8.100|
;;;622        }
;;;623        else if((u32PllFreq <= FREQ_50MHZ) && (u32PllFreq >= FREQ_25MHZ))
000064  4845              LDR      r0,|L8.380|
000066  4945              LDR      r1,|L8.380|
000068  1820              ADDS     r0,r4,r0
00006a  4249              RSBS     r1,r1,#0
00006c  4288              CMP      r0,r1
00006e  d849              BHI      |L8.260|
;;;624        {
;;;625            u32NO = 3;
000070  2003              MOVS     r0,#3
;;;626            u32PllFreq = u32PllFreq << 2;
000072  00a4              LSLS     r4,r4,#2
000074  9004              STR      r0,[sp,#0x10]
                  |L8.118|
;;;627        }
;;;628        else
;;;629        {
;;;630            /* Wrong frequency request. Just return default setting. */
;;;631            goto lexit;
;;;632        }
;;;633    
;;;634        /* Find best solution */
;;;635        u32Min = (uint32_t) - 1;
000076  2600              MOVS     r6,#0
000078  43f6              MVNS     r6,r6
;;;636        u32MinNR = 0;
00007a  2000              MOVS     r0,#0
;;;637        u32MinNF = 0;
00007c  9000              STR      r0,[sp,#0]
;;;638        for(; u32NR <= 33; u32NR++)
00007e  9001              STR      r0,[sp,#4]
000080  e021              B        |L8.198|
                  |L8.130|
;;;639        {
;;;640            u32Tmp = u32PllSrcClk / u32NR;
000082  4629              MOV      r1,r5
000084  9803              LDR      r0,[sp,#0xc]
000086  f7fffffe          BL       __aeabi_uidivmod
;;;641            if((u32Tmp > 1600000) && (u32Tmp < 15000000))
00008a  493d              LDR      r1,|L8.384|
00008c  4a3d              LDR      r2,|L8.388|
00008e  1841              ADDS     r1,r0,r1
000090  4291              CMP      r1,r2
000092  d217              BCS      |L8.196|
;;;642            {
;;;643                for(u32NF = 2; u32NF <= 513; u32NF++)
000094  2202              MOVS     r2,#2
                  |L8.150|
;;;644                {
;;;645                    u32Tmp2 = u32Tmp * u32NF;
;;;646                    if((u32Tmp2 >= 100000000) && (u32Tmp2 <= 200000000))
000096  4b35              LDR      r3,|L8.364|
000098  4601              MOV      r1,r0                 ;643
00009a  4351              MULS     r1,r2,r1              ;645
00009c  1c5b              ADDS     r3,r3,#1
00009e  18cf              ADDS     r7,r1,r3
0000a0  425b              RSBS     r3,r3,#0
0000a2  429f              CMP      r7,r3
0000a4  d80a              BHI      |L8.188|
;;;647                    {
;;;648                        u32Tmp3 = (u32Tmp2 > u32PllFreq) ? u32Tmp2 - u32PllFreq : u32PllFreq - u32Tmp2;
0000a6  42a1              CMP      r1,r4
0000a8  d901              BLS      |L8.174|
0000aa  1b0b              SUBS     r3,r1,r4
0000ac  e000              B        |L8.176|
                  |L8.174|
0000ae  1a63              SUBS     r3,r4,r1
                  |L8.176|
;;;649                        if(u32Tmp3 < u32Min)
0000b0  42b3              CMP      r3,r6
0000b2  d203              BCS      |L8.188|
;;;650                        {
;;;651                            u32Min = u32Tmp3;
0000b4  001e              MOVS     r6,r3
;;;652                            u32MinNR = u32NR;
;;;653                            u32MinNF = u32NF;
;;;654    
;;;655                            /* Break when get good results */
;;;656                            if(u32Min == 0)
0000b6  9500              STR      r5,[sp,#0]
0000b8  9201              STR      r2,[sp,#4]
0000ba  d003              BEQ      |L8.196|
                  |L8.188|
0000bc  4932              LDR      r1,|L8.392|
0000be  1c52              ADDS     r2,r2,#1              ;643
0000c0  428a              CMP      r2,r1                 ;643
0000c2  d9e8              BLS      |L8.150|
                  |L8.196|
0000c4  1c6d              ADDS     r5,r5,#1              ;643
                  |L8.198|
0000c6  2d21              CMP      r5,#0x21              ;638
0000c8  d9db              BLS      |L8.130|
;;;657                                break;
;;;658                        }
;;;659                    }
;;;660                }
;;;661            }
;;;662        }
;;;663    
;;;664        /* Enable and apply new PLL setting. */
;;;665        CLK->PLLCON = u32CLK_SRC | (u32NO << 14) | ((u32MinNR - 2) << 9) | (u32MinNF - 2);
0000ca  9804              LDR      r0,[sp,#0x10]
0000cc  9902              LDR      r1,[sp,#8]
0000ce  0380              LSLS     r0,r0,#14
0000d0  4308              ORRS     r0,r0,r1
0000d2  9900              LDR      r1,[sp,#0]
0000d4  2201              MOVS     r2,#1
0000d6  0249              LSLS     r1,r1,#9
0000d8  0292              LSLS     r2,r2,#10
0000da  1a89              SUBS     r1,r1,r2
0000dc  4308              ORRS     r0,r0,r1
0000de  9901              LDR      r1,[sp,#4]
0000e0  1e89              SUBS     r1,r1,#2
0000e2  4308              ORRS     r0,r0,r1
0000e4  491e              LDR      r1,|L8.352|
0000e6  6208              STR      r0,[r1,#0x20]
;;;666    
;;;667        /* Waiting for PLL clock stable */
;;;668        CLK_WaitClockReady(CLK_CLKSTATUS_PLL_STB_Msk);
0000e8  2004              MOVS     r0,#4
0000ea  f7fffffe          BL       CLK_WaitClockReady
;;;669    
;;;670        /* Return actual PLL output clock frequency */
;;;671        return u32PllSrcClk / ((u32NO + 1) * u32MinNR) * u32MinNF;
0000ee  9904              LDR      r1,[sp,#0x10]
0000f0  9800              LDR      r0,[sp,#0]
0000f2  1c49              ADDS     r1,r1,#1
0000f4  4341              MULS     r1,r0,r1
0000f6  9803              LDR      r0,[sp,#0xc]
0000f8  f7fffffe          BL       __aeabi_uidivmod
0000fc  9901              LDR      r1,[sp,#4]
0000fe  4348              MULS     r0,r1,r0
                  |L8.256|
;;;672    
;;;673    lexit:
;;;674    
;;;675        /* Apply default PLL setting and return */
;;;676        if(u32PllClkSrc == CLK_PLLCON_PLL_SRC_HXT)
;;;677            CLK->PLLCON = 0xC22E; /* 48MHz */
;;;678        else
;;;679            CLK->PLLCON = 0xD66F; /* 48.06498462MHz */
;;;680    
;;;681        CLK_WaitClockReady(CLK_CLKSTATUS_PLL_STB_Msk);
;;;682        return CLK_GetPLLClockFreq();
;;;683    
;;;684    }
000100  b005              ADD      sp,sp,#0x14
000102  bdf0              POP      {r4-r7,pc}
                  |L8.260|
000104  2f00              CMP      r7,#0                 ;676
000106  d00f              BEQ      |L8.296|
000108  4920              LDR      r1,|L8.396|
                  |L8.266|
00010a  4815              LDR      r0,|L8.352|
00010c  6201              STR      r1,[r0,#0x20]         ;679
00010e  2004              MOVS     r0,#4                 ;681
000110  f7fffffe          BL       CLK_WaitClockReady
000114  a01e              ADR      r0,|L8.400|
000116  6800              LDR      r0,[r0,#0]            ;681
000118  9000              STR      r0,[sp,#0]            ;681
00011a  4811              LDR      r0,|L8.352|
00011c  6a01              LDR      r1,[r0,#0x20]         ;681
00011e  1300              ASRS     r0,r0,#12             ;681
000120  4201              TST      r1,r0                 ;681
000122  d003              BEQ      |L8.300|
000124  2000              MOVS     r0,#0                 ;681
000126  e7eb              B        |L8.256|
                  |L8.296|
000128  491a              LDR      r1,|L8.404|
00012a  e7ee              B        |L8.266|
                  |L8.300|
00012c  0308              LSLS     r0,r1,#12             ;677
00012e  d500              BPL      |L8.306|
000130  4e0d              LDR      r6,|L8.360|
                  |L8.306|
000132  0388              LSLS     r0,r1,#14             ;677
000134  d501              BPL      |L8.314|
000136  4630              MOV      r0,r6                 ;677
000138  e7e2              B        |L8.256|
                  |L8.314|
00013a  0408              LSLS     r0,r1,#16
00013c  0f80              LSRS     r0,r0,#30
00013e  466a              MOV      r2,sp
000140  5c10              LDRB     r0,[r2,r0]
000142  05ca              LSLS     r2,r1,#23
000144  0489              LSLS     r1,r1,#18
000146  0ec9              LSRS     r1,r1,#27
000148  1c89              ADDS     r1,r1,#2
00014a  0dd2              LSRS     r2,r2,#23
00014c  4341              MULS     r1,r0,r1
00014e  08b0              LSRS     r0,r6,#2
000150  1c92              ADDS     r2,r2,#2
000152  4350              MULS     r0,r2,r0
000154  f7fffffe          BL       __aeabi_uidivmod
000158  0080              LSLS     r0,r0,#2
00015a  e7d1              B        |L8.256|
;;;685    
                          ENDP

                  |L8.348|
                          DCD      0x00010000
                  |L8.352|
                          DCD      0x50000200
                  |L8.356|
                          DCD      0x00b71b00
                  |L8.360|
                          DCD      0x01518000
                  |L8.364|
                          DCD      0xfa0a1eff
                  |L8.368|
                          DCD      0x05f5e0ff
                  |L8.372|
                          DCD      0xfd050f7f
                  |L8.376|
                          DCD      0x02faf07f
                  |L8.380|
                          DCD      0xfe8287c0
                  |L8.384|
                          DCD      0xffe795ff
                  |L8.388|
                          DCD      0x00cc77bf
                  |L8.392|
                          DCD      0x00000201
                  |L8.396|
                          DCD      0x0000d66f
                  |L8.400|
000190  01020204          DCB      1,2,2,4
                  |L8.404|
                          DCD      0x0000c22e

                          AREA ||i.CLK_EnableSysTick||, CODE, READONLY, ALIGN=2

                  CLK_EnableSysTick PROC
;;;736      */
;;;737    void CLK_EnableSysTick(uint32_t u32ClkSrc, uint32_t u32Count) 
000000  b570              PUSH     {r4-r6,lr}
;;;738    {
;;;739        /* Set System Tick counter disabled */
;;;740        SysTick->CTRL = 0;    
000002  4a0b              LDR      r2,|L9.48|
000004  2400              MOVS     r4,#0
000006  6114              STR      r4,[r2,#0x10]
;;;741    
;;;742        /* Set System Tick clock source */
;;;743        if( u32ClkSrc == CLK_CLKSEL0_STCLK_S_HCLK )         
000008  2804              CMP      r0,#4
00000a  d00c              BEQ      |L9.38|
;;;744            SysTick->CTRL |= SysTick_CTRL_CLKSOURCE_Msk;
;;;745        else
;;;746            CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_STCLK_S_Msk) | u32ClkSrc; 
00000c  4d09              LDR      r5,|L9.52|
00000e  692b              LDR      r3,[r5,#0x10]
000010  2638              MOVS     r6,#0x38
000012  43b3              BICS     r3,r3,r6
000014  4303              ORRS     r3,r3,r0
000016  612b              STR      r3,[r5,#0x10]
                  |L9.24|
;;;747    
;;;748        /* Set System Tick reload value */
;;;749        SysTick->LOAD = u32Count;   
000018  6151              STR      r1,[r2,#0x14]
;;;750        
;;;751        /* Clear System Tick current value and counter flag */
;;;752        SysTick->VAL = 0;           
00001a  6194              STR      r4,[r2,#0x18]
;;;753        
;;;754        /* Set System Tick interrupt enabled and counter enabled */    
;;;755        SysTick->CTRL |= SysTick_CTRL_TICKINT_Msk | SysTick_CTRL_ENABLE_Msk;       
00001c  6910              LDR      r0,[r2,#0x10]
00001e  2103              MOVS     r1,#3
000020  4308              ORRS     r0,r0,r1
000022  6110              STR      r0,[r2,#0x10]
;;;756    }
000024  bd70              POP      {r4-r6,pc}
                  |L9.38|
000026  6910              LDR      r0,[r2,#0x10]         ;744
000028  2304              MOVS     r3,#4                 ;744
00002a  4318              ORRS     r0,r0,r3              ;744
00002c  6110              STR      r0,[r2,#0x10]         ;744
00002e  e7f3              B        |L9.24|
;;;757    
                          ENDP

                  |L9.48|
                          DCD      0xe000e000
                  |L9.52|
                          DCD      0x50000200

                          AREA ||i.CLK_EnableXtalRC||, CODE, READONLY, ALIGN=2

                  CLK_EnableXtalRC PROC
;;;445      */
;;;446    void CLK_EnableXtalRC(uint32_t u32ClkMask)
000000  4902              LDR      r1,|L10.12|
;;;447    {
;;;448        CLK->PWRCON |= u32ClkMask;
000002  680a              LDR      r2,[r1,#0]
000004  4302              ORRS     r2,r2,r0
000006  600a              STR      r2,[r1,#0]
;;;449    }
000008  4770              BX       lr
;;;450    
                          ENDP

00000a  0000              DCW      0x0000
                  |L10.12|
                          DCD      0x50000200

                          AREA ||i.CLK_GetCPUFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetCPUFreq PROC
;;;149      */
;;;150    uint32_t CLK_GetCPUFreq(void)
000000  b510              PUSH     {r4,lr}
;;;151    {
;;;152        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;153        return SystemCoreClock;
000006  4801              LDR      r0,|L11.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;154    }
00000a  bd10              POP      {r4,pc}
;;;155    
                          ENDP

                  |L11.12|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetHCLKFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetHCLKFreq PROC
;;;137      */
;;;138    uint32_t CLK_GetHCLKFreq(void)
000000  b510              PUSH     {r4,lr}
;;;139    {
;;;140        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;141        return SystemCoreClock;
000006  4801              LDR      r0,|L12.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;142    }
00000a  bd10              POP      {r4,pc}
;;;143    
                          ENDP

                  |L12.12|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_GetHXTFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetHXTFreq PROC
;;;109      */
;;;110    uint32_t CLK_GetHXTFreq(void)
000000  4802              LDR      r0,|L13.12|
;;;111    {
;;;112        if(CLK->PWRCON & CLK_PWRCON_XTL12M_EN_Msk)
000002  6800              LDR      r0,[r0,#0]
000004  07c0              LSLS     r0,r0,#31
000006  d000              BEQ      |L13.10|
;;;113            return __HXT;
000008  4801              LDR      r0,|L13.16|
                  |L13.10|
;;;114        else
;;;115            return 0;
;;;116    }
00000a  4770              BX       lr
;;;117    
                          ENDP

                  |L13.12|
                          DCD      0x50000200
                  |L13.16|
                          DCD      0x00b71b00

                          AREA ||i.CLK_GetLXTFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetLXTFreq PROC
;;;123      */
;;;124    uint32_t CLK_GetLXTFreq(void)
000000  4804              LDR      r0,|L14.20|
;;;125    {
;;;126        if(CLK->PWRCON & CLK_PWRCON_XTL32K_EN_Msk)
000002  6800              LDR      r0,[r0,#0]
000004  0780              LSLS     r0,r0,#30
000006  d502              BPL      |L14.14|
;;;127            return __LXT;
000008  2001              MOVS     r0,#1
00000a  03c0              LSLS     r0,r0,#15
;;;128        else
;;;129            return 0;
;;;130    }
00000c  4770              BX       lr
                  |L14.14|
00000e  2000              MOVS     r0,#0                 ;129
000010  4770              BX       lr
;;;131    
                          ENDP

000012  0000              DCW      0x0000
                  |L14.20|
                          DCD      0x50000200

                          AREA ||i.CLK_GetPCLKFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetPCLKFreq PROC
;;;161      */
;;;162    uint32_t CLK_GetPCLKFreq(void)
000000  b510              PUSH     {r4,lr}
;;;163    {
;;;164        SystemCoreClockUpdate();
000002  f7fffffe          BL       SystemCoreClockUpdate
;;;165        return SystemCoreClock;
000006  4801              LDR      r0,|L15.12|
000008  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
;;;166    }
00000a  bd10              POP      {r4,pc}
;;;167    
                          ENDP

                  |L15.12|
                          DCD      SystemCoreClock

                          AREA ||i.CLK_Idle||, CODE, READONLY, ALIGN=2

                  CLK_Idle PROC
;;;91       */
;;;92     void CLK_Idle(void)
000000  4805              LDR      r0,|L16.24|
;;;93     {
;;;94         /* Set the processor uses sleep as its low power mode */
;;;95         SCB->SCR &= ~SCB_SCR_SLEEPDEEP_Msk;
000002  6901              LDR      r1,[r0,#0x10]
000004  2204              MOVS     r2,#4
000006  4391              BICS     r1,r1,r2
000008  6101              STR      r1,[r0,#0x10]
;;;96     
;;;97         /* Set chip in idle mode because of WFI command */
;;;98         CLK->PWRCON &= ~CLK_PWRCON_PWR_DOWN_EN_Msk;
00000a  4804              LDR      r0,|L16.28|
00000c  6801              LDR      r1,[r0,#0]
00000e  2280              MOVS     r2,#0x80
000010  4391              BICS     r1,r1,r2
000012  6001              STR      r1,[r0,#0]
;;;99     
;;;100        /* Chip enter idle mode after CPU run WFI instruction */
;;;101        __WFI();
000014  bf30              WFI      
;;;102    }
000016  4770              BX       lr
;;;103    
                          ENDP

                  |L16.24|
                          DCD      0xe000ed00
                  |L16.28|
                          DCD      0x50000200

                          AREA ||i.CLK_PowerDown||, CODE, READONLY, ALIGN=2

                  CLK_PowerDown PROC
;;;73       */
;;;74     void CLK_PowerDown(void)
000000  4806              LDR      r0,|L17.28|
;;;75     {
;;;76         /* Set the processor uses deep sleep as its low power mode */
;;;77         SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
000002  6901              LDR      r1,[r0,#0x10]
000004  2204              MOVS     r2,#4
000006  4311              ORRS     r1,r1,r2
000008  6101              STR      r1,[r0,#0x10]
;;;78     
;;;79         /* Set system Power-down enabled and Power-down entry condition */
;;;80         CLK->PWRCON |= (CLK_PWRCON_PWR_DOWN_EN_Msk | CLK_PWRCON_PD_WAIT_CPU_Msk);
00000a  4805              LDR      r0,|L17.32|
00000c  6801              LDR      r1,[r0,#0]
00000e  22ff              MOVS     r2,#0xff
000010  3281              ADDS     r2,r2,#0x81
000012  4311              ORRS     r1,r1,r2
000014  6001              STR      r1,[r0,#0]
;;;81     
;;;82         /* Chip enter Power-down mode after CPU run WFI instruction */
;;;83         __WFI();
000016  bf30              WFI      
;;;84     }
000018  4770              BX       lr
;;;85     
                          ENDP

00001a  0000              DCW      0x0000
                  |L17.28|
                          DCD      0xe000ed00
                  |L17.32|
                          DCD      0x50000200

                          AREA ||i.CLK_SetCoreClock||, CODE, READONLY, ALIGN=2

                  CLK_SetCoreClock PROC
;;;174      */
;;;175    uint32_t CLK_SetCoreClock(uint32_t u32Hclk)
000000  b5f8              PUSH     {r3-r7,lr}
;;;176    {
;;;177        uint32_t u32FomSel; /* u32FomSel=0x50(HCLK=72MHz), u32FomSel=0(HCLK=50MHz) */
;;;178        uint32_t u32Div, u32HIRCSTB;
;;;179    
;;;180        /* Read HIRC clock source stable flag */
;;;181        u32HIRCSTB = CLK->CLKSTATUS & CLK_CLKSTATUS_OSC22M_STB_Msk;
000002  492e              LDR      r1,|L18.188|
000004  68cc              LDR      r4,[r1,#0xc]
000006  2210              MOVS     r2,#0x10
;;;182    
;;;183        /* Boundary Check */
;;;184        if(u32Hclk > FREQ_72MHZ)
000008  4b2d              LDR      r3,|L18.192|
00000a  4014              ANDS     r4,r4,r2              ;181
00000c  4298              CMP      r0,r3
00000e  d901              BLS      |L18.20|
;;;185            u32Hclk = FREQ_72MHZ;
000010  4618              MOV      r0,r3
000012  e003              B        |L18.28|
                  |L18.20|
;;;186        if(u32Hclk < FREQ_25MHZ)
000014  4a2b              LDR      r2,|L18.196|
000016  4290              CMP      r0,r2
000018  d200              BCS      |L18.28|
;;;187            u32Hclk = FREQ_25MHZ;
00001a  4610              MOV      r0,r2
                  |L18.28|
;;;188    
;;;189        /* HCLK divider */
;;;190        u32Div = 1;
;;;191    
;;;192        /* Flash Access Delay */
;;;193        if(u32Hclk > FREQ_50MHZ)
00001c  4a2a              LDR      r2,|L18.200|
00001e  2501              MOVS     r5,#1                 ;190
000020  4290              CMP      r0,r2
000022  d901              BLS      |L18.40|
;;;194            u32FomSel = 0x50;
000024  2650              MOVS     r6,#0x50
000026  e000              B        |L18.42|
                  |L18.40|
;;;195        else
;;;196            u32FomSel = 0;
000028  2600              MOVS     r6,#0
                  |L18.42|
;;;197    
;;;198        /* Maximum Flash Access Delay for Safe */
;;;199        FMC->FATCON = (FMC->FATCON & (~(5 << 4))) | 0x50;
00002a  4a28              LDR      r2,|L18.204|
00002c  6992              LDR      r2,[r2,#0x18]
00002e  2750              MOVS     r7,#0x50
000030  433a              ORRS     r2,r2,r7
000032  4f26              LDR      r7,|L18.204|
000034  61ba              STR      r2,[r7,#0x18]
;;;200    
;;;201        /* Switch to HIRC for Safe. Avoid HCLK too high when applying new divider. */
;;;202        CLK->PWRCON |= CLK_PWRCON_OSC22M_EN_Msk;
000036  680a              LDR      r2,[r1,#0]
000038  2704              MOVS     r7,#4
00003a  433a              ORRS     r2,r2,r7
00003c  600a              STR      r2,[r1,#0]
                  |L18.62|
;;;203        while((CLK->CLKSTATUS & CLK_CLKSTATUS_OSC22M_STB_Msk) == 0);
00003e  68ca              LDR      r2,[r1,#0xc]
000040  06d2              LSLS     r2,r2,#27
000042  d5fc              BPL      |L18.62|
;;;204        CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLK_S_Msk)) | CLK_CLKSEL0_HCLK_S_HIRC;
000044  491d              LDR      r1,|L18.188|
000046  690a              LDR      r2,[r1,#0x10]
000048  2707              MOVS     r7,#7
00004a  433a              ORRS     r2,r2,r7
00004c  610a              STR      r2,[r1,#0x10]
;;;205    
;;;206        /* Disable PLL to Avoid PLL Unstable while Setting */
;;;207        CLK->PLLCON |= CLK_PLLCON_PD_Msk;
00004e  6a0a              LDR      r2,[r1,#0x20]
000050  01cf              LSLS     r7,r1,#7
000052  433a              ORRS     r2,r2,r7
000054  620a              STR      r2,[r1,#0x20]
;;;208    
;;;209        /* Configure PLL setting if HXT clock is enabled */
;;;210        if(CLK->PWRCON & CLK_PWRCON_XTL12M_EN_Msk)
000056  6809              LDR      r1,[r1,#0]
000058  07c9              LSLS     r1,r1,#31
00005a  d00e              BEQ      |L18.122|
;;;211        {
;;;212            if(u32Hclk == FREQ_72MHZ)
00005c  4298              CMP      r0,r3
00005e  d106              BNE      |L18.110|
;;;213            {
;;;214                /* PLL = 144MHz, HCLK = PLL / 2 (This is for using USB(48MHz) with HCLK=72MHz) */
;;;215                u32Hclk = CLK_EnablePLL(CLK_PLLCON_PLL_SRC_HXT, u32Hclk * 2);
000060  0041              LSLS     r1,r0,#1
000062  2000              MOVS     r0,#0
000064  f7fffffe          BL       CLK_EnablePLL
000068  4607              MOV      r7,r0
;;;216                u32Div = 2;
00006a  2502              MOVS     r5,#2
00006c  e00f              B        |L18.142|
                  |L18.110|
;;;217            }
;;;218            else
;;;219                u32Hclk = CLK_EnablePLL(CLK_PLLCON_PLL_SRC_HXT, u32Hclk);
00006e  4601              MOV      r1,r0
000070  2000              MOVS     r0,#0
000072  f7fffffe          BL       CLK_EnablePLL
000076  4607              MOV      r7,r0
000078  e009              B        |L18.142|
                  |L18.122|
;;;220        }
;;;221    
;;;222        /* Configure PLL setting if HXT clock is not enabled */
;;;223        else
;;;224        {
;;;225            u32Hclk = CLK_EnablePLL(CLK_PLLCON_PLL_SRC_HIRC, u32Hclk);
00007a  4601              MOV      r1,r0
00007c  2001              MOVS     r0,#1
00007e  04c0              LSLS     r0,r0,#19
000080  f7fffffe          BL       CLK_EnablePLL
000084  4607              MOV      r7,r0
;;;226    
;;;227            /* Read HIRC clock source stable flag */
;;;228            u32HIRCSTB = CLK->CLKSTATUS & CLK_CLKSTATUS_OSC22M_STB_Msk;
000086  480d              LDR      r0,|L18.188|
000088  68c4              LDR      r4,[r0,#0xc]
00008a  2010              MOVS     r0,#0x10
00008c  4004              ANDS     r4,r4,r0
                  |L18.142|
;;;229        }
;;;230    
;;;231        /* Flash Access Delay */
;;;232        FMC->FATCON = (FMC->FATCON & (~(5 << 4))) | u32FomSel;
00008e  480f              LDR      r0,|L18.204|
000090  6981              LDR      r1,[r0,#0x18]
000092  2250              MOVS     r2,#0x50
000094  4391              BICS     r1,r1,r2
000096  4331              ORRS     r1,r1,r6
000098  6181              STR      r1,[r0,#0x18]
;;;233    
;;;234        CLK_SetHCLK(CLK_CLKSEL0_HCLK_S_PLL, CLK_CLKDIV_HCLK(u32Div));
00009a  1e69              SUBS     r1,r5,#1
00009c  2002              MOVS     r0,#2
00009e  f7fffffe          BL       CLK_SetHCLK
;;;235    
;;;236        /* Disable HIRC if HIRC is disabled before setting core clock */
;;;237        if(u32HIRCSTB == 0)
0000a2  2c00              CMP      r4,#0
0000a4  d104              BNE      |L18.176|
;;;238            CLK->PWRCON &= ~CLK_PWRCON_OSC22M_EN_Msk;
0000a6  4805              LDR      r0,|L18.188|
0000a8  6802              LDR      r2,[r0,#0]
0000aa  2104              MOVS     r1,#4
0000ac  438a              BICS     r2,r2,r1
0000ae  6002              STR      r2,[r0,#0]
                  |L18.176|
;;;239    
;;;240        return u32Hclk / u32Div;
0000b0  4629              MOV      r1,r5
0000b2  4638              MOV      r0,r7
0000b4  f7fffffe          BL       __aeabi_uidivmod
;;;241    }
0000b8  bdf8              POP      {r3-r7,pc}
;;;242    
                          ENDP

0000ba  0000              DCW      0x0000
                  |L18.188|
                          DCD      0x50000200
                  |L18.192|
                          DCD      0x044aa200
                  |L18.196|
                          DCD      0x017d7840
                  |L18.200|
                          DCD      0x02faf080
                  |L18.204|
                          DCD      0x5000c000

                          AREA ||i.CLK_SetHCLK||, CODE, READONLY, ALIGN=2

                  CLK_SetHCLK PROC
;;;255      */
;;;256    void CLK_SetHCLK(uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000000  b570              PUSH     {r4-r6,lr}
;;;257    {
;;;258        uint32_t u32HIRCSTB;
;;;259    
;;;260        /* Read HIRC clock source stable flag */
;;;261        u32HIRCSTB = CLK->CLKSTATUS & CLK_CLKSTATUS_OSC22M_STB_Msk;
000002  4c10              LDR      r4,|L19.68|
000004  68e5              LDR      r5,[r4,#0xc]
000006  2610              MOVS     r6,#0x10
;;;262    
;;;263        /* Switch to HIRC for Safe. Avoid HCLK too high when applying new divider. */
;;;264        CLK->PWRCON |= CLK_PWRCON_OSC22M_EN_Msk;
000008  6822              LDR      r2,[r4,#0]
00000a  4035              ANDS     r5,r5,r6              ;261
00000c  2304              MOVS     r3,#4
00000e  431a              ORRS     r2,r2,r3
000010  6022              STR      r2,[r4,#0]
                  |L19.18|
;;;265        while((CLK->CLKSTATUS & CLK_CLKSTATUS_OSC22M_STB_Msk) == 0);
000012  68e2              LDR      r2,[r4,#0xc]
000014  06d2              LSLS     r2,r2,#27
000016  d5fc              BPL      |L19.18|
;;;266        CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLK_S_Msk)) | CLK_CLKSEL0_HCLK_S_HIRC;
000018  6922              LDR      r2,[r4,#0x10]
00001a  2307              MOVS     r3,#7
00001c  431a              ORRS     r2,r2,r3
00001e  6122              STR      r2,[r4,#0x10]
;;;267    
;;;268        /* Apply new Divider */
;;;269        CLK->CLKDIV = (CLK->CLKDIV & (~CLK_CLKDIV_HCLK_N_Msk)) | u32ClkDiv;
000020  69a2              LDR      r2,[r4,#0x18]
000022  0912              LSRS     r2,r2,#4
000024  0112              LSLS     r2,r2,#4
000026  430a              ORRS     r2,r2,r1
000028  61a2              STR      r2,[r4,#0x18]
;;;270    
;;;271        /* Switch to new HCLK source */
;;;272        CLK->CLKSEL0 = (CLK->CLKSEL0 & (~CLK_CLKSEL0_HCLK_S_Msk)) | u32ClkSrc;
00002a  6921              LDR      r1,[r4,#0x10]
00002c  4399              BICS     r1,r1,r3
00002e  4301              ORRS     r1,r1,r0
000030  6121              STR      r1,[r4,#0x10]
;;;273    
;;;274        /* Update System Core Clock */
;;;275        SystemCoreClockUpdate();
000032  f7fffffe          BL       SystemCoreClockUpdate
;;;276    
;;;277        /* Disable HIRC if HIRC is disabled before switching HCLK source */
;;;278        if(u32HIRCSTB == 0)
000036  2d00              CMP      r5,#0
000038  d102              BNE      |L19.64|
;;;279            CLK->PWRCON &= ~CLK_CLKSTATUS_OSC22M_STB_Msk;
00003a  6820              LDR      r0,[r4,#0]
00003c  43b0              BICS     r0,r0,r6
00003e  6020              STR      r0,[r4,#0]
                  |L19.64|
;;;280    }
000040  bd70              POP      {r4-r6,pc}
;;;281    
                          ENDP

000042  0000              DCW      0x0000
                  |L19.68|
                          DCD      0x50000200

                          AREA ||i.CLK_SetModuleClock||, CODE, READONLY, ALIGN=2

                  CLK_SetModuleClock PROC
;;;386    
;;;387    void CLK_SetModuleClock(uint32_t u32ModuleIdx, uint32_t u32ClkSrc, uint32_t u32ClkDiv)
000000  b5f0              PUSH     {r4-r7,lr}
;;;388    {
;;;389        uint32_t u32sel = 0, u32div = 0;
;;;390        uint32_t u32SelTbl[4] = {0x0, 0x4, 0xC, 0x24};
000002  4b2c              LDR      r3,|L20.180|
000004  b086              SUB      sp,sp,#0x18           ;388
000006  461c              MOV      r4,r3
000008  3408              ADDS     r4,r4,#8
00000a  ccf0              LDM      r4,{r4-r7}
00000c  9400              STR      r4,[sp,#0]
00000e  ac01              ADD      r4,sp,#4
000010  c4e0              STM      r4!,{r5-r7}
000012  cb18              LDM      r3,{r3,r4}
;;;391        uint32_t u32DivTbl[2] = {0x0, 0x20};
;;;392    
;;;393        if(MODULE_CLKSEL_Msk(u32ModuleIdx) != MODULE_NoMsk)
000014  9304              STR      r3,[sp,#0x10]
000016  0e43              LSRS     r3,r0,#25
000018  9405              STR      r4,[sp,#0x14]
00001a  075b              LSLS     r3,r3,#29
00001c  d034              BEQ      |L20.136|
;;;394        {
;;;395            /* Get clock select control register address */
;;;396            u32sel = (uint32_t)&CLK->CLKSEL0 + (u32SelTbl[MODULE_CLKSEL(u32ModuleIdx)]);
00001e  0083              LSLS     r3,r0,#2
000020  0f9b              LSRS     r3,r3,#30
000022  009b              LSLS     r3,r3,#2
000024  466c              MOV      r4,sp
000026  58e3              LDR      r3,[r4,r3]
000028  4c23              LDR      r4,|L20.184|
00002a  191b              ADDS     r3,r3,r4
;;;397            /* Set new clock selection setting */
;;;398            M32(u32sel) = (M32(u32sel) & (~(MODULE_CLKSEL_Msk(u32ModuleIdx) << MODULE_CLKSEL_Pos(u32ModuleIdx)))) | u32ClkSrc;
00002c  0104              LSLS     r4,r0,#4
00002e  0f65              LSRS     r5,r4,#29
000030  01c4              LSLS     r4,r0,#7
000032  0ee4              LSRS     r4,r4,#27
000034  40a5              LSLS     r5,r5,r4
000036  681c              LDR      r4,[r3,#0]
000038  43ac              BICS     r4,r4,r5
00003a  430c              ORRS     r4,r4,r1
00003c  601c              STR      r4,[r3,#0]
;;;399    
;;;400            /* We need to set CLKSEL2 ext control bit for PWM */
;;;401            if(u32ModuleIdx == PWM01_MODULE)
;;;402                CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_PWM01_S_E_Msk)) | (u32ClkSrc & CLK_CLKSEL2_PWM01_S_E_Msk);
00003e  4b1e              LDR      r3,|L20.184|
000040  4c1e              LDR      r4,|L20.188|
000042  3b10              SUBS     r3,r3,#0x10
000044  42a0              CMP      r0,r4                 ;401
000046  d107              BNE      |L20.88|
000048  69dd              LDR      r5,[r3,#0x1c]
00004a  24ff              MOVS     r4,#0xff
00004c  3401              ADDS     r4,#1
00004e  43a5              BICS     r5,r5,r4
000050  4021              ANDS     r1,r1,r4
000052  430d              ORRS     r5,r5,r1
000054  61dd              STR      r5,[r3,#0x1c]
000056  e017              B        |L20.136|
                  |L20.88|
;;;403            else if(u32ModuleIdx == PWM23_MODULE)
000058  4c19              LDR      r4,|L20.192|
00005a  42a0              CMP      r0,r4
00005c  d103              BNE      |L20.102|
;;;404                CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_PWM23_S_E_Msk)) | (u32ClkSrc & CLK_CLKSEL2_PWM23_S_E_Msk);
00005e  69dc              LDR      r4,[r3,#0x1c]
000060  2501              MOVS     r5,#1
000062  026d              LSLS     r5,r5,#9
000064  e00c              B        |L20.128|
                  |L20.102|
;;;405            else if(u32ModuleIdx == PWM45_MODULE)
000066  4c17              LDR      r4,|L20.196|
000068  42a0              CMP      r0,r4
00006a  d103              BNE      |L20.116|
;;;406                CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_PWM45_S_E_Msk)) | (u32ClkSrc & CLK_CLKSEL2_PWM45_S_E_Msk);
00006c  69dc              LDR      r4,[r3,#0x1c]
00006e  2501              MOVS     r5,#1
000070  02ad              LSLS     r5,r5,#10
000072  e005              B        |L20.128|
                  |L20.116|
;;;407            else if(u32ModuleIdx == PWM67_MODULE)
000074  4c14              LDR      r4,|L20.200|
000076  42a0              CMP      r0,r4
000078  d106              BNE      |L20.136|
;;;408                CLK->CLKSEL2 = (CLK->CLKSEL2 & (~CLK_CLKSEL2_PWM67_S_E_Msk)) | (u32ClkSrc & CLK_CLKSEL2_PWM67_S_E_Msk);
00007a  69dc              LDR      r4,[r3,#0x1c]
00007c  2501              MOVS     r5,#1
00007e  02ed              LSLS     r5,r5,#11
                  |L20.128|
000080  43ac              BICS     r4,r4,r5
000082  4029              ANDS     r1,r1,r5
000084  430c              ORRS     r4,r4,r1
000086  61dc              STR      r4,[r3,#0x1c]
                  |L20.136|
;;;409        }
;;;410    
;;;411        if(MODULE_CLKDIV_Msk(u32ModuleIdx) != MODULE_NoMsk)
000088  0a83              LSRS     r3,r0,#10
00008a  0619              LSLS     r1,r3,#24
00008c  0e09              LSRS     r1,r1,#24
00008e  d00f              BEQ      |L20.176|
;;;412        {
;;;413            /* Get clock divider control register address */
;;;414            u32div = (uint32_t)&CLK->CLKDIV + (u32DivTbl[MODULE_CLKDIV(u32ModuleIdx)]);
000090  0301              LSLS     r1,r0,#12
000092  0f89              LSRS     r1,r1,#30
000094  0089              LSLS     r1,r1,#2
000096  ac04              ADD      r4,sp,#0x10
000098  5861              LDR      r1,[r4,r1]
00009a  4c07              LDR      r4,|L20.184|
;;;415            /* Apply new divider */
;;;416            M32(u32div) = (M32(u32div) & (~(MODULE_CLKDIV_Msk(u32ModuleIdx) << MODULE_CLKDIV_Pos(u32ModuleIdx)))) | u32ClkDiv;
00009c  0580              LSLS     r0,r0,#22
00009e  3408              ADDS     r4,r4,#8              ;414
0000a0  1909              ADDS     r1,r1,r4              ;414
0000a2  b2db              UXTB     r3,r3
0000a4  0ec0              LSRS     r0,r0,#27
0000a6  4083              LSLS     r3,r3,r0
0000a8  6808              LDR      r0,[r1,#0]
0000aa  4398              BICS     r0,r0,r3
0000ac  4310              ORRS     r0,r0,r2
0000ae  6008              STR      r0,[r1,#0]
                  |L20.176|
;;;417        }
;;;418    }
0000b0  b006              ADD      sp,sp,#0x18
0000b2  bdf0              POP      {r4-r7,pc}
;;;419    
                          ENDP

                  |L20.180|
                          DCD      ||.constdata||
                  |L20.184|
                          DCD      0x50000210
                  |L20.188|
                          DCD      0x57c00014
                  |L20.192|
                          DCD      0x57e00015
                  |L20.196|
                          DCD      0x66400016
                  |L20.200|
                          DCD      0x66600017

                          AREA ||i.CLK_SetSysTickClockSrc||, CODE, READONLY, ALIGN=2

                  CLK_SetSysTickClockSrc PROC
;;;430      */
;;;431    void CLK_SetSysTickClockSrc(uint32_t u32ClkSrc)
000000  4a03              LDR      r2,|L21.16|
;;;432    {
;;;433        CLK->CLKSEL0 = (CLK->CLKSEL0 & ~CLK_CLKSEL0_STCLK_S_Msk) | u32ClkSrc;
000002  6911              LDR      r1,[r2,#0x10]
000004  2338              MOVS     r3,#0x38
000006  4399              BICS     r1,r1,r3
000008  4301              ORRS     r1,r1,r0
00000a  6111              STR      r1,[r2,#0x10]
;;;434    }
00000c  4770              BX       lr
;;;435    
                          ENDP

00000e  0000              DCW      0x0000
                  |L21.16|
                          DCD      0x50000200

                          AREA ||i.CLK_WaitClockReady||, CODE, READONLY, ALIGN=2

                  CLK_WaitClockReady PROC
;;;709      */
;;;710    uint32_t CLK_WaitClockReady(uint32_t u32ClkMask)
000000  b510              PUSH     {r4,lr}
;;;711    {
000002  4604              MOV      r4,r0
;;;712        int32_t i32TimeOutCnt = 1200000;
000004  4907              LDR      r1,|L22.36|
;;;713    
;;;714        while((CLK->CLKSTATUS & u32ClkMask) != u32ClkMask)
000006  4b08              LDR      r3,|L22.40|
000008  e005              B        |L22.22|
                  |L22.10|
;;;715        {
;;;716            if(i32TimeOutCnt-- <= 0)
00000a  460a              MOV      r2,r1
00000c  1e49              SUBS     r1,r1,#1
00000e  2a00              CMP      r2,#0
000010  dc01              BGT      |L22.22|
;;;717                return 0;
000012  2000              MOVS     r0,#0
;;;718        }
;;;719    
;;;720        return 1;
;;;721    }
000014  bd10              POP      {r4,pc}
                  |L22.22|
000016  68da              LDR      r2,[r3,#0xc]          ;714
000018  4620              MOV      r0,r4                 ;714
00001a  4390              BICS     r0,r0,r2              ;714
00001c  d1f5              BNE      |L22.10|
00001e  2001              MOVS     r0,#1                 ;720
000020  bd10              POP      {r4,pc}
;;;722    
                          ENDP

000022  0000              DCW      0x0000
                  |L22.36|
                          DCD      0x00124f80
                  |L22.40|
                          DCD      0x50000200

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00000000
                          DCD      0x00000020
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x0000000c
                          DCD      0x00000024
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x0000002c
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x0000002c
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "Libraries\\StdDriver\\src\\clk.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____REV16|
#line 118 ".\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___5_clk_c_9b5832dc____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_clk_c_9b5832dc____REVSH|
#line 132
|__asm___5_clk_c_9b5832dc____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
