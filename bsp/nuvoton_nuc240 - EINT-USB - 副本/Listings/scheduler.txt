; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\scheduler.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\scheduler.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I.\Libraries\Device\Nuvoton -I..\..\components\finsh -I.\Libraries\CMSIS\Include -I.\Libraries\StdDriver\inc -I..\..\include -I.\APP -I.\Drivers -I..\..\components\drivers\include -I..\..\components\drivers\include\drivers -I..\nuvoton_nuc240 -I.\Libraries\Device\Nuvoton\NUC230_240\Include -I..\..\include -I..\..\components\drivers\usb\usbdevice\class -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=521 -DRT_DEBUG --omf_browse=.\objects\scheduler.crf ..\..\src\scheduler.c]
                          THUMB

                          AREA ||i.rt_critical_level||, CODE, READONLY, ALIGN=2

                  rt_critical_level PROC
;;;409     */
;;;410    rt_uint16_t rt_critical_level(void)
000000  4801              LDR      r0,|L1.8|
;;;411    {
;;;412        return rt_scheduler_lock_nest;
000002  8840              LDRH     r0,[r0,#2]  ; rt_scheduler_lock_nest
000004  b280              UXTH     r0,r0
;;;413    }
000006  4770              BX       lr
;;;414    RTM_EXPORT(rt_critical_level);
                          ENDP

                  |L1.8|
                          DCD      ||.data||

                          AREA ||i.rt_enter_critical||, CODE, READONLY, ALIGN=2

                  rt_enter_critical PROC
;;;358     */
;;;359    void rt_enter_critical(void)
000000  b510              PUSH     {r4,lr}
;;;360    {
;;;361        register rt_base_t level;
;;;362    
;;;363        /* disable interrupt */
;;;364        level = rt_hw_interrupt_disable();
000002  f7fffffe          BL       rt_hw_interrupt_disable
;;;365    
;;;366        /*
;;;367         * the maximal number of nest is RT_UINT16_MAX, which is big
;;;368         * enough and does not check here
;;;369         */
;;;370        rt_scheduler_lock_nest ++;
000006  4a03              LDR      r2,|L2.20|
000008  8851              LDRH     r1,[r2,#2]  ; rt_scheduler_lock_nest
00000a  1c49              ADDS     r1,r1,#1
00000c  8051              STRH     r1,[r2,#2]
;;;371    
;;;372        /* enable interrupt */
;;;373        rt_hw_interrupt_enable(level);
00000e  f7fffffe          BL       rt_hw_interrupt_enable
;;;374    }
000012  bd10              POP      {r4,pc}
;;;375    RTM_EXPORT(rt_enter_critical);
                          ENDP

                  |L2.20|
                          DCD      ||.data||

                          AREA ||i.rt_exit_critical||, CODE, READONLY, ALIGN=2

                  rt_exit_critical PROC
;;;379     */
;;;380    void rt_exit_critical(void)
000000  b510              PUSH     {r4,lr}
;;;381    {
;;;382        register rt_base_t level;
;;;383    
;;;384        /* disable interrupt */
;;;385        level = rt_hw_interrupt_disable();
000002  f7fffffe          BL       rt_hw_interrupt_disable
;;;386    
;;;387        rt_scheduler_lock_nest --;
000006  4a08              LDR      r2,|L3.40|
000008  8851              LDRH     r1,[r2,#2]  ; rt_scheduler_lock_nest
00000a  1e49              SUBS     r1,r1,#1
00000c  b209              SXTH     r1,r1
00000e  8051              STRH     r1,[r2,#2]
;;;388    
;;;389        if (rt_scheduler_lock_nest <= 0)
000010  2900              CMP      r1,#0
000012  dc06              BGT      |L3.34|
;;;390        {
;;;391            rt_scheduler_lock_nest = 0;
000014  2100              MOVS     r1,#0
000016  8051              STRH     r1,[r2,#2]
;;;392            /* enable interrupt */
;;;393            rt_hw_interrupt_enable(level);
000018  f7fffffe          BL       rt_hw_interrupt_enable
;;;394    
;;;395            rt_schedule();
00001c  f7fffffe          BL       rt_schedule
;;;396        }
;;;397        else
;;;398        {
;;;399            /* enable interrupt */
;;;400            rt_hw_interrupt_enable(level);
;;;401        }
;;;402    }
000020  bd10              POP      {r4,pc}
                  |L3.34|
000022  f7fffffe          BL       rt_hw_interrupt_enable
000026  bd10              POP      {r4,pc}
;;;403    RTM_EXPORT(rt_exit_critical);
                          ENDP

                  |L3.40|
                          DCD      ||.data||

                          AREA ||i.rt_schedule||, CODE, READONLY, ALIGN=2

                  rt_schedule PROC
;;;191     */
;;;192    void rt_schedule(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;193    {
;;;194        rt_base_t level;
;;;195        struct rt_thread *to_thread;
;;;196        struct rt_thread *from_thread;
;;;197    
;;;198        /* disable interrupt */
;;;199        level = rt_hw_interrupt_disable();
000002  f7fffffe          BL       rt_hw_interrupt_disable
;;;200    
;;;201        /* check the scheduler is enabled or not */
;;;202        if (rt_scheduler_lock_nest == 0)
000006  4e16              LDR      r6,|L4.96|
000008  4607              MOV      r7,r0                 ;199
00000a  8870              LDRH     r0,[r6,#2]  ; rt_scheduler_lock_nest
00000c  2800              CMP      r0,#0
00000e  d11b              BNE      |L4.72|
;;;203        {
;;;204            register rt_ubase_t highest_ready_priority;
;;;205    
;;;206    #if RT_THREAD_PRIORITY_MAX <= 32
;;;207            highest_ready_priority = __rt_ffs(rt_thread_ready_priority_group) - 1;
000010  68b0              LDR      r0,[r6,#8]  ; rt_thread_ready_priority_group
000012  f7fffffe          BL       __rt_ffs
000016  1e40              SUBS     r0,r0,#1
;;;208    #else
;;;209            register rt_ubase_t number;
;;;210    
;;;211            number = __rt_ffs(rt_thread_ready_priority_group) - 1;
;;;212            highest_ready_priority = (number << 3) + __rt_ffs(rt_thread_ready_table[number]) - 1;
;;;213    #endif
;;;214    
;;;215            /* get switch to thread */
;;;216            to_thread = rt_list_entry(rt_thread_priority_table[highest_ready_priority].next,
000018  4a12              LDR      r2,|L4.100|
00001a  00c1              LSLS     r1,r0,#3
00001c  5854              LDR      r4,[r2,r1]
;;;217                                      struct rt_thread,
;;;218                                      tlist);
;;;219    
;;;220            /* if the destination thread is not the same as current thread */
;;;221            if (to_thread != rt_current_thread)
00001e  6875              LDR      r5,[r6,#4]  ; rt_current_thread
000020  3c14              SUBS     r4,r4,#0x14
000022  42ac              CMP      r4,r5
000024  d010              BEQ      |L4.72|
;;;222            {
;;;223                rt_current_priority = (rt_uint8_t)highest_ready_priority;
000026  7030              STRB     r0,[r6,#0]
;;;224                from_thread         = rt_current_thread;
;;;225                rt_current_thread   = to_thread;
;;;226    
;;;227                RT_OBJECT_HOOK_CALL(rt_scheduler_hook, (from_thread, to_thread));
;;;228    
;;;229                /* switch to new thread */
;;;230                RT_DEBUG_LOG(RT_DEBUG_SCHEDULER,
;;;231                             ("[%d]switch to priority#%d "
;;;232                              "thread:%.*s(sp:0x%p), "
;;;233                              "from thread:%.*s(sp: 0x%p)\n",
;;;234                              rt_interrupt_nest, highest_ready_priority,
;;;235                              RT_NAME_MAX, to_thread->name, to_thread->sp,
;;;236                              RT_NAME_MAX, from_thread->name, from_thread->sp));
;;;237    						rt_kprintf("from_thread->name:%s,to_thread->name:%s\n",from_thread->name,to_thread->name);
000028  4622              MOV      r2,r4
00002a  4629              MOV      r1,r5
00002c  a00e              ADR      r0,|L4.104|
00002e  6074              STR      r4,[r6,#4]  ; rt_current_thread
000030  f7fffffe          BL       rt_kprintf
;;;238    #ifdef RT_USING_OVERFLOW_CHECK
;;;239                _rt_scheduler_stack_check(to_thread);
;;;240    #endif
;;;241    
;;;242                if (rt_interrupt_nest == 0)
000034  4817              LDR      r0,|L4.148|
000036  7800              LDRB     r0,[r0,#0]  ; rt_interrupt_nest
000038  2800              CMP      r0,#0
00003a  d009              BEQ      |L4.80|
;;;243                {
;;;244                    rt_hw_context_switch((rt_uint32_t)&from_thread->sp,
;;;245                                         (rt_uint32_t)&to_thread->sp);
;;;246                }
;;;247                else
;;;248                {
;;;249                    RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("switch in interrupt\n"));
;;;250    
;;;251                    rt_hw_context_switch_interrupt((rt_uint32_t)&from_thread->sp,
00003c  4621              MOV      r1,r4
00003e  4628              MOV      r0,r5
000040  311c              ADDS     r1,r1,#0x1c
000042  301c              ADDS     r0,r0,#0x1c
000044  f7fffffe          BL       rt_hw_context_switch_interrupt
                  |L4.72|
;;;252                                                   (rt_uint32_t)&to_thread->sp);
;;;253                }
;;;254            }
;;;255        }
;;;256    
;;;257        /* enable interrupt */
;;;258        rt_hw_interrupt_enable(level);
000048  4638              MOV      r0,r7
00004a  f7fffffe          BL       rt_hw_interrupt_enable
;;;259    }
00004e  bdf8              POP      {r3-r7,pc}
                  |L4.80|
000050  4621              MOV      r1,r4                 ;244
000052  4628              MOV      r0,r5                 ;244
000054  311c              ADDS     r1,r1,#0x1c           ;244
000056  301c              ADDS     r0,r0,#0x1c           ;244
000058  f7fffffe          BL       rt_hw_context_switch
00005c  e7f4              B        |L4.72|
;;;260    
                          ENDP

00005e  0000              DCW      0x0000
                  |L4.96|
                          DCD      ||.data||
                  |L4.100|
                          DCD      ||.bss||
                  |L4.104|
000068  66726f6d          DCB      "from_thread->name:%s,to_thread->name:%s\n",0
00006c  5f746872
000070  6561642d
000074  3e6e616d
000078  653a2573
00007c  2c746f5f
000080  74687265
000084  61642d3e
000088  6e616d65
00008c  3a25730a
000090  00      
000091  00                DCB      0
000092  00                DCB      0
000093  00                DCB      0
                  |L4.148|
                          DCD      rt_interrupt_nest

                          AREA ||i.rt_schedule_insert_thread||, CODE, READONLY, ALIGN=2

                  rt_schedule_insert_thread PROC
;;;267     */
;;;268    void rt_schedule_insert_thread(struct rt_thread *thread)
000000  b570              PUSH     {r4-r6,lr}
;;;269    {
000002  0005              MOVS     r5,r0
000004  d105              BNE      |L5.18|
;;;270        register rt_base_t temp;
;;;271    
;;;272        RT_ASSERT(thread != RT_NULL);
000006  22ff              MOVS     r2,#0xff
000008  3211              ADDS     r2,r2,#0x11
00000a  4910              LDR      r1,|L5.76|
00000c  a010              ADR      r0,|L5.80|
00000e  f7fffffe          BL       rt_assert_handler
                  |L5.18|
;;;273    
;;;274        /* disable interrupt */
;;;275        temp = rt_hw_interrupt_disable();
000012  f7fffffe          BL       rt_hw_interrupt_disable
000016  4602              MOV      r2,r0
;;;276    
;;;277        /* change stat */
;;;278        thread->stat = RT_THREAD_READY;
000018  4628              MOV      r0,r5
00001a  2101              MOVS     r1,#1
00001c  3020              ADDS     r0,r0,#0x20
00001e  7501              STRB     r1,[r0,#0x14]
;;;279    
;;;280        /* insert thread to ready list */
;;;281        rt_list_insert_before(&(rt_thread_priority_table[thread->current_priority]),
000020  7d40              LDRB     r0,[r0,#0x15]
000022  4910              LDR      r1,|L5.100|
000024  00c0              LSLS     r0,r0,#3
000026  1841              ADDS     r1,r0,r1
000028  462c              MOV      r4,r5
00002a  6848              LDR      r0,[r1,#4]
00002c  3414              ADDS     r4,r4,#0x14
00002e  6004              STR      r4,[r0,#0]
000030  6848              LDR      r0,[r1,#4]
000032  61a8              STR      r0,[r5,#0x18]
000034  604c              STR      r4,[r1,#4]
;;;282                              &(thread->tlist));
;;;283    
;;;284        /* set priority mask */
;;;285    #if RT_THREAD_PRIORITY_MAX <= 32
;;;286        RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("insert thread[%.*s], the priority: %d\n",
;;;287                                          RT_NAME_MAX, thread->name, thread->current_priority));
;;;288    #else
;;;289        RT_DEBUG_LOG(RT_DEBUG_SCHEDULER,
;;;290                     ("insert thread[%.*s], the priority: %d 0x%x %d\n",
;;;291                      RT_NAME_MAX,
;;;292                      thread->name,
;;;293                      thread->number,
;;;294                      thread->number_mask,
;;;295                      thread->high_mask));
;;;296    #endif
;;;297    
;;;298    #if RT_THREAD_PRIORITY_MAX > 32
;;;299        rt_thread_ready_table[thread->number] |= thread->high_mask;
;;;300    #endif
;;;301        rt_thread_ready_priority_group |= thread->number_mask;
000036  6169              STR      r1,[r5,#0x14]
000038  490b              LDR      r1,|L5.104|
00003a  6ba8              LDR      r0,[r5,#0x38]
00003c  688b              LDR      r3,[r1,#8]  ; rt_thread_ready_priority_group
00003e  4318              ORRS     r0,r0,r3
;;;302    
;;;303        /* enable interrupt */
;;;304        rt_hw_interrupt_enable(temp);
000040  6088              STR      r0,[r1,#8]  ; rt_thread_ready_priority_group
000042  4610              MOV      r0,r2
000044  f7fffffe          BL       rt_hw_interrupt_enable
;;;305    }
000048  bd70              POP      {r4-r6,pc}
;;;306    
                          ENDP

00004a  0000              DCW      0x0000
                  |L5.76|
                          DCD      ||.constdata||
                  |L5.80|
000050  74687265          DCB      "thread != RT_NULL",0
000054  61642021
000058  3d205254
00005c  5f4e554c
000060  4c00    
000062  00                DCB      0
000063  00                DCB      0
                  |L5.100|
                          DCD      ||.bss||
                  |L5.104|
                          DCD      ||.data||

                          AREA ||i.rt_schedule_remove_thread||, CODE, READONLY, ALIGN=2

                  rt_schedule_remove_thread PROC
;;;313     */
;;;314    void rt_schedule_remove_thread(struct rt_thread *thread)
000000  b570              PUSH     {r4-r6,lr}
;;;315    {
000002  0005              MOVS     r5,r0
000004  d105              BNE      |L6.18|
;;;316        register rt_base_t temp;
;;;317    
;;;318        RT_ASSERT(thread != RT_NULL);
000006  22ff              MOVS     r2,#0xff
000008  323f              ADDS     r2,r2,#0x3f
00000a  4911              LDR      r1,|L6.80|
00000c  a011              ADR      r0,|L6.84|
00000e  f7fffffe          BL       rt_assert_handler
                  |L6.18|
;;;319    
;;;320        /* disable interrupt */
;;;321        temp = rt_hw_interrupt_disable();
000012  f7fffffe          BL       rt_hw_interrupt_disable
;;;322    
;;;323    #if RT_THREAD_PRIORITY_MAX <= 32
;;;324        RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("remove thread[%.*s], the priority: %d\n",
;;;325                                          RT_NAME_MAX, thread->name,
;;;326                                          thread->current_priority));
;;;327    #else
;;;328        RT_DEBUG_LOG(RT_DEBUG_SCHEDULER,
;;;329                     ("remove thread[%.*s], the priority: %d 0x%x %d\n",
;;;330                      RT_NAME_MAX,
;;;331                      thread->name,
;;;332                      thread->number,
;;;333                      thread->number_mask,
;;;334                      thread->high_mask));
;;;335    #endif
;;;336    
;;;337        /* remove thread from ready list */
;;;338        rt_list_remove(&(thread->tlist));
000016  462c              MOV      r4,r5
000018  4601              MOV      r1,r0                 ;321
00001a  3414              ADDS     r4,r4,#0x14
00001c  cc05              LDM      r4!,{r0,r2}
00001e  3c08              SUBS     r4,r4,#8
000020  6042              STR      r2,[r0,#4]
000022  cc05              LDM      r4!,{r0,r2}
000024  3c08              SUBS     r4,r4,#8
000026  6010              STR      r0,[r2,#0]
000028  6064              STR      r4,[r4,#4]
00002a  6024              STR      r4,[r4,#0]
;;;339        if (rt_list_isempty(&(rt_thread_priority_table[thread->current_priority])))
00002c  2035              MOVS     r0,#0x35
00002e  5d40              LDRB     r0,[r0,r5]
000030  4a0d              LDR      r2,|L6.104|
000032  00c0              LSLS     r0,r0,#3
000034  1880              ADDS     r0,r0,r2
000036  6802              LDR      r2,[r0,#0]
000038  4282              CMP      r2,r0
00003a  d104              BNE      |L6.70|
;;;340        {
;;;341    #if RT_THREAD_PRIORITY_MAX > 32
;;;342            rt_thread_ready_table[thread->number] &= ~thread->high_mask;
;;;343            if (rt_thread_ready_table[thread->number] == 0)
;;;344            {
;;;345                rt_thread_ready_priority_group &= ~thread->number_mask;
;;;346            }
;;;347    #else
;;;348            rt_thread_ready_priority_group &= ~thread->number_mask;
00003c  480b              LDR      r0,|L6.108|
00003e  6bab              LDR      r3,[r5,#0x38]
000040  6882              LDR      r2,[r0,#8]  ; rt_thread_ready_priority_group
000042  439a              BICS     r2,r2,r3
000044  6082              STR      r2,[r0,#8]  ; rt_thread_ready_priority_group
                  |L6.70|
;;;349    #endif
;;;350        }
;;;351    
;;;352        /* enable interrupt */
;;;353        rt_hw_interrupt_enable(temp);
000046  4608              MOV      r0,r1
000048  f7fffffe          BL       rt_hw_interrupt_enable
;;;354    }
00004c  bd70              POP      {r4-r6,pc}
;;;355    
                          ENDP

00004e  0000              DCW      0x0000
                  |L6.80|
                          DCD      ||.constdata||+0x1a
                  |L6.84|
000054  74687265          DCB      "thread != RT_NULL",0
000058  61642021
00005c  3d205254
000060  5f4e554c
000064  4c00    
000066  00                DCB      0
000067  00                DCB      0
                  |L6.104|
                          DCD      ||.bss||
                  |L6.108|
                          DCD      ||.data||

                          AREA ||i.rt_system_scheduler_init||, CODE, READONLY, ALIGN=2

                  rt_system_scheduler_init PROC
;;;120     */
;;;121    void rt_system_scheduler_init(void)
000000  b510              PUSH     {r4,lr}
;;;122    {
;;;123        register rt_base_t offset;
;;;124    
;;;125        rt_scheduler_lock_nest = 0;
000002  2300              MOVS     r3,#0
000004  4a09              LDR      r2,|L7.44|
;;;126    
;;;127        RT_DEBUG_LOG(RT_DEBUG_SCHEDULER, ("start scheduler: max priority 0x%02x\n",
;;;128                                          RT_THREAD_PRIORITY_MAX));
;;;129    
;;;130        for (offset = 0; offset < RT_THREAD_PRIORITY_MAX; offset ++)
;;;131        {
;;;132            rt_list_init(&rt_thread_priority_table[offset]);
000006  4c0a              LDR      r4,|L7.48|
000008  8053              STRH     r3,[r2,#2]            ;125
00000a  4618              MOV      r0,r3                 ;130
                  |L7.12|
00000c  00c1              LSLS     r1,r0,#3
00000e  1909              ADDS     r1,r1,r4
000010  6049              STR      r1,[r1,#4]
000012  1c40              ADDS     r0,r0,#1
000014  6009              STR      r1,[r1,#0]
000016  2820              CMP      r0,#0x20              ;130
000018  dbf8              BLT      |L7.12|
;;;133        }
;;;134    
;;;135        rt_current_priority = RT_THREAD_PRIORITY_MAX - 1;
00001a  201f              MOVS     r0,#0x1f
00001c  7010              STRB     r0,[r2,#0]
;;;136        rt_current_thread = RT_NULL;
;;;137    
;;;138        /* initialize ready priority group */
;;;139        rt_thread_ready_priority_group = 0;
;;;140    
;;;141    #if RT_THREAD_PRIORITY_MAX > 32
;;;142        /* initialize ready table */
;;;143        rt_memset(rt_thread_ready_table, 0, sizeof(rt_thread_ready_table));
;;;144    #endif
;;;145    
;;;146        /* initialize thread defunct */
;;;147        rt_list_init(&rt_thread_defunct);
00001e  4803              LDR      r0,|L7.44|
000020  6053              STR      r3,[r2,#4]            ;139  ; rt_current_thread
000022  300c              ADDS     r0,r0,#0xc
000024  6093              STR      r3,[r2,#8]  ; rt_thread_ready_priority_group
000026  6040              STR      r0,[r0,#4]
000028  6000              STR      r0,[r0,#0]
;;;148    }
00002a  bd10              POP      {r4,pc}
;;;149    
                          ENDP

                  |L7.44|
                          DCD      ||.data||
                  |L7.48|
                          DCD      ||.bss||

                          AREA ||i.rt_system_scheduler_start||, CODE, READONLY, ALIGN=2

                  rt_system_scheduler_start PROC
;;;154     */
;;;155    void rt_system_scheduler_start(void)
000000  b510              PUSH     {r4,lr}
;;;156    {
;;;157        register struct rt_thread *to_thread;
;;;158        register rt_ubase_t highest_ready_priority;
;;;159    
;;;160    #if RT_THREAD_PRIORITY_MAX > 32
;;;161        register rt_ubase_t number;
;;;162    
;;;163        number = __rt_ffs(rt_thread_ready_priority_group) - 1;
;;;164        highest_ready_priority = (number << 3) + __rt_ffs(rt_thread_ready_table[number]) - 1;
;;;165    #else
;;;166        highest_ready_priority = __rt_ffs(rt_thread_ready_priority_group) - 1;
000002  4c07              LDR      r4,|L8.32|
000004  68a0              LDR      r0,[r4,#8]  ; rt_thread_ready_priority_group
000006  f7fffffe          BL       __rt_ffs
00000a  1e40              SUBS     r0,r0,#1
;;;167    #endif
;;;168    
;;;169        /* get switch to thread */
;;;170        to_thread = rt_list_entry(rt_thread_priority_table[highest_ready_priority].next,
00000c  4905              LDR      r1,|L8.36|
00000e  00c0              LSLS     r0,r0,#3
000010  5808              LDR      r0,[r1,r0]
000012  3814              SUBS     r0,r0,#0x14
;;;171                                  struct rt_thread,
;;;172                                  tlist);
;;;173    
;;;174        rt_current_thread = to_thread;
000014  6060              STR      r0,[r4,#4]  ; rt_current_thread
000016  301c              ADDS     r0,r0,#0x1c
;;;175    
;;;176        /* switch to new thread */
;;;177        rt_hw_context_switch_to((rt_uint32_t)&to_thread->sp);
000018  f7fffffe          BL       rt_hw_context_switch_to
;;;178    
;;;179        /* never come back */
;;;180    }
00001c  bd10              POP      {r4,pc}
;;;181    
                          ENDP

00001e  0000              DCW      0x0000
                  |L8.32|
                          DCD      ||.data||
                  |L8.36|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  rt_thread_priority_table
                          %        256

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  72745f73          DCB      0x72,0x74,0x5f,0x73
000004  63686564          DCB      0x63,0x68,0x65,0x64
000008  756c655f          DCB      0x75,0x6c,0x65,0x5f
00000c  696e7365          DCB      0x69,0x6e,0x73,0x65
000010  72745f74          DCB      0x72,0x74,0x5f,0x74
000014  68726561          DCB      0x68,0x72,0x65,0x61
000018  6400              DCB      0x64,0x00
                  |symbol_number.31|
00001a  7274              DCB      0x72,0x74
00001c  5f736368          DCB      0x5f,0x73,0x63,0x68
000020  6564756c          DCB      0x65,0x64,0x75,0x6c
000024  655f7265          DCB      0x65,0x5f,0x72,0x65
000028  6d6f7665          DCB      0x6d,0x6f,0x76,0x65
00002c  5f746872          DCB      0x5f,0x74,0x68,0x72
000030  65616400          DCB      0x65,0x61,0x64,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  rt_current_priority
000000  0000              DCB      0x00,0x00
                  rt_scheduler_lock_nest
000002  0000              DCB      0x00,0x00
                  rt_current_thread
                          DCD      0x00000000
                  rt_thread_ready_priority_group
                          DCD      0x00000000
                  rt_thread_defunct
                          %        8
