; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\ringbuffer.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\ringbuffer.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I.\Libraries\Device\Nuvoton -I..\..\components\finsh -I.\Libraries\CMSIS\Include -I.\Libraries\StdDriver\inc -I..\..\include -I.\APP -I.\Drivers -I..\..\components\drivers\include -I..\..\components\drivers\include\drivers -I..\nuvoton_nuc240 -I.\Libraries\Device\Nuvoton\NUC230_240\Include -I..\..\include -I..\..\components\drivers\usb\usbdevice\class -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=521 -DRT_DEBUG --omf_browse=.\objects\ringbuffer.crf ..\..\components\drivers\src\ringbuffer.c]
                          THUMB

                          AREA ||i.rt_ringbuffer_data_len||, CODE, READONLY, ALIGN=1

                  rt_ringbuffer_data_len PROC
;;;225    /** return the size of data in rb */
;;;226    rt_inline rt_uint16_t rt_ringbuffer_data_len(struct rt_ringbuffer *rb)
000000  b510              PUSH     {r4,lr}
;;;227    {
000002  4604              MOV      r4,r0
;;;228        switch (rt_ringbuffer_status(rb))
000004  f7fffffe          BL       rt_ringbuffer_status
000008  2800              CMP      r0,#0
00000a  d00b              BEQ      |L1.36|
00000c  2801              CMP      r0,#1
00000e  d00a              BEQ      |L1.38|
;;;229        {
;;;230        case RT_RINGBUFFER_EMPTY:
;;;231            return 0;
;;;232        case RT_RINGBUFFER_FULL:
;;;233            return rb->buffer_size;
;;;234        case RT_RINGBUFFER_HALFFULL:
;;;235        default:
;;;236            if (rb->write_index > rb->read_index)
000010  88e0              LDRH     r0,[r4,#6]
000012  0841              LSRS     r1,r0,#1
000014  88a0              LDRH     r0,[r4,#4]
000016  0840              LSRS     r0,r0,#1
000018  4281              CMP      r1,r0
00001a  d801              BHI      |L1.32|
;;;237                return rb->write_index - rb->read_index;
;;;238            else
;;;239                return rb->buffer_size - (rb->read_index - rb->write_index);
00001c  1a40              SUBS     r0,r0,r1
00001e  8921              LDRH     r1,[r4,#8]
                  |L1.32|
000020  1a08              SUBS     r0,r1,r0              ;237
000022  b280              UXTH     r0,r0                 ;237
                  |L1.36|
;;;240        };
;;;241    }
000024  bd10              POP      {r4,pc}
                  |L1.38|
000026  8920              LDRH     r0,[r4,#8]            ;233
000028  bd10              POP      {r4,pc}
;;;242    
                          ENDP


                          AREA ||i.rt_ringbuffer_get||, CODE, READONLY, ALIGN=2

                  rt_ringbuffer_get PROC
;;;149     */
;;;150    rt_size_t rt_ringbuffer_get(struct rt_ringbuffer *rb,
000000  b570              PUSH     {r4-r6,lr}
;;;151                                rt_uint8_t           *ptr,
;;;152                                rt_uint16_t           length)
;;;153    {
000002  4615              MOV      r5,r2
000004  460e              MOV      r6,r1
000006  0004              MOVS     r4,r0
000008  d104              BNE      |L2.20|
;;;154        rt_size_t size;
;;;155    
;;;156        RT_ASSERT(rb != RT_NULL);
00000a  229c              MOVS     r2,#0x9c
00000c  491d              LDR      r1,|L2.132|
00000e  a01e              ADR      r0,|L2.136|
000010  f7fffffe          BL       rt_assert_handler
                  |L2.20|
;;;157    
;;;158        /* whether has enough data  */
;;;159        size = rt_ringbuffer_data_len(rb);
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       rt_ringbuffer_data_len
;;;160    
;;;161        /* no data */
;;;162        if (size == 0)
00001a  2800              CMP      r0,#0
00001c  d031              BEQ      |L2.130|
;;;163            return 0;
;;;164    
;;;165        /* less data */
;;;166        if (size < length)
00001e  42a8              CMP      r0,r5
000020  d200              BCS      |L2.36|
;;;167            length = size;
000022  4605              MOV      r5,r0
                  |L2.36|
;;;168    
;;;169        if (rb->buffer_size - rb->read_index > length)
000024  2108              MOVS     r1,#8
000026  88a0              LDRH     r0,[r4,#4]
000028  5e61              LDRSH    r1,[r4,r1]
00002a  0840              LSRS     r0,r0,#1
00002c  1a0a              SUBS     r2,r1,r0
00002e  6821              LDR      r1,[r4,#0]
000030  42aa              CMP      r2,r5
000032  dd0b              BLE      |L2.76|
;;;170        {
;;;171            /* copy all of data */
;;;172            memcpy(ptr, &rb->buffer_ptr[rb->read_index], length);
000034  1809              ADDS     r1,r1,r0
000036  462a              MOV      r2,r5
000038  4630              MOV      r0,r6
00003a  f7fffffe          BL       __aeabi_memcpy
;;;173            /* this should not cause overflow because there is enough space for
;;;174             * length of data in current mirror */
;;;175            rb->read_index += length;
00003e  88a0              LDRH     r0,[r4,#4]
000040  07c1              LSLS     r1,r0,#31
000042  0840              LSRS     r0,r0,#1
000044  0fc9              LSRS     r1,r1,#31
000046  1940              ADDS     r0,r0,r5
000048  0040              LSLS     r0,r0,#1
;;;176            return length;
00004a  e017              B        |L2.124|
                  |L2.76|
;;;177        }
;;;178    
;;;179        memcpy(&ptr[0],
00004c  1809              ADDS     r1,r1,r0
00004e  4630              MOV      r0,r6
000050  f7fffffe          BL       __aeabi_memcpy
;;;180               &rb->buffer_ptr[rb->read_index],
;;;181               rb->buffer_size - rb->read_index);
;;;182        memcpy(&ptr[rb->buffer_size - rb->read_index],
000054  2008              MOVS     r0,#8
000056  88a1              LDRH     r1,[r4,#4]
000058  5e20              LDRSH    r0,[r4,r0]
00005a  0849              LSRS     r1,r1,#1
00005c  1a40              SUBS     r0,r0,r1
00005e  1a2a              SUBS     r2,r5,r0
000060  1980              ADDS     r0,r0,r6
000062  6821              LDR      r1,[r4,#0]
000064  f7fffffe          BL       __aeabi_memcpy
;;;183               &rb->buffer_ptr[0],
;;;184               length - (rb->buffer_size - rb->read_index));
;;;185    
;;;186        /* we are going into the other side of the mirror */
;;;187        rb->read_mirror = ~rb->read_mirror;
000068  88a0              LDRH     r0,[r4,#4]
00006a  2101              MOVS     r1,#1
00006c  4048              EORS     r0,r0,r1
;;;188        rb->read_index = length - (rb->buffer_size - rb->read_index);
00006e  8921              LDRH     r1,[r4,#8]
000070  0842              LSRS     r2,r0,#1
000072  1a89              SUBS     r1,r1,r2
000074  1a69              SUBS     r1,r5,r1
000076  0049              LSLS     r1,r1,#1
000078  07c0              LSLS     r0,r0,#31
00007a  0fc0              LSRS     r0,r0,#31
                  |L2.124|
00007c  4301              ORRS     r1,r1,r0
00007e  80a1              STRH     r1,[r4,#4]
;;;189    
;;;190        return length;
000080  4628              MOV      r0,r5
                  |L2.130|
;;;191    }
000082  bd70              POP      {r4-r6,pc}
;;;192    RTM_EXPORT(rt_ringbuffer_get);
                          ENDP

                  |L2.132|
                          DCD      ||.constdata||+0x3d
                  |L2.136|
000088  72622021          DCB      "rb != RT_NULL",0
00008c  3d205254
000090  5f4e554c
000094  4c00    
000096  00                DCB      0
000097  00                DCB      0

                          AREA ||i.rt_ringbuffer_getchar||, CODE, READONLY, ALIGN=2

                  rt_ringbuffer_getchar PROC
;;;261     */
;;;262    rt_size_t rt_ringbuffer_getchar(struct rt_ringbuffer *rb, rt_uint8_t *ch)
000000  b570              PUSH     {r4-r6,lr}
;;;263    {
000002  460d              MOV      r5,r1
000004  0004              MOVS     r4,r0
000006  d105              BNE      |L3.20|
;;;264        RT_ASSERT(rb != RT_NULL);
000008  22ff              MOVS     r2,#0xff
00000a  3209              ADDS     r2,r2,#9
00000c  4910              LDR      r1,|L3.80|
00000e  a011              ADR      r0,|L3.84|
000010  f7fffffe          BL       rt_assert_handler
                  |L3.20|
;;;265    
;;;266        /* ringbuffer is empty */
;;;267        if (!rt_ringbuffer_data_len(rb))
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       rt_ringbuffer_data_len
00001a  2800              CMP      r0,#0
00001c  d016              BEQ      |L3.76|
;;;268            return 0;
;;;269    
;;;270        /* put character */
;;;271        *ch = rb->buffer_ptr[rb->read_index];
00001e  88a1              LDRH     r1,[r4,#4]
000020  6820              LDR      r0,[r4,#0]
000022  0849              LSRS     r1,r1,#1
000024  5c40              LDRB     r0,[r0,r1]
000026  7028              STRB     r0,[r5,#0]
;;;272    
;;;273        if (rb->read_index == rb->buffer_size-1)
000028  2208              MOVS     r2,#8
00002a  88a0              LDRH     r0,[r4,#4]
00002c  5ea2              LDRSH    r2,[r4,r2]
00002e  0841              LSRS     r1,r0,#1
000030  1e52              SUBS     r2,r2,#1
000032  4291              CMP      r1,r2
000034  d103              BNE      |L3.62|
;;;274        {
;;;275            rb->read_mirror = ~rb->read_mirror;
000036  2101              MOVS     r1,#1
000038  4048              EORS     r0,r0,r1
;;;276            rb->read_index = 0;
00003a  4008              ANDS     r0,r0,r1
00003c  e004              B        |L3.72|
                  |L3.62|
;;;277        }
;;;278        else
;;;279        {
;;;280            rb->read_index++;
00003e  07c0              LSLS     r0,r0,#31
000040  0fc0              LSRS     r0,r0,#31
000042  1c49              ADDS     r1,r1,#1
000044  0049              LSLS     r1,r1,#1
000046  4308              ORRS     r0,r0,r1
                  |L3.72|
000048  80a0              STRH     r0,[r4,#4]
;;;281        }
;;;282    
;;;283        return 1;
00004a  2001              MOVS     r0,#1
                  |L3.76|
;;;284    }
00004c  bd70              POP      {r4-r6,pc}
;;;285    RTM_EXPORT(rt_ringbuffer_getchar);
                          ENDP

00004e  0000              DCW      0x0000
                  |L3.80|
                          DCD      ||.constdata||+0x81
                  |L3.84|
000054  72622021          DCB      "rb != RT_NULL",0
000058  3d205254
00005c  5f4e554c
000060  4c00    
000062  00                DCB      0
000063  00                DCB      0

                          AREA ||i.rt_ringbuffer_init||, CODE, READONLY, ALIGN=2

                  rt_ringbuffer_init PROC
;;;29     
;;;30     void rt_ringbuffer_init(struct rt_ringbuffer *rb,
000000  b570              PUSH     {r4-r6,lr}
;;;31                             rt_uint8_t           *pool,
;;;32                             rt_int16_t            size)
;;;33     {
000002  4615              MOV      r5,r2
000004  460e              MOV      r6,r1
000006  0004              MOVS     r4,r0
000008  d104              BNE      |L4.20|
;;;34         RT_ASSERT(rb != RT_NULL);
00000a  2222              MOVS     r2,#0x22
00000c  4909              LDR      r1,|L4.52|
00000e  a00a              ADR      r0,|L4.56|
000010  f7fffffe          BL       rt_assert_handler
                  |L4.20|
;;;35         RT_ASSERT(size > 0)
000014  2d00              CMP      r5,#0
000016  dc04              BGT      |L4.34|
000018  2223              MOVS     r2,#0x23
00001a  4906              LDR      r1,|L4.52|
00001c  a00a              ADR      r0,|L4.72|
00001e  f7fffffe          BL       rt_assert_handler
                  |L4.34|
;;;36     
;;;37         /* initialize read and write index */
;;;38         rb->read_mirror = rb->read_index = 0;
000022  2000              MOVS     r0,#0
000024  80a0              STRH     r0,[r4,#4]
;;;39         rb->write_mirror = rb->write_index = 0;
000026  80e0              STRH     r0,[r4,#6]
;;;40     
;;;41         /* set buffer pool and size */
;;;42         rb->buffer_ptr = pool;
;;;43         rb->buffer_size = RT_ALIGN_DOWN(size, RT_ALIGN_SIZE);
000028  08a8              LSRS     r0,r5,#2
00002a  0080              LSLS     r0,r0,#2
00002c  6026              STR      r6,[r4,#0]
00002e  8120              STRH     r0,[r4,#8]
;;;44     }
000030  bd70              POP      {r4-r6,pc}
;;;45     RTM_EXPORT(rt_ringbuffer_init);
                          ENDP

000032  0000              DCW      0x0000
                  |L4.52|
                          DCD      ||.constdata||
                  |L4.56|
000038  72622021          DCB      "rb != RT_NULL",0
00003c  3d205254
000040  5f4e554c
000044  4c00    
000046  00                DCB      0
000047  00                DCB      0
                  |L4.72|
000048  73697a65          DCB      "size > 0",0
00004c  203e2030
000050  00      
000051  00                DCB      0
000052  00                DCB      0
000053  00                DCB      0

                          AREA ||i.rt_ringbuffer_put||, CODE, READONLY, ALIGN=2

                  rt_ringbuffer_put PROC
;;;49      */
;;;50     rt_size_t rt_ringbuffer_put(struct rt_ringbuffer *rb,
000000  b570              PUSH     {r4-r6,lr}
;;;51                                 const rt_uint8_t     *ptr,
;;;52                                 rt_uint16_t           length)
;;;53     {
000002  4615              MOV      r5,r2
000004  460e              MOV      r6,r1
000006  0004              MOVS     r4,r0
000008  d104              BNE      |L5.20|
;;;54         rt_uint16_t size;
;;;55     
;;;56         RT_ASSERT(rb != RT_NULL);
00000a  2238              MOVS     r2,#0x38
00000c  491e              LDR      r1,|L5.136|
00000e  a01f              ADR      r0,|L5.140|
000010  f7fffffe          BL       rt_assert_handler
                  |L5.20|
;;;57     
;;;58         /* whether has enough space */
;;;59         size = rt_ringbuffer_space_len(rb);
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       rt_ringbuffer_data_len
00001a  2108              MOVS     r1,#8
00001c  5e61              LDRSH    r1,[r4,r1]
00001e  1a08              SUBS     r0,r1,r0
000020  0400              LSLS     r0,r0,#16
000022  0c00              LSRS     r0,r0,#16
;;;60     
;;;61         /* no space */
;;;62         if (size == 0)
000024  d02f              BEQ      |L5.134|
;;;63             return 0;
;;;64     
;;;65         /* drop some data */
;;;66         if (size < length)
000026  42a8              CMP      r0,r5
000028  d200              BCS      |L5.44|
;;;67             length = size;
00002a  4605              MOV      r5,r0
                  |L5.44|
;;;68     
;;;69         if (rb->buffer_size - rb->write_index > length)
00002c  88e0              LDRH     r0,[r4,#6]
00002e  0840              LSRS     r0,r0,#1
000030  1a0a              SUBS     r2,r1,r0
000032  6821              LDR      r1,[r4,#0]
000034  42aa              CMP      r2,r5
000036  dd0b              BLE      |L5.80|
;;;70         {
;;;71             /* read_index - write_index = empty space */
;;;72             memcpy(&rb->buffer_ptr[rb->write_index], ptr, length);
000038  1808              ADDS     r0,r1,r0
00003a  462a              MOV      r2,r5
00003c  4631              MOV      r1,r6
00003e  f7fffffe          BL       __aeabi_memcpy
;;;73             /* this should not cause overflow because there is enough space for
;;;74              * length of data in current mirror */
;;;75             rb->write_index += length;
000042  88e0              LDRH     r0,[r4,#6]
000044  07c1              LSLS     r1,r0,#31
000046  0840              LSRS     r0,r0,#1
000048  0fc9              LSRS     r1,r1,#31
00004a  1940              ADDS     r0,r0,r5
00004c  0040              LSLS     r0,r0,#1
;;;76             return length;
00004e  e017              B        |L5.128|
                  |L5.80|
;;;77         }
;;;78     
;;;79         memcpy(&rb->buffer_ptr[rb->write_index],
000050  1808              ADDS     r0,r1,r0
000052  4631              MOV      r1,r6
000054  f7fffffe          BL       __aeabi_memcpy
;;;80                &ptr[0],
;;;81                rb->buffer_size - rb->write_index);
;;;82         memcpy(&rb->buffer_ptr[0],
000058  2008              MOVS     r0,#8
00005a  88e1              LDRH     r1,[r4,#6]
00005c  5e20              LDRSH    r0,[r4,r0]
00005e  0849              LSRS     r1,r1,#1
000060  1a40              SUBS     r0,r0,r1
000062  1a2a              SUBS     r2,r5,r0
000064  1981              ADDS     r1,r0,r6
000066  6820              LDR      r0,[r4,#0]
000068  f7fffffe          BL       __aeabi_memcpy
;;;83                &ptr[rb->buffer_size - rb->write_index],
;;;84                length - (rb->buffer_size - rb->write_index));
;;;85     
;;;86         /* we are going into the other side of the mirror */
;;;87         rb->write_mirror = ~rb->write_mirror;
00006c  88e0              LDRH     r0,[r4,#6]
00006e  2101              MOVS     r1,#1
000070  4048              EORS     r0,r0,r1
;;;88         rb->write_index = length - (rb->buffer_size - rb->write_index);
000072  8921              LDRH     r1,[r4,#8]
000074  0842              LSRS     r2,r0,#1
000076  1a89              SUBS     r1,r1,r2
000078  1a69              SUBS     r1,r5,r1
00007a  0049              LSLS     r1,r1,#1
00007c  07c0              LSLS     r0,r0,#31
00007e  0fc0              LSRS     r0,r0,#31
                  |L5.128|
000080  4301              ORRS     r1,r1,r0
000082  80e1              STRH     r1,[r4,#6]
;;;89     
;;;90         return length;
000084  4628              MOV      r0,r5
                  |L5.134|
;;;91     }
000086  bd70              POP      {r4-r6,pc}
;;;92     RTM_EXPORT(rt_ringbuffer_put);
                          ENDP

                  |L5.136|
                          DCD      ||.constdata||+0x13
                  |L5.140|
00008c  72622021          DCB      "rb != RT_NULL",0
000090  3d205254
000094  5f4e554c
000098  4c00    
00009a  00                DCB      0
00009b  00                DCB      0

                          AREA ||i.rt_ringbuffer_put_force||, CODE, READONLY, ALIGN=2

                  rt_ringbuffer_put_force PROC
;;;98      */
;;;99     rt_size_t rt_ringbuffer_put_force(struct rt_ringbuffer *rb,
000000  b5f8              PUSH     {r3-r7,lr}
;;;100                                const rt_uint8_t     *ptr,
;;;101                                rt_uint16_t           length)
;;;102    {
000002  4615              MOV      r5,r2
000004  460f              MOV      r7,r1
000006  0004              MOVS     r4,r0
000008  d104              BNE      |L6.20|
;;;103        rt_uint16_t space_length;
;;;104    
;;;105        RT_ASSERT(rb != RT_NULL);
00000a  2269              MOVS     r2,#0x69
00000c  4927              LDR      r1,|L6.172|
00000e  a028              ADR      r0,|L6.176|
000010  f7fffffe          BL       rt_assert_handler
                  |L6.20|
;;;106    
;;;107        space_length = rt_ringbuffer_space_len(rb);
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       rt_ringbuffer_data_len
00001a  2108              MOVS     r1,#8
00001c  5e61              LDRSH    r1,[r4,r1]
00001e  1a08              SUBS     r0,r1,r0
000020  b286              UXTH     r6,r0
;;;108    
;;;109        if (length > space_length)
000022  42b5              CMP      r5,r6
000024  d900              BLS      |L6.40|
;;;110            length = rb->buffer_size;
000026  8925              LDRH     r5,[r4,#8]
                  |L6.40|
;;;111    
;;;112        if (rb->buffer_size - rb->write_index > length)
000028  88e0              LDRH     r0,[r4,#6]
00002a  0840              LSRS     r0,r0,#1
00002c  1a0a              SUBS     r2,r1,r0
00002e  6821              LDR      r1,[r4,#0]
000030  42aa              CMP      r2,r5
000032  dd17              BLE      |L6.100|
;;;113        {
;;;114            /* read_index - write_index = empty space */
;;;115            memcpy(&rb->buffer_ptr[rb->write_index], ptr, length);
000034  1808              ADDS     r0,r1,r0
000036  462a              MOV      r2,r5
000038  4639              MOV      r1,r7
00003a  f7fffffe          BL       __aeabi_memcpy
;;;116            /* this should not cause overflow because there is enough space for
;;;117             * length of data in current mirror */
;;;118            rb->write_index += length;
00003e  88e1              LDRH     r1,[r4,#6]
000040  07c8              LSLS     r0,r1,#31
000042  0849              LSRS     r1,r1,#1
000044  1949              ADDS     r1,r1,r5
000046  0449              LSLS     r1,r1,#17
000048  0fc0              LSRS     r0,r0,#31
00004a  0c09              LSRS     r1,r1,#16
00004c  4308              ORRS     r0,r0,r1
00004e  80e0              STRH     r0,[r4,#6]
;;;119    
;;;120            if (length > space_length)
000050  42b5              CMP      r5,r6
000052  d929              BLS      |L6.168|
;;;121                rb->read_index = rb->write_index;
000054  7921              LDRB     r1,[r4,#4]
000056  0840              LSRS     r0,r0,#1
000058  07c9              LSLS     r1,r1,#31
00005a  0fc9              LSRS     r1,r1,#31
00005c  0040              LSLS     r0,r0,#1
00005e  4301              ORRS     r1,r1,r0
000060  80a1              STRH     r1,[r4,#4]
000062  e021              B        |L6.168|
                  |L6.100|
;;;122    
;;;123            return length;
;;;124        }
;;;125    
;;;126        memcpy(&rb->buffer_ptr[rb->write_index],
000064  1808              ADDS     r0,r1,r0
000066  4639              MOV      r1,r7
000068  f7fffffe          BL       __aeabi_memcpy
;;;127               &ptr[0],
;;;128               rb->buffer_size - rb->write_index);
;;;129        memcpy(&rb->buffer_ptr[0],
00006c  2008              MOVS     r0,#8
00006e  88e1              LDRH     r1,[r4,#6]
000070  5e20              LDRSH    r0,[r4,r0]
000072  0849              LSRS     r1,r1,#1
000074  1a40              SUBS     r0,r0,r1
000076  1a2a              SUBS     r2,r5,r0
000078  19c1              ADDS     r1,r0,r7
00007a  6820              LDR      r0,[r4,#0]
00007c  f7fffffe          BL       __aeabi_memcpy
;;;130               &ptr[rb->buffer_size - rb->write_index],
;;;131               length - (rb->buffer_size - rb->write_index));
;;;132    
;;;133        /* we are going into the other side of the mirror */
;;;134        rb->write_mirror = ~rb->write_mirror;
000080  88e0              LDRH     r0,[r4,#6]
000082  2201              MOVS     r2,#1
000084  4050              EORS     r0,r0,r2
;;;135        rb->write_index = length - (rb->buffer_size - rb->write_index);
000086  8921              LDRH     r1,[r4,#8]
000088  0843              LSRS     r3,r0,#1
00008a  1ac9              SUBS     r1,r1,r3
00008c  1a69              SUBS     r1,r5,r1
00008e  0449              LSLS     r1,r1,#17
000090  0c09              LSRS     r1,r1,#16
000092  4010              ANDS     r0,r0,r2
000094  4301              ORRS     r1,r1,r0
000096  80e1              STRH     r1,[r4,#6]
;;;136    
;;;137        if (length > space_length)
000098  42b5              CMP      r5,r6
00009a  d905              BLS      |L6.168|
;;;138        {
;;;139            rb->read_mirror = ~rb->read_mirror;
00009c  7920              LDRB     r0,[r4,#4]
;;;140            rb->read_index = rb->write_index;
00009e  4391              BICS     r1,r1,r2
0000a0  4050              EORS     r0,r0,r2              ;139
0000a2  4010              ANDS     r0,r0,r2
0000a4  4308              ORRS     r0,r0,r1
0000a6  80a0              STRH     r0,[r4,#4]
                  |L6.168|
;;;141        }
;;;142    
;;;143        return length;
0000a8  4628              MOV      r0,r5
;;;144    }
0000aa  bdf8              POP      {r3-r7,pc}
;;;145    RTM_EXPORT(rt_ringbuffer_put_force);
                          ENDP

                  |L6.172|
                          DCD      ||.constdata||+0x25
                  |L6.176|
0000b0  72622021          DCB      "rb != RT_NULL",0
0000b4  3d205254
0000b8  5f4e554c
0000bc  4c00    
0000be  00                DCB      0
0000bf  00                DCB      0

                          AREA ||i.rt_ringbuffer_putchar||, CODE, READONLY, ALIGN=2

                  rt_ringbuffer_putchar PROC
;;;196     */
;;;197    rt_size_t rt_ringbuffer_putchar(struct rt_ringbuffer *rb, const rt_uint8_t ch)
000000  b570              PUSH     {r4-r6,lr}
;;;198    {
000002  460d              MOV      r5,r1
000004  0004              MOVS     r4,r0
000006  d104              BNE      |L7.18|
;;;199        RT_ASSERT(rb != RT_NULL);
000008  22c7              MOVS     r2,#0xc7
00000a  4912              LDR      r1,|L7.84|
00000c  a012              ADR      r0,|L7.88|
00000e  f7fffffe          BL       rt_assert_handler
                  |L7.18|
;;;200    
;;;201        /* whether has enough space */
;;;202        if (!rt_ringbuffer_space_len(rb))
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       rt_ringbuffer_data_len
000018  2108              MOVS     r1,#8
00001a  5e61              LDRSH    r1,[r4,r1]
00001c  4288              CMP      r0,r1
00001e  d101              BNE      |L7.36|
;;;203            return 0;
000020  2000              MOVS     r0,#0
;;;204    
;;;205        rb->buffer_ptr[rb->write_index] = ch;
;;;206    
;;;207        /* flip mirror */
;;;208        if (rb->write_index == rb->buffer_size-1)
;;;209        {
;;;210            rb->write_mirror = ~rb->write_mirror;
;;;211            rb->write_index = 0;
;;;212        }
;;;213        else
;;;214        {
;;;215            rb->write_index++;
;;;216        }
;;;217    
;;;218        return 1;
;;;219    }
000022  bd70              POP      {r4-r6,pc}
                  |L7.36|
000024  88e1              LDRH     r1,[r4,#6]            ;205
000026  6820              LDR      r0,[r4,#0]            ;205
000028  0849              LSRS     r1,r1,#1              ;205
00002a  5445              STRB     r5,[r0,r1]            ;205
00002c  2208              MOVS     r2,#8                 ;208
00002e  88e0              LDRH     r0,[r4,#6]            ;208
000030  5ea2              LDRSH    r2,[r4,r2]            ;208
000032  0841              LSRS     r1,r0,#1              ;208
000034  1e52              SUBS     r2,r2,#1              ;208
000036  4291              CMP      r1,r2                 ;208
000038  d103              BNE      |L7.66|
00003a  2101              MOVS     r1,#1                 ;210
00003c  4048              EORS     r0,r0,r1              ;210
00003e  4008              ANDS     r0,r0,r1              ;211
000040  e004              B        |L7.76|
                  |L7.66|
000042  07c0              LSLS     r0,r0,#31             ;215
000044  0fc0              LSRS     r0,r0,#31             ;215
000046  1c49              ADDS     r1,r1,#1              ;215
000048  0049              LSLS     r1,r1,#1              ;215
00004a  4308              ORRS     r0,r0,r1              ;215
                  |L7.76|
00004c  80e0              STRH     r0,[r4,#6]            ;215
00004e  2001              MOVS     r0,#1                 ;218
000050  bd70              POP      {r4-r6,pc}
;;;220    RTM_EXPORT(rt_ringbuffer_putchar);
                          ENDP

000052  0000              DCW      0x0000
                  |L7.84|
                          DCD      ||.constdata||+0x4f
                  |L7.88|
000058  72622021          DCB      "rb != RT_NULL",0
00005c  3d205254
000060  5f4e554c
000064  4c00    
000066  00                DCB      0
000067  00                DCB      0

                          AREA ||i.rt_ringbuffer_putchar_force||, CODE, READONLY, ALIGN=2

                  rt_ringbuffer_putchar_force PROC
;;;226     */
;;;227    rt_size_t rt_ringbuffer_putchar_force(struct rt_ringbuffer *rb, const rt_uint8_t ch)
000000  b570              PUSH     {r4-r6,lr}
;;;228    {
000002  460d              MOV      r5,r1
000004  0004              MOVS     r4,r0
000006  d104              BNE      |L8.18|
;;;229        enum rt_ringbuffer_state old_state;
;;;230    
;;;231        RT_ASSERT(rb != RT_NULL);
000008  22e7              MOVS     r2,#0xe7
00000a  4917              LDR      r1,|L8.104|
00000c  a017              ADR      r0,|L8.108|
00000e  f7fffffe          BL       rt_assert_handler
                  |L8.18|
;;;232    
;;;233        old_state = rt_ringbuffer_status(rb);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       rt_ringbuffer_status
000018  4602              MOV      r2,r0
;;;234    
;;;235        rb->buffer_ptr[rb->write_index] = ch;
00001a  88e1              LDRH     r1,[r4,#6]
00001c  6820              LDR      r0,[r4,#0]
00001e  0849              LSRS     r1,r1,#1
000020  5445              STRB     r5,[r0,r1]
;;;236    
;;;237        /* flip mirror */
;;;238        if (rb->write_index == rb->buffer_size-1)
000022  2308              MOVS     r3,#8
000024  88e0              LDRH     r0,[r4,#6]
000026  5ee3              LDRSH    r3,[r4,r3]
000028  0841              LSRS     r1,r0,#1
00002a  1e5b              SUBS     r3,r3,#1
00002c  4299              CMP      r1,r3
00002e  d10a              BNE      |L8.70|
;;;239        {
;;;240            rb->write_mirror = ~rb->write_mirror;
000030  2101              MOVS     r1,#1
000032  4048              EORS     r0,r0,r1
;;;241            rb->write_index = 0;
000034  4008              ANDS     r0,r0,r1
000036  80e0              STRH     r0,[r4,#6]
;;;242            if (old_state == RT_RINGBUFFER_FULL)
000038  2a01              CMP      r2,#1
00003a  d112              BNE      |L8.98|
;;;243            {
;;;244                rb->read_mirror = ~rb->read_mirror;
00003c  7920              LDRB     r0,[r4,#4]
00003e  4048              EORS     r0,r0,r1
;;;245                rb->read_index = rb->write_index;
000040  4008              ANDS     r0,r0,r1
000042  80a0              STRH     r0,[r4,#4]
000044  e00d              B        |L8.98|
                  |L8.70|
;;;246            }
;;;247        }
;;;248        else
;;;249        {
;;;250            rb->write_index++;
000046  1c49              ADDS     r1,r1,#1
000048  07c0              LSLS     r0,r0,#31
00004a  0449              LSLS     r1,r1,#17
00004c  0fc0              LSRS     r0,r0,#31
00004e  0c09              LSRS     r1,r1,#16
000050  4308              ORRS     r0,r0,r1
000052  80e0              STRH     r0,[r4,#6]
;;;251            if (old_state == RT_RINGBUFFER_FULL)
000054  2a01              CMP      r2,#1
000056  d104              BNE      |L8.98|
;;;252                rb->read_index = rb->write_index;
000058  7921              LDRB     r1,[r4,#4]
00005a  4390              BICS     r0,r0,r2
00005c  4011              ANDS     r1,r1,r2
00005e  4301              ORRS     r1,r1,r0
000060  80a1              STRH     r1,[r4,#4]
                  |L8.98|
;;;253        }
;;;254    
;;;255        return 1;
000062  2001              MOVS     r0,#1
;;;256    }
000064  bd70              POP      {r4-r6,pc}
;;;257    RTM_EXPORT(rt_ringbuffer_putchar_force);
                          ENDP

000066  0000              DCW      0x0000
                  |L8.104|
                          DCD      ||.constdata||+0x65
                  |L8.108|
00006c  72622021          DCB      "rb != RT_NULL",0
000070  3d205254
000074  5f4e554c
000078  4c00    
00007a  00                DCB      0
00007b  00                DCB      0

                          AREA ||i.rt_ringbuffer_status||, CODE, READONLY, ALIGN=1

                  rt_ringbuffer_status PROC
;;;212    rt_inline enum rt_ringbuffer_state
;;;213    rt_ringbuffer_status(struct rt_ringbuffer *rb)
000000  8881              LDRH     r1,[r0,#4]
;;;214    {
;;;215        if (rb->read_index == rb->write_index)
000002  88c0              LDRH     r0,[r0,#6]
000004  084a              LSRS     r2,r1,#1
000006  0843              LSRS     r3,r0,#1
000008  429a              CMP      r2,r3
00000a  d109              BNE      |L9.32|
;;;216        {
;;;217            if (rb->read_mirror == rb->write_mirror)
00000c  07c9              LSLS     r1,r1,#31
00000e  07c0              LSLS     r0,r0,#31
000010  0fc9              LSRS     r1,r1,#31
000012  0fc0              LSRS     r0,r0,#31
000014  4281              CMP      r1,r0
000016  d101              BNE      |L9.28|
;;;218                return RT_RINGBUFFER_EMPTY;
000018  2000              MOVS     r0,#0
;;;219            else
;;;220                return RT_RINGBUFFER_FULL;
;;;221        }
;;;222        return RT_RINGBUFFER_HALFFULL;
;;;223    }
00001a  4770              BX       lr
                  |L9.28|
00001c  2001              MOVS     r0,#1                 ;220
00001e  4770              BX       lr
                  |L9.32|
000020  2002              MOVS     r0,#2                 ;222
000022  4770              BX       lr
;;;224    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  72745f72          DCB      0x72,0x74,0x5f,0x72
000004  696e6762          DCB      0x69,0x6e,0x67,0x62
000008  75666665          DCB      0x75,0x66,0x66,0x65
00000c  725f696e          DCB      0x72,0x5f,0x69,0x6e
000010  697400            DCB      0x69,0x74,0x00
                  |symbol_number.30|
000013  72                DCB      0x72
000014  745f7269          DCB      0x74,0x5f,0x72,0x69
000018  6e676275          DCB      0x6e,0x67,0x62,0x75
00001c  66666572          DCB      0x66,0x66,0x65,0x72
000020  5f707574          DCB      0x5f,0x70,0x75,0x74
000024  00                DCB      0x00
                  |symbol_number.31|
000025  72745f            DCB      0x72,0x74,0x5f
000028  72696e67          DCB      0x72,0x69,0x6e,0x67
00002c  62756666          DCB      0x62,0x75,0x66,0x66
000030  65725f70          DCB      0x65,0x72,0x5f,0x70
000034  75745f66          DCB      0x75,0x74,0x5f,0x66
000038  6f726365          DCB      0x6f,0x72,0x63,0x65
00003c  00                DCB      0x00
                  |symbol_number.32|
00003d  72745f            DCB      0x72,0x74,0x5f
000040  72696e67          DCB      0x72,0x69,0x6e,0x67
000044  62756666          DCB      0x62,0x75,0x66,0x66
000048  65725f67          DCB      0x65,0x72,0x5f,0x67
00004c  657400            DCB      0x65,0x74,0x00
                  |symbol_number.33|
00004f  72                DCB      0x72
000050  745f7269          DCB      0x74,0x5f,0x72,0x69
000054  6e676275          DCB      0x6e,0x67,0x62,0x75
000058  66666572          DCB      0x66,0x66,0x65,0x72
00005c  5f707574          DCB      0x5f,0x70,0x75,0x74
000060  63686172          DCB      0x63,0x68,0x61,0x72
000064  00                DCB      0x00
                  |symbol_number.34|
000065  72745f            DCB      0x72,0x74,0x5f
000068  72696e67          DCB      0x72,0x69,0x6e,0x67
00006c  62756666          DCB      0x62,0x75,0x66,0x66
000070  65725f70          DCB      0x65,0x72,0x5f,0x70
000074  75746368          DCB      0x75,0x74,0x63,0x68
000078  61725f66          DCB      0x61,0x72,0x5f,0x66
00007c  6f726365          DCB      0x6f,0x72,0x63,0x65
000080  00                DCB      0x00
                  |symbol_number.35|
000081  72745f            DCB      0x72,0x74,0x5f
000084  72696e67          DCB      0x72,0x69,0x6e,0x67
000088  62756666          DCB      0x62,0x75,0x66,0x66
00008c  65725f67          DCB      0x65,0x72,0x5f,0x67
000090  65746368          DCB      0x65,0x74,0x63,0x68
000094  617200            DCB      0x61,0x72,0x00
