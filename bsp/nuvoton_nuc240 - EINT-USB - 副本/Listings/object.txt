; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\object.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\object.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I.\Libraries\Device\Nuvoton -I..\..\components\finsh -I.\Libraries\CMSIS\Include -I.\Libraries\StdDriver\inc -I..\..\include -I.\APP -I.\Drivers -I..\..\components\drivers\include -I..\..\components\drivers\include\drivers -I..\nuvoton_nuc240 -I.\Libraries\Device\Nuvoton\NUC230_240\Include -I..\..\include -I..\..\components\drivers\usb\usbdevice\class -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=521 -DRT_DEBUG --omf_browse=.\objects\object.crf ..\..\src\object.c]
                          THUMB

                          AREA ||i.rt_list_insert_after||, CODE, READONLY, ALIGN=1

                  rt_list_insert_after PROC
;;;61      */
;;;62     rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
000000  6802              LDR      r2,[r0,#0]
;;;63     {
;;;64         l->next->prev = n;
;;;65         n->next = l->next;
000002  6051              STR      r1,[r2,#4]
000004  6802              LDR      r2,[r0,#0]
;;;66     
;;;67         l->next = n;
000006  600a              STR      r2,[r1,#0]
;;;68         n->prev = l;
000008  6001              STR      r1,[r0,#0]
00000a  6048              STR      r0,[r1,#4]
;;;69     }
00000c  4770              BX       lr
;;;70     
                          ENDP


                          AREA ||i.rt_list_remove||, CODE, READONLY, ALIGN=1

                  rt_list_remove PROC
;;;90      */
;;;91     rt_inline void rt_list_remove(rt_list_t *n)
000000  c806              LDM      r0!,{r1,r2}
;;;92     {
;;;93         n->next->prev = n->prev;
000002  3808              SUBS     r0,r0,#8
000004  604a              STR      r2,[r1,#4]
000006  c806              LDM      r0!,{r1,r2}
;;;94         n->prev->next = n->next;
000008  3808              SUBS     r0,r0,#8
;;;95     
;;;96         n->next = n->prev = n;
00000a  6011              STR      r1,[r2,#0]
00000c  6040              STR      r0,[r0,#4]
00000e  6000              STR      r0,[r0,#0]
;;;97     }
000010  4770              BX       lr
;;;98     
                          ENDP


                          AREA ||i.rt_object_allocate||, CODE, READONLY, ALIGN=2

                  rt_object_allocate PROC
;;;273     */
;;;274    rt_object_t rt_object_allocate(enum rt_object_class_type type, const char *name)
000000  b5f8              PUSH     {r3-r7,lr}
;;;275    {
000002  460f              MOV      r7,r1
000004  4606              MOV      r6,r0
;;;276        struct rt_object *object;
;;;277        register rt_base_t temp;
;;;278        struct rt_object_information *information;
;;;279    
;;;280        RT_DEBUG_NOT_IN_INTERRUPT;
000006  f7fffffe          BL       rt_hw_interrupt_disable
00000a  4604              MOV      r4,r0
00000c  f7fffffe          BL       rt_interrupt_get_nest
000010  2800              CMP      r0,#0
000012  d009              BEQ      |L3.40|
000014  4915              LDR      r1,|L3.108|
000016  a016              ADR      r0,|L3.112|
000018  f7fffffe          BL       rt_kprintf
00001c  22ff              MOVS     r2,#0xff
00001e  3219              ADDS     r2,r2,#0x19
000020  4912              LDR      r1,|L3.108|
000022  a01c              ADR      r0,|L3.148|
000024  f7fffffe          BL       rt_assert_handler
                  |L3.40|
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       rt_hw_interrupt_enable
;;;281    
;;;282    #ifdef RT_USING_MODULE
;;;283        /*
;;;284         * get module object information,
;;;285         * module object should be managed by kernel object container
;;;286         */
;;;287        information = (rt_module_self() != RT_NULL && (type != RT_Object_Class_Module)) ?
;;;288                      &rt_module_self()->module_object[type] : &rt_object_container[type];
;;;289    #else
;;;290        /* get object information */
;;;291        information = &rt_object_container[type];
00002e  491a              LDR      r1,|L3.152|
000030  0130              LSLS     r0,r6,#4
000032  1845              ADDS     r5,r0,r1
;;;292    #endif
;;;293    
;;;294        object = (struct rt_object *)RT_KERNEL_MALLOC(information->object_size);
000034  68e8              LDR      r0,[r5,#0xc]
000036  f7fffffe          BL       rt_malloc
00003a  0004              MOVS     r4,r0
;;;295        if (object == RT_NULL)
00003c  d014              BEQ      |L3.104|
;;;296        {
;;;297            /* no memory can be allocated */
;;;298            return RT_NULL;
;;;299        }
;;;300    
;;;301        /* initialize object's parameters */
;;;302    
;;;303        /* set object type */
;;;304        object->type = type;
00003e  7226              STRB     r6,[r4,#8]
;;;305    
;;;306        /* set object flag */
;;;307        object->flag = 0;
000040  2000              MOVS     r0,#0
000042  7260              STRB     r0,[r4,#9]
;;;308    
;;;309    #ifdef RT_USING_MODULE
;;;310        if (rt_module_self() != RT_NULL)
;;;311        {
;;;312            object->flag |= RT_OBJECT_FLAG_MODULE;
;;;313        }
;;;314        object->module_id = (void *)rt_module_self();
;;;315    #endif
;;;316    
;;;317        /* copy name */
;;;318        rt_strncpy(object->name, name, RT_NAME_MAX);
000044  2208              MOVS     r2,#8
000046  4639              MOV      r1,r7
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       rt_strncpy
;;;319    
;;;320        RT_OBJECT_HOOK_CALL(rt_object_attach_hook, (object));
;;;321    
;;;322        /* lock interrupt */
;;;323        temp = rt_hw_interrupt_disable();
00004e  f7fffffe          BL       rt_hw_interrupt_disable
000052  4606              MOV      r6,r0
;;;324    
;;;325        /* insert object into information object list */
;;;326        rt_list_insert_after(&(information->object_list), &(object->list));
000054  4621              MOV      r1,r4
000056  310c              ADDS     r1,r1,#0xc
000058  1d28              ADDS     r0,r5,#4
00005a  f7fffffe          BL       rt_list_insert_after
;;;327    
;;;328        /* unlock interrupt */
;;;329        rt_hw_interrupt_enable(temp);
00005e  4630              MOV      r0,r6
000060  f7fffffe          BL       rt_hw_interrupt_enable
;;;330    
;;;331        /* return object */
;;;332        return object;
000064  4620              MOV      r0,r4
;;;333    }
000066  bdf8              POP      {r3-r7,pc}
                  |L3.104|
000068  2000              MOVS     r0,#0                 ;298
00006a  bdf8              POP      {r3-r7,pc}
;;;334    
                          ENDP

                  |L3.108|
                          DCD      ||.constdata||+0x11
                  |L3.112|
000070  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
000074  74696f6e
000078  5b25735d
00007c  20736861
000080  6c6c206e
000084  6f742075
000088  73656420
00008c  696e2049
000090  53520a00
                  |L3.148|
000094  3000              DCB      "0",0
000096  00                DCB      0
000097  00                DCB      0
                  |L3.152|
                          DCD      ||.data||

                          AREA ||i.rt_object_delete||, CODE, READONLY, ALIGN=2

                  rt_object_delete PROC
;;;339     */
;;;340    void rt_object_delete(rt_object_t object)
000000  b570              PUSH     {r4-r6,lr}
;;;341    {
000002  0004              MOVS     r4,r0
000004  d105              BNE      |L4.18|
;;;342        register rt_base_t temp;
;;;343    
;;;344        /* object check */
;;;345        RT_ASSERT(object != RT_NULL);
000006  22ff              MOVS     r2,#0xff
000008  325a              ADDS     r2,r2,#0x5a
00000a  490d              LDR      r1,|L4.64|
00000c  a00d              ADR      r0,|L4.68|
00000e  f7fffffe          BL       rt_assert_handler
                  |L4.18|
;;;346        RT_ASSERT(!(object->type & RT_Object_Class_Static));
000012  7a20              LDRB     r0,[r4,#8]
000014  0600              LSLS     r0,r0,#24
000016  d505              BPL      |L4.36|
000018  22ff              MOVS     r2,#0xff
00001a  325b              ADDS     r2,r2,#0x5b
00001c  4908              LDR      r1,|L4.64|
00001e  a00e              ADR      r0,|L4.88|
000020  f7fffffe          BL       rt_assert_handler
                  |L4.36|
;;;347    
;;;348        RT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));
;;;349    
;;;350        /* lock interrupt */
;;;351        temp = rt_hw_interrupt_disable();
000024  f7fffffe          BL       rt_hw_interrupt_disable
000028  4605              MOV      r5,r0
;;;352    
;;;353        /* remove from old list */
;;;354        rt_list_remove(&(object->list));
00002a  4620              MOV      r0,r4
00002c  300c              ADDS     r0,r0,#0xc
00002e  f7fffffe          BL       rt_list_remove
;;;355    
;;;356        /* unlock interrupt */
;;;357        rt_hw_interrupt_enable(temp);
000032  4628              MOV      r0,r5
000034  f7fffffe          BL       rt_hw_interrupt_enable
;;;358    
;;;359    #if defined(RT_USING_MODULE) && defined(RT_USING_SLAB)
;;;360        if (object->flag & RT_OBJECT_FLAG_MODULE)
;;;361            rt_module_free((rt_module_t)object->module_id, object);
;;;362        else
;;;363    #endif
;;;364    
;;;365        /* free the memory of object */
;;;366        RT_KERNEL_FREE(object);
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       rt_free
;;;367    }
00003e  bd70              POP      {r4-r6,pc}
;;;368    #endif
                          ENDP

                  |L4.64|
                          DCD      ||.constdata||+0x24
                  |L4.68|
000044  6f626a65          DCB      "object != RT_NULL",0
000048  63742021
00004c  3d205254
000050  5f4e554c
000054  4c00    
000056  00                DCB      0
000057  00                DCB      0
                  |L4.88|
000058  21286f62          DCB      "!(object->type & RT_Object_Class_Static)",0
00005c  6a656374
000060  2d3e7479
000064  70652026
000068  2052545f
00006c  4f626a65
000070  63745f43
000074  6c617373
000078  5f537461
00007c  74696329
000080  00      
000081  00                DCB      0
000082  00                DCB      0
000083  00                DCB      0

                          AREA ||i.rt_object_detach||, CODE, READONLY, ALIGN=2

                  rt_object_detach PROC
;;;245     */
;;;246    void rt_object_detach(rt_object_t object)
000000  b570              PUSH     {r4-r6,lr}
;;;247    {
000002  0004              MOVS     r4,r0
000004  d104              BNE      |L5.16|
;;;248        register rt_base_t temp;
;;;249    
;;;250        /* object check */
;;;251        RT_ASSERT(object != RT_NULL);
000006  22fb              MOVS     r2,#0xfb
000008  4907              LDR      r1,|L5.40|
00000a  a008              ADR      r0,|L5.44|
00000c  f7fffffe          BL       rt_assert_handler
                  |L5.16|
;;;252    
;;;253        RT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));
;;;254    
;;;255        /* lock interrupt */
;;;256        temp = rt_hw_interrupt_disable();
000010  f7fffffe          BL       rt_hw_interrupt_disable
000014  4605              MOV      r5,r0
;;;257    
;;;258        /* remove from old list */
;;;259        rt_list_remove(&(object->list));
000016  4620              MOV      r0,r4
000018  300c              ADDS     r0,r0,#0xc
00001a  f7fffffe          BL       rt_list_remove
;;;260    
;;;261        /* unlock interrupt */
;;;262        rt_hw_interrupt_enable(temp);
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       rt_hw_interrupt_enable
;;;263    }
000024  bd70              POP      {r4-r6,pc}
;;;264    
                          ENDP

000026  0000              DCW      0x0000
                  |L5.40|
                          DCD      ||.constdata||
                  |L5.44|
00002c  6f626a65          DCB      "object != RT_NULL",0
000030  63742021
000034  3d205254
000038  5f4e554c
00003c  4c00    
00003e  00                DCB      0
00003f  00                DCB      0

                          AREA ||i.rt_object_find||, CODE, READONLY, ALIGN=2

                  rt_object_find PROC
;;;401     */
;;;402    rt_object_t rt_object_find(const char *name, rt_uint8_t type)
000000  b5f8              PUSH     {r3-r7,lr}
;;;403    {
000002  460c              MOV      r4,r1
000004  0007              MOVS     r7,r0
000006  d001              BEQ      |L6.12|
;;;404        struct rt_object *object = RT_NULL;
;;;405        struct rt_list_node *node = RT_NULL;
;;;406        struct rt_object_information *information = RT_NULL;
;;;407    
;;;408        /* parameter check */
;;;409        if ((name == RT_NULL) || (type > RT_Object_Class_Unknown))
000008  2c09              CMP      r4,#9
00000a  d901              BLS      |L6.16|
                  |L6.12|
;;;410            return RT_NULL;
00000c  2000              MOVS     r0,#0
;;;411    
;;;412        /* which is invoke in interrupt status */
;;;413        RT_DEBUG_NOT_IN_INTERRUPT;
;;;414    
;;;415    #ifdef RT_USING_MODULE
;;;416        /* check whether to find a object inside a module. */
;;;417        {
;;;418            const char *name_ptr;
;;;419            int module_name_length;
;;;420    
;;;421            name_ptr = name;
;;;422            while ((*name_ptr != '\0') && (*name_ptr != '/'))
;;;423                name_ptr ++;
;;;424    
;;;425            if (*name_ptr == '/')
;;;426            {
;;;427                struct rt_module* module = RT_NULL;
;;;428    
;;;429                /* get the name length of module */
;;;430                module_name_length = name_ptr - name;
;;;431    
;;;432                /* enter critical */
;;;433                rt_enter_critical();
;;;434    
;;;435                /* find module */
;;;436                information = &rt_object_container[RT_Object_Class_Module];
;;;437                for (node = information->object_list.next;
;;;438                    node != &(information->object_list);
;;;439                    node  = node->next)
;;;440                {
;;;441                    object = rt_list_entry(node, struct rt_object, list);
;;;442                    if ((rt_strncmp(object->name, name, module_name_length) == 0) &&
;;;443                        (module_name_length == RT_NAME_MAX || object->name[module_name_length] == '\0'))
;;;444                    {
;;;445                        /* get module */
;;;446                        module = (struct rt_module*)object;
;;;447                        break;
;;;448                    }
;;;449                }
;;;450                rt_exit_critical();
;;;451    
;;;452                /* there is no this module inside the system */
;;;453                if (module == RT_NULL) return RT_NULL;
;;;454    
;;;455                /* get the object pool of module */
;;;456                information = &(module->module_object[type]);
;;;457    
;;;458                /* get object name */
;;;459                while ((*name_ptr == '/') && (*name_ptr != '\0')) name_ptr ++;
;;;460                if (*name_ptr == '\0')
;;;461                {
;;;462                    if (type == RT_Object_Class_Module) return object;
;;;463                    return RT_NULL;
;;;464                }
;;;465    
;;;466                /* point to the object name */
;;;467                name = name_ptr;
;;;468            }
;;;469        }
;;;470    #endif
;;;471    
;;;472        /* enter critical */
;;;473        rt_enter_critical();
;;;474    
;;;475        /* try to find object */
;;;476        if (information == RT_NULL) information = &rt_object_container[type];
;;;477        for (node  = information->object_list.next;
;;;478             node != &(information->object_list);
;;;479             node  = node->next)
;;;480        {
;;;481            object = rt_list_entry(node, struct rt_object, list);
;;;482            if (rt_strncmp(object->name, name, RT_NAME_MAX) == 0)
;;;483            {
;;;484                /* leave critical */
;;;485                rt_exit_critical();
;;;486    
;;;487                return object;
;;;488            }
;;;489        }
;;;490    
;;;491        /* leave critical */
;;;492        rt_exit_critical();
;;;493    
;;;494        return RT_NULL;
;;;495    }
00000e  bdf8              POP      {r3-r7,pc}
                  |L6.16|
000010  f7fffffe          BL       rt_hw_interrupt_disable
000014  4605              MOV      r5,r0                 ;413
000016  f7fffffe          BL       rt_interrupt_get_nest
00001a  2800              CMP      r0,#0                 ;413
00001c  d009              BEQ      |L6.50|
00001e  4914              LDR      r1,|L6.112|
000020  a014              ADR      r0,|L6.116|
000022  f7fffffe          BL       rt_kprintf
000026  22ff              MOVS     r2,#0xff              ;413
000028  329e              ADDS     r2,r2,#0x9e           ;413
00002a  4911              LDR      r1,|L6.112|
00002c  a01a              ADR      r0,|L6.152|
00002e  f7fffffe          BL       rt_assert_handler
                  |L6.50|
000032  4628              MOV      r0,r5                 ;413
000034  f7fffffe          BL       rt_hw_interrupt_enable
000038  f7fffffe          BL       rt_enter_critical
00003c  4917              LDR      r1,|L6.156|
00003e  0120              LSLS     r0,r4,#4              ;476
000040  1846              ADDS     r6,r0,r1              ;476
000042  6874              LDR      r4,[r6,#4]            ;477
000044  1d36              ADDS     r6,r6,#4              ;477
000046  e009              B        |L6.92|
                  |L6.72|
000048  4625              MOV      r5,r4                 ;481
00004a  3d0c              SUBS     r5,r5,#0xc            ;481
00004c  2208              MOVS     r2,#8                 ;482
00004e  4639              MOV      r1,r7                 ;482
000050  4628              MOV      r0,r5                 ;482
000052  f7fffffe          BL       rt_strncmp
000056  2800              CMP      r0,#0                 ;482
000058  d005              BEQ      |L6.102|
00005a  6824              LDR      r4,[r4,#0]            ;479
                  |L6.92|
00005c  42b4              CMP      r4,r6                 ;478
00005e  d1f3              BNE      |L6.72|
000060  f7fffffe          BL       rt_exit_critical
000064  e7d2              B        |L6.12|
                  |L6.102|
000066  f7fffffe          BL       rt_exit_critical
00006a  4628              MOV      r0,r5                 ;487
00006c  bdf8              POP      {r3-r7,pc}
;;;496    
                          ENDP

00006e  0000              DCW      0x0000
                  |L6.112|
                          DCD      ||.constdata||+0x4f
                  |L6.116|
000074  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
000078  74696f6e
00007c  5b25735d
000080  20736861
000084  6c6c206e
000088  6f742075
00008c  73656420
000090  696e2049
000094  53520a00
                  |L6.152|
000098  3000              DCB      "0",0
00009a  00                DCB      0
00009b  00                DCB      0
                  |L6.156|
                          DCD      ||.data||

                          AREA ||i.rt_object_get_information||, CODE, READONLY, ALIGN=2

                  rt_object_get_information PROC
;;;189    struct rt_object_information *
;;;190    rt_object_get_information(enum rt_object_class_type type)
000000  4901              LDR      r1,|L7.8|
;;;191    {
;;;192        return &rt_object_container[type];
000002  0100              LSLS     r0,r0,#4
000004  1840              ADDS     r0,r0,r1
;;;193    }
000006  4770              BX       lr
;;;194    RTM_EXPORT(rt_object_get_information);
                          ENDP

                  |L7.8|
                          DCD      ||.data||

                          AREA ||i.rt_object_init||, CODE, READONLY, ALIGN=2

                  rt_object_init PROC
;;;203     */
;;;204    void rt_object_init(struct rt_object         *object,
000000  b570              PUSH     {r4-r6,lr}
;;;205                        enum rt_object_class_type type,
;;;206                        const char               *name)
;;;207    {
000002  4613              MOV      r3,r2
000004  4604              MOV      r4,r0
;;;208        register rt_base_t temp;
;;;209        struct rt_object_information *information;
;;;210    
;;;211    #ifdef RT_USING_MODULE
;;;212        /* get module object information */
;;;213        information = (rt_module_self() != RT_NULL) ?
;;;214            &rt_module_self()->module_object[type] : &rt_object_container[type];
;;;215    #else
;;;216        /* get object information */
;;;217        information = &rt_object_container[type];
000006  4a0b              LDR      r2,|L8.52|
000008  0108              LSLS     r0,r1,#4
00000a  1885              ADDS     r5,r0,r2
;;;218    #endif
;;;219    
;;;220        /* initialize object's parameters */
;;;221    
;;;222        /* set object type to static */
;;;223        object->type = type | RT_Object_Class_Static;
00000c  2080              MOVS     r0,#0x80
00000e  4301              ORRS     r1,r1,r0
000010  7221              STRB     r1,[r4,#8]
;;;224    
;;;225        /* copy name */
;;;226        rt_strncpy(object->name, name, RT_NAME_MAX);
000012  2208              MOVS     r2,#8
000014  4619              MOV      r1,r3
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       rt_strncpy
;;;227    
;;;228        RT_OBJECT_HOOK_CALL(rt_object_attach_hook, (object));
;;;229    
;;;230        /* lock interrupt */
;;;231        temp = rt_hw_interrupt_disable();
00001c  f7fffffe          BL       rt_hw_interrupt_disable
000020  4606              MOV      r6,r0
;;;232    
;;;233        /* insert object into information object list */
;;;234        rt_list_insert_after(&(information->object_list), &(object->list));
000022  4621              MOV      r1,r4
000024  310c              ADDS     r1,r1,#0xc
000026  1d28              ADDS     r0,r5,#4
000028  f7fffffe          BL       rt_list_insert_after
;;;235    
;;;236        /* unlock interrupt */
;;;237        rt_hw_interrupt_enable(temp);
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       rt_hw_interrupt_enable
;;;238    }
000032  bd70              POP      {r4-r6,pc}
;;;239    
                          ENDP

                  |L8.52|
                          DCD      ||.data||

                          AREA ||i.rt_object_is_systemobject||, CODE, READONLY, ALIGN=2

                  rt_object_is_systemobject PROC
;;;378     */
;;;379    rt_bool_t rt_object_is_systemobject(rt_object_t object)
000000  b510              PUSH     {r4,lr}
;;;380    {
000002  0004              MOVS     r4,r0
000004  d105              BNE      |L9.18|
;;;381        /* object check */
;;;382        RT_ASSERT(object != RT_NULL);
000006  22ff              MOVS     r2,#0xff
000008  327f              ADDS     r2,r2,#0x7f
00000a  4905              LDR      r1,|L9.32|
00000c  a005              ADR      r0,|L9.36|
00000e  f7fffffe          BL       rt_assert_handler
                  |L9.18|
;;;383    
;;;384        if (object->type & RT_Object_Class_Static)
000012  7a20              LDRB     r0,[r4,#8]
000014  0600              LSLS     r0,r0,#24
000016  d501              BPL      |L9.28|
;;;385            return RT_TRUE;
000018  2001              MOVS     r0,#1
;;;386    
;;;387        return RT_FALSE;
;;;388    }
00001a  bd10              POP      {r4,pc}
                  |L9.28|
00001c  2000              MOVS     r0,#0                 ;387
00001e  bd10              POP      {r4,pc}
;;;389    
                          ENDP

                  |L9.32|
                          DCD      ||.constdata||+0x35
                  |L9.36|
000024  6f626a65          DCB      "object != RT_NULL",0
000028  63742021
00002c  3d205254
000030  5f4e554c
000034  4c00    
000036  00                DCB      0
000037  00                DCB      0

                          AREA ||i.rt_system_object_init||, CODE, READONLY, ALIGN=1

                  rt_system_object_init PROC
;;;172     */
;;;173    void rt_system_object_init(void)
000000  4770              BX       lr
;;;174    {
;;;175    }
;;;176    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  72745f6f          DCB      0x72,0x74,0x5f,0x6f
000004  626a6563          DCB      0x62,0x6a,0x65,0x63
000008  745f6465          DCB      0x74,0x5f,0x64,0x65
00000c  74616368          DCB      0x74,0x61,0x63,0x68
000010  00                DCB      0x00
                  |symbol_number.33|
000011  72745f            DCB      0x72,0x74,0x5f
000014  6f626a65          DCB      0x6f,0x62,0x6a,0x65
000018  63745f61          DCB      0x63,0x74,0x5f,0x61
00001c  6c6c6f63          DCB      0x6c,0x6c,0x6f,0x63
000020  61746500          DCB      0x61,0x74,0x65,0x00
                  |symbol_number.34|
000024  72745f6f          DCB      0x72,0x74,0x5f,0x6f
000028  626a6563          DCB      0x62,0x6a,0x65,0x63
00002c  745f6465          DCB      0x74,0x5f,0x64,0x65
000030  6c657465          DCB      0x6c,0x65,0x74,0x65
000034  00                DCB      0x00
                  |symbol_number.35|
000035  72745f            DCB      0x72,0x74,0x5f
000038  6f626a65          DCB      0x6f,0x62,0x6a,0x65
00003c  63745f69          DCB      0x63,0x74,0x5f,0x69
000040  735f7379          DCB      0x73,0x5f,0x73,0x79
000044  7374656d          DCB      0x73,0x74,0x65,0x6d
000048  6f626a65          DCB      0x6f,0x62,0x6a,0x65
00004c  637400            DCB      0x63,0x74,0x00
                  |symbol_number.36|
00004f  72                DCB      0x72
000050  745f6f62          DCB      0x74,0x5f,0x6f,0x62
000054  6a656374          DCB      0x6a,0x65,0x63,0x74
000058  5f66696e          DCB      0x5f,0x66,0x69,0x6e
00005c  6400              DCB      0x64,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  rt_object_container
000000  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      rt_object_container+0x4
                          DCD      rt_object_container+0x4
                          DCD      0x00000080
000010  01000000          DCB      0x01,0x00,0x00,0x00
                          DCD      rt_object_container+0x14
                          DCD      rt_object_container+0x14
                          DCD      0x00000020
000020  02000000          DCB      0x02,0x00,0x00,0x00
                          DCD      rt_object_container+0x24
                          DCD      rt_object_container+0x24
                          DCD      0x00000024
000030  03000000          DCB      0x03,0x00,0x00,0x00
                          DCD      rt_object_container+0x34
                          DCD      rt_object_container+0x34
                          DCD      0x00000020
000040  04000000          DCB      0x04,0x00,0x00,0x00
                          DCD      rt_object_container+0x44
                          DCD      rt_object_container+0x44
                          DCD      0x00000030
000050  05000000          DCB      0x05,0x00,0x00,0x00
                          DCD      rt_object_container+0x54
                          DCD      rt_object_container+0x54
                          DCD      0x00000034
000060  06000000          DCB      0x06,0x00,0x00,0x00
                          DCD      rt_object_container+0x64
                          DCD      rt_object_container+0x64
                          DCD      0x00000038
000070  07000000          DCB      0x07,0x00,0x00,0x00
                          DCD      rt_object_container+0x74
                          DCD      rt_object_container+0x74
                          DCD      0x00000040
000080  08000000          DCB      0x08,0x00,0x00,0x00
                          DCD      rt_object_container+0x84
                          DCD      rt_object_container+0x84
                          DCD      0x0000002c
