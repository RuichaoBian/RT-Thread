; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\dataqueue.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\dataqueue.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I.\Libraries\Device\Nuvoton -I..\..\components\finsh -I.\Libraries\CMSIS\Include -I.\Libraries\StdDriver\inc -I..\..\include -I.\APP -I.\Drivers -I..\..\components\drivers\include -I..\..\components\drivers\include\drivers -I..\nuvoton_nuc240 -I.\Libraries\Device\Nuvoton\NUC230_240\Include -I..\..\include -I..\..\components\drivers\usb\usbdevice\class -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=521 -DRT_DEBUG --omf_browse=.\objects\dataqueue.crf ..\..\components\drivers\src\dataqueue.c]
                          THUMB

                          AREA ||i.rt_data_queue_init||, CODE, READONLY, ALIGN=2

                  rt_data_queue_init PROC
;;;36     rt_err_t
;;;37     rt_data_queue_init(struct rt_data_queue *queue,
000000  b5f8              PUSH     {r3-r7,lr}
;;;38                        rt_uint16_t size,
;;;39                        rt_uint16_t lwm,
;;;40                        void (*evt_notify)(struct rt_data_queue *queue, rt_uint32_t event))
;;;41     {
000002  461e              MOV      r6,r3
000004  4617              MOV      r7,r2
000006  460d              MOV      r5,r1
000008  0004              MOVS     r4,r0
00000a  d104              BNE      |L1.22|
;;;42         RT_ASSERT(queue != RT_NULL);
00000c  222a              MOVS     r2,#0x2a
00000e  490e              LDR      r1,|L1.72|
000010  a00e              ADR      r0,|L1.76|
000012  f7fffffe          BL       rt_assert_handler
                  |L1.22|
;;;43     
;;;44         queue->evt_notify = evt_notify;
;;;45     
;;;46         queue->size = size;
000016  61e6              STR      r6,[r4,#0x1c]
000018  8025              STRH     r5,[r4,#0]
;;;47         queue->lwm = lwm;
00001a  8067              STRH     r7,[r4,#2]
;;;48     
;;;49         queue->get_index = 0;
00001c  2000              MOVS     r0,#0
00001e  80a0              STRH     r0,[r4,#4]
;;;50         queue->put_index = 0;
000020  80e0              STRH     r0,[r4,#6]
;;;51     
;;;52         rt_list_init(&(queue->suspended_push_list));
000022  4620              MOV      r0,r4
000024  300c              ADDS     r0,r0,#0xc
000026  6120              STR      r0,[r4,#0x10]
;;;53         rt_list_init(&(queue->suspended_pop_list));
000028  60e0              STR      r0,[r4,#0xc]
00002a  3008              ADDS     r0,r0,#8
00002c  61a0              STR      r0,[r4,#0x18]
;;;54     
;;;55         queue->queue = (struct rt_data_item *)rt_malloc(sizeof(struct rt_data_item) * size);
00002e  6160              STR      r0,[r4,#0x14]
000030  00e8              LSLS     r0,r5,#3
000032  f7fffffe          BL       rt_malloc
;;;56         if (queue->queue == RT_NULL)
000036  60a0              STR      r0,[r4,#8]
000038  2800              CMP      r0,#0
00003a  d001              BEQ      |L1.64|
;;;57         {
;;;58             return -RT_ENOMEM;
;;;59         }
;;;60     
;;;61         return RT_EOK;
00003c  2000              MOVS     r0,#0
;;;62     }
00003e  bdf8              POP      {r3-r7,pc}
                  |L1.64|
000040  2004              MOVS     r0,#4                 ;58
000042  43c0              MVNS     r0,r0                 ;58
000044  bdf8              POP      {r3-r7,pc}
;;;63     RTM_EXPORT(rt_data_queue_init);
                          ENDP

000046  0000              DCW      0x0000
                  |L1.72|
                          DCD      ||.constdata||
                  |L1.76|
00004c  71756575          DCB      "queue != RT_NULL",0
000050  6520213d
000054  2052545f
000058  4e554c4c
00005c  00      
00005d  00                DCB      0
00005e  00                DCB      0
00005f  00                DCB      0

                          AREA ||i.rt_data_queue_peak||, CODE, READONLY, ALIGN=2

                  rt_data_queue_peak PROC
;;;255    
;;;256    rt_err_t rt_data_queue_peak(struct rt_data_queue *queue,
000000  b5f8              PUSH     {r3-r7,lr}
;;;257                                const void** data_ptr,
;;;258                                rt_size_t *size)
;;;259    {
000002  4616              MOV      r6,r2
000004  460f              MOV      r7,r1
000006  0004              MOVS     r4,r0
000008  d105              BNE      |L2.22|
;;;260        rt_ubase_t  level;
;;;261    
;;;262        RT_ASSERT(queue != RT_NULL);
00000a  22ff              MOVS     r2,#0xff
00000c  3207              ADDS     r2,#7
00000e  4913              LDR      r1,|L2.92|
000010  a013              ADR      r0,|L2.96|
000012  f7fffffe          BL       rt_assert_handler
                  |L2.22|
;;;263    
;;;264        level = rt_hw_interrupt_disable();
000016  f7fffffe          BL       rt_hw_interrupt_disable
00001a  4605              MOV      r5,r0
;;;265    
;;;266        if (queue->get_index == queue->put_index) 
00001c  88a0              LDRH     r0,[r4,#4]
00001e  88e1              LDRH     r1,[r4,#6]
000020  4288              CMP      r0,r1
000022  d105              BNE      |L2.48|
;;;267        {
;;;268            rt_hw_interrupt_enable(level);
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       rt_hw_interrupt_enable
;;;269            
;;;270            return -RT_EEMPTY;
00002a  2003              MOVS     r0,#3
00002c  43c0              MVNS     r0,r0
;;;271        }
;;;272    
;;;273        *data_ptr = queue->queue[queue->get_index % queue->size].data_ptr;
;;;274        *size     = queue->queue[queue->get_index % queue->size].data_size;
;;;275    
;;;276        rt_hw_interrupt_enable(level);
;;;277    
;;;278        return RT_EOK;
;;;279    }
00002e  bdf8              POP      {r3-r7,pc}
                  |L2.48|
000030  8821              LDRH     r1,[r4,#0]            ;273
000032  f7fffffe          BL       __aeabi_uidivmod
000036  00c8              LSLS     r0,r1,#3              ;273
000038  68a1              LDR      r1,[r4,#8]            ;273
00003a  5808              LDR      r0,[r1,r0]            ;273
00003c  6038              STR      r0,[r7,#0]            ;274
00003e  8821              LDRH     r1,[r4,#0]            ;274
000040  88a0              LDRH     r0,[r4,#4]            ;274
000042  f7fffffe          BL       __aeabi_uidivmod
000046  00c8              LSLS     r0,r1,#3              ;274
000048  68a1              LDR      r1,[r4,#8]            ;274
00004a  1d00              ADDS     r0,r0,#4              ;274
00004c  5808              LDR      r0,[r1,r0]            ;274
00004e  6030              STR      r0,[r6,#0]            ;276
000050  4628              MOV      r0,r5                 ;276
000052  f7fffffe          BL       rt_hw_interrupt_enable
000056  2000              MOVS     r0,#0                 ;278
000058  bdf8              POP      {r3-r7,pc}
;;;280    RTM_EXPORT(rt_data_queue_peak);
                          ENDP

00005a  0000              DCW      0x0000
                  |L2.92|
                          DCD      ||.constdata||+0x38
                  |L2.96|
000060  71756575          DCB      "queue != RT_NULL",0
000064  6520213d
000068  2052545f
00006c  4e554c4c
000070  00      
000071  00                DCB      0
000072  00                DCB      0
000073  00                DCB      0

                          AREA ||i.rt_data_queue_pop||, CODE, READONLY, ALIGN=2

                  rt_data_queue_pop PROC
;;;153    
;;;154    rt_err_t rt_data_queue_pop(struct rt_data_queue *queue,
000000  b5ff              PUSH     {r0-r7,lr}
;;;155                               const void** data_ptr,
;;;156                               rt_size_t *size, 
;;;157                               rt_int32_t timeout)
;;;158    {
000002  b081              SUB      sp,sp,#4
000004  4617              MOV      r7,r2
000006  0004              MOVS     r4,r0
000008  d104              BNE      |L3.20|
;;;159        rt_ubase_t  level;
;;;160        rt_thread_t thread;
;;;161        rt_err_t    result;
;;;162    
;;;163        RT_ASSERT(queue != RT_NULL);
00000a  22a3              MOVS     r2,#0xa3
00000c  494e              LDR      r1,|L3.328|
00000e  a04f              ADR      r0,|L3.332|
000010  f7fffffe          BL       rt_assert_handler
                  |L3.20|
;;;164        RT_ASSERT(data_ptr != RT_NULL);
000014  9802              LDR      r0,[sp,#8]
000016  2800              CMP      r0,#0
000018  d104              BNE      |L3.36|
00001a  22a4              MOVS     r2,#0xa4
00001c  494a              LDR      r1,|L3.328|
00001e  a050              ADR      r0,|L3.352|
000020  f7fffffe          BL       rt_assert_handler
                  |L3.36|
;;;165        RT_ASSERT(size != RT_NULL);
000024  2f00              CMP      r7,#0
000026  d104              BNE      |L3.50|
000028  22a5              MOVS     r2,#0xa5
00002a  4947              LDR      r1,|L3.328|
00002c  a051              ADR      r0,|L3.372|
00002e  f7fffffe          BL       rt_assert_handler
                  |L3.50|
;;;166    
;;;167        result = RT_EOK;
000032  2600              MOVS     r6,#0
;;;168        thread = rt_thread_self();
000034  f7fffffe          BL       rt_thread_self
000038  4605              MOV      r5,r0
;;;169    
;;;170        level = rt_hw_interrupt_disable();
00003a  f7fffffe          BL       rt_hw_interrupt_disable
;;;171        while (queue->get_index == queue->put_index)
00003e  9000              STR      r0,[sp,#0]
000040  e03c              B        |L3.188|
                  |L3.66|
;;;172        {
;;;173            /* queue is empty */
;;;174            if (timeout == 0)
000042  9804              LDR      r0,[sp,#0x10]
000044  2800              CMP      r0,#0
000046  d036              BEQ      |L3.182|
;;;175            {
;;;176                result = -RT_ETIMEOUT;
;;;177                goto __exit;
;;;178            }
;;;179    
;;;180            /* current context checking */
;;;181            RT_DEBUG_NOT_IN_INTERRUPT;
000048  f7fffffe          BL       rt_hw_interrupt_disable
00004c  4606              MOV      r6,r0
00004e  f7fffffe          BL       rt_interrupt_get_nest
000052  2800              CMP      r0,#0
000054  d008              BEQ      |L3.104|
000056  493c              LDR      r1,|L3.328|
000058  a04a              ADR      r0,|L3.388|
00005a  f7fffffe          BL       rt_kprintf
00005e  22b5              MOVS     r2,#0xb5
000060  4939              LDR      r1,|L3.328|
000062  a051              ADR      r0,|L3.424|
000064  f7fffffe          BL       rt_assert_handler
                  |L3.104|
000068  4630              MOV      r0,r6
00006a  f7fffffe          BL       rt_hw_interrupt_enable
;;;182    
;;;183            /* reset thread error number */
;;;184            thread->error = RT_EOK;
00006e  2000              MOVS     r0,#0
;;;185            
;;;186            /* suspend thread on the pop list */
;;;187            rt_thread_suspend(thread);
000070  6328              STR      r0,[r5,#0x30]
000072  4628              MOV      r0,r5
000074  f7fffffe          BL       rt_thread_suspend
;;;188            rt_list_insert_before(&(queue->suspended_pop_list), &(thread->tlist));
000078  4629              MOV      r1,r5
00007a  4620              MOV      r0,r4
00007c  3114              ADDS     r1,r1,#0x14
00007e  3014              ADDS     r0,r0,#0x14
000080  f7fffffe          BL       rt_list_insert_before
;;;189            /* start timer */
;;;190            if (timeout > 0)
000084  9804              LDR      r0,[sp,#0x10]
000086  2800              CMP      r0,#0
000088  dd09              BLE      |L3.158|
;;;191            {
;;;192                /* reset the timeout of thread timer and start it */
;;;193                rt_timer_control(&(thread->thread_timer),
00008a  4628              MOV      r0,r5
00008c  304c              ADDS     r0,r0,#0x4c
00008e  aa04              ADD      r2,sp,#0x10
000090  2100              MOVS     r1,#0
000092  4606              MOV      r6,r0
000094  f7fffffe          BL       rt_timer_control
000098  4630              MOV      r0,r6
;;;194                                 RT_TIMER_CTRL_SET_TIME,
;;;195                                 &timeout);
;;;196                rt_timer_start(&(thread->thread_timer));
00009a  f7fffffe          BL       rt_timer_start
                  |L3.158|
;;;197            }
;;;198    
;;;199            /* enable interrupt */
;;;200            rt_hw_interrupt_enable(level);
00009e  9800              LDR      r0,[sp,#0]
0000a0  f7fffffe          BL       rt_hw_interrupt_enable
;;;201    
;;;202            /* do schedule */
;;;203            rt_schedule();
0000a4  f7fffffe          BL       rt_schedule
;;;204    
;;;205            /* thread is waked up */
;;;206            result = thread->error;
;;;207            level  = rt_hw_interrupt_disable();
0000a8  6b2e              LDR      r6,[r5,#0x30]
0000aa  f7fffffe          BL       rt_hw_interrupt_disable
;;;208            if (result != RT_EOK)
0000ae  9000              STR      r0,[sp,#0]
0000b0  2e00              CMP      r6,#0
0000b2  d003              BEQ      |L3.188|
0000b4  e039              B        |L3.298|
                  |L3.182|
0000b6  2601              MOVS     r6,#1                 ;176
0000b8  43f6              MVNS     r6,r6                 ;176
0000ba  e036              B        |L3.298|
                  |L3.188|
0000bc  88a0              LDRH     r0,[r4,#4]            ;171
0000be  88e1              LDRH     r1,[r4,#6]            ;171
0000c0  4288              CMP      r0,r1                 ;171
0000c2  d0be              BEQ      |L3.66|
;;;209                goto __exit;
;;;210        }
;;;211    
;;;212        *data_ptr = queue->queue[queue->get_index % queue->size].data_ptr;
0000c4  8821              LDRH     r1,[r4,#0]
0000c6  b280              UXTH     r0,r0
0000c8  f7fffffe          BL       __aeabi_uidivmod
0000cc  00c8              LSLS     r0,r1,#3
0000ce  68a1              LDR      r1,[r4,#8]
0000d0  5809              LDR      r1,[r1,r0]
0000d2  9802              LDR      r0,[sp,#8]
;;;213        *size     = queue->queue[queue->get_index % queue->size].data_size;
0000d4  6001              STR      r1,[r0,#0]
0000d6  8821              LDRH     r1,[r4,#0]
0000d8  88a0              LDRH     r0,[r4,#4]
0000da  f7fffffe          BL       __aeabi_uidivmod
0000de  00c8              LSLS     r0,r1,#3
0000e0  68a1              LDR      r1,[r4,#8]
0000e2  1d00              ADDS     r0,r0,#4
0000e4  5808              LDR      r0,[r1,r0]
;;;214    
;;;215        queue->get_index += 1;
0000e6  6038              STR      r0,[r7,#0]
0000e8  88a0              LDRH     r0,[r4,#4]
0000ea  1c40              ADDS     r0,r0,#1
0000ec  b280              UXTH     r0,r0
0000ee  80a0              STRH     r0,[r4,#4]
;;;216    
;;;217        if ((queue->put_index - queue->get_index) <= queue->lwm)
0000f0  88e1              LDRH     r1,[r4,#6]
0000f2  1a08              SUBS     r0,r1,r0
0000f4  8861              LDRH     r1,[r4,#2]
0000f6  4288              CMP      r0,r1
0000f8  dc17              BGT      |L3.298|
;;;218        {
;;;219            /* there is at least one thread in suspended list */
;;;220            if (!rt_list_isempty(&(queue->suspended_push_list)))
0000fa  4620              MOV      r0,r4
0000fc  300c              ADDS     r0,r0,#0xc
0000fe  f7fffffe          BL       rt_list_isempty
000102  2800              CMP      r0,#0
000104  d007              BEQ      |L3.278|
;;;221            {
;;;222                /* get thread entry */
;;;223                thread = rt_list_entry(queue->suspended_push_list.next,
;;;224                                       struct rt_thread,
;;;225                                       tlist);
;;;226    
;;;227                /* resume it */
;;;228                rt_thread_resume(thread);
;;;229                rt_hw_interrupt_enable(level);
;;;230    
;;;231                /* perform a schedule */
;;;232                rt_schedule();
;;;233            }
;;;234            else
;;;235            {
;;;236                rt_hw_interrupt_enable(level);
000106  9800              LDR      r0,[sp,#0]
000108  f7fffffe          BL       rt_hw_interrupt_enable
                  |L3.268|
;;;237            }
;;;238    
;;;239            if (queue->evt_notify != RT_NULL)
00010c  69e2              LDR      r2,[r4,#0x1c]
00010e  2a00              CMP      r2,#0
000110  d016              BEQ      |L3.320|
;;;240                queue->evt_notify(queue, RT_DATAQUEUE_EVENT_LWM);
000112  2103              MOVS     r1,#3
000114  e012              B        |L3.316|
                  |L3.278|
000116  68e0              LDR      r0,[r4,#0xc]          ;223
000118  3814              SUBS     r0,r0,#0x14           ;223
00011a  f7fffffe          BL       rt_thread_resume
00011e  9800              LDR      r0,[sp,#0]            ;229
000120  f7fffffe          BL       rt_hw_interrupt_enable
000124  f7fffffe          BL       rt_schedule
000128  e7f0              B        |L3.268|
                  |L3.298|
;;;241    
;;;242            return result;
;;;243        }
;;;244    
;;;245    __exit:
;;;246        rt_hw_interrupt_enable(level);
00012a  9800              LDR      r0,[sp,#0]
00012c  f7fffffe          BL       rt_hw_interrupt_enable
;;;247        if ((result == RT_EOK) && (queue->evt_notify != RT_NULL))
000130  2e00              CMP      r6,#0
000132  d105              BNE      |L3.320|
000134  69e2              LDR      r2,[r4,#0x1c]
000136  2a00              CMP      r2,#0
000138  d002              BEQ      |L3.320|
;;;248        {
;;;249            queue->evt_notify(queue, RT_DATAQUEUE_EVENT_POP);
00013a  2101              MOVS     r1,#1
                  |L3.316|
00013c  4620              MOV      r0,r4                 ;240
00013e  4790              BLX      r2                    ;240
                  |L3.320|
;;;250        }
;;;251    
;;;252        return result;
000140  4630              MOV      r0,r6
;;;253    }
000142  b005              ADD      sp,sp,#0x14
000144  bdf0              POP      {r4-r7,pc}
;;;254    RTM_EXPORT(rt_data_queue_pop);
                          ENDP

000146  0000              DCW      0x0000
                  |L3.328|
                          DCD      ||.constdata||+0x26
                  |L3.332|
00014c  71756575          DCB      "queue != RT_NULL",0
000150  6520213d
000154  2052545f
000158  4e554c4c
00015c  00      
00015d  00                DCB      0
00015e  00                DCB      0
00015f  00                DCB      0
                  |L3.352|
000160  64617461          DCB      "data_ptr != RT_NULL",0
000164  5f707472
000168  20213d20
00016c  52545f4e
000170  554c4c00
                  |L3.372|
000174  73697a65          DCB      "size != RT_NULL",0
000178  20213d20
00017c  52545f4e
000180  554c4c00
                  |L3.388|
000184  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
000188  74696f6e
00018c  5b25735d
000190  20736861
000194  6c6c206e
000198  6f742075
00019c  73656420
0001a0  696e2049
0001a4  53520a00
                  |L3.424|
0001a8  3000              DCB      "0",0
0001aa  00                DCB      0
0001ab  00                DCB      0

                          AREA ||i.rt_data_queue_push||, CODE, READONLY, ALIGN=2

                  rt_data_queue_push PROC
;;;64     
;;;65     rt_err_t rt_data_queue_push(struct rt_data_queue *queue,
000000  b5ff              PUSH     {r0-r7,lr}
;;;66                                 const void *data_ptr,
;;;67                                 rt_size_t data_size,
;;;68                                 rt_int32_t timeout)
;;;69     {
000002  b081              SUB      sp,sp,#4
000004  0004              MOVS     r4,r0
000006  d104              BNE      |L4.18|
;;;70         rt_ubase_t  level;
;;;71         rt_thread_t thread;
;;;72         rt_err_t    result;
;;;73         
;;;74         RT_ASSERT(queue != RT_NULL);
000008  224a              MOVS     r2,#0x4a
00000a  4941              LDR      r1,|L4.272|
00000c  a041              ADR      r0,|L4.276|
00000e  f7fffffe          BL       rt_assert_handler
                  |L4.18|
;;;75     
;;;76         result = RT_EOK;
000012  2600              MOVS     r6,#0
;;;77         thread = rt_thread_self();
000014  f7fffffe          BL       rt_thread_self
000018  4605              MOV      r5,r0
;;;78     
;;;79         level = rt_hw_interrupt_disable();
00001a  f7fffffe          BL       rt_hw_interrupt_disable
00001e  4607              MOV      r7,r0
;;;80         while (queue->put_index - queue->get_index == queue->size)
000020  e03c              B        |L4.156|
                  |L4.34|
;;;81         {
;;;82             /* queue is full */
;;;83             if (timeout == 0)
000022  9804              LDR      r0,[sp,#0x10]
000024  2800              CMP      r0,#0
000026  d036              BEQ      |L4.150|
;;;84             {
;;;85                 result = -RT_ETIMEOUT;
;;;86     
;;;87                 goto __exit;
;;;88             }
;;;89     
;;;90             /* current context checking */
;;;91             RT_DEBUG_NOT_IN_INTERRUPT;
000028  f7fffffe          BL       rt_hw_interrupt_disable
00002c  4606              MOV      r6,r0
00002e  f7fffffe          BL       rt_interrupt_get_nest
000032  2800              CMP      r0,#0
000034  d008              BEQ      |L4.72|
000036  4936              LDR      r1,|L4.272|
000038  a03b              ADR      r0,|L4.296|
00003a  f7fffffe          BL       rt_kprintf
00003e  225b              MOVS     r2,#0x5b
000040  4933              LDR      r1,|L4.272|
000042  a042              ADR      r0,|L4.332|
000044  f7fffffe          BL       rt_assert_handler
                  |L4.72|
000048  4630              MOV      r0,r6
00004a  f7fffffe          BL       rt_hw_interrupt_enable
;;;92     
;;;93             /* reset thread error number */
;;;94             thread->error = RT_EOK;
00004e  2000              MOVS     r0,#0
;;;95             
;;;96             /* suspend thread on the push list */
;;;97             rt_thread_suspend(thread);
000050  6328              STR      r0,[r5,#0x30]
000052  4628              MOV      r0,r5
000054  f7fffffe          BL       rt_thread_suspend
;;;98             rt_list_insert_before(&(queue->suspended_push_list), &(thread->tlist));
000058  4629              MOV      r1,r5
00005a  4620              MOV      r0,r4
00005c  3114              ADDS     r1,r1,#0x14
00005e  300c              ADDS     r0,r0,#0xc
000060  f7fffffe          BL       rt_list_insert_before
;;;99             /* start timer */
;;;100            if (timeout > 0)
000064  9804              LDR      r0,[sp,#0x10]
000066  2800              CMP      r0,#0
000068  dd09              BLE      |L4.126|
;;;101            {
;;;102                /* reset the timeout of thread timer and start it */
;;;103                rt_timer_control(&(thread->thread_timer),
00006a  4628              MOV      r0,r5
00006c  304c              ADDS     r0,r0,#0x4c
00006e  aa04              ADD      r2,sp,#0x10
000070  2100              MOVS     r1,#0
000072  4606              MOV      r6,r0
000074  f7fffffe          BL       rt_timer_control
000078  4630              MOV      r0,r6
;;;104                                 RT_TIMER_CTRL_SET_TIME,
;;;105                                 &timeout);
;;;106                rt_timer_start(&(thread->thread_timer));
00007a  f7fffffe          BL       rt_timer_start
                  |L4.126|
;;;107            }
;;;108    
;;;109            /* enable interrupt */
;;;110            rt_hw_interrupt_enable(level);
00007e  4638              MOV      r0,r7
000080  f7fffffe          BL       rt_hw_interrupt_enable
;;;111    
;;;112            /* do schedule */
;;;113            rt_schedule();
000084  f7fffffe          BL       rt_schedule
;;;114    
;;;115            /* thread is waked up */
;;;116            result = thread->error;
;;;117            level = rt_hw_interrupt_disable();
000088  6b2e              LDR      r6,[r5,#0x30]
00008a  f7fffffe          BL       rt_hw_interrupt_disable
00008e  4607              MOV      r7,r0
;;;118            if (result != RT_EOK) goto __exit;
000090  2e00              CMP      r6,#0
000092  d003              BEQ      |L4.156|
000094  e022              B        |L4.220|
                  |L4.150|
000096  2601              MOVS     r6,#1                 ;85
000098  43f6              MVNS     r6,r6                 ;85
00009a  e01f              B        |L4.220|
                  |L4.156|
00009c  88e0              LDRH     r0,[r4,#6]            ;80
00009e  88a1              LDRH     r1,[r4,#4]            ;80
0000a0  1a40              SUBS     r0,r0,r1              ;80
0000a2  8821              LDRH     r1,[r4,#0]            ;80
0000a4  4288              CMP      r0,r1                 ;80
0000a6  d0bc              BEQ      |L4.34|
;;;119        }
;;;120    
;;;121        queue->queue[queue->put_index % queue->size].data_ptr  = data_ptr;
0000a8  b289              UXTH     r1,r1
0000aa  88e0              LDRH     r0,[r4,#6]
0000ac  f7fffffe          BL       __aeabi_uidivmod
0000b0  68a2              LDR      r2,[r4,#8]
0000b2  00c9              LSLS     r1,r1,#3
0000b4  9802              LDR      r0,[sp,#8]
0000b6  5050              STR      r0,[r2,r1]
;;;122        queue->queue[queue->put_index % queue->size].data_size = data_size;
0000b8  8821              LDRH     r1,[r4,#0]
0000ba  88e0              LDRH     r0,[r4,#6]
0000bc  f7fffffe          BL       __aeabi_uidivmod
0000c0  00c8              LSLS     r0,r1,#3
0000c2  68a2              LDR      r2,[r4,#8]
0000c4  1d00              ADDS     r0,r0,#4
0000c6  9903              LDR      r1,[sp,#0xc]
0000c8  5011              STR      r1,[r2,r0]
;;;123        queue->put_index += 1;
0000ca  88e0              LDRH     r0,[r4,#6]
0000cc  1c40              ADDS     r0,r0,#1
0000ce  80e0              STRH     r0,[r4,#6]
;;;124    
;;;125        /* there is at least one thread in suspended list */
;;;126        if (!rt_list_isempty(&(queue->suspended_pop_list)))
0000d0  4620              MOV      r0,r4
0000d2  3014              ADDS     r0,r0,#0x14
0000d4  f7fffffe          BL       rt_list_isempty
0000d8  2800              CMP      r0,#0
0000da  d005              BEQ      |L4.232|
                  |L4.220|
;;;127        {
;;;128            /* get thread entry */
;;;129            thread = rt_list_entry(queue->suspended_pop_list.next,
;;;130                                   struct rt_thread,
;;;131                                   tlist);
;;;132    
;;;133            /* resume it */
;;;134            rt_thread_resume(thread);
;;;135            rt_hw_interrupt_enable(level);
;;;136    
;;;137            /* perform a schedule */
;;;138            rt_schedule();
;;;139    
;;;140            return result;
;;;141        }
;;;142    
;;;143    __exit:
;;;144        rt_hw_interrupt_enable(level);
0000dc  4638              MOV      r0,r7
0000de  f7fffffe          BL       rt_hw_interrupt_enable
;;;145        if ((result == RT_EOK) && queue->evt_notify != RT_NULL)
0000e2  2e00              CMP      r6,#0
0000e4  d00a              BEQ      |L4.252|
0000e6  e00f              B        |L4.264|
                  |L4.232|
0000e8  6960              LDR      r0,[r4,#0x14]         ;129
0000ea  3814              SUBS     r0,r0,#0x14           ;129
0000ec  f7fffffe          BL       rt_thread_resume
0000f0  4638              MOV      r0,r7                 ;135
0000f2  f7fffffe          BL       rt_hw_interrupt_enable
0000f6  f7fffffe          BL       rt_schedule
0000fa  e005              B        |L4.264|
                  |L4.252|
0000fc  69e2              LDR      r2,[r4,#0x1c]
0000fe  2a00              CMP      r2,#0
000100  d002              BEQ      |L4.264|
;;;146        {
;;;147            queue->evt_notify(queue, RT_DATAQUEUE_EVENT_PUSH);
000102  2102              MOVS     r1,#2
000104  4620              MOV      r0,r4
000106  4790              BLX      r2
                  |L4.264|
;;;148        }
;;;149    
;;;150        return result;
000108  4630              MOV      r0,r6
;;;151    }
00010a  b005              ADD      sp,sp,#0x14
00010c  bdf0              POP      {r4-r7,pc}
;;;152    RTM_EXPORT(rt_data_queue_push);
                          ENDP

00010e  0000              DCW      0x0000
                  |L4.272|
                          DCD      ||.constdata||+0x13
                  |L4.276|
000114  71756575          DCB      "queue != RT_NULL",0
000118  6520213d
00011c  2052545f
000120  4e554c4c
000124  00      
000125  00                DCB      0
000126  00                DCB      0
000127  00                DCB      0
                  |L4.296|
000128  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
00012c  74696f6e
000130  5b25735d
000134  20736861
000138  6c6c206e
00013c  6f742075
000140  73656420
000144  696e2049
000148  53520a00
                  |L4.332|
00014c  3000              DCB      "0",0
00014e  00                DCB      0
00014f  00                DCB      0

                          AREA ||i.rt_data_queue_reset||, CODE, READONLY, ALIGN=1

                  rt_data_queue_reset PROC
;;;281    
;;;282    void rt_data_queue_reset(struct rt_data_queue *queue)
000000  b5f8              PUSH     {r3-r7,lr}
;;;283    {
000002  4604              MOV      r4,r0
;;;284        struct rt_thread *thread;
;;;285        register rt_ubase_t temp;
;;;286    
;;;287        rt_enter_critical();
000004  f7fffffe          BL       rt_enter_critical
;;;288        /* wakeup all suspend threads */
;;;289    
;;;290        /* resume on pop list */
;;;291        while (!rt_list_isempty(&(queue->suspended_pop_list)))
;;;292        {
;;;293            /* disable interrupt */
;;;294            temp = rt_hw_interrupt_disable();
;;;295    
;;;296            /* get next suspend thread */
;;;297            thread = rt_list_entry(queue->suspended_pop_list.next,
;;;298                                   struct rt_thread,
;;;299                                   tlist);
;;;300            /* set error code to RT_ERROR */
;;;301            thread->error = -RT_ERROR;
000008  2600              MOVS     r6,#0
00000a  43f6              MVNS     r6,r6
00000c  4627              MOV      r7,r4                 ;291
00000e  3714              ADDS     r7,r7,#0x14           ;291
000010  e00a              B        |L5.40|
                  |L5.18|
000012  f7fffffe          BL       rt_hw_interrupt_disable
000016  4605              MOV      r5,r0                 ;294
000018  6960              LDR      r0,[r4,#0x14]
00001a  61c6              STR      r6,[r0,#0x1c]
00001c  3814              SUBS     r0,r0,#0x14
;;;302    
;;;303            /*
;;;304             * resume thread
;;;305             * In rt_thread_resume function, it will remove current thread from
;;;306             * suspend list
;;;307             */
;;;308            rt_thread_resume(thread);
00001e  f7fffffe          BL       rt_thread_resume
;;;309    
;;;310            /* enable interrupt */
;;;311            rt_hw_interrupt_enable(temp);
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       rt_hw_interrupt_enable
                  |L5.40|
000028  4638              MOV      r0,r7
00002a  f7fffffe          BL       rt_list_isempty
00002e  2800              CMP      r0,#0                 ;291
000030  d0ef              BEQ      |L5.18|
;;;312        }
;;;313    
;;;314        /* resume on push list */
;;;315        while (!rt_list_isempty(&(queue->suspended_push_list)))
000032  4627              MOV      r7,r4
000034  370c              ADDS     r7,r7,#0xc
                  |L5.54|
000036  4638              MOV      r0,r7
000038  f7fffffe          BL       rt_list_isempty
00003c  2800              CMP      r0,#0
00003e  d004              BEQ      |L5.74|
;;;316        {
;;;317            /* disable interrupt */
;;;318            temp = rt_hw_interrupt_disable();
;;;319    
;;;320            /* get next suspend thread */
;;;321            thread = rt_list_entry(queue->suspended_push_list.next,
;;;322                                   struct rt_thread,
;;;323                                   tlist);
;;;324            /* set error code to RT_ERROR */
;;;325            thread->error = -RT_ERROR;
;;;326    
;;;327            /*
;;;328             * resume thread
;;;329             * In rt_thread_resume function, it will remove current thread from
;;;330             * suspend list
;;;331             */
;;;332            rt_thread_resume(thread);
;;;333    
;;;334            /* enable interrupt */
;;;335            rt_hw_interrupt_enable(temp);
;;;336        }
;;;337        rt_exit_critical();
000040  f7fffffe          BL       rt_exit_critical
;;;338    
;;;339        rt_schedule();
000044  f7fffffe          BL       rt_schedule
;;;340    }
000048  bdf8              POP      {r3-r7,pc}
                  |L5.74|
00004a  f7fffffe          BL       rt_hw_interrupt_disable
00004e  4605              MOV      r5,r0                 ;318
000050  68e0              LDR      r0,[r4,#0xc]          ;325
000052  61c6              STR      r6,[r0,#0x1c]         ;325
000054  3814              SUBS     r0,r0,#0x14           ;325
000056  f7fffffe          BL       rt_thread_resume
00005a  4628              MOV      r0,r5                 ;335
00005c  f7fffffe          BL       rt_hw_interrupt_enable
000060  e7e9              B        |L5.54|
;;;341    RTM_EXPORT(rt_data_queue_reset);
                          ENDP


                          AREA ||i.rt_list_insert_before||, CODE, READONLY, ALIGN=1

                  rt_list_insert_before PROC
;;;76      */
;;;77     rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
000000  6842              LDR      r2,[r0,#4]
;;;78     {
;;;79         l->prev->next = n;
;;;80         n->prev = l->prev;
000002  6011              STR      r1,[r2,#0]
000004  6842              LDR      r2,[r0,#4]
;;;81     
;;;82         l->prev = n;
000006  604a              STR      r2,[r1,#4]
;;;83         n->next = l;
000008  6041              STR      r1,[r0,#4]
00000a  6008              STR      r0,[r1,#0]
;;;84     }
00000c  4770              BX       lr
;;;85     
                          ENDP


                          AREA ||i.rt_list_isempty||, CODE, READONLY, ALIGN=1

                  rt_list_isempty PROC
;;;102     */
;;;103    rt_inline int rt_list_isempty(const rt_list_t *l)
000000  6801              LDR      r1,[r0,#0]
;;;104    {
;;;105        return l->next == l;
000002  4281              CMP      r1,r0
000004  d101              BNE      |L7.10|
000006  2001              MOVS     r0,#1
;;;106    }
000008  4770              BX       lr
                  |L7.10|
00000a  2000              MOVS     r0,#0                 ;105
00000c  4770              BX       lr
;;;107    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  72745f64          DCB      0x72,0x74,0x5f,0x64
000004  6174615f          DCB      0x61,0x74,0x61,0x5f
000008  71756575          DCB      0x71,0x75,0x65,0x75
00000c  655f696e          DCB      0x65,0x5f,0x69,0x6e
000010  697400            DCB      0x69,0x74,0x00
                  |symbol_number.23|
000013  72                DCB      0x72
000014  745f6461          DCB      0x74,0x5f,0x64,0x61
000018  74615f71          DCB      0x74,0x61,0x5f,0x71
00001c  75657565          DCB      0x75,0x65,0x75,0x65
000020  5f707573          DCB      0x5f,0x70,0x75,0x73
000024  6800              DCB      0x68,0x00
                  |symbol_number.24|
000026  7274              DCB      0x72,0x74
000028  5f646174          DCB      0x5f,0x64,0x61,0x74
00002c  615f7175          DCB      0x61,0x5f,0x71,0x75
000030  6575655f          DCB      0x65,0x75,0x65,0x5f
000034  706f7000          DCB      0x70,0x6f,0x70,0x00
                  |symbol_number.25|
000038  72745f64          DCB      0x72,0x74,0x5f,0x64
00003c  6174615f          DCB      0x61,0x74,0x61,0x5f
000040  71756575          DCB      0x71,0x75,0x65,0x75
000044  655f7065          DCB      0x65,0x5f,0x70,0x65
000048  616b00            DCB      0x61,0x6b,0x00
