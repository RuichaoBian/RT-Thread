; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\mem.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\mem.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I.\Libraries\Device\Nuvoton -I..\..\components\finsh -I.\Libraries\CMSIS\Include -I.\Libraries\StdDriver\inc -I..\..\include -I.\APP -I.\Drivers -I..\..\components\drivers\include -I..\..\components\drivers\include\drivers -I..\nuvoton_nuc240 -I.\Libraries\Device\Nuvoton\NUC230_240\Include -I..\..\include -I..\..\components\drivers\usb\usbdevice\class -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=521 -DRT_DEBUG --omf_browse=.\objects\mem.crf ..\..\src\mem.c]
                          THUMB

                          AREA ||i.list_mem||, CODE, READONLY, ALIGN=2

                  list_mem PROC
;;;577    
;;;578    void list_mem(void)
000000  b510              PUSH     {r4,lr}
;;;579    {
;;;580        rt_kprintf("total memory: %d\n", mem_size_aligned);
000002  4c07              LDR      r4,|L1.32|
000004  a007              ADR      r0,|L1.36|
000006  68e1              LDR      r1,[r4,#0xc]  ; mem_size_aligned
000008  f7fffffe          BL       rt_kprintf
;;;581        rt_kprintf("used memory : %d\n", used_mem);
00000c  a00a              ADR      r0,|L1.56|
00000e  6921              LDR      r1,[r4,#0x10]  ; used_mem
000010  f7fffffe          BL       rt_kprintf
;;;582        rt_kprintf("maximum allocated memory: %d\n", max_mem);
000014  a00d              ADR      r0,|L1.76|
000016  6961              LDR      r1,[r4,#0x14]  ; max_mem
000018  f7fffffe          BL       rt_kprintf
;;;583    }
00001c  bd10              POP      {r4,pc}
;;;584    FINSH_FUNCTION_EXPORT(list_mem, list memory usage information)
                          ENDP

00001e  0000              DCW      0x0000
                  |L1.32|
                          DCD      ||.data||
                  |L1.36|
000024  746f7461          DCB      "total memory: %d\n",0
000028  6c206d65
00002c  6d6f7279
000030  3a202564
000034  0a00    
000036  00                DCB      0
000037  00                DCB      0
                  |L1.56|
000038  75736564          DCB      "used memory : %d\n",0
00003c  206d656d
000040  6f727920
000044  3a202564
000048  0a00    
00004a  00                DCB      0
00004b  00                DCB      0
                  |L1.76|
00004c  6d617869          DCB      "maximum allocated memory: %d\n",0
000050  6d756d20
000054  616c6c6f
000058  63617465
00005c  64206d65
000060  6d6f7279
000064  3a202564
000068  0a00    
00006a  00                DCB      0
00006b  00                DCB      0

                          AREA ||i.plug_holes||, CODE, READONLY, ALIGN=2

                  plug_holes PROC
;;;135    
;;;136    static void plug_holes(struct heap_mem *mem)
000000  b570              PUSH     {r4-r6,lr}
;;;137    {
;;;138        struct heap_mem *nmem;
;;;139        struct heap_mem *pmem;
;;;140    
;;;141        RT_ASSERT((rt_uint8_t *)mem >= heap_ptr);
000002  4d21              LDR      r5,|L2.136|
000004  4604              MOV      r4,r0                 ;137
000006  6828              LDR      r0,[r5,#0]  ; heap_ptr
000008  4284              CMP      r4,r0
00000a  d204              BCS      |L2.22|
00000c  228d              MOVS     r2,#0x8d
00000e  491f              LDR      r1,|L2.140|
000010  a01f              ADR      r0,|L2.144|
000012  f7fffffe          BL       rt_assert_handler
                  |L2.22|
;;;142        RT_ASSERT((rt_uint8_t *)mem < (rt_uint8_t *)heap_end);
000016  6868              LDR      r0,[r5,#4]  ; heap_end
000018  4284              CMP      r4,r0
00001a  d304              BCC      |L2.38|
00001c  228e              MOVS     r2,#0x8e
00001e  491b              LDR      r1,|L2.140|
000020  a023              ADR      r0,|L2.176|
000022  f7fffffe          BL       rt_assert_handler
                  |L2.38|
;;;143        RT_ASSERT(mem->used == 0);
000026  8860              LDRH     r0,[r4,#2]
000028  2800              CMP      r0,#0
00002a  d004              BEQ      |L2.54|
00002c  228f              MOVS     r2,#0x8f
00002e  4917              LDR      r1,|L2.140|
000030  a02a              ADR      r0,|L2.220|
000032  f7fffffe          BL       rt_assert_handler
                  |L2.54|
;;;144    
;;;145        /* plug hole forward */
;;;146        nmem = (struct heap_mem *)&heap_ptr[mem->next];
000036  6860              LDR      r0,[r4,#4]
000038  6829              LDR      r1,[r5,#0]  ; heap_ptr
00003a  1840              ADDS     r0,r0,r1
;;;147        if (mem != nmem &&
00003c  4284              CMP      r4,r0
00003e  d010              BEQ      |L2.98|
;;;148            nmem->used == 0 &&
000040  8842              LDRH     r2,[r0,#2]
000042  2a00              CMP      r2,#0
000044  d10d              BNE      |L2.98|
;;;149            (rt_uint8_t *)nmem != (rt_uint8_t *)heap_end)
000046  686a              LDR      r2,[r5,#4]  ; heap_end
000048  4290              CMP      r0,r2
00004a  d00a              BEQ      |L2.98|
;;;150        {
;;;151            /* if mem->next is unused and not end of heap_ptr,
;;;152             * combine mem and mem->next
;;;153             */
;;;154            if (lfree == nmem)
00004c  68aa              LDR      r2,[r5,#8]  ; lfree
00004e  4282              CMP      r2,r0
000050  d100              BNE      |L2.84|
;;;155            {
;;;156                lfree = mem;
000052  60ac              STR      r4,[r5,#8]  ; lfree
                  |L2.84|
;;;157            }
;;;158            mem->next = nmem->next;
000054  6842              LDR      r2,[r0,#4]
;;;159            ((struct heap_mem *)&heap_ptr[nmem->next])->prev = (rt_uint8_t *)mem - heap_ptr;
000056  6062              STR      r2,[r4,#4]
000058  6843              LDR      r3,[r0,#4]
00005a  1a62              SUBS     r2,r4,r1
00005c  4608              MOV      r0,r1
00005e  3008              ADDS     r0,r0,#8
000060  501a              STR      r2,[r3,r0]
                  |L2.98|
;;;160        }
;;;161    
;;;162        /* plug hole backward */
;;;163        pmem = (struct heap_mem *)&heap_ptr[mem->prev];
000062  68a0              LDR      r0,[r4,#8]
000064  1840              ADDS     r0,r0,r1
;;;164        if (pmem != mem && pmem->used == 0)
000066  42a0              CMP      r0,r4
000068  d00c              BEQ      |L2.132|
00006a  8842              LDRH     r2,[r0,#2]
00006c  2a00              CMP      r2,#0
00006e  d109              BNE      |L2.132|
;;;165        {
;;;166            /* if mem->prev is unused, combine mem and mem->prev */
;;;167            if (lfree == mem)
000070  68aa              LDR      r2,[r5,#8]  ; lfree
000072  42a2              CMP      r2,r4
000074  d100              BNE      |L2.120|
;;;168            {
;;;169                lfree = pmem;
000076  60a8              STR      r0,[r5,#8]  ; lfree
                  |L2.120|
;;;170            }
;;;171            pmem->next = mem->next;
000078  6862              LDR      r2,[r4,#4]
;;;172            ((struct heap_mem *)&heap_ptr[mem->next])->prev = (rt_uint8_t *)pmem - heap_ptr;
00007a  6042              STR      r2,[r0,#4]
00007c  1a40              SUBS     r0,r0,r1
00007e  6862              LDR      r2,[r4,#4]
000080  3108              ADDS     r1,r1,#8
000082  5050              STR      r0,[r2,r1]
                  |L2.132|
;;;173        }
;;;174    }
000084  bd70              POP      {r4-r6,pc}
;;;175    
                          ENDP

000086  0000              DCW      0x0000
                  |L2.136|
                          DCD      ||.data||
                  |L2.140|
                          DCD      ||.constdata||+0x8
                  |L2.144|
000090  2872745f          DCB      "(rt_uint8_t *)mem >= heap_ptr",0
000094  75696e74
000098  385f7420
00009c  2a296d65
0000a0  6d203e3d
0000a4  20686561
0000a8  705f7074
0000ac  7200    
0000ae  00                DCB      0
0000af  00                DCB      0
                  |L2.176|
0000b0  2872745f          DCB      "(rt_uint8_t *)mem < (rt_uint8_t *)heap_end",0
0000b4  75696e74
0000b8  385f7420
0000bc  2a296d65
0000c0  6d203c20
0000c4  2872745f
0000c8  75696e74
0000cc  385f7420
0000d0  2a296865
0000d4  61705f65
0000d8  6e6400  
0000db  00                DCB      0
                  |L2.220|
0000dc  6d656d2d          DCB      "mem->used == 0",0
0000e0  3e757365
0000e4  64203d3d
0000e8  203000  
0000eb  00                DCB      0

                          AREA ||i.rt_calloc||, CODE, READONLY, ALIGN=2

                  rt_calloc PROC
;;;481     */
;;;482    void *rt_calloc(rt_size_t count, rt_size_t size)
000000  b570              PUSH     {r4-r6,lr}
;;;483    {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;484        void *p;
;;;485    
;;;486        RT_DEBUG_NOT_IN_INTERRUPT;
000006  f7fffffe          BL       rt_hw_interrupt_disable
00000a  4606              MOV      r6,r0
00000c  f7fffffe          BL       rt_interrupt_get_nest
000010  2800              CMP      r0,#0
000012  d009              BEQ      |L3.40|
000014  490c              LDR      r1,|L3.72|
000016  a00d              ADR      r0,|L3.76|
000018  f7fffffe          BL       rt_kprintf
00001c  22ff              MOVS     r2,#0xff
00001e  32e7              ADDS     r2,r2,#0xe7
000020  4909              LDR      r1,|L3.72|
000022  a013              ADR      r0,|L3.112|
000024  f7fffffe          BL       rt_assert_handler
                  |L3.40|
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       rt_hw_interrupt_enable
;;;487    
;;;488        /* allocate 'count' objects of size 'size' */
;;;489        p = rt_malloc(count * size);
00002e  436c              MULS     r4,r5,r4
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       rt_malloc
000036  0005              MOVS     r5,r0
;;;490    
;;;491        /* zero the memory */
;;;492        if (p)
000038  d003              BEQ      |L3.66|
00003a  4622              MOV      r2,r4
;;;493            rt_memset(p, 0, count * size);
00003c  2100              MOVS     r1,#0
00003e  f7fffffe          BL       rt_memset
                  |L3.66|
;;;494    
;;;495        return p;
000042  4628              MOV      r0,r5
;;;496    }
000044  bd70              POP      {r4-r6,pc}
;;;497    RTM_EXPORT(rt_calloc);
                          ENDP

000046  0000              DCW      0x0000
                  |L3.72|
                          DCD      ||.constdata||+0x3c
                  |L3.76|
00004c  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
000050  74696f6e
000054  5b25735d
000058  20736861
00005c  6c6c206e
000060  6f742075
000064  73656420
000068  696e2049
00006c  53520a00
                  |L3.112|
000070  3000              DCB      "0",0
000072  00                DCB      0
000073  00                DCB      0

                          AREA ||i.rt_free||, CODE, READONLY, ALIGN=2

                  rt_free PROC
;;;504     */
;;;505    void rt_free(void *rmem)
000000  b570              PUSH     {r4-r6,lr}
;;;506    {
000002  4604              MOV      r4,r0
;;;507        struct heap_mem *mem;
;;;508    
;;;509        RT_DEBUG_NOT_IN_INTERRUPT;
000004  f7fffffe          BL       rt_hw_interrupt_disable
000008  4605              MOV      r5,r0
00000a  f7fffffe          BL       rt_interrupt_get_nest
00000e  2800              CMP      r0,#0
000010  d009              BEQ      |L4.38|
000012  492c              LDR      r1,|L4.196|
000014  a02c              ADR      r0,|L4.200|
000016  f7fffffe          BL       rt_kprintf
00001a  22ff              MOVS     r2,#0xff
00001c  32fe              ADDS     r2,r2,#0xfe
00001e  4929              LDR      r1,|L4.196|
000020  a032              ADR      r0,|L4.236|
000022  f7fffffe          BL       rt_assert_handler
                  |L4.38|
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       rt_hw_interrupt_enable
;;;510    
;;;511        if (rmem == RT_NULL)
00002c  2c00              CMP      r4,#0
00002e  d047              BEQ      |L4.192|
;;;512            return;
;;;513        RT_ASSERT((((rt_uint32_t)rmem) & (RT_ALIGN_SIZE-1)) == 0);
000030  07a0              LSLS     r0,r4,#30
000032  d004              BEQ      |L4.62|
000034  4a2e              LDR      r2,|L4.240|
000036  4923              LDR      r1,|L4.196|
000038  a02e              ADR      r0,|L4.244|
00003a  f7fffffe          BL       rt_assert_handler
                  |L4.62|
;;;514        RT_ASSERT((rt_uint8_t *)rmem >= (rt_uint8_t *)heap_ptr &&
00003e  4d39              LDR      r5,|L4.292|
000040  6828              LDR      r0,[r5,#0]  ; heap_ptr
000042  4284              CMP      r4,r0
000044  d302              BCC      |L4.76|
000046  6868              LDR      r0,[r5,#4]  ; heap_end
000048  4284              CMP      r4,r0
00004a  d305              BCC      |L4.88|
                  |L4.76|
00004c  4a28              LDR      r2,|L4.240|
00004e  491d              LDR      r1,|L4.196|
000050  1c52              ADDS     r2,r2,#1
000052  4835              LDR      r0,|L4.296|
000054  f7fffffe          BL       rt_assert_handler
                  |L4.88|
;;;515                  (rt_uint8_t *)rmem < (rt_uint8_t *)heap_end);
;;;516    
;;;517        RT_OBJECT_HOOK_CALL(rt_free_hook, (rmem));
;;;518    
;;;519        if ((rt_uint8_t *)rmem < (rt_uint8_t *)heap_ptr ||
000058  6828              LDR      r0,[r5,#0]  ; heap_ptr
00005a  4284              CMP      r4,r0
00005c  d330              BCC      |L4.192|
;;;520            (rt_uint8_t *)rmem >= (rt_uint8_t *)heap_end)
00005e  6868              LDR      r0,[r5,#4]  ; heap_end
000060  4284              CMP      r4,r0
000062  d22d              BCS      |L4.192|
;;;521        {
;;;522            RT_DEBUG_LOG(RT_DEBUG_MEM, ("illegal memory\n"));
;;;523    
;;;524            return;
;;;525        }
;;;526    
;;;527        /* Get the corresponding struct heap_mem ... */
;;;528        mem = (struct heap_mem *)((rt_uint8_t *)rmem - SIZEOF_STRUCT_MEM);
;;;529    
;;;530        RT_DEBUG_LOG(RT_DEBUG_MEM,
;;;531                     ("release memory 0x%x, size: %d\n",
;;;532                      (rt_uint32_t)rmem,
;;;533                      (rt_uint32_t)(mem->next - ((rt_uint8_t *)mem - heap_ptr))));
;;;534    
;;;535    
;;;536        /* protect the heap from concurrent access */
;;;537        rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
000064  2100              MOVS     r1,#0
000066  43c9              MVNS     r1,r1
000068  4830              LDR      r0,|L4.300|
00006a  3c0c              SUBS     r4,r4,#0xc
00006c  f7fffffe          BL       rt_sem_take
;;;538    
;;;539        /* ... which has to be in a used state ... */
;;;540        RT_ASSERT(mem->used);
000070  8860              LDRH     r0,[r4,#2]
000072  2800              CMP      r0,#0
000074  d105              BNE      |L4.130|
000076  2287              MOVS     r2,#0x87
000078  0092              LSLS     r2,r2,#2
00007a  4912              LDR      r1,|L4.196|
00007c  a02c              ADR      r0,|L4.304|
00007e  f7fffffe          BL       rt_assert_handler
                  |L4.130|
;;;541        RT_ASSERT(mem->magic == HEAP_MAGIC);
000082  8820              LDRH     r0,[r4,#0]
000084  26f5              MOVS     r6,#0xf5
000086  0176              LSLS     r6,r6,#5
000088  42b0              CMP      r0,r6
00008a  d005              BEQ      |L4.152|
00008c  4a18              LDR      r2,|L4.240|
00008e  490d              LDR      r1,|L4.196|
000090  321c              ADDS     r2,r2,#0x1c
000092  a02a              ADR      r0,|L4.316|
000094  f7fffffe          BL       rt_assert_handler
                  |L4.152|
;;;542        /* ... and is now unused. */
;;;543        mem->used  = 0;
000098  2000              MOVS     r0,#0
00009a  8060              STRH     r0,[r4,#2]
;;;544        mem->magic = HEAP_MAGIC;
00009c  8026              STRH     r6,[r4,#0]
;;;545    
;;;546        if (mem < lfree)
00009e  68a8              LDR      r0,[r5,#8]  ; lfree
0000a0  4284              CMP      r4,r0
0000a2  d200              BCS      |L4.166|
;;;547        {
;;;548            /* the newly freed struct is now the lowest */
;;;549            lfree = mem;
0000a4  60ac              STR      r4,[r5,#8]  ; lfree
                  |L4.166|
;;;550        }
;;;551    
;;;552    #ifdef RT_MEM_STATS
;;;553        used_mem -= (mem->next - ((rt_uint8_t*)mem - heap_ptr));
0000a6  6829              LDR      r1,[r5,#0]  ; heap_ptr
0000a8  6860              LDR      r0,[r4,#4]
0000aa  1a61              SUBS     r1,r4,r1
0000ac  1a40              SUBS     r0,r0,r1
0000ae  6929              LDR      r1,[r5,#0x10]  ; used_mem
0000b0  1a08              SUBS     r0,r1,r0
;;;554    #endif
;;;555    
;;;556        /* finally, see if prev or next are free also */
;;;557        plug_holes(mem);
0000b2  6128              STR      r0,[r5,#0x10]  ; used_mem
0000b4  4620              MOV      r0,r4
0000b6  f7fffffe          BL       plug_holes
;;;558        rt_sem_release(&heap_sem);
0000ba  481c              LDR      r0,|L4.300|
0000bc  f7fffffe          BL       rt_sem_release
                  |L4.192|
;;;559    }
0000c0  bd70              POP      {r4-r6,pc}
;;;560    RTM_EXPORT(rt_free);
                          ENDP

0000c2  0000              DCW      0x0000
                  |L4.196|
                          DCD      ||.constdata||
                  |L4.200|
0000c8  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
0000cc  74696f6e
0000d0  5b25735d
0000d4  20736861
0000d8  6c6c206e
0000dc  6f742075
0000e0  73656420
0000e4  696e2049
0000e8  53520a00
                  |L4.236|
0000ec  3000              DCB      "0",0
0000ee  00                DCB      0
0000ef  00                DCB      0
                  |L4.240|
                          DCD      0x00000201
                  |L4.244|
0000f4  28282872          DCB      "(((rt_uint32_t)rmem) & (RT_ALIGN_SIZE-1)) == 0",0
0000f8  745f7569
0000fc  6e743332
000100  5f742972
000104  6d656d29
000108  20262028
00010c  52545f41
000110  4c49474e
000114  5f53495a
000118  452d3129
00011c  29203d3d
000120  203000  
000123  00                DCB      0
                  |L4.292|
                          DCD      ||.data||
                  |L4.296|
                          DCD      ||.conststring||+0x94
                  |L4.300|
                          DCD      ||.bss||
                  |L4.304|
000130  6d656d2d          DCB      "mem->used",0
000134  3e757365
000138  6400    
00013a  00                DCB      0
00013b  00                DCB      0
                  |L4.316|
00013c  6d656d2d          DCB      "mem->magic == HEAP_MAGIC",0
000140  3e6d6167
000144  6963203d
000148  3d204845
00014c  41505f4d
000150  41474943
000154  00      
000155  00                DCB      0
000156  00                DCB      0
000157  00                DCB      0

                          AREA ||i.rt_malloc||, CODE, READONLY, ALIGN=2

                  rt_malloc PROC
;;;245     */
;;;246    void *rt_malloc(rt_size_t size)
000000  b5f8              PUSH     {r3-r7,lr}
;;;247    {
000002  4604              MOV      r4,r0
;;;248        rt_size_t ptr, ptr2;
;;;249        struct heap_mem *mem, *mem2;
;;;250    
;;;251        RT_DEBUG_NOT_IN_INTERRUPT;
000004  f7fffffe          BL       rt_hw_interrupt_disable
000008  4605              MOV      r5,r0
00000a  f7fffffe          BL       rt_interrupt_get_nest
00000e  2800              CMP      r0,#0
000010  d008              BEQ      |L5.36|
000012  494f              LDR      r1,|L5.336|
000014  a04f              ADR      r0,|L5.340|
000016  f7fffffe          BL       rt_kprintf
00001a  22fb              MOVS     r2,#0xfb
00001c  494c              LDR      r1,|L5.336|
00001e  a056              ADR      r0,|L5.376|
000020  f7fffffe          BL       rt_assert_handler
                  |L5.36|
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       rt_hw_interrupt_enable
;;;252    
;;;253        if (size == 0)
00002a  2c00              CMP      r4,#0
00002c  d006              BEQ      |L5.60|
;;;254            return RT_NULL;
;;;255    
;;;256        if (size != RT_ALIGN(size, RT_ALIGN_SIZE))
;;;257            RT_DEBUG_LOG(RT_DEBUG_MEM, ("malloc size %d, but align to %d\n",
;;;258                                        size, RT_ALIGN(size, RT_ALIGN_SIZE)));
;;;259        else
;;;260            RT_DEBUG_LOG(RT_DEBUG_MEM, ("malloc size %d\n", size));
;;;261    
;;;262        /* alignment size */
;;;263        size = RT_ALIGN(size, RT_ALIGN_SIZE);
;;;264    
;;;265        if (size > mem_size_aligned)
00002e  4e53              LDR      r6,|L5.380|
000030  1ce4              ADDS     r4,r4,#3              ;253
000032  08a5              LSRS     r5,r4,#2              ;263
000034  68f0              LDR      r0,[r6,#0xc]  ; mem_size_aligned
000036  00ad              LSLS     r5,r5,#2              ;263
000038  4285              CMP      r5,r0
00003a  d901              BLS      |L5.64|
                  |L5.60|
;;;266        {
;;;267            RT_DEBUG_LOG(RT_DEBUG_MEM, ("no memory\n"));
;;;268    
;;;269            return RT_NULL;
00003c  2000              MOVS     r0,#0
;;;270        }
;;;271    
;;;272        /* every data block must be at least MIN_SIZE_ALIGNED long */
;;;273        if (size < MIN_SIZE_ALIGNED)
;;;274            size = MIN_SIZE_ALIGNED;
;;;275    
;;;276        /* take memory semaphore */
;;;277        rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
;;;278    
;;;279        for (ptr = (rt_uint8_t *)lfree - heap_ptr;
;;;280             ptr < mem_size_aligned - size;
;;;281             ptr = ((struct heap_mem *)&heap_ptr[ptr])->next)
;;;282        {
;;;283            mem = (struct heap_mem *)&heap_ptr[ptr];
;;;284    
;;;285            if ((!mem->used) && (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size)
;;;286            {
;;;287                /* mem is not used and at least perfect fit is possible:
;;;288                 * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */
;;;289    
;;;290                if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >=
;;;291                    (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED))
;;;292                {
;;;293                    /* (in addition to the above, we test if another struct heap_mem (SIZEOF_STRUCT_MEM) containing
;;;294                     * at least MIN_SIZE_ALIGNED of data also fits in the 'user data space' of 'mem')
;;;295                     * -> split large block, create empty remainder,
;;;296                     * remainder must be large enough to contain MIN_SIZE_ALIGNED data: if
;;;297                     * mem->next - (ptr + (2*SIZEOF_STRUCT_MEM)) == size,
;;;298                     * struct heap_mem would fit in but no data between mem2 and mem2->next
;;;299                     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
;;;300                     *       region that couldn't hold data, but when mem->next gets freed,
;;;301                     *       the 2 regions would be combined, resulting in more free memory
;;;302                     */
;;;303                    ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
;;;304    
;;;305                    /* create mem2 struct */
;;;306                    mem2       = (struct heap_mem *)&heap_ptr[ptr2];
;;;307                    mem2->magic = HEAP_MAGIC;
;;;308                    mem2->used = 0;
;;;309                    mem2->next = mem->next;
;;;310                    mem2->prev = ptr;
;;;311    
;;;312                    /* and insert it between mem and mem->next */
;;;313                    mem->next = ptr2;
;;;314                    mem->used = 1;
;;;315    
;;;316                    if (mem2->next != mem_size_aligned + SIZEOF_STRUCT_MEM)
;;;317                    {
;;;318                        ((struct heap_mem *)&heap_ptr[mem2->next])->prev = ptr2;
;;;319                    }
;;;320    #ifdef RT_MEM_STATS
;;;321                    used_mem += (size + SIZEOF_STRUCT_MEM);
;;;322                    if (max_mem < used_mem)
;;;323                        max_mem = used_mem;
;;;324    #endif
;;;325                }
;;;326                else
;;;327                {
;;;328                    /* (a mem2 struct does no fit into the user data space of mem and mem->next will always
;;;329                     * be used at this point: if not we have 2 unused structs in a row, plug_holes should have
;;;330                     * take care of this).
;;;331                     * -> near fit or excact fit: do not split, no mem2 creation
;;;332                     * also can't move mem->next directly behind mem, since mem->next
;;;333                     * will always be used at this point!
;;;334                     */
;;;335                    mem->used = 1;
;;;336    #ifdef RT_MEM_STATS
;;;337                    used_mem += mem->next - ((rt_uint8_t*)mem - heap_ptr);
;;;338                    if (max_mem < used_mem)
;;;339                        max_mem = used_mem;
;;;340    #endif
;;;341                }
;;;342                /* set memory block magic */
;;;343                mem->magic = HEAP_MAGIC;
;;;344    
;;;345                if (mem == lfree)
;;;346                {
;;;347                    /* Find next free block after mem and update lowest free pointer */
;;;348                    while (lfree->used && lfree != heap_end)
;;;349                        lfree = (struct heap_mem *)&heap_ptr[lfree->next];
;;;350    
;;;351                    RT_ASSERT(((lfree == heap_end) || (!lfree->used)));
;;;352                }
;;;353    
;;;354                rt_sem_release(&heap_sem);
;;;355                RT_ASSERT((rt_uint32_t)mem + SIZEOF_STRUCT_MEM + size <= (rt_uint32_t)heap_end);
;;;356                RT_ASSERT((rt_uint32_t)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM) % RT_ALIGN_SIZE == 0);
;;;357                RT_ASSERT((((rt_uint32_t)mem) & (RT_ALIGN_SIZE-1)) == 0);
;;;358    
;;;359                RT_DEBUG_LOG(RT_DEBUG_MEM,
;;;360                             ("allocate memory at 0x%x, size: %d\n",
;;;361                              (rt_uint32_t)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM),
;;;362                              (rt_uint32_t)(mem->next - ((rt_uint8_t *)mem - heap_ptr))));
;;;363    
;;;364                RT_OBJECT_HOOK_CALL(rt_malloc_hook,
;;;365                                    (((void *)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM)), size));
;;;366    
;;;367                /* return the memory data except mem struct */
;;;368                return (rt_uint8_t *)mem + SIZEOF_STRUCT_MEM;
;;;369            }
;;;370        }
;;;371    
;;;372        rt_sem_release(&heap_sem);
;;;373    
;;;374        return RT_NULL;
;;;375    }
00003e  bdf8              POP      {r3-r7,pc}
                  |L5.64|
000040  2d0c              CMP      r5,#0xc               ;273
000042  d200              BCS      |L5.70|
000044  250c              MOVS     r5,#0xc               ;274
                  |L5.70|
000046  2100              MOVS     r1,#0                 ;277
000048  43c9              MVNS     r1,r1                 ;277
00004a  484d              LDR      r0,|L5.384|
00004c  f7fffffe          BL       rt_sem_take
000050  68b0              LDR      r0,[r6,#8]            ;279  ; lfree
000052  6831              LDR      r1,[r6,#0]            ;279  ; heap_ptr
000054  68f2              LDR      r2,[r6,#0xc]          ;265
000056  4686              MOV      lr,r0                 ;279
000058  1a40              SUBS     r0,r0,r1              ;279
00005a  4694              MOV      r12,r2                ;265
00005c  1b53              SUBS     r3,r2,r5              ;280
00005e  e070              B        |L5.322|
                  |L5.96|
000060  180c              ADDS     r4,r1,r0              ;283
000062  8862              LDRH     r2,[r4,#2]            ;285
000064  2a00              CMP      r2,#0                 ;285
000066  d16b              BNE      |L5.320|
000068  6862              LDR      r2,[r4,#4]            ;285
00006a  1a12              SUBS     r2,r2,r0              ;285
00006c  3a0c              SUBS     r2,r2,#0xc            ;285
00006e  42aa              CMP      r2,r5                 ;285
000070  d366              BCC      |L5.320|
000072  6862              LDR      r2,[r4,#4]            ;290
000074  1a13              SUBS     r3,r2,r0              ;290
000076  462a              MOV      r2,r5                 ;290
000078  3218              ADDS     r2,r2,#0x18           ;290
00007a  3b0c              SUBS     r3,r3,#0xc            ;290
00007c  4293              CMP      r3,r2                 ;290
00007e  d32d              BCC      |L5.220|
000080  1943              ADDS     r3,r0,r5              ;303
000082  330c              ADDS     r3,r3,#0xc            ;303
000084  27f5              MOVS     r7,#0xf5              ;307
000086  18ca              ADDS     r2,r1,r3              ;306
000088  017f              LSLS     r7,r7,#5              ;307
00008a  8017              STRH     r7,[r2,#0]            ;307
00008c  2700              MOVS     r7,#0                 ;308
00008e  8057              STRH     r7,[r2,#2]            ;308
000090  6867              LDR      r7,[r4,#4]            ;309
000092  6057              STR      r7,[r2,#4]            ;313
000094  6090              STR      r0,[r2,#8]            ;313
000096  2001              MOVS     r0,#1                 ;314
000098  6063              STR      r3,[r4,#4]            ;314
00009a  8060              STRH     r0,[r4,#2]            ;314
00009c  6850              LDR      r0,[r2,#4]            ;316
00009e  4662              MOV      r2,r12                ;316
0000a0  320c              ADDS     r2,r2,#0xc            ;316
0000a2  4290              CMP      r0,r2                 ;316
0000a4  d002              BEQ      |L5.172|
0000a6  460a              MOV      r2,r1                 ;318
0000a8  3208              ADDS     r2,r2,#8              ;318
0000aa  5083              STR      r3,[r0,r2]            ;318
                  |L5.172|
0000ac  6930              LDR      r0,[r6,#0x10]         ;321  ; used_mem
0000ae  1940              ADDS     r0,r0,r5              ;321
0000b0  300c              ADDS     r0,r0,#0xc            ;321
                  |L5.178|
0000b2  6130              STR      r0,[r6,#0x10]         ;338  ; used_mem
0000b4  6972              LDR      r2,[r6,#0x14]         ;338  ; max_mem
0000b6  4282              CMP      r2,r0                 ;338
0000b8  d200              BCS      |L5.188|
0000ba  6170              STR      r0,[r6,#0x14]         ;339  ; max_mem
                  |L5.188|
0000bc  20f5              MOVS     r0,#0xf5              ;343
0000be  0140              LSLS     r0,r0,#5              ;343
0000c0  8020              STRH     r0,[r4,#0]            ;343
0000c2  4574              CMP      r4,lr                 ;345
0000c4  d11d              BNE      |L5.258|
0000c6  6872              LDR      r2,[r6,#4]            ;348
0000c8  68b0              LDR      r0,[r6,#8]            ;348  ; lfree
                  |L5.202|
0000ca  8843              LDRH     r3,[r0,#2]            ;348
0000cc  2b00              CMP      r3,#0                 ;348
0000ce  d00d              BEQ      |L5.236|
0000d0  4290              CMP      r0,r2                 ;348
0000d2  d00b              BEQ      |L5.236|
0000d4  6840              LDR      r0,[r0,#4]            ;349
0000d6  1840              ADDS     r0,r0,r1              ;349
0000d8  60b0              STR      r0,[r6,#8]            ;349  ; lfree
0000da  e7f6              B        |L5.202|
                  |L5.220|
0000dc  2001              MOVS     r0,#1                 ;335
0000de  8060              STRH     r0,[r4,#2]            ;335
0000e0  6860              LDR      r0,[r4,#4]            ;337
0000e2  1a62              SUBS     r2,r4,r1              ;337
0000e4  1a80              SUBS     r0,r0,r2              ;337
0000e6  6932              LDR      r2,[r6,#0x10]         ;337  ; used_mem
0000e8  1880              ADDS     r0,r0,r2              ;337
0000ea  e7e2              B        |L5.178|
                  |L5.236|
0000ec  4290              CMP      r0,r2                 ;351
0000ee  d008              BEQ      |L5.258|
0000f0  0418              LSLS     r0,r3,#16             ;351
0000f2  0c00              LSRS     r0,r0,#16             ;351
0000f4  d005              BEQ      |L5.258|
0000f6  22ff              MOVS     r2,#0xff              ;351
0000f8  3260              ADDS     r2,r2,#0x60           ;351
0000fa  4915              LDR      r1,|L5.336|
0000fc  a021              ADR      r0,|L5.388|
0000fe  f7fffffe          BL       rt_assert_handler
                  |L5.258|
000102  481f              LDR      r0,|L5.384|
000104  f7fffffe          BL       rt_sem_release
000108  1960              ADDS     r0,r4,r5              ;355
00010a  6871              LDR      r1,[r6,#4]            ;355  ; heap_end
00010c  300c              ADDS     r0,r0,#0xc            ;355
00010e  4288              CMP      r0,r1                 ;355
000110  d905              BLS      |L5.286|
000112  22ff              MOVS     r2,#0xff              ;355
000114  3264              ADDS     r2,r2,#0x64           ;355
000116  490e              LDR      r1,|L5.336|
000118  4824              LDR      r0,|L5.428|
00011a  f7fffffe          BL       rt_assert_handler
                  |L5.286|
00011e  07a0              LSLS     r0,r4,#30             ;356
000120  d00b              BEQ      |L5.314|
000122  22ff              MOVS     r2,#0xff              ;356
000124  3265              ADDS     r2,r2,#0x65           ;356
000126  490a              LDR      r1,|L5.336|
000128  4821              LDR      r0,|L5.432|
00012a  f7fffffe          BL       rt_assert_handler
00012e  22ff              MOVS     r2,#0xff              ;357
000130  3266              ADDS     r2,r2,#0x66           ;357
000132  4907              LDR      r1,|L5.336|
000134  a01f              ADR      r0,|L5.436|
000136  f7fffffe          BL       rt_assert_handler
                  |L5.314|
00013a  4620              MOV      r0,r4                 ;368
00013c  300c              ADDS     r0,r0,#0xc            ;368
00013e  bdf8              POP      {r3-r7,pc}
                  |L5.320|
000140  6860              LDR      r0,[r4,#4]            ;281
                  |L5.322|
000142  4283              CMP      r3,r0                 ;280
000144  d88c              BHI      |L5.96|
000146  480e              LDR      r0,|L5.384|
000148  f7fffffe          BL       rt_sem_release
00014c  e776              B        |L5.60|
;;;376    RTM_EXPORT(rt_malloc);
                          ENDP

00014e  0000              DCW      0x0000
                  |L5.336|
                          DCD      ||.constdata||+0x27
                  |L5.340|
000154  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
000158  74696f6e
00015c  5b25735d
000160  20736861
000164  6c6c206e
000168  6f742075
00016c  73656420
000170  696e2049
000174  53520a00
                  |L5.376|
000178  3000              DCB      "0",0
00017a  00                DCB      0
00017b  00                DCB      0
                  |L5.380|
                          DCD      ||.data||
                  |L5.384|
                          DCD      ||.bss||
                  |L5.388|
000184  28286c66          DCB      "((lfree == heap_end) || (!lfree->used))",0
000188  72656520
00018c  3d3d2068
000190  6561705f
000194  656e6429
000198  207c7c20
00019c  28216c66
0001a0  7265652d
0001a4  3e757365
0001a8  64292900
                  |L5.428|
                          DCD      ||.conststring||
                  |L5.432|
                          DCD      ||.conststring||+0x48
                  |L5.436|
0001b4  28282872          DCB      "(((rt_uint32_t)mem) & (RT_ALIGN_SIZE-1)) == 0",0
0001b8  745f7569
0001bc  6e743332
0001c0  5f74296d
0001c4  656d2920
0001c8  26202852
0001cc  545f414c
0001d0  49474e5f
0001d4  53495a45
0001d8  2d312929
0001dc  203d3d20
0001e0  3000    
0001e2  00                DCB      0
0001e3  00                DCB      0

                          AREA ||i.rt_memory_info||, CODE, READONLY, ALIGN=2

                  rt_memory_info PROC
;;;562    #ifdef RT_MEM_STATS
;;;563    void rt_memory_info(rt_uint32_t *total,
000000  b510              PUSH     {r4,lr}
;;;564                        rt_uint32_t *used,
;;;565                        rt_uint32_t *max_used)
;;;566    {
;;;567        if (total != RT_NULL)
;;;568            *total = mem_size_aligned;
000002  4b07              LDR      r3,|L6.32|
000004  2800              CMP      r0,#0                 ;567
000006  d001              BEQ      |L6.12|
000008  68dc              LDR      r4,[r3,#0xc]  ; mem_size_aligned
00000a  6004              STR      r4,[r0,#0]
                  |L6.12|
;;;569        if (used  != RT_NULL)
00000c  2900              CMP      r1,#0
00000e  d001              BEQ      |L6.20|
;;;570            *used = used_mem;
000010  6918              LDR      r0,[r3,#0x10]  ; used_mem
000012  6008              STR      r0,[r1,#0]
                  |L6.20|
;;;571        if (max_used != RT_NULL)
000014  2a00              CMP      r2,#0
000016  d001              BEQ      |L6.28|
;;;572            *max_used = max_mem;
000018  6958              LDR      r0,[r3,#0x14]  ; max_mem
00001a  6010              STR      r0,[r2,#0]
                  |L6.28|
;;;573    }
00001c  bd10              POP      {r4,pc}
;;;574    
                          ENDP

00001e  0000              DCW      0x0000
                  |L6.32|
                          DCD      ||.data||

                          AREA ||i.rt_realloc||, CODE, READONLY, ALIGN=2

                  rt_realloc PROC
;;;385     */
;;;386    void *rt_realloc(void *rmem, rt_size_t newsize)
000000  b5f8              PUSH     {r3-r7,lr}
;;;387    {
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;388        rt_size_t size;
;;;389        rt_size_t ptr, ptr2;
;;;390        struct heap_mem *mem, *mem2;
;;;391        void *nmem;
;;;392    
;;;393        RT_DEBUG_NOT_IN_INTERRUPT;
000006  f7fffffe          BL       rt_hw_interrupt_disable
00000a  4606              MOV      r6,r0
00000c  f7fffffe          BL       rt_interrupt_get_nest
000010  2800              CMP      r0,#0
000012  d009              BEQ      |L7.40|
000014  4932              LDR      r1,|L7.224|
000016  a033              ADR      r0,|L7.228|
000018  f7fffffe          BL       rt_kprintf
00001c  22ff              MOVS     r2,#0xff
00001e  328a              ADDS     r2,r2,#0x8a
000020  492f              LDR      r1,|L7.224|
000022  a039              ADR      r0,|L7.264|
000024  f7fffffe          BL       rt_assert_handler
                  |L7.40|
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       rt_hw_interrupt_enable
;;;394    
;;;395        /* alignment size */
;;;396        newsize = RT_ALIGN(newsize, RT_ALIGN_SIZE);
;;;397        if (newsize > mem_size_aligned)
00002e  4e37              LDR      r6,|L7.268|
000030  1ce4              ADDS     r4,r4,#3              ;393
000032  08a4              LSRS     r4,r4,#2              ;396
000034  68f0              LDR      r0,[r6,#0xc]  ; mem_size_aligned
000036  00a4              LSLS     r4,r4,#2              ;396
000038  4284              CMP      r4,r0
00003a  d901              BLS      |L7.64|
;;;398        {
;;;399            RT_DEBUG_LOG(RT_DEBUG_MEM, ("realloc: out of memory\n"));
;;;400    
;;;401            return RT_NULL;
00003c  2000              MOVS     r0,#0
;;;402        }
;;;403    
;;;404        /* allocate a new memory block */
;;;405        if (rmem == RT_NULL)
;;;406            return rt_malloc(newsize);
;;;407    
;;;408        rt_sem_take(&heap_sem, RT_WAITING_FOREVER);
;;;409    
;;;410        if ((rt_uint8_t *)rmem < (rt_uint8_t *)heap_ptr ||
;;;411            (rt_uint8_t *)rmem >= (rt_uint8_t *)heap_end)
;;;412        {
;;;413            /* illegal memory */
;;;414            rt_sem_release(&heap_sem);
;;;415    
;;;416            return rmem;
;;;417        }
;;;418    
;;;419        mem = (struct heap_mem *)((rt_uint8_t *)rmem - SIZEOF_STRUCT_MEM);
;;;420    
;;;421        ptr = (rt_uint8_t *)mem - heap_ptr;
;;;422        size = mem->next - ptr - SIZEOF_STRUCT_MEM;
;;;423        if (size == newsize)
;;;424        {
;;;425            /* the size is the same as */
;;;426            rt_sem_release(&heap_sem);
;;;427    
;;;428            return rmem;
;;;429        }
;;;430    
;;;431        if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE < size)
;;;432        {
;;;433            /* split memory block */
;;;434    #ifdef RT_MEM_STATS
;;;435            used_mem -= (size - newsize);
;;;436    #endif
;;;437    
;;;438            ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
;;;439            mem2 = (struct heap_mem *)&heap_ptr[ptr2];
;;;440            mem2->magic= HEAP_MAGIC;
;;;441            mem2->used = 0;
;;;442            mem2->next = mem->next;
;;;443            mem2->prev = ptr;
;;;444            mem->next = ptr2;
;;;445            if (mem2->next != mem_size_aligned + SIZEOF_STRUCT_MEM)
;;;446            {
;;;447                ((struct heap_mem *)&heap_ptr[mem2->next])->prev = ptr2;
;;;448            }
;;;449    
;;;450            plug_holes(mem2);
;;;451    
;;;452            rt_sem_release(&heap_sem);
;;;453    
;;;454            return rmem;
;;;455        }
;;;456        rt_sem_release(&heap_sem);
;;;457    
;;;458        /* expand memory */
;;;459        nmem = rt_malloc(newsize);
;;;460        if (nmem != RT_NULL) /* check memory */
;;;461        {
;;;462            rt_memcpy(nmem, rmem, size < newsize ? size : newsize);
;;;463            rt_free(rmem);
;;;464        }
;;;465    
;;;466        return nmem;
;;;467    }
00003e  bdf8              POP      {r3-r7,pc}
                  |L7.64|
000040  2d00              CMP      r5,#0                 ;405
000042  d017              BEQ      |L7.116|
000044  2100              MOVS     r1,#0                 ;408
000046  43c9              MVNS     r1,r1                 ;408
000048  4831              LDR      r0,|L7.272|
00004a  f7fffffe          BL       rt_sem_take
00004e  6832              LDR      r2,[r6,#0]            ;410  ; heap_ptr
000050  4295              CMP      r5,r2                 ;410
000052  d30a              BCC      |L7.106|
000054  6870              LDR      r0,[r6,#4]            ;411  ; heap_end
000056  4285              CMP      r5,r0                 ;411
000058  d207              BCS      |L7.106|
00005a  4629              MOV      r1,r5                 ;419
00005c  390c              SUBS     r1,r1,#0xc            ;419
00005e  6848              LDR      r0,[r1,#4]            ;422
000060  1a8b              SUBS     r3,r1,r2              ;421
000062  1ac7              SUBS     r7,r0,r3              ;422
000064  3f0c              SUBS     r7,r7,#0xc            ;422
000066  42a7              CMP      r7,r4                 ;423
000068  d108              BNE      |L7.124|
                  |L7.106|
00006a  4829              LDR      r0,|L7.272|
00006c  f7fffffe          BL       rt_sem_release
000070  4628              MOV      r0,r5                 ;428
000072  bdf8              POP      {r3-r7,pc}
                  |L7.116|
000074  4620              MOV      r0,r4                 ;406
000076  f7fffffe          BL       rt_malloc
00007a  bdf8              POP      {r3-r7,pc}
                  |L7.124|
00007c  4620              MOV      r0,r4                 ;431
00007e  3018              ADDS     r0,r0,#0x18           ;431
000080  42b8              CMP      r0,r7                 ;431
000082  d219              BCS      |L7.184|
000084  1b38              SUBS     r0,r7,r4              ;435
000086  6937              LDR      r7,[r6,#0x10]         ;435  ; used_mem
000088  191c              ADDS     r4,r3,r4              ;438
00008a  1a38              SUBS     r0,r7,r0              ;435
00008c  340c              ADDS     r4,r4,#0xc            ;438
00008e  6130              STR      r0,[r6,#0x10]         ;439  ; used_mem
000090  27f5              MOVS     r7,#0xf5              ;440
000092  1910              ADDS     r0,r2,r4              ;439
000094  017f              LSLS     r7,r7,#5              ;440
000096  8007              STRH     r7,[r0,#0]            ;440
000098  2700              MOVS     r7,#0                 ;441
00009a  8047              STRH     r7,[r0,#2]            ;441
00009c  684f              LDR      r7,[r1,#4]            ;442
00009e  6047              STR      r7,[r0,#4]            ;444
0000a0  6083              STR      r3,[r0,#8]            ;444
0000a2  604c              STR      r4,[r1,#4]            ;445
0000a4  68f3              LDR      r3,[r6,#0xc]          ;445  ; mem_size_aligned
0000a6  6841              LDR      r1,[r0,#4]            ;445
0000a8  330c              ADDS     r3,r3,#0xc            ;445
0000aa  4299              CMP      r1,r3                 ;445
0000ac  d001              BEQ      |L7.178|
0000ae  3208              ADDS     r2,r2,#8              ;445
0000b0  508c              STR      r4,[r1,r2]            ;447
                  |L7.178|
0000b2  f7fffffe          BL       plug_holes
0000b6  e7d8              B        |L7.106|
                  |L7.184|
0000b8  4815              LDR      r0,|L7.272|
0000ba  f7fffffe          BL       rt_sem_release
0000be  4620              MOV      r0,r4                 ;459
0000c0  f7fffffe          BL       rt_malloc
0000c4  0006              MOVS     r6,r0                 ;459
0000c6  d009              BEQ      |L7.220|
0000c8  42a7              CMP      r7,r4                 ;462
0000ca  d200              BCS      |L7.206|
0000cc  463c              MOV      r4,r7                 ;462
                  |L7.206|
0000ce  4622              MOV      r2,r4                 ;462
0000d0  4629              MOV      r1,r5                 ;462
0000d2  f7fffffe          BL       rt_memcpy
0000d6  4628              MOV      r0,r5                 ;463
0000d8  f7fffffe          BL       rt_free
                  |L7.220|
0000dc  4630              MOV      r0,r6                 ;466
0000de  bdf8              POP      {r3-r7,pc}
;;;468    RTM_EXPORT(rt_realloc);
                          ENDP

                  |L7.224|
                          DCD      ||.constdata||+0x31
                  |L7.228|
0000e4  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
0000e8  74696f6e
0000ec  5b25735d
0000f0  20736861
0000f4  6c6c206e
0000f8  6f742075
0000fc  73656420
000100  696e2049
000104  53520a00
                  |L7.264|
000108  3000              DCB      "0",0
00010a  00                DCB      0
00010b  00                DCB      0
                  |L7.268|
                          DCD      ||.data||
                  |L7.272|
                          DCD      ||.bss||

                          AREA ||i.rt_system_heap_init||, CODE, READONLY, ALIGN=2

                  rt_system_heap_init PROC
;;;183     */
;;;184    void rt_system_heap_init(void *begin_addr, void *end_addr)
000000  b5f8              PUSH     {r3-r7,lr}
;;;185    {
000002  4606              MOV      r6,r0
;;;186        struct heap_mem *mem;
;;;187        rt_uint32_t begin_align = RT_ALIGN((rt_uint32_t)begin_addr, RT_ALIGN_SIZE);
000004  1cc0              ADDS     r0,r0,#3
000006  0884              LSRS     r4,r0,#2
;;;188        rt_uint32_t end_align = RT_ALIGN_DOWN((rt_uint32_t)end_addr, RT_ALIGN_SIZE);
000008  088d              LSRS     r5,r1,#2
00000a  460f              MOV      r7,r1                 ;185
00000c  00a4              LSLS     r4,r4,#2              ;187
00000e  00ad              LSLS     r5,r5,#2
;;;189    
;;;190        RT_DEBUG_NOT_IN_INTERRUPT;
000010  f7fffffe          BL       rt_hw_interrupt_disable
000014  9000              STR      r0,[sp,#0]
000016  f7fffffe          BL       rt_interrupt_get_nest
00001a  2800              CMP      r0,#0
00001c  d008              BEQ      |L8.48|
00001e  491a              LDR      r1,|L8.136|
000020  a01a              ADR      r0,|L8.140|
000022  f7fffffe          BL       rt_kprintf
000026  22be              MOVS     r2,#0xbe
000028  4917              LDR      r1,|L8.136|
00002a  a021              ADR      r0,|L8.176|
00002c  f7fffffe          BL       rt_assert_handler
                  |L8.48|
000030  9800              LDR      r0,[sp,#0]
000032  f7fffffe          BL       rt_hw_interrupt_enable
;;;191    
;;;192        /* alignment addr */
;;;193        if ((end_align > (2 * SIZEOF_STRUCT_MEM)) &&
000036  2d18              CMP      r5,#0x18
000038  d91f              BLS      |L8.122|
;;;194            ((end_align - 2 * SIZEOF_STRUCT_MEM) >= begin_align))
00003a  4628              MOV      r0,r5
00003c  3818              SUBS     r0,r0,#0x18
00003e  42a0              CMP      r0,r4
000040  d31b              BCC      |L8.122|
;;;195        {
;;;196            /* calculate the aligned memory size */
;;;197            mem_size_aligned = end_align - begin_align - 2 * SIZEOF_STRUCT_MEM;
000042  1b29              SUBS     r1,r5,r4
000044  4d1b              LDR      r5,|L8.180|
000046  3918              SUBS     r1,r1,#0x18
;;;198        }
;;;199        else
;;;200        {
;;;201            rt_kprintf("mem init, error begin address 0x%x, and end address 0x%x\n",
;;;202                       (rt_uint32_t)begin_addr, (rt_uint32_t)end_addr);
;;;203    
;;;204            return;
;;;205        }
;;;206    
;;;207        /* point to begin address of heap */
;;;208        heap_ptr = (rt_uint8_t *)begin_align;
;;;209    
;;;210        RT_DEBUG_LOG(RT_DEBUG_MEM, ("mem init, heap begin address 0x%x, size %d\n",
;;;211                                    (rt_uint32_t)heap_ptr, mem_size_aligned));
;;;212    
;;;213        /* initialize the start of the heap */
;;;214        mem        = (struct heap_mem *)heap_ptr;
;;;215        mem->magic = HEAP_MAGIC;
000048  602c              STR      r4,[r5,#0]  ; heap_ptr
00004a  22f5              MOVS     r2,#0xf5
00004c  60e9              STR      r1,[r5,#0xc]  ; mem_size_aligned
00004e  0152              LSLS     r2,r2,#5
000050  8022              STRH     r2,[r4,#0]
000052  310c              ADDS     r1,r1,#0xc
;;;216        mem->next  = mem_size_aligned + SIZEOF_STRUCT_MEM;
;;;217        mem->prev  = 0;
000054  2000              MOVS     r0,#0
;;;218        mem->used  = 0;
000056  6061              STR      r1,[r4,#4]
000058  60a0              STR      r0,[r4,#8]
00005a  8060              STRH     r0,[r4,#2]
;;;219    
;;;220        /* initialize the end of the heap */
;;;221        heap_end        = (struct heap_mem *)&heap_ptr[mem->next];
00005c  1908              ADDS     r0,r1,r4
;;;222        heap_end->magic = HEAP_MAGIC;
00005e  6068              STR      r0,[r5,#4]  ; heap_end
000060  8002              STRH     r2,[r0,#0]
;;;223        heap_end->used  = 1;
000062  2201              MOVS     r2,#1
000064  8042              STRH     r2,[r0,#2]
;;;224        heap_end->next  = mem_size_aligned + SIZEOF_STRUCT_MEM;
;;;225        heap_end->prev  = mem_size_aligned + SIZEOF_STRUCT_MEM;
000066  6041              STR      r1,[r0,#4]
;;;226    
;;;227        rt_sem_init(&heap_sem, "heap", 1, RT_IPC_FLAG_FIFO);
000068  6081              STR      r1,[r0,#8]
00006a  2300              MOVS     r3,#0
00006c  a112              ADR      r1,|L8.184|
00006e  4814              LDR      r0,|L8.192|
000070  f7fffffe          BL       rt_sem_init
;;;228    
;;;229        /* initialize the lowest-free pointer to the start of the heap */
;;;230        lfree = (struct heap_mem *)heap_ptr;
000074  6828              LDR      r0,[r5,#0]  ; heap_ptr
000076  60a8              STR      r0,[r5,#8]            ;197  ; lfree
;;;231    }
000078  bdf8              POP      {r3-r7,pc}
                  |L8.122|
00007a  463a              MOV      r2,r7                 ;201
00007c  4631              MOV      r1,r6                 ;201
00007e  a011              ADR      r0,|L8.196|
000080  f7fffffe          BL       rt_kprintf
000084  bdf8              POP      {r3-r7,pc}
;;;232    
                          ENDP

000086  0000              DCW      0x0000
                  |L8.136|
                          DCD      ||.constdata||+0x13
                  |L8.140|
00008c  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
000090  74696f6e
000094  5b25735d
000098  20736861
00009c  6c6c206e
0000a0  6f742075
0000a4  73656420
0000a8  696e2049
0000ac  53520a00
                  |L8.176|
0000b0  3000              DCB      "0",0
0000b2  00                DCB      0
0000b3  00                DCB      0
                  |L8.180|
                          DCD      ||.data||
                  |L8.184|
0000b8  68656170          DCB      "heap",0
0000bc  00      
0000bd  00                DCB      0
0000be  00                DCB      0
0000bf  00                DCB      0
                  |L8.192|
                          DCD      ||.bss||
                  |L8.196|
0000c4  6d656d20          DCB      "mem init, error begin address 0x%x, and end address 0x%"
0000c8  696e6974
0000cc  2c206572
0000d0  726f7220
0000d4  62656769
0000d8  6e206164
0000dc  64726573
0000e0  73203078
0000e4  25782c20
0000e8  616e6420
0000ec  656e6420
0000f0  61646472
0000f4  65737320
0000f8  307825  
0000fb  780a00            DCB      "x\n",0
0000fe  00                DCB      0
0000ff  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  heap_sem
                          %        32

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  72745f66          DCB      0x72,0x74,0x5f,0x66
000004  72656500          DCB      0x72,0x65,0x65,0x00
                  |symbol_number.36|
000008  706c7567          DCB      0x70,0x6c,0x75,0x67
00000c  5f686f6c          DCB      0x5f,0x68,0x6f,0x6c
000010  657300            DCB      0x65,0x73,0x00
                  |symbol_number.37|
000013  72                DCB      0x72
000014  745f7379          DCB      0x74,0x5f,0x73,0x79
000018  7374656d          DCB      0x73,0x74,0x65,0x6d
00001c  5f686561          DCB      0x5f,0x68,0x65,0x61
000020  705f696e          DCB      0x70,0x5f,0x69,0x6e
000024  697400            DCB      0x69,0x74,0x00
                  |symbol_number.38|
000027  72                DCB      0x72
000028  745f6d61          DCB      0x74,0x5f,0x6d,0x61
00002c  6c6c6f63          DCB      0x6c,0x6c,0x6f,0x63
000030  00                DCB      0x00
                  |symbol_number.39|
000031  72745f            DCB      0x72,0x74,0x5f
000034  7265616c          DCB      0x72,0x65,0x61,0x6c
000038  6c6f6300          DCB      0x6c,0x6f,0x63,0x00
                  |symbol_number.40|
00003c  72745f63          DCB      0x72,0x74,0x5f,0x63
000040  616c6c6f          DCB      0x61,0x6c,0x6c,0x6f
000044  6300              DCB      0x63,0x00

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  2872745f          DCB      "(rt_uint32_t)mem + SIZEOF_STRUCT_MEM + size <= (rt_uint"
000004  75696e74
000008  33325f74
00000c  296d656d
000010  202b2053
000014  495a454f
000018  465f5354
00001c  52554354
000020  5f4d454d
000024  202b2073
000028  697a6520
00002c  3c3d2028
000030  72745f75
000034  696e74  
000037  33325f74          DCB      "32_t)heap_end",0
00003b  29686561
00003f  705f656e
000043  6400    
000045  00                DCB      0
000046  00                DCB      0
000047  00                DCB      0
000048  2872745f          DCB      "(rt_uint32_t)((rt_uint8_t *)mem + SIZEOF_STRUCT_MEM) % "
00004c  75696e74
000050  33325f74
000054  29282872
000058  745f7569
00005c  6e74385f
000060  74202a29
000064  6d656d20
000068  2b205349
00006c  5a454f46
000070  5f535452
000074  5543545f
000078  4d454d29
00007c  202520  
00007f  52545f41          DCB      "RT_ALIGN_SIZE == 0",0
000083  4c49474e
000087  5f53495a
00008b  45203d3d
00008f  203000  
000092  00                DCB      0
000093  00                DCB      0
000094  2872745f          DCB      "(rt_uint8_t *)rmem >= (rt_uint8_t *)heap_ptr && (rt_uin"
000098  75696e74
00009c  385f7420
0000a0  2a29726d
0000a4  656d203e
0000a8  3d202872
0000ac  745f7569
0000b0  6e74385f
0000b4  74202a29
0000b8  68656170
0000bc  5f707472
0000c0  20262620
0000c4  2872745f
0000c8  75696e  
0000cb  74385f74          DCB      "t8_t *)rmem < (rt_uint8_t *)heap_end",0
0000cf  202a2972
0000d3  6d656d20
0000d7  3c202872
0000db  745f7569
0000df  6e74385f
0000e3  74202a29
0000e7  68656170
0000eb  5f656e64
0000ef  00      

                          AREA ||.data||, DATA, ALIGN=2

                  heap_ptr
                          DCD      0x00000000
                  heap_end
                          DCD      0x00000000
                  lfree
                          DCD      0x00000000
                  mem_size_aligned
                          DCD      0x00000000
                  used_mem
                          DCD      0x00000000
                  max_mem
                          DCD      0x00000000

                          AREA ||.rodata.name||, DATA, READONLY, ALIGN=0

                  __fsym_list_mem_name
000000  6c697374          DCB      0x6c,0x69,0x73,0x74
000004  5f6d656d          DCB      0x5f,0x6d,0x65,0x6d
000008  00                DCB      0x00

                          AREA ||area_number.16||, DATA, READONLY, ALIGN=0

                          EXPORTAS ||area_number.16||, ||.rodata.name||
                  __fsym_list_mem_desc
000000  6c697374          DCB      0x6c,0x69,0x73,0x74
000004  206d656d          DCB      0x20,0x6d,0x65,0x6d
000008  6f727920          DCB      0x6f,0x72,0x79,0x20
00000c  75736167          DCB      0x75,0x73,0x61,0x67
000010  6520696e          DCB      0x65,0x20,0x69,0x6e
000014  666f726d          DCB      0x66,0x6f,0x72,0x6d
000018  6174696f          DCB      0x61,0x74,0x69,0x6f
00001c  6e00              DCB      0x6e,0x00

                          AREA FSymTab, DATA, READONLY, ALIGN=2

                  __fsym_list_mem
                          DCD      __fsym_list_mem_name
                          DCD      __fsym_list_mem_desc
                          DCD      list_mem
