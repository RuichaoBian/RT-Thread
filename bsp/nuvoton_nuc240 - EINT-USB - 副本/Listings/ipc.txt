; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\ipc.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\ipc.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I.\Libraries\Device\Nuvoton -I..\..\components\finsh -I.\Libraries\CMSIS\Include -I.\Libraries\StdDriver\inc -I..\..\include -I.\APP -I.\Drivers -I..\..\components\drivers\include -I..\..\components\drivers\include\drivers -I..\nuvoton_nuc240 -I.\Libraries\Device\Nuvoton\NUC230_240\Include -I..\..\include -I..\..\components\drivers\usb\usbdevice\class -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=521 -DRT_DEBUG --omf_browse=.\objects\ipc.crf ..\..\src\ipc.c]
                          THUMB

                          AREA ||i.rt_event_control||, CODE, READONLY, ALIGN=2

                  rt_event_control PROC
;;;1212    */
;;;1213   rt_err_t rt_event_control(rt_event_t event, rt_uint8_t cmd, void *arg)
000000  b570              PUSH     {r4-r6,lr}
;;;1214   {
000002  460d              MOV      r5,r1
000004  0004              MOVS     r4,r0
000006  d105              BNE      |L1.20|
;;;1215       rt_ubase_t level;
;;;1216       RT_ASSERT(event != RT_NULL);
000008  2213              MOVS     r2,#0x13
00000a  0192              LSLS     r2,r2,#6
00000c  490c              LDR      r1,|L1.64|
00000e  a00d              ADR      r0,|L1.68|
000010  f7fffffe          BL       rt_assert_handler
                  |L1.20|
;;;1217   
;;;1218       if (cmd == RT_IPC_CMD_RESET)
000014  2d01              CMP      r5,#1
000016  d002              BEQ      |L1.30|
;;;1219       {
;;;1220           /* disable interrupt */
;;;1221           level = rt_hw_interrupt_disable();
;;;1222   
;;;1223           /* resume all waiting thread */
;;;1224           rt_ipc_list_resume_all(&event->parent.suspend_thread);
;;;1225   
;;;1226           /* init event set */
;;;1227           event->set = 0;
;;;1228   
;;;1229           /* enable interrupt */
;;;1230           rt_hw_interrupt_enable(level);
;;;1231   
;;;1232           rt_schedule();
;;;1233   
;;;1234           return RT_EOK;
;;;1235       }
;;;1236   
;;;1237       return -RT_ERROR;
000018  2000              MOVS     r0,#0
00001a  43c0              MVNS     r0,r0
;;;1238   }
00001c  bd70              POP      {r4-r6,pc}
                  |L1.30|
00001e  f7fffffe          BL       rt_hw_interrupt_disable
000022  4605              MOV      r5,r0                 ;1221
000024  4620              MOV      r0,r4                 ;1224
000026  3014              ADDS     r0,r0,#0x14           ;1224
000028  f7fffffe          BL       rt_ipc_list_resume_all
00002c  2000              MOVS     r0,#0                 ;1227
00002e  61e0              STR      r0,[r4,#0x1c]         ;1230
000030  4628              MOV      r0,r5                 ;1230
000032  f7fffffe          BL       rt_hw_interrupt_enable
000036  f7fffffe          BL       rt_schedule
00003a  2000              MOVS     r0,#0                 ;1234
00003c  bd70              POP      {r4-r6,pc}
;;;1239   RTM_EXPORT(rt_event_control);
                          ENDP

00003e  0000              DCW      0x0000
                  |L1.64|
                          DCD      ||.constdata||+0x108
                  |L1.68|
000044  6576656e          DCB      "event != RT_NULL",0
000048  7420213d
00004c  2052545f
000050  4e554c4c
000054  00      
000055  00                DCB      0
000056  00                DCB      0
000057  00                DCB      0

                          AREA ||i.rt_event_create||, CODE, READONLY, ALIGN=2

                  rt_event_create PROC
;;;939     */
;;;940    rt_event_t rt_event_create(const char *name, rt_uint8_t flag)
000000  b570              PUSH     {r4-r6,lr}
;;;941    {
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;942        rt_event_t event;
;;;943    
;;;944        RT_DEBUG_NOT_IN_INTERRUPT;
000006  f7fffffe          BL       rt_hw_interrupt_disable
00000a  4606              MOV      r6,r0
00000c  f7fffffe          BL       rt_interrupt_get_nest
000010  2800              CMP      r0,#0
000012  d009              BEQ      |L2.40|
000014  490d              LDR      r1,|L2.76|
000016  a00e              ADR      r0,|L2.80|
000018  f7fffffe          BL       rt_kprintf
00001c  223b              MOVS     r2,#0x3b
00001e  0112              LSLS     r2,r2,#4
000020  490a              LDR      r1,|L2.76|
000022  a014              ADR      r0,|L2.116|
000024  f7fffffe          BL       rt_assert_handler
                  |L2.40|
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       rt_hw_interrupt_enable
;;;945    
;;;946        /* allocate object */
;;;947        event = (rt_event_t)rt_object_allocate(RT_Object_Class_Event, name);
00002e  4629              MOV      r1,r5
000030  2003              MOVS     r0,#3
000032  f7fffffe          BL       rt_object_allocate
;;;948        if (event == RT_NULL)
000036  2800              CMP      r0,#0
000038  d006              BEQ      |L2.72|
00003a  4601              MOV      r1,r0
;;;949            return event;
;;;950    
;;;951        /* set parent */
;;;952        event->parent.parent.flag = flag;
00003c  7244              STRB     r4,[r0,#9]
00003e  3114              ADDS     r1,r1,#0x14
000040  6181              STR      r1,[r0,#0x18]
;;;953    
;;;954        /* init ipc object */
;;;955        rt_ipc_object_init(&(event->parent));
;;;956    
;;;957        /* init event */
;;;958        event->set = 0;
000042  6141              STR      r1,[r0,#0x14]
000044  2100              MOVS     r1,#0
000046  61c1              STR      r1,[r0,#0x1c]
                  |L2.72|
;;;959    
;;;960        return event;
;;;961    }
000048  bd70              POP      {r4-r6,pc}
;;;962    RTM_EXPORT(rt_event_create);
                          ENDP

00004a  0000              DCW      0x0000
                  |L2.76|
                          DCD      ||.constdata||+0xcc
                  |L2.80|
000050  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
000054  74696f6e
000058  5b25735d
00005c  20736861
000060  6c6c206e
000064  6f742075
000068  73656420
00006c  696e2049
000070  53520a00
                  |L2.116|
000074  3000              DCB      "0",0
000076  00                DCB      0
000077  00                DCB      0

                          AREA ||i.rt_event_delete||, CODE, READONLY, ALIGN=2

                  rt_event_delete PROC
;;;970     */
;;;971    rt_err_t rt_event_delete(rt_event_t event)
000000  b570              PUSH     {r4-r6,lr}
;;;972    {
000002  0004              MOVS     r4,r0
000004  d104              BNE      |L3.16|
;;;973        /* parameter check */
;;;974        RT_ASSERT(event != RT_NULL);
000006  4a11              LDR      r2,|L3.76|
000008  4911              LDR      r1,|L3.80|
00000a  a012              ADR      r0,|L3.84|
00000c  f7fffffe          BL       rt_assert_handler
                  |L3.16|
;;;975    
;;;976        RT_DEBUG_NOT_IN_INTERRUPT;
000010  f7fffffe          BL       rt_hw_interrupt_disable
000014  4605              MOV      r5,r0
000016  f7fffffe          BL       rt_interrupt_get_nest
00001a  2800              CMP      r0,#0
00001c  d009              BEQ      |L3.50|
00001e  490c              LDR      r1,|L3.80|
000020  a011              ADR      r0,|L3.104|
000022  f7fffffe          BL       rt_kprintf
000026  223d              MOVS     r2,#0x3d
000028  0112              LSLS     r2,r2,#4
00002a  4909              LDR      r1,|L3.80|
00002c  a017              ADR      r0,|L3.140|
00002e  f7fffffe          BL       rt_assert_handler
                  |L3.50|
000032  4628              MOV      r0,r5
000034  f7fffffe          BL       rt_hw_interrupt_enable
;;;977    
;;;978        /* resume all suspended thread */
;;;979        rt_ipc_list_resume_all(&(event->parent.suspend_thread));
000038  4620              MOV      r0,r4
00003a  3014              ADDS     r0,r0,#0x14
00003c  f7fffffe          BL       rt_ipc_list_resume_all
;;;980    
;;;981        /* delete event object */
;;;982        rt_object_delete(&(event->parent.parent));
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       rt_object_delete
;;;983    
;;;984        return RT_EOK;
000046  2000              MOVS     r0,#0
;;;985    }
000048  bd70              POP      {r4-r6,pc}
;;;986    RTM_EXPORT(rt_event_delete);
                          ENDP

00004a  0000              DCW      0x0000
                  |L3.76|
                          DCD      0x000003ce
                  |L3.80|
                          DCD      ||.constdata||+0xdc
                  |L3.84|
000054  6576656e          DCB      "event != RT_NULL",0
000058  7420213d
00005c  2052545f
000060  4e554c4c
000064  00      
000065  00                DCB      0
000066  00                DCB      0
000067  00                DCB      0
                  |L3.104|
000068  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
00006c  74696f6e
000070  5b25735d
000074  20736861
000078  6c6c206e
00007c  6f742075
000080  73656420
000084  696e2049
000088  53520a00
                  |L3.140|
00008c  3000              DCB      "0",0
00008e  00                DCB      0
00008f  00                DCB      0

                          AREA ||i.rt_event_detach||, CODE, READONLY, ALIGN=2

                  rt_event_detach PROC
;;;915     */
;;;916    rt_err_t rt_event_detach(rt_event_t event)
000000  b510              PUSH     {r4,lr}
;;;917    {
000002  0004              MOVS     r4,r0
000004  d104              BNE      |L4.16|
;;;918        /* parameter check */
;;;919        RT_ASSERT(event != RT_NULL);
000006  4a07              LDR      r2,|L4.36|
000008  4907              LDR      r1,|L4.40|
00000a  a008              ADR      r0,|L4.44|
00000c  f7fffffe          BL       rt_assert_handler
                  |L4.16|
;;;920    
;;;921        /* resume all suspended thread */
;;;922        rt_ipc_list_resume_all(&(event->parent.suspend_thread));
000010  4620              MOV      r0,r4
000012  3014              ADDS     r0,r0,#0x14
000014  f7fffffe          BL       rt_ipc_list_resume_all
;;;923    
;;;924        /* detach event object */
;;;925        rt_object_detach(&(event->parent.parent));
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       rt_object_detach
;;;926    
;;;927        return RT_EOK;
00001e  2000              MOVS     r0,#0
;;;928    }
000020  bd10              POP      {r4,pc}
;;;929    RTM_EXPORT(rt_event_detach);
                          ENDP

000022  0000              DCW      0x0000
                  |L4.36|
                          DCD      0x00000397
                  |L4.40|
                          DCD      ||.constdata||+0xbc
                  |L4.44|
00002c  6576656e          DCB      "event != RT_NULL",0
000030  7420213d
000034  2052545f
000038  4e554c4c
00003c  00      
00003d  00                DCB      0
00003e  00                DCB      0
00003f  00                DCB      0

                          AREA ||i.rt_event_init||, CODE, READONLY, ALIGN=2

                  rt_event_init PROC
;;;888     */
;;;889    rt_err_t rt_event_init(rt_event_t event, const char *name, rt_uint8_t flag)
000000  b570              PUSH     {r4-r6,lr}
;;;890    {
000002  4615              MOV      r5,r2
000004  460e              MOV      r6,r1
000006  0004              MOVS     r4,r0
000008  d104              BNE      |L5.20|
;;;891        RT_ASSERT(event != RT_NULL);
00000a  4a09              LDR      r2,|L5.48|
00000c  4909              LDR      r1,|L5.52|
00000e  a00a              ADR      r0,|L5.56|
000010  f7fffffe          BL       rt_assert_handler
                  |L5.20|
;;;892    
;;;893        /* init object */
;;;894        rt_object_init(&(event->parent.parent), RT_Object_Class_Event, name);
000014  4632              MOV      r2,r6
000016  2103              MOVS     r1,#3
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       rt_object_init
00001e  4620              MOV      r0,r4
;;;895    
;;;896        /* set parent flag */
;;;897        event->parent.parent.flag = flag;
000020  7265              STRB     r5,[r4,#9]
000022  3014              ADDS     r0,r0,#0x14
000024  61a0              STR      r0,[r4,#0x18]
;;;898    
;;;899        /* init ipc object */
;;;900        rt_ipc_object_init(&(event->parent));
;;;901    
;;;902        /* init event */
;;;903        event->set = 0;
000026  6160              STR      r0,[r4,#0x14]
000028  2000              MOVS     r0,#0
00002a  61e0              STR      r0,[r4,#0x1c]
;;;904    
;;;905        return RT_EOK;
;;;906    }
00002c  bd70              POP      {r4-r6,pc}
;;;907    RTM_EXPORT(rt_event_init);
                          ENDP

00002e  0000              DCW      0x0000
                  |L5.48|
                          DCD      0x0000037b
                  |L5.52|
                          DCD      ||.constdata||+0xae
                  |L5.56|
000038  6576656e          DCB      "event != RT_NULL",0
00003c  7420213d
000040  2052545f
000044  4e554c4c
000048  00      
000049  00                DCB      0
00004a  00                DCB      0
00004b  00                DCB      0

                          AREA ||i.rt_event_recv||, CODE, READONLY, ALIGN=2

                  rt_event_recv PROC
;;;1092    */
;;;1093   rt_err_t rt_event_recv(rt_event_t   event,
000000  b5ff              PUSH     {r0-r7,lr}
;;;1094                          rt_uint32_t  set,
;;;1095                          rt_uint8_t   option,
;;;1096                          rt_int32_t   timeout,
;;;1097                          rt_uint32_t *recved)
;;;1098   {
000002  b083              SUB      sp,sp,#0xc
000004  4617              MOV      r7,r2
000006  460e              MOV      r6,r1
000008  4605              MOV      r5,r0
;;;1099       struct rt_thread *thread;
;;;1100       register rt_ubase_t level;
;;;1101       register rt_base_t status;
;;;1102   
;;;1103       RT_DEBUG_IN_THREAD_CONTEXT;
00000a  f7fffffe          BL       rt_hw_interrupt_disable
00000e  9001              STR      r0,[sp,#4]
000010  f7fffffe          BL       rt_thread_self
000014  4c43              LDR      r4,|L6.292|
000016  2800              CMP      r0,#0
000018  d108              BNE      |L6.44|
00001a  4943              LDR      r1,|L6.296|
00001c  a043              ADR      r0,|L6.300|
00001e  f7fffffe          BL       rt_kprintf
000022  4622              MOV      r2,r4
000024  4940              LDR      r1,|L6.296|
000026  a04f              ADR      r0,|L6.356|
000028  f7fffffe          BL       rt_assert_handler
                  |L6.44|
00002c  f7fffffe          BL       rt_hw_interrupt_disable
000030  9000              STR      r0,[sp,#0]
000032  f7fffffe          BL       rt_interrupt_get_nest
000036  2800              CMP      r0,#0
000038  d008              BEQ      |L6.76|
00003a  493b              LDR      r1,|L6.296|
00003c  a04a              ADR      r0,|L6.360|
00003e  f7fffffe          BL       rt_kprintf
000042  4622              MOV      r2,r4
000044  4938              LDR      r1,|L6.296|
000046  a047              ADR      r0,|L6.356|
000048  f7fffffe          BL       rt_assert_handler
                  |L6.76|
00004c  9800              LDR      r0,[sp,#0]
00004e  f7fffffe          BL       rt_hw_interrupt_enable
000052  9801              LDR      r0,[sp,#4]
000054  f7fffffe          BL       rt_hw_interrupt_enable
;;;1104   
;;;1105       /* parameter check */
;;;1106       RT_ASSERT(event != RT_NULL);
000058  2d00              CMP      r5,#0
00005a  d105              BNE      |L6.104|
00005c  4a31              LDR      r2,|L6.292|
00005e  4932              LDR      r1,|L6.296|
000060  1cd2              ADDS     r2,r2,#3
000062  a04a              ADR      r0,|L6.396|
000064  f7fffffe          BL       rt_assert_handler
                  |L6.104|
;;;1107       if (set == 0)
;;;1108           return -RT_ERROR;
000068  2000              MOVS     r0,#0
00006a  43c0              MVNS     r0,r0
00006c  2e00              CMP      r6,#0                 ;1107
00006e  d053              BEQ      |L6.280|
;;;1109   
;;;1110       /* init status */
;;;1111       status = -RT_ERROR;
;;;1112       /* get current thread */
;;;1113       thread = rt_thread_self();
000070  f7fffffe          BL       rt_thread_self
000074  4604              MOV      r4,r0
;;;1114       /* reset thread error */
;;;1115       thread->error = RT_EOK;
000076  2000              MOVS     r0,#0
;;;1116   
;;;1117       RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(event->parent.parent)));
;;;1118   
;;;1119       /* disable interrupt */
;;;1120       level = rt_hw_interrupt_disable();
000078  6320              STR      r0,[r4,#0x30]
00007a  f7fffffe          BL       rt_hw_interrupt_disable
;;;1121   
;;;1122       /* check event set */
;;;1123       if (option & RT_EVENT_FLAG_AND)
00007e  9000              STR      r0,[sp,#0]
000080  07f8              LSLS     r0,r7,#31
000082  d004              BEQ      |L6.142|
;;;1124       {
;;;1125           if ((event->set & set) == set)
000084  69e9              LDR      r1,[r5,#0x1c]
000086  4630              MOV      r0,r6
000088  4388              BICS     r0,r0,r1
00008a  d005              BEQ      |L6.152|
00008c  e017              B        |L6.190|
                  |L6.142|
;;;1126               status = RT_EOK;
;;;1127       }
;;;1128       else if (option & RT_EVENT_FLAG_OR)
00008e  07b8              LSLS     r0,r7,#30
000090  d50f              BPL      |L6.178|
;;;1129       {
;;;1130           if (event->set & set)
000092  69e8              LDR      r0,[r5,#0x1c]
000094  4230              TST      r0,r6
000096  d012              BEQ      |L6.190|
                  |L6.152|
;;;1131               status = RT_EOK;
;;;1132       }
;;;1133       else
;;;1134       {
;;;1135           /* either RT_EVENT_FLAG_AND or RT_EVENT_FLAG_OR should be set */
;;;1136           RT_ASSERT(0);
;;;1137       }
;;;1138   
;;;1139       if (status == RT_EOK)
;;;1140       {
;;;1141           /* set received event */
;;;1142           if (recved)
000098  980c              LDR      r0,[sp,#0x30]
00009a  2800              CMP      r0,#0
00009c  d003              BEQ      |L6.166|
;;;1143               *recved = (event->set & set);
00009e  69e8              LDR      r0,[r5,#0x1c]
0000a0  990c              LDR      r1,[sp,#0x30]
0000a2  4030              ANDS     r0,r0,r6
0000a4  6008              STR      r0,[r1,#0]
                  |L6.166|
;;;1144   
;;;1145           /* received event */
;;;1146           if (option & RT_EVENT_FLAG_CLEAR)
0000a6  0778              LSLS     r0,r7,#29
0000a8  d532              BPL      |L6.272|
;;;1147               event->set &= ~set;
0000aa  69e8              LDR      r0,[r5,#0x1c]
0000ac  43b0              BICS     r0,r0,r6
0000ae  61e8              STR      r0,[r5,#0x1c]
0000b0  e02e              B        |L6.272|
                  |L6.178|
0000b2  2247              MOVS     r2,#0x47              ;1136
0000b4  0112              LSLS     r2,r2,#4              ;1136
0000b6  491c              LDR      r1,|L6.296|
0000b8  a02a              ADR      r0,|L6.356|
0000ba  f7fffffe          BL       rt_assert_handler
                  |L6.190|
;;;1148       }
;;;1149       else if (timeout == 0)
0000be  9806              LDR      r0,[sp,#0x18]
0000c0  2800              CMP      r0,#0
0000c2  d02b              BEQ      |L6.284|
;;;1150       {
;;;1151           /* no waiting */
;;;1152           thread->error = -RT_ETIMEOUT;
;;;1153       }
;;;1154       else
;;;1155       {
;;;1156           /* fill thread event info */
;;;1157           thread->event_set  = set;
;;;1158           thread->event_info = option;
0000c4  2040              MOVS     r0,#0x40
0000c6  63e6              STR      r6,[r4,#0x3c]
0000c8  5507              STRB     r7,[r0,r4]
;;;1159   
;;;1160           /* put thread to suspended thread list */
;;;1161           rt_ipc_list_suspend(&(event->parent.suspend_thread),
0000ca  4628              MOV      r0,r5
0000cc  7a6a              LDRB     r2,[r5,#9]
0000ce  4621              MOV      r1,r4
0000d0  3014              ADDS     r0,r0,#0x14
0000d2  f7fffffe          BL       rt_ipc_list_suspend
;;;1162                               thread,
;;;1163                               event->parent.parent.flag);
;;;1164   
;;;1165           /* if there is a waiting timeout, active thread timer */
;;;1166           if (timeout > 0)
0000d6  9806              LDR      r0,[sp,#0x18]
0000d8  2800              CMP      r0,#0
0000da  dd09              BLE      |L6.240|
;;;1167           {
;;;1168               /* reset the timeout of thread timer and start it */
;;;1169               rt_timer_control(&(thread->thread_timer),
0000dc  4620              MOV      r0,r4
0000de  304c              ADDS     r0,r0,#0x4c
0000e0  aa06              ADD      r2,sp,#0x18
0000e2  2100              MOVS     r1,#0
0000e4  4605              MOV      r5,r0
0000e6  f7fffffe          BL       rt_timer_control
0000ea  4628              MOV      r0,r5
;;;1170                                RT_TIMER_CTRL_SET_TIME,
;;;1171                                &timeout);
;;;1172               rt_timer_start(&(thread->thread_timer));
0000ec  f7fffffe          BL       rt_timer_start
                  |L6.240|
;;;1173           }
;;;1174   
;;;1175           /* enable interrupt */
;;;1176           rt_hw_interrupt_enable(level);
0000f0  9800              LDR      r0,[sp,#0]
0000f2  f7fffffe          BL       rt_hw_interrupt_enable
;;;1177   
;;;1178           /* do a schedule */
;;;1179           rt_schedule();
0000f6  f7fffffe          BL       rt_schedule
;;;1180   
;;;1181           if (thread->error != RT_EOK)
0000fa  6b20              LDR      r0,[r4,#0x30]
0000fc  2800              CMP      r0,#0
0000fe  d10b              BNE      |L6.280|
;;;1182           {
;;;1183               /* return error */
;;;1184               return thread->error;
;;;1185           }
;;;1186   
;;;1187           /* received an event, disable interrupt to protect */
;;;1188           level = rt_hw_interrupt_disable();
000100  f7fffffe          BL       rt_hw_interrupt_disable
;;;1189   
;;;1190           /* set received event */
;;;1191           if (recved)
000104  9000              STR      r0,[sp,#0]
000106  980c              LDR      r0,[sp,#0x30]
000108  2800              CMP      r0,#0
00010a  d001              BEQ      |L6.272|
;;;1192               *recved = thread->event_set;
00010c  6be1              LDR      r1,[r4,#0x3c]
00010e  6001              STR      r1,[r0,#0]
                  |L6.272|
;;;1193       }
;;;1194   
;;;1195       /* enable interrupt */
;;;1196       rt_hw_interrupt_enable(level);
000110  9800              LDR      r0,[sp,#0]
000112  f7fffffe          BL       rt_hw_interrupt_enable
;;;1197   
;;;1198       RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(event->parent.parent)));
;;;1199   
;;;1200       return thread->error;
000116  6b20              LDR      r0,[r4,#0x30]
                  |L6.280|
;;;1201   }
000118  b007              ADD      sp,sp,#0x1c
00011a  bdf0              POP      {r4-r7,pc}
                  |L6.284|
00011c  2001              MOVS     r0,#1                 ;1152
00011e  43c0              MVNS     r0,r0                 ;1152
000120  6320              STR      r0,[r4,#0x30]         ;1152
000122  e7f5              B        |L6.272|
;;;1202   RTM_EXPORT(rt_event_recv);
                          ENDP

                  |L6.292|
                          DCD      0x0000044f
                  |L6.296|
                          DCD      ||.constdata||+0xfa
                  |L6.300|
00012c  46756e63          DCB      "Function[%s] shall not be used before scheduler start\n"
000130  74696f6e
000134  5b25735d
000138  20736861
00013c  6c6c206e
000140  6f742062
000144  65207573
000148  65642062
00014c  65666f72
000150  65207363
000154  68656475
000158  6c657220
00015c  73746172
000160  740a    
000162  00                DCB      0
000163  00                DCB      0
                  |L6.356|
000164  3000              DCB      "0",0
000166  00                DCB      0
000167  00                DCB      0
                  |L6.360|
000168  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
00016c  74696f6e
000170  5b25735d
000174  20736861
000178  6c6c206e
00017c  6f742075
000180  73656420
000184  696e2049
000188  53520a00
                  |L6.396|
00018c  6576656e          DCB      "event != RT_NULL",0
000190  7420213d
000194  2052545f
000198  4e554c4c
00019c  00      
00019d  00                DCB      0
00019e  00                DCB      0
00019f  00                DCB      0

                          AREA ||i.rt_event_send||, CODE, READONLY, ALIGN=2

                  rt_event_send PROC
;;;997     */
;;;998    rt_err_t rt_event_send(rt_event_t event, rt_uint32_t set)
000000  b5fe              PUSH     {r1-r7,lr}
;;;999    {
000002  460d              MOV      r5,r1
000004  0004              MOVS     r4,r0
000006  d104              BNE      |L7.18|
;;;1000       struct rt_list_node *n;
;;;1001       struct rt_thread *thread;
;;;1002       register rt_ubase_t level;
;;;1003       register rt_base_t status;
;;;1004       rt_bool_t need_schedule;
;;;1005   
;;;1006       /* parameter check */
;;;1007       RT_ASSERT(event != RT_NULL);
000008  4a25              LDR      r2,|L7.160|
00000a  4926              LDR      r1,|L7.164|
00000c  a026              ADR      r0,|L7.168|
00000e  f7fffffe          BL       rt_assert_handler
                  |L7.18|
;;;1008       if (set == 0)
000012  2d00              CMP      r5,#0
000014  d00e              BEQ      |L7.52|
;;;1009           return -RT_ERROR;
;;;1010   
;;;1011       need_schedule = RT_FALSE;
000016  2600              MOVS     r6,#0
;;;1012       RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(event->parent.parent)));
;;;1013   
;;;1014       /* disable interrupt */
;;;1015       level = rt_hw_interrupt_disable();
000018  f7fffffe          BL       rt_hw_interrupt_disable
;;;1016   
;;;1017       /* set event */
;;;1018       event->set |= set;
00001c  9001              STR      r0,[sp,#4]
00001e  69e0              LDR      r0,[r4,#0x1c]
000020  4328              ORRS     r0,r0,r5
;;;1019   
;;;1020       if (!rt_list_isempty(&event->parent.suspend_thread))
000022  61e0              STR      r0,[r4,#0x1c]
000024  4620              MOV      r0,r4
000026  3014              ADDS     r0,r0,#0x14
000028  9000              STR      r0,[sp,#0]
00002a  f7fffffe          BL       rt_list_isempty
00002e  2800              CMP      r0,#0
000030  d003              BEQ      |L7.58|
000032  e02c              B        |L7.142|
                  |L7.52|
000034  2000              MOVS     r0,#0                 ;1009
000036  43c0              MVNS     r0,r0                 ;1009
;;;1021       {
;;;1022           /* search thread list to resume thread */
;;;1023           n = event->parent.suspend_thread.next;
;;;1024           while (n != &(event->parent.suspend_thread))
;;;1025           {
;;;1026               /* get thread */
;;;1027               thread = rt_list_entry(n, struct rt_thread, tlist);
;;;1028   
;;;1029               status = -RT_ERROR;
;;;1030               if (thread->event_info & RT_EVENT_FLAG_AND)
;;;1031               {
;;;1032                   if ((thread->event_set & event->set) == thread->event_set)
;;;1033                   {
;;;1034                       /* received an AND event */
;;;1035                       status = RT_EOK;
;;;1036                   }
;;;1037               }
;;;1038               else if (thread->event_info & RT_EVENT_FLAG_OR)
;;;1039               {
;;;1040                   if (thread->event_set & event->set)
;;;1041                   {
;;;1042                       /* save recieved event set */
;;;1043                       thread->event_set = thread->event_set & event->set;
;;;1044   
;;;1045                       /* received an OR event */
;;;1046                       status = RT_EOK;
;;;1047                   }
;;;1048               }
;;;1049   
;;;1050               /* move node to the next */
;;;1051               n = n->next;
;;;1052   
;;;1053               /* condition is satisfied, resume thread */
;;;1054               if (status == RT_EOK)
;;;1055               {
;;;1056                   /* clear event */
;;;1057                   if (thread->event_info & RT_EVENT_FLAG_CLEAR)
;;;1058                       event->set &= ~thread->event_set;
;;;1059   
;;;1060                   /* resume thread, and thread list breaks out */
;;;1061                   rt_thread_resume(thread);
;;;1062   
;;;1063                   /* need do a scheduling */
;;;1064                   need_schedule = RT_TRUE;
;;;1065               }
;;;1066           }
;;;1067       }
;;;1068   
;;;1069       /* enable interrupt */
;;;1070       rt_hw_interrupt_enable(level);
;;;1071   
;;;1072       /* do a schedule */
;;;1073       if (need_schedule == RT_TRUE)
;;;1074           rt_schedule();
;;;1075   
;;;1076       return RT_EOK;
;;;1077   }
000038  bdfe              POP      {r1-r7,pc}
                  |L7.58|
00003a  6965              LDR      r5,[r4,#0x14]         ;1024
00003c  e024              B        |L7.136|
                  |L7.62|
00003e  4628              MOV      r0,r5                 ;1027
000040  3814              SUBS     r0,r0,#0x14           ;1027
000042  462a              MOV      r2,r5                 ;1030
000044  322c              ADDS     r2,r2,#0x2c           ;1030
000046  4613              MOV      r3,r2                 ;1030
000048  2100              MOVS     r1,#0                 ;1029
00004a  7812              LDRB     r2,[r2,#0]            ;1030
00004c  43c9              MVNS     r1,r1                 ;1029
00004e  07d7              LSLS     r7,r2,#31             ;1030
000050  d005              BEQ      |L7.94|
000052  6bc2              LDR      r2,[r0,#0x3c]         ;1032
000054  69e7              LDR      r7,[r4,#0x1c]         ;1032
000056  43ba              BICS     r2,r2,r7              ;1032
000058  d109              BNE      |L7.110|
                  |L7.90|
00005a  2100              MOVS     r1,#0                 ;1035
00005c  e007              B        |L7.110|
                  |L7.94|
00005e  0792              LSLS     r2,r2,#30             ;1038
000060  d505              BPL      |L7.110|
000062  6bc2              LDR      r2,[r0,#0x3c]         ;1040
000064  69e7              LDR      r7,[r4,#0x1c]         ;1040
000066  403a              ANDS     r2,r2,r7              ;1040
000068  d001              BEQ      |L7.110|
00006a  63c2              STR      r2,[r0,#0x3c]         ;1046
00006c  e7f5              B        |L7.90|
                  |L7.110|
00006e  682d              LDR      r5,[r5,#0]            ;1051
000070  2900              CMP      r1,#0                 ;1054
000072  d109              BNE      |L7.136|
000074  7819              LDRB     r1,[r3,#0]            ;1057
000076  0749              LSLS     r1,r1,#29             ;1057
000078  d503              BPL      |L7.130|
00007a  69e1              LDR      r1,[r4,#0x1c]         ;1058
00007c  6bc2              LDR      r2,[r0,#0x3c]         ;1058
00007e  4391              BICS     r1,r1,r2              ;1058
000080  61e1              STR      r1,[r4,#0x1c]         ;1058
                  |L7.130|
000082  f7fffffe          BL       rt_thread_resume
000086  2601              MOVS     r6,#1                 ;1064
                  |L7.136|
000088  9800              LDR      r0,[sp,#0]            ;1024
00008a  4285              CMP      r5,r0                 ;1024
00008c  d1d7              BNE      |L7.62|
                  |L7.142|
00008e  9801              LDR      r0,[sp,#4]            ;1070
000090  f7fffffe          BL       rt_hw_interrupt_enable
000094  2e00              CMP      r6,#0                 ;1073
000096  d001              BEQ      |L7.156|
000098  f7fffffe          BL       rt_schedule
                  |L7.156|
00009c  2000              MOVS     r0,#0                 ;1076
00009e  bdfe              POP      {r1-r7,pc}
;;;1078   RTM_EXPORT(rt_event_send);
                          ENDP

                  |L7.160|
                          DCD      0x000003ef
                  |L7.164|
                          DCD      ||.constdata||+0xec
                  |L7.168|
0000a8  6576656e          DCB      "event != RT_NULL",0
0000ac  7420213d
0000b0  2052545f
0000b4  4e554c4c
0000b8  00      
0000b9  00                DCB      0
0000ba  00                DCB      0
0000bb  00                DCB      0

                          AREA ||i.rt_ipc_list_resume||, CODE, READONLY, ALIGN=1

                  rt_ipc_list_resume PROC
;;;145     */
;;;146    rt_inline rt_err_t rt_ipc_list_resume(rt_list_t *list)
000000  b510              PUSH     {r4,lr}
;;;147    {
;;;148        struct rt_thread *thread;
;;;149    
;;;150        /* get thread entry */
;;;151        thread = rt_list_entry(list->next, struct rt_thread, tlist);
000002  6800              LDR      r0,[r0,#0]
000004  3814              SUBS     r0,r0,#0x14
;;;152    
;;;153        RT_DEBUG_LOG(RT_DEBUG_IPC, ("resume thread:%s\n", thread->name));
;;;154    
;;;155        /* resume it */
;;;156        rt_thread_resume(thread);
000006  f7fffffe          BL       rt_thread_resume
;;;157    
;;;158        return RT_EOK;
00000a  2000              MOVS     r0,#0
;;;159    }
00000c  bd10              POP      {r4,pc}
;;;160    
                          ENDP


                          AREA ||i.rt_ipc_list_resume_all||, CODE, READONLY, ALIGN=1

                  rt_ipc_list_resume_all PROC
;;;168     */
;;;169    rt_inline rt_err_t rt_ipc_list_resume_all(rt_list_t *list)
000000  b570              PUSH     {r4-r6,lr}
;;;170    {
;;;171        struct rt_thread *thread;
;;;172        register rt_ubase_t temp;
;;;173    
;;;174        /* wakeup all suspend threads */
;;;175        while (!rt_list_isempty(list))
;;;176        {
;;;177            /* disable interrupt */
;;;178            temp = rt_hw_interrupt_disable();
;;;179    
;;;180            /* get next suspend thread */
;;;181            thread = rt_list_entry(list->next, struct rt_thread, tlist);
;;;182            /* set error code to RT_ERROR */
;;;183            thread->error = -RT_ERROR;
000002  2600              MOVS     r6,#0
000004  4605              MOV      r5,r0                 ;170
000006  43f6              MVNS     r6,r6
000008  e00a              B        |L9.32|
                  |L9.10|
00000a  f7fffffe          BL       rt_hw_interrupt_disable
00000e  4604              MOV      r4,r0                 ;178
000010  6828              LDR      r0,[r5,#0]
000012  61c6              STR      r6,[r0,#0x1c]
000014  3814              SUBS     r0,r0,#0x14
;;;184    
;;;185            /*
;;;186             * resume thread
;;;187             * In rt_thread_resume function, it will remove current thread from
;;;188             * suspend list
;;;189             */
;;;190            rt_thread_resume(thread);
000016  f7fffffe          BL       rt_thread_resume
;;;191    
;;;192            /* enable interrupt */
;;;193            rt_hw_interrupt_enable(temp);
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       rt_hw_interrupt_enable
                  |L9.32|
000020  4628              MOV      r0,r5                 ;175
000022  f7fffffe          BL       rt_list_isempty
000026  2800              CMP      r0,#0                 ;175
000028  d0ef              BEQ      |L9.10|
;;;194        }
;;;195    
;;;196        return RT_EOK;
00002a  2000              MOVS     r0,#0
;;;197    }
00002c  bd70              POP      {r4-r6,pc}
;;;198    
                          ENDP


                          AREA ||i.rt_ipc_list_suspend||, CODE, READONLY, ALIGN=1

                  rt_ipc_list_suspend PROC
;;;91      */
;;;92     rt_inline rt_err_t rt_ipc_list_suspend(rt_list_t        *list,
000000  b5f8              PUSH     {r3-r7,lr}
;;;93                                            struct rt_thread *thread,
;;;94                                            rt_uint8_t        flag)
;;;95     {
000002  4605              MOV      r5,r0
000004  4614              MOV      r4,r2
000006  460e              MOV      r6,r1
;;;96         /* suspend thread */
;;;97         rt_thread_suspend(thread);
000008  4608              MOV      r0,r1
00000a  f7fffffe          BL       rt_thread_suspend
;;;98     
;;;99         switch (flag)
;;;100        {
;;;101        case RT_IPC_FLAG_FIFO:
;;;102            rt_list_insert_before(list, &(thread->tlist));
00000e  4637              MOV      r7,r6
000010  3714              ADDS     r7,r7,#0x14
000012  2c00              CMP      r4,#0                 ;99
000014  d015              BEQ      |L10.66|
000016  2c01              CMP      r4,#1                 ;99
000018  d117              BNE      |L10.74|
;;;103            break;
;;;104    
;;;105        case RT_IPC_FLAG_PRIO:
;;;106            {
;;;107                struct rt_list_node *n;
;;;108                struct rt_thread *sthread;
;;;109    
;;;110                /* find a suitable position */
;;;111                for (n = list->next; n != list; n = n->next)
00001a  3620              ADDS     r6,r6,#0x20
00001c  682c              LDR      r4,[r5,#0]
00001e  e00c              B        |L10.58|
                  |L10.32|
;;;112                {
;;;113                    sthread = rt_list_entry(n, struct rt_thread, tlist);
;;;114    
;;;115                    /* find out */
;;;116                    if (thread->current_priority < sthread->current_priority)
000020  2121              MOVS     r1,#0x21
000022  4620              MOV      r0,r4                 ;113
000024  7d72              LDRB     r2,[r6,#0x15]
000026  5d09              LDRB     r1,[r1,r4]
000028  3814              SUBS     r0,r0,#0x14           ;113
00002a  428a              CMP      r2,r1
00002c  d204              BCS      |L10.56|
00002e  4639              MOV      r1,r7
000030  3014              ADDS     r0,r0,#0x14
;;;117                    {
;;;118                        /* insert this thread before the sthread */
;;;119                        rt_list_insert_before(&(sthread->tlist), &(thread->tlist));
000032  f7fffffe          BL       rt_list_insert_before
;;;120                        break;
000036  e002              B        |L10.62|
                  |L10.56|
000038  6824              LDR      r4,[r4,#0]            ;111
                  |L10.58|
00003a  42ac              CMP      r4,r5                 ;111
00003c  d1f0              BNE      |L10.32|
                  |L10.62|
;;;121                    }
;;;122                }
;;;123    
;;;124                /*
;;;125                 * not found a suitable position,
;;;126                 * append to the end of suspend_thread list
;;;127                 */
;;;128                if (n == list)
00003e  42ac              CMP      r4,r5
000040  d103              BNE      |L10.74|
                  |L10.66|
000042  4639              MOV      r1,r7
;;;129                    rt_list_insert_before(list, &(thread->tlist));
000044  4628              MOV      r0,r5
000046  f7fffffe          BL       rt_list_insert_before
                  |L10.74|
;;;130            }
;;;131            break;
;;;132        }
;;;133    
;;;134        return RT_EOK;
00004a  2000              MOVS     r0,#0
;;;135    }
00004c  bdf8              POP      {r3-r7,pc}
;;;136    
                          ENDP


                          AREA ||i.rt_list_insert_before||, CODE, READONLY, ALIGN=1

                  rt_list_insert_before PROC
;;;76      */
;;;77     rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
000000  6842              LDR      r2,[r0,#4]
;;;78     {
;;;79         l->prev->next = n;
;;;80         n->prev = l->prev;
000002  6011              STR      r1,[r2,#0]
000004  6842              LDR      r2,[r0,#4]
;;;81     
;;;82         l->prev = n;
000006  604a              STR      r2,[r1,#4]
;;;83         n->next = l;
000008  6041              STR      r1,[r0,#4]
00000a  6008              STR      r0,[r1,#0]
;;;84     }
00000c  4770              BX       lr
;;;85     
                          ENDP


                          AREA ||i.rt_list_isempty||, CODE, READONLY, ALIGN=1

                  rt_list_isempty PROC
;;;102     */
;;;103    rt_inline int rt_list_isempty(const rt_list_t *l)
000000  6801              LDR      r1,[r0,#0]
;;;104    {
;;;105        return l->next == l;
000002  4281              CMP      r1,r0
000004  d101              BNE      |L12.10|
000006  2001              MOVS     r0,#1
;;;106    }
000008  4770              BX       lr
                  |L12.10|
00000a  2000              MOVS     r0,#0                 ;105
00000c  4770              BX       lr
;;;107    
                          ENDP


                          AREA ||i.rt_mb_control||, CODE, READONLY, ALIGN=2

                  rt_mb_control PROC
;;;1687    */
;;;1688   rt_err_t rt_mb_control(rt_mailbox_t mb, rt_uint8_t cmd, void *arg)
000000  b570              PUSH     {r4-r6,lr}
;;;1689   {
000002  460d              MOV      r5,r1
000004  0004              MOVS     r4,r0
000006  d104              BNE      |L13.18|
;;;1690       rt_ubase_t level;
;;;1691       RT_ASSERT(mb != RT_NULL);
000008  4a0f              LDR      r2,|L13.72|
00000a  4910              LDR      r1,|L13.76|
00000c  a010              ADR      r0,|L13.80|
00000e  f7fffffe          BL       rt_assert_handler
                  |L13.18|
;;;1692   
;;;1693       if (cmd == RT_IPC_CMD_RESET)
000012  2d01              CMP      r5,#1
000014  d002              BEQ      |L13.28|
;;;1694       {
;;;1695           /* disable interrupt */
;;;1696           level = rt_hw_interrupt_disable();
;;;1697   
;;;1698           /* resume all waiting thread */
;;;1699           rt_ipc_list_resume_all(&(mb->parent.suspend_thread));
;;;1700           /* also resume all mailbox private suspended thread */
;;;1701           rt_ipc_list_resume_all(&(mb->suspend_sender_thread));
;;;1702   
;;;1703           /* re-init mailbox */
;;;1704           mb->entry      = 0;
;;;1705           mb->in_offset  = 0;
;;;1706           mb->out_offset = 0;
;;;1707   
;;;1708           /* enable interrupt */
;;;1709           rt_hw_interrupt_enable(level);
;;;1710   
;;;1711           rt_schedule();
;;;1712   
;;;1713           return RT_EOK;
;;;1714       }
;;;1715   
;;;1716       return -RT_ERROR;
000016  2000              MOVS     r0,#0
000018  43c0              MVNS     r0,r0
;;;1717   }
00001a  bd70              POP      {r4-r6,pc}
                  |L13.28|
00001c  f7fffffe          BL       rt_hw_interrupt_disable
000020  4605              MOV      r5,r0                 ;1696
000022  4620              MOV      r0,r4                 ;1699
000024  3014              ADDS     r0,r0,#0x14           ;1699
000026  f7fffffe          BL       rt_ipc_list_resume_all
00002a  4620              MOV      r0,r4                 ;1701
00002c  3028              ADDS     r0,r0,#0x28           ;1701
00002e  f7fffffe          BL       rt_ipc_list_resume_all
000032  2000              MOVS     r0,#0                 ;1704
000034  8460              STRH     r0,[r4,#0x22]         ;1704
000036  84a0              STRH     r0,[r4,#0x24]         ;1705
000038  84e0              STRH     r0,[r4,#0x26]         ;1706
00003a  4628              MOV      r0,r5                 ;1709
00003c  f7fffffe          BL       rt_hw_interrupt_enable
000040  f7fffffe          BL       rt_schedule
000044  2000              MOVS     r0,#0                 ;1713
000046  bd70              POP      {r4-r6,pc}
;;;1718   RTM_EXPORT(rt_mb_control);
                          ENDP

                  |L13.72|
                          DCD      0x0000069b
                  |L13.76|
                          DCD      ||.constdata||+0x166
                  |L13.80|
000050  6d622021          DCB      "mb != RT_NULL",0
000054  3d205254
000058  5f4e554c
00005c  4c00    
00005e  00                DCB      0
00005f  00                DCB      0

                          AREA ||i.rt_mb_create||, CODE, READONLY, ALIGN=2

                  rt_mb_create PROC
;;;1319    */
;;;1320   rt_mailbox_t rt_mb_create(const char *name, rt_size_t size, rt_uint8_t flag)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1321   {
000002  4616              MOV      r6,r2
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
;;;1322       rt_mailbox_t mb;
;;;1323   
;;;1324       RT_DEBUG_NOT_IN_INTERRUPT;
000008  f7fffffe          BL       rt_hw_interrupt_disable
00000c  4607              MOV      r7,r0
00000e  f7fffffe          BL       rt_interrupt_get_nest
000012  2800              CMP      r0,#0
000014  d008              BEQ      |L14.40|
000016  4917              LDR      r1,|L14.116|
000018  a017              ADR      r0,|L14.120|
00001a  f7fffffe          BL       rt_kprintf
00001e  4a1f              LDR      r2,|L14.156|
000020  4914              LDR      r1,|L14.116|
000022  a01f              ADR      r0,|L14.160|
000024  f7fffffe          BL       rt_assert_handler
                  |L14.40|
000028  4638              MOV      r0,r7
00002a  f7fffffe          BL       rt_hw_interrupt_enable
;;;1325   
;;;1326       /* allocate object */
;;;1327       mb = (rt_mailbox_t)rt_object_allocate(RT_Object_Class_MailBox, name);
00002e  4621              MOV      r1,r4
000030  2004              MOVS     r0,#4
000032  f7fffffe          BL       rt_object_allocate
000036  0004              MOVS     r4,r0
;;;1328       if (mb == RT_NULL)
000038  d015              BEQ      |L14.102|
00003a  4620              MOV      r0,r4
;;;1329           return mb;
;;;1330   
;;;1331       /* set parent */
;;;1332       mb->parent.parent.flag = flag;
00003c  7266              STRB     r6,[r4,#9]
00003e  3014              ADDS     r0,r0,#0x14
000040  61a0              STR      r0,[r4,#0x18]
;;;1333   
;;;1334       /* init ipc object */
;;;1335       rt_ipc_object_init(&(mb->parent));
;;;1336   
;;;1337       /* init mailbox */
;;;1338       mb->size     = size;
000042  6160              STR      r0,[r4,#0x14]
000044  b2a8              UXTH     r0,r5
000046  8420              STRH     r0,[r4,#0x20]
;;;1339       mb->msg_pool = RT_KERNEL_MALLOC(mb->size * sizeof(rt_uint32_t));
000048  0080              LSLS     r0,r0,#2
00004a  f7fffffe          BL       rt_malloc
;;;1340       if (mb->msg_pool == RT_NULL)
00004e  61e0              STR      r0,[r4,#0x1c]
000050  2800              CMP      r0,#0
000052  d009              BEQ      |L14.104|
;;;1341       {
;;;1342           /* delete mailbox object */
;;;1343           rt_object_delete(&(mb->parent.parent));
;;;1344   
;;;1345           return RT_NULL;
;;;1346       }
;;;1347       mb->entry      = 0;
000054  2000              MOVS     r0,#0
000056  8460              STRH     r0,[r4,#0x22]
;;;1348       mb->in_offset  = 0;
000058  84a0              STRH     r0,[r4,#0x24]
;;;1349       mb->out_offset = 0;
00005a  84e0              STRH     r0,[r4,#0x26]
;;;1350   
;;;1351       /* init an additional list of sender suspend thread */
;;;1352       rt_list_init(&(mb->suspend_sender_thread));
00005c  4620              MOV      r0,r4
00005e  3028              ADDS     r0,r0,#0x28
000060  62e0              STR      r0,[r4,#0x2c]
;;;1353   
;;;1354       return mb;
000062  62a0              STR      r0,[r4,#0x28]
000064  4620              MOV      r0,r4
                  |L14.102|
;;;1355   }
000066  bdf8              POP      {r3-r7,pc}
                  |L14.104|
000068  4620              MOV      r0,r4                 ;1343
00006a  f7fffffe          BL       rt_object_delete
00006e  2000              MOVS     r0,#0                 ;1345
000070  bdf8              POP      {r3-r7,pc}
;;;1356   RTM_EXPORT(rt_mb_create);
                          ENDP

000072  0000              DCW      0x0000
                  |L14.116|
                          DCD      ||.constdata||+0x131
                  |L14.120|
000078  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
00007c  74696f6e
000080  5b25735d
000084  20736861
000088  6c6c206e
00008c  6f742075
000090  73656420
000094  696e2049
000098  53520a00
                  |L14.156|
                          DCD      0x0000052c
                  |L14.160|
0000a0  3000              DCB      "0",0
0000a2  00                DCB      0
0000a3  00                DCB      0

                          AREA ||i.rt_mb_delete||, CODE, READONLY, ALIGN=2

                  rt_mb_delete PROC
;;;1364    */
;;;1365   rt_err_t rt_mb_delete(rt_mailbox_t mb)
000000  b570              PUSH     {r4-r6,lr}
;;;1366   {
000002  4604              MOV      r4,r0
;;;1367       RT_DEBUG_NOT_IN_INTERRUPT;
000004  f7fffffe          BL       rt_hw_interrupt_disable
000008  4605              MOV      r5,r0
00000a  f7fffffe          BL       rt_interrupt_get_nest
00000e  2800              CMP      r0,#0
000010  d008              BEQ      |L15.36|
000012  4912              LDR      r1,|L15.92|
000014  a012              ADR      r0,|L15.96|
000016  f7fffffe          BL       rt_kprintf
00001a  4a1a              LDR      r2,|L15.132|
00001c  490f              LDR      r1,|L15.92|
00001e  a01a              ADR      r0,|L15.136|
000020  f7fffffe          BL       rt_assert_handler
                  |L15.36|
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       rt_hw_interrupt_enable
;;;1368   
;;;1369       /* parameter check */
;;;1370       RT_ASSERT(mb != RT_NULL);
00002a  2c00              CMP      r4,#0
00002c  d105              BNE      |L15.58|
00002e  4a15              LDR      r2,|L15.132|
000030  490a              LDR      r1,|L15.92|
000032  1cd2              ADDS     r2,r2,#3
000034  a015              ADR      r0,|L15.140|
000036  f7fffffe          BL       rt_assert_handler
                  |L15.58|
;;;1371   
;;;1372       /* resume all suspended thread */
;;;1373       rt_ipc_list_resume_all(&(mb->parent.suspend_thread));
00003a  4620              MOV      r0,r4
00003c  3014              ADDS     r0,r0,#0x14
00003e  f7fffffe          BL       rt_ipc_list_resume_all
;;;1374   
;;;1375       /* also resume all mailbox private suspended thread */
;;;1376       rt_ipc_list_resume_all(&(mb->suspend_sender_thread));
000042  4620              MOV      r0,r4
000044  3028              ADDS     r0,r0,#0x28
000046  f7fffffe          BL       rt_ipc_list_resume_all
;;;1377   
;;;1378   #if defined(RT_USING_MODULE) && defined(RT_USING_SLAB)
;;;1379       /* the mb object belongs to an application module */
;;;1380       if (mb->parent.parent.flag & RT_OBJECT_FLAG_MODULE)
;;;1381           rt_module_free(mb->parent.parent.module_id, mb->msg_pool);
;;;1382       else
;;;1383   #endif
;;;1384   
;;;1385       /* free mailbox pool */
;;;1386       RT_KERNEL_FREE(mb->msg_pool);
00004a  69e0              LDR      r0,[r4,#0x1c]
00004c  f7fffffe          BL       rt_free
;;;1387   
;;;1388       /* delete mailbox object */
;;;1389       rt_object_delete(&(mb->parent.parent));
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       rt_object_delete
;;;1390   
;;;1391       return RT_EOK;
000056  2000              MOVS     r0,#0
;;;1392   }
000058  bd70              POP      {r4-r6,pc}
;;;1393   RTM_EXPORT(rt_mb_delete);
                          ENDP

00005a  0000              DCW      0x0000
                  |L15.92|
                          DCD      ||.constdata||+0x13e
                  |L15.96|
000060  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
000064  74696f6e
000068  5b25735d
00006c  20736861
000070  6c6c206e
000074  6f742075
000078  73656420
00007c  696e2049
000080  53520a00
                  |L15.132|
                          DCD      0x00000557
                  |L15.136|
000088  3000              DCB      "0",0
00008a  00                DCB      0
00008b  00                DCB      0
                  |L15.140|
00008c  6d622021          DCB      "mb != RT_NULL",0
000090  3d205254
000094  5f4e554c
000098  4c00    
00009a  00                DCB      0
00009b  00                DCB      0

                          AREA ||i.rt_mb_detach||, CODE, READONLY, ALIGN=2

                  rt_mb_detach PROC
;;;1292    */
;;;1293   rt_err_t rt_mb_detach(rt_mailbox_t mb)
000000  b510              PUSH     {r4,lr}
;;;1294   {
000002  0004              MOVS     r4,r0
000004  d105              BNE      |L16.18|
;;;1295       /* parameter check */
;;;1296       RT_ASSERT(mb != RT_NULL);
000006  2251              MOVS     r2,#0x51
000008  0112              LSLS     r2,r2,#4
00000a  4908              LDR      r1,|L16.44|
00000c  a008              ADR      r0,|L16.48|
00000e  f7fffffe          BL       rt_assert_handler
                  |L16.18|
;;;1297   
;;;1298       /* resume all suspended thread */
;;;1299       rt_ipc_list_resume_all(&(mb->parent.suspend_thread));
000012  4620              MOV      r0,r4
000014  3014              ADDS     r0,r0,#0x14
000016  f7fffffe          BL       rt_ipc_list_resume_all
;;;1300       /* also resume all mailbox private suspended thread */
;;;1301       rt_ipc_list_resume_all(&(mb->suspend_sender_thread));
00001a  4620              MOV      r0,r4
00001c  3028              ADDS     r0,r0,#0x28
00001e  f7fffffe          BL       rt_ipc_list_resume_all
;;;1302   
;;;1303       /* detach mailbox object */
;;;1304       rt_object_detach(&(mb->parent.parent));
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       rt_object_detach
;;;1305   
;;;1306       return RT_EOK;
000028  2000              MOVS     r0,#0
;;;1307   }
00002a  bd10              POP      {r4,pc}
;;;1308   RTM_EXPORT(rt_mb_detach);
                          ENDP

                  |L16.44|
                          DCD      ||.constdata||+0x124
                  |L16.48|
000030  6d622021          DCB      "mb != RT_NULL",0
000034  3d205254
000038  5f4e554c
00003c  4c00    
00003e  00                DCB      0
00003f  00                DCB      0

                          AREA ||i.rt_mb_init||, CODE, READONLY, ALIGN=2

                  rt_mb_init PROC
;;;1254    */
;;;1255   rt_err_t rt_mb_init(rt_mailbox_t mb,
000000  b5ff              PUSH     {r0-r7,lr}
;;;1256                       const char  *name,
;;;1257                       void        *msgpool,
;;;1258                       rt_size_t    size,
;;;1259                       rt_uint8_t   flag)
;;;1260   {
000002  b081              SUB      sp,sp,#4
000004  9f0a              LDR      r7,[sp,#0x28]
000006  461d              MOV      r5,r3
000008  4616              MOV      r6,r2
00000a  0004              MOVS     r4,r0
00000c  d104              BNE      |L17.24|
;;;1261       RT_ASSERT(mb != RT_NULL);
00000e  4a0d              LDR      r2,|L17.68|
000010  490d              LDR      r1,|L17.72|
000012  a00e              ADR      r0,|L17.76|
000014  f7fffffe          BL       rt_assert_handler
                  |L17.24|
;;;1262   
;;;1263       /* init object */
;;;1264       rt_object_init(&(mb->parent.parent), RT_Object_Class_MailBox, name);
000018  2104              MOVS     r1,#4
00001a  4620              MOV      r0,r4
00001c  9a02              LDR      r2,[sp,#8]
00001e  f7fffffe          BL       rt_object_init
000022  4620              MOV      r0,r4
;;;1265   
;;;1266       /* set parent flag */
;;;1267       mb->parent.parent.flag = flag;
000024  7267              STRB     r7,[r4,#9]
000026  3014              ADDS     r0,r0,#0x14
000028  61a0              STR      r0,[r4,#0x18]
;;;1268   
;;;1269       /* init ipc object */
;;;1270       rt_ipc_object_init(&(mb->parent));
;;;1271   
;;;1272       /* init mailbox */
;;;1273       mb->msg_pool   = msgpool;
;;;1274       mb->size       = size;
00002a  61e6              STR      r6,[r4,#0x1c]
00002c  6160              STR      r0,[r4,#0x14]
00002e  8425              STRH     r5,[r4,#0x20]
;;;1275       mb->entry      = 0;
000030  2000              MOVS     r0,#0
000032  8460              STRH     r0,[r4,#0x22]
;;;1276       mb->in_offset  = 0;
000034  84a0              STRH     r0,[r4,#0x24]
;;;1277       mb->out_offset = 0;
000036  84e0              STRH     r0,[r4,#0x26]
000038  3428              ADDS     r4,r4,#0x28
00003a  6064              STR      r4,[r4,#4]
00003c  6024              STR      r4,[r4,#0]
;;;1278   
;;;1279       /* init an additional list of sender suspend thread */
;;;1280       rt_list_init(&(mb->suspend_sender_thread));
;;;1281   
;;;1282       return RT_EOK;
;;;1283   }
00003e  b005              ADD      sp,sp,#0x14
000040  bdf0              POP      {r4-r7,pc}
;;;1284   RTM_EXPORT(rt_mb_init);
                          ENDP

000042  0000              DCW      0x0000
                  |L17.68|
                          DCD      0x000004ed
                  |L17.72|
                          DCD      ||.constdata||+0x119
                  |L17.76|
00004c  6d622021          DCB      "mb != RT_NULL",0
000050  3d205254
000054  5f4e554c
000058  4c00    
00005a  00                DCB      0
00005b  00                DCB      0

                          AREA ||i.rt_mb_recv||, CODE, READONLY, ALIGN=2

                  rt_mb_recv PROC
;;;1552    */
;;;1553   rt_err_t rt_mb_recv(rt_mailbox_t mb, rt_uint32_t *value, rt_int32_t timeout)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;1554   {
000002  b084              SUB      sp,sp,#0x10
000004  0004              MOVS     r4,r0
000006  d105              BNE      |L18.20|
;;;1555       struct rt_thread *thread;
;;;1556       register rt_ubase_t temp;
;;;1557       rt_uint32_t tick_delta;
;;;1558   
;;;1559       /* parameter check */
;;;1560       RT_ASSERT(mb != RT_NULL);
000008  22c3              MOVS     r2,#0xc3
00000a  00d2              LSLS     r2,r2,#3
00000c  494e              LDR      r1,|L18.328|
00000e  a04f              ADR      r0,|L18.332|
000010  f7fffffe          BL       rt_assert_handler
                  |L18.20|
;;;1561   
;;;1562       /* initialize delta tick */
;;;1563       tick_delta = 0;
000014  2600              MOVS     r6,#0
;;;1564       /* get current thread */
;;;1565       thread = rt_thread_self();
000016  f7fffffe          BL       rt_thread_self
00001a  4605              MOV      r5,r0
;;;1566   
;;;1567       RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(mb->parent.parent)));
;;;1568   
;;;1569       /* disable interrupt */
;;;1570       temp = rt_hw_interrupt_disable();
00001c  f7fffffe          BL       rt_hw_interrupt_disable
;;;1571   
;;;1572       /* for non-blocking call */
;;;1573       if (mb->entry == 0 && timeout == 0)
000020  9000              STR      r0,[sp,#0]
000022  8c60              LDRH     r0,[r4,#0x22]
000024  9906              LDR      r1,[sp,#0x18]
000026  2700              MOVS     r7,#0
000028  4308              ORRS     r0,r0,r1
00002a  2800              CMP      r0,#0
00002c  d163              BNE      |L18.246|
;;;1574       {
;;;1575           rt_hw_interrupt_enable(temp);
00002e  9800              LDR      r0,[sp,#0]
000030  f7fffffe          BL       rt_hw_interrupt_enable
;;;1576   
;;;1577           return -RT_ETIMEOUT;
000034  1eb0              SUBS     r0,r6,#2
                  |L18.54|
;;;1578       }
;;;1579   
;;;1580       /* mailbox is empty */
;;;1581       while (mb->entry == 0)
;;;1582       {
;;;1583           /* reset error number in thread */
;;;1584           thread->error = RT_EOK;
;;;1585   
;;;1586           /* no waiting, return timeout */
;;;1587           if (timeout == 0)
;;;1588           {
;;;1589               /* enable interrupt */
;;;1590               rt_hw_interrupt_enable(temp);
;;;1591   
;;;1592               thread->error = -RT_ETIMEOUT;
;;;1593   
;;;1594               return -RT_ETIMEOUT;
;;;1595           }
;;;1596   
;;;1597           RT_DEBUG_IN_THREAD_CONTEXT;
;;;1598           /* suspend current thread */
;;;1599           rt_ipc_list_suspend(&(mb->parent.suspend_thread),
;;;1600                               thread,
;;;1601                               mb->parent.parent.flag);
;;;1602   
;;;1603           /* has waiting time, start thread timer */
;;;1604           if (timeout > 0)
;;;1605           {
;;;1606               /* get the start tick of timer */
;;;1607               tick_delta = rt_tick_get();
;;;1608   
;;;1609               RT_DEBUG_LOG(RT_DEBUG_IPC, ("mb_recv: start timer of thread:%s\n",
;;;1610                                           thread->name));
;;;1611   
;;;1612               /* reset the timeout of thread timer and start it */
;;;1613               rt_timer_control(&(thread->thread_timer),
;;;1614                                RT_TIMER_CTRL_SET_TIME,
;;;1615                                &timeout);
;;;1616               rt_timer_start(&(thread->thread_timer));
;;;1617           }
;;;1618   
;;;1619           /* enable interrupt */
;;;1620           rt_hw_interrupt_enable(temp);
;;;1621   
;;;1622           /* re-schedule */
;;;1623           rt_schedule();
;;;1624   
;;;1625           /* resume from suspend state */
;;;1626           if (thread->error != RT_EOK)
;;;1627           {
;;;1628               /* return error */
;;;1629               return thread->error;
;;;1630           }
;;;1631   
;;;1632           /* disable interrupt */
;;;1633           temp = rt_hw_interrupt_disable();
;;;1634   
;;;1635           /* if it's not waiting forever and then re-calculate timeout tick */
;;;1636           if (timeout > 0)
;;;1637           {
;;;1638               tick_delta = rt_tick_get() - tick_delta;
;;;1639               timeout -= tick_delta;
;;;1640               if (timeout < 0)
;;;1641                   timeout = 0;
;;;1642           }
;;;1643       }
;;;1644   
;;;1645       /* fill ptr */
;;;1646       *value = mb->msg_pool[mb->out_offset];
;;;1647   
;;;1648       /* increase output offset */
;;;1649       ++ mb->out_offset;
;;;1650       if (mb->out_offset >= mb->size)
;;;1651           mb->out_offset = 0;
;;;1652       /* decrease message entry */
;;;1653       mb->entry --;
;;;1654   
;;;1655       /* resume suspended thread */
;;;1656       if (!rt_list_isempty(&(mb->suspend_sender_thread)))
;;;1657       {
;;;1658           rt_ipc_list_resume(&(mb->suspend_sender_thread));
;;;1659   
;;;1660           /* enable interrupt */
;;;1661           rt_hw_interrupt_enable(temp);
;;;1662   
;;;1663           RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mb->parent.parent)));
;;;1664   
;;;1665           rt_schedule();
;;;1666   
;;;1667           return RT_EOK;
;;;1668       }
;;;1669   
;;;1670       /* enable interrupt */
;;;1671       rt_hw_interrupt_enable(temp);
;;;1672   
;;;1673       RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mb->parent.parent)));
;;;1674   
;;;1675       return RT_EOK;
;;;1676   }
000036  b007              ADD      sp,sp,#0x1c
000038  bdf0              POP      {r4-r7,pc}
                  |L18.58|
00003a  632f              STR      r7,[r5,#0x30]         ;1587
00003c  9806              LDR      r0,[sp,#0x18]         ;1587
00003e  2800              CMP      r0,#0                 ;1587
000040  d007              BEQ      |L18.82|
000042  f7fffffe          BL       rt_hw_interrupt_disable
000046  9002              STR      r0,[sp,#8]            ;1597
000048  f7fffffe          BL       rt_thread_self
00004c  2800              CMP      r0,#0                 ;1597
00004e  d007              BEQ      |L18.96|
000050  e00f              B        |L18.114|
                  |L18.82|
000052  9800              LDR      r0,[sp,#0]            ;1590
000054  f7fffffe          BL       rt_hw_interrupt_enable
000058  2001              MOVS     r0,#1                 ;1592
00005a  43c0              MVNS     r0,r0                 ;1592
00005c  6328              STR      r0,[r5,#0x30]         ;1594
00005e  e7ea              B        |L18.54|
                  |L18.96|
000060  4939              LDR      r1,|L18.328|
000062  a03e              ADR      r0,|L18.348|
000064  f7fffffe          BL       rt_kprintf
000068  4a4a              LDR      r2,|L18.404|
00006a  4937              LDR      r1,|L18.328|
00006c  a04a              ADR      r0,|L18.408|
00006e  f7fffffe          BL       rt_assert_handler
                  |L18.114|
000072  f7fffffe          BL       rt_hw_interrupt_disable
000076  9001              STR      r0,[sp,#4]            ;1597
000078  f7fffffe          BL       rt_interrupt_get_nest
00007c  2800              CMP      r0,#0                 ;1597
00007e  d008              BEQ      |L18.146|
000080  4931              LDR      r1,|L18.328|
000082  a046              ADR      r0,|L18.412|
000084  f7fffffe          BL       rt_kprintf
000088  4a42              LDR      r2,|L18.404|
00008a  492f              LDR      r1,|L18.328|
00008c  a042              ADR      r0,|L18.408|
00008e  f7fffffe          BL       rt_assert_handler
                  |L18.146|
000092  9801              LDR      r0,[sp,#4]            ;1597
000094  f7fffffe          BL       rt_hw_interrupt_enable
000098  9802              LDR      r0,[sp,#8]            ;1597
00009a  f7fffffe          BL       rt_hw_interrupt_enable
00009e  4620              MOV      r0,r4                 ;1599
0000a0  7a62              LDRB     r2,[r4,#9]            ;1599
0000a2  4629              MOV      r1,r5                 ;1599
0000a4  3014              ADDS     r0,r0,#0x14           ;1599
0000a6  f7fffffe          BL       rt_ipc_list_suspend
0000aa  9806              LDR      r0,[sp,#0x18]         ;1604
0000ac  2800              CMP      r0,#0                 ;1604
0000ae  dd0c              BLE      |L18.202|
0000b0  f7fffffe          BL       rt_tick_get
0000b4  4606              MOV      r6,r0                 ;1607
0000b6  4628              MOV      r0,r5                 ;1613
0000b8  304c              ADDS     r0,r0,#0x4c           ;1613
0000ba  aa06              ADD      r2,sp,#0x18           ;1613
0000bc  2100              MOVS     r1,#0                 ;1613
0000be  9001              STR      r0,[sp,#4]            ;1613
0000c0  f7fffffe          BL       rt_timer_control
0000c4  9801              LDR      r0,[sp,#4]            ;1616
0000c6  f7fffffe          BL       rt_timer_start
                  |L18.202|
0000ca  9800              LDR      r0,[sp,#0]            ;1620
0000cc  f7fffffe          BL       rt_hw_interrupt_enable
0000d0  f7fffffe          BL       rt_schedule
0000d4  6b28              LDR      r0,[r5,#0x30]         ;1626
0000d6  2800              CMP      r0,#0                 ;1626
0000d8  d1ad              BNE      |L18.54|
0000da  f7fffffe          BL       rt_hw_interrupt_disable
0000de  9000              STR      r0,[sp,#0]            ;1636
0000e0  9806              LDR      r0,[sp,#0x18]         ;1636
0000e2  2800              CMP      r0,#0                 ;1636
0000e4  dd07              BLE      |L18.246|
0000e6  f7fffffe          BL       rt_tick_get
0000ea  1b86              SUBS     r6,r0,r6              ;1638
0000ec  9806              LDR      r0,[sp,#0x18]         ;1639
0000ee  1b80              SUBS     r0,r0,r6              ;1639
0000f0  9006              STR      r0,[sp,#0x18]         ;1640
0000f2  d500              BPL      |L18.246|
0000f4  9706              STR      r7,[sp,#0x18]         ;1641
                  |L18.246|
0000f6  8c60              LDRH     r0,[r4,#0x22]         ;1581
0000f8  2800              CMP      r0,#0                 ;1581
0000fa  d09e              BEQ      |L18.58|
0000fc  8ce1              LDRH     r1,[r4,#0x26]         ;1646
0000fe  69e0              LDR      r0,[r4,#0x1c]         ;1646
000100  0089              LSLS     r1,r1,#2              ;1646
000102  5841              LDR      r1,[r0,r1]            ;1646
000104  9805              LDR      r0,[sp,#0x14]         ;1646
000106  6001              STR      r1,[r0,#0]            ;1649
000108  8ce0              LDRH     r0,[r4,#0x26]         ;1649
00010a  1c40              ADDS     r0,r0,#1              ;1649
00010c  b280              UXTH     r0,r0                 ;1649
00010e  84e0              STRH     r0,[r4,#0x26]         ;1649
000110  8c21              LDRH     r1,[r4,#0x20]         ;1650
000112  4288              CMP      r0,r1                 ;1650
000114  d300              BCC      |L18.280|
000116  84e7              STRH     r7,[r4,#0x26]         ;1651
                  |L18.280|
000118  8c60              LDRH     r0,[r4,#0x22]         ;1653
00011a  1e40              SUBS     r0,r0,#1              ;1653
00011c  8460              STRH     r0,[r4,#0x22]         ;1653
00011e  4620              MOV      r0,r4                 ;1656
000120  3028              ADDS     r0,r0,#0x28           ;1656
000122  4604              MOV      r4,r0                 ;1656
000124  f7fffffe          BL       rt_list_isempty
000128  2800              CMP      r0,#0                 ;1656
00012a  d004              BEQ      |L18.310|
00012c  9800              LDR      r0,[sp,#0]            ;1671
00012e  f7fffffe          BL       rt_hw_interrupt_enable
                  |L18.306|
000132  2000              MOVS     r0,#0                 ;1675
000134  e77f              B        |L18.54|
                  |L18.310|
000136  4620              MOV      r0,r4
000138  f7fffffe          BL       rt_ipc_list_resume
00013c  9800              LDR      r0,[sp,#0]            ;1661
00013e  f7fffffe          BL       rt_hw_interrupt_enable
000142  f7fffffe          BL       rt_schedule
000146  e7f4              B        |L18.306|
;;;1677   RTM_EXPORT(rt_mb_recv);
                          ENDP

                  |L18.328|
                          DCD      ||.constdata||+0x15b
                  |L18.332|
00014c  6d622021          DCB      "mb != RT_NULL",0
000150  3d205254
000154  5f4e554c
000158  4c00    
00015a  00                DCB      0
00015b  00                DCB      0
                  |L18.348|
00015c  46756e63          DCB      "Function[%s] shall not be used before scheduler start\n"
000160  74696f6e
000164  5b25735d
000168  20736861
00016c  6c6c206e
000170  6f742062
000174  65207573
000178  65642062
00017c  65666f72
000180  65207363
000184  68656475
000188  6c657220
00018c  73746172
000190  740a    
000192  00                DCB      0
000193  00                DCB      0
                  |L18.404|
                          DCD      0x0000063d
                  |L18.408|
000198  3000              DCB      "0",0
00019a  00                DCB      0
00019b  00                DCB      0
                  |L18.412|
00019c  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
0001a0  74696f6e
0001a4  5b25735d
0001a8  20736861
0001ac  6c6c206e
0001b0  6f742075
0001b4  73656420
0001b8  696e2049
0001bc  53520a00

                          AREA ||i.rt_mb_send||, CODE, READONLY, ALIGN=1

                  rt_mb_send PROC
;;;1536    */
;;;1537   rt_err_t rt_mb_send(rt_mailbox_t mb, rt_uint32_t value)
000000  b510              PUSH     {r4,lr}
;;;1538   {
;;;1539       return rt_mb_send_wait(mb, value, 0);
000002  2200              MOVS     r2,#0
000004  f7fffffe          BL       rt_mb_send_wait
;;;1540   }
000008  bd10              POP      {r4,pc}
;;;1541   RTM_EXPORT(rt_mb_send);
                          ENDP


                          AREA ||i.rt_mb_send_wait||, CODE, READONLY, ALIGN=2

                  rt_mb_send_wait PROC
;;;1405    */
;;;1406   rt_err_t rt_mb_send_wait(rt_mailbox_t mb,
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;1407                            rt_uint32_t  value,
;;;1408                            rt_int32_t   timeout)
;;;1409   {
000002  b084              SUB      sp,sp,#0x10
000004  0004              MOVS     r4,r0
000006  d104              BNE      |L20.18|
;;;1410       struct rt_thread *thread;
;;;1411       register rt_ubase_t temp;
;;;1412       rt_uint32_t tick_delta;
;;;1413   
;;;1414       /* parameter check */
;;;1415       RT_ASSERT(mb != RT_NULL);
000008  4a4e              LDR      r2,|L20.324|
00000a  494f              LDR      r1,|L20.328|
00000c  a04f              ADR      r0,|L20.332|
00000e  f7fffffe          BL       rt_assert_handler
                  |L20.18|
;;;1416   
;;;1417       /* initialize delta tick */
;;;1418       tick_delta = 0;
000012  2600              MOVS     r6,#0
;;;1419       /* get current thread */
;;;1420       thread = rt_thread_self();
000014  f7fffffe          BL       rt_thread_self
000018  4605              MOV      r5,r0
;;;1421   
;;;1422       RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mb->parent.parent)));
;;;1423   
;;;1424       /* disable interrupt */
;;;1425       temp = rt_hw_interrupt_disable();
00001a  f7fffffe          BL       rt_hw_interrupt_disable
;;;1426   
;;;1427       /* for non-blocking call */
;;;1428       if (mb->entry == mb->size && timeout == 0)
00001e  9000              STR      r0,[sp,#0]
000020  8c60              LDRH     r0,[r4,#0x22]
000022  8c21              LDRH     r1,[r4,#0x20]
000024  2700              MOVS     r7,#0
000026  4288              CMP      r0,r1
000028  d163              BNE      |L20.242|
00002a  9806              LDR      r0,[sp,#0x18]
00002c  2800              CMP      r0,#0
00002e  d00c              BEQ      |L20.74|
000030  e05f              B        |L20.242|
                  |L20.50|
;;;1429       {
;;;1430           rt_hw_interrupt_enable(temp);
;;;1431   
;;;1432           return -RT_EFULL;
;;;1433       }
;;;1434   
;;;1435       /* mailbox is full */
;;;1436       while (mb->entry == mb->size)
;;;1437       {
;;;1438           /* reset error number in thread */
;;;1439           thread->error = RT_EOK;
;;;1440   
;;;1441           /* no waiting, return timeout */
;;;1442           if (timeout == 0)
000032  632f              STR      r7,[r5,#0x30]
000034  9806              LDR      r0,[sp,#0x18]
000036  2800              CMP      r0,#0
000038  d007              BEQ      |L20.74|
;;;1443           {
;;;1444               /* enable interrupt */
;;;1445               rt_hw_interrupt_enable(temp);
;;;1446   
;;;1447               return -RT_EFULL;
;;;1448           }
;;;1449   
;;;1450           RT_DEBUG_IN_THREAD_CONTEXT;
00003a  f7fffffe          BL       rt_hw_interrupt_disable
00003e  9002              STR      r0,[sp,#8]
000040  f7fffffe          BL       rt_thread_self
000044  2800              CMP      r0,#0
000046  d007              BEQ      |L20.88|
000048  e010              B        |L20.108|
                  |L20.74|
00004a  9800              LDR      r0,[sp,#0]            ;1445
00004c  f7fffffe          BL       rt_hw_interrupt_enable
000050  2002              MOVS     r0,#2                 ;1447
000052  43c0              MVNS     r0,r0                 ;1447
                  |L20.84|
;;;1451           /* suspend current thread */
;;;1452           rt_ipc_list_suspend(&(mb->suspend_sender_thread),
;;;1453                               thread,
;;;1454                               mb->parent.parent.flag);
;;;1455   
;;;1456           /* has waiting time, start thread timer */
;;;1457           if (timeout > 0)
;;;1458           {
;;;1459               /* get the start tick of timer */
;;;1460               tick_delta = rt_tick_get();
;;;1461   
;;;1462               RT_DEBUG_LOG(RT_DEBUG_IPC, ("mb_send_wait: start timer of thread:%s\n",
;;;1463                                           thread->name));
;;;1464   
;;;1465               /* reset the timeout of thread timer and start it */
;;;1466               rt_timer_control(&(thread->thread_timer),
;;;1467                                RT_TIMER_CTRL_SET_TIME,
;;;1468                                &timeout);
;;;1469               rt_timer_start(&(thread->thread_timer));
;;;1470           }
;;;1471   
;;;1472           /* enable interrupt */
;;;1473           rt_hw_interrupt_enable(temp);
;;;1474   
;;;1475           /* re-schedule */
;;;1476           rt_schedule();
;;;1477   
;;;1478           /* resume from suspend state */
;;;1479           if (thread->error != RT_EOK)
;;;1480           {
;;;1481               /* return error */
;;;1482               return thread->error;
;;;1483           }
;;;1484   
;;;1485           /* disable interrupt */
;;;1486           temp = rt_hw_interrupt_disable();
;;;1487   
;;;1488           /* if it's not waiting forever and then re-calculate timeout tick */
;;;1489           if (timeout > 0)
;;;1490           {
;;;1491               tick_delta = rt_tick_get() - tick_delta;
;;;1492               timeout -= tick_delta;
;;;1493               if (timeout < 0)
;;;1494                   timeout = 0;
;;;1495           }
;;;1496       }
;;;1497   
;;;1498       /* set ptr */
;;;1499       mb->msg_pool[mb->in_offset] = value;
;;;1500       /* increase input offset */
;;;1501       ++ mb->in_offset;
;;;1502       if (mb->in_offset >= mb->size)
;;;1503           mb->in_offset = 0;
;;;1504       /* increase message entry */
;;;1505       mb->entry ++;
;;;1506   
;;;1507       /* resume suspended thread */
;;;1508       if (!rt_list_isempty(&mb->parent.suspend_thread))
;;;1509       {
;;;1510           rt_ipc_list_resume(&(mb->parent.suspend_thread));
;;;1511   
;;;1512           /* enable interrupt */
;;;1513           rt_hw_interrupt_enable(temp);
;;;1514   
;;;1515           rt_schedule();
;;;1516   
;;;1517           return RT_EOK;
;;;1518       }
;;;1519   
;;;1520       /* enable interrupt */
;;;1521       rt_hw_interrupt_enable(temp);
;;;1522   
;;;1523       return RT_EOK;
;;;1524   }
000054  b007              ADD      sp,sp,#0x1c
000056  bdf0              POP      {r4-r7,pc}
                  |L20.88|
000058  493b              LDR      r1,|L20.328|
00005a  a040              ADR      r0,|L20.348|
00005c  f7fffffe          BL       rt_kprintf
000060  4a38              LDR      r2,|L20.324|
000062  4939              LDR      r1,|L20.328|
000064  3223              ADDS     r2,r2,#0x23           ;1450
000066  a04b              ADR      r0,|L20.404|
000068  f7fffffe          BL       rt_assert_handler
                  |L20.108|
00006c  f7fffffe          BL       rt_hw_interrupt_disable
000070  9001              STR      r0,[sp,#4]            ;1450
000072  f7fffffe          BL       rt_interrupt_get_nest
000076  2800              CMP      r0,#0                 ;1450
000078  d009              BEQ      |L20.142|
00007a  4933              LDR      r1,|L20.328|
00007c  a046              ADR      r0,|L20.408|
00007e  f7fffffe          BL       rt_kprintf
000082  4a30              LDR      r2,|L20.324|
000084  4930              LDR      r1,|L20.328|
000086  3223              ADDS     r2,r2,#0x23           ;1450
000088  a042              ADR      r0,|L20.404|
00008a  f7fffffe          BL       rt_assert_handler
                  |L20.142|
00008e  9801              LDR      r0,[sp,#4]            ;1450
000090  f7fffffe          BL       rt_hw_interrupt_enable
000094  9802              LDR      r0,[sp,#8]            ;1450
000096  f7fffffe          BL       rt_hw_interrupt_enable
00009a  4620              MOV      r0,r4                 ;1452
00009c  7a62              LDRB     r2,[r4,#9]            ;1452
00009e  4629              MOV      r1,r5                 ;1452
0000a0  3028              ADDS     r0,r0,#0x28           ;1452
0000a2  f7fffffe          BL       rt_ipc_list_suspend
0000a6  9806              LDR      r0,[sp,#0x18]         ;1457
0000a8  2800              CMP      r0,#0                 ;1457
0000aa  dd0c              BLE      |L20.198|
0000ac  f7fffffe          BL       rt_tick_get
0000b0  4606              MOV      r6,r0                 ;1460
0000b2  4628              MOV      r0,r5                 ;1466
0000b4  304c              ADDS     r0,r0,#0x4c           ;1466
0000b6  aa06              ADD      r2,sp,#0x18           ;1466
0000b8  2100              MOVS     r1,#0                 ;1466
0000ba  9001              STR      r0,[sp,#4]            ;1466
0000bc  f7fffffe          BL       rt_timer_control
0000c0  9801              LDR      r0,[sp,#4]            ;1469
0000c2  f7fffffe          BL       rt_timer_start
                  |L20.198|
0000c6  9800              LDR      r0,[sp,#0]            ;1473
0000c8  f7fffffe          BL       rt_hw_interrupt_enable
0000cc  f7fffffe          BL       rt_schedule
0000d0  6b28              LDR      r0,[r5,#0x30]         ;1479
0000d2  2800              CMP      r0,#0                 ;1479
0000d4  d1be              BNE      |L20.84|
0000d6  f7fffffe          BL       rt_hw_interrupt_disable
0000da  9000              STR      r0,[sp,#0]            ;1489
0000dc  9806              LDR      r0,[sp,#0x18]         ;1489
0000de  2800              CMP      r0,#0                 ;1489
0000e0  dd07              BLE      |L20.242|
0000e2  f7fffffe          BL       rt_tick_get
0000e6  1b86              SUBS     r6,r0,r6              ;1491
0000e8  9806              LDR      r0,[sp,#0x18]         ;1492
0000ea  1b80              SUBS     r0,r0,r6              ;1492
0000ec  9006              STR      r0,[sp,#0x18]         ;1493
0000ee  d500              BPL      |L20.242|
0000f0  9706              STR      r7,[sp,#0x18]         ;1494
                  |L20.242|
0000f2  8c60              LDRH     r0,[r4,#0x22]         ;1436
0000f4  8c21              LDRH     r1,[r4,#0x20]         ;1436
0000f6  4288              CMP      r0,r1                 ;1436
0000f8  d09b              BEQ      |L20.50|
0000fa  8ca2              LDRH     r2,[r4,#0x24]         ;1499
0000fc  69e1              LDR      r1,[r4,#0x1c]         ;1499
0000fe  9805              LDR      r0,[sp,#0x14]         ;1499
000100  0092              LSLS     r2,r2,#2              ;1499
000102  5088              STR      r0,[r1,r2]            ;1499
000104  8ca0              LDRH     r0,[r4,#0x24]         ;1501
000106  1c40              ADDS     r0,r0,#1              ;1501
000108  b280              UXTH     r0,r0                 ;1501
00010a  84a0              STRH     r0,[r4,#0x24]         ;1501
00010c  8c21              LDRH     r1,[r4,#0x20]         ;1502
00010e  4288              CMP      r0,r1                 ;1502
000110  d300              BCC      |L20.276|
000112  84a7              STRH     r7,[r4,#0x24]         ;1503
                  |L20.276|
000114  8c60              LDRH     r0,[r4,#0x22]         ;1505
000116  1c40              ADDS     r0,r0,#1              ;1505
000118  8460              STRH     r0,[r4,#0x22]         ;1505
00011a  4620              MOV      r0,r4                 ;1508
00011c  3014              ADDS     r0,r0,#0x14           ;1508
00011e  4604              MOV      r4,r0                 ;1508
000120  f7fffffe          BL       rt_list_isempty
000124  2800              CMP      r0,#0                 ;1508
000126  d004              BEQ      |L20.306|
000128  9800              LDR      r0,[sp,#0]            ;1521
00012a  f7fffffe          BL       rt_hw_interrupt_enable
                  |L20.302|
00012e  2000              MOVS     r0,#0                 ;1523
000130  e790              B        |L20.84|
                  |L20.306|
000132  4620              MOV      r0,r4
000134  f7fffffe          BL       rt_ipc_list_resume
000138  9800              LDR      r0,[sp,#0]            ;1513
00013a  f7fffffe          BL       rt_hw_interrupt_enable
00013e  f7fffffe          BL       rt_schedule
000142  e7f4              B        |L20.302|
;;;1525   RTM_EXPORT(rt_mb_send_wait);
                          ENDP

                  |L20.324|
                          DCD      0x00000587
                  |L20.328|
                          DCD      ||.constdata||+0x14b
                  |L20.332|
00014c  6d622021          DCB      "mb != RT_NULL",0
000150  3d205254
000154  5f4e554c
000158  4c00    
00015a  00                DCB      0
00015b  00                DCB      0
                  |L20.348|
00015c  46756e63          DCB      "Function[%s] shall not be used before scheduler start\n"
000160  74696f6e
000164  5b25735d
000168  20736861
00016c  6c6c206e
000170  6f742062
000174  65207573
000178  65642062
00017c  65666f72
000180  65207363
000184  68656475
000188  6c657220
00018c  73746172
000190  740a    
000192  00                DCB      0
000193  00                DCB      0
                  |L20.404|
000194  3000              DCB      "0",0
000196  00                DCB      0
000197  00                DCB      0
                  |L20.408|
000198  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
00019c  74696f6e
0001a0  5b25735d
0001a4  20736861
0001a8  6c6c206e
0001ac  6f742075
0001b0  73656420
0001b4  696e2049
0001b8  53520a00

                          AREA ||i.rt_mq_control||, CODE, READONLY, ALIGN=2

                  rt_mq_control PROC
;;;2235    */
;;;2236   rt_err_t rt_mq_control(rt_mq_t mq, rt_uint8_t cmd, void *arg)
000000  b570              PUSH     {r4-r6,lr}
;;;2237   {
000002  460d              MOV      r5,r1
000004  0004              MOVS     r4,r0
000006  d104              BNE      |L21.18|
;;;2238       rt_ubase_t level;
;;;2239       struct rt_mq_message *msg;
;;;2240   
;;;2241       RT_ASSERT(mq != RT_NULL);
000008  4a13              LDR      r2,|L21.88|
00000a  4914              LDR      r1,|L21.92|
00000c  a014              ADR      r0,|L21.96|
00000e  f7fffffe          BL       rt_assert_handler
                  |L21.18|
;;;2242   
;;;2243       if (cmd == RT_IPC_CMD_RESET)
000012  2d01              CMP      r5,#1
000014  d002              BEQ      |L21.28|
;;;2244       {
;;;2245           /* disable interrupt */
;;;2246           level = rt_hw_interrupt_disable();
;;;2247   
;;;2248           /* resume all waiting thread */
;;;2249           rt_ipc_list_resume_all(&mq->parent.suspend_thread);
;;;2250   
;;;2251           /* release all message in the queue */
;;;2252           while (mq->msg_queue_head != RT_NULL)
;;;2253           {
;;;2254               /* get message from queue */
;;;2255               msg = (struct rt_mq_message *)mq->msg_queue_head;
;;;2256   
;;;2257               /* move message queue head */
;;;2258               mq->msg_queue_head = msg->next;
;;;2259               /* reach queue tail, set to NULL */
;;;2260               if (mq->msg_queue_tail == msg)
;;;2261                   mq->msg_queue_tail = RT_NULL;
;;;2262   
;;;2263               /* put message to free list */
;;;2264               msg->next = (struct rt_mq_message *)mq->msg_queue_free;
;;;2265               mq->msg_queue_free = msg;
;;;2266           }
;;;2267   
;;;2268           /* clean entry */
;;;2269           mq->entry = 0;
;;;2270   
;;;2271           /* enable interrupt */
;;;2272           rt_hw_interrupt_enable(level);
;;;2273   
;;;2274           rt_schedule();
;;;2275   
;;;2276           return RT_EOK;
;;;2277       }
;;;2278   
;;;2279       return -RT_ERROR;
000016  2000              MOVS     r0,#0
000018  43c0              MVNS     r0,r0
;;;2280   }
00001a  bd70              POP      {r4-r6,pc}
                  |L21.28|
00001c  f7fffffe          BL       rt_hw_interrupt_disable
000020  4605              MOV      r5,r0                 ;2246
000022  4620              MOV      r0,r4                 ;2249
000024  3014              ADDS     r0,r0,#0x14           ;2249
000026  f7fffffe          BL       rt_ipc_list_resume_all
00002a  2100              MOVS     r1,#0                 ;2249
00002c  e008              B        |L21.64|
                  |L21.46|
00002e  6802              LDR      r2,[r0,#0]            ;2258
000030  62a2              STR      r2,[r4,#0x28]         ;2260
000032  6ae2              LDR      r2,[r4,#0x2c]         ;2260
000034  4282              CMP      r2,r0                 ;2260
000036  d100              BNE      |L21.58|
000038  62e1              STR      r1,[r4,#0x2c]         ;2261
                  |L21.58|
00003a  6b22              LDR      r2,[r4,#0x30]         ;2264
00003c  6002              STR      r2,[r0,#0]            ;2265
00003e  6320              STR      r0,[r4,#0x30]         ;2265
                  |L21.64|
000040  6aa0              LDR      r0,[r4,#0x28]         ;2252
000042  2800              CMP      r0,#0                 ;2252
000044  d1f3              BNE      |L21.46|
000046  84a1              STRH     r1,[r4,#0x24]         ;2269
000048  4628              MOV      r0,r5                 ;2272
00004a  f7fffffe          BL       rt_hw_interrupt_enable
00004e  f7fffffe          BL       rt_schedule
000052  2000              MOVS     r0,#0                 ;2276
000054  bd70              POP      {r4-r6,pc}
;;;2281   RTM_EXPORT(rt_mq_control);
                          ENDP

000056  0000              DCW      0x0000
                  |L21.88|
                          DCD      0x000008c1
                  |L21.92|
                          DCD      ||.constdata||+0x1c9
                  |L21.96|
000060  6d712021          DCB      "mq != RT_NULL",0
000064  3d205254
000068  5f4e554c
00006c  4c00    
00006e  00                DCB      0
00006f  00                DCB      0

                          AREA ||i.rt_mq_create||, CODE, READONLY, ALIGN=2

                  rt_mq_create PROC
;;;1822    */
;;;1823   rt_mq_t rt_mq_create(const char *name,
000000  b5f8              PUSH     {r3-r7,lr}
;;;1824                        rt_size_t   msg_size,
;;;1825                        rt_size_t   max_msgs,
;;;1826                        rt_uint8_t  flag)
;;;1827   {
000002  461f              MOV      r7,r3
000004  4615              MOV      r5,r2
000006  460e              MOV      r6,r1
000008  4604              MOV      r4,r0
;;;1828       struct rt_messagequeue *mq;
;;;1829       struct rt_mq_message *head;
;;;1830       register rt_base_t temp;
;;;1831   
;;;1832       RT_DEBUG_NOT_IN_INTERRUPT;
00000a  f7fffffe          BL       rt_hw_interrupt_disable
00000e  9000              STR      r0,[sp,#0]
000010  f7fffffe          BL       rt_interrupt_get_nest
000014  2800              CMP      r0,#0
000016  d009              BEQ      |L22.44|
000018  491f              LDR      r1,|L22.152|
00001a  a020              ADR      r0,|L22.156|
00001c  f7fffffe          BL       rt_kprintf
000020  22e5              MOVS     r2,#0xe5
000022  00d2              LSLS     r2,r2,#3
000024  491c              LDR      r1,|L22.152|
000026  a026              ADR      r0,|L22.192|
000028  f7fffffe          BL       rt_assert_handler
                  |L22.44|
00002c  9800              LDR      r0,[sp,#0]
00002e  f7fffffe          BL       rt_hw_interrupt_enable
;;;1833   
;;;1834       /* allocate object */
;;;1835       mq = (rt_mq_t)rt_object_allocate(RT_Object_Class_MessageQueue, name);
000032  4621              MOV      r1,r4
000034  2005              MOVS     r0,#5
000036  f7fffffe          BL       rt_object_allocate
00003a  0004              MOVS     r4,r0
;;;1836       if (mq == RT_NULL)
00003c  d01b              BEQ      |L22.118|
00003e  4620              MOV      r0,r4
;;;1837           return mq;
;;;1838   
;;;1839       /* set parent */
;;;1840       mq->parent.parent.flag = flag;
000040  7267              STRB     r7,[r4,#9]
000042  3014              ADDS     r0,r0,#0x14
000044  61a0              STR      r0,[r4,#0x18]
;;;1841   
;;;1842       /* init ipc object */
;;;1843       rt_ipc_object_init(&(mq->parent));
;;;1844   
;;;1845       /* init message queue */
;;;1846   
;;;1847       /* get correct message size */
;;;1848       mq->msg_size = RT_ALIGN(msg_size, RT_ALIGN_SIZE);
000046  6160              STR      r0,[r4,#0x14]
000048  491e              LDR      r1,|L22.196|
00004a  1cf0              ADDS     r0,r6,#3
00004c  4008              ANDS     r0,r0,r1
00004e  8420              STRH     r0,[r4,#0x20]
;;;1849       mq->max_msgs = max_msgs;
000050  b2a9              UXTH     r1,r5
000052  1d00              ADDS     r0,r0,#4
000054  8461              STRH     r1,[r4,#0x22]
;;;1850   
;;;1851       /* allocate message pool */
;;;1852       mq->msg_pool = RT_KERNEL_MALLOC((mq->msg_size + sizeof(struct rt_mq_message))* mq->max_msgs);
000056  4348              MULS     r0,r1,r0
000058  f7fffffe          BL       rt_malloc
;;;1853       if (mq->msg_pool == RT_NULL)
00005c  61e0              STR      r0,[r4,#0x1c]
00005e  2800              CMP      r0,#0
000060  d005              BEQ      |L22.110|
;;;1854       {
;;;1855           rt_mq_delete(mq);
;;;1856   
;;;1857           return RT_NULL;
;;;1858       }
;;;1859   
;;;1860       /* init message list */
;;;1861       mq->msg_queue_head = RT_NULL;
000062  2200              MOVS     r2,#0
;;;1862       mq->msg_queue_tail = RT_NULL;
000064  62a2              STR      r2,[r4,#0x28]
;;;1863   
;;;1864       /* init message empty list */
;;;1865       mq->msg_queue_free = RT_NULL;
000066  62e2              STR      r2,[r4,#0x2c]
;;;1866       for (temp = 0; temp < mq->max_msgs; temp ++)
000068  4610              MOV      r0,r2
00006a  6322              STR      r2,[r4,#0x30]
00006c  e00d              B        |L22.138|
                  |L22.110|
00006e  4620              MOV      r0,r4                 ;1855
000070  f7fffffe          BL       rt_mq_delete
000074  2000              MOVS     r0,#0                 ;1857
                  |L22.118|
;;;1867       {
;;;1868           head = (struct rt_mq_message *)((rt_uint8_t *)mq->msg_pool +
;;;1869                  temp * (mq->msg_size + sizeof(struct rt_mq_message)));
;;;1870           head->next = mq->msg_queue_free;
;;;1871           mq->msg_queue_free = head;
;;;1872       }
;;;1873   
;;;1874       /* the initial entry is zero */
;;;1875       mq->entry = 0;
;;;1876   
;;;1877       return mq;
;;;1878   }
000076  bdf8              POP      {r3-r7,pc}
                  |L22.120|
000078  8c21              LDRH     r1,[r4,#0x20]         ;1868
00007a  69e3              LDR      r3,[r4,#0x1c]         ;1868
00007c  1d09              ADDS     r1,r1,#4              ;1868
00007e  4341              MULS     r1,r0,r1              ;1868
000080  1859              ADDS     r1,r3,r1              ;1868
000082  6b23              LDR      r3,[r4,#0x30]         ;1870
000084  600b              STR      r3,[r1,#0]            ;1871
000086  1c40              ADDS     r0,r0,#1              ;1871
000088  6321              STR      r1,[r4,#0x30]         ;1871
                  |L22.138|
00008a  8c61              LDRH     r1,[r4,#0x22]         ;1866
00008c  4281              CMP      r1,r0                 ;1866
00008e  dcf3              BGT      |L22.120|
000090  84a2              STRH     r2,[r4,#0x24]         ;1875
000092  4620              MOV      r0,r4                 ;1877
000094  bdf8              POP      {r3-r7,pc}
;;;1879   RTM_EXPORT(rt_mq_create);
                          ENDP

000096  0000              DCW      0x0000
                  |L22.152|
                          DCD      ||.constdata||+0x18c
                  |L22.156|
00009c  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
0000a0  74696f6e
0000a4  5b25735d
0000a8  20736861
0000ac  6c6c206e
0000b0  6f742075
0000b4  73656420
0000b8  696e2049
0000bc  53520a00
                  |L22.192|
0000c0  3000              DCB      "0",0
0000c2  00                DCB      0
0000c3  00                DCB      0
                  |L22.196|
                          DCD      0x0000fffc

                          AREA ||i.rt_mq_delete||, CODE, READONLY, ALIGN=2

                  rt_mq_delete PROC
;;;1887    */
;;;1888   rt_err_t rt_mq_delete(rt_mq_t mq)
000000  b570              PUSH     {r4-r6,lr}
;;;1889   {
000002  4604              MOV      r4,r0
;;;1890       RT_DEBUG_NOT_IN_INTERRUPT;
000004  f7fffffe          BL       rt_hw_interrupt_disable
000008  4605              MOV      r5,r0
00000a  f7fffffe          BL       rt_interrupt_get_nest
00000e  2800              CMP      r0,#0
000010  d008              BEQ      |L23.36|
000012  4910              LDR      r1,|L23.84|
000014  a010              ADR      r0,|L23.88|
000016  f7fffffe          BL       rt_kprintf
00001a  4a18              LDR      r2,|L23.124|
00001c  490d              LDR      r1,|L23.84|
00001e  a018              ADR      r0,|L23.128|
000020  f7fffffe          BL       rt_assert_handler
                  |L23.36|
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       rt_hw_interrupt_enable
;;;1891   
;;;1892       /* parameter check */
;;;1893       RT_ASSERT(mq != RT_NULL);
00002a  2c00              CMP      r4,#0
00002c  d105              BNE      |L23.58|
00002e  4a13              LDR      r2,|L23.124|
000030  4908              LDR      r1,|L23.84|
000032  1cd2              ADDS     r2,r2,#3
000034  a013              ADR      r0,|L23.132|
000036  f7fffffe          BL       rt_assert_handler
                  |L23.58|
;;;1894   
;;;1895       /* resume all suspended thread */
;;;1896       rt_ipc_list_resume_all(&(mq->parent.suspend_thread));
00003a  4620              MOV      r0,r4
00003c  3014              ADDS     r0,r0,#0x14
00003e  f7fffffe          BL       rt_ipc_list_resume_all
;;;1897   
;;;1898   #if defined(RT_USING_MODULE) && defined(RT_USING_SLAB)
;;;1899       /* the mq object belongs to an application module */
;;;1900       if (mq->parent.parent.flag & RT_OBJECT_FLAG_MODULE)
;;;1901           rt_module_free(mq->parent.parent.module_id, mq->msg_pool);
;;;1902       else
;;;1903   #endif
;;;1904   
;;;1905       /* free message queue pool */
;;;1906       RT_KERNEL_FREE(mq->msg_pool);
000042  69e0              LDR      r0,[r4,#0x1c]
000044  f7fffffe          BL       rt_free
;;;1907   
;;;1908       /* delete message queue object */
;;;1909       rt_object_delete(&(mq->parent.parent));
000048  4620              MOV      r0,r4
00004a  f7fffffe          BL       rt_object_delete
;;;1910   
;;;1911       return RT_EOK;
00004e  2000              MOVS     r0,#0
;;;1912   }
000050  bd70              POP      {r4-r6,pc}
;;;1913   RTM_EXPORT(rt_mq_delete);
                          ENDP

000052  0000              DCW      0x0000
                  |L23.84|
                          DCD      ||.constdata||+0x199
                  |L23.88|
000058  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
00005c  74696f6e
000060  5b25735d
000064  20736861
000068  6c6c206e
00006c  6f742075
000070  73656420
000074  696e2049
000078  53520a00
                  |L23.124|
                          DCD      0x00000762
                  |L23.128|
000080  3000              DCB      "0",0
000082  00                DCB      0
000083  00                DCB      0
                  |L23.132|
000084  6d712021          DCB      "mq != RT_NULL",0
000088  3d205254
00008c  5f4e554c
000090  4c00    
000092  00                DCB      0
000093  00                DCB      0

                          AREA ||i.rt_mq_detach||, CODE, READONLY, ALIGN=2

                  rt_mq_detach PROC
;;;1796    */
;;;1797   rt_err_t rt_mq_detach(rt_mq_t mq)
000000  b510              PUSH     {r4,lr}
;;;1798   {
000002  0004              MOVS     r4,r0
000004  d105              BNE      |L24.18|
;;;1799       /* parameter check */
;;;1800       RT_ASSERT(mq != RT_NULL);
000006  22e1              MOVS     r2,#0xe1
000008  00d2              LSLS     r2,r2,#3
00000a  4906              LDR      r1,|L24.36|
00000c  a006              ADR      r0,|L24.40|
00000e  f7fffffe          BL       rt_assert_handler
                  |L24.18|
;;;1801   
;;;1802       /* resume all suspended thread */
;;;1803       rt_ipc_list_resume_all(&mq->parent.suspend_thread);
000012  4620              MOV      r0,r4
000014  3014              ADDS     r0,r0,#0x14
000016  f7fffffe          BL       rt_ipc_list_resume_all
;;;1804   
;;;1805       /* detach message queue object */
;;;1806       rt_object_detach(&(mq->parent.parent));
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       rt_object_detach
;;;1807   
;;;1808       return RT_EOK;
000020  2000              MOVS     r0,#0
;;;1809   }
000022  bd10              POP      {r4,pc}
;;;1810   RTM_EXPORT(rt_mq_detach);
                          ENDP

                  |L24.36|
                          DCD      ||.constdata||+0x17f
                  |L24.40|
000028  6d712021          DCB      "mq != RT_NULL",0
00002c  3d205254
000030  5f4e554c
000034  4c00    
000036  00                DCB      0
000037  00                DCB      0

                          AREA ||i.rt_mq_init||, CODE, READONLY, ALIGN=2

                  rt_mq_init PROC
;;;1739    */
;;;1740   rt_err_t rt_mq_init(rt_mq_t     mq,
000000  b5ff              PUSH     {r0-r7,lr}
;;;1741                       const char *name,
;;;1742                       void       *msgpool,
;;;1743                       rt_size_t   msg_size,
;;;1744                       rt_size_t   pool_size,
;;;1745                       rt_uint8_t  flag)
;;;1746   {
000002  b081              SUB      sp,sp,#4
000004  9f0b              LDR      r7,[sp,#0x2c]
000006  461d              MOV      r5,r3
000008  4616              MOV      r6,r2
00000a  0004              MOVS     r4,r0
00000c  d104              BNE      |L25.24|
;;;1747       struct rt_mq_message *head;
;;;1748       register rt_base_t temp;
;;;1749   
;;;1750       /* parameter check */
;;;1751       RT_ASSERT(mq != RT_NULL);
00000e  4a17              LDR      r2,|L25.108|
000010  4917              LDR      r1,|L25.112|
000012  a018              ADR      r0,|L25.116|
000014  f7fffffe          BL       rt_assert_handler
                  |L25.24|
;;;1752   
;;;1753       /* init object */
;;;1754       rt_object_init(&(mq->parent.parent), RT_Object_Class_MessageQueue, name);
000018  2105              MOVS     r1,#5
00001a  4620              MOV      r0,r4
00001c  9a02              LDR      r2,[sp,#8]
00001e  f7fffffe          BL       rt_object_init
000022  4620              MOV      r0,r4
;;;1755   
;;;1756       /* set parent flag */
;;;1757       mq->parent.parent.flag = flag;
000024  7267              STRB     r7,[r4,#9]
000026  3014              ADDS     r0,r0,#0x14
000028  61a0              STR      r0,[r4,#0x18]
;;;1758   
;;;1759       /* init ipc object */
;;;1760       rt_ipc_object_init(&(mq->parent));
;;;1761   
;;;1762       /* set messasge pool */
;;;1763       mq->msg_pool = msgpool;
;;;1764   
;;;1765       /* get correct message size */
;;;1766       mq->msg_size = RT_ALIGN(msg_size, RT_ALIGN_SIZE);
00002a  61e6              STR      r6,[r4,#0x1c]
00002c  6160              STR      r0,[r4,#0x14]
00002e  4815              LDR      r0,|L25.132|
000030  1ce9              ADDS     r1,r5,#3
000032  4001              ANDS     r1,r1,r0
000034  8421              STRH     r1,[r4,#0x20]
;;;1767       mq->max_msgs = pool_size / (mq->msg_size + sizeof(struct rt_mq_message));
000036  1d09              ADDS     r1,r1,#4
000038  980a              LDR      r0,[sp,#0x28]
00003a  f7fffffe          BL       __aeabi_uidivmod
00003e  8460              STRH     r0,[r4,#0x22]
;;;1768   
;;;1769       /* init message list */
;;;1770       mq->msg_queue_head = RT_NULL;
000040  2200              MOVS     r2,#0
;;;1771       mq->msg_queue_tail = RT_NULL;
000042  62a2              STR      r2,[r4,#0x28]
;;;1772   
;;;1773       /* init message empty list */
;;;1774       mq->msg_queue_free = RT_NULL;
000044  62e2              STR      r2,[r4,#0x2c]
;;;1775       for (temp = 0; temp < mq->max_msgs; temp ++)
000046  4610              MOV      r0,r2
000048  6322              STR      r2,[r4,#0x30]
00004a  e008              B        |L25.94|
                  |L25.76|
;;;1776       {
;;;1777           head = (struct rt_mq_message *)((rt_uint8_t *)mq->msg_pool +
00004c  8c21              LDRH     r1,[r4,#0x20]
00004e  69e3              LDR      r3,[r4,#0x1c]
000050  1d09              ADDS     r1,r1,#4
000052  4341              MULS     r1,r0,r1
000054  1859              ADDS     r1,r3,r1
;;;1778               temp * (mq->msg_size + sizeof(struct rt_mq_message)));
;;;1779           head->next = mq->msg_queue_free;
000056  6b23              LDR      r3,[r4,#0x30]
;;;1780           mq->msg_queue_free = head;
000058  600b              STR      r3,[r1,#0]
00005a  1c40              ADDS     r0,r0,#1
00005c  6321              STR      r1,[r4,#0x30]
                  |L25.94|
00005e  8c61              LDRH     r1,[r4,#0x22]         ;1775
000060  4281              CMP      r1,r0                 ;1775
000062  dcf3              BGT      |L25.76|
;;;1781       }
;;;1782   
;;;1783       /* the initial entry is zero */
;;;1784       mq->entry = 0;
000064  84a2              STRH     r2,[r4,#0x24]
;;;1785   
;;;1786       return RT_EOK;
000066  2000              MOVS     r0,#0
;;;1787   }
000068  b005              ADD      sp,sp,#0x14
00006a  bdf0              POP      {r4-r7,pc}
;;;1788   RTM_EXPORT(rt_mq_init);
                          ENDP

                  |L25.108|
                          DCD      0x000006d7
                  |L25.112|
                          DCD      ||.constdata||+0x174
                  |L25.116|
000074  6d712021          DCB      "mq != RT_NULL",0
000078  3d205254
00007c  5f4e554c
000080  4c00    
000082  00                DCB      0
000083  00                DCB      0
                  |L25.132|
                          DCD      0x0000fffc

                          AREA ||i.rt_mq_recv||, CODE, READONLY, ALIGN=2

                  rt_mq_recv PROC
;;;2096    */
;;;2097   rt_err_t rt_mq_recv(rt_mq_t    mq,
000000  b5ff              PUSH     {r0-r7,lr}
;;;2098                       void      *buffer,
;;;2099                       rt_size_t  size,
;;;2100                       rt_int32_t timeout)
;;;2101   {
000002  b083              SUB      sp,sp,#0xc
000004  0004              MOVS     r4,r0
000006  d104              BNE      |L26.18|
;;;2102       struct rt_thread *thread;
;;;2103       register rt_ubase_t temp;
;;;2104       struct rt_mq_message *msg;
;;;2105       rt_uint32_t tick_delta;
;;;2106   
;;;2107       RT_ASSERT(mq != RT_NULL);
000008  4a55              LDR      r2,|L26.352|
00000a  4956              LDR      r1,|L26.356|
00000c  a056              ADR      r0,|L26.360|
00000e  f7fffffe          BL       rt_assert_handler
                  |L26.18|
;;;2108       RT_ASSERT(buffer != RT_NULL);
000012  9804              LDR      r0,[sp,#0x10]
000014  2800              CMP      r0,#0
000016  d105              BNE      |L26.36|
000018  4a51              LDR      r2,|L26.352|
00001a  4952              LDR      r1,|L26.356|
00001c  1c52              ADDS     r2,r2,#1
00001e  a056              ADR      r0,|L26.376|
000020  f7fffffe          BL       rt_assert_handler
                  |L26.36|
;;;2109       RT_ASSERT(size != 0);
000024  9805              LDR      r0,[sp,#0x14]
000026  2800              CMP      r0,#0
000028  d105              BNE      |L26.54|
00002a  4a4d              LDR      r2,|L26.352|
00002c  494d              LDR      r1,|L26.356|
00002e  1c92              ADDS     r2,r2,#2
000030  a056              ADR      r0,|L26.396|
000032  f7fffffe          BL       rt_assert_handler
                  |L26.54|
;;;2110   
;;;2111       /* initialize delta tick */
;;;2112       tick_delta = 0;
000036  2600              MOVS     r6,#0
;;;2113       /* get current thread */
;;;2114       thread = rt_thread_self();
000038  f7fffffe          BL       rt_thread_self
00003c  4605              MOV      r5,r0
;;;2115       RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(mq->parent.parent)));
;;;2116   
;;;2117       /* disable interrupt */
;;;2118       temp = rt_hw_interrupt_disable();
00003e  f7fffffe          BL       rt_hw_interrupt_disable
;;;2119   
;;;2120       /* for non-blocking call */
;;;2121       if (mq->entry == 0 && timeout == 0)
000042  9000              STR      r0,[sp,#0]
000044  8ca0              LDRH     r0,[r4,#0x24]
000046  9906              LDR      r1,[sp,#0x18]
000048  2700              MOVS     r7,#0
00004a  4308              ORRS     r0,r0,r1
00004c  2800              CMP      r0,#0
00004e  d15d              BNE      |L26.268|
;;;2122       {
;;;2123           rt_hw_interrupt_enable(temp);
000050  9800              LDR      r0,[sp,#0]
000052  f7fffffe          BL       rt_hw_interrupt_enable
;;;2124   
;;;2125           return -RT_ETIMEOUT;
000056  1eb0              SUBS     r0,r6,#2
                  |L26.88|
;;;2126       }
;;;2127   
;;;2128       /* message queue is empty */
;;;2129       while (mq->entry == 0)
;;;2130       {
;;;2131           RT_DEBUG_IN_THREAD_CONTEXT;
;;;2132   
;;;2133           /* reset error number in thread */
;;;2134           thread->error = RT_EOK;
;;;2135   
;;;2136           /* no waiting, return timeout */
;;;2137           if (timeout == 0)
;;;2138           {
;;;2139               /* enable interrupt */
;;;2140               rt_hw_interrupt_enable(temp);
;;;2141   
;;;2142               thread->error = -RT_ETIMEOUT;
;;;2143   
;;;2144               return -RT_ETIMEOUT;
;;;2145           }
;;;2146   
;;;2147           /* suspend current thread */
;;;2148           rt_ipc_list_suspend(&(mq->parent.suspend_thread),
;;;2149                               thread,
;;;2150                               mq->parent.parent.flag);
;;;2151   
;;;2152           /* has waiting time, start thread timer */
;;;2153           if (timeout > 0)
;;;2154           {
;;;2155               /* get the start tick of timer */
;;;2156               tick_delta = rt_tick_get();
;;;2157   
;;;2158               RT_DEBUG_LOG(RT_DEBUG_IPC, ("set thread:%s to timer list\n",
;;;2159                                           thread->name));
;;;2160   
;;;2161               /* reset the timeout of thread timer and start it */
;;;2162               rt_timer_control(&(thread->thread_timer),
;;;2163                                RT_TIMER_CTRL_SET_TIME,
;;;2164                                &timeout);
;;;2165               rt_timer_start(&(thread->thread_timer));
;;;2166           }
;;;2167   
;;;2168           /* enable interrupt */
;;;2169           rt_hw_interrupt_enable(temp);
;;;2170   
;;;2171           /* re-schedule */
;;;2172           rt_schedule();
;;;2173   
;;;2174           /* recv message */
;;;2175           if (thread->error != RT_EOK)
;;;2176           {
;;;2177               /* return error */
;;;2178               return thread->error;
;;;2179           }
;;;2180   
;;;2181           /* disable interrupt */
;;;2182           temp = rt_hw_interrupt_disable();
;;;2183   
;;;2184           /* if it's not waiting forever and then re-calculate timeout tick */
;;;2185           if (timeout > 0)
;;;2186           {
;;;2187               tick_delta = rt_tick_get() - tick_delta;
;;;2188               timeout -= tick_delta;
;;;2189               if (timeout < 0)
;;;2190                   timeout = 0;
;;;2191           }
;;;2192       }
;;;2193   
;;;2194       /* get message from queue */
;;;2195       msg = (struct rt_mq_message *)mq->msg_queue_head;
;;;2196   
;;;2197       /* move message queue head */
;;;2198       mq->msg_queue_head = msg->next;
;;;2199       /* reach queue tail, set to NULL */
;;;2200       if (mq->msg_queue_tail == msg)
;;;2201           mq->msg_queue_tail = RT_NULL;
;;;2202   
;;;2203       /* decrease message entry */
;;;2204       mq->entry --;
;;;2205   
;;;2206       /* enable interrupt */
;;;2207       rt_hw_interrupt_enable(temp);
;;;2208   
;;;2209       /* copy message */
;;;2210       rt_memcpy(buffer, msg + 1, size > mq->msg_size ? mq->msg_size : size);
;;;2211   
;;;2212       /* disable interrupt */
;;;2213       temp = rt_hw_interrupt_disable();
;;;2214       /* put message to free list */
;;;2215       msg->next = (struct rt_mq_message *)mq->msg_queue_free;
;;;2216       mq->msg_queue_free = msg;
;;;2217       /* enable interrupt */
;;;2218       rt_hw_interrupt_enable(temp);
;;;2219   
;;;2220       RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mq->parent.parent)));
;;;2221   
;;;2222       return RT_EOK;
;;;2223   }
000058  b007              ADD      sp,sp,#0x1c
00005a  bdf0              POP      {r4-r7,pc}
                  |L26.92|
00005c  f7fffffe          BL       rt_hw_interrupt_disable
000060  9002              STR      r0,[sp,#8]            ;2131
000062  f7fffffe          BL       rt_thread_self
000066  2800              CMP      r0,#0                 ;2131
000068  d109              BNE      |L26.126|
00006a  493e              LDR      r1,|L26.356|
00006c  a04a              ADR      r0,|L26.408|
00006e  f7fffffe          BL       rt_kprintf
000072  4a3b              LDR      r2,|L26.352|
000074  493b              LDR      r1,|L26.356|
000076  3218              ADDS     r2,r2,#0x18           ;2131
000078  a046              ADR      r0,|L26.404|
00007a  f7fffffe          BL       rt_assert_handler
                  |L26.126|
00007e  f7fffffe          BL       rt_hw_interrupt_disable
000082  9001              STR      r0,[sp,#4]            ;2131
000084  f7fffffe          BL       rt_interrupt_get_nest
000088  2800              CMP      r0,#0                 ;2131
00008a  d009              BEQ      |L26.160|
00008c  4935              LDR      r1,|L26.356|
00008e  a050              ADR      r0,|L26.464|
000090  f7fffffe          BL       rt_kprintf
000094  4a32              LDR      r2,|L26.352|
000096  4933              LDR      r1,|L26.356|
000098  3218              ADDS     r2,r2,#0x18           ;2131
00009a  a03e              ADR      r0,|L26.404|
00009c  f7fffffe          BL       rt_assert_handler
                  |L26.160|
0000a0  9801              LDR      r0,[sp,#4]            ;2131
0000a2  f7fffffe          BL       rt_hw_interrupt_enable
0000a6  9802              LDR      r0,[sp,#8]            ;2131
0000a8  f7fffffe          BL       rt_hw_interrupt_enable
0000ac  632f              STR      r7,[r5,#0x30]         ;2137
0000ae  9806              LDR      r0,[sp,#0x18]         ;2137
0000b0  2800              CMP      r0,#0                 ;2137
0000b2  d04d              BEQ      |L26.336|
0000b4  4620              MOV      r0,r4                 ;2148
0000b6  7a62              LDRB     r2,[r4,#9]            ;2148
0000b8  4629              MOV      r1,r5                 ;2148
0000ba  3014              ADDS     r0,r0,#0x14           ;2148
0000bc  f7fffffe          BL       rt_ipc_list_suspend
0000c0  9806              LDR      r0,[sp,#0x18]         ;2153
0000c2  2800              CMP      r0,#0                 ;2153
0000c4  dd0c              BLE      |L26.224|
0000c6  f7fffffe          BL       rt_tick_get
0000ca  4606              MOV      r6,r0                 ;2156
0000cc  4628              MOV      r0,r5                 ;2162
0000ce  304c              ADDS     r0,r0,#0x4c           ;2162
0000d0  aa06              ADD      r2,sp,#0x18           ;2162
0000d2  2100              MOVS     r1,#0                 ;2162
0000d4  9001              STR      r0,[sp,#4]            ;2162
0000d6  f7fffffe          BL       rt_timer_control
0000da  9801              LDR      r0,[sp,#4]            ;2165
0000dc  f7fffffe          BL       rt_timer_start
                  |L26.224|
0000e0  9800              LDR      r0,[sp,#0]            ;2169
0000e2  f7fffffe          BL       rt_hw_interrupt_enable
0000e6  f7fffffe          BL       rt_schedule
0000ea  6b28              LDR      r0,[r5,#0x30]         ;2175
0000ec  2800              CMP      r0,#0                 ;2175
0000ee  d1b3              BNE      |L26.88|
0000f0  f7fffffe          BL       rt_hw_interrupt_disable
0000f4  9000              STR      r0,[sp,#0]            ;2185
0000f6  9806              LDR      r0,[sp,#0x18]         ;2185
0000f8  2800              CMP      r0,#0                 ;2185
0000fa  dd07              BLE      |L26.268|
0000fc  f7fffffe          BL       rt_tick_get
000100  1b86              SUBS     r6,r0,r6              ;2187
000102  9806              LDR      r0,[sp,#0x18]         ;2188
000104  1b80              SUBS     r0,r0,r6              ;2188
000106  9006              STR      r0,[sp,#0x18]         ;2189
000108  d500              BPL      |L26.268|
00010a  9706              STR      r7,[sp,#0x18]         ;2190
                  |L26.268|
00010c  8ca0              LDRH     r0,[r4,#0x24]         ;2129
00010e  2800              CMP      r0,#0                 ;2129
000110  d0a4              BEQ      |L26.92|
000112  6aa5              LDR      r5,[r4,#0x28]         ;2198
000114  6828              LDR      r0,[r5,#0]            ;2198
000116  62a0              STR      r0,[r4,#0x28]         ;2200
000118  6ae0              LDR      r0,[r4,#0x2c]         ;2200
00011a  42a8              CMP      r0,r5                 ;2200
00011c  d100              BNE      |L26.288|
00011e  62e7              STR      r7,[r4,#0x2c]         ;2201
                  |L26.288|
000120  8ca0              LDRH     r0,[r4,#0x24]         ;2204
000122  1e40              SUBS     r0,r0,#1              ;2204
000124  84a0              STRH     r0,[r4,#0x24]         ;2204
000126  9800              LDR      r0,[sp,#0]            ;2207
000128  f7fffffe          BL       rt_hw_interrupt_enable
00012c  8c22              LDRH     r2,[r4,#0x20]         ;2210
00012e  9805              LDR      r0,[sp,#0x14]         ;2210
000130  4282              CMP      r2,r0                 ;2210
000132  d300              BCC      |L26.310|
000134  4602              MOV      r2,r0                 ;2210
                  |L26.310|
000136  1d29              ADDS     r1,r5,#4              ;2210
000138  9804              LDR      r0,[sp,#0x10]         ;2210
00013a  f7fffffe          BL       rt_memcpy
00013e  f7fffffe          BL       rt_hw_interrupt_disable
000142  6b21              LDR      r1,[r4,#0x30]         ;2215
000144  6029              STR      r1,[r5,#0]            ;2216
000146  6325              STR      r5,[r4,#0x30]         ;2218
000148  f7fffffe          BL       rt_hw_interrupt_enable
00014c  2000              MOVS     r0,#0                 ;2222
00014e  e783              B        |L26.88|
                  |L26.336|
000150  9800              LDR      r0,[sp,#0]            ;2140
000152  f7fffffe          BL       rt_hw_interrupt_enable
000156  2001              MOVS     r0,#1                 ;2142
000158  43c0              MVNS     r0,r0                 ;2142
00015a  6328              STR      r0,[r5,#0x30]         ;2142
00015c  e77c              B        |L26.88|
;;;2224   RTM_EXPORT(rt_mq_recv);
                          ENDP

00015e  0000              DCW      0x0000
                  |L26.352|
                          DCD      0x0000083b
                  |L26.356|
                          DCD      ||.constdata||+0x1be
                  |L26.360|
000168  6d712021          DCB      "mq != RT_NULL",0
00016c  3d205254
000170  5f4e554c
000174  4c00    
000176  00                DCB      0
000177  00                DCB      0
                  |L26.376|
000178  62756666          DCB      "buffer != RT_NULL",0
00017c  65722021
000180  3d205254
000184  5f4e554c
000188  4c00    
00018a  00                DCB      0
00018b  00                DCB      0
                  |L26.396|
00018c  73697a65          DCB      "size != "
000190  20213d20
                  |L26.404|
000194  3000              DCB      "0",0
000196  00                DCB      0
000197  00                DCB      0
                  |L26.408|
000198  46756e63          DCB      "Function[%s] shall not be used before scheduler start\n"
00019c  74696f6e
0001a0  5b25735d
0001a4  20736861
0001a8  6c6c206e
0001ac  6f742062
0001b0  65207573
0001b4  65642062
0001b8  65666f72
0001bc  65207363
0001c0  68656475
0001c4  6c657220
0001c8  73746172
0001cc  740a    
0001ce  00                DCB      0
0001cf  00                DCB      0
                  |L26.464|
0001d0  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
0001d4  74696f6e
0001d8  5b25735d
0001dc  20736861
0001e0  6c6c206e
0001e4  6f742075
0001e8  73656420
0001ec  696e2049
0001f0  53520a00

                          AREA ||i.rt_mq_send||, CODE, READONLY, ALIGN=2

                  rt_mq_send PROC
;;;1925    */
;;;1926   rt_err_t rt_mq_send(rt_mq_t mq, void *buffer, rt_size_t size)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1927   {
000002  4616              MOV      r6,r2
000004  460f              MOV      r7,r1
000006  0004              MOVS     r4,r0
000008  d104              BNE      |L27.20|
;;;1928       register rt_ubase_t temp;
;;;1929       struct rt_mq_message *msg;
;;;1930   
;;;1931       RT_ASSERT(mq != RT_NULL);
00000a  4a2a              LDR      r2,|L27.180|
00000c  492a              LDR      r1,|L27.184|
00000e  a02b              ADR      r0,|L27.188|
000010  f7fffffe          BL       rt_assert_handler
                  |L27.20|
;;;1932       RT_ASSERT(buffer != RT_NULL);
000014  2f00              CMP      r7,#0
000016  d105              BNE      |L27.36|
000018  4a26              LDR      r2,|L27.180|
00001a  4927              LDR      r1,|L27.184|
00001c  1c52              ADDS     r2,r2,#1
00001e  a02b              ADR      r0,|L27.204|
000020  f7fffffe          BL       rt_assert_handler
                  |L27.36|
;;;1933       RT_ASSERT(size != 0);
000024  2e00              CMP      r6,#0
000026  d105              BNE      |L27.52|
000028  4a22              LDR      r2,|L27.180|
00002a  4923              LDR      r1,|L27.184|
00002c  1c92              ADDS     r2,r2,#2
00002e  a02c              ADR      r0,|L27.224|
000030  f7fffffe          BL       rt_assert_handler
                  |L27.52|
;;;1934   
;;;1935       /* greater than one message size */
;;;1936       if (size > mq->msg_size)
000034  8c20              LDRH     r0,[r4,#0x20]
000036  42b0              CMP      r0,r6
000038  d202              BCS      |L27.64|
;;;1937           return -RT_ERROR;
00003a  2000              MOVS     r0,#0
00003c  43c0              MVNS     r0,r0
;;;1938   
;;;1939       RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mq->parent.parent)));
;;;1940   
;;;1941       /* disable interrupt */
;;;1942       temp = rt_hw_interrupt_disable();
;;;1943   
;;;1944       /* get a free list, there must be an empty item */
;;;1945       msg = (struct rt_mq_message*)mq->msg_queue_free;
;;;1946       /* message queue is full */
;;;1947       if (msg == RT_NULL)
;;;1948       {
;;;1949           /* enable interrupt */
;;;1950           rt_hw_interrupt_enable(temp);
;;;1951   
;;;1952           return -RT_EFULL;
;;;1953       }
;;;1954       /* move free list pointer */
;;;1955       mq->msg_queue_free = msg->next;
;;;1956   
;;;1957       /* enable interrupt */
;;;1958       rt_hw_interrupt_enable(temp);
;;;1959   
;;;1960       /* the msg is the new tailer of list, the next shall be NULL */
;;;1961       msg->next = RT_NULL;
;;;1962       /* copy buffer */
;;;1963       rt_memcpy(msg + 1, buffer, size);
;;;1964   
;;;1965       /* disable interrupt */
;;;1966       temp = rt_hw_interrupt_disable();
;;;1967       /* link msg to message queue */
;;;1968       if (mq->msg_queue_tail != RT_NULL)
;;;1969       {
;;;1970           /* if the tail exists, */
;;;1971           ((struct rt_mq_message *)mq->msg_queue_tail)->next = msg;
;;;1972       }
;;;1973   
;;;1974       /* set new tail */
;;;1975       mq->msg_queue_tail = msg;
;;;1976       /* if the head is empty, set head */
;;;1977       if (mq->msg_queue_head == RT_NULL)
;;;1978           mq->msg_queue_head = msg;
;;;1979   
;;;1980       /* increase message entry */
;;;1981       mq->entry ++;
;;;1982   
;;;1983       /* resume suspended thread */
;;;1984       if (!rt_list_isempty(&mq->parent.suspend_thread))
;;;1985       {
;;;1986           rt_ipc_list_resume(&(mq->parent.suspend_thread));
;;;1987   
;;;1988           /* enable interrupt */
;;;1989           rt_hw_interrupt_enable(temp);
;;;1990   
;;;1991           rt_schedule();
;;;1992   
;;;1993           return RT_EOK;
;;;1994       }
;;;1995   
;;;1996       /* enable interrupt */
;;;1997       rt_hw_interrupt_enable(temp);
;;;1998   
;;;1999       return RT_EOK;
;;;2000   }
00003e  bdf8              POP      {r3-r7,pc}
                  |L27.64|
000040  f7fffffe          BL       rt_hw_interrupt_disable
000044  6b25              LDR      r5,[r4,#0x30]         ;1947
000046  2d00              CMP      r5,#0                 ;1947
000048  d016              BEQ      |L27.120|
00004a  6829              LDR      r1,[r5,#0]            ;1955
00004c  6321              STR      r1,[r4,#0x30]         ;1958
00004e  f7fffffe          BL       rt_hw_interrupt_enable
000052  2000              MOVS     r0,#0                 ;1961
000054  6028              STR      r0,[r5,#0]            ;1963
000056  4632              MOV      r2,r6                 ;1963
000058  4639              MOV      r1,r7                 ;1963
00005a  1d28              ADDS     r0,r5,#4              ;1963
00005c  f7fffffe          BL       rt_memcpy
000060  f7fffffe          BL       rt_hw_interrupt_disable
000064  4606              MOV      r6,r0                 ;1966
000066  6ae0              LDR      r0,[r4,#0x2c]         ;1968
000068  2800              CMP      r0,#0                 ;1968
00006a  d000              BEQ      |L27.110|
00006c  6005              STR      r5,[r0,#0]            ;1971
                  |L27.110|
00006e  62e5              STR      r5,[r4,#0x2c]         ;1977
000070  6aa0              LDR      r0,[r4,#0x28]         ;1977
000072  2800              CMP      r0,#0                 ;1977
000074  d005              BEQ      |L27.130|
000076  e005              B        |L27.132|
                  |L27.120|
000078  f7fffffe          BL       rt_hw_interrupt_enable
00007c  2002              MOVS     r0,#2                 ;1952
00007e  43c0              MVNS     r0,r0                 ;1952
000080  bdf8              POP      {r3-r7,pc}
                  |L27.130|
000082  62a5              STR      r5,[r4,#0x28]         ;1978
                  |L27.132|
000084  8ca0              LDRH     r0,[r4,#0x24]         ;1981
000086  1c40              ADDS     r0,r0,#1              ;1981
000088  84a0              STRH     r0,[r4,#0x24]         ;1981
00008a  4620              MOV      r0,r4                 ;1984
00008c  3014              ADDS     r0,r0,#0x14           ;1984
00008e  4604              MOV      r4,r0                 ;1984
000090  f7fffffe          BL       rt_list_isempty
000094  2800              CMP      r0,#0                 ;1984
000096  d004              BEQ      |L27.162|
000098  4630              MOV      r0,r6                 ;1997
00009a  f7fffffe          BL       rt_hw_interrupt_enable
                  |L27.158|
00009e  2000              MOVS     r0,#0                 ;1999
0000a0  bdf8              POP      {r3-r7,pc}
                  |L27.162|
0000a2  4620              MOV      r0,r4
0000a4  f7fffffe          BL       rt_ipc_list_resume
0000a8  4630              MOV      r0,r6                 ;1989
0000aa  f7fffffe          BL       rt_hw_interrupt_enable
0000ae  f7fffffe          BL       rt_schedule
0000b2  e7f4              B        |L27.158|
;;;2001   RTM_EXPORT(rt_mq_send);
                          ENDP

                  |L27.180|
                          DCD      0x0000078b
                  |L27.184|
                          DCD      ||.constdata||+0x1a6
                  |L27.188|
0000bc  6d712021          DCB      "mq != RT_NULL",0
0000c0  3d205254
0000c4  5f4e554c
0000c8  4c00    
0000ca  00                DCB      0
0000cb  00                DCB      0
                  |L27.204|
0000cc  62756666          DCB      "buffer != RT_NULL",0
0000d0  65722021
0000d4  3d205254
0000d8  5f4e554c
0000dc  4c00    
0000de  00                DCB      0
0000df  00                DCB      0
                  |L27.224|
0000e0  73697a65          DCB      "size != 0",0
0000e4  20213d20
0000e8  3000    
0000ea  00                DCB      0
0000eb  00                DCB      0

                          AREA ||i.rt_mq_urgent||, CODE, READONLY, ALIGN=2

                  rt_mq_urgent PROC
;;;2013    */
;;;2014   rt_err_t rt_mq_urgent(rt_mq_t mq, void *buffer, rt_size_t size)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2015   {
000002  4616              MOV      r6,r2
000004  460f              MOV      r7,r1
000006  0004              MOVS     r4,r0
000008  d104              BNE      |L28.20|
;;;2016       register rt_ubase_t temp;
;;;2017       struct rt_mq_message *msg;
;;;2018   
;;;2019       RT_ASSERT(mq != RT_NULL);
00000a  4a28              LDR      r2,|L28.172|
00000c  4928              LDR      r1,|L28.176|
00000e  a029              ADR      r0,|L28.180|
000010  f7fffffe          BL       rt_assert_handler
                  |L28.20|
;;;2020       RT_ASSERT(buffer != RT_NULL);
000014  2f00              CMP      r7,#0
000016  d105              BNE      |L28.36|
000018  4a24              LDR      r2,|L28.172|
00001a  4925              LDR      r1,|L28.176|
00001c  1c52              ADDS     r2,r2,#1
00001e  a029              ADR      r0,|L28.196|
000020  f7fffffe          BL       rt_assert_handler
                  |L28.36|
;;;2021       RT_ASSERT(size != 0);
000024  2e00              CMP      r6,#0
000026  d105              BNE      |L28.52|
000028  4a20              LDR      r2,|L28.172|
00002a  4921              LDR      r1,|L28.176|
00002c  1c92              ADDS     r2,r2,#2
00002e  a02a              ADR      r0,|L28.216|
000030  f7fffffe          BL       rt_assert_handler
                  |L28.52|
;;;2022   
;;;2023       /* greater than one message size */
;;;2024       if (size > mq->msg_size)
000034  8c20              LDRH     r0,[r4,#0x20]
000036  42b0              CMP      r0,r6
000038  d202              BCS      |L28.64|
;;;2025           return -RT_ERROR;
00003a  2000              MOVS     r0,#0
00003c  43c0              MVNS     r0,r0
;;;2026   
;;;2027       RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mq->parent.parent)));
;;;2028   
;;;2029       /* disable interrupt */
;;;2030       temp = rt_hw_interrupt_disable();
;;;2031   
;;;2032       /* get a free list, there must be an empty item */
;;;2033       msg = (struct rt_mq_message *)mq->msg_queue_free;
;;;2034       /* message queue is full */
;;;2035       if (msg == RT_NULL)
;;;2036       {
;;;2037           /* enable interrupt */
;;;2038           rt_hw_interrupt_enable(temp);
;;;2039   
;;;2040           return -RT_EFULL;
;;;2041       }
;;;2042       /* move free list pointer */
;;;2043       mq->msg_queue_free = msg->next;
;;;2044   
;;;2045       /* enable interrupt */
;;;2046       rt_hw_interrupt_enable(temp);
;;;2047   
;;;2048       /* copy buffer */
;;;2049       rt_memcpy(msg + 1, buffer, size);
;;;2050   
;;;2051       /* disable interrupt */
;;;2052       temp = rt_hw_interrupt_disable();
;;;2053   
;;;2054       /* link msg to the beginning of message queue */
;;;2055       msg->next = mq->msg_queue_head;
;;;2056       mq->msg_queue_head = msg;
;;;2057   
;;;2058       /* if there is no tail */
;;;2059       if (mq->msg_queue_tail == RT_NULL)
;;;2060           mq->msg_queue_tail = msg;
;;;2061   
;;;2062       /* increase message entry */
;;;2063       mq->entry ++;
;;;2064   
;;;2065       /* resume suspended thread */
;;;2066       if (!rt_list_isempty(&mq->parent.suspend_thread))
;;;2067       {
;;;2068           rt_ipc_list_resume(&(mq->parent.suspend_thread));
;;;2069   
;;;2070           /* enable interrupt */
;;;2071           rt_hw_interrupt_enable(temp);
;;;2072   
;;;2073           rt_schedule();
;;;2074   
;;;2075           return RT_EOK;
;;;2076       }
;;;2077   
;;;2078       /* enable interrupt */
;;;2079       rt_hw_interrupt_enable(temp);
;;;2080   
;;;2081       return RT_EOK;
;;;2082   }
00003e  bdf8              POP      {r3-r7,pc}
                  |L28.64|
000040  f7fffffe          BL       rt_hw_interrupt_disable
000044  6b25              LDR      r5,[r4,#0x30]         ;2035
000046  2d00              CMP      r5,#0                 ;2035
000048  d012              BEQ      |L28.112|
00004a  6829              LDR      r1,[r5,#0]            ;2043
00004c  6321              STR      r1,[r4,#0x30]         ;2046
00004e  f7fffffe          BL       rt_hw_interrupt_enable
000052  4632              MOV      r2,r6                 ;2049
000054  4639              MOV      r1,r7                 ;2049
000056  1d28              ADDS     r0,r5,#4              ;2049
000058  f7fffffe          BL       rt_memcpy
00005c  f7fffffe          BL       rt_hw_interrupt_disable
000060  4606              MOV      r6,r0                 ;2052
000062  6aa0              LDR      r0,[r4,#0x28]         ;2055
000064  6028              STR      r0,[r5,#0]            ;2056
000066  62a5              STR      r5,[r4,#0x28]         ;2059
000068  6ae0              LDR      r0,[r4,#0x2c]         ;2059
00006a  2800              CMP      r0,#0                 ;2059
00006c  d005              BEQ      |L28.122|
00006e  e005              B        |L28.124|
                  |L28.112|
000070  f7fffffe          BL       rt_hw_interrupt_enable
000074  2002              MOVS     r0,#2                 ;2040
000076  43c0              MVNS     r0,r0                 ;2040
000078  bdf8              POP      {r3-r7,pc}
                  |L28.122|
00007a  62e5              STR      r5,[r4,#0x2c]         ;2060
                  |L28.124|
00007c  8ca0              LDRH     r0,[r4,#0x24]         ;2063
00007e  1c40              ADDS     r0,r0,#1              ;2063
000080  84a0              STRH     r0,[r4,#0x24]         ;2063
000082  4620              MOV      r0,r4                 ;2066
000084  3014              ADDS     r0,r0,#0x14           ;2066
000086  4604              MOV      r4,r0                 ;2066
000088  f7fffffe          BL       rt_list_isempty
00008c  2800              CMP      r0,#0                 ;2066
00008e  d004              BEQ      |L28.154|
000090  4630              MOV      r0,r6                 ;2079
000092  f7fffffe          BL       rt_hw_interrupt_enable
                  |L28.150|
000096  2000              MOVS     r0,#0                 ;2081
000098  bdf8              POP      {r3-r7,pc}
                  |L28.154|
00009a  4620              MOV      r0,r4
00009c  f7fffffe          BL       rt_ipc_list_resume
0000a0  4630              MOV      r0,r6                 ;2071
0000a2  f7fffffe          BL       rt_hw_interrupt_enable
0000a6  f7fffffe          BL       rt_schedule
0000aa  e7f4              B        |L28.150|
;;;2083   RTM_EXPORT(rt_mq_urgent);
                          ENDP

                  |L28.172|
                          DCD      0x000007e3
                  |L28.176|
                          DCD      ||.constdata||+0x1b1
                  |L28.180|
0000b4  6d712021          DCB      "mq != RT_NULL",0
0000b8  3d205254
0000bc  5f4e554c
0000c0  4c00    
0000c2  00                DCB      0
0000c3  00                DCB      0
                  |L28.196|
0000c4  62756666          DCB      "buffer != RT_NULL",0
0000c8  65722021
0000cc  3d205254
0000d0  5f4e554c
0000d4  4c00    
0000d6  00                DCB      0
0000d7  00                DCB      0
                  |L28.216|
0000d8  73697a65          DCB      "size != 0",0
0000dc  20213d20
0000e0  3000    
0000e2  00                DCB      0
0000e3  00                DCB      0

                          AREA ||i.rt_mutex_control||, CODE, READONLY, ALIGN=1

                  rt_mutex_control PROC
;;;870     */
;;;871    rt_err_t rt_mutex_control(rt_mutex_t mutex, rt_uint8_t cmd, void *arg)
000000  2000              MOVS     r0,#0
;;;872    {
;;;873        return -RT_ERROR;
000002  43c0              MVNS     r0,r0
;;;874    }
000004  4770              BX       lr
;;;875    RTM_EXPORT(rt_mutex_control);
                          ENDP


                          AREA ||i.rt_mutex_create||, CODE, READONLY, ALIGN=2

                  rt_mutex_create PROC
;;;580     */
;;;581    rt_mutex_t rt_mutex_create(const char *name, rt_uint8_t flag)
000000  b570              PUSH     {r4-r6,lr}
;;;582    {
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;583        struct rt_mutex *mutex;
;;;584    
;;;585        RT_DEBUG_NOT_IN_INTERRUPT;
000006  f7fffffe          BL       rt_hw_interrupt_disable
00000a  4606              MOV      r6,r0
00000c  f7fffffe          BL       rt_interrupt_get_nest
000010  2800              CMP      r0,#0
000012  d008              BEQ      |L30.38|
000014  490f              LDR      r1,|L30.84|
000016  a010              ADR      r0,|L30.88|
000018  f7fffffe          BL       rt_kprintf
00001c  4a17              LDR      r2,|L30.124|
00001e  490d              LDR      r1,|L30.84|
000020  a017              ADR      r0,|L30.128|
000022  f7fffffe          BL       rt_assert_handler
                  |L30.38|
000026  4630              MOV      r0,r6
000028  f7fffffe          BL       rt_hw_interrupt_enable
;;;586    
;;;587        /* allocate object */
;;;588        mutex = (rt_mutex_t)rt_object_allocate(RT_Object_Class_Mutex, name);
00002c  4629              MOV      r1,r5
00002e  2002              MOVS     r0,#2
000030  f7fffffe          BL       rt_object_allocate
;;;589        if (mutex == RT_NULL)
000034  2800              CMP      r0,#0
000036  d00b              BEQ      |L30.80|
000038  4601              MOV      r1,r0
00003a  3114              ADDS     r1,r1,#0x14
00003c  6181              STR      r1,[r0,#0x18]
;;;590            return mutex;
;;;591    
;;;592        /* init ipc object */
;;;593        rt_ipc_object_init(&(mutex->parent));
;;;594    
;;;595        mutex->value              = 1;
00003e  6141              STR      r1,[r0,#0x14]
000040  2101              MOVS     r1,#1
000042  8381              STRH     r1,[r0,#0x1c]
;;;596        mutex->owner              = RT_NULL;
000044  2100              MOVS     r1,#0
;;;597        mutex->original_priority  = 0xFF;
000046  22ff              MOVS     r2,#0xff
000048  6201              STR      r1,[r0,#0x20]
00004a  7782              STRB     r2,[r0,#0x1e]
;;;598        mutex->hold               = 0;
00004c  77c1              STRB     r1,[r0,#0x1f]
;;;599    
;;;600        /* set flag */
;;;601        mutex->parent.parent.flag = flag;
00004e  7244              STRB     r4,[r0,#9]
                  |L30.80|
;;;602    
;;;603        return mutex;
;;;604    }
000050  bd70              POP      {r4-r6,pc}
;;;605    RTM_EXPORT(rt_mutex_create);
                          ENDP

000052  0000              DCW      0x0000
                  |L30.84|
                          DCD      ||.constdata||+0x6f
                  |L30.88|
000058  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
00005c  74696f6e
000060  5b25735d
000064  20736861
000068  6c6c206e
00006c  6f742075
000070  73656420
000074  696e2049
000078  53520a00
                  |L30.124|
                          DCD      0x00000249
                  |L30.128|
000080  3000              DCB      "0",0
000082  00                DCB      0
000083  00                DCB      0

                          AREA ||i.rt_mutex_delete||, CODE, READONLY, ALIGN=2

                  rt_mutex_delete PROC
;;;615     */
;;;616    rt_err_t rt_mutex_delete(rt_mutex_t mutex)
000000  b570              PUSH     {r4-r6,lr}
;;;617    {
000002  4604              MOV      r4,r0
;;;618        RT_DEBUG_NOT_IN_INTERRUPT;
000004  f7fffffe          BL       rt_hw_interrupt_disable
000008  4605              MOV      r5,r0
00000a  f7fffffe          BL       rt_interrupt_get_nest
00000e  2800              CMP      r0,#0
000010  d008              BEQ      |L31.36|
000012  490e              LDR      r1,|L31.76|
000014  a00e              ADR      r0,|L31.80|
000016  f7fffffe          BL       rt_kprintf
00001a  4a16              LDR      r2,|L31.116|
00001c  490b              LDR      r1,|L31.76|
00001e  a016              ADR      r0,|L31.120|
000020  f7fffffe          BL       rt_assert_handler
                  |L31.36|
000024  4628              MOV      r0,r5
000026  f7fffffe          BL       rt_hw_interrupt_enable
;;;619    
;;;620        RT_ASSERT(mutex != RT_NULL);
00002a  2c00              CMP      r4,#0
00002c  d105              BNE      |L31.58|
00002e  229b              MOVS     r2,#0x9b
000030  0092              LSLS     r2,r2,#2
000032  4906              LDR      r1,|L31.76|
000034  a011              ADR      r0,|L31.124|
000036  f7fffffe          BL       rt_assert_handler
                  |L31.58|
;;;621    
;;;622        /* wakeup all suspend threads */
;;;623        rt_ipc_list_resume_all(&(mutex->parent.suspend_thread));
00003a  4620              MOV      r0,r4
00003c  3014              ADDS     r0,r0,#0x14
00003e  f7fffffe          BL       rt_ipc_list_resume_all
;;;624    
;;;625        /* delete semaphore object */
;;;626        rt_object_delete(&(mutex->parent.parent));
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       rt_object_delete
;;;627    
;;;628        return RT_EOK;
000048  2000              MOVS     r0,#0
;;;629    }
00004a  bd70              POP      {r4-r6,pc}
;;;630    RTM_EXPORT(rt_mutex_delete);
                          ENDP

                  |L31.76|
                          DCD      ||.constdata||+0x7f
                  |L31.80|
000050  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
000054  74696f6e
000058  5b25735d
00005c  20736861
000060  6c6c206e
000064  6f742075
000068  73656420
00006c  696e2049
000070  53520a00
                  |L31.116|
                          DCD      0x0000026a
                  |L31.120|
000078  3000              DCB      "0",0
00007a  00                DCB      0
00007b  00                DCB      0
                  |L31.124|
00007c  6d757465          DCB      "mutex != RT_NULL",0
000080  7820213d
000084  2052545f
000088  4e554c4c
00008c  00      
00008d  00                DCB      0
00008e  00                DCB      0
00008f  00                DCB      0

                          AREA ||i.rt_mutex_detach||, CODE, READONLY, ALIGN=2

                  rt_mutex_detach PROC
;;;555     */
;;;556    rt_err_t rt_mutex_detach(rt_mutex_t mutex)
000000  b510              PUSH     {r4,lr}
;;;557    {
000002  0004              MOVS     r4,r0
000004  d104              BNE      |L32.16|
;;;558        RT_ASSERT(mutex != RT_NULL);
000006  4a07              LDR      r2,|L32.36|
000008  4907              LDR      r1,|L32.40|
00000a  a008              ADR      r0,|L32.44|
00000c  f7fffffe          BL       rt_assert_handler
                  |L32.16|
;;;559    
;;;560        /* wakeup all suspend threads */
;;;561        rt_ipc_list_resume_all(&(mutex->parent.suspend_thread));
000010  4620              MOV      r0,r4
000012  3014              ADDS     r0,r0,#0x14
000014  f7fffffe          BL       rt_ipc_list_resume_all
;;;562    
;;;563        /* detach semaphore object */
;;;564        rt_object_detach(&(mutex->parent.parent));
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       rt_object_detach
;;;565    
;;;566        return RT_EOK;
00001e  2000              MOVS     r0,#0
;;;567    }
000020  bd10              POP      {r4,pc}
;;;568    RTM_EXPORT(rt_mutex_detach);
                          ENDP

000022  0000              DCW      0x0000
                  |L32.36|
                          DCD      0x0000022e
                  |L32.40|
                          DCD      ||.constdata||+0x5f
                  |L32.44|
00002c  6d757465          DCB      "mutex != RT_NULL",0
000030  7820213d
000034  2052545f
000038  4e554c4c
00003c  00      
00003d  00                DCB      0
00003e  00                DCB      0
00003f  00                DCB      0

                          AREA ||i.rt_mutex_init||, CODE, READONLY, ALIGN=2

                  rt_mutex_init PROC
;;;524     */
;;;525    rt_err_t rt_mutex_init(rt_mutex_t mutex, const char *name, rt_uint8_t flag)
000000  b570              PUSH     {r4-r6,lr}
;;;526    {
000002  4615              MOV      r5,r2
000004  460e              MOV      r6,r1
000006  0004              MOVS     r4,r0
000008  d104              BNE      |L33.20|
;;;527        RT_ASSERT(mutex != RT_NULL);
00000a  4a0b              LDR      r2,|L33.56|
00000c  490b              LDR      r1,|L33.60|
00000e  a00c              ADR      r0,|L33.64|
000010  f7fffffe          BL       rt_assert_handler
                  |L33.20|
;;;528    
;;;529        /* init object */
;;;530        rt_object_init(&(mutex->parent.parent), RT_Object_Class_Mutex, name);
000014  4632              MOV      r2,r6
000016  2102              MOVS     r1,#2
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       rt_object_init
00001e  4620              MOV      r0,r4
000020  3014              ADDS     r0,r0,#0x14
000022  61a0              STR      r0,[r4,#0x18]
;;;531    
;;;532        /* init ipc object */
;;;533        rt_ipc_object_init(&(mutex->parent));
;;;534    
;;;535        mutex->value = 1;
000024  6160              STR      r0,[r4,#0x14]
000026  2001              MOVS     r0,#1
000028  83a0              STRH     r0,[r4,#0x1c]
;;;536        mutex->owner = RT_NULL;
00002a  2000              MOVS     r0,#0
;;;537        mutex->original_priority = 0xFF;
00002c  21ff              MOVS     r1,#0xff
00002e  6220              STR      r0,[r4,#0x20]
000030  77a1              STRB     r1,[r4,#0x1e]
;;;538        mutex->hold  = 0;
000032  77e0              STRB     r0,[r4,#0x1f]
;;;539    
;;;540        /* set flag */
;;;541        mutex->parent.parent.flag = flag;
000034  7265              STRB     r5,[r4,#9]
;;;542    
;;;543        return RT_EOK;
;;;544    }
000036  bd70              POP      {r4-r6,pc}
;;;545    RTM_EXPORT(rt_mutex_init);
                          ENDP

                  |L33.56|
                          DCD      0x0000020f
                  |L33.60|
                          DCD      ||.constdata||+0x51
                  |L33.64|
000040  6d757465          DCB      "mutex != RT_NULL",0
000044  7820213d
000048  2052545f
00004c  4e554c4c
000050  00      
000051  00                DCB      0
000052  00                DCB      0
000053  00                DCB      0

                          AREA ||i.rt_mutex_release||, CODE, READONLY, ALIGN=2

                  rt_mutex_release PROC
;;;771     */
;;;772    rt_err_t rt_mutex_release(rt_mutex_t mutex)
000000  b5f8              PUSH     {r3-r7,lr}
;;;773    {
000002  4604              MOV      r4,r0
;;;774        register rt_base_t temp;
;;;775        struct rt_thread *thread;
;;;776        rt_bool_t need_schedule;
;;;777    
;;;778        need_schedule = RT_FALSE;
000004  2700              MOVS     r7,#0
;;;779    
;;;780        /* only thread could release mutex because we need test the ownership */
;;;781        RT_DEBUG_IN_THREAD_CONTEXT;
000006  f7fffffe          BL       rt_hw_interrupt_disable
00000a  9000              STR      r0,[sp,#0]
00000c  f7fffffe          BL       rt_thread_self
000010  4d33              LDR      r5,|L34.224|
000012  2800              CMP      r0,#0
000014  d108              BNE      |L34.40|
000016  4933              LDR      r1,|L34.228|
000018  a033              ADR      r0,|L34.232|
00001a  f7fffffe          BL       rt_kprintf
00001e  462a              MOV      r2,r5
000020  4930              LDR      r1,|L34.228|
000022  a03f              ADR      r0,|L34.288|
000024  f7fffffe          BL       rt_assert_handler
                  |L34.40|
000028  f7fffffe          BL       rt_hw_interrupt_disable
00002c  4606              MOV      r6,r0
00002e  f7fffffe          BL       rt_interrupt_get_nest
000032  2800              CMP      r0,#0
000034  d008              BEQ      |L34.72|
000036  492b              LDR      r1,|L34.228|
000038  a03a              ADR      r0,|L34.292|
00003a  f7fffffe          BL       rt_kprintf
00003e  462a              MOV      r2,r5
000040  4928              LDR      r1,|L34.228|
000042  a037              ADR      r0,|L34.288|
000044  f7fffffe          BL       rt_assert_handler
                  |L34.72|
000048  4630              MOV      r0,r6
00004a  f7fffffe          BL       rt_hw_interrupt_enable
00004e  9800              LDR      r0,[sp,#0]
000050  f7fffffe          BL       rt_hw_interrupt_enable
;;;782    
;;;783        /* get current thread */
;;;784        thread = rt_thread_self();
000054  f7fffffe          BL       rt_thread_self
000058  4606              MOV      r6,r0
;;;785    
;;;786        /* disable interrupt */
;;;787        temp = rt_hw_interrupt_disable();
00005a  f7fffffe          BL       rt_hw_interrupt_disable
00005e  4605              MOV      r5,r0
;;;788    
;;;789        RT_DEBUG_LOG(RT_DEBUG_IPC,
;;;790                     ("mutex_release:current thread %s, mutex value: %d, hold: %d\n",
;;;791                      thread->name, mutex->value, mutex->hold));
;;;792    
;;;793        RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mutex->parent.parent)));
;;;794    
;;;795        /* mutex only can be released by owner */
;;;796        if (thread != mutex->owner)
000060  6a20              LDR      r0,[r4,#0x20]
000062  42b0              CMP      r0,r6
000064  d007              BEQ      |L34.118|
;;;797        {
;;;798            thread->error = -RT_ERROR;
000066  2400              MOVS     r4,#0
000068  43e4              MVNS     r4,r4
;;;799    
;;;800            /* enable interrupt */
;;;801            rt_hw_interrupt_enable(temp);
00006a  4628              MOV      r0,r5
00006c  6334              STR      r4,[r6,#0x30]
00006e  f7fffffe          BL       rt_hw_interrupt_enable
;;;802    
;;;803            return -RT_ERROR;
000072  4620              MOV      r0,r4
;;;804        }
;;;805    
;;;806        /* decrease hold */
;;;807        mutex->hold --;
;;;808        /* if no hold */
;;;809        if (mutex->hold == 0)
;;;810        {
;;;811            /* change the owner thread to original priority */
;;;812            if (mutex->original_priority != mutex->owner->current_priority)
;;;813            {
;;;814                rt_thread_control(mutex->owner,
;;;815                                  RT_THREAD_CTRL_CHANGE_PRIORITY,
;;;816                                  &(mutex->original_priority));
;;;817            }
;;;818    
;;;819            /* wakeup suspended thread */
;;;820            if (!rt_list_isempty(&mutex->parent.suspend_thread))
;;;821            {
;;;822                /* get suspended thread */
;;;823                thread = rt_list_entry(mutex->parent.suspend_thread.next,
;;;824                                       struct rt_thread,
;;;825                                       tlist);
;;;826    
;;;827                RT_DEBUG_LOG(RT_DEBUG_IPC, ("mutex_release: resume thread: %s\n",
;;;828                                            thread->name));
;;;829    
;;;830                /* set new owner and priority */
;;;831                mutex->owner             = thread;
;;;832                mutex->original_priority = thread->current_priority;
;;;833                mutex->hold ++;
;;;834    
;;;835                /* resume thread */
;;;836                rt_ipc_list_resume(&(mutex->parent.suspend_thread));
;;;837    
;;;838                need_schedule = RT_TRUE;
;;;839            }
;;;840            else
;;;841            {
;;;842                /* increase value */
;;;843                mutex->value ++;
;;;844    
;;;845                /* clear owner */
;;;846                mutex->owner             = RT_NULL;
;;;847                mutex->original_priority = 0xff;
;;;848            }
;;;849        }
;;;850    
;;;851        /* enable interrupt */
;;;852        rt_hw_interrupt_enable(temp);
;;;853    
;;;854        /* perform a schedule */
;;;855        if (need_schedule == RT_TRUE)
;;;856            rt_schedule();
;;;857    
;;;858        return RT_EOK;
;;;859    }
000074  bdf8              POP      {r3-r7,pc}
                  |L34.118|
000076  7fe1              LDRB     r1,[r4,#0x1f]         ;807
000078  1e49              SUBS     r1,r1,#1              ;807
00007a  0609              LSLS     r1,r1,#24             ;807
00007c  0e09              LSRS     r1,r1,#24             ;807
00007e  77e1              STRB     r1,[r4,#0x1f]         ;807
000080  d117              BNE      |L34.178|
000082  2135              MOVS     r1,#0x35              ;812
000084  7fa2              LDRB     r2,[r4,#0x1e]         ;812
000086  5c09              LDRB     r1,[r1,r0]            ;812
000088  428a              CMP      r2,r1                 ;812
00008a  d004              BEQ      |L34.150|
00008c  4622              MOV      r2,r4                 ;814
00008e  321e              ADDS     r2,r2,#0x1e           ;814
000090  2102              MOVS     r1,#2                 ;814
000092  f7fffffe          BL       rt_thread_control
                  |L34.150|
000096  4620              MOV      r0,r4                 ;820
000098  3014              ADDS     r0,r0,#0x14           ;820
00009a  4606              MOV      r6,r0                 ;820
00009c  f7fffffe          BL       rt_list_isempty
0000a0  2800              CMP      r0,#0                 ;820
0000a2  d00f              BEQ      |L34.196|
0000a4  8ba0              LDRH     r0,[r4,#0x1c]         ;843
0000a6  1c40              ADDS     r0,r0,#1              ;843
0000a8  83a0              STRH     r0,[r4,#0x1c]         ;843
0000aa  2000              MOVS     r0,#0                 ;846
0000ac  6220              STR      r0,[r4,#0x20]         ;847
0000ae  20ff              MOVS     r0,#0xff              ;847
0000b0  77a0              STRB     r0,[r4,#0x1e]         ;847
                  |L34.178|
0000b2  4628              MOV      r0,r5                 ;852
0000b4  f7fffffe          BL       rt_hw_interrupt_enable
0000b8  2f00              CMP      r7,#0                 ;855
0000ba  d001              BEQ      |L34.192|
0000bc  f7fffffe          BL       rt_schedule
                  |L34.192|
0000c0  2000              MOVS     r0,#0                 ;858
0000c2  bdf8              POP      {r3-r7,pc}
                  |L34.196|
0000c4  6960              LDR      r0,[r4,#0x14]         ;823
0000c6  3814              SUBS     r0,r0,#0x14           ;823
0000c8  6220              STR      r0,[r4,#0x20]         ;831
0000ca  3020              ADDS     r0,r0,#0x20           ;831
0000cc  7d40              LDRB     r0,[r0,#0x15]         ;832
0000ce  77a0              STRB     r0,[r4,#0x1e]         ;832
0000d0  7fe0              LDRB     r0,[r4,#0x1f]         ;833
0000d2  1c40              ADDS     r0,r0,#1              ;833
0000d4  77e0              STRB     r0,[r4,#0x1f]         ;833
0000d6  4630              MOV      r0,r6                 ;833
0000d8  f7fffffe          BL       rt_ipc_list_resume
0000dc  2701              MOVS     r7,#1                 ;838
0000de  e7e8              B        |L34.178|
;;;860    RTM_EXPORT(rt_mutex_release);
                          ENDP

                  |L34.224|
                          DCD      0x0000030d
                  |L34.228|
                          DCD      ||.constdata||+0x9d
                  |L34.232|
0000e8  46756e63          DCB      "Function[%s] shall not be used before scheduler start\n"
0000ec  74696f6e
0000f0  5b25735d
0000f4  20736861
0000f8  6c6c206e
0000fc  6f742062
000100  65207573
000104  65642062
000108  65666f72
00010c  65207363
000110  68656475
000114  6c657220
000118  73746172
00011c  740a    
00011e  00                DCB      0
00011f  00                DCB      0
                  |L34.288|
000120  3000              DCB      "0",0
000122  00                DCB      0
000123  00                DCB      0
                  |L34.292|
000124  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
000128  74696f6e
00012c  5b25735d
000130  20736861
000134  6c6c206e
000138  6f742075
00013c  73656420
000140  696e2049
000144  53520a00

                          AREA ||i.rt_mutex_take||, CODE, READONLY, ALIGN=2

                  rt_mutex_take PROC
;;;641     */
;;;642    rt_err_t rt_mutex_take(rt_mutex_t mutex, rt_int32_t time)
000000  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;643    {
000002  b081              SUB      sp,sp,#4
000004  4604              MOV      r4,r0
;;;644        register rt_base_t temp;
;;;645        struct rt_thread *thread;
;;;646    
;;;647        /* this function must not be used in interrupt even if time = 0 */
;;;648        RT_DEBUG_IN_THREAD_CONTEXT;
000006  f7fffffe          BL       rt_hw_interrupt_disable
00000a  4606              MOV      r6,r0
00000c  f7fffffe          BL       rt_thread_self
000010  2551              MOVS     r5,#0x51
000012  00ed              LSLS     r5,r5,#3
000014  2800              CMP      r0,#0
000016  d108              BNE      |L35.42|
000018  493b              LDR      r1,|L35.264|
00001a  a03c              ADR      r0,|L35.268|
00001c  f7fffffe          BL       rt_kprintf
000020  462a              MOV      r2,r5
000022  4939              LDR      r1,|L35.264|
000024  a047              ADR      r0,|L35.324|
000026  f7fffffe          BL       rt_assert_handler
                  |L35.42|
00002a  f7fffffe          BL       rt_hw_interrupt_disable
00002e  4607              MOV      r7,r0
000030  f7fffffe          BL       rt_interrupt_get_nest
000034  2800              CMP      r0,#0
000036  d008              BEQ      |L35.74|
000038  4933              LDR      r1,|L35.264|
00003a  a043              ADR      r0,|L35.328|
00003c  f7fffffe          BL       rt_kprintf
000040  462a              MOV      r2,r5
000042  4931              LDR      r1,|L35.264|
000044  a03f              ADR      r0,|L35.324|
000046  f7fffffe          BL       rt_assert_handler
                  |L35.74|
00004a  4638              MOV      r0,r7
00004c  f7fffffe          BL       rt_hw_interrupt_enable
000050  4630              MOV      r0,r6
000052  f7fffffe          BL       rt_hw_interrupt_enable
;;;649    
;;;650        RT_ASSERT(mutex != RT_NULL);
000056  2c00              CMP      r4,#0
000058  d104              BNE      |L35.100|
00005a  4a44              LDR      r2,|L35.364|
00005c  492a              LDR      r1,|L35.264|
00005e  a044              ADR      r0,|L35.368|
000060  f7fffffe          BL       rt_assert_handler
                  |L35.100|
;;;651    
;;;652        /* disable interrupt */
;;;653        temp = rt_hw_interrupt_disable();
000064  f7fffffe          BL       rt_hw_interrupt_disable
000068  4606              MOV      r6,r0
;;;654    
;;;655        /* get current thread */
;;;656        thread = rt_thread_self();
00006a  f7fffffe          BL       rt_thread_self
00006e  4605              MOV      r5,r0
;;;657    
;;;658        RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(mutex->parent.parent)));
;;;659    
;;;660        RT_DEBUG_LOG(RT_DEBUG_IPC,
;;;661                     ("mutex_take: current thread %s, mutex value: %d, hold: %d\n",
;;;662                      thread->name, mutex->value, mutex->hold));
;;;663    
;;;664        /* reset thread error */
;;;665        thread->error = RT_EOK;
000070  2000              MOVS     r0,#0
;;;666    
;;;667        if (mutex->owner == thread)
000072  6328              STR      r0,[r5,#0x30]
000074  6a20              LDR      r0,[r4,#0x20]
000076  42a8              CMP      r0,r5
000078  d103              BNE      |L35.130|
                  |L35.122|
;;;668        {
;;;669            /* it's the same thread */
;;;670            mutex->hold ++;
00007a  7fe0              LDRB     r0,[r4,#0x1f]
00007c  1c40              ADDS     r0,r0,#1
00007e  77e0              STRB     r0,[r4,#0x1f]
000080  e034              B        |L35.236|
                  |L35.130|
;;;671        }
;;;672        else
;;;673        {
;;;674            /* The value of mutex is 1 in initial status. Therefore, if the
;;;675             * value is great than 0, it indicates the mutex is avaible.
;;;676             */
;;;677            if (mutex->value > 0)
000082  8ba1              LDRH     r1,[r4,#0x1c]
000084  2900              CMP      r1,#0
000086  d006              BEQ      |L35.150|
000088  1e49              SUBS     r1,r1,#1
;;;678            {
;;;679                /* mutex is available */
;;;680                mutex->value --;
00008a  83a1              STRH     r1,[r4,#0x1c]
;;;681    
;;;682                /* set mutex owner and original priority */
;;;683                mutex->owner             = thread;
00008c  6225              STR      r5,[r4,#0x20]
00008e  3520              ADDS     r5,r5,#0x20
;;;684                mutex->original_priority = thread->current_priority;
000090  7d68              LDRB     r0,[r5,#0x15]
000092  77a0              STRB     r0,[r4,#0x1e]
;;;685                mutex->hold ++;
000094  e7f1              B        |L35.122|
                  |L35.150|
;;;686            }
;;;687            else
;;;688            {
;;;689                /* no waiting, return with timeout */
;;;690                if (time == 0)
000096  9902              LDR      r1,[sp,#8]
000098  2900              CMP      r1,#0
00009a  d02c              BEQ      |L35.246|
;;;691                {
;;;692                    /* set error as timeout */
;;;693                    thread->error = -RT_ETIMEOUT;
;;;694    
;;;695                    /* enable interrupt */
;;;696                    rt_hw_interrupt_enable(temp);
;;;697    
;;;698                    return -RT_ETIMEOUT;
;;;699                }
;;;700                else
;;;701                {
;;;702                    /* mutex is unavailable, push to suspend list */
;;;703                    RT_DEBUG_LOG(RT_DEBUG_IPC, ("mutex_take: suspend thread: %s\n",
;;;704                                                thread->name));
;;;705    
;;;706                    /* change the owner thread priority of mutex */
;;;707                    if (thread->current_priority < mutex->owner->current_priority)
00009c  2135              MOVS     r1,#0x35
00009e  5d4a              LDRB     r2,[r1,r5]
0000a0  5c09              LDRB     r1,[r1,r0]
0000a2  428a              CMP      r2,r1
0000a4  d204              BCS      |L35.176|
;;;708                    {
;;;709                        /* change the owner thread priority */
;;;710                        rt_thread_control(mutex->owner,
0000a6  462a              MOV      r2,r5
0000a8  3235              ADDS     r2,r2,#0x35
0000aa  2102              MOVS     r1,#2
0000ac  f7fffffe          BL       rt_thread_control
                  |L35.176|
;;;711                                          RT_THREAD_CTRL_CHANGE_PRIORITY,
;;;712                                          &thread->current_priority);
;;;713                    }
;;;714    
;;;715                    /* suspend current thread */
;;;716                    rt_ipc_list_suspend(&(mutex->parent.suspend_thread),
0000b0  4620              MOV      r0,r4
0000b2  7a62              LDRB     r2,[r4,#9]
0000b4  4629              MOV      r1,r5
0000b6  3014              ADDS     r0,r0,#0x14
0000b8  f7fffffe          BL       rt_ipc_list_suspend
;;;717                                        thread,
;;;718                                        mutex->parent.parent.flag);
;;;719    
;;;720                    /* has waiting time, start thread timer */
;;;721                    if (time > 0)
0000bc  9802              LDR      r0,[sp,#8]
0000be  2800              CMP      r0,#0
0000c0  dd09              BLE      |L35.214|
;;;722                    {
;;;723                        RT_DEBUG_LOG(RT_DEBUG_IPC,
;;;724                                     ("mutex_take: start the timer of thread:%s\n",
;;;725                                      thread->name));
;;;726    
;;;727                        /* reset the timeout of thread timer and start it */
;;;728                        rt_timer_control(&(thread->thread_timer),
0000c2  4628              MOV      r0,r5
0000c4  304c              ADDS     r0,r0,#0x4c
0000c6  aa02              ADD      r2,sp,#8
0000c8  2100              MOVS     r1,#0
0000ca  4604              MOV      r4,r0
0000cc  f7fffffe          BL       rt_timer_control
0000d0  4620              MOV      r0,r4
;;;729                                         RT_TIMER_CTRL_SET_TIME,
;;;730                                         &time);
;;;731                        rt_timer_start(&(thread->thread_timer));
0000d2  f7fffffe          BL       rt_timer_start
                  |L35.214|
;;;732                    }
;;;733    
;;;734                    /* enable interrupt */
;;;735                    rt_hw_interrupt_enable(temp);
0000d6  4630              MOV      r0,r6
0000d8  f7fffffe          BL       rt_hw_interrupt_enable
;;;736    
;;;737                    /* do schedule */
;;;738                    rt_schedule();
0000dc  f7fffffe          BL       rt_schedule
;;;739    
;;;740                    if (thread->error != RT_EOK)
0000e0  6b28              LDR      r0,[r5,#0x30]
0000e2  2800              CMP      r0,#0
0000e4  d106              BNE      |L35.244|
;;;741                    {
;;;742                        /* return error */
;;;743                        return thread->error;
;;;744                    }
;;;745                    else
;;;746                    {
;;;747                        /* the mutex is taken successfully. */
;;;748                        /* disable interrupt */
;;;749                        temp = rt_hw_interrupt_disable();
0000e6  f7fffffe          BL       rt_hw_interrupt_disable
0000ea  4606              MOV      r6,r0
                  |L35.236|
;;;750                    }
;;;751                }
;;;752            }
;;;753        }
;;;754    
;;;755        /* enable interrupt */
;;;756        rt_hw_interrupt_enable(temp);
0000ec  4630              MOV      r0,r6
0000ee  f7fffffe          BL       rt_hw_interrupt_enable
;;;757    
;;;758        RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mutex->parent.parent)));
;;;759    
;;;760        return RT_EOK;
0000f2  2000              MOVS     r0,#0
                  |L35.244|
;;;761    }
0000f4  bdfe              POP      {r1-r7,pc}
                  |L35.246|
0000f6  2401              MOVS     r4,#1                 ;693
0000f8  43e4              MVNS     r4,r4                 ;693
0000fa  4630              MOV      r0,r6                 ;696
0000fc  632c              STR      r4,[r5,#0x30]         ;696
0000fe  f7fffffe          BL       rt_hw_interrupt_enable
000102  4620              MOV      r0,r4                 ;698
000104  bdfe              POP      {r1-r7,pc}
;;;762    RTM_EXPORT(rt_mutex_take);
                          ENDP

000106  0000              DCW      0x0000
                  |L35.264|
                          DCD      ||.constdata||+0x8f
                  |L35.268|
00010c  46756e63          DCB      "Function[%s] shall not be used before scheduler start\n"
000110  74696f6e
000114  5b25735d
000118  20736861
00011c  6c6c206e
000120  6f742062
000124  65207573
000128  65642062
00012c  65666f72
000130  65207363
000134  68656475
000138  6c657220
00013c  73746172
000140  740a    
000142  00                DCB      0
000143  00                DCB      0
                  |L35.324|
000144  3000              DCB      "0",0
000146  00                DCB      0
000147  00                DCB      0
                  |L35.328|
000148  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
00014c  74696f6e
000150  5b25735d
000154  20736861
000158  6c6c206e
00015c  6f742075
000160  73656420
000164  696e2049
000168  53520a00
                  |L35.364|
                          DCD      0x0000028a
                  |L35.368|
000170  6d757465          DCB      "mutex != RT_NULL",0
000174  7820213d
000178  2052545f
00017c  4e554c4c
000180  00      
000181  00                DCB      0
000182  00                DCB      0
000183  00                DCB      0

                          AREA ||i.rt_sem_control||, CODE, READONLY, ALIGN=2

                  rt_sem_control PROC
;;;480     */
;;;481    rt_err_t rt_sem_control(rt_sem_t sem, rt_uint8_t cmd, void *arg)
000000  b570              PUSH     {r4-r6,lr}
;;;482    {
000002  4615              MOV      r5,r2
000004  460e              MOV      r6,r1
000006  0004              MOVS     r4,r0
000008  d105              BNE      |L36.22|
;;;483        rt_ubase_t level;
;;;484        RT_ASSERT(sem != RT_NULL);
00000a  22ff              MOVS     r2,#0xff
00000c  32e5              ADDS     r2,r2,#0xe5
00000e  490c              LDR      r1,|L36.64|
000010  a00c              ADR      r0,|L36.68|
000012  f7fffffe          BL       rt_assert_handler
                  |L36.22|
;;;485    
;;;486        if (cmd == RT_IPC_CMD_RESET)
000016  2e01              CMP      r6,#1
000018  d002              BEQ      |L36.32|
;;;487        {
;;;488            rt_uint32_t value;
;;;489    
;;;490            /* get value */
;;;491            value = (rt_uint32_t)arg;
;;;492            /* disable interrupt */
;;;493            level = rt_hw_interrupt_disable();
;;;494    
;;;495            /* resume all waiting thread */
;;;496            rt_ipc_list_resume_all(&sem->parent.suspend_thread);
;;;497    
;;;498            /* set new value */
;;;499            sem->value = (rt_uint16_t)value;
;;;500    
;;;501            /* enable interrupt */
;;;502            rt_hw_interrupt_enable(level);
;;;503    
;;;504            rt_schedule();
;;;505    
;;;506            return RT_EOK;
;;;507        }
;;;508    
;;;509        return -RT_ERROR;
00001a  2000              MOVS     r0,#0
00001c  43c0              MVNS     r0,r0
;;;510    }
00001e  bd70              POP      {r4-r6,pc}
                  |L36.32|
000020  f7fffffe          BL       rt_hw_interrupt_disable
000024  4606              MOV      r6,r0                 ;493
000026  4620              MOV      r0,r4                 ;496
000028  3014              ADDS     r0,r0,#0x14           ;496
00002a  f7fffffe          BL       rt_ipc_list_resume_all
00002e  83a5              STRH     r5,[r4,#0x1c]         ;499
000030  4630              MOV      r0,r6                 ;502
000032  f7fffffe          BL       rt_hw_interrupt_enable
000036  f7fffffe          BL       rt_schedule
00003a  2000              MOVS     r0,#0                 ;506
00003c  bd70              POP      {r4-r6,pc}
;;;511    RTM_EXPORT(rt_sem_control);
                          ENDP

00003e  0000              DCW      0x0000
                  |L36.64|
                          DCD      ||.constdata||+0x42
                  |L36.68|
000044  73656d20          DCB      "sem != RT_NULL",0
000048  213d2052
00004c  545f4e55
000050  4c4c00  
000053  00                DCB      0

                          AREA ||i.rt_sem_create||, CODE, READONLY, ALIGN=2

                  rt_sem_create PROC
;;;268     */
;;;269    rt_sem_t rt_sem_create(const char *name, rt_uint32_t value, rt_uint8_t flag)
000000  b5f8              PUSH     {r3-r7,lr}
;;;270    {
000002  4615              MOV      r5,r2
000004  460c              MOV      r4,r1
000006  4606              MOV      r6,r0
;;;271        rt_sem_t sem;
;;;272    
;;;273        RT_DEBUG_NOT_IN_INTERRUPT;
000008  f7fffffe          BL       rt_hw_interrupt_disable
00000c  4607              MOV      r7,r0
00000e  f7fffffe          BL       rt_interrupt_get_nest
000012  2800              CMP      r0,#0
000014  d009              BEQ      |L37.42|
000016  490d              LDR      r1,|L37.76|
000018  a00d              ADR      r0,|L37.80|
00001a  f7fffffe          BL       rt_kprintf
00001e  22ff              MOVS     r2,#0xff
000020  3212              ADDS     r2,r2,#0x12
000022  490a              LDR      r1,|L37.76|
000024  a013              ADR      r0,|L37.116|
000026  f7fffffe          BL       rt_assert_handler
                  |L37.42|
00002a  4638              MOV      r0,r7
00002c  f7fffffe          BL       rt_hw_interrupt_enable
;;;274    
;;;275        /* allocate object */
;;;276        sem = (rt_sem_t)rt_object_allocate(RT_Object_Class_Semaphore, name);
000030  4631              MOV      r1,r6
000032  2001              MOVS     r0,#1
000034  f7fffffe          BL       rt_object_allocate
;;;277        if (sem == RT_NULL)
000038  2800              CMP      r0,#0
00003a  d005              BEQ      |L37.72|
00003c  4601              MOV      r1,r0
00003e  3114              ADDS     r1,r1,#0x14
000040  6181              STR      r1,[r0,#0x18]
;;;278            return sem;
;;;279    
;;;280        /* init ipc object */
;;;281        rt_ipc_object_init(&(sem->parent));
;;;282    
;;;283        /* set init value */
;;;284        sem->value = value;
000042  6141              STR      r1,[r0,#0x14]
000044  8384              STRH     r4,[r0,#0x1c]
;;;285    
;;;286        /* set parent */
;;;287        sem->parent.parent.flag = flag;
000046  7245              STRB     r5,[r0,#9]
                  |L37.72|
;;;288    
;;;289        return sem;
;;;290    }
000048  bdf8              POP      {r3-r7,pc}
;;;291    RTM_EXPORT(rt_sem_create);
                          ENDP

00004a  0000              DCW      0x0000
                  |L37.76|
                          DCD      ||.constdata||+0x1a
                  |L37.80|
000050  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
000054  74696f6e
000058  5b25735d
00005c  20736861
000060  6c6c206e
000064  6f742075
000068  73656420
00006c  696e2049
000070  53520a00
                  |L37.116|
000074  3000              DCB      "0",0
000076  00                DCB      0
000077  00                DCB      0

                          AREA ||i.rt_sem_delete||, CODE, READONLY, ALIGN=2

                  rt_sem_delete PROC
;;;301     */
;;;302    rt_err_t rt_sem_delete(rt_sem_t sem)
000000  b570              PUSH     {r4-r6,lr}
;;;303    {
000002  4604              MOV      r4,r0
;;;304        RT_DEBUG_NOT_IN_INTERRUPT;
000004  f7fffffe          BL       rt_hw_interrupt_disable
000008  4605              MOV      r5,r0
00000a  f7fffffe          BL       rt_interrupt_get_nest
00000e  2800              CMP      r0,#0
000010  d009              BEQ      |L38.38|
000012  490f              LDR      r1,|L38.80|
000014  a00f              ADR      r0,|L38.84|
000016  f7fffffe          BL       rt_kprintf
00001a  22ff              MOVS     r2,#0xff
00001c  3231              ADDS     r2,r2,#0x31
00001e  490c              LDR      r1,|L38.80|
000020  a015              ADR      r0,|L38.120|
000022  f7fffffe          BL       rt_assert_handler
                  |L38.38|
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       rt_hw_interrupt_enable
;;;305    
;;;306        RT_ASSERT(sem != RT_NULL);
00002c  2c00              CMP      r4,#0
00002e  d105              BNE      |L38.60|
000030  22ff              MOVS     r2,#0xff
000032  3233              ADDS     r2,r2,#0x33
000034  4906              LDR      r1,|L38.80|
000036  a011              ADR      r0,|L38.124|
000038  f7fffffe          BL       rt_assert_handler
                  |L38.60|
;;;307    
;;;308        /* wakeup all suspend threads */
;;;309        rt_ipc_list_resume_all(&(sem->parent.suspend_thread));
00003c  4620              MOV      r0,r4
00003e  3014              ADDS     r0,r0,#0x14
000040  f7fffffe          BL       rt_ipc_list_resume_all
;;;310    
;;;311        /* delete semaphore object */
;;;312        rt_object_delete(&(sem->parent.parent));
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       rt_object_delete
;;;313    
;;;314        return RT_EOK;
00004a  2000              MOVS     r0,#0
;;;315    }
00004c  bd70              POP      {r4-r6,pc}
;;;316    RTM_EXPORT(rt_sem_delete);
                          ENDP

00004e  0000              DCW      0x0000
                  |L38.80|
                          DCD      ||.constdata||+0x28
                  |L38.84|
000054  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
000058  74696f6e
00005c  5b25735d
000060  20736861
000064  6c6c206e
000068  6f742075
00006c  73656420
000070  696e2049
000074  53520a00
                  |L38.120|
000078  3000              DCB      "0",0
00007a  00                DCB      0
00007b  00                DCB      0
                  |L38.124|
00007c  73656d20          DCB      "sem != RT_NULL",0
000080  213d2052
000084  545f4e55
000088  4c4c00  
00008b  00                DCB      0

                          AREA ||i.rt_sem_detach||, CODE, READONLY, ALIGN=2

                  rt_sem_detach PROC
;;;242     */
;;;243    rt_err_t rt_sem_detach(rt_sem_t sem)
000000  b510              PUSH     {r4,lr}
;;;244    {
000002  0004              MOVS     r4,r0
000004  d104              BNE      |L39.16|
;;;245        RT_ASSERT(sem != RT_NULL);
000006  22f5              MOVS     r2,#0xf5
000008  4906              LDR      r1,|L39.36|
00000a  a007              ADR      r0,|L39.40|
00000c  f7fffffe          BL       rt_assert_handler
                  |L39.16|
;;;246    
;;;247        /* wakeup all suspend threads */
;;;248        rt_ipc_list_resume_all(&(sem->parent.suspend_thread));
000010  4620              MOV      r0,r4
000012  3014              ADDS     r0,r0,#0x14
000014  f7fffffe          BL       rt_ipc_list_resume_all
;;;249    
;;;250        /* detach semaphore object */
;;;251        rt_object_detach(&(sem->parent.parent));
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       rt_object_detach
;;;252    
;;;253        return RT_EOK;
00001e  2000              MOVS     r0,#0
;;;254    }
000020  bd10              POP      {r4,pc}
;;;255    RTM_EXPORT(rt_sem_detach);
                          ENDP

000022  0000              DCW      0x0000
                  |L39.36|
                          DCD      ||.constdata||+0xc
                  |L39.40|
000028  73656d20          DCB      "sem != RT_NULL",0
00002c  213d2052
000030  545f4e55
000034  4c4c00  
000037  00                DCB      0

                          AREA ||i.rt_sem_init||, CODE, READONLY, ALIGN=2

                  rt_sem_init PROC
;;;210     */
;;;211    rt_err_t rt_sem_init(rt_sem_t    sem,
000000  b5f8              PUSH     {r3-r7,lr}
;;;212                         const char *name,
;;;213                         rt_uint32_t value,
;;;214                         rt_uint8_t  flag)
;;;215    {
000002  461e              MOV      r6,r3
000004  4615              MOV      r5,r2
000006  460f              MOV      r7,r1
000008  0004              MOVS     r4,r0
00000a  d104              BNE      |L40.22|
;;;216        RT_ASSERT(sem != RT_NULL);
00000c  22d8              MOVS     r2,#0xd8
00000e  4908              LDR      r1,|L40.48|
000010  a008              ADR      r0,|L40.52|
000012  f7fffffe          BL       rt_assert_handler
                  |L40.22|
;;;217    
;;;218        /* init object */
;;;219        rt_object_init(&(sem->parent.parent), RT_Object_Class_Semaphore, name);
000016  463a              MOV      r2,r7
000018  2101              MOVS     r1,#1
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       rt_object_init
000020  4620              MOV      r0,r4
000022  3014              ADDS     r0,r0,#0x14
000024  61a0              STR      r0,[r4,#0x18]
;;;220    
;;;221        /* init ipc object */
;;;222        rt_ipc_object_init(&(sem->parent));
;;;223    
;;;224        /* set init value */
;;;225        sem->value = value;
000026  6160              STR      r0,[r4,#0x14]
000028  83a5              STRH     r5,[r4,#0x1c]
;;;226    
;;;227        /* set parent */
;;;228        sem->parent.parent.flag = flag;
00002a  7266              STRB     r6,[r4,#9]
;;;229    
;;;230        return RT_EOK;
00002c  2000              MOVS     r0,#0
;;;231    }
00002e  bdf8              POP      {r3-r7,pc}
;;;232    RTM_EXPORT(rt_sem_init);
                          ENDP

                  |L40.48|
                          DCD      ||.constdata||
                  |L40.52|
000034  73656d20          DCB      "sem != RT_NULL",0
000038  213d2052
00003c  545f4e55
000040  4c4c00  
000043  00                DCB      0

                          AREA ||i.rt_sem_release||, CODE, READONLY, ALIGN=1

                  rt_sem_release PROC
;;;434     */
;;;435    rt_err_t rt_sem_release(rt_sem_t sem)
000000  b5f8              PUSH     {r3-r7,lr}
;;;436    {
000002  4604              MOV      r4,r0
;;;437        register rt_base_t temp;
;;;438        register rt_bool_t need_schedule;
;;;439    
;;;440        RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(sem->parent.parent)));
;;;441    
;;;442        need_schedule = RT_FALSE;
000004  2500              MOVS     r5,#0
;;;443    
;;;444        /* disable interrupt */
;;;445        temp = rt_hw_interrupt_disable();
000006  f7fffffe          BL       rt_hw_interrupt_disable
00000a  4606              MOV      r6,r0
;;;446    
;;;447        RT_DEBUG_LOG(RT_DEBUG_IPC, ("thread %s releases sem:%s, which value is: %d\n",
;;;448                                    rt_thread_self()->name,
;;;449                                    ((struct rt_object *)sem)->name,
;;;450                                    sem->value));
;;;451    
;;;452        if (!rt_list_isempty(&sem->parent.suspend_thread))
00000c  4620              MOV      r0,r4
00000e  3014              ADDS     r0,r0,#0x14
000010  4607              MOV      r7,r0
000012  f7fffffe          BL       rt_list_isempty
000016  2800              CMP      r0,#0
000018  d00b              BEQ      |L41.50|
;;;453        {
;;;454            /* resume the suspended thread */
;;;455            rt_ipc_list_resume(&(sem->parent.suspend_thread));
;;;456            need_schedule = RT_TRUE;
;;;457        }
;;;458        else
;;;459            sem->value ++; /* increase value */
00001a  8ba0              LDRH     r0,[r4,#0x1c]
00001c  1c40              ADDS     r0,r0,#1
00001e  83a0              STRH     r0,[r4,#0x1c]
                  |L41.32|
;;;460    
;;;461        /* enable interrupt */
;;;462        rt_hw_interrupt_enable(temp);
000020  4630              MOV      r0,r6
000022  f7fffffe          BL       rt_hw_interrupt_enable
;;;463    
;;;464        /* resume a thread, re-schedule */
;;;465        if (need_schedule == RT_TRUE)
000026  2d00              CMP      r5,#0
000028  d001              BEQ      |L41.46|
;;;466            rt_schedule();
00002a  f7fffffe          BL       rt_schedule
                  |L41.46|
;;;467    
;;;468        return RT_EOK;
00002e  2000              MOVS     r0,#0
;;;469    }
000030  bdf8              POP      {r3-r7,pc}
                  |L41.50|
000032  4638              MOV      r0,r7
000034  f7fffffe          BL       rt_ipc_list_resume
000038  2501              MOVS     r5,#1                 ;456
00003a  e7f1              B        |L41.32|
;;;470    RTM_EXPORT(rt_sem_release);
                          ENDP


                          AREA ||i.rt_sem_take||, CODE, READONLY, ALIGN=2

                  rt_sem_take PROC
;;;327     */
;;;328    rt_err_t rt_sem_take(rt_sem_t sem, rt_int32_t time)
000000  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;329    {
000002  b081              SUB      sp,sp,#4
000004  0004              MOVS     r4,r0
000006  d105              BNE      |L42.20|
;;;330        register rt_base_t temp;
;;;331        struct rt_thread *thread;
;;;332    
;;;333        RT_ASSERT(sem != RT_NULL);
000008  22ff              MOVS     r2,#0xff
00000a  324e              ADDS     r2,r2,#0x4e
00000c  4931              LDR      r1,|L42.212|
00000e  a032              ADR      r0,|L42.216|
000010  f7fffffe          BL       rt_assert_handler
                  |L42.20|
;;;334    
;;;335        RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(sem->parent.parent)));
;;;336    
;;;337        /* disable interrupt */
;;;338        temp = rt_hw_interrupt_disable();
000014  f7fffffe          BL       rt_hw_interrupt_disable
000018  4606              MOV      r6,r0
;;;339    
;;;340        RT_DEBUG_LOG(RT_DEBUG_IPC, ("thread %s take sem:%s, which value is: %d\n",
;;;341                                    rt_thread_self()->name,
;;;342                                    ((struct rt_object *)sem)->name,
;;;343                                    sem->value));
;;;344    
;;;345        if (sem->value > 0)
00001a  8ba0              LDRH     r0,[r4,#0x1c]
00001c  2800              CMP      r0,#0
00001e  d005              BEQ      |L42.44|
000020  1e40              SUBS     r0,r0,#1
;;;346        {
;;;347            /* semaphore is available */
;;;348            sem->value --;
000022  83a0              STRH     r0,[r4,#0x1c]
;;;349    
;;;350            /* enable interrupt */
;;;351            rt_hw_interrupt_enable(temp);
000024  4630              MOV      r0,r6
000026  f7fffffe          BL       rt_hw_interrupt_enable
00002a  e051              B        |L42.208|
                  |L42.44|
;;;352        }
;;;353        else
;;;354        {
;;;355            /* no waiting, return with timeout */
;;;356            if (time == 0)
00002c  9802              LDR      r0,[sp,#8]
00002e  2800              CMP      r0,#0
000030  d009              BEQ      |L42.70|
;;;357            {
;;;358                rt_hw_interrupt_enable(temp);
;;;359    
;;;360                return -RT_ETIMEOUT;
;;;361            }
;;;362            else
;;;363            {
;;;364                /* current context checking */
;;;365                RT_DEBUG_IN_THREAD_CONTEXT;
000032  f7fffffe          BL       rt_hw_interrupt_disable
000036  9000              STR      r0,[sp,#0]
000038  f7fffffe          BL       rt_thread_self
00003c  25ff              MOVS     r5,#0xff
00003e  356e              ADDS     r5,r5,#0x6e
000040  2800              CMP      r0,#0
000042  d006              BEQ      |L42.82|
000044  e00e              B        |L42.100|
                  |L42.70|
000046  4630              MOV      r0,r6                 ;358
000048  f7fffffe          BL       rt_hw_interrupt_enable
00004c  2001              MOVS     r0,#1                 ;360
00004e  43c0              MVNS     r0,r0                 ;360
                  |L42.80|
;;;366    
;;;367                /* semaphore is unavailable, push to suspend list */
;;;368                /* get current thread */
;;;369                thread = rt_thread_self();
;;;370    
;;;371                /* reset thread error number */
;;;372                thread->error = RT_EOK;
;;;373    
;;;374                RT_DEBUG_LOG(RT_DEBUG_IPC, ("sem take: suspend thread - %s\n",
;;;375                                            thread->name));
;;;376    
;;;377                /* suspend thread */
;;;378                rt_ipc_list_suspend(&(sem->parent.suspend_thread),
;;;379                                    thread,
;;;380                                    sem->parent.parent.flag);
;;;381    
;;;382                /* has waiting time, start thread timer */
;;;383                if (time > 0)
;;;384                {
;;;385                    RT_DEBUG_LOG(RT_DEBUG_IPC, ("set thread:%s to timer list\n",
;;;386                                                thread->name));
;;;387    
;;;388                    /* reset the timeout of thread timer and start it */
;;;389                    rt_timer_control(&(thread->thread_timer),
;;;390                                     RT_TIMER_CTRL_SET_TIME,
;;;391                                     &time);
;;;392                    rt_timer_start(&(thread->thread_timer));
;;;393                }
;;;394    
;;;395                /* enable interrupt */
;;;396                rt_hw_interrupt_enable(temp);
;;;397    
;;;398                /* do schedule */
;;;399                rt_schedule();
;;;400    
;;;401                if (thread->error != RT_EOK)
;;;402                {
;;;403                    return thread->error;
;;;404                }
;;;405            }
;;;406        }
;;;407    
;;;408        RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(sem->parent.parent)));
;;;409    
;;;410        return RT_EOK;
;;;411    }
000050  bdfe              POP      {r1-r7,pc}
                  |L42.82|
000052  4920              LDR      r1,|L42.212|
000054  a024              ADR      r0,|L42.232|
000056  f7fffffe          BL       rt_kprintf
00005a  462a              MOV      r2,r5                 ;365
00005c  491d              LDR      r1,|L42.212|
00005e  a030              ADR      r0,|L42.288|
000060  f7fffffe          BL       rt_assert_handler
                  |L42.100|
000064  f7fffffe          BL       rt_hw_interrupt_disable
000068  4607              MOV      r7,r0                 ;365
00006a  f7fffffe          BL       rt_interrupt_get_nest
00006e  2800              CMP      r0,#0                 ;365
000070  d008              BEQ      |L42.132|
000072  4918              LDR      r1,|L42.212|
000074  a02b              ADR      r0,|L42.292|
000076  f7fffffe          BL       rt_kprintf
00007a  462a              MOV      r2,r5                 ;365
00007c  4915              LDR      r1,|L42.212|
00007e  a028              ADR      r0,|L42.288|
000080  f7fffffe          BL       rt_assert_handler
                  |L42.132|
000084  4638              MOV      r0,r7                 ;365
000086  f7fffffe          BL       rt_hw_interrupt_enable
00008a  9800              LDR      r0,[sp,#0]            ;365
00008c  f7fffffe          BL       rt_hw_interrupt_enable
000090  f7fffffe          BL       rt_thread_self
000094  4605              MOV      r5,r0                 ;369
000096  2000              MOVS     r0,#0                 ;372
000098  6328              STR      r0,[r5,#0x30]         ;378
00009a  4620              MOV      r0,r4                 ;378
00009c  7a62              LDRB     r2,[r4,#9]            ;378
00009e  4629              MOV      r1,r5                 ;378
0000a0  3014              ADDS     r0,r0,#0x14           ;378
0000a2  f7fffffe          BL       rt_ipc_list_suspend
0000a6  9802              LDR      r0,[sp,#8]            ;383
0000a8  2800              CMP      r0,#0                 ;383
0000aa  dd09              BLE      |L42.192|
0000ac  4628              MOV      r0,r5                 ;389
0000ae  304c              ADDS     r0,r0,#0x4c           ;389
0000b0  aa02              ADD      r2,sp,#8              ;389
0000b2  2100              MOVS     r1,#0                 ;389
0000b4  4604              MOV      r4,r0                 ;389
0000b6  f7fffffe          BL       rt_timer_control
0000ba  4620              MOV      r0,r4                 ;389
0000bc  f7fffffe          BL       rt_timer_start
                  |L42.192|
0000c0  4630              MOV      r0,r6                 ;396
0000c2  f7fffffe          BL       rt_hw_interrupt_enable
0000c6  f7fffffe          BL       rt_schedule
0000ca  6b28              LDR      r0,[r5,#0x30]         ;401
0000cc  2800              CMP      r0,#0                 ;401
0000ce  d1bf              BNE      |L42.80|
                  |L42.208|
0000d0  2000              MOVS     r0,#0                 ;410
0000d2  bdfe              POP      {r1-r7,pc}
;;;412    RTM_EXPORT(rt_sem_take);
                          ENDP

                  |L42.212|
                          DCD      ||.constdata||+0x36
                  |L42.216|
0000d8  73656d20          DCB      "sem != RT_NULL",0
0000dc  213d2052
0000e0  545f4e55
0000e4  4c4c00  
0000e7  00                DCB      0
                  |L42.232|
0000e8  46756e63          DCB      "Function[%s] shall not be used before scheduler start\n"
0000ec  74696f6e
0000f0  5b25735d
0000f4  20736861
0000f8  6c6c206e
0000fc  6f742062
000100  65207573
000104  65642062
000108  65666f72
00010c  65207363
000110  68656475
000114  6c657220
000118  73746172
00011c  740a    
00011e  00                DCB      0
00011f  00                DCB      0
                  |L42.288|
000120  3000              DCB      "0",0
000122  00                DCB      0
000123  00                DCB      0
                  |L42.292|
000124  46756e63          DCB      "Function[%s] shall not used in ISR\n",0
000128  74696f6e
00012c  5b25735d
000130  20736861
000134  6c6c206e
000138  6f742075
00013c  73656420
000140  696e2049
000144  53520a00

                          AREA ||i.rt_sem_trytake||, CODE, READONLY, ALIGN=1

                  rt_sem_trytake PROC
;;;420     */
;;;421    rt_err_t rt_sem_trytake(rt_sem_t sem)
000000  b510              PUSH     {r4,lr}
;;;422    {
;;;423        return rt_sem_take(sem, 0);
000002  2100              MOVS     r1,#0
000004  f7fffffe          BL       rt_sem_take
;;;424    }
000008  bd10              POP      {r4,pc}
;;;425    RTM_EXPORT(rt_sem_trytake);
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  72745f73          DCB      0x72,0x74,0x5f,0x73
000004  656d5f69          DCB      0x65,0x6d,0x5f,0x69
000008  6e697400          DCB      0x6e,0x69,0x74,0x00
                  |symbol_number.125|
00000c  72745f73          DCB      0x72,0x74,0x5f,0x73
000010  656d5f64          DCB      0x65,0x6d,0x5f,0x64
000014  65746163          DCB      0x65,0x74,0x61,0x63
000018  6800              DCB      0x68,0x00
                  |symbol_number.126|
00001a  7274              DCB      0x72,0x74
00001c  5f73656d          DCB      0x5f,0x73,0x65,0x6d
000020  5f637265          DCB      0x5f,0x63,0x72,0x65
000024  61746500          DCB      0x61,0x74,0x65,0x00
                  |symbol_number.127|
000028  72745f73          DCB      0x72,0x74,0x5f,0x73
00002c  656d5f64          DCB      0x65,0x6d,0x5f,0x64
000030  656c6574          DCB      0x65,0x6c,0x65,0x74
000034  6500              DCB      0x65,0x00
                  |symbol_number.128|
000036  7274              DCB      0x72,0x74
000038  5f73656d          DCB      0x5f,0x73,0x65,0x6d
00003c  5f74616b          DCB      0x5f,0x74,0x61,0x6b
000040  6500              DCB      0x65,0x00
                  |symbol_number.129|
000042  7274              DCB      0x72,0x74
000044  5f73656d          DCB      0x5f,0x73,0x65,0x6d
000048  5f636f6e          DCB      0x5f,0x63,0x6f,0x6e
00004c  74726f6c          DCB      0x74,0x72,0x6f,0x6c
000050  00                DCB      0x00
                  |symbol_number.130|
000051  72745f            DCB      0x72,0x74,0x5f
000054  6d757465          DCB      0x6d,0x75,0x74,0x65
000058  785f696e          DCB      0x78,0x5f,0x69,0x6e
00005c  697400            DCB      0x69,0x74,0x00
                  |symbol_number.131|
00005f  72                DCB      0x72
000060  745f6d75          DCB      0x74,0x5f,0x6d,0x75
000064  7465785f          DCB      0x74,0x65,0x78,0x5f
000068  64657461          DCB      0x64,0x65,0x74,0x61
00006c  636800            DCB      0x63,0x68,0x00
                  |symbol_number.132|
00006f  72                DCB      0x72
000070  745f6d75          DCB      0x74,0x5f,0x6d,0x75
000074  7465785f          DCB      0x74,0x65,0x78,0x5f
000078  63726561          DCB      0x63,0x72,0x65,0x61
00007c  746500            DCB      0x74,0x65,0x00
                  |symbol_number.133|
00007f  72                DCB      0x72
000080  745f6d75          DCB      0x74,0x5f,0x6d,0x75
000084  7465785f          DCB      0x74,0x65,0x78,0x5f
000088  64656c65          DCB      0x64,0x65,0x6c,0x65
00008c  746500            DCB      0x74,0x65,0x00
                  |symbol_number.134|
00008f  72                DCB      0x72
000090  745f6d75          DCB      0x74,0x5f,0x6d,0x75
000094  7465785f          DCB      0x74,0x65,0x78,0x5f
000098  74616b65          DCB      0x74,0x61,0x6b,0x65
00009c  00                DCB      0x00
                  |symbol_number.135|
00009d  72745f            DCB      0x72,0x74,0x5f
0000a0  6d757465          DCB      0x6d,0x75,0x74,0x65
0000a4  785f7265          DCB      0x78,0x5f,0x72,0x65
0000a8  6c656173          DCB      0x6c,0x65,0x61,0x73
0000ac  6500              DCB      0x65,0x00
                  |symbol_number.136|
0000ae  7274              DCB      0x72,0x74
0000b0  5f657665          DCB      0x5f,0x65,0x76,0x65
0000b4  6e745f69          DCB      0x6e,0x74,0x5f,0x69
0000b8  6e697400          DCB      0x6e,0x69,0x74,0x00
                  |symbol_number.137|
0000bc  72745f65          DCB      0x72,0x74,0x5f,0x65
0000c0  76656e74          DCB      0x76,0x65,0x6e,0x74
0000c4  5f646574          DCB      0x5f,0x64,0x65,0x74
0000c8  61636800          DCB      0x61,0x63,0x68,0x00
                  |symbol_number.138|
0000cc  72745f65          DCB      0x72,0x74,0x5f,0x65
0000d0  76656e74          DCB      0x76,0x65,0x6e,0x74
0000d4  5f637265          DCB      0x5f,0x63,0x72,0x65
0000d8  61746500          DCB      0x61,0x74,0x65,0x00
                  |symbol_number.139|
0000dc  72745f65          DCB      0x72,0x74,0x5f,0x65
0000e0  76656e74          DCB      0x76,0x65,0x6e,0x74
0000e4  5f64656c          DCB      0x5f,0x64,0x65,0x6c
0000e8  65746500          DCB      0x65,0x74,0x65,0x00
                  |symbol_number.140|
0000ec  72745f65          DCB      0x72,0x74,0x5f,0x65
0000f0  76656e74          DCB      0x76,0x65,0x6e,0x74
0000f4  5f73656e          DCB      0x5f,0x73,0x65,0x6e
0000f8  6400              DCB      0x64,0x00
                  |symbol_number.141|
0000fa  7274              DCB      0x72,0x74
0000fc  5f657665          DCB      0x5f,0x65,0x76,0x65
000100  6e745f72          DCB      0x6e,0x74,0x5f,0x72
000104  65637600          DCB      0x65,0x63,0x76,0x00
                  |symbol_number.142|
000108  72745f65          DCB      0x72,0x74,0x5f,0x65
00010c  76656e74          DCB      0x76,0x65,0x6e,0x74
000110  5f636f6e          DCB      0x5f,0x63,0x6f,0x6e
000114  74726f6c          DCB      0x74,0x72,0x6f,0x6c
000118  00                DCB      0x00
                  |symbol_number.143|
000119  72745f            DCB      0x72,0x74,0x5f
00011c  6d625f69          DCB      0x6d,0x62,0x5f,0x69
000120  6e697400          DCB      0x6e,0x69,0x74,0x00
                  |symbol_number.144|
000124  72745f6d          DCB      0x72,0x74,0x5f,0x6d
000128  625f6465          DCB      0x62,0x5f,0x64,0x65
00012c  74616368          DCB      0x74,0x61,0x63,0x68
000130  00                DCB      0x00
                  |symbol_number.145|
000131  72745f            DCB      0x72,0x74,0x5f
000134  6d625f63          DCB      0x6d,0x62,0x5f,0x63
000138  72656174          DCB      0x72,0x65,0x61,0x74
00013c  6500              DCB      0x65,0x00
                  |symbol_number.146|
00013e  7274              DCB      0x72,0x74
000140  5f6d625f          DCB      0x5f,0x6d,0x62,0x5f
000144  64656c65          DCB      0x64,0x65,0x6c,0x65
000148  746500            DCB      0x74,0x65,0x00
                  |symbol_number.147|
00014b  72                DCB      0x72
00014c  745f6d62          DCB      0x74,0x5f,0x6d,0x62
000150  5f73656e          DCB      0x5f,0x73,0x65,0x6e
000154  645f7761          DCB      0x64,0x5f,0x77,0x61
000158  697400            DCB      0x69,0x74,0x00
                  |symbol_number.148|
00015b  72                DCB      0x72
00015c  745f6d62          DCB      0x74,0x5f,0x6d,0x62
000160  5f726563          DCB      0x5f,0x72,0x65,0x63
000164  7600              DCB      0x76,0x00
                  |symbol_number.149|
000166  7274              DCB      0x72,0x74
000168  5f6d625f          DCB      0x5f,0x6d,0x62,0x5f
00016c  636f6e74          DCB      0x63,0x6f,0x6e,0x74
000170  726f6c00          DCB      0x72,0x6f,0x6c,0x00
                  |symbol_number.150|
000174  72745f6d          DCB      0x72,0x74,0x5f,0x6d
000178  715f696e          DCB      0x71,0x5f,0x69,0x6e
00017c  697400            DCB      0x69,0x74,0x00
                  |symbol_number.151|
00017f  72                DCB      0x72
000180  745f6d71          DCB      0x74,0x5f,0x6d,0x71
000184  5f646574          DCB      0x5f,0x64,0x65,0x74
000188  61636800          DCB      0x61,0x63,0x68,0x00
                  |symbol_number.152|
00018c  72745f6d          DCB      0x72,0x74,0x5f,0x6d
000190  715f6372          DCB      0x71,0x5f,0x63,0x72
000194  65617465          DCB      0x65,0x61,0x74,0x65
000198  00                DCB      0x00
                  |symbol_number.153|
000199  72745f            DCB      0x72,0x74,0x5f
00019c  6d715f64          DCB      0x6d,0x71,0x5f,0x64
0001a0  656c6574          DCB      0x65,0x6c,0x65,0x74
0001a4  6500              DCB      0x65,0x00
                  |symbol_number.154|
0001a6  7274              DCB      0x72,0x74
0001a8  5f6d715f          DCB      0x5f,0x6d,0x71,0x5f
0001ac  73656e64          DCB      0x73,0x65,0x6e,0x64
0001b0  00                DCB      0x00
                  |symbol_number.155|
0001b1  72745f            DCB      0x72,0x74,0x5f
0001b4  6d715f75          DCB      0x6d,0x71,0x5f,0x75
0001b8  7267656e          DCB      0x72,0x67,0x65,0x6e
0001bc  7400              DCB      0x74,0x00
                  |symbol_number.156|
0001be  7274              DCB      0x72,0x74
0001c0  5f6d715f          DCB      0x5f,0x6d,0x71,0x5f
0001c4  72656376          DCB      0x72,0x65,0x63,0x76
0001c8  00                DCB      0x00
                  |symbol_number.157|
0001c9  72745f            DCB      0x72,0x74,0x5f
0001cc  6d715f63          DCB      0x6d,0x71,0x5f,0x63
0001d0  6f6e7472          DCB      0x6f,0x6e,0x74,0x72
0001d4  6f6c00            DCB      0x6f,0x6c,0x00
