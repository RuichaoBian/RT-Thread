; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\device.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\device.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I.\Libraries\Device\Nuvoton -I..\..\components\finsh -I.\Libraries\CMSIS\Include -I.\Libraries\StdDriver\inc -I..\..\include -I.\APP -I.\Drivers -I..\..\components\drivers\include -I..\..\components\drivers\include\drivers -I..\nuvoton_nuc240 -I.\Libraries\Device\Nuvoton\NUC230_240\Include -I..\..\include -I..\..\components\drivers\usb\usbdevice\class -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=521 -DRT_DEBUG --omf_browse=.\objects\device.crf ..\..\src\device.c]
                          THUMB

                          AREA ||i.rt_device_close||, CODE, READONLY, ALIGN=2

                  rt_device_close PROC
;;;238     */
;;;239    rt_err_t rt_device_close(rt_device_t dev)
000000  b570              PUSH     {r4-r6,lr}
;;;240    {
;;;241        rt_err_t result = RT_EOK;
000002  2500              MOVS     r5,#0
000004  4604              MOV      r4,r0                 ;240
;;;242    
;;;243        RT_ASSERT(dev != RT_NULL);
000006  2800              CMP      r0,#0
000008  d104              BNE      |L1.20|
00000a  22f3              MOVS     r2,#0xf3
00000c  490e              LDR      r1,|L1.72|
00000e  a00f              ADR      r0,|L1.76|
000010  f7fffffe          BL       rt_assert_handler
                  |L1.20|
;;;244    
;;;245        if (dev->ref_count == 0)
000014  7ea0              LDRB     r0,[r4,#0x1a]
000016  2800              CMP      r0,#0
000018  d006              BEQ      |L1.40|
00001a  1e40              SUBS     r0,r0,#1
;;;246            return -RT_ERROR;
;;;247    
;;;248        dev->ref_count--;
00001c  0600              LSLS     r0,r0,#24
00001e  0e00              LSRS     r0,r0,#24
000020  76a0              STRB     r0,[r4,#0x1a]
;;;249    
;;;250        if (dev->ref_count != 0)
000022  d004              BEQ      |L1.46|
;;;251            return RT_EOK;
000024  2000              MOVS     r0,#0
;;;252    
;;;253        /* call device close interface */
;;;254        if (dev->close != RT_NULL)
;;;255        {
;;;256            result = dev->close(dev);
;;;257        }
;;;258    
;;;259        /* set open flag */
;;;260        if (result == RT_EOK || result == -RT_ENOSYS)
;;;261            dev->open_flag = RT_DEVICE_OFLAG_CLOSE;
;;;262    
;;;263        return result;
;;;264    }
000026  bd70              POP      {r4-r6,pc}
                  |L1.40|
000028  2000              MOVS     r0,#0                 ;246
00002a  43c0              MVNS     r0,r0                 ;246
00002c  bd70              POP      {r4-r6,pc}
                  |L1.46|
00002e  6ae1              LDR      r1,[r4,#0x2c]         ;254
000030  2900              CMP      r1,#0                 ;254
000032  d005              BEQ      |L1.64|
000034  4620              MOV      r0,r4                 ;256
000036  4788              BLX      r1                    ;256
000038  0005              MOVS     r5,r0                 ;256
00003a  d001              BEQ      |L1.64|
00003c  1da8              ADDS     r0,r5,#6              ;260
00003e  d101              BNE      |L1.68|
                  |L1.64|
000040  2000              MOVS     r0,#0                 ;261
000042  8320              STRH     r0,[r4,#0x18]         ;261
                  |L1.68|
000044  4628              MOV      r0,r5                 ;263
000046  bd70              POP      {r4-r6,pc}
;;;265    RTM_EXPORT(rt_device_close);
                          ENDP

                  |L1.72|
                          DCD      ||.constdata||+0x33
                  |L1.76|
00004c  64657620          DCB      "dev != RT_NULL",0
000050  213d2052
000054  545f4e55
000058  4c4c00  
00005b  00                DCB      0

                          AREA ||i.rt_device_control||, CODE, READONLY, ALIGN=2

                  rt_device_control PROC
;;;351     */
;;;352    rt_err_t rt_device_control(rt_device_t dev, rt_uint8_t cmd, void *arg)
000000  b570              PUSH     {r4-r6,lr}
;;;353    {
000002  4615              MOV      r5,r2
000004  460e              MOV      r6,r1
000006  0004              MOVS     r4,r0
000008  d105              BNE      |L2.22|
;;;354        RT_ASSERT(dev != RT_NULL);
00000a  22ff              MOVS     r2,#0xff
00000c  3263              ADDS     r2,r2,#0x63
00000e  4907              LDR      r1,|L2.44|
000010  a007              ADR      r0,|L2.48|
000012  f7fffffe          BL       rt_assert_handler
                  |L2.22|
;;;355    
;;;356        /* call device write interface */
;;;357        if (dev->control != RT_NULL)
000016  6ba3              LDR      r3,[r4,#0x38]
000018  2b00              CMP      r3,#0
00001a  d004              BEQ      |L2.38|
;;;358        {
;;;359            return dev->control(dev, cmd, arg);
00001c  462a              MOV      r2,r5
00001e  4631              MOV      r1,r6
000020  4620              MOV      r0,r4
000022  4798              BLX      r3
;;;360        }
;;;361    
;;;362        return RT_EOK;
;;;363    }
000024  bd70              POP      {r4-r6,pc}
                  |L2.38|
000026  2000              MOVS     r0,#0                 ;362
000028  bd70              POP      {r4-r6,pc}
;;;364    RTM_EXPORT(rt_device_control);
                          ENDP

00002a  0000              DCW      0x0000
                  |L2.44|
                          DCD      ||.constdata||+0x62
                  |L2.48|
000030  64657620          DCB      "dev != RT_NULL",0
000034  213d2052
000038  545f4e55
00003c  4c4c00  
00003f  00                DCB      0

                          AREA ||i.rt_device_find||, CODE, READONLY, ALIGN=2

                  rt_device_find PROC
;;;99      */
;;;100    rt_device_t rt_device_find(const char *name)
000000  b5f8              PUSH     {r3-r7,lr}
;;;101    {
000002  4607              MOV      r7,r0
;;;102        struct rt_object *object;
;;;103        struct rt_list_node *node;
;;;104        struct rt_object_information *information;
;;;105    
;;;106        extern struct rt_object_information rt_object_container[];
;;;107    
;;;108        /* enter critical */
;;;109        if (rt_thread_self() != RT_NULL)
000004  f7fffffe          BL       rt_thread_self
000008  2800              CMP      r0,#0
00000a  d001              BEQ      |L3.16|
;;;110            rt_enter_critical();
00000c  f7fffffe          BL       rt_enter_critical
                  |L3.16|
;;;111    
;;;112        /* try to find device object */
;;;113        information = &rt_object_container[RT_Object_Class_Device];
000010  4e0f              LDR      r6,|L3.80|
;;;114        for (node  = information->object_list.next;
000012  6f74              LDR      r4,[r6,#0x74]
000014  3674              ADDS     r6,r6,#0x74
000016  e009              B        |L3.44|
                  |L3.24|
;;;115             node != &(information->object_list);
;;;116             node  = node->next)
;;;117        {
;;;118            object = rt_list_entry(node, struct rt_object, list);
000018  4625              MOV      r5,r4
00001a  3d0c              SUBS     r5,r5,#0xc
;;;119            if (rt_strncmp(object->name, name, RT_NAME_MAX) == 0)
00001c  2208              MOVS     r2,#8
00001e  4639              MOV      r1,r7
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       rt_strncmp
000026  2800              CMP      r0,#0
000028  d00a              BEQ      |L3.64|
00002a  6824              LDR      r4,[r4,#0]            ;116
                  |L3.44|
00002c  42b4              CMP      r4,r6                 ;115
00002e  d1f3              BNE      |L3.24|
;;;120            {
;;;121                /* leave critical */
;;;122                if (rt_thread_self() != RT_NULL)
;;;123                    rt_exit_critical();
;;;124    
;;;125                return (rt_device_t)object;
;;;126            }
;;;127        }
;;;128    
;;;129        /* leave critical */
;;;130        if (rt_thread_self() != RT_NULL)
000030  f7fffffe          BL       rt_thread_self
000034  2800              CMP      r0,#0
000036  d001              BEQ      |L3.60|
;;;131            rt_exit_critical();
000038  f7fffffe          BL       rt_exit_critical
                  |L3.60|
;;;132    
;;;133        /* not found */
;;;134        return RT_NULL;
00003c  2000              MOVS     r0,#0
;;;135    }
00003e  bdf8              POP      {r3-r7,pc}
                  |L3.64|
000040  f7fffffe          BL       rt_thread_self
000044  2800              CMP      r0,#0                 ;122
000046  d001              BEQ      |L3.76|
000048  f7fffffe          BL       rt_exit_critical
                  |L3.76|
00004c  4628              MOV      r0,r5                 ;125
00004e  bdf8              POP      {r3-r7,pc}
;;;136    RTM_EXPORT(rt_device_find);
                          ENDP

                  |L3.80|
                          DCD      rt_object_container

                          AREA ||i.rt_device_init||, CODE, READONLY, ALIGN=2

                  rt_device_init PROC
;;;144     */
;;;145    rt_err_t rt_device_init(rt_device_t dev)
000000  b570              PUSH     {r4-r6,lr}
;;;146    {
;;;147        rt_err_t result = RT_EOK;
000002  2500              MOVS     r5,#0
000004  4604              MOV      r4,r0                 ;146
;;;148    
;;;149        RT_ASSERT(dev != RT_NULL);
000006  2800              CMP      r0,#0
000008  d104              BNE      |L4.20|
00000a  2295              MOVS     r2,#0x95
00000c  490c              LDR      r1,|L4.64|
00000e  a00d              ADR      r0,|L4.68|
000010  f7fffffe          BL       rt_assert_handler
                  |L4.20|
;;;150    
;;;151        /* get device init handler */
;;;152        if (dev->init != RT_NULL)
000014  6a61              LDR      r1,[r4,#0x24]
000016  2900              CMP      r1,#0
000018  d010              BEQ      |L4.60|
;;;153        {
;;;154            if (!(dev->flag & RT_DEVICE_FLAG_ACTIVATED))
00001a  7da0              LDRB     r0,[r4,#0x16]
00001c  06c0              LSLS     r0,r0,#27
00001e  d40d              BMI      |L4.60|
;;;155            {
;;;156                result = dev->init(dev);
000020  4620              MOV      r0,r4
000022  4788              BLX      r1
000024  0005              MOVS     r5,r0
;;;157                if (result != RT_EOK)
000026  d005              BEQ      |L4.52|
;;;158                {
;;;159                    rt_kprintf("To initialize device:%s failed. The error code is %d\n",
000028  4602              MOV      r2,r0
00002a  4621              MOV      r1,r4
00002c  a009              ADR      r0,|L4.84|
00002e  f7fffffe          BL       rt_kprintf
000032  e003              B        |L4.60|
                  |L4.52|
;;;160                               dev->parent.name, result);
;;;161                }
;;;162                else
;;;163                {
;;;164                    dev->flag |= RT_DEVICE_FLAG_ACTIVATED;
000034  8ae0              LDRH     r0,[r4,#0x16]
000036  2110              MOVS     r1,#0x10
000038  4308              ORRS     r0,r0,r1
00003a  82e0              STRH     r0,[r4,#0x16]
                  |L4.60|
;;;165                }
;;;166            }
;;;167        }
;;;168    
;;;169        return result;
00003c  4628              MOV      r0,r5
;;;170    }
00003e  bd70              POP      {r4-r6,pc}
;;;171    
                          ENDP

                  |L4.64|
                          DCD      ||.constdata||+0x15
                  |L4.68|
000044  64657620          DCB      "dev != RT_NULL",0
000048  213d2052
00004c  545f4e55
000050  4c4c00  
000053  00                DCB      0
                  |L4.84|
000054  546f2069          DCB      "To initialize device:%s failed. The error code is %d\n",0
000058  6e697469
00005c  616c697a
000060  65206465
000064  76696365
000068  3a257320
00006c  6661696c
000070  65642e20
000074  54686520
000078  6572726f
00007c  7220636f
000080  64652069
000084  73202564
000088  0a00    
00008a  00                DCB      0
00008b  00                DCB      0

                          AREA ||i.rt_device_init_all||, CODE, READONLY, ALIGN=1

                  rt_device_init_all PROC
;;;87      */
;;;88     rt_err_t rt_device_init_all(void)
000000  2000              MOVS     r0,#0
;;;89     {
;;;90         return RT_EOK;
;;;91     }
000002  4770              BX       lr
;;;92     
                          ENDP


                          AREA ||i.rt_device_open||, CODE, READONLY, ALIGN=2

                  rt_device_open PROC
;;;179     */
;;;180    rt_err_t rt_device_open(rt_device_t dev, rt_uint16_t oflag)
000000  b570              PUSH     {r4-r6,lr}
;;;181    {
;;;182        rt_err_t result = RT_EOK;
000002  2500              MOVS     r5,#0
000004  460e              MOV      r6,r1                 ;181
000006  4604              MOV      r4,r0                 ;181
;;;183    
;;;184        RT_ASSERT(dev != RT_NULL);
000008  2800              CMP      r0,#0
00000a  d104              BNE      |L6.22|
00000c  22b8              MOVS     r2,#0xb8
00000e  491d              LDR      r1,|L6.132|
000010  a01d              ADR      r0,|L6.136|
000012  f7fffffe          BL       rt_assert_handler
                  |L6.22|
;;;185    
;;;186        /* if device is not initialized, initialize it. */
;;;187        if (!(dev->flag & RT_DEVICE_FLAG_ACTIVATED))
000016  7da0              LDRB     r0,[r4,#0x16]
000018  06c0              LSLS     r0,r0,#27
00001a  d410              BMI      |L6.62|
;;;188        {
;;;189            if (dev->init != RT_NULL)
00001c  6a61              LDR      r1,[r4,#0x24]
00001e  2900              CMP      r1,#0
000020  d009              BEQ      |L6.54|
;;;190            {
;;;191                result = dev->init(dev);
000022  4620              MOV      r0,r4
000024  4788              BLX      r1
000026  0005              MOVS     r5,r0
;;;192                if (result != RT_EOK)
000028  d005              BEQ      |L6.54|
;;;193                {
;;;194                    rt_kprintf("To initialize device:%s failed. The error code is %d\n",
00002a  4602              MOV      r2,r0
00002c  4621              MOV      r1,r4
00002e  a01a              ADR      r0,|L6.152|
000030  f7fffffe          BL       rt_kprintf
;;;195                               dev->parent.name, result);
;;;196    
;;;197                    return result;
000034  e024              B        |L6.128|
                  |L6.54|
;;;198                }
;;;199            }
;;;200    
;;;201            dev->flag |= RT_DEVICE_FLAG_ACTIVATED;
000036  8ae0              LDRH     r0,[r4,#0x16]
000038  2110              MOVS     r1,#0x10
00003a  4308              ORRS     r0,r0,r1
00003c  82e0              STRH     r0,[r4,#0x16]
                  |L6.62|
;;;202        }
;;;203    
;;;204        /* device is a stand alone device and opened */
;;;205        if ((dev->flag & RT_DEVICE_FLAG_STANDALONE) &&
00003e  7da0              LDRB     r0,[r4,#0x16]
000040  0700              LSLS     r0,r0,#28
000042  d505              BPL      |L6.80|
;;;206            (dev->open_flag & RT_DEVICE_OFLAG_OPEN))
000044  7e20              LDRB     r0,[r4,#0x18]
000046  0700              LSLS     r0,r0,#28
000048  d502              BPL      |L6.80|
;;;207        {
;;;208            return -RT_EBUSY;
00004a  2006              MOVS     r0,#6
00004c  43c0              MVNS     r0,r0
;;;209        }
;;;210    
;;;211        /* call device open interface */
;;;212        if (dev->open != RT_NULL)
;;;213        {
;;;214            result = dev->open(dev, oflag);
;;;215        }
;;;216    
;;;217        /* set open flag */
;;;218        if (result == RT_EOK || result == -RT_ENOSYS)
;;;219        {
;;;220            dev->open_flag = oflag | RT_DEVICE_OFLAG_OPEN;
;;;221    
;;;222            dev->ref_count++;
;;;223            /* don't let bad things happen silently. If you are bitten by this assert,
;;;224             * please set the ref_count to a bigger type. */
;;;225            RT_ASSERT(dev->ref_count != 0);
;;;226        }
;;;227    
;;;228        return result;
;;;229    }
00004e  bd70              POP      {r4-r6,pc}
                  |L6.80|
000050  6aa2              LDR      r2,[r4,#0x28]         ;212
000052  2a00              CMP      r2,#0                 ;212
000054  d006              BEQ      |L6.100|
000056  4631              MOV      r1,r6                 ;214
000058  4620              MOV      r0,r4                 ;214
00005a  4790              BLX      r2                    ;214
00005c  0005              MOVS     r5,r0                 ;214
00005e  d001              BEQ      |L6.100|
000060  1da8              ADDS     r0,r5,#6              ;218
000062  d10d              BNE      |L6.128|
                  |L6.100|
000064  2008              MOVS     r0,#8                 ;220
000066  4306              ORRS     r6,r6,r0              ;220
000068  8326              STRH     r6,[r4,#0x18]         ;220
00006a  7ea0              LDRB     r0,[r4,#0x1a]         ;222
00006c  1c40              ADDS     r0,r0,#1              ;222
00006e  0600              LSLS     r0,r0,#24             ;222
000070  0e00              LSRS     r0,r0,#24             ;222
000072  76a0              STRB     r0,[r4,#0x1a]         ;222
000074  d104              BNE      |L6.128|
000076  22e1              MOVS     r2,#0xe1              ;225
000078  4902              LDR      r1,|L6.132|
00007a  a015              ADR      r0,|L6.208|
00007c  f7fffffe          BL       rt_assert_handler
                  |L6.128|
000080  4628              MOV      r0,r5                 ;228
000082  bd70              POP      {r4-r6,pc}
;;;230    RTM_EXPORT(rt_device_open);
                          ENDP

                  |L6.132|
                          DCD      ||.constdata||+0x24
                  |L6.136|
000088  64657620          DCB      "dev != RT_NULL",0
00008c  213d2052
000090  545f4e55
000094  4c4c00  
000097  00                DCB      0
                  |L6.152|
000098  546f2069          DCB      "To initialize device:%s failed. The error code is %d\n",0
00009c  6e697469
0000a0  616c697a
0000a4  65206465
0000a8  76696365
0000ac  3a257320
0000b0  6661696c
0000b4  65642e20
0000b8  54686520
0000bc  6572726f
0000c0  7220636f
0000c4  64652069
0000c8  73202564
0000cc  0a00    
0000ce  00                DCB      0
0000cf  00                DCB      0
                  |L6.208|
0000d0  6465762d          DCB      "dev->ref_count != 0",0
0000d4  3e726566
0000d8  5f636f75
0000dc  6e742021
0000e0  3d203000

                          AREA ||i.rt_device_read||, CODE, READONLY, ALIGN=2

                  rt_device_read PROC
;;;278     */
;;;279    rt_size_t rt_device_read(rt_device_t dev,
000000  b5ff              PUSH     {r0-r7,lr}
;;;280                             rt_off_t    pos,
;;;281                             void       *buffer,
;;;282                             rt_size_t   size)
;;;283    {
000002  b081              SUB      sp,sp,#4
000004  461e              MOV      r6,r3
000006  4617              MOV      r7,r2
000008  0004              MOVS     r4,r0
00000a  d105              BNE      |L7.24|
;;;284        RT_ASSERT(dev != RT_NULL);
00000c  22ff              MOVS     r2,#0xff
00000e  321d              ADDS     r2,r2,#0x1d
000010  490c              LDR      r1,|L7.68|
000012  a00d              ADR      r0,|L7.72|
000014  f7fffffe          BL       rt_assert_handler
                  |L7.24|
;;;285    
;;;286        if (dev->ref_count == 0)
000018  7ea0              LDRB     r0,[r4,#0x1a]
00001a  2800              CMP      r0,#0
00001c  d009              BEQ      |L7.50|
;;;287        {
;;;288            rt_set_errno(-RT_ERROR);
;;;289            return 0;
;;;290        }
;;;291    
;;;292        /* call device read interface */
;;;293        if (dev->read != RT_NULL)
00001e  6b25              LDR      r5,[r4,#0x30]
000020  2d00              CMP      r5,#0
000022  d009              BEQ      |L7.56|
;;;294        {
;;;295            return dev->read(dev, pos, buffer, size);
000024  4633              MOV      r3,r6
000026  463a              MOV      r2,r7
000028  4620              MOV      r0,r4
00002a  9902              LDR      r1,[sp,#8]
00002c  47a8              BLX      r5
                  |L7.46|
;;;296        }
;;;297    
;;;298        /* set error code */
;;;299        rt_set_errno(-RT_ENOSYS);
;;;300    
;;;301        return 0;
;;;302    }
00002e  b005              ADD      sp,sp,#0x14
000030  bdf0              POP      {r4-r7,pc}
                  |L7.50|
000032  2000              MOVS     r0,#0                 ;288
000034  43c0              MVNS     r0,r0                 ;288
000036  e001              B        |L7.60|
                  |L7.56|
000038  2005              MOVS     r0,#5                 ;299
00003a  43c0              MVNS     r0,r0                 ;299
                  |L7.60|
00003c  f7fffffe          BL       rt_set_errno
000040  2000              MOVS     r0,#0                 ;301
000042  e7f4              B        |L7.46|
;;;303    RTM_EXPORT(rt_device_read);
                          ENDP

                  |L7.68|
                          DCD      ||.constdata||+0x43
                  |L7.72|
000048  64657620          DCB      "dev != RT_NULL",0
00004c  213d2052
000050  545f4e55
000054  4c4c00  
000057  00                DCB      0

                          AREA ||i.rt_device_register||, CODE, READONLY, ALIGN=2

                  rt_device_register PROC
;;;43      */
;;;44     rt_err_t rt_device_register(rt_device_t dev,
000000  b5f8              PUSH     {r3-r7,lr}
;;;45                                 const char *name,
;;;46                                 rt_uint16_t flags)
;;;47     {
;;;48         if (dev == RT_NULL)
;;;49             return -RT_ERROR;
000002  4d0b              LDR      r5,|L8.48|
000004  4616              MOV      r6,r2                 ;47
000006  0004              MOVS     r4,r0                 ;47
000008  460f              MOV      r7,r1                 ;47
00000a  d004              BEQ      |L8.22|
;;;50     
;;;51         if (rt_device_find(name) != RT_NULL)
00000c  4608              MOV      r0,r1
00000e  f7fffffe          BL       rt_device_find
000012  2800              CMP      r0,#0
000014  d001              BEQ      |L8.26|
                  |L8.22|
;;;52             return -RT_ERROR;
000016  4628              MOV      r0,r5
;;;53     
;;;54         rt_object_init(&(dev->parent), RT_Object_Class_Device, name);
;;;55         dev->flag = flags;
;;;56         dev->ref_count = 0;
;;;57         dev->open_flag = 0;
;;;58     
;;;59         return RT_EOK;
;;;60     }
000018  bdf8              POP      {r3-r7,pc}
                  |L8.26|
00001a  463a              MOV      r2,r7                 ;54
00001c  2107              MOVS     r1,#7                 ;54
00001e  4620              MOV      r0,r4                 ;54
000020  f7fffffe          BL       rt_object_init
000024  82e6              STRH     r6,[r4,#0x16]         ;55
000026  2000              MOVS     r0,#0                 ;56
000028  76a0              STRB     r0,[r4,#0x1a]         ;56
00002a  8320              STRH     r0,[r4,#0x18]         ;57
00002c  bdf8              POP      {r3-r7,pc}
;;;61     RTM_EXPORT(rt_device_register);
                          ENDP

00002e  0000              DCW      0x0000
                  |L8.48|
                          DCD      0xffffffff

                          AREA ||i.rt_device_set_rx_indicate||, CODE, READONLY, ALIGN=2

                  rt_device_set_rx_indicate PROC
;;;375    rt_err_t
;;;376    rt_device_set_rx_indicate(rt_device_t dev,
000000  b570              PUSH     {r4-r6,lr}
;;;377                              rt_err_t (*rx_ind)(rt_device_t dev, rt_size_t size))
;;;378    {
000002  460d              MOV      r5,r1
000004  0004              MOVS     r4,r0
000006  d105              BNE      |L9.20|
;;;379        RT_ASSERT(dev != RT_NULL);
000008  22ff              MOVS     r2,#0xff
00000a  327c              ADDS     r2,r2,#0x7c
00000c  4903              LDR      r1,|L9.28|
00000e  a004              ADR      r0,|L9.32|
000010  f7fffffe          BL       rt_assert_handler
                  |L9.20|
;;;380    
;;;381        dev->rx_indicate = rx_ind;
;;;382    
;;;383        return RT_EOK;
000014  2000              MOVS     r0,#0
000016  61e5              STR      r5,[r4,#0x1c]
;;;384    }
000018  bd70              POP      {r4-r6,pc}
;;;385    RTM_EXPORT(rt_device_set_rx_indicate);
                          ENDP

00001a  0000              DCW      0x0000
                  |L9.28|
                          DCD      ||.constdata||+0x74
                  |L9.32|
000020  64657620          DCB      "dev != RT_NULL",0
000024  213d2052
000028  545f4e55
00002c  4c4c00  
00002f  00                DCB      0

                          AREA ||i.rt_device_set_tx_complete||, CODE, READONLY, ALIGN=2

                  rt_device_set_tx_complete PROC
;;;396    rt_err_t
;;;397    rt_device_set_tx_complete(rt_device_t dev,
000000  b570              PUSH     {r4-r6,lr}
;;;398                              rt_err_t (*tx_done)(rt_device_t dev, void *buffer))
;;;399    {
000002  460d              MOV      r5,r1
000004  0004              MOVS     r4,r0
000006  d105              BNE      |L10.20|
;;;400        RT_ASSERT(dev != RT_NULL);
000008  22ff              MOVS     r2,#0xff
00000a  3291              ADDS     r2,r2,#0x91
00000c  4903              LDR      r1,|L10.28|
00000e  a004              ADR      r0,|L10.32|
000010  f7fffffe          BL       rt_assert_handler
                  |L10.20|
;;;401    
;;;402        dev->tx_complete = tx_done;
;;;403    
;;;404        return RT_EOK;
000014  2000              MOVS     r0,#0
000016  6225              STR      r5,[r4,#0x20]
;;;405    }
000018  bd70              POP      {r4-r6,pc}
;;;406    RTM_EXPORT(rt_device_set_tx_complete);
                          ENDP

00001a  0000              DCW      0x0000
                  |L10.28|
                          DCD      ||.constdata||+0x8e
                  |L10.32|
000020  64657620          DCB      "dev != RT_NULL",0
000024  213d2052
000028  545f4e55
00002c  4c4c00  
00002f  00                DCB      0

                          AREA ||i.rt_device_unregister||, CODE, READONLY, ALIGN=2

                  rt_device_unregister PROC
;;;69      */
;;;70     rt_err_t rt_device_unregister(rt_device_t dev)
000000  b510              PUSH     {r4,lr}
;;;71     {
000002  0004              MOVS     r4,r0
000004  d104              BNE      |L11.16|
;;;72         RT_ASSERT(dev != RT_NULL);
000006  2248              MOVS     r2,#0x48
000008  4904              LDR      r1,|L11.28|
00000a  a005              ADR      r0,|L11.32|
00000c  f7fffffe          BL       rt_assert_handler
                  |L11.16|
;;;73     
;;;74         rt_object_detach(&(dev->parent));
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       rt_object_detach
;;;75     
;;;76         return RT_EOK;
000016  2000              MOVS     r0,#0
;;;77     }
000018  bd10              POP      {r4,pc}
;;;78     RTM_EXPORT(rt_device_unregister);
                          ENDP

00001a  0000              DCW      0x0000
                  |L11.28|
                          DCD      ||.constdata||
                  |L11.32|
000020  64657620          DCB      "dev != RT_NULL",0
000024  213d2052
000028  545f4e55
00002c  4c4c00  
00002f  00                DCB      0

                          AREA ||i.rt_device_write||, CODE, READONLY, ALIGN=2

                  rt_device_write PROC
;;;316     */
;;;317    rt_size_t rt_device_write(rt_device_t dev,
000000  b5ff              PUSH     {r0-r7,lr}
;;;318                              rt_off_t    pos,
;;;319                              const void *buffer,
;;;320                              rt_size_t   size)
;;;321    {
000002  b081              SUB      sp,sp,#4
000004  461e              MOV      r6,r3
000006  4617              MOV      r7,r2
000008  0004              MOVS     r4,r0
00000a  d105              BNE      |L12.24|
;;;322        RT_ASSERT(dev != RT_NULL);
00000c  22ff              MOVS     r2,#0xff
00000e  3243              ADDS     r2,r2,#0x43
000010  490c              LDR      r1,|L12.68|
000012  a00d              ADR      r0,|L12.72|
000014  f7fffffe          BL       rt_assert_handler
                  |L12.24|
;;;323    
;;;324        if (dev->ref_count == 0)
000018  7ea0              LDRB     r0,[r4,#0x1a]
00001a  2800              CMP      r0,#0
00001c  d009              BEQ      |L12.50|
;;;325        {
;;;326            rt_set_errno(-RT_ERROR);
;;;327            return 0;
;;;328        }
;;;329    
;;;330        /* call device write interface */
;;;331        if (dev->write != RT_NULL)
00001e  6b65              LDR      r5,[r4,#0x34]
000020  2d00              CMP      r5,#0
000022  d009              BEQ      |L12.56|
;;;332        {
;;;333            return dev->write(dev, pos, buffer, size);
000024  4633              MOV      r3,r6
000026  463a              MOV      r2,r7
000028  4620              MOV      r0,r4
00002a  9902              LDR      r1,[sp,#8]
00002c  47a8              BLX      r5
                  |L12.46|
;;;334        }
;;;335    
;;;336        /* set error code */
;;;337        rt_set_errno(-RT_ENOSYS);
;;;338    
;;;339        return 0;
;;;340    }
00002e  b005              ADD      sp,sp,#0x14
000030  bdf0              POP      {r4-r7,pc}
                  |L12.50|
000032  2000              MOVS     r0,#0                 ;326
000034  43c0              MVNS     r0,r0                 ;326
000036  e001              B        |L12.60|
                  |L12.56|
000038  2005              MOVS     r0,#5                 ;337
00003a  43c0              MVNS     r0,r0                 ;337
                  |L12.60|
00003c  f7fffffe          BL       rt_set_errno
000040  2000              MOVS     r0,#0                 ;339
000042  e7f4              B        |L12.46|
;;;341    RTM_EXPORT(rt_device_write);
                          ENDP

                  |L12.68|
                          DCD      ||.constdata||+0x52
                  |L12.72|
000048  64657620          DCB      "dev != RT_NULL",0
00004c  213d2052
000050  545f4e55
000054  4c4c00  
000057  00                DCB      0

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  72745f64          DCB      0x72,0x74,0x5f,0x64
000004  65766963          DCB      0x65,0x76,0x69,0x63
000008  655f756e          DCB      0x65,0x5f,0x75,0x6e
00000c  72656769          DCB      0x72,0x65,0x67,0x69
000010  73746572          DCB      0x73,0x74,0x65,0x72
000014  00                DCB      0x00
                  |symbol_number.40|
000015  72745f            DCB      0x72,0x74,0x5f
000018  64657669          DCB      0x64,0x65,0x76,0x69
00001c  63655f69          DCB      0x63,0x65,0x5f,0x69
000020  6e697400          DCB      0x6e,0x69,0x74,0x00
                  |symbol_number.41|
000024  72745f64          DCB      0x72,0x74,0x5f,0x64
000028  65766963          DCB      0x65,0x76,0x69,0x63
00002c  655f6f70          DCB      0x65,0x5f,0x6f,0x70
000030  656e00            DCB      0x65,0x6e,0x00
                  |symbol_number.42|
000033  72                DCB      0x72
000034  745f6465          DCB      0x74,0x5f,0x64,0x65
000038  76696365          DCB      0x76,0x69,0x63,0x65
00003c  5f636c6f          DCB      0x5f,0x63,0x6c,0x6f
000040  736500            DCB      0x73,0x65,0x00
                  |symbol_number.43|
000043  72                DCB      0x72
000044  745f6465          DCB      0x74,0x5f,0x64,0x65
000048  76696365          DCB      0x76,0x69,0x63,0x65
00004c  5f726561          DCB      0x5f,0x72,0x65,0x61
000050  6400              DCB      0x64,0x00
                  |symbol_number.44|
000052  7274              DCB      0x72,0x74
000054  5f646576          DCB      0x5f,0x64,0x65,0x76
000058  6963655f          DCB      0x69,0x63,0x65,0x5f
00005c  77726974          DCB      0x77,0x72,0x69,0x74
000060  6500              DCB      0x65,0x00
                  |symbol_number.45|
000062  7274              DCB      0x72,0x74
000064  5f646576          DCB      0x5f,0x64,0x65,0x76
000068  6963655f          DCB      0x69,0x63,0x65,0x5f
00006c  636f6e74          DCB      0x63,0x6f,0x6e,0x74
000070  726f6c00          DCB      0x72,0x6f,0x6c,0x00
                  |symbol_number.46|
000074  72745f64          DCB      0x72,0x74,0x5f,0x64
000078  65766963          DCB      0x65,0x76,0x69,0x63
00007c  655f7365          DCB      0x65,0x5f,0x73,0x65
000080  745f7278          DCB      0x74,0x5f,0x72,0x78
000084  5f696e64          DCB      0x5f,0x69,0x6e,0x64
000088  69636174          DCB      0x69,0x63,0x61,0x74
00008c  6500              DCB      0x65,0x00
                  |symbol_number.47|
00008e  7274              DCB      0x72,0x74
000090  5f646576          DCB      0x5f,0x64,0x65,0x76
000094  6963655f          DCB      0x69,0x63,0x65,0x5f
000098  7365745f          DCB      0x73,0x65,0x74,0x5f
00009c  74785f63          DCB      0x74,0x78,0x5f,0x63
0000a0  6f6d706c          DCB      0x6f,0x6d,0x70,0x6c
0000a4  65746500          DCB      0x65,0x74,0x65,0x00
