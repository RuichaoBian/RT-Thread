L 1 "Libraries\StdDriver\src\ps2.c"
N/**************************************************************************//**
N * @file     ps2.c
N * @version  V3.00
N * $Revision: 4 $
N * $Date: 15/05/19 11:41a $
N * @brief    NUC230_240 series PS/2 driver source file
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N
N#include <stdio.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdio.h" 1
N/* stdio.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.9 */
N/* Copyright (C) Codemist Ltd., 1988-1993                       */
N/* Copyright 1991-1998 ARM Limited. All rights reserved.        */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: sdouglas $
N */
N
N/*
N * stdio.h declares two types, several macros, and many functions for
N * performing input and output. For a discussion on Streams and Files
N * refer to sections 4.9.2 and 4.9.3 in the above ANSI draft, or to a
N * modern textbook on C.
N */
N
N#ifndef __stdio_h
N#define __stdio_h
N#define __ARMCLIB_VERSION 5060016
N
N/*
N * Depending on compiler version __int64 or __INT64_TYPE__ should be defined.
N */
N#ifndef __int64
N  #ifdef __INT64_TYPE__
S    #define __int64 __INT64_TYPE__
N  #endif
N  /* On some architectures neither of these may be defined - if so, fall
N     through and error out if used. */
N#endif
N
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STDIO_DECLS
N  #define __STDIO_DECLS
N
N    #undef __CLIBNS
N    #ifdef __cplusplus
S      namespace std {
S      #define __CLIBNS ::std::
S        extern "C" {
N    #else /* ndef __cplusplus */
N      #define __CLIBNS
N    #endif /* ndef __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__size_t)
X#if 0L || !0L || !0L
N /* always defined in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __size_t 1
N  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N/* ANSI forbids va_list to be defined here */
N/* keep in step with <stdarg.h> and <wchar.h> */
N#if !defined(__va_list) && (defined(__cplusplus) || !defined(__STRICT_ANSI__) || !defined(__va_list_defined))
X#if !0L && (0L || !0L || !0L)
N/* always defined in C++ and non-strict C for consistency of debug info */
N  #ifdef __clang__
S    typedef __builtin_va_list __va_list;
N  #else
N    typedef struct __va_list __va_list;
N  #endif
N  #if !defined(__cplusplus) && defined(__STRICT_ANSI__)
X  #if !0L && 0L
S    #define __va_list_defined 1
N  #endif
N#endif
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain compliant versions of the printf
N    * and scanf families of functions
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Ntypedef struct __fpos_t_struct {
N    unsigned __int64 __pos;
N    /*
N     * this structure is equivalent to an mbstate_t, but we're not
N     * allowed to actually define the type name `mbstate_t' within
N     * stdio.h
N     */
N    struct {
N        unsigned int __state1, __state2;
N    } __mbstate;
N} fpos_t;
N   /*
N    * fpos_t is an object capable of recording all information needed to
N    * specify uniquely every position within a file.
N    */
N
N#define _SYS_OPEN 16
N   /* _SYS_OPEN defines a limit on the number of open files that is imposed
N    * by this C library
N    */
N
Ntypedef struct __FILE FILE;
N   /*
N    * FILE is an object capable of recording all information needed to control
N    * a stream, such as its file position indicator, a pointer to its
N    * associated buffer, an error indicator that records whether a read/write
N    * error has occurred and an end-of-file indicator that records whether the
N    * end-of-file has been reached.
N    * Its structure is not made known to library clients.
N    */
N
N#if defined(__STRICT_ANSI__) && !__FILE_INCOMPLETE
X#if 0L && !__FILE_INCOMPLETE
Sstruct __FILE {
S    union {
S        long __FILE_alignment;
S#ifdef __TARGET_ARCH_AARCH64
S        char __FILE_size[136];
S#else /* __TARGET_ARCH_AARCH64 */
S        char __FILE_size[84];
S#endif /* __TARGET_ARCH_AARCH64 */
S    } __FILE_opaque;
S};
S    /*
S     * FILE must be an object type (C99 - 7.19.1) and an object type fully
S     * describes an object [including its static size] (C99 - 6.2.5).
S     * This definition is a placeholder which matches the struct __FILE in
S     * size and alignment as used internally by libc.
S     */
N#endif
N
N
Nextern FILE __stdin, __stdout, __stderr;
Nextern FILE *__aeabi_stdin, *__aeabi_stdout, *__aeabi_stderr;
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S#define stdin  (__CLIBNS __aeabi_stdin)
S   /* pointer to a FILE object associated with standard input stream */
S#define stdout (__CLIBNS __aeabi_stdout)
S   /* pointer to a FILE object associated with standard output stream */
S#define stderr (__CLIBNS __aeabi_stderr)
S   /* pointer to a FILE object associated with standard error stream */
Sextern const int __aeabi_IOFBF;
S#define _IOFBF (__CLIBNS __aeabi_IOFBF)
Sextern const int __aeabi_IONBF;
S#define _IONBF (__CLIBNS __aeabi_IONBF)
Sextern const int __aeabi_IOLBF;
S#define _IOLBF (__CLIBNS __aeabi_IOLBF)
Sextern const int __aeabi_BUFSIZ;
S#define BUFSIZ (__CLIBNS __aeabi_BUFSIZ)
Sextern const int __aeabi_FOPEN_MAX;
S#define FOPEN_MAX (__CLIBNS __aeabi_FOPEN_MAX)
Sextern const int __aeabi_TMP_MAX;
S#define TMP_MAX (__CLIBNS __aeabi_TMP_MAX)
Sextern const int __aeabi_FILENAME_MAX;
S#define FILENAME_MAX (__CLIBNS __aeabi_FILENAME_MAX)
Sextern const int __aeabi_L_tmpnam;
S#define L_tmpnam (__CLIBNS __aeabi_L_tmpnam)
N#else
N#define stdin  (&__CLIBNS __stdin)
N   /* pointer to a FILE object associated with standard input stream */
N#define stdout (&__CLIBNS __stdout)
N   /* pointer to a FILE object associated with standard output stream */
N#define stderr (&__CLIBNS __stderr)
N   /* pointer to a FILE object associated with standard error stream */
N
N#define _IOFBF           0x100 /* fully buffered IO */
N#define _IOLBF           0x200 /* line buffered IO */
N#define _IONBF           0x400 /* unbuffered IO */
N
N    /* Various default file IO buffer sizes */
N#define BUFSIZ       (512)  /* system buffer size (as used by setbuf) */
N
N#define FOPEN_MAX _SYS_OPEN
N   /*
N    * an integral constant expression that is the minimum number of files that
N    * this implementation guarantees can be open simultaneously.
N    */
N
N#define FILENAME_MAX 256
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold the longest filename string
N    */
N#define L_tmpnam FILENAME_MAX
N   /*
N    * an integral constant expression that is the size of an array of char
N    * large enough to hold a temporary file name string generated by the
N    * tmpnam function.
N    */
N#define TMP_MAX 256
N   /*
N    * an integral constant expression that is the minimum number of unique
N    * file names that shall be generated by the tmpnam function.
N    */
N
N#endif
N
N#define EOF      (-1)
N   /*
N    * negative integral constant, indicates end-of-file, that is, no more input
N    * from a stream.
N    */
N
N#define SEEK_SET 0 /* start of stream (see fseek) */
N#define SEEK_CUR 1 /* current position in stream (see fseek) */
N#define SEEK_END 2 /* end of stream (see fseek) */
N
N    /*
N     * _IOBIN is the flag passed to _sys_write to denote a binary
N     * file.
N     */
N#define _IOBIN            0x04     /* binary stream */
N
N#define __STDIN_BUFSIZ  (64)  /* default stdin buffer size */
N#define __STDOUT_BUFSIZ (64)  /* default stdout buffer size */
N#define __STDERR_BUFSIZ (16)  /* default stderr buffer size */
N
Nextern _ARMABI int remove(const char * /*filename*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int remove(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the file whose name is the string pointed to by filename to be
N    * removed. Subsequent attempts to open the file will fail, unless it is
N    * created anew. If the file is open, the behaviour of the remove function
N    * is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails.
N    */
Nextern _ARMABI int rename(const char * /*old*/, const char * /*new*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int rename(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * causes the file whose name is the string pointed to by old to be
N    * henceforth known by the name given by the string pointed to by new. The
N    * file named old is effectively removed. If a file named by the string
N    * pointed to by new exists prior to the call of the rename function, the
N    * behaviour is implementation-defined.
N    * Returns: zero if the operation succeeds, nonzero if it fails, in which
N    *          case if the file existed previously it is still known by its
N    *          original name.
N    */
Nextern _ARMABI FILE *tmpfile(void);
Xextern __declspec(__nothrow) FILE *tmpfile(void);
N   /*
N    * creates a temporary binary file that will be automatically removed when
N    * it is closed or at program termination. The file is opened for update.
N    * Returns: a pointer to the stream of the file that it created. If the file
N    *          cannot be created, a null pointer is returned.
N    */
Nextern _ARMABI char *tmpnam(char * /*s*/);
Xextern __declspec(__nothrow) char *tmpnam(char *  );
N   /*
N    * generates a string that is not the same as the name of an existing file.
N    * The tmpnam function generates a different string each time it is called,
N    * up to TMP_MAX times. If it is called more than TMP_MAX times, the
N    * behaviour is implementation-defined.
N    * Returns: If the argument is a null pointer, the tmpnam function leaves
N    *          its result in an internal static object and returns a pointer to
N    *          that object. Subsequent calls to the tmpnam function may modify
N    *          the same object. if the argument is not a null pointer, it is
N    *          assumed to point to an array of at least L_tmpnam characters;
N    *          the tmpnam function writes its result in that array and returns
N    *          the argument as its value.
N    */
N
Nextern _ARMABI int fclose(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fclose(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * causes the stream pointed to by stream to be flushed and the associated
N    * file to be closed. Any unwritten buffered data for the stream are
N    * delivered to the host environment to be written to the file; any unread
N    * buffered data are discarded. The stream is disassociated from the file.
N    * If the associated buffer was automatically allocated, it is deallocated.
N    * Returns: zero if the stream was succesfully closed, or nonzero if any
N    *          errors were detected or if the stream was already closed.
N    */
Nextern _ARMABI int fflush(FILE * /*stream*/);
Xextern __declspec(__nothrow) int fflush(FILE *  );
N   /*
N    * If the stream points to an output or update stream in which the most
N    * recent operation was output, the fflush function causes any unwritten
N    * data for that stream to be delivered to the host environment to be
N    * written to the file. If the stream points to an input or update stream,
N    * the fflush function undoes the effect of any preceding ungetc operation
N    * on the stream.
N    * Returns: nonzero if a write error occurs.
N    */
Nextern _ARMABI FILE *fopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *fopen(const char * __restrict  ,
N                           const char * __restrict /*mode*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * opens the file whose name is the string pointed to by filename, and
N    * associates a stream with it.
N    * The argument mode points to a string beginning with one of the following
N    * sequences:
N    * "r"         open text file for reading
N    * "w"         create text file for writing, or truncate to zero length
N    * "a"         append; open text file or create for writing at eof
N    * "rb"        open binary file for reading
N    * "wb"        create binary file for writing, or truncate to zero length
N    * "ab"        append; open binary file or create for writing at eof
N    * "r+"        open text file for update (reading and writing)
N    * "w+"        create text file for update, or truncate to zero length
N    * "a+"        append; open text file or create for update, writing at eof
N    * "r+b"/"rb+" open binary file for update (reading and writing)
N    * "w+b"/"wb+" create binary file for update, or truncate to zero length
N    * "a+b"/"ab+" append; open binary file or create for update, writing at eof
N    *
N    * Opening a file with read mode ('r' as the first character in the mode
N    * argument) fails if the file does not exist or cannot be read.
N    * Opening a file with append mode ('a' as the first character in the mode
N    * argument) causes all subsequent writes to be forced to the current end of
N    * file, regardless of intervening calls to the fseek function. In some
N    * implementations, opening a binary file with append mode ('b' as the
N    * second or third character in the mode argument) may initially position
N    * the file position indicator beyond the last data written, because of the
N    * NUL padding.
N    * When a file is opened with update mode ('+' as the second or third
N    * character in the mode argument), both input and output may be performed
N    * on the associated stream. However, output may not be directly followed
N    * by input without an intervening call to the fflush fuction or to a file
N    * positioning function (fseek, fsetpos, or rewind), and input be not be
N    * directly followed by output without an intervening call to the fflush
N    * fuction or to a file positioning function, unless the input operation
N    * encounters end-of-file. Opening a file with update mode may open or
N    * create a binary stream in some implementations. When opened, a stream
N    * is fully buffered if and only if it does not refer to an interactive
N    * device. The error and end-of-file indicators for the stream are
N    * cleared.
N    * Returns: a pointer to the object controlling the stream. If the open
N    *          operation fails, fopen returns a null pointer.
N    */
Nextern _ARMABI FILE *freopen(const char * __restrict /*filename*/,
Xextern __declspec(__nothrow) FILE *freopen(const char * __restrict  ,
N                    const char * __restrict /*mode*/,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(2,3)));
N   /*
N    * opens the file whose name is the string pointed to by filename and
N    * associates the stream pointed to by stream with it. The mode argument is
N    * used just as in the fopen function.
N    * The freopen function first attempts to close any file that is associated
N    * with the specified stream. Failure to close the file successfully is
N    * ignored. The error and end-of-file indicators for the stream are cleared.
N    * Returns: a null pointer if the operation fails. Otherwise, freopen
N    *          returns the value of the stream.
N    */
Nextern _ARMABI void setbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) void setbuf(FILE * __restrict  ,
N                    char * __restrict /*buf*/) __attribute__((__nonnull__(1)));
N   /*
N    * Except that it returns no value, the setbuf function is equivalent to the
N    * setvbuf function invoked with the values _IOFBF for mode and BUFSIZ for
N    * size, or (if buf is a null pointer), with the value _IONBF for mode.
N    * Returns: no value.
N    */
Nextern _ARMABI int setvbuf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int setvbuf(FILE * __restrict  ,
N                   char * __restrict /*buf*/,
N                   int /*mode*/, size_t /*size*/) __attribute__((__nonnull__(1)));
N   /*
N    * may be used after the stream pointed to by stream has been associated
N    * with an open file but before it is read or written. The argument mode
N    * determines how stream will be buffered, as follows: _IOFBF causes
N    * input/output to be fully buffered; _IOLBF causes output to be line
N    * buffered (the buffer will be flushed when a new-line character is
N    * written, when the buffer is full, or when input is requested); _IONBF
N    * causes input/output to be completely unbuffered. If buf is not the null
N    * pointer, the array it points to may be used instead of an automatically
N    * allocated buffer (the buffer must have a lifetime at least as great as
N    * the open stream, so the stream should be closed before a buffer that has
N    * automatic storage duration is deallocated upon block exit). The argument
N    * size specifies the size of the array. The contents of the array at any
N    * time are indeterminate.
N    * Returns: zero on success, or nonzero if an invalid value is given for
N    *          mode or size, or if the request cannot be honoured.
N    */
N#pragma __printf_args
Nextern _ARMABI int fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes output to the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies how subsequent arguments are
N    * converted for output. If there are insufficient arguments for the format,
N    * the behaviour is undefined. If the format is exhausted while arguments
N    * remain, the excess arguments are evaluated but otherwise ignored. The
N    * fprintf function returns when the end of the format string is reached.
N    * The format shall be a multibyte character sequence, beginning and ending
N    * in its initial shift state. The format is composed of zero or more
N    * directives: ordinary multibyte characters (not %), which are copied
N    * unchanged to the output stream; and conversion specifiers, each of which
N    * results in fetching zero or more subsequent arguments. Each conversion
N    * specification is introduced by the character %. For a description of the
N    * available conversion specifiers refer to section 4.9.6.1 in the ANSI
N    * draft mentioned at the start of this file or to any modern textbook on C.
N    * The minimum value for the maximum number of characters producable by any
N    * single conversion is at least 509.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _fprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, but does not support floating-point formats.
N    * You can use instead of fprintf to improve code size.
N    * Returns: as fprintf.
N    */
N#pragma __printf_args
Nextern _ARMABI int printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fprintf with the argument stdout interposed before the
N    * arguments to printf.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
N#pragma __printf_args
Nextern _ARMABI int _printf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _printf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, but does not support floating-point formats.
N    * You can use instead of printf to improve code size.
N    * Returns: as printf.
N    */
N#pragma __printf_args
Nextern _ARMABI int sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. A null character is written at the end of the characters written;
N    * it is not counted as part of the returned sum.
N    * Returns: the number of characters written to the array, not counting the
N    *          terminating null character.
N    */
N#pragma __printf_args
Nextern _ARMABI int _sprintf(char * __restrict /*s*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _sprintf(char * __restrict  , const char * __restrict  , ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, but does not support floating-point formats.
N    * You can use instead of sprintf to improve code size.
N    * Returns: as sprintf.
N    */
N
N#pragma __printf_args
Nextern _ARMABI int __ARM_snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
N#pragma __printf_args
Nextern _ARMABI int snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int snprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to fprintf, except that the argument s specifies an array
N    * into which the generated output is to be written, rather than to a
N    * stream. The argument n specifies the size of the output array, so as to
N    * avoid overflowing the buffer.
N    * A null character is written at the end of the characters written, even
N    * if the formatting was not completed; it is not counted as part of the
N    * returned sum. At most n characters of the output buffer are used,
N    * _including_ the null character.
N    * Returns: the number of characters that would have been written to the
N    *          array, not counting the terminating null character, if the
N    *          array had been big enough. So if the return is >=0 and <n, then
N    *          the entire string was successfully formatted; if the return is
N    *          >=n, the string was truncated (but there is still a null char
N    *          at the end of what was written); if the return is <0, there was
N    *          an error.
N    */
N#endif
N#pragma __printf_args
Nextern _ARMABI int _snprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _snprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, ...) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, but does not support floating-point formats.
N    * You can use instead of snprintf to improve code size.
N    * Returns: as snprintf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int fscanf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * reads input from the stream pointed to by stream, under control of the
N    * string pointed to by format that specifies the admissible input sequences
N    * and how thay are to be converted for assignment, using subsequent
N    * arguments as pointers to the objects to receive the converted input. If
N    * there are insufficient arguments for the format, the behaviour is
N    * undefined. If the format is exhausted while arguments remain, the excess
N    * arguments are evaluated but otherwise ignored.
N    * The format is composed of zero or more directives: one or more
N    * white-space characters; an ordinary character (not %); or a conversion
N    * specification. Each conversion specification is introduced by the
N    * character %. For a description of the available conversion specifiers
N    * refer to section 4.9.6.2 in the ANSI draft mentioned at the start of this
N    * file, or to any modern textbook on C.
N    * If end-of-file is encountered during input, conversion is terminated. If
N    * end-of-file occurs before any characters matching the current directive
N    * have been read (other than leading white space, where permitted),
N    * execution of the current directive terminates with an input failure;
N    * otherwise, unless execution of the current directive is terminated with a
N    * matching failure, execution of the following directive (if any) is
N    * terminated with an input failure.
N    * If conversions terminates on a conflicting input character, the offending
N    * input character is left unread in the input strem. Trailing white space
N    * (including new-line characters) is left unread unless matched by a
N    * directive. The success of literal matches and suppressed asignments is
N    * not directly determinable other than via the %n directive.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the fscanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early conflict between an input
N    *          character and the format.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _fscanf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _fscanf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf, but does not support floating-point formats.
N    * You can use instead of fscanf to improve code size.
N    * Returns: as fscanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fscanf with the argument stdin interposed before the
N    * arguments to scanf.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _scanf(const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _scanf(const char * __restrict  , ...) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to scanf, but does not support floating-point formats.
N    * You can use instead of scanf to improve code size.
N    * Returns: as scanf.
N    */
N#pragma __scanf_args
Nextern _ARMABI int sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int sscanf(const char * __restrict  ,
N                    const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fscanf except that the argument s specifies a string
N    * from which the input is to be obtained, rather than from a stream.
N    * Reaching the end of the string is equivalent to encountering end-of-file
N    * for the fscanf function.
N    * Returns: the value of the macro EOF if an input failure occurs before any
N    *          conversion. Otherwise, the scanf function returns the number of
N    *          input items assigned, which can be fewer than provided for, or
N    *          even zero, in the event of an early matching failure.
N    */
N#pragma __scanf_args
Nextern _ARMABI int _sscanf(const char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _sscanf(const char * __restrict  ,
N                     const char * __restrict /*format*/, ...) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sscanf, but does not support floating-point formats.
N    * You can use instead of sscanf to improve code size.
N    * Returns: as sscanf.
N    */
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
N/* C99 additions */
Nextern _ARMABI int vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N#endif
Nextern _ARMABI int _vfscanf(FILE * __restrict /*stream*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vfscanf(FILE * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int _vscanf(const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vscanf(const char * __restrict  , __va_list) __attribute__((__nonnull__(1)));
Nextern _ARMABI int _vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int _vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI int __ARM_vsscanf(const char * __restrict /*s*/, const char * __restrict /*format*/, __va_list) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int __ARM_vsscanf(const char * __restrict  , const char * __restrict  , __va_list) __attribute__((__nonnull__(1,2)));
N
Nextern _ARMABI int vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to printf, with the variable argument list replaced by arg,
N    * which has been initialised by the va_start macro (and possibly subsequent
N    * va_arg calls). The vprintf function does not invoke the va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int _vprintf(const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _vprintf(const char * __restrict  , __va_list  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to vprintf, but does not support floating-point formats.
N    * You can use instead of vprintf to improve code size.
N    * Returns: as vprintf.
N    */
Nextern _ARMABI int vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int vfprintf(FILE * __restrict  ,
N                    const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to fprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vfprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters transmitted, or a negative value if an
N    *          output error occurred.
N    */
Nextern _ARMABI int vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int vsprintf(char * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to sprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters written in the array, not counting the
N    *          terminating null character.
N    */
Nextern _ARMABI int __ARM_vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int __ARM_vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
Nextern _ARMABI int vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int vsnprintf(char * __restrict  , size_t  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to snprintf, with the variable argument list replaced by
N    * arg, which has been initialised by the va_start macro (and possibly
N    * subsequent va_arg calls). The vsprintf function does not invoke the
N    * va_end function.
N    * Returns: the number of characters that would have been written in the
N    *          array, not counting the terminating null character. As
N    *          snprintf.
N    */
N#endif
Nextern _ARMABI int _vsprintf(char * __restrict /*s*/,
Xextern __declspec(__nothrow) int _vsprintf(char * __restrict  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vsprintf, but does not support floating-point formats.
N    * You can use instead of vsprintf to improve code size.
N    * Returns: as vsprintf.
N    */
Nextern _ARMABI int _vfprintf(FILE * __restrict /*stream*/,
Xextern __declspec(__nothrow) int _vfprintf(FILE * __restrict  ,
N                     const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * is equivalent to vfprintf, but does not support floating-point formats.
N    * You can use instead of vfprintf to improve code size.
N    * Returns: as vfprintf.
N    */
Nextern _ARMABI int _vsnprintf(char * __restrict /*s*/, size_t /*n*/,
Xextern __declspec(__nothrow) int _vsnprintf(char * __restrict  , size_t  ,
N                      const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(3)));
N   /*
N    * is equivalent to vsnprintf, but does not support floating-point formats.
N    * You can use instead of vsnprintf to improve code size.
N    * Returns: as vsnprintf.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
N#pragma __printf_args
Nextern _ARMABI int asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N#endif
N#pragma __printf_args
Nextern _ARMABI int __ARM_asprintf(char ** /*strp*/, const char * __restrict /*format*/, ...) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_asprintf(char **  , const char * __restrict  , ...) __attribute__((__nonnull__(2)));
Nextern _ARMABI int __ARM_vasprintf(char ** /*strp*/, const char * __restrict /*format*/, __va_list /*arg*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int __ARM_vasprintf(char **  , const char * __restrict  , __va_list  ) __attribute__((__nonnull__(2)));
N   /*
N    * dynamically allocates a buffer of the right size for the
N    * formatted string, and returns it in (*strp). Formal return value
N    * is the same as any other printf variant, except that it returns
N    * -1 if the buffer could not be allocated.
N    *
N    * (The functions with __ARM_ prefixed names are identical to the
N    * ones without, but are available in all compilation modes without
N    * violating user namespace.)
N    */
N
Nextern _ARMABI int fgetc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fgetc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the next character (if present) as an unsigned char converted to
N    * an int, from the input stream pointed to by stream, and advances the
N    * associated file position indicator (if defined).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and fgetc returns EOF. If a read error occurs, the error
N    *          indicator is set and fgetc returns EOF.
N    */
Nextern _ARMABI char *fgets(char * __restrict /*s*/, int /*n*/,
Xextern __declspec(__nothrow) char *fgets(char * __restrict  , int  ,
N                    FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads at most one less than the number of characters specified by n from
N    * the stream pointed to by stream into the array pointed to by s. No
N    * additional characters are read after a new-line character (which is
N    * retained) or after end-of-file. A null character is written immediately
N    * after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int fputc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int fputc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * writes the character specified by c (converted to an unsigned char) to
N    * the output stream pointed to by stream, at the position indicated by the
N    * asociated file position indicator (if defined), and advances the
N    * indicator appropriately. If the file position indicator is not defined,
N    * the character is appended to the output stream.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and fputc returns EOF.
N    */
Nextern _ARMABI int fputs(const char * __restrict /*s*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fputs(const char * __restrict  , FILE * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stream.
N    * The terminating null character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int getc(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int getc(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * is equivalent to fgetc except that it may be implemented as an unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the next character from the input stream pointed to by stream.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getc returns EOF. If a read error occurs, the error
N    *          indicator is set and getc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int getchar() { return getc(stdin); }
N#else
N    #define getchar() getc(stdin)
N    extern _ARMABI int (getchar)(void);
X    extern __declspec(__nothrow) int (getchar)(void);
N#endif
N   /*
N    * is equivalent to getc with the argument stdin.
N    * Returns: the next character from the input stream pointed to by stdin.
N    *          If the stream is at end-of-file, the end-of-file indicator is
N    *          set and getchar returns EOF. If a read error occurs, the error
N    *          indicator is set and getchar returns EOF.
N    */
Nextern _ARMABI char *gets(char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *gets(char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * reads characters from the input stream pointed to by stdin into the array
N    * pointed to by s, until end-of-file is encountered or a new-line character
N    * is read. Any new-line character is discarded, and a null character is
N    * written immediately after the last character read into the array.
N    * Returns: s if successful. If end-of-file is encountered and no characters
N    *          have been read into the array, the contents of the array remain
N    *          unchanged and a null pointer is returned. If a read error occurs
N    *          during the operation, the array contents are indeterminate and a
N    *          null pointer is returned.
N    */
Nextern _ARMABI int putc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int putc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * is equivalent to fputc except that it may be implemented as aan unsafe
N    * macro (stream may be evaluated more than once, so the argument should
N    * never be an expression with side-effects).
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
N#ifdef __cplusplus
S    inline int putchar(int __c) { return putc(__c, stdout); }
N#else
N    #define putchar(c) putc(c, stdout)
N    extern _ARMABI int (putchar)(int /*c*/);
X    extern __declspec(__nothrow) int (putchar)(int  );
N#endif
N   /*
N    * is equivalent to putc with the second argument stdout.
N    * Returns: the character written. If a write error occurs, the error
N    *          indicator is set and putc returns EOF.
N    */
Nextern _ARMABI int puts(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int puts(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * writes the string pointed to by s to the stream pointed to by stdout, and
N    * appends a new-line character to the output. The terminating null
N    * character is not written.
N    * Returns: EOF if a write error occurs; otherwise it returns a nonnegative
N    *          value.
N    */
Nextern _ARMABI int ungetc(int /*c*/, FILE * /*stream*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) int ungetc(int  , FILE *  ) __attribute__((__nonnull__(2)));
N   /*
N    * pushes the character specified by c (converted to an unsigned char) back
N    * onto the input stream pointed to by stream. The character will be
N    * returned by the next read on that stream. An intervening call to the
N    * fflush function or to a file positioning function (fseek, fsetpos,
N    * rewind) discards any pushed-back characters. The extern _ARMABIal storage
N    * corresponding to the stream is unchanged.
N    * One character pushback is guaranteed. If the unget function is called too
N    * many times on the same stream without an intervening read or file
N    * positioning operation on that stream, the operation may fail.
N    * If the value of c equals that of the macro EOF, the operation fails and
N    * the input stream is unchanged.
N    * A successful call to the ungetc function clears the end-of-file
N    * indicator. The value of the file position indicator after reading or
N    * discarding all pushed-back characters shall be the same as it was before
N    * the characters were pushed back. For a text stream, the value of the file
N    * position indicator after a successful call to the ungetc function is
N    * unspecified until all pushed-back characters are read or discarded. For a
N    * binary stream, the file position indicator is decremented by each
N    * successful call to the ungetc function; if its value was zero before a
N    * call, it is indeterminate after the call.
N    * Returns: the character pushed back after conversion, or EOF if the
N    *          operation fails.
N    */
N
Nextern _ARMABI size_t fread(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fread(void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * reads into the array pointed to by ptr, up to nmemb members whose size is
N    * specified by size, from the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully read. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate. If a partial member is read, its
N    * value is indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.
N    * Returns: the number of members successfully read, which may be less than
N    *          nmemb if a read error or end-of-file is encountered. If size or
N    *          nmemb is zero, fread returns zero and the contents of the array
N    *          and the state of the stream remain unchanged.
N    */
N
Nextern _ARMABI size_t __fread_bytes_avail(void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t __fread_bytes_avail(void * __restrict  ,
N                    size_t /*count*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,3)));
N   /*
N    * reads into the array pointed to by ptr, up to count characters from the
N    * stream pointed to by stream. The file position indicator (if defined)
N    * is advanced by the number of characters successfully read. If an error
N    * occurs, the resulting value of the file position indicator is
N    * indeterminate. The ferror or feof function shall be used to
N    * distinguish between a read error and end-of-file.  The call will block
N    * only if no characters are available.
N    * Returns: the number of characters successfully read, which may be less than
N    *          count. If count is zero, __fread_bytes_avail returns zero and
N    *          the contents of the array and the state of the stream remain
N    *          unchanged.
N    */
N
Nextern _ARMABI size_t fwrite(const void * __restrict /*ptr*/,
Xextern __declspec(__nothrow) size_t fwrite(const void * __restrict  ,
N                    size_t /*size*/, size_t /*nmemb*/, FILE * __restrict /*stream*/) __attribute__((__nonnull__(1,4)));
N   /*
N    * writes, from the array pointed to by ptr up to nmemb members whose size
N    * is specified by size, to the stream pointed to by stream. The file
N    * position indicator (if defined) is advanced by the number of characters
N    * successfully written. If an error occurs, the resulting value of the file
N    * position indicator is indeterminate.
N    * Returns: the number of members successfully written, which will be less
N    *          than nmemb only if a write error is encountered.
N    */
N
Nextern _ARMABI int fgetpos(FILE * __restrict /*stream*/, fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fgetpos(FILE * __restrict  , fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * stores the current value of the file position indicator for the stream
N    * pointed to by stream in the object pointed to by pos. The value stored
N    * contains unspecified information usable by the fsetpos function for
N    * repositioning the stream to its position at the time  of the call to the
N    * fgetpos function.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI int fseek(FILE * /*stream*/, long int /*offset*/, int /*whence*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int fseek(FILE *  , long int  , int  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream.
N    * For a binary stream, the new position is at the signed number of
N    * characters specified by offset away from the point specified by whence.
N    * The specified point is the beginning of the file for SEEK_SET, the
N    * current position in the file for SEEK_CUR, or end-of-file for SEEK_END.
N    * A binary stream need not meaningfully support fseek calls with a whence
N    * value of SEEK_END.
N    * For a text stream, either offset shall be zero, or offset shall be a
N    * value returned by an earlier call to the ftell function on the same
N    * stream and whence shall be SEEK_SET.
N    * The fseek function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fseek call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: nonzero only for a request that cannot be satisfied.
N    */
Nextern _ARMABI int fsetpos(FILE * __restrict /*stream*/, const fpos_t * __restrict /*pos*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int fsetpos(FILE * __restrict  , const fpos_t * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * sets  the file position indicator for the stream pointed to by stream
N    * according to the value of the object pointed to by pos, which shall be a
N    * value returned by an earlier call to the fgetpos function on the same
N    * stream.
N    * The fsetpos function clears the end-of-file indicator and undoes any
N    * effects of the ungetc function on the same stream. After an fsetpos call,
N    * the next operation on an update stream may be either input or output.
N    * Returns: zero, if successful. Otherwise nonzero is returned and the
N    *          integer expression errno is set to an implementation-defined
N    *          nonzero value.
N    */
Nextern _ARMABI long int ftell(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int ftell(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * obtains the current value of the file position indicator for the stream
N    * pointed to by stream. For a binary stream, the value is the number of
N    * characters from the beginning of the file. For a text stream, the file
N    * position indicator contains unspecified information, usable by the fseek
N    * function for returning the file position indicator to its position at the
N    * time of the ftell call; the difference between two such return values is
N    * not necessarily a meaningful measure of the number of characters written
N    * or read.
N    * Returns: if successful, the current value of the file position indicator.
N    *          On failure, the ftell function returns -1L and sets the integer
N    *          expression errno to an implementation-defined nonzero value.
N    */
Nextern _ARMABI void rewind(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void rewind(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * sets the file position indicator for the stream pointed to by stream to
N    * the beginning of the file. It is equivalent to
N    *          (void)fseek(stream, 0L, SEEK_SET)
N    * except that the error indicator for the stream is also cleared.
N    * Returns: no value.
N    */
N
Nextern _ARMABI void clearerr(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void clearerr(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * clears the end-of-file and error indicators for the stream pointed to by
N    * stream. These indicators are cleared only when the file is opened or by
N    * an explicit call to the clearerr function or to the rewind function.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int feof(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int feof(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the end-of-file indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the end-of-file indicator is set for stream.
N    */
Nextern _ARMABI int ferror(FILE * /*stream*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int ferror(FILE *  ) __attribute__((__nonnull__(1)));
N   /*
N    * tests the error indicator for the stream pointed to by stream.
N    * Returns: nonzero iff the error indicator is set for stream.
N    */
Nextern _ARMABI void perror(const char * /*s*/);
Xextern __declspec(__nothrow) void perror(const char *  );
N   /*
N    * maps the error number  in the integer expression errno to an error
N    * message. It writes a sequence of characters to the standard error stream
N    * thus: first (if s is not a null pointer and the character pointed to by
N    * s is not the null character), the string pointed to by s followed by a
N    * colon and a space; then an appropriate error message string followed by
N    * a new-line character. The contents of the error message strings are the
N    * same as those returned by the strerror function with argument errno,
N    * which are implementation-defined.
N    * Returns: no value.
N    */
N
Nextern _ARMABI int _fisatty(FILE * /*stream*/ ) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int _fisatty(FILE *   ) __attribute__((__nonnull__(1)));
N    /* Returns 1 if the stream is tty (stdin), 0 otherwise. Not ANSI compliant.
N     */
N
Nextern _ARMABI void __use_no_semihosting_swi(void);
Xextern __declspec(__nothrow) void __use_no_semihosting_swi(void);
Nextern _ARMABI void __use_no_semihosting(void);
Xextern __declspec(__nothrow) void __use_no_semihosting(void);
N    /*
N     * Referencing either of these symbols will cause a link-time
N     * error if any library functions that use semihosting SWI
N     * calls are also present in the link, i.e. you define it if
N     * you want to make sure you haven't accidentally used any such
N     * SWIs.
N     */
N
N    #ifdef __cplusplus
S        }  /* extern "C" */
S      }  /* namespace std */
N    #endif
N  #endif /* __STDIO_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #if defined(__cplusplus) && !defined(__STDIO_NO_EXPORTS)
X  #if 0L && !0L
S    using ::std::size_t;
S    using ::std::fpos_t;
S    using ::std::FILE;
S    using ::std::remove;
S    using ::std::rename;
S    using ::std::tmpfile;
S    using ::std::tmpnam;
S    using ::std::fclose;
S    using ::std::fflush;
S    using ::std::fopen;
S    using ::std::freopen;
S    using ::std::setbuf;
S    using ::std::setvbuf;
S    using ::std::fprintf;
S    using ::std::_fprintf;
S    using ::std::printf;
S    using ::std::_printf;
S    using ::std::sprintf;
S    using ::std::_sprintf;
S    #if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
S      using ::std::snprintf;
S      using ::std::vsnprintf;
S      using ::std::vfscanf;
S      using ::std::vscanf;
S      using ::std::vsscanf;
S    #endif
S    using ::std::_snprintf;
S    using ::std::_vsnprintf;
S#if !defined(__STRICT_ANSI__)
S    using ::std::asprintf;
S    using ::std::vasprintf;
S#endif
S    using ::std::__ARM_asprintf;
S    using ::std::__ARM_vasprintf;
S    using ::std::__ARM_vsnprintf;
S    using ::std::__ARM_snprintf;
S    using ::std::__ARM_vsscanf;
S    using ::std::fscanf;
S    using ::std::_fscanf;
S    using ::std::scanf;
S    using ::std::_scanf;
S    using ::std::sscanf;
S    using ::std::_sscanf;
S    using ::std::_vfscanf;
S    using ::std::_vscanf;
S    using ::std::_vsscanf;
S    using ::std::vprintf;
S    using ::std::_vprintf;
S    using ::std::vfprintf;
S    using ::std::_vfprintf;
S    using ::std::vsprintf;
S    using ::std::_vsprintf;
S    using ::std::fgetc;
S    using ::std::fgets;
S    using ::std::fputc;
S    using ::std::fputs;
S    using ::std::getc;
S    using ::std::getchar;
S    using ::std::gets;
S    using ::std::putc;
S    using ::std::putchar;
S    using ::std::puts;
S    using ::std::ungetc;
S    using ::std::fread;
S    using ::std::__fread_bytes_avail;
S    using ::std::fwrite;
S    using ::std::fgetpos;
S    using ::std::fseek;
S    using ::std::fsetpos;
S    using ::std::ftell;
S    using ::std::rewind;
S    using ::std::clearerr;
S    using ::std::feof;
S    using ::std::ferror;
S    using ::std::perror;
S    using ::std::_fisatty;
S    using ::std::__use_no_semihosting_swi;
S    using ::std::__use_no_semihosting;
N  #endif
N
N#endif /* ndef __stdio_h */
N
N/* end of stdio.h */
N
L 13 "Libraries\StdDriver\src\ps2.c" 2
N#include "NUC230_240.h"
L 1 ".\Libraries\Device\Nuvoton\NUC230_240\Include\NUC230_240.h" 1
N/**************************************************************************//**
N * @file     NUC230_240.h
N * @version  V3.0
N * $Revision: 39 $
N * $Date: 15/09/04 3:38p $
N * @brief    NUC230_240 Series Peripheral Access Layer Header File
N *
N * @note
N * Copyright (C) 2015 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N
N
N/**
N  \mainpage Introduction
N  *
N  *
N  * This user manual describes the usage of NUC230_240 Series MCU device driver
N  *
N  * <b>Disclaimer</b>
N  *
N  * The Software is furnished "AS IS", without warranty as to performance or results, and
N  * the entire risk as to performance or results is assumed by YOU. Nuvoton disclaims all
N  * warranties, express, implied or otherwise, with regard to the Software, its use, or
N  * operation, including without limitation any and all warranties of merchantability, fitness
N  * for a particular purpose, and non-infringement of intellectual property rights.
N  *
N  * <b>Copyright Notice</b>
N  *
N  * Copyright (C) 2015 Nuvoton Technology Corp. All rights reserved.
N  */
N
N/**
N  * \page PG_REV Revision History
N  *
N  * <b>Revision 3.01.001</b>
N  * \li Fixed the clock selection bug in SCUART_TxRx() sample code.
N  * \li Fixed the reset handler from __iar_program_start to Reset_Handler.
N  * \li Fixed the bug of clearing wrong enable bit in UART_SelectLINMode() of UART driver.
N  * \li Fixed CAN_STATUS_LEC_Msk from 0x03 to 0x07.
N  * \li Fixed SC_UACTL_UA_MODE_EN_Msk define error from (3ul << SC_UACTL_UA_MODE_EN_Pos) to (1ul << SC_UACTL_UA_MODE_EN_Pos).
N  * \li Fixed the wrong SC1 and SC2 clock source select shift position in MODULE constant definitions.
N  * \li Fixed the wrong definition bug of PS2_DISABLE_OVERRIDE() and PS2_ENABLE_OVERRIDE().
N  * \li Fixed the bug of PS2_Write() in PS2 driver.
N  * \li Removed ReadDID() function from FMC driver as It is no longer supported.
N  * \li Updated USB driver to improve reliability and compatibility.
N  * \li Added NuEdu sample code.
N  * \li Added INT 'MCUIRQ' and 'MCUIRQCR' bit field definitions.
N  * \li Added CLK_EnableSysTick() and CLK_DisableSysTick() to control SysTick and select SysTick clock source.
N  * \li Added SPI_FIFO_SIZE constant definition.
N  * \li Added USB device sample code.
N  * \li Improved USBD driver for adding more USB sample code.
N  *
N  * <b>Revision 3.00.002</b>
N  * \li Fixed the wrong baud rate returned by SCUART_SetLineConfig() in SCUART driver.
N  * \li Fixed SCUART_Open() of SCUART driver for wrong clock calculation and return value.
N  * \li Fixed SC_SET_STOP_BIT_LEN define error.
N  * \li Fixed the bug of ADC_IS_DATA_OVERRUN() that the input parameter is channel number but channel bit mask.
N  * \li Updated CAN clock setting in CAN_Open() of CAN driver to comply with different system clocks.
N  * \li Fixed the wrong return value bug of CLK_SetCoreClock() in CLK driver.
N  * \li Fixed CLK_SetModuleClock() error for PWM clock selection in CLK driver.
N  * \li Fixed the bug of CLK_SysTickDelay() that COUNTFLAG may not be cleared in CLK driver.
N  * \li Fixed the GPIO_ENABLE_DOUT_MASK() and GPIO_DISABLE_DOUT_MASK() implement inverse error in GPIO driver.
N  * \li Fixed the close wrong I2C bug of I2C_Close() in I2C driver.
N  * \li Fixed API declare name from I2C_SetClockBusFreq() to I2C_SetBusClockFreq() in I2C driver.
N  * \li Fixed the clear RS-485 address byte detection flag bug to clear one flag at one time in RS485_HANDLE() of UART driver.
N  * \li Added one more zero packet when BULK IN transfer is end by max packet size packet at last packet in VCOM sample code.
N  * \li Fixed UA_LIN_CTL[4] bit field name as 'MUTE_EN' not 'WAKE_EN' in UART LIN_CTL bit field definitions of header file.
N  * \li Fixed the wrong mask definition of SC_TRSR_TX_POINT_F_Msk and SC_TRSR_RX_POINT_F_Msk in header file.
N  * \li Fixed the wrong bit definition of WAKEUP_EN in USB_INTEN register of header file.
N  * \li Fixed the channel 0 trigger disabled bug when channel 1~3 trigger enabled in PWM_EnableADCTrigger() of PWM driver.
N  * \li Fixed the bug that channel 0 trigger will be disabled when channel 1~3 trigger are enabled in PWM_EnableADCTrigger() of PWM driver.
N  * \li Fixed SCUART_PARITY_NONE/SCUART_PARITY_EVEN/SCUART_PARITY_ODD definition bug in SCUART driver.
N  * \li Fixed four macro definitions of SPI driver to avoid affecting non-target SPI_SS pin including SPI_SET_SS0_HIGH() SPI_SET_SS1_HIGH() SPI_SET_SS0_LOW() SPI_SET_SS1_LOW().
N  * \li Fixed the clear flag bug to clear one flag at one time in UART_ClearIntFlag(). It should be '(uart)->FSR = UART_FSR_RS485_ADD_DETF_Msk' but '(uart)->FSR |= UART_FSR_RS485_ADD_DETF_Msk'.
N  * \li Fixed the clear wrong flag bug in UART_RS485_CLEAR_ADDR_FLAG().
N  * \li Fixed UA_LIN_CTL[4] bit field name as 'MUTE_EN' not 'WAKE_EN' in UA_LIN_CTL constants definitions in UART driver.
N  * \li Added SPI_SET_SS_LEVEL() macro definition in SPI driver to allow user to set both SPI_SS pins.
N  * \li Added a lack macro SYS_IS_LVR_RST() to SYS driver.
N  * 
N  * <b>Revision 3.00.001</b>
N  * \li Updated to support new API
N*/
N
N#ifndef __NUC230_240_H__
N#define __NUC230_240_H__
N
N/*
N * ==========================================================================
N * ---------- Interrupt Number Definition -----------------------------------
N * ==========================================================================
N*/
N
N/** @addtogroup CMSIS Device Definitions for CMSIS
N  Interrupt Number Definition and Configurations for CMSIS
N  @{
N*/
N
N/**
N * @details  Interrupt Number Definition. The maximum of 32 Specific Interrupts are possible.
N */
N
Ntypedef enum IRQn {
N    /******  Cortex-M0 Processor Exceptions Numbers ***************************************************/
N    NonMaskableInt_IRQn         = -14,    /*!< 2 Non Maskable Interrupt                             */
N    HardFault_IRQn              = -13,    /*!< 3 Cortex-M0 Hard Fault Interrupt                     */
N    SVCall_IRQn                 = -5,     /*!< 11 Cortex-M0 SV Call Interrupt                       */
N    PendSV_IRQn                 = -2,     /*!< 14 Cortex-M0 Pend SV Interrupt                       */
N    SysTick_IRQn                = -1,     /*!< 15 Cortex-M0 System Tick Interrupt                   */
N
N    /******  ARMIKMCU Swift specific Interrupt Numbers ************************************************/
N    BOD_IRQn                  = 0,        /*!< Brown-Out Low Voltage Detected Interrupt             */
N    WDT_IRQn                  = 1,        /*!< Watch Dog Timer Interrupt                            */
N    EINT0_IRQn                = 2,        /*!< EINT0 Interrupt                                      */
N    EINT1_IRQn                = 3,        /*!< EINT1 Interrupt                                      */
N    GPAB_IRQn                 = 4,        /*!< GPIO_PA/PB Interrupt                                 */
N    GPCDEF_IRQn               = 5,        /*!< GPIO_PC/PD/PE/PF Interrupt                           */
N    PWMA_IRQn                 = 6,        /*!< PWMA Interrupt                                       */
N    PWMB_IRQn                 = 7,        /*!< PWMB Interrupt                                       */
N    TMR0_IRQn                 = 8,        /*!< TIMER0 Interrupt                                     */
N    TMR1_IRQn                 = 9,        /*!< TIMER1 Interrupt                                     */
N    TMR2_IRQn                 = 10,       /*!< TIMER2 Interrupt                                     */
N    TMR3_IRQn                 = 11,       /*!< TIMER3 Interrupt                                     */
N    UART02_IRQn               = 12,       /*!< UART0/UART2 Interrupt                                */
N    UART1_IRQn                = 13,       /*!< UART1 Interrupt                                      */
N    SPI0_IRQn                 = 14,       /*!< SPI0 Interrupt                                       */
N    SPI1_IRQn                 = 15,       /*!< SPI1 Interrupt                                       */
N    SPI2_IRQn                 = 16,       /*!< SPI2 Interrupt                                       */
N    SPI3_IRQn                 = 17,       /*!< SPI3 Interrupt                                       */
N    I2C0_IRQn                 = 18,       /*!< I2C0 Interrupt                                       */
N    I2C1_IRQn                 = 19,       /*!< I2C1 Interrupt                                       */
N    CAN0_IRQn                 = 20,       /*!< CAN0 Interrupt                                       */
N    CAN1_IRQn                 = 21,       /*!< CAN1 Interrupt                                       */
N    SC012_IRQn                = 22,       /*!< SC0/SC1/SC2 Interrupt                                */
N    USBD_IRQn                 = 23,       /*!< USB device Interrupt                                 */
N    PS2_IRQn                  = 24,       /*!< PS/2 device Interrupt                                */
N    ACMP_IRQn                 = 25,       /*!< ACMP0 Interrupt                                      */
N    PDMA_IRQn                 = 26,       /*!< PDMA Interrupt                                       */
N    I2S_IRQn                  = 27,       /*!< I2S Interrupt                                        */
N    PWRWU_IRQn                = 28,       /*!< Power Down Wake Up Interrupt                         */
N    ADC_IRQn                  = 29,       /*!< ADC Interrupt                                        */
N    IRC_IRQn                  = 30,       /*!< IRC TRIM Interrupt                                   */
N    RTC_IRQn                  = 31        /*!< RTC Interrupt                                        */
N} IRQn_Type;
N
N
N/*
N * ==========================================================================
N * ----------- Processor and Core Peripheral Section ------------------------
N * ==========================================================================
N */
N
N/* Configuration of the Cortex-M0 Processor and Core Peripherals */
N#define __MPU_PRESENT           0       /*!< armikcmu does not provide a MPU present or not       */
N#define __NVIC_PRIO_BITS        2       /*!< armikcmu Supports 2 Bits for the Priority Levels     */
N#define __Vendor_SysTickConfig  0       /*!< Set to 1 if different SysTick Config is used         */
N
N
N/*@}*/ /* end of group CMSIS */
N
N
N#include "core_cm0.h"                   /* Cortex-M0 processor and core peripherals               */
L 1 ".\Libraries\CMSIS\Include\core_cm0.h" 1
N/**************************************************************************//**
N * @file     core_cm0.h
N * @brief    CMSIS Cortex-M0 Core Peripheral Access Layer Header File
N * @version  V3.01
N * @date     13. March 2012
N *
N * @note
N * Copyright (C) 2009-2012 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N#if defined ( __ICCARM__ )
X#if 0L
S #pragma system_include  /* treat file as system include file for MISRA check */
N#endif
N
N#ifdef __cplusplus
S extern "C" {
N#endif
N
N#ifndef __CORE_CM0_H_GENERIC
N#define __CORE_CM0_H_GENERIC
N
N/** @addtogroup CMSIS_Definitions CMSIS
N  @{
N*/
N
N/** \page CMSIS_MISRA_Exceptions  MISRA-C:2004 Compliance Exceptions
N  CMSIS violates the following MISRA-C:2004 rules:
N
N   \li Required Rule 8.5, object/function definition in header file.<br>
N     Function definitions in header files are used to allow 'inlining'.
N
N   \li Required Rule 18.4, declaration of union type or object of union type: '{...}'.<br>
N     Unions are used for effective representation of core registers.
N
N   \li Advisory Rule 19.7, Function-like macro defined.<br>
N     Function-like macros are used to allow more efficient code.
N */
N
N
N/*******************************************************************************
N *                 CMSIS definitions
N ******************************************************************************/
N/** \ingroup Cortex_M0
N  @{
N */
N
N/*  CMSIS CM0 definitions */
N#define __CM0_CMSIS_VERSION_MAIN  (0x03)                                   /*!< [31:16] CMSIS HAL main version   */
N#define __CM0_CMSIS_VERSION_SUB   (0x01)                                   /*!< [15:0]  CMSIS HAL sub version    */
N#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16) | \
N                                    __CM0_CMSIS_VERSION_SUB          )     /*!< CMSIS HAL version number         */
X#define __CM0_CMSIS_VERSION       ((__CM0_CMSIS_VERSION_MAIN << 16) |                                     __CM0_CMSIS_VERSION_SUB          )      
N
N#define __CORTEX_M                (0x00)                                   /*!< Cortex-M Core                    */
N
N
N#if   defined ( __CC_ARM )
X#if   1L
N  #define __ASM            __asm                                      /*!< asm keyword for ARM Compiler          */
N  #define __INLINE         __inline                                   /*!< inline keyword for ARM Compiler       */
N  #define __STATIC_INLINE  static __inline
N
N#elif defined ( __ICCARM__ )
S  #define __ASM            __asm                                      /*!< asm keyword for IAR Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for IAR Compiler. Only available in High optimization mode! */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __GNUC__ )
S  #define __ASM            __asm                                      /*!< asm keyword for GNU Compiler          */
S  #define __INLINE         inline                                     /*!< inline keyword for GNU Compiler       */
S  #define __STATIC_INLINE  static inline
S
S#elif defined ( __TASKING__ )
S  #define __ASM            __asm                                      /*!< asm keyword for TASKING Compiler      */
S  #define __INLINE         inline                                     /*!< inline keyword for TASKING Compiler   */
S  #define __STATIC_INLINE  static inline
S
N#endif
N
N/** __FPU_USED indicates whether an FPU is used or not. This core does not support an FPU at all
N*/
N#define __FPU_USED       0
N
N#if defined ( __CC_ARM )
X#if 1L
N  #if defined __TARGET_FPU_VFP
X  #if 0L
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
N  #endif
N
N#elif defined ( __ICCARM__ )
S  #if defined __ARMVFP__
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __GNUC__ )
S  #if defined (__VFP_FP__) && !defined(__SOFTFP__)
S    #warning "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
S
S#elif defined ( __TASKING__ )
S  #if defined __FPU_VFP__
S    #error "Compiler generates FPU instructions for a device without an FPU (check __FPU_PRESENT)"
S  #endif
N#endif
N
N#include <stdint.h>                      /* standard types definitions                      */
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdint.h" 1
N/* Copyright (C) ARM Ltd., 1999,2014 */
N/* All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdint_h
N#define __stdint_h
N#define __ARMCLIB_VERSION 5060016
N
N  #ifdef __INT64_TYPE__
S    /* armclang predefines '__INT64_TYPE__' and '__INT64_C_SUFFIX__' */
S    #define __INT64 __INT64_TYPE__
N  #else
N    /* armcc has builtin '__int64' which can be used in --strict mode */
N    #define __INT64 __int64
N    #define __INT64_C_SUFFIX__ ll
N  #endif
N  #define __PASTE2(x, y) x ## y
N  #define __PASTE(x, y) __PASTE2(x, y)
N  #define __INT64_C(x)  __ESCAPE__(__PASTE(x, __INT64_C_SUFFIX__))
N  #define __UINT64_C(x)  __ESCAPE__(__PASTE(x ## u, __INT64_C_SUFFIX__))
N  #if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X  #if 0L || (1L && !0L)
N    /* armclang and non-strict armcc allow 'long long' in system headers */
N    #define __LONGLONG long long
N  #else
S    /* strict armcc has '__int64' */
S    #define __LONGLONG __int64
N  #endif
N
N  #ifndef __STDINT_DECLS
N  #define __STDINT_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N
N/*
N * 'signed' is redundant below, except for 'signed char' and if
N * the typedef is used to declare a bitfield.
N */
N
N    /* 7.18.1.1 */
N
N    /* exact-width signed integer types */
Ntypedef   signed          char int8_t;
Ntypedef   signed short     int int16_t;
Ntypedef   signed           int int32_t;
Ntypedef   signed       __INT64 int64_t;
Xtypedef   signed       __int64 int64_t;
N
N    /* exact-width unsigned integer types */
Ntypedef unsigned          char uint8_t;
Ntypedef unsigned short     int uint16_t;
Ntypedef unsigned           int uint32_t;
Ntypedef unsigned       __INT64 uint64_t;
Xtypedef unsigned       __int64 uint64_t;
N
N    /* 7.18.1.2 */
N
N    /* smallest type of at least n bits */
N    /* minimum-width signed integer types */
Ntypedef   signed          char int_least8_t;
Ntypedef   signed short     int int_least16_t;
Ntypedef   signed           int int_least32_t;
Ntypedef   signed       __INT64 int_least64_t;
Xtypedef   signed       __int64 int_least64_t;
N
N    /* minimum-width unsigned integer types */
Ntypedef unsigned          char uint_least8_t;
Ntypedef unsigned short     int uint_least16_t;
Ntypedef unsigned           int uint_least32_t;
Ntypedef unsigned       __INT64 uint_least64_t;
Xtypedef unsigned       __int64 uint_least64_t;
N
N    /* 7.18.1.3 */
N
N    /* fastest minimum-width signed integer types */
Ntypedef   signed           int int_fast8_t;
Ntypedef   signed           int int_fast16_t;
Ntypedef   signed           int int_fast32_t;
Ntypedef   signed       __INT64 int_fast64_t;
Xtypedef   signed       __int64 int_fast64_t;
N
N    /* fastest minimum-width unsigned integer types */
Ntypedef unsigned           int uint_fast8_t;
Ntypedef unsigned           int uint_fast16_t;
Ntypedef unsigned           int uint_fast32_t;
Ntypedef unsigned       __INT64 uint_fast64_t;
Xtypedef unsigned       __int64 uint_fast64_t;
N
N    /* 7.18.1.4 integer types capable of holding object pointers */
N#if __sizeof_ptr == 8
X#if 4 == 8
Stypedef   signed       __INT64 intptr_t;
Stypedef unsigned       __INT64 uintptr_t;
N#else
Ntypedef   signed           int intptr_t;
Ntypedef unsigned           int uintptr_t;
N#endif
N
N    /* 7.18.1.5 greatest-width integer types */
Ntypedef   signed     __LONGLONG intmax_t;
Xtypedef   signed     long long intmax_t;
Ntypedef unsigned     __LONGLONG uintmax_t;
Xtypedef unsigned     long long uintmax_t;
N
N
N#if !defined(__cplusplus) || defined(__STDC_LIMIT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.2.1 */
N
N    /* minimum values of exact-width signed integer types */
N#define INT8_MIN                   -128
N#define INT16_MIN                -32768
N#define INT32_MIN          (~0x7fffffff)   /* -2147483648 is unsigned */
N#define INT64_MIN  __INT64_C(~0x7fffffffffffffff) /* -9223372036854775808 is unsigned */
N
N    /* maximum values of exact-width signed integer types */
N#define INT8_MAX                    127
N#define INT16_MAX                 32767
N#define INT32_MAX            2147483647
N#define INT64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of exact-width unsigned integer types */
N#define UINT8_MAX                   255
N#define UINT16_MAX                65535
N#define UINT32_MAX           4294967295u
N#define UINT64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.2 */
N
N    /* minimum values of minimum-width signed integer types */
N#define INT_LEAST8_MIN                   -128
N#define INT_LEAST16_MIN                -32768
N#define INT_LEAST32_MIN          (~0x7fffffff)
N#define INT_LEAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of minimum-width signed integer types */
N#define INT_LEAST8_MAX                    127
N#define INT_LEAST16_MAX                 32767
N#define INT_LEAST32_MAX            2147483647
N#define INT_LEAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of minimum-width unsigned integer types */
N#define UINT_LEAST8_MAX                   255
N#define UINT_LEAST16_MAX                65535
N#define UINT_LEAST32_MAX           4294967295u
N#define UINT_LEAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.3 */
N
N    /* minimum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MIN           (~0x7fffffff)
N#define INT_FAST16_MIN          (~0x7fffffff)
N#define INT_FAST32_MIN          (~0x7fffffff)
N#define INT_FAST64_MIN  __INT64_C(~0x7fffffffffffffff)
N
N    /* maximum values of fastest minimum-width signed integer types */
N#define INT_FAST8_MAX             2147483647
N#define INT_FAST16_MAX            2147483647
N#define INT_FAST32_MAX            2147483647
N#define INT_FAST64_MAX  __INT64_C(9223372036854775807)
N
N    /* maximum values of fastest minimum-width unsigned integer types */
N#define UINT_FAST8_MAX            4294967295u
N#define UINT_FAST16_MAX           4294967295u
N#define UINT_FAST32_MAX           4294967295u
N#define UINT_FAST64_MAX __UINT64_C(18446744073709551615)
N
N    /* 7.18.2.4 */
N
N    /* minimum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MIN INT64_MIN
N#else
N#define INTPTR_MIN INT32_MIN
N#endif
N
N    /* maximum value of pointer-holding signed integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define INTPTR_MAX INT64_MAX
N#else
N#define INTPTR_MAX INT32_MAX
N#endif
N
N    /* maximum value of pointer-holding unsigned integer type */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define UINTPTR_MAX UINT64_MAX
N#else
N#define UINTPTR_MAX UINT32_MAX
N#endif
N
N    /* 7.18.2.5 */
N
N    /* minimum value of greatest-width signed integer type */
N#define INTMAX_MIN  __ESCAPE__(~0x7fffffffffffffffll)
N
N    /* maximum value of greatest-width signed integer type */
N#define INTMAX_MAX  __ESCAPE__(9223372036854775807ll)
N
N    /* maximum value of greatest-width unsigned integer type */
N#define UINTMAX_MAX __ESCAPE__(18446744073709551615ull)
N
N    /* 7.18.3 */
N
N    /* limits of ptrdiff_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define PTRDIFF_MIN INT64_MIN
S#define PTRDIFF_MAX INT64_MAX
N#else
N#define PTRDIFF_MIN INT32_MIN
N#define PTRDIFF_MAX INT32_MAX
N#endif
N
N    /* limits of sig_atomic_t */
N#define SIG_ATOMIC_MIN (~0x7fffffff)
N#define SIG_ATOMIC_MAX   2147483647
N
N    /* limit of size_t */
N#if __sizeof_ptr == 8
X#if 4 == 8
S#define SIZE_MAX UINT64_MAX
N#else
N#define SIZE_MAX UINT32_MAX
N#endif
N
N    /* limits of wchar_t */
N    /* NB we have to undef and redef because they're defined in both
N     * stdint.h and wchar.h */
N#undef WCHAR_MIN
N#undef WCHAR_MAX
N
N#if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X#if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S  #define WCHAR_MIN   0
S  #define WCHAR_MAX   0xffffffffU
N#else
N  #define WCHAR_MIN   0
N  #define WCHAR_MAX   65535
N#endif
N
N    /* limits of wint_t */
N#define WINT_MIN (~0x7fffffff)
N#define WINT_MAX 2147483647
N
N#endif /* __STDC_LIMIT_MACROS */
N
N#if !defined(__cplusplus) || defined(__STDC_CONSTANT_MACROS)
X#if !0L || 0L
N
N    /* 7.18.4.1 macros for minimum-width integer constants */
N#define INT8_C(x)   (x)
N#define INT16_C(x)  (x)
N#define INT32_C(x)  (x)
N#define INT64_C(x)  __INT64_C(x)
N
N#define UINT8_C(x)  (x ## u)
N#define UINT16_C(x) (x ## u)
N#define UINT32_C(x) (x ## u)
N#define UINT64_C(x) __UINT64_C(x)
N
N    /* 7.18.4.2 macros for greatest-width integer constants */
N#define INTMAX_C(x)  __ESCAPE__(x ## ll)
N#define UINTMAX_C(x) __ESCAPE__(x ## ull)
N
N#endif /* __STDC_CONSTANT_MACROS */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDINT_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDINT_NO_EXPORTS
S      using ::std::int8_t;
S      using ::std::int16_t;
S      using ::std::int32_t;
S      using ::std::int64_t;
S      using ::std::uint8_t;
S      using ::std::uint16_t;
S      using ::std::uint32_t;
S      using ::std::uint64_t;
S      using ::std::int_least8_t;
S      using ::std::int_least16_t;
S      using ::std::int_least32_t;
S      using ::std::int_least64_t;
S      using ::std::uint_least8_t;
S      using ::std::uint_least16_t;
S      using ::std::uint_least32_t;
S      using ::std::uint_least64_t;
S      using ::std::int_fast8_t;
S      using ::std::int_fast16_t;
S      using ::std::int_fast32_t;
S      using ::std::int_fast64_t;
S      using ::std::uint_fast8_t;
S      using ::std::uint_fast16_t;
S      using ::std::uint_fast32_t;
S      using ::std::uint_fast64_t;
S      using ::std::intptr_t;
S      using ::std::uintptr_t;
S      using ::std::intmax_t;
S      using ::std::uintmax_t;
S    #endif
N  #endif /* __cplusplus */
N
N#undef __INT64
N#undef __LONGLONG
N
N#endif /* __stdint_h */
N
N/* end of stdint.h */
L 116 ".\Libraries\CMSIS\Include\core_cm0.h" 2
N#include <core_cmInstr.h>                /* Core Instruction Access                         */
L 1 ".\Libraries\CMSIS\Include\core_cmInstr.h" 1
N/**************************************************************************//**
N * @file     core_cmInstr.h
N * @brief    CMSIS Cortex-M Core Instruction Access Header File
N * @version  V3.01
N * @date     06. March 2012
N *
N * @note
N * Copyright (C) 2009-2012 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CORE_CMINSTR_H
N#define __CORE_CMINSTR_H
N
N/** @addtogroup CMSIS_Definitions CMSIS
N  @{
N*/
N
N
N/* ##########################  Core Instruction Access  ######################### */
N/** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
N  Access to dedicated instructions
N  @{
N*/
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5060300 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N
N/** \brief  No Operation
N
N    No Operation does nothing. This instruction can be used for code alignment purposes.
N */
N#define __NOP                             __nop
N
N
N/** \brief  Wait For Interrupt
N
N    Wait For Interrupt is a hint instruction that suspends execution
N    until one of a number of events occurs.
N */
N#define __WFI                             __wfi
N
N
N/** \brief  Wait For Event
N
N    Wait For Event is a hint instruction that permits the processor to enter
N    a low-power state until one of a number of events occurs.
N */
N#define __WFE                             __wfe
N
N
N/** \brief  Send Event
N
N    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
N */
N#define __SEV                             __sev
N
N
N/** \brief  Instruction Synchronization Barrier
N
N    Instruction Synchronization Barrier flushes the pipeline in the processor,
N    so that all instructions following the ISB are fetched from cache or
N    memory, after the instruction has been completed.
N */
N#define __ISB()                           __isb(0xF)
N
N
N/** \brief  Data Synchronization Barrier
N
N    This function acts as a special kind of Data Memory Barrier.
N    It completes when all explicit memory accesses before this instruction complete.
N */
N#define __DSB()                           __dsb(0xF)
N
N
N/** \brief  Data Memory Barrier
N
N    This function ensures the apparent order of the explicit memory operations before
N    and after the instruction, without ensuring their completion.
N */
N#define __DMB()                           __dmb(0xF)
N
N
N/** \brief  Reverse byte order (32 bit)
N
N    This function reverses the byte order in integer value.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N#define __REV                             __rev
N
N
N/** \brief  Reverse byte order (16 bit)
N
N    This function reverses the byte order in two unsigned short values.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N__attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
X__attribute__((section(".rev16_text"))) static __inline __asm uint32_t __REV16(uint32_t value)
N{
N  rev16 r0, r0
N  bx lr
N}
N
N
N/** \brief  Reverse byte order in signed short value
N
N    This function reverses the byte order in a signed short value with sign extension to integer.
N
N    \param [in]    value  Value to reverse
N    \return               Reversed value
N */
N__attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
X__attribute__((section(".revsh_text"))) static __inline __asm int32_t __REVSH(int32_t value)
N{
N  revsh r0, r0
N  bx lr
N}
N
N
N/** \brief  Rotate Right in unsigned value (32 bit)
N
N    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
N
N    \param [in]    value  Value to rotate
N    \param [in]    value  Number of Bits to rotate
N    \return               Rotated value
N */
N#define __ROR                             __ror
N
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x00) >= 0x03)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S#define __RBIT                            __rbit
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function performs a exclusive LDR command for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S#define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function performs a exclusive LDR command for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S#define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function performs a exclusive LDR command for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S#define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function performs a exclusive STR command for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXB(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function performs a exclusive STR command for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXH(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function performs a exclusive STR command for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S#define __STREXW(value, ptr)              __strex(value, ptr)
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S#define __CLREX                           __clrex
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT                            __ssat
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT                            __usat
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S#define __CLZ                             __clz
S
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N
N#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/** \brief  No Operation
S
S    No Operation does nothing. This instruction can be used for code alignment purposes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
S{
S  __ASM volatile ("nop");
S}
S
S
S/** \brief  Wait For Interrupt
S
S    Wait For Interrupt is a hint instruction that suspends execution
S    until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFI(void)
S{
S  __ASM volatile ("wfi");
S}
S
S
S/** \brief  Wait For Event
S
S    Wait For Event is a hint instruction that permits the processor to enter
S    a low-power state until one of a number of events occurs.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __WFE(void)
S{
S  __ASM volatile ("wfe");
S}
S
S
S/** \brief  Send Event
S
S    Send Event is a hint instruction. It causes an event to be signaled to the CPU.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __SEV(void)
S{
S  __ASM volatile ("sev");
S}
S
S
S/** \brief  Instruction Synchronization Barrier
S
S    Instruction Synchronization Barrier flushes the pipeline in the processor,
S    so that all instructions following the ISB are fetched from cache or
S    memory, after the instruction has been completed.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __ISB(void)
S{
S  __ASM volatile ("isb");
S}
S
S
S/** \brief  Data Synchronization Barrier
S
S    This function acts as a special kind of Data Memory Barrier.
S    It completes when all explicit memory accesses before this instruction complete.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
S{
S  __ASM volatile ("dsb");
S}
S
S
S/** \brief  Data Memory Barrier
S
S    This function ensures the apparent order of the explicit memory operations before
S    and after the instruction, without ensuring their completion.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __DMB(void)
S{
S  __ASM volatile ("dmb");
S}
S
S
S/** \brief  Reverse byte order (32 bit)
S
S    This function reverses the byte order in integer value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rev %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order (16 bit)
S
S    This function reverses the byte order in two unsigned short values.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __REV16(uint32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("rev16 %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S/** \brief  Reverse byte order in signed short value
S
S    This function reverses the byte order in a signed short value with sign extension to integer.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE int32_t __REVSH(int32_t value)
S{
S  uint32_t result;
S
S  __ASM volatile ("revsh %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S
S/** \brief  Rotate Right in unsigned value (32 bit)
S
S    This function Rotate Right (immediate) provides the value of the contents of a register rotated by a variable number of bits.
S
S    \param [in]    value  Value to rotate
S    \param [in]    value  Number of Bits to rotate
S    \return               Rotated value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __ROR(uint32_t op1, uint32_t op2)
S{
S
S  __ASM volatile ("ror %0, %0, %1" : "+r" (op1) : "r" (op2) );
S  return(op1);
S}
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Reverse bit order of value
S
S    This function reverses the bit order of the given value.
S
S    \param [in]    value  Value to reverse
S    \return               Reversed value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __RBIT(uint32_t value)
S{
S  uint32_t result;
S
S   __ASM volatile ("rbit %0, %1" : "=r" (result) : "r" (value) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (8 bit)
S
S    This function performs a exclusive LDR command for 8 bit value.
S
S    \param [in]    ptr  Pointer to data
S    \return             value of type uint8_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __LDREXB(volatile uint8_t *addr)
S{
S    uint8_t result;
S
S   __ASM volatile ("ldrexb %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (16 bit)
S
S    This function performs a exclusive LDR command for 16 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint16_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint16_t __LDREXH(volatile uint16_t *addr)
S{
S    uint16_t result;
S
S   __ASM volatile ("ldrexh %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  LDR Exclusive (32 bit)
S
S    This function performs a exclusive LDR command for 32 bit values.
S
S    \param [in]    ptr  Pointer to data
S    \return        value of type uint32_t at (*ptr)
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __LDREXW(volatile uint32_t *addr)
S{
S    uint32_t result;
S
S   __ASM volatile ("ldrex %0, [%1]" : "=r" (result) : "r" (addr) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (8 bit)
S
S    This function performs a exclusive STR command for 8 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXB(uint8_t value, volatile uint8_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexb %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (16 bit)
S
S    This function performs a exclusive STR command for 16 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXH(uint16_t value, volatile uint16_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strexh %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  STR Exclusive (32 bit)
S
S    This function performs a exclusive STR command for 32 bit values.
S
S    \param [in]  value  Value to store
S    \param [in]    ptr  Pointer to location
S    \return          0  Function succeeded
S    \return          1  Function failed
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __STREXW(uint32_t value, volatile uint32_t *addr)
S{
S   uint32_t result;
S
S   __ASM volatile ("strex %0, %2, [%1]" : "=&r" (result) : "r" (addr), "r" (value) );
S   return(result);
S}
S
S
S/** \brief  Remove the exclusive lock
S
S    This function removes the exclusive lock which is created by LDREX.
S
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __CLREX(void)
S{
S  __ASM volatile ("clrex");
S}
S
S
S/** \brief  Signed Saturate
S
S    This function saturates a signed value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (1..32)
S    \return             Saturated value
S */
S#define __SSAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __SSAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("ssat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Unsigned Saturate
S
S    This function saturates an unsigned value.
S
S    \param [in]  value  Value to be saturated
S    \param [in]    sat  Bit position to saturate to (0..31)
S    \return             Saturated value
S */
S#define __USAT(ARG1,ARG2) \
S({                          \
S  uint32_t __RES, __ARG1 = (ARG1); \
S  __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) ); \
S  __RES; \
S })
X#define __USAT(ARG1,ARG2) ({                            uint32_t __RES, __ARG1 = (ARG1);   __ASM ("usat %0, %1, %2" : "=r" (__RES) :  "I" (ARG2), "r" (__ARG1) );   __RES;  })
S
S
S/** \brief  Count leading zeros
S
S    This function counts the number of leading zeros of a data value.
S
S    \param [in]  value  Value to count the leading zeros
S    \return             number of leading zeros in value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint8_t __CLZ(uint32_t value)
S{
S  uint8_t result;
S
S  __ASM volatile ("clz %0, %1" : "=r" (result) : "r" (value) );
S  return(result);
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all intrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N/*@}*/ /* end of group CMSIS_Core_InstructionInterface */
N
N/*@}*/ /* end of group CMSIS_Definitions */
N
N#endif /* __CORE_CMINSTR_H */
L 117 ".\Libraries\CMSIS\Include\core_cm0.h" 2
N#include <core_cmFunc.h>                 /* Core Function Access                            */
L 1 ".\Libraries\CMSIS\Include\core_cmFunc.h" 1
N/**************************************************************************//**
N * @file     core_cmFunc.h
N * @brief    CMSIS Cortex-M Core Function Access Header File
N * @version  V3.01
N * @date     06. March 2012
N *
N * @note
N * Copyright (C) 2009-2012 ARM Limited. All rights reserved.
N *
N * @par
N * ARM Limited (ARM) is supplying this software for use with Cortex-M
N * processor based microcontrollers.  This file can be freely distributed
N * within development tools that are supporting such ARM based processors.
N *
N * @par
N * THIS SOFTWARE IS PROVIDED "AS IS".  NO WARRANTIES, WHETHER EXPRESS, IMPLIED
N * OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, IMPLIED WARRANTIES OF
N * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE APPLY TO THIS SOFTWARE.
N * ARM SHALL NOT, IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL, OR
N * CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
N *
N ******************************************************************************/
N
N#ifndef __CORE_CMFUNC_H
N#define __CORE_CMFUNC_H
N
N/** @addtogroup CMSIS_Definitions CMSIS
N  @{
N*/
N
N/* ###########################  Core Function Access  ########################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_RegAccFunctions CMSIS Core Register Access Functions
N  @{
N */
N
N#if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
X#if   1L  
N/* ARM armcc specific functions */
N
N#if (__ARMCC_VERSION < 400677)
X#if (5060300 < 400677)
S  #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
N#endif
N
N/* intrinsic void __enable_irq();     */
N/* intrinsic void __disable_irq();    */
N
N/** \brief  Get Control Register
N
N    This function returns the content of the Control Register.
N
N    \return               Control Register value
N */
N__STATIC_INLINE uint32_t __get_CONTROL(void)
Xstatic __inline uint32_t __get_CONTROL(void)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  return(__regControl);
N}
N
N
N/** \brief  Set Control Register
N
N    This function writes the given value to the Control Register.
N
N    \param [in]    control  Control Register value to set
N */
N__STATIC_INLINE void __set_CONTROL(uint32_t control)
Xstatic __inline void __set_CONTROL(uint32_t control)
N{
N  register uint32_t __regControl         __ASM("control");
X  register uint32_t __regControl         __asm("control");
N  __regControl = control;
N}
N
N
N/** \brief  Get IPSR Register
N
N    This function returns the content of the IPSR Register.
N
N    \return               IPSR Register value
N */
N__STATIC_INLINE uint32_t __get_IPSR(void)
Xstatic __inline uint32_t __get_IPSR(void)
N{
N  register uint32_t __regIPSR          __ASM("ipsr");
X  register uint32_t __regIPSR          __asm("ipsr");
N  return(__regIPSR);
N}
N
N
N/** \brief  Get APSR Register
N
N    This function returns the content of the APSR Register.
N
N    \return               APSR Register value
N */
N__STATIC_INLINE uint32_t __get_APSR(void)
Xstatic __inline uint32_t __get_APSR(void)
N{
N  register uint32_t __regAPSR          __ASM("apsr");
X  register uint32_t __regAPSR          __asm("apsr");
N  return(__regAPSR);
N}
N
N
N/** \brief  Get xPSR Register
N
N    This function returns the content of the xPSR Register.
N
N    \return               xPSR Register value
N */
N__STATIC_INLINE uint32_t __get_xPSR(void)
Xstatic __inline uint32_t __get_xPSR(void)
N{
N  register uint32_t __regXPSR          __ASM("xpsr");
X  register uint32_t __regXPSR          __asm("xpsr");
N  return(__regXPSR);
N}
N
N
N/** \brief  Get Process Stack Pointer
N
N    This function returns the current value of the Process Stack Pointer (PSP).
N
N    \return               PSP Register value
N */
N__STATIC_INLINE uint32_t __get_PSP(void)
Xstatic __inline uint32_t __get_PSP(void)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  return(__regProcessStackPointer);
N}
N
N
N/** \brief  Set Process Stack Pointer
N
N    This function assigns the given value to the Process Stack Pointer (PSP).
N
N    \param [in]    topOfProcStack  Process Stack Pointer value to set
N */
N__STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
Xstatic __inline void __set_PSP(uint32_t topOfProcStack)
N{
N  register uint32_t __regProcessStackPointer  __ASM("psp");
X  register uint32_t __regProcessStackPointer  __asm("psp");
N  __regProcessStackPointer = topOfProcStack;
N}
N
N
N/** \brief  Get Main Stack Pointer
N
N    This function returns the current value of the Main Stack Pointer (MSP).
N
N    \return               MSP Register value
N */
N__STATIC_INLINE uint32_t __get_MSP(void)
Xstatic __inline uint32_t __get_MSP(void)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  return(__regMainStackPointer);
N}
N
N
N/** \brief  Set Main Stack Pointer
N
N    This function assigns the given value to the Main Stack Pointer (MSP).
N
N    \param [in]    topOfMainStack  Main Stack Pointer value to set
N */
N__STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
Xstatic __inline void __set_MSP(uint32_t topOfMainStack)
N{
N  register uint32_t __regMainStackPointer     __ASM("msp");
X  register uint32_t __regMainStackPointer     __asm("msp");
N  __regMainStackPointer = topOfMainStack;
N}
N
N
N/** \brief  Get Priority Mask
N
N    This function returns the current state of the priority mask bit from the Priority Mask Register.
N
N    \return               Priority Mask value
N */
N__STATIC_INLINE uint32_t __get_PRIMASK(void)
Xstatic __inline uint32_t __get_PRIMASK(void)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  return(__regPriMask);
N}
N
N
N/** \brief  Set Priority Mask
N
N    This function assigns the given value to the Priority Mask Register.
N
N    \param [in]    priMask  Priority Mask
N */
N__STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
Xstatic __inline void __set_PRIMASK(uint32_t priMask)
N{
N  register uint32_t __regPriMask         __ASM("primask");
X  register uint32_t __regPriMask         __asm("primask");
N  __regPriMask = (priMask);
N}
N
N
N#if       (__CORTEX_M >= 0x03)
X#if       ((0x00) >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S#define __enable_fault_irq                __enable_fiq
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S#define __disable_fault_irq               __disable_fiq
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__STATIC_INLINE uint32_t  __get_BASEPRI(void)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  return(__regBasePri);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__STATIC_INLINE void __set_BASEPRI(uint32_t basePri)
S{
S  register uint32_t __regBasePri         __ASM("basepri");
S  __regBasePri = (basePri & 0xff);
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  return(__regFaultMask);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  register uint32_t __regFaultMask       __ASM("faultmask");
S  __regFaultMask = (faultMask & (uint32_t)1);
S}
S
N#endif /* (__CORTEX_M >= 0x03) */
N
N
N#if       (__CORTEX_M == 0x04)
X#if       ((0x00) == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  return(__regfpscr);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  register uint32_t __regfpscr         __ASM("fpscr");
S  __regfpscr = (fpscr);
S#endif
S}
S
N#endif /* (__CORTEX_M == 0x04) */
N
N
N#elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
S/* IAR iccarm specific functions */
S
S#include <cmsis_iar.h>
S
S
S#elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
S/* TI CCS specific functions */
S
S#include <cmsis_ccs.h>
S
S
S#elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
S/* GNU gcc specific functions */
S
S/** \brief  Enable IRQ Interrupts
S
S  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
S{
S  __ASM volatile ("cpsie i");
S}
S
S
S/** \brief  Disable IRQ Interrupts
S
S  This function disables IRQ interrupts by setting the I-bit in the CPSR.
S  Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
S{
S  __ASM volatile ("cpsid i");
S}
S
S
S/** \brief  Get Control Register
S
S    This function returns the content of the Control Register.
S
S    \return               Control Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_CONTROL(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, control" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Control Register
S
S    This function writes the given value to the Control Register.
S
S    \param [in]    control  Control Register value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_CONTROL(uint32_t control)
S{
S  __ASM volatile ("MSR control, %0" : : "r" (control) );
S}
S
S
S/** \brief  Get IPSR Register
S
S    This function returns the content of the IPSR Register.
S
S    \return               IPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get APSR Register
S
S    This function returns the content of the APSR Register.
S
S    \return               APSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_APSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, apsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get xPSR Register
S
S    This function returns the content of the xPSR Register.
S
S    \return               xPSR Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_xPSR(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, xpsr" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Get Process Stack Pointer
S
S    This function returns the current value of the Process Stack Pointer (PSP).
S
S    \return               PSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Process Stack Pointer
S
S    This function assigns the given value to the Process Stack Pointer (PSP).
S
S    \param [in]    topOfProcStack  Process Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
S{
S  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) );
S}
S
S
S/** \brief  Get Main Stack Pointer
S
S    This function returns the current value of the Main Stack Pointer (MSP).
S
S    \return               MSP Register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_MSP(void)
S{
S  register uint32_t result;
S
S  __ASM volatile ("MRS %0, msp\n" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Main Stack Pointer
S
S    This function assigns the given value to the Main Stack Pointer (MSP).
S
S    \param [in]    topOfMainStack  Main Stack Pointer value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_MSP(uint32_t topOfMainStack)
S{
S  __ASM volatile ("MSR msp, %0\n" : : "r" (topOfMainStack) );
S}
S
S
S/** \brief  Get Priority Mask
S
S    This function returns the current state of the priority mask bit from the Priority Mask Register.
S
S    \return               Priority Mask value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PRIMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, primask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Priority Mask
S
S    This function assigns the given value to the Priority Mask Register.
S
S    \param [in]    priMask  Priority Mask
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PRIMASK(uint32_t priMask)
S{
S  __ASM volatile ("MSR primask, %0" : : "r" (priMask) );
S}
S
S
S#if       (__CORTEX_M >= 0x03)
S
S/** \brief  Enable FIQ
S
S    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_fault_irq(void)
S{
S  __ASM volatile ("cpsie f");
S}
S
S
S/** \brief  Disable FIQ
S
S    This function disables FIQ interrupts by setting the F-bit in the CPSR.
S    Can only be executed in Privileged modes.
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_fault_irq(void)
S{
S  __ASM volatile ("cpsid f");
S}
S
S
S/** \brief  Get Base Priority
S
S    This function returns the current value of the Base Priority register.
S
S    \return               Base Priority register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, basepri_max" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Base Priority
S
S    This function assigns the given value to the Base Priority register.
S
S    \param [in]    basePri  Base Priority value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
S{
S  __ASM volatile ("MSR basepri, %0" : : "r" (value) );
S}
S
S
S/** \brief  Get Fault Mask
S
S    This function returns the current value of the Fault Mask register.
S
S    \return               Fault Mask register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FAULTMASK(void)
S{
S  uint32_t result;
S
S  __ASM volatile ("MRS %0, faultmask" : "=r" (result) );
S  return(result);
S}
S
S
S/** \brief  Set Fault Mask
S
S    This function assigns the given value to the Fault Mask register.
S
S    \param [in]    faultMask  Fault Mask value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FAULTMASK(uint32_t faultMask)
S{
S  __ASM volatile ("MSR faultmask, %0" : : "r" (faultMask) );
S}
S
S#endif /* (__CORTEX_M >= 0x03) */
S
S
S#if       (__CORTEX_M == 0x04)
S
S/** \brief  Get FPSCR
S
S    This function returns the current value of the Floating Point Status/Control register.
S
S    \return               Floating Point Status/Control register value
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_FPSCR(void)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  uint32_t result;
S
S  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
S  return(result);
S#else
S   return(0);
S#endif
S}
S
S
S/** \brief  Set FPSCR
S
S    This function assigns the given value to the Floating Point Status/Control register.
S
S    \param [in]    fpscr  Floating Point Status/Control value to set
S */
S__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_FPSCR(uint32_t fpscr)
S{
S#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
S  __ASM volatile ("VMSR fpscr, %0" : : "r" (fpscr) );
S#endif
S}
S
S#endif /* (__CORTEX_M == 0x04) */
S
S
S#elif defined ( __TASKING__ ) /*------------------ TASKING Compiler --------------*/
S/* TASKING carm specific functions */
S
S/*
S * The CMSIS functions have been implemented as intrinsics in the compiler.
S * Please use "carm -?i" to get an up to date list of all instrinsics,
S * Including the CMSIS ones.
S */
S
N#endif
N
N/*@} end of CMSIS_Core_RegAccFunctions */
N
N/*@}*/ /* end of group CMSIS_Definitions */
N
N#endif /* __CORE_CMFUNC_H */
L 118 ".\Libraries\CMSIS\Include\core_cm0.h" 2
N
N#endif /* __CORE_CM0_H_GENERIC */
N
N#ifndef __CMSIS_GENERIC
N
N#ifndef __CORE_CM0_H_DEPENDANT
N#define __CORE_CM0_H_DEPENDANT
N
N/* check device defines and use defaults */
N#if defined __CHECK_DEVICE_DEFINES
X#if 0L
S  #ifndef __CM0_REV
S    #define __CM0_REV               0x0000
S    #warning "__CM0_REV not defined in device header file; using default!"
S  #endif
S
S  #ifndef __NVIC_PRIO_BITS
S    #define __NVIC_PRIO_BITS          2
S    #warning "__NVIC_PRIO_BITS not defined in device header file; using default!"
S  #endif
S
S  #ifndef __Vendor_SysTickConfig
S    #define __Vendor_SysTickConfig    0
S    #warning "__Vendor_SysTickConfig not defined in device header file; using default!"
S  #endif
N#endif
N
N/* IO definitions (access restrictions to peripheral registers) */
N/**
N    \defgroup CMSIS_glob_defs CMSIS Global Defines
N
N    <strong>IO Type Qualifiers</strong> are used
N    \li to specify the access to peripheral variables.
N    \li for automatic generation of peripheral register debug information.
N*/
N#ifdef __cplusplus
S  #define   __I     volatile             /*!< Defines 'read only' permissions                 */
N#else
N  #define   __I     volatile const       /*!< Defines 'read only' permissions                 */
N#endif
N#define     __O     volatile             /*!< Defines 'write only' permissions                */
N#define     __IO    volatile             /*!< Defines 'read / write' permissions              */
N
N/*@} end of group Cortex_M0 */
N
N
N
N/*******************************************************************************
N *                 Register Abstraction
N  Core Register contain:
N  - Core Register
N  - Core NVIC Register
N  - Core SCB Register
N  - Core SysTick Register
N ******************************************************************************/
N/** \defgroup CMSIS_core_register Defines and Type Definitions
N    \brief Type definitions and defines for Cortex-M processor based devices.
N*/
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_CORE  Status and Control Registers
N    \brief  Core Register type definitions.
N  @{
N */
N
N/** \brief  Union type to access the Application Program Status Register (APSR).
N */
Ntypedef union
N{
N  struct
N  {
N#if (__CORTEX_M != 0x04)
X#if ((0x00) != 0x04)
N    uint32_t _reserved0:27;              /*!< bit:  0..26  Reserved                           */
N#else
S    uint32_t _reserved0:16;              /*!< bit:  0..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:7;               /*!< bit: 20..26  Reserved                           */
N#endif
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} APSR_Type;
N
N
N/** \brief  Union type to access the Interrupt Program Status Register (IPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N    uint32_t _reserved0:23;              /*!< bit:  9..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} IPSR_Type;
N
N
N/** \brief  Union type to access the Special-Purpose Program Status Registers (xPSR).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t ISR:9;                      /*!< bit:  0.. 8  Exception number                   */
N#if (__CORTEX_M != 0x04)
X#if ((0x00) != 0x04)
N    uint32_t _reserved0:15;              /*!< bit:  9..23  Reserved                           */
N#else
S    uint32_t _reserved0:7;               /*!< bit:  9..15  Reserved                           */
S    uint32_t GE:4;                       /*!< bit: 16..19  Greater than or Equal flags        */
S    uint32_t _reserved1:4;               /*!< bit: 20..23  Reserved                           */
N#endif
N    uint32_t T:1;                        /*!< bit:     24  Thumb bit        (read 0)          */
N    uint32_t IT:2;                       /*!< bit: 25..26  saved IT state   (read 0)          */
N    uint32_t Q:1;                        /*!< bit:     27  Saturation condition flag          */
N    uint32_t V:1;                        /*!< bit:     28  Overflow condition code flag       */
N    uint32_t C:1;                        /*!< bit:     29  Carry condition code flag          */
N    uint32_t Z:1;                        /*!< bit:     30  Zero condition code flag           */
N    uint32_t N:1;                        /*!< bit:     31  Negative condition code flag       */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} xPSR_Type;
N
N
N/** \brief  Union type to access the Control Registers (CONTROL).
N */
Ntypedef union
N{
N  struct
N  {
N    uint32_t nPRIV:1;                    /*!< bit:      0  Execution privilege in Thread mode */
N    uint32_t SPSEL:1;                    /*!< bit:      1  Stack to be used                   */
N    uint32_t FPCA:1;                     /*!< bit:      2  FP extension active flag           */
N    uint32_t _reserved0:29;              /*!< bit:  3..31  Reserved                           */
N  } b;                                   /*!< Structure used for bit  access                  */
N  uint32_t w;                            /*!< Type      used for word access                  */
N} CONTROL_Type;
N
N/*@} end of group CMSIS_CORE */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_NVIC  Nested Vectored Interrupt Controller (NVIC)
N    \brief      Type definitions for the NVIC Registers
N  @{
N */
N
N/** \brief  Structure type to access the Nested Vectored Interrupt Controller (NVIC).
N */
Ntypedef struct
N{
N  __IO uint32_t ISER[1];                 /*!< Offset: 0x000 (R/W)  Interrupt Set Enable Register           */
X  volatile uint32_t ISER[1];                  
N       uint32_t RESERVED0[31];
N  __IO uint32_t ICER[1];                 /*!< Offset: 0x080 (R/W)  Interrupt Clear Enable Register          */
X  volatile uint32_t ICER[1];                  
N       uint32_t RSERVED1[31];
N  __IO uint32_t ISPR[1];                 /*!< Offset: 0x100 (R/W)  Interrupt Set Pending Register           */
X  volatile uint32_t ISPR[1];                  
N       uint32_t RESERVED2[31];
N  __IO uint32_t ICPR[1];                 /*!< Offset: 0x180 (R/W)  Interrupt Clear Pending Register         */
X  volatile uint32_t ICPR[1];                  
N       uint32_t RESERVED3[31];
N       uint32_t RESERVED4[64];
N  __IO uint32_t IP[8];                   /*!< Offset: 0x300 (R/W)  Interrupt Priority Register              */
X  volatile uint32_t IP[8];                    
N}  NVIC_Type;
N
N/*@} end of group CMSIS_NVIC */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SCB     System Control Block (SCB)
N    \brief      Type definitions for the System Control Block Registers
N  @{
N */
N
N/** \brief  Structure type to access the System Control Block (SCB).
N */
Ntypedef struct
N{
N  __I  uint32_t CPUID;                   /*!< Offset: 0x000 (R/ )  CPUID Base Register                                   */
X  volatile const  uint32_t CPUID;                    
N  __IO uint32_t ICSR;                    /*!< Offset: 0x004 (R/W)  Interrupt Control and State Register                  */
X  volatile uint32_t ICSR;                     
N       uint32_t RESERVED0;
N  __IO uint32_t AIRCR;                   /*!< Offset: 0x00C (R/W)  Application Interrupt and Reset Control Register      */
X  volatile uint32_t AIRCR;                    
N  __IO uint32_t SCR;                     /*!< Offset: 0x010 (R/W)  System Control Register                               */
X  volatile uint32_t SCR;                      
N  __IO uint32_t CCR;                     /*!< Offset: 0x014 (R/W)  Configuration Control Register                        */
X  volatile uint32_t CCR;                      
N       uint32_t RESERVED1;
N  __IO uint32_t SHP[2];                  /*!< Offset: 0x01C (R/W)  System Handlers Priority Registers. [0] is RESERVED   */
X  volatile uint32_t SHP[2];                   
N  __IO uint32_t SHCSR;                   /*!< Offset: 0x024 (R/W)  System Handler Control and State Register             */
X  volatile uint32_t SHCSR;                    
N} SCB_Type;
N
N/* SCB CPUID Register Definitions */
N#define SCB_CPUID_IMPLEMENTER_Pos          24                                             /*!< SCB CPUID: IMPLEMENTER Position */
N#define SCB_CPUID_IMPLEMENTER_Msk          (0xFFUL << SCB_CPUID_IMPLEMENTER_Pos)          /*!< SCB CPUID: IMPLEMENTER Mask */
N
N#define SCB_CPUID_VARIANT_Pos              20                                             /*!< SCB CPUID: VARIANT Position */
N#define SCB_CPUID_VARIANT_Msk              (0xFUL << SCB_CPUID_VARIANT_Pos)               /*!< SCB CPUID: VARIANT Mask */
N
N#define SCB_CPUID_ARCHITECTURE_Pos         16                                             /*!< SCB CPUID: ARCHITECTURE Position */
N#define SCB_CPUID_ARCHITECTURE_Msk         (0xFUL << SCB_CPUID_ARCHITECTURE_Pos)          /*!< SCB CPUID: ARCHITECTURE Mask */
N
N#define SCB_CPUID_PARTNO_Pos                4                                             /*!< SCB CPUID: PARTNO Position */
N#define SCB_CPUID_PARTNO_Msk               (0xFFFUL << SCB_CPUID_PARTNO_Pos)              /*!< SCB CPUID: PARTNO Mask */
N
N#define SCB_CPUID_REVISION_Pos              0                                             /*!< SCB CPUID: REVISION Position */
N#define SCB_CPUID_REVISION_Msk             (0xFUL << SCB_CPUID_REVISION_Pos)              /*!< SCB CPUID: REVISION Mask */
N
N/* SCB Interrupt Control State Register Definitions */
N#define SCB_ICSR_NMIPENDSET_Pos            31                                             /*!< SCB ICSR: NMIPENDSET Position */
N#define SCB_ICSR_NMIPENDSET_Msk            (1UL << SCB_ICSR_NMIPENDSET_Pos)               /*!< SCB ICSR: NMIPENDSET Mask */
N
N#define SCB_ICSR_PENDSVSET_Pos             28                                             /*!< SCB ICSR: PENDSVSET Position */
N#define SCB_ICSR_PENDSVSET_Msk             (1UL << SCB_ICSR_PENDSVSET_Pos)                /*!< SCB ICSR: PENDSVSET Mask */
N
N#define SCB_ICSR_PENDSVCLR_Pos             27                                             /*!< SCB ICSR: PENDSVCLR Position */
N#define SCB_ICSR_PENDSVCLR_Msk             (1UL << SCB_ICSR_PENDSVCLR_Pos)                /*!< SCB ICSR: PENDSVCLR Mask */
N
N#define SCB_ICSR_PENDSTSET_Pos             26                                             /*!< SCB ICSR: PENDSTSET Position */
N#define SCB_ICSR_PENDSTSET_Msk             (1UL << SCB_ICSR_PENDSTSET_Pos)                /*!< SCB ICSR: PENDSTSET Mask */
N
N#define SCB_ICSR_PENDSTCLR_Pos             25                                             /*!< SCB ICSR: PENDSTCLR Position */
N#define SCB_ICSR_PENDSTCLR_Msk             (1UL << SCB_ICSR_PENDSTCLR_Pos)                /*!< SCB ICSR: PENDSTCLR Mask */
N
N#define SCB_ICSR_ISRPREEMPT_Pos            23                                             /*!< SCB ICSR: ISRPREEMPT Position */
N#define SCB_ICSR_ISRPREEMPT_Msk            (1UL << SCB_ICSR_ISRPREEMPT_Pos)               /*!< SCB ICSR: ISRPREEMPT Mask */
N
N#define SCB_ICSR_ISRPENDING_Pos            22                                             /*!< SCB ICSR: ISRPENDING Position */
N#define SCB_ICSR_ISRPENDING_Msk            (1UL << SCB_ICSR_ISRPENDING_Pos)               /*!< SCB ICSR: ISRPENDING Mask */
N
N#define SCB_ICSR_VECTPENDING_Pos           12                                             /*!< SCB ICSR: VECTPENDING Position */
N#define SCB_ICSR_VECTPENDING_Msk           (0x1FFUL << SCB_ICSR_VECTPENDING_Pos)          /*!< SCB ICSR: VECTPENDING Mask */
N
N#define SCB_ICSR_VECTACTIVE_Pos             0                                             /*!< SCB ICSR: VECTACTIVE Position */
N#define SCB_ICSR_VECTACTIVE_Msk            (0x1FFUL << SCB_ICSR_VECTACTIVE_Pos)           /*!< SCB ICSR: VECTACTIVE Mask */
N
N/* SCB Application Interrupt and Reset Control Register Definitions */
N#define SCB_AIRCR_VECTKEY_Pos              16                                             /*!< SCB AIRCR: VECTKEY Position */
N#define SCB_AIRCR_VECTKEY_Msk              (0xFFFFUL << SCB_AIRCR_VECTKEY_Pos)            /*!< SCB AIRCR: VECTKEY Mask */
N
N#define SCB_AIRCR_VECTKEYSTAT_Pos          16                                             /*!< SCB AIRCR: VECTKEYSTAT Position */
N#define SCB_AIRCR_VECTKEYSTAT_Msk          (0xFFFFUL << SCB_AIRCR_VECTKEYSTAT_Pos)        /*!< SCB AIRCR: VECTKEYSTAT Mask */
N
N#define SCB_AIRCR_ENDIANESS_Pos            15                                             /*!< SCB AIRCR: ENDIANESS Position */
N#define SCB_AIRCR_ENDIANESS_Msk            (1UL << SCB_AIRCR_ENDIANESS_Pos)               /*!< SCB AIRCR: ENDIANESS Mask */
N
N#define SCB_AIRCR_SYSRESETREQ_Pos           2                                             /*!< SCB AIRCR: SYSRESETREQ Position */
N#define SCB_AIRCR_SYSRESETREQ_Msk          (1UL << SCB_AIRCR_SYSRESETREQ_Pos)             /*!< SCB AIRCR: SYSRESETREQ Mask */
N
N#define SCB_AIRCR_VECTCLRACTIVE_Pos         1                                             /*!< SCB AIRCR: VECTCLRACTIVE Position */
N#define SCB_AIRCR_VECTCLRACTIVE_Msk        (1UL << SCB_AIRCR_VECTCLRACTIVE_Pos)           /*!< SCB AIRCR: VECTCLRACTIVE Mask */
N
N/* SCB System Control Register Definitions */
N#define SCB_SCR_SEVONPEND_Pos               4                                             /*!< SCB SCR: SEVONPEND Position */
N#define SCB_SCR_SEVONPEND_Msk              (1UL << SCB_SCR_SEVONPEND_Pos)                 /*!< SCB SCR: SEVONPEND Mask */
N
N#define SCB_SCR_SLEEPDEEP_Pos               2                                             /*!< SCB SCR: SLEEPDEEP Position */
N#define SCB_SCR_SLEEPDEEP_Msk              (1UL << SCB_SCR_SLEEPDEEP_Pos)                 /*!< SCB SCR: SLEEPDEEP Mask */
N
N#define SCB_SCR_SLEEPONEXIT_Pos             1                                             /*!< SCB SCR: SLEEPONEXIT Position */
N#define SCB_SCR_SLEEPONEXIT_Msk            (1UL << SCB_SCR_SLEEPONEXIT_Pos)               /*!< SCB SCR: SLEEPONEXIT Mask */
N
N/* SCB Configuration Control Register Definitions */
N#define SCB_CCR_STKALIGN_Pos                9                                             /*!< SCB CCR: STKALIGN Position */
N#define SCB_CCR_STKALIGN_Msk               (1UL << SCB_CCR_STKALIGN_Pos)                  /*!< SCB CCR: STKALIGN Mask */
N
N#define SCB_CCR_UNALIGN_TRP_Pos             3                                             /*!< SCB CCR: UNALIGN_TRP Position */
N#define SCB_CCR_UNALIGN_TRP_Msk            (1UL << SCB_CCR_UNALIGN_TRP_Pos)               /*!< SCB CCR: UNALIGN_TRP Mask */
N
N/* SCB System Handler Control and State Register Definitions */
N#define SCB_SHCSR_SVCALLPENDED_Pos         15                                             /*!< SCB SHCSR: SVCALLPENDED Position */
N#define SCB_SHCSR_SVCALLPENDED_Msk         (1UL << SCB_SHCSR_SVCALLPENDED_Pos)            /*!< SCB SHCSR: SVCALLPENDED Mask */
N
N/*@} end of group CMSIS_SCB */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_SysTick     System Tick Timer (SysTick)
N    \brief      Type definitions for the System Timer Registers.
N  @{
N */
N
N/** \brief  Structure type to access the System Timer (SysTick).
N */
Ntypedef struct
N{
N  __IO uint32_t CTRL;                    /*!< Offset: 0x000 (R/W)  SysTick Control and Status Register */
X  volatile uint32_t CTRL;                     
N  __IO uint32_t LOAD;                    /*!< Offset: 0x004 (R/W)  SysTick Reload Value Register       */
X  volatile uint32_t LOAD;                     
N  __IO uint32_t VAL;                     /*!< Offset: 0x008 (R/W)  SysTick Current Value Register      */
X  volatile uint32_t VAL;                      
N  __I  uint32_t CALIB;                   /*!< Offset: 0x00C (R/ )  SysTick Calibration Register        */
X  volatile const  uint32_t CALIB;                    
N} SysTick_Type;
N
N/* SysTick Control / Status Register Definitions */
N#define SysTick_CTRL_COUNTFLAG_Pos         16                                             /*!< SysTick CTRL: COUNTFLAG Position */
N#define SysTick_CTRL_COUNTFLAG_Msk         (1UL << SysTick_CTRL_COUNTFLAG_Pos)            /*!< SysTick CTRL: COUNTFLAG Mask */
N
N#define SysTick_CTRL_CLKSOURCE_Pos          2                                             /*!< SysTick CTRL: CLKSOURCE Position */
N#define SysTick_CTRL_CLKSOURCE_Msk         (1UL << SysTick_CTRL_CLKSOURCE_Pos)            /*!< SysTick CTRL: CLKSOURCE Mask */
N
N#define SysTick_CTRL_TICKINT_Pos            1                                             /*!< SysTick CTRL: TICKINT Position */
N#define SysTick_CTRL_TICKINT_Msk           (1UL << SysTick_CTRL_TICKINT_Pos)              /*!< SysTick CTRL: TICKINT Mask */
N
N#define SysTick_CTRL_ENABLE_Pos             0                                             /*!< SysTick CTRL: ENABLE Position */
N#define SysTick_CTRL_ENABLE_Msk            (1UL << SysTick_CTRL_ENABLE_Pos)               /*!< SysTick CTRL: ENABLE Mask */
N
N/* SysTick Reload Register Definitions */
N#define SysTick_LOAD_RELOAD_Pos             0                                             /*!< SysTick LOAD: RELOAD Position */
N#define SysTick_LOAD_RELOAD_Msk            (0xFFFFFFUL << SysTick_LOAD_RELOAD_Pos)        /*!< SysTick LOAD: RELOAD Mask */
N
N/* SysTick Current Register Definitions */
N#define SysTick_VAL_CURRENT_Pos             0                                             /*!< SysTick VAL: CURRENT Position */
N#define SysTick_VAL_CURRENT_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick VAL: CURRENT Mask */
N
N/* SysTick Calibration Register Definitions */
N#define SysTick_CALIB_NOREF_Pos            31                                             /*!< SysTick CALIB: NOREF Position */
N#define SysTick_CALIB_NOREF_Msk            (1UL << SysTick_CALIB_NOREF_Pos)               /*!< SysTick CALIB: NOREF Mask */
N
N#define SysTick_CALIB_SKEW_Pos             30                                             /*!< SysTick CALIB: SKEW Position */
N#define SysTick_CALIB_SKEW_Msk             (1UL << SysTick_CALIB_SKEW_Pos)                /*!< SysTick CALIB: SKEW Mask */
N
N#define SysTick_CALIB_TENMS_Pos             0                                             /*!< SysTick CALIB: TENMS Position */
N#define SysTick_CALIB_TENMS_Msk            (0xFFFFFFUL << SysTick_VAL_CURRENT_Pos)        /*!< SysTick CALIB: TENMS Mask */
N
N/*@} end of group CMSIS_SysTick */
N
N
N/** \ingroup  CMSIS_core_register
N    \defgroup CMSIS_CoreDebug       Core Debug Registers (CoreDebug)
N    \brief      Cortex-M0 Core Debug Registers (DCB registers, SHCSR, and DFSR)
N                are only accessible over DAP and not via processor. Therefore
N                they are not covered by the Cortex-M0 header file.
N  @{
N */
N/*@} end of group CMSIS_CoreDebug */
N
N
N/** \ingroup    CMSIS_core_register
N    \defgroup   CMSIS_core_base     Core Definitions
N    \brief      Definitions for base addresses, unions, and structures.
N  @{
N */
N
N/* Memory mapping of Cortex-M0 Hardware */
N#define SCS_BASE            (0xE000E000UL)                            /*!< System Control Space Base Address */
N#define SysTick_BASE        (SCS_BASE +  0x0010UL)                    /*!< SysTick Base Address              */
N#define NVIC_BASE           (SCS_BASE +  0x0100UL)                    /*!< NVIC Base Address                 */
N#define SCB_BASE            (SCS_BASE +  0x0D00UL)                    /*!< System Control Block Base Address */
N
N#define SCB                 ((SCB_Type       *)     SCB_BASE      )   /*!< SCB configuration struct           */
N#define SysTick             ((SysTick_Type   *)     SysTick_BASE  )   /*!< SysTick configuration struct       */
N#define NVIC                ((NVIC_Type      *)     NVIC_BASE     )   /*!< NVIC configuration struct          */
N
N
N/*@} */
N
N
N
N/*******************************************************************************
N *                Hardware Abstraction Layer
N  Core Function Interface contains:
N  - Core NVIC Functions
N  - Core SysTick Functions
N  - Core Register Access Functions
N ******************************************************************************/
N/** \defgroup CMSIS_Core_FunctionInterface Functions and Instructions Reference
N*/
N
N
N
N/* ##########################   NVIC functions  #################################### */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_NVICFunctions NVIC Functions
N    \brief      Functions that manage interrupts and exceptions via the NVIC.
N    @{
N */
N
N/* Interrupt Priorities are WORD accessible only under ARMv6M                   */
N/* The following MACROS handle generation of the register offset and byte masks */
N#define _BIT_SHIFT(IRQn)         (  (((uint32_t)(IRQn)       )    &  0x03) * 8 )
N#define _SHP_IDX(IRQn)           ( ((((uint32_t)(IRQn) & 0x0F)-8) >>    2)     )
N#define _IP_IDX(IRQn)            (   ((uint32_t)(IRQn)            >>    2)     )
N
N
N/** \brief  Enable External Interrupt
N
N    The function enables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_EnableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_EnableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Disable External Interrupt
N
N    The function disables a device-specific interrupt in the NVIC interrupt controller.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_DisableIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_DisableIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICER[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Get Pending Interrupt
N
N    The function reads the pending register in the NVIC and returns the pending bit
N    for the specified interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N
N    \return             0  Interrupt status is not pending.
N    \return             1  Interrupt status is pending.
N */
N__STATIC_INLINE uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPendingIRQ(IRQn_Type IRQn)
N{
N  return((uint32_t) ((NVIC->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
X  return((uint32_t) ((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0] & (1 << ((uint32_t)(IRQn) & 0x1F)))?1:0));
N}
N
N
N/** \brief  Set Pending Interrupt
N
N    The function sets the pending bit of an external interrupt.
N
N    \param [in]      IRQn  Interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_SetPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_SetPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ISPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));
N}
N
N
N/** \brief  Clear Pending Interrupt
N
N    The function clears the pending bit of an external interrupt.
N
N    \param [in]      IRQn  External interrupt number. Value cannot be negative.
N */
N__STATIC_INLINE void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
Xstatic __inline void NVIC_ClearPendingIRQ(IRQn_Type IRQn)
N{
N  NVIC->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F)); /* Clear pending interrupt */
X  ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->ICPR[0] = (1 << ((uint32_t)(IRQn) & 0x1F));  
N}
N
N
N/** \brief  Set Interrupt Priority
N
N    The function sets the priority of an interrupt.
N
N    \note The priority cannot be set for every core interrupt.
N
N    \param [in]      IRQn  Interrupt number.
N    \param [in]  priority  Priority to set.
N */
N__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
Xstatic __inline void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
N{
N  if(IRQn < 0) {
N    SCB->SHP[_SHP_IDX(IRQn)] = (SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
X    ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] = (((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] & ~(0xFF << ( (((uint32_t)(IRQn) ) & 0x03) * 8 ))) |
N        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
X        (((priority << (8 - 2)) & 0xFF) << ( (((uint32_t)(IRQn) ) & 0x03) * 8 )); }
N  else {
N    NVIC->IP[_IP_IDX(IRQn)] = (NVIC->IP[_IP_IDX(IRQn)] & ~(0xFF << _BIT_SHIFT(IRQn))) |
X    ((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( ((uint32_t)(IRQn) >> 2) )] = (((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[( ((uint32_t)(IRQn) >> 2) )] & ~(0xFF << ( (((uint32_t)(IRQn) ) & 0x03) * 8 ))) |
N        (((priority << (8 - __NVIC_PRIO_BITS)) & 0xFF) << _BIT_SHIFT(IRQn)); }
X        (((priority << (8 - 2)) & 0xFF) << ( (((uint32_t)(IRQn) ) & 0x03) * 8 )); }
N}
N
N
N/** \brief  Get Interrupt Priority
N
N    The function reads the priority of an interrupt. The interrupt
N    number can be positive to specify an external (device specific)
N    interrupt, or negative to specify an internal (core) interrupt.
N
N
N    \param [in]   IRQn  Interrupt number.
N    \return             Interrupt Priority. Value is aligned automatically to the implemented
N                        priority bits of the microcontroller.
N */
N__STATIC_INLINE uint32_t NVIC_GetPriority(IRQn_Type IRQn)
Xstatic __inline uint32_t NVIC_GetPriority(IRQn_Type IRQn)
N{
N
N  if(IRQn < 0) {
N    return((uint32_t)((SCB->SHP[_SHP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for Cortex-M0 system interrupts */
X    return((uint32_t)((((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->SHP[( ((((uint32_t)(IRQn) & 0x0F)-8) >> 2) )] >> ( (((uint32_t)(IRQn) ) & 0x03) * 8 ) ) >> (8 - 2)));  }  
N  else {
N    return((uint32_t)((NVIC->IP[ _IP_IDX(IRQn)] >> _BIT_SHIFT(IRQn) ) >> (8 - __NVIC_PRIO_BITS)));  } /* get priority for device specific interrupts  */
X    return((uint32_t)((((NVIC_Type *) ((0xE000E000UL) + 0x0100UL) )->IP[ ( ((uint32_t)(IRQn) >> 2) )] >> ( (((uint32_t)(IRQn) ) & 0x03) * 8 ) ) >> (8 - 2)));  }  
N}
N
N
N/** \brief  System Reset
N
N    The function initiates a system reset request to reset the MCU.
N */
N__STATIC_INLINE void NVIC_SystemReset(void)
Xstatic __inline void NVIC_SystemReset(void)
N{
N  __DSB();                                                     /* Ensure all outstanding memory accesses included
X  __dsb(0xF);                                                     
N                                                                  buffered write are completed before reset */
N  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
X  ((SCB_Type *) ((0xE000E000UL) + 0x0D00UL) )->AIRCR  = ((0x5FA << 16)      |
N                 SCB_AIRCR_SYSRESETREQ_Msk);
X                 (1UL << 2));
N  __DSB();                                                     /* Ensure completion of memory access */
X  __dsb(0xF);                                                      
N  while(1);                                                    /* wait until reset */
N}
N
N/*@} end of CMSIS_Core_NVICFunctions */
N
N
N
N/* ##################################    SysTick function  ############################################ */
N/** \ingroup  CMSIS_Core_FunctionInterface
N    \defgroup CMSIS_Core_SysTickFunctions SysTick Functions
N    \brief      Functions that configure the System.
N  @{
N */
N
N#if (__Vendor_SysTickConfig == 0)
X#if (0 == 0)
N
N/** \brief  System Tick Configuration
N
N    The function initializes the System Timer and its interrupt, and starts the System Tick Timer.
N    Counter is in free running mode to generate periodic interrupts.
N
N    \param [in]  ticks  Number of ticks between two interrupts.
N
N    \return          0  Function succeeded.
N    \return          1  Function failed.
N
N    \note     When the variable <b>__Vendor_SysTickConfig</b> is set to 1, then the
N    function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
N    must contain a vendor-specific implementation of this function.
N
N */
N__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
Xstatic __inline uint32_t SysTick_Config(uint32_t ticks)
N{
N  if (ticks > SysTick_LOAD_RELOAD_Msk)  return (1);            /* Reload value impossible */
X  if (ticks > (0xFFFFFFUL << 0))  return (1);             
N
N  SysTick->LOAD  = (ticks & SysTick_LOAD_RELOAD_Msk) - 1;      /* set reload register */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD  = (ticks & (0xFFFFFFUL << 0)) - 1;       
N  NVIC_SetPriority (SysTick_IRQn, (1<<__NVIC_PRIO_BITS) - 1);  /* set Priority for Systick Interrupt */
X  NVIC_SetPriority (SysTick_IRQn, (1<<2) - 1);   
N  SysTick->VAL   = 0;                                          /* Load the SysTick Counter Value */
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL   = 0;                                           
N  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
X  ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL  = (1UL << 2) |
N                   SysTick_CTRL_TICKINT_Msk   |
X                   (1UL << 1)   |
N                   SysTick_CTRL_ENABLE_Msk;                    /* Enable SysTick IRQ and SysTick Timer */
X                   (1UL << 0);                     
N  return (0);                                                  /* Function successful */
N}
N
N#endif
N
N/*@} end of CMSIS_Core_SysTickFunctions */
N
N
N
N
N#endif /* __CORE_CM0_H_DEPENDANT */
N
N#endif /* __CMSIS_GENERIC */
N
N/*@}*/ /* end of group CMSIS_Definitions */
N
N#ifdef __cplusplus
S}
N#endif
L 163 ".\Libraries\Device\Nuvoton\NUC230_240\Include\NUC230_240.h" 2
N#include "system_NUC230_240.h"          /* System                                                 */
L 1 ".\Libraries\Device\Nuvoton\NUC230_240\Include\system_NUC230_240.h" 1
N/**************************************************************************//**
N * @file     system_NUC230_240.h
N * @version  V3.0
N * $Revision: 1 $
N * $Date: 14/10/01 5:16p $
N * @brief    NUC230_240 Series CMSIS System Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __SYSTEM_NUC2xx_H
N#define __SYSTEM_NUC2xx_H
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N/*---------------------------------------------------------------------------------------------------------*/
N/* Macro Definition                                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/* Using UART0 or UART1 */
N#define DEBUG_PORT   UART0
N
N/*----------------------------------------------------------------------------
N  Define SYSCLK
N *----------------------------------------------------------------------------*/
N#define __HXT       (12000000UL)    /*!< External Crystal Clock Frequency     */
N#define __LXT       (32768UL)       /*!< External Crystal Clock Frequency 32.768KHz */
N#define __HIRC      (22118400UL)    /*!< Internal 22M RC Oscillator Frequency */
N#define __LIRC      (10000UL)       /*!< Internal 10K RC Oscillator Frequency */
N#define __HSI       (50000000UL)    /*!< PLL default output is 50MHz */
N
Nextern uint32_t SystemCoreClock;    /*!< System Clock Frequency (Core Clock) */
Nextern uint32_t CyclesPerUs;        /*!< Cycles per micro second              */
Nextern uint32_t PllClock;           /*!< PLL Output Clock Frequency           */
N
N/**
N * Initialize the system
N *
N * @param  none
N * @return none
N *
N * @brief  Setup the microcontroller system
N *         Initialise GPIO directions and values
N */
Nextern void SystemInit(void);
N
N
N/**
N * Update SystemCoreClock variable
N *
N * @param  none
N * @return none
N *
N * @brief  Updates the SystemCoreClock with current core Clock
N *         retrieved from cpu registers.
N */
Nextern void SystemCoreClockUpdate(void);
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 164 ".\Libraries\Device\Nuvoton\NUC230_240\Include\NUC230_240.h" 2
N
N#if defined ( __CC_ARM   )
X#if 1L
N#pragma anon_unions
N#endif
N
N
N/*-------------------------------- Device Specific Peripheral registers structures ---------------------*/
N/** @addtogroup REGISTER Control Register
N  Peripheral Control Registers
N  @{
N */
N
N
N
N
N/*---------------------- Analog Comparator Controller -------------------------*/
N/**
N    @addtogroup ACMP Analog Comparator Controller (ACMP)
N    Memory Mapped Structure for ACMP Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N/**
N * @var ACMP_T::CMPCR
N * Offset: 0x00~0x04  Analog Comparator Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |CMPEN     |Comparator Enable
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[1]     |CMPIE     |Comparator Interrupt Enable
N * |        |          |0 = Interrupt function
N * |        |          |Disabled.
N * |        |          |1 = Interrupt function
N * |        |          |Enabled.
N * |[2]     |CMP_HYSEN |Comparator Hysteresis Enable
N * |        |          |0 = Hysteresis function Disabled (Default).
N * |        |          |1 = Hysteresis function
N * |        |          |Enabled.
N * |[4]     |CMPCN     |Comparator Negative Input Selection
N * |        |          |0 = The source of the negative comparator input is from ACMPn_N pin (n = 0, 1).
N * |        |          |1 = Internal band-gap reference voltage is selected as the source
N * |        |          |    of negative comparator input.
N * |[6]     |CMPINV    |Comparator Output Inverse Enable
N * |        |          |0 = Comparator analog output inverse is Disabled.
N * |        |          |1 = Comparator analog output inverse is Enabled.
N * @var ACMP_T::CMPSR
N * Offset: 0x08  Analog Comparator Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |CMPF0     |Comparator 0 Interrupt Flag
N * |        |          |This bit is set by hardware whenever the comparator 0 output changes state.
N * |        |          |This will cause an interrupt if CMPCR0[1] is set to 1.
N * |        |          |Write 1 to clear this bit to 0.
N * |[1]     |CMPF1     |Comparator 1 Interrupt Flag
N * |        |          |This bit is set by hardware whenever the comparator 1 output changes state.
N * |        |          |This will cause an interrupt if CMPCR1[1] is set to 1.
N * |        |          |Write 1 to clear this bit to 0.
N * |[2]     |CO0       |Comparator 0 Output
N * |        |          |Synchronized to the APB clock to allow reading by software.
N * |        |          |Cleared when the comparator 0 is disabled (CMPCR0[0] = 0).
N * |[3]     |CO1       |Comparator 1 Output
N * |        |          |Synchronized to the APB clock to allow reading by software.
N * |        |          |Cleared when the comparator 1 is disabled (CMPCR1[0] = 0).
N */
N
N    __IO uint32_t CMPCR[2];      /* Offset: 0x00  Analog Comparator 0 Control Register                               */
X    volatile uint32_t CMPCR[2];       
N    __IO uint32_t CMPSR;         /* Offset: 0x04  Analog Comparator 1 Control Register                               */
X    volatile uint32_t CMPSR;          
N
N} ACMP_T;
N
N
N/**
N    @addtogroup ACMP_CONST ACMP Bit Field Definition
N    Constant Definitions for ACMP Controller
N@{ */
N
N
N
N/* CMPCR Bit Field Definitions */
N#define ACMP_CMPCR_CMPINV_Pos      6                                   /*!< ACMP_T::CMPCR: CMPINV Position */
N#define ACMP_CMPCR_CMPINV_Msk      (1ul << ACMP_CMPCR_CMPINV_Pos)      /*!< ACMP_T::CMPCR: CMPINV Mask */
N
N#define ACMP_CMPCR_CMPCN_Pos       4                                   /*!< ACMP_T::CMPCR: CMPCN Position */
N#define ACMP_CMPCR_CMPCN_Msk       (1ul << ACMP_CMPCR_CMPCN_Pos)       /*!< ACMP_T::CMPCR: CMPCN Mask */
N
N#define ACMP_CMPCR_CMP_HYSEN_Pos   2                                   /*!< ACMP_T::CMPCR: CMP_HYSEN Position */
N#define ACMP_CMPCR_CMP_HYSEN_Msk   (1ul << ACMP_CMPCR_CMP_HYSEN_Pos)   /*!< ACMP_T::CMPCR: CMP_HYSEN Mask */
N
N#define ACMP_CMPCR_CMPIE_Pos       1                                   /*!< ACMP_T::CMPCR: CMPIE Position */
N#define ACMP_CMPCR_CMPIE_Msk       (1ul << ACMP_CMPCR_CMPIE_Pos)       /*!< ACMP_T::CMPCR: CMPIE Mask */
N
N#define ACMP_CMPCR_CMPEN_Pos       0                                   /*!< ACMP_T::CMPCR: CMPEN Position */
N#define ACMP_CMPCR_CMPEN_Msk       (1ul << ACMP_CMPCR_CMPEN_Pos)       /*!< ACMP_T::CMPCR: CMPEN Mask */
N
N/* CMPSR Bit Field Definitions */
N#define ACMP_CMPSR_CO1_Pos     3                                 /*!< ACMP_T::CMPSR: CO1 Position */
N#define ACMP_CMPSR_CO1_Msk     (1ul << ACMP_CMPSR_CO1_Pos)       /*!< ACMP_T::CMPSR: CO1 Mask */
N
N#define ACMP_CMPSR_CO0_Pos     2                                 /*!< ACMP_T::CMPSR: CO0 Position */
N#define ACMP_CMPSR_CO0_Msk     (1ul << ACMP_CMPSR_CO0_Pos)       /*!< ACMP_T::CMPSR: CO0 Mask */
N
N#define ACMP_CMPSR_CMPF1_Pos   1                                 /*!< ACMP_T::CMPSR: CMPF1 Position */
N#define ACMP_CMPSR_CMPF1_Msk   (1ul << ACMP_CMPSR_CMPF1_Pos)     /*!< ACMP_T::CMPSR: CMPF1 Mask */
N
N#define ACMP_CMPSR_CMPF0_Pos   0                                 /*!< ACMP_T::CMPSR: CMPF0 Position */
N#define ACMP_CMPSR_CMPF0_Msk   (1ul << ACMP_CMPSR_CMPF0_Pos)     /*!< ACMP_T::CMPSR: CMPF0 Mask */
N/*@}*/ /* end of group ACMP_CONST */
N/*@}*/ /* end of group ACMP */
N
N
N
N/*----------------------------- ADC Controller -------------------------------*/
N/** @addtogroup ADC Analog to Digital Converter (ADC)
N  Memory Mapped Structure for ADC Controller
N  @{
N */
N
N
Ntypedef struct
N{
N
N/**
N * @var ADC_T::ADDR
N * Offset: 0x00-0x1C  ADC Data Register  
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |RSLT      |A/D Conversion Result
N * |        |          |This field contains conversion result of ADC.
N * |        |          |When DMOF bit (ADCR[31]) set to 0, 12-bit ADC conversion result with unsigned format will be
N * |        |          |filled in RSLT (ADDRx[11:0], x=0~7) and zero will be filled in RSLT (ADDRx[15:12], x=0~7).
N * |        |          |When DMOF bit (ADCR[31]) set to 1, 12-bit ADC conversion result with 2'complement format will be
N * |        |          |filled in RSLT(ADDRx[11:0], x=0~7) and signed bits to will be filled in RSLT (ADDRx[15:12],
N * |        |          |x=0~7).
N * |[16]    |OVERRUN   |Overrun Flag
N * |        |          |0 = Data in RSLT (ADDRx[15:0], x=0~7) is recent conversion result.
N * |        |          |1 = Data in RSLT (ADDRx[15:0], x=0~7) is overwritten.
N * |        |          |If converted data in RSLT has not been read before new conversion result is loaded to this
N * |        |          |register, OVERRUN is set to 1 and previous conversion result is gone.
N * |        |          |It is cleared by hardware after ADDR register is read.
N * |        |          |This is a read only bit.
N * |[17]    |VALID     |Valid Flag
N * |        |          |0 = Data in RSLT bits (ADDRx[15:0], x=0~7) is not valid.
N * |        |          |1 = Data in RSLT bits (ADDRx[15:0], x=0~7) is valid.
N * |        |          |This bit is set to 1 when corresponding channel analog input conversion is completed and cleared
N * |        |          |by hardware after ADDR register is read.
N * |        |          |This is a read only bit
N * @var ADC_T::ADCR
N * Offset: 0x20  ADC Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |ADEN      |A/D Converter Enable
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |        |          |Before starting A/D conversion function, this bit should be set to 1.
N * |        |          |Clear it to 0 to disable A/D converter analog circuit for saving power consumption.
N * |[1]     |ADIE      |A/D Interrupt Enable
N * |        |          |0 = A/D interrupt function Disabled.
N * |        |          |1 = A/D interrupt function Enabled.
N * |        |          |A/D conversion end interrupt request is generated if ADIE bit (ADCR[1]) is set to 1.
N * |[3:2]   |ADMD      |A/D Converter Operation Mode
N * |        |          |00 = Single conversion.
N * |        |          |01 = Reserved.
N * |        |          |10 = Single-cycle scan.
N * |        |          |11 = Continuous scan.
N * |        |          |When changing the operation mode, software should disable ADST bit (ADCR[11]) firstly.
N * |[5:4]   |TRGS      |Hardware Trigger Source
N * |        |          |00 = A/D conversion is started by external STADC pin.
N * |        |          |11 = A/D conversion is started by PWM Center-aligned trigger.
N * |        |          |Others = Reserved.
N * |        |          |Software should disable TRGEN (ADCR[8]) and ADST (ADCR[11]) before change TRGS.
N * |[7:6]   |TRGCOND   |External Trigger Condition
N * |        |          |These two bits decide external pin STADC trigger event is level or edge.
N * |        |          |The signal must be kept at stable state at least 8 PCLKs for level trigger and 4 PCLKs at high
N * |        |          |and low state for edge trigger.
N * |        |          |00 = Low level.
N * |        |          |01 = High level.
N * |        |          |10 = Falling edge.
N * |        |          |11 = Rising edge.
N * |[8]     |TRGEN     |Hardware Trigger Enable
N * |        |          |Enable or disable triggering of A/D conversion by hardware (external STADC pin or PWM
N * |        |          |Center-aligned trigger).
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |        |          |ADC hardware trigger function is only supported in single-cycle scan mode.
N * |        |          |If hardware trigger mode, the ADST bit (ADCR[11]) can be set to 1 by the selected hardware
N * |        |          |trigger source.
N * |[9]     |PTEN      |PDMA Transfer Enable
N * |        |          |0 = PDMA data transfer Disabled.
N * |        |          |1 = PDMA data transfer in ADDR 0~7 Enabled.
N * |        |          |When A/D conversion is completed, the converted data is loaded into ADDR 0~7, software can
N * |        |          |enable this bit to generate a PDMA data transfer request.
N * |        |          |When PTEN=1, software must set ADIE=0 (ADCR[1]) to disable interrupt.
N * |[10]    |DIFFEN    |Differential Input Mode Enable
N * |        |          |0 = Single-end analog input mode.
N * |        |          |1 = Differential analog input mode.
N * |        |          |Differential   input Paired Channel
N * |        |          |Differential input voltage (Vdiff) = Vplus - Vminus, where Vplus
N * |        |          |is the analog input; Vminus is the inverted analog input.
N * |        |          |In differential input mode, only the even number of the two corresponding channels needs to be
N * |        |          |enabled in ADCHER.
N * |        |          |The conversion result will be placed to the corresponding data register of the enabled channel.
N * |[11]    |ADST      |A/D Conversion Start
N * |        |          |0 = Conversion stops and A/D converter enter idle state.
N * |        |          |1 = Conversion starts.
N * |        |          |ADST bit can be set to 1 from three sources: software, PWM Center-aligned trigger and external
N * |        |          |pin STADC.
N * |        |          |ADST will be cleared to 0 by hardware automatically at the ends of single mode and single-cycle
N * |        |          |scan mode.
N * |        |          |In continuous scan mode, A/D conversion is continuously performed until software writes 0 to
N * |        |          |this bit or chip reset.
N * |[31]    |DMOF      |A/D Differential Input Mode Output Format
N * |        |          |0 = A/D Conversion result will be filled in RSLT at ADDRx registers with unsigned format.
N * |        |          |1 = A/D Conversion result will be filled in RSLT at ADDRx registers with 2'complement format.
N * @var ADC_T::ADCHER
N * Offset: 0x24  ADC Channel Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |CHEN      |Analog Input Channel Enable
N * |        |          |Set CHEN[7:0] to enable the corresponding analog input channel 7 ~ 0.
N * |        |          |If DIFFEN bit (ADCR[10]) is set to 1, only the even number channels need to be enabled.
N * |        |          |0 = ADC input channel Disabled.
N * |        |          |1 = ADC input channel Enabled.
N * |[9:8]   |PRESEL    |Analog Input Channel 7 Select
N * |        |          |00 = External analog input.
N * |        |          |01 = Internal band-gap voltage.
N * |        |          |10 = Internal temperature sensor.
N * |        |          |11 = Reserved.
N * |        |          |Note:
N * |        |          |When software select the band-gap voltage as the analog input source of ADC channel 7, ADC clock
N * |        |          |rate needs to be limited to slower than 300 kHz.
N * @var ADC_T::ADCMPR
N * Offset: 0x28  ADC Compare Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |CMPEN     |Compare Enable
N * |        |          |0 = Compare function Disabled.
N * |        |          |1 = Compare function Enabled.
N * |        |          |Set this bit to 1 to enable ADC controller to compare CMPD (ADCMPR0/1[27:16]) with specified
N * |        |          |channel conversion result when converted data is loaded into ADDR register.
N * |[1]     |CMPIE     |Compare Interrupt Enable
N * |        |          |0 = Compare function interrupt Disabled.
N * |        |          |1 = Compare function interrupt Enabled.
N * |        |          |If the compare function is enabled and the compare condition matches the setting of CMPCOND
N * |        |          |(ADCMPR0/1[2]) and CMPMATCNT (ADCMPR0/1[11:8]), CMPF0/1 bit (ADSR[1]/[2]) will be asserted, in
N * |        |          |the meanwhile, if CMPIE (ADCMPR0/1[1]) is set to 1, a compare interrupt request is generated.
N * |[2]     |CMPCOND   |Compare Condition
N * |        |          |0 = Set the compare condition as that when a 12-bit A/D conversion result is less than the
N * |        |          |12-bit CMPD (ADCMPR0/1[27:16]), the internal match counter will increase one.
N * |        |          |1 = Set the compare condition as that when a 12-bit A/D conversion result is greater or equal to
N * |        |          |the 12-bit CMPD (ADCMPR0/1[27:16]), the internal match counter will increase one.
N * |        |          |Note: When the internal counter reaches the value to (CMPMATCNT (ADCMPR0/1[11:8])+1), the
N * |        |          |CMPF0/1 bit (ADSR[1]/[2]) will be set.
N * |[5:3]   |CMPCH     |Compare Channel Selection
N * |        |          |000 = Channel 0 conversion result is selected to be compared.
N * |        |          |001 = Channel 1 conversion result is selected to be compared.
N * |        |          |010 = Channel 2 conversion result is selected to be compared.
N * |        |          |011 = Channel 3 conversion result is selected to be compared.
N * |        |          |100 = Channel 4 conversion result is selected to be compared.
N * |        |          |101 = Channel 5 conversion result is selected to be compared.
N * |        |          |110 = Channel 6 conversion result is selected to be compared.
N * |        |          |111 = Channel 7 conversion result is selected to be compared.
N * |[11:8]  |CMPMATCNT |Compare Match Count
N * |        |          |When the specified A/D channel analog conversion result matches the compare condition defined by
N * |        |          |CMPCOND (ADCMPR0/1[2]), the internal match counter will increase 1.
N * |        |          |When the internal counter reaches the value to (CMPMATCNT (ADCMPR0/1[11:8]) +1), the CMPF0/1 bit
N * |        |          |(ADSR[1]/[2]) will be set.
N * |[27:16] |CMPD      |Comparison Data
N * |        |          |The 12-bit data is used to compare with conversion result of specified channel.
N * |        |          |When DMOF bit (ADCR[31]) is set to 0, ADC comparator compares CMPD with conversion result with
N * |        |          |unsigned format.
N * |        |          |CMPD should be filled in unsigned format.
N * |        |          |When DMOF bit (ADCR[31]) is set to 1, ADC comparator compares CMPD with conversion result with
N * |        |          |2'complement format.
N * |        |          |CMPD should be filled in 2'complement format.
N * @var ADC_T::ADSR
N * Offset: 0x30  ADC Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |ADF       |A/D Conversion End Flag
N * |        |          |A status flag that indicates the end of A/D conversion.
N * |        |          |ADF is set to 1 at these two conditions:
N * |        |          |1. When A/D conversion ends in Single mode.
N * |        |          |2. When A/D conversion ends on all specified channels in Scan mode.
N * |        |          |This flag can be cleared by writing 1 to itself.
N * |[1]     |CMPF0     |Compare Flag
N * |        |          |When the selected channel A/D conversion result meets setting condition in ADCMPR0 then this bit
N * |        |          |is set to 1.
N * |        |          |And it is cleared by writing 1 to self.
N * |        |          |0 = Conversion result in ADDR does not meet ADCMPR0 setting.
N * |        |          |1 = Conversion result in ADDR meets ADCMPR0 setting.
N * |[2]     |CMPF1     |Compare Flag
N * |        |          |When the selected channel A/D conversion result meets setting condition in ADCMPR1 then this bit
N * |        |          |is set to 1.
N * |        |          |And it is cleared by writing 1 to self.
N * |        |          |0 = Conversion result in ADDR does not meet ADCMPR1 setting.
N * |        |          |1 = Conversion result in ADDR meets ADCMPR1 setting.
N * |[3]     |BUSY      |BUSY/IDLE
N * |        |          |0 = A/D converter is in idle state.
N * |        |          |1 = A/D converter is busy at conversion.
N * |        |          |This bit is mirror of as ADST bit (ADCR[11]).
N * |        |          |It is read only.
N * |[6:4]   |CHANNEL   |Current Conversion Channel
N * |        |          |This field reflects the current conversion channel when BUSY = 1 (ADSR[3]).
N * |        |          |When BUSY = 0, it shows the number of the next converted channel.
N * |        |          |It is read only.
N * |[15:8]  |VALID     |Data Valid Flag
N * |        |          |It is a mirror of VALID bit (ADDR0~7[17]).
N * |        |          |It is read only.
N * |[23:16] |OVERRUN   |Overrun Flag
N * |        |          |It is a mirror to OVERRUN bit (ADDR0~7[16]).
N * |        |          |It is read only.
N * @var ADC_T::ADPDMA
N * Offset: 0x40  ADC PDMA Current Transfer Data Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[17:0]  |AD_PDMA   |ADC PDMA Current Transfer Data Register
N * |        |          |When PDMA transferring, read this register can monitor current PDMA transfer data.
N * |        |          |Current PDMA transfer data is the content of ADDR0 ~ ADDR7.
N * |        |          |This is a read only register.
N */
N
N    __I  uint32_t ADDR[8];       /* Offset: 0x00-0x1C  ADC Data Register                                             */
X    volatile const  uint32_t ADDR[8];        
N    __IO uint32_t ADCR;          /* Offset: 0x20  ADC Control Register                                               */
X    volatile uint32_t ADCR;           
N    __IO uint32_t ADCHER;        /* Offset: 0x24  ADC Channel Enable Register                                        */
X    volatile uint32_t ADCHER;         
N    __IO uint32_t ADCMPR[2];     /* Offset: 0x28  ADC Compare Register                                               */
X    volatile uint32_t ADCMPR[2];      
N    __IO uint32_t ADSR;          /* Offset: 0x30  ADC Status Register                                                */
X    volatile uint32_t ADSR;           
N    __I  uint32_t RESERVE0[3];  
X    volatile const  uint32_t RESERVE0[3];  
N    __I  uint32_t ADPDMA;        /* Offset: 0x40  ADC PDMA Current Transfer Data Register                            */
X    volatile const  uint32_t ADPDMA;         
N
N} ADC_T;
N
N
N/**
N    @addtogroup ADC_CONST ADC Bit Field Definition
N    Constant Definitions for ADC Controller
N@{ */
N
N
N
N/* ADDR Bit Field Definitions */
N#define ADC_ADDR_VALID_Pos      17                                /*!< ADC_T::ADDR: VALID Position */
N#define ADC_ADDR_VALID_Msk      (1ul << ADC_ADDR_VALID_Pos)       /*!< ADC_T::ADDR: VALID Mask */
N
N#define ADC_ADDR_OVERRUN_Pos    16                                /*!< ADC_T::ADDR: OVERRUN Position */
N#define ADC_ADDR_OVERRUN_Msk    (1ul << ADC_ADDR_OVERRUN_Pos)     /*!< ADC_T::ADDR: OVERRUN Mask */
N
N#define ADC_ADDR_RSLT_Pos       0                                 /*!< ADC_T::ADDR: RSLT Position */
N#define ADC_ADDR_RSLT_Msk       (0xFFFFul << ADC_ADDR_RSLT_Pos)   /*!< ADC_T::ADDR: RSLT Mask */
N
N/* ADCR Bit Field Definitions */
N#define ADC_ADCR_DMOF_Pos       31                                /*!< ADC_T::ADCR: DMOF Position */
N#define ADC_ADCR_DMOF_Msk       (1ul << ADC_ADCR_DMOF_Pos)        /*!< ADC_T::ADCR: DMOF Mask */
N
N#define ADC_ADCR_ADST_Pos       11                                /*!< ADC_T::ADCR: ADST Position */
N#define ADC_ADCR_ADST_Msk       (1ul << ADC_ADCR_ADST_Pos)        /*!< ADC_T::ADCR: ADST Mask */
N
N#define ADC_ADCR_DIFFEN_Pos     10                                /*!< ADC_T::ADCR: DIFFEN Position */
N#define ADC_ADCR_DIFFEN_Msk     (1ul << ADC_ADCR_DIFFEN_Pos)      /*!< ADC_T::ADCR: DIFFEN Mask */
N
N#define ADC_ADCR_PTEN_Pos       9                                 /*!< ADC_T::ADCR: PTEN Position */
N#define ADC_ADCR_PTEN_Msk       (1ul << ADC_ADCR_PTEN_Pos)        /*!< ADC_T::ADCR: PTEN Mask */
N
N#define ADC_ADCR_TRGEN_Pos      8                                 /*!< ADC_T::ADCR: TRGEN Position */
N#define ADC_ADCR_TRGEN_Msk      (1ul << ADC_ADCR_TRGEN_Pos)       /*!< ADC_T::ADCR: TRGEN Mask */
N
N#define ADC_ADCR_TRGCOND_Pos    6                                 /*!< ADC_T::ADCR: TRGCOND Position */
N#define ADC_ADCR_TRGCOND_Msk    (3ul << ADC_ADCR_TRGCOND_Pos)     /*!< ADC_T::ADCR: TRGCOND Mask */
N
N#define ADC_ADCR_TRGS_Pos       4                                 /*!< ADC_T::ADCR: TRGS Position */
N#define ADC_ADCR_TRGS_Msk       (3ul << ADC_ADCR_TRGS_Pos)        /*!< ADC_T::ADCR: TRGS Mask */
N
N#define ADC_ADCR_ADMD_Pos       2                                 /*!< ADC_T::ADCR: ADMD Position */
N#define ADC_ADCR_ADMD_Msk       (3ul << ADC_ADCR_ADMD_Pos)        /*!< ADC_T::ADCR: ADMD Mask */
N
N#define ADC_ADCR_ADIE_Pos       1                                 /*!< ADC_T::ADCR: ADIE Position */
N#define ADC_ADCR_ADIE_Msk       (1ul << ADC_ADCR_ADIE_Pos)        /*!< ADC_T::ADCR: ADIE Mask */
N
N#define ADC_ADCR_ADEN_Pos       0                                 /*!< ADC_T::ADCR: ADEN Position */
N#define ADC_ADCR_ADEN_Msk       (1ul << ADC_ADCR_ADEN_Pos)        /*!< ADC_T::ADCR: ADEN Mask */
N
N/* ADCHER Bit Field Definitions */
N#define ADC_ADCHER_PRESEL_Pos   8                                 /*!< ADC_T::ADCHER: PRESEL Position */
N#define ADC_ADCHER_PRESEL_Msk   (3ul << ADC_ADCHER_PRESEL_Pos)    /*!< ADC_T::ADCHER: PRESEL Mask */
N
N#define ADC_ADCHER_CHEN_Pos     0                                 /*!< ADC_T::ADCHER: CHEN Position */
N#define ADC_ADCHER_CHEN_Msk     (0xFFul << ADC_ADCHER_CHEN_Pos)   /*!< ADC_T::ADCHER: CHEN Mask */
N
N/* ADCMPR Bit Field Definitions */
N#define ADC_ADCMPR_CMPD_Pos        16                                    /*!< ADC_T::ADCMPR: CMPD Position */
N#define ADC_ADCMPR_CMPD_Msk        (0xFFFul << ADC_ADCMPR_CMPD_Pos)      /*!< ADC_T::ADCMPR: CMPD Mask */
N
N#define ADC_ADCMPR_CMPMATCNT_Pos   8                                     /*!< ADC_T::ADCMPR: CMPMATCNT Position */
N#define ADC_ADCMPR_CMPMATCNT_Msk   (0xFul << ADC_ADCMPR_CMPMATCNT_Pos)   /*!< ADC_T::ADCMPR: CMPMATCNT Mask */
N
N#define ADC_ADCMPR_CMPCH_Pos       3                                     /*!< ADC_T::ADCMPR: CMPCH Position */
N#define ADC_ADCMPR_CMPCH_Msk       (7ul << ADC_ADCMPR_CMPCH_Pos)         /*!< ADC_T::ADCMPR: CMPCH Mask */
N
N#define ADC_ADCMPR_CMPCOND_Pos     2                                     /*!< ADC_T::ADCMPR: CMPCOND Position */
N#define ADC_ADCMPR_CMPCOND_Msk     (1ul << ADC_ADCMPR_CMPCOND_Pos)       /*!< ADC_T::ADCMPR: CMPCOND Mask */
N
N#define ADC_ADCMPR_CMPIE_Pos       1                                     /*!< ADC_T::ADCMPR: CMPIE Position */
N#define ADC_ADCMPR_CMPIE_Msk       (1ul << ADC_ADCMPR_CMPIE_Pos)         /*!< ADC_T::ADCMPR: CMPIE Mask */
N
N#define ADC_ADCMPR_CMPEN_Pos       0                                     /*!< ADC_T::ADCMPR: CMPEN Position */
N#define ADC_ADCMPR_CMPEN_Msk       (1ul << ADC_ADCMPR_CMPEN_Pos)         /*!< ADC_T::ADCMPR: CMPEN Mask */
N
N/* ADSR Bit Field Definitions */
N#define ADC_ADSR_OVERRUN_Pos       16                                    /*!< ADC_T::ADSR: OVERRUN Position */
N#define ADC_ADSR_OVERRUN_Msk       (0xFFul << ADC_ADSR_OVERRUN_Pos)      /*!< ADC_T::ADSR: OVERRUN Mask */
N
N#define ADC_ADSR_VALID_Pos         8                                     /*!< ADC_T::ADSR: VALID Position */
N#define ADC_ADSR_VALID_Msk         (0xFFul << ADC_ADSR_VALID_Pos)        /*!< ADC_T::ADSR: VALID Mask */
N
N#define ADC_ADSR_CHANNEL_Pos       4                                     /*!< ADC_T::ADSR: CHANNEL Position */
N#define ADC_ADSR_CHANNEL_Msk       (7ul << ADC_ADSR_CHANNEL_Pos)         /*!< ADC_T::ADSR: CHANNEL Mask */
N
N#define ADC_ADSR_BUSY_Pos          3                                     /*!< ADC_T::ADSR: BUSY Position */
N#define ADC_ADSR_BUSY_Msk          (1ul << ADC_ADSR_BUSY_Pos)            /*!< ADC_T::ADSR: BUSY Mask */
N
N#define ADC_ADSR_CMPF1_Pos         2                                     /*!< ADC_T::ADSR: CMPF1 Position */
N#define ADC_ADSR_CMPF1_Msk         (1ul << ADC_ADSR_CMPF1_Pos)           /*!< ADC_T::ADSR: CMPF1 Mask */
N
N#define ADC_ADSR_CMPF0_Pos         1                                     /*!< ADC_T::ADSR: CMPF0 Position */
N#define ADC_ADSR_CMPF0_Msk         (1ul << ADC_ADSR_CMPF0_Pos)           /*!< ADC_T::ADSR: CMPF0 Mask */
N
N#define ADC_ADSR_ADF_Pos           0                                     /*!< ADC_T::ADSR: ADF Position */
N#define ADC_ADSR_ADF_Msk           (1ul << ADC_ADSR_ADF_Pos)             /*!< ADC_T::ADSR: ADF Mask */
N
N/* ADPDMA Bit Field Definitions */
N#define ADC_ADPDMA_AD_PDMA_Pos     0                                     /*!< ADC_T::ADPDMA: AD_PDMA Position */
N#define ADC_ADPDMA_AD_PDMA_Msk     (0x3FFFFul << ADC_ADPDMA_AD_PDMA_Pos) /*!< ADC_T::ADPDMA: AD_PDMA Mask */
N/*@}*/ /* end of group ADC_CONST */
N/*@}*/ /* end of group ADC */
N
N
N
N/*----------------------------- CAN Controller ------------------------------*/
N/** @addtogroup CAN Controller Area Network (CAN)
N  Register Structure for CAN Device Controller
N  @{
N */
N
N
N
Ntypedef struct
N{
N
N
N
N/**
N * @var CAN_IF_T::CREQ
N * Offset: 0x20, 0x80  IFn (Register Map Note 2) Command Request Registers
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[5:0]   |MessageNumber|Message Number
N * |        |          |0x01-0x20: Valid Message Number, the Message Object in the Message
N * |        |          |RAM is selected for data transfer.
N * |        |          |0x00: Not a valid Message Number, interpreted as 0x20.
N * |        |          |0x21-0x3F: Not a valid Message Number, interpreted as 0x01-0x1F.
N * |[15]    |Busy      |Busy Flag
N * |        |          |0 = Read/write action has finished.
N * |        |          |1 = Writing to the IFn Command Request Register is in progress.
N * |        |          |This bit can only be read by the software.
N * @var CAN_IF_T::CMASK
N * Offset: 0x24, 0x84  IFn Command Mask Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |DAT_B     |Access Data Bytes [7:4]
N * |        |          |Write Operation:
N * |        |          |0 = Data Bytes [7:4] unchanged.
N * |        |          |1 = Transfer Data Bytes [7:4] to Message Object.
N * |        |          |Read Operation:
N * |        |          |0 = Data Bytes [7:4] unchanged.
N * |        |          |1 = Transfer Data Bytes [7:4] to IFn Message Buffer Register.
N * |[1]     |DAT_A     |Access Data Bytes [3:0]
N * |        |          |Write Operation:
N * |        |          |0 = Data Bytes [3:0] unchanged.
N * |        |          |1 = Transfer Data Bytes [3:0] to Message Object.
N * |        |          |Read Operation:
N * |        |          |0 = Data Bytes [3:0] unchanged.
N * |        |          |1 = Transfer Data Bytes [3:0] to IFn Message Buffer Register.
N * |[2]     |TxRqst_NewDat|Access Transmission Request Bit When Write Operation
N * |        |          |0 = TxRqst bit unchanged.
N * |        |          |1 = Set TxRqst bit.
N * |        |          |Note: If a transmission is requested by programming bit TxRqst/NewDat in the IFn Command Mask
N * |        |          |Register, bit TxRqst in the IFn Message Control Register will be ignored.
N * |        |          |Access New Data Bit when Read Operation.
N * |        |          |0 = NewDat bit remains unchanged.
N * |        |          |1 = Clear NewDat bit in the Message Object.
N * |        |          |Note: A read access to a Message Object can be combined with the reset of the control bits
N * |        |          |IntPnd and NewDat.
N * |        |          |The values of these bits transferred to the IFn Message Control Register always reflect the
N * |        |          |status before resetting these bits.
N * |[3]     |ClrIntPnd |Clear Interrupt Pending Bit
N * |        |          |Write Operation:
N * |        |          |When writing to a Message Object, this bit is ignored.
N * |        |          |Read Operation:
N * |        |          |0 = IntPnd bit (CAN_IFn_MCON[13]) remains unchanged.
N * |        |          |1 = Clear IntPnd bit in the Message Object.
N * |[4]     |Control   |Control Access Control Bits
N * |        |          |Write Operation:
N * |        |          |0 = Control Bits unchanged.
N * |        |          |1 = Transfer Control Bits to Message Object.
N * |        |          |Read Operation:
N * |        |          |0 = Control Bits unchanged.
N * |        |          |1 = Transfer Control Bits to IFn Message Buffer Register.
N * |[5]     |Arb       |Access Arbitration Bits
N * |        |          |Write Operation:
N * |        |          |0 = Arbitration bits unchanged.
N * |        |          |1 = Transfer Identifier + Dir (CAN_IFn_ARB2[13]) + Xtd (CAN_IFn_ARB2[14]) + MsgVal
N * |        |          |(CAN_IFn_APB2[15]) to Message Object.
N * |        |          |Read Operation:
N * |        |          |0 = Arbitration bits unchanged.
N * |        |          |1 = Transfer Identifier + Dir + Xtd + MsgVal to IFn Message Buffer Register.
N * |[6]     |Mask      |Access Mask Bits
N * |        |          |Write Operation:
N * |        |          |0 = Mask bits unchanged.
N * |        |          |1 = Transfer Identifier Mask + MDir + MXtd to Message Object.
N * |        |          |Read Operation:
N * |        |          |0 = Mask bits unchanged.
N * |        |          |1 = Transfer Identifier Mask + MDir + MXtd to IFn Message Buffer Register.
N * |[7]     |WR_RD     |Write / Read Mode
N * |        |          |0 = Read: Transfer data from the Message Object addressed by the Command Request Register into
N * |        |          |the selected Message Buffer Registers.
N * |        |          |1 = Write: Transfer data from the selected Message Buffer Registers to the Message Object
N * |        |          |addressed by the Command Request Register.
N * @var CAN_IF_T::MASK1
N * Offset: 0x28, 0x88  IFn Mask 1 Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |Msk[15:0] |Identifier Mask 15-0
N * |        |          |0 = The corresponding bit in the identifier of the message object cannot inhibit the match in
N * |        |          |the acceptance filtering.
N * |        |          |1 = The corresponding identifier bit is used for acceptance filtering.
N * @var CAN_IF_T::MASK2
N * Offset: 0x2C, 0x8C  IFn Mask 2 Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[12:0]  |Msk[28:16]|Identifier Mask 28-16
N * |        |          |0 = The corresponding bit in the identifier of the message object cannot inhibit the match in
N * |        |          |the acceptance filtering.
N * |        |          |1 = The corresponding identifier bit is used for acceptance filtering.
N * |[14]    |MDir      |Mask Message Direction
N * |        |          |0 = The message direction bit (Dir (CAN_IFn_ARB2[13])) has no effect on the acceptance
N * |        |          |filtering.
N * |        |          |1 = The message direction bit (Dir) is used for acceptance filtering.
N * |[15]    |MXtd      |Mask Extended Identifier
N * |        |          |0 = The extended identifier bit (IDE) has no effect on the acceptance filtering.
N * |        |          |1 = The extended identifier bit (IDE) is used for acceptance filtering.
N * |        |          |Note: When 11-bit ("standard") Identifiers are used for a Message Object, the identifiers of
N * |        |          |received Data Frames are written into bits ID28 to ID18 (CAN_IFn_ARB2[12:2]).
N * |        |          |For acceptance filtering, only these bits together with mask bits Msk28 to Msk18
N * |        |          |(CAN_IFn_MASK2[12:2]) are considered.
N * @var CAN_IF_T::ARB1
N * Offset: 0x30, 0x90  IFn Arbitration 1 Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |ID[15:0]  |Message Identifier 15-0
N * |        |          |ID28 - ID0, 29-bit Identifier ("Extended Frame").
N * |        |          |ID28 - ID18, 11-bit Identifier ("Standard Frame")
N * @var CAN_IF_T::ARB2
N * Offset: 0x34, 0x94  IFn Arbitration 2 Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[12:0]  |ID[28:16] |Message Identifier 28-16
N * |        |          |ID28 - ID0, 29-bit Identifier ("Extended Frame").
N * |        |          |ID28 - ID18, 11-bit Identifier ("Standard Frame")
N * |[13]    |Dir       |Message Direction
N * |        |          |0 = Direction is receive.
N * |        |          |On TxRqst, a Remote Frame with the identifier of this Message Object is transmitted.
N * |        |          |On reception of a Data Frame with matching identifier, that message is stored in this Message
N * |        |          |Object.
N * |        |          |1 = Direction is transmit.
N * |        |          |On TxRqst, the respective Message Object is transmitted as a Data Frame.
N * |        |          |On reception of a Remote Frame with matching identifier, the TxRqst bit (CAN_IFn_CMASK[2]) of
N * |        |          |this Message Object is set (if RmtEn (CAN_IFn_MCON[9]) = one).
N * |[14]    |Xtd       |Extended Identifier
N * |        |          |0 = The 11-bit ("standard") Identifier will be used for this Message Object.
N * |        |          |1 = The 29-bit ("extended") Identifier will be used for this Message Object.
N * |[15]    |MsgVal    |Message Valid
N * |        |          |0 = The Message Object is ignored by the Message Handler.
N * |        |          |1 = The Message Object is configured and should be considered by the Message Handler.
N * |        |          |Note: The application software must reset the MsgVal bit of all unused Messages Objects during
N * |        |          |the initialization before it resets bit Init (CAN_CON[0]).
N * |        |          |This bit must also be reset before the identifier Id28-0 (CAN_IFn_ARB1/2), the control bits Xtd
N * |        |          |(CAN_IFn_ARB2[14]), Dir (CAN_IFn_APB2[13]), or the Data Length Code DLC3-0 (CAN_IFn_MCON[3:0])
N * |        |          |are modified, or if the Messages Object is no longer required.
N * @var CAN_IF_T::MCON
N * Offset: 0x38, 0x98  IFn Message Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |DLC       |Data Length Code
N * |        |          |0-8: Data Frame has 0-8 data bytes.
N * |        |          |9-15: Data Frame has 8 data bytes
N * |        |          |Note: The Data Length Code of a Message Object must be defined the same as in all the
N * |        |          |corresponding objects with the same identifier at other nodes.
N * |        |          |When the Message Handler stores a data frame, it will write the DLC to the value given by the
N * |        |          |received message.
N * |        |          |Data 0: 1st data byte of a CAN Data Frame
N * |        |          |Data 1: 2nd data byte of a CAN Data Frame
N * |        |          |Data 2: 3rd data byte of a CAN Data Frame
N * |        |          |Data 3: 4th data byte of a CAN Data Frame
N * |        |          |Data 4: 5th data byte of a CAN Data Frame
N * |        |          |Data 5: 6th data byte of a CAN Data Frame
N * |        |          |Data 6: 7th data byte of a CAN Data Frame
N * |        |          |Data 7 : 8th data byte of a CAN Data Frame
N * |        |          |Note: The Data 0 Byte is the first data byte shifted into the shift register of the CAN Core
N * |        |          |during a reception while the Data 7 byte is the last.
N * |        |          |When the Message Handler stores a Data Frame, it will write all the eight data bytes into a
N * |        |          |Message Object.
N * |        |          |If the Data Length Code is less than 8, the remaining bytes of the Message Object will be
N * |        |          |overwritten by unspecified values.
N * |[7]     |EoB       |End Of Buffer
N * |        |          |0 = Message Object belongs to a FIFO Buffer and is not the last Message Object of that FIFO
N * |        |          |Buffer.
N * |        |          |1 = Single Message Object or last Message Object of a FIFO Buffer.
N * |        |          |Note: This bit is used to concatenate two or more Message Objects (up to 32) to build a FIFO
N * |        |          |Buffer.
N * |        |          |For single Message Objects (not belonging to a FIFO Buffer), this bit must always be set to one.
N * |[8]     |TxRqst    |Transmit Request
N * |        |          |0 = This Message Object is not waiting for transmission.
N * |        |          |1 = The transmission of this Message Object is requested and is not yet done.
N * |[9]     |RmtEn     |Remote Enable Control
N * |        |          |0 = At the reception of a Remote Frame, TxRqst (CAN_IFn_MCON[8]) is left unchanged.
N * |        |          |1 = At the reception of a Remote Frame, TxRqst is set.
N * |[10]    |RxIE      |Receive Interrupt Enable Control
N * |        |          |0 = IntPnd (CAN_IFn_MCON[13]) will be left unchanged after a successful reception of a frame.
N * |        |          |1 = IntPnd will be set after a successful reception of a frame.
N * |[11]    |TxIE      |Transmit Interrupt Enable Control
N * |        |          |0 = IntPnd (CAN_IFn_MCON[13]) will be left unchanged after the successful transmission of a
N * |        |          |frame.
N * |        |          |1 = IntPnd will be set after a successful transmission of a frame.
N * |[12]    |UMask     |Use Acceptance Mask
N * |        |          |0 = Mask ignored.
N * |        |          |1 = Use Mask (Msk28-0, MXtd, and MDir) for acceptance filtering.
N * |        |          |Note: If the UMask bit is set to one, the Message Object's mask bits have to be programmed
N * |        |          |during initialization of the Message Object before MsgVal bit (CAN_IFn_APB2[15]) is set to one.
N * |[13]    |IntPnd    |Interrupt Pending
N * |        |          |0 = This message object is not the source of an interrupt.
N * |        |          |1 = This message object is the source of an interrupt.
N * |        |          |The Interrupt Identifier in the Interrupt Register will point to this message object if there is
N * |        |          |no other interrupt source with higher priority.
N * |[14]    |MsgLst    |Message Lost (only valid for Message Objects with direction = receive).
N * |        |          |0 = No message lost since last time this bit was reset by the CPU.
N * |        |          |1 = The Message Handler stored a new message into this object when NewDat was still set, the CPU
N * |        |          |has lost a message.
N * |[15]    |NewDat    |New Data
N * |        |          |0 = No new data has been written into the data portion of this Message Object by the Message
N * |        |          |Handler since last time this flag was cleared by the application software.
N * |        |          |1 = The Message Handler or the application software has written new data into the data portion
N * |        |          |of this Message Object.
N * @var CAN_IF_T::DAT_A1
N * Offset: 0x3C, 0x9C  IFn Data A1 Register (Register Map Note 3)
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |Data0     |Data Byte 0
N * |        |          |1st data byte of a CAN Data Frame
N * |[15:8]  |Data1     |Data Byte 1
N * |        |          |2nd data byte of a CAN Data Frame
N * @var CAN_IF_T::DAT_A2
N * Offset: 0x40, 0xA0  IFn Data A2 Register (Register Map Note 3)
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |Data2     |Data Byte 2
N * |        |          |3rd data byte of CAN Data Frame
N * |[15:8]  |Data3     |Data Byte 3
N * |        |          |4th data byte of CAN Data Frame
N * @var CAN_IF_T::DAT_B1
N * Offset: 0x44, 0xA4  IFn Data B1 Register (Register Map Note 3)
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |Data4     |Data Byte 4
N * |        |          |5th data byte of CAN Data Frame
N * |[15:8]  |Data5     |Data Byte 5
N * |        |          |6th data byte of CAN Data Frame
N * @var CAN_IF_T::DAT_B2
N * Offset: 0x48, 0xA8  IFn Data B2 Register (Register Map Note 3)
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |Data6     |Data Byte 6
N * |        |          |7th data byte of CAN Data Frame.
N * |[15:8]  |Data7     |Data Byte 7
N * |        |          |8th data byte of CAN Data Frame.
N */
N
N    __IO uint32_t CREQ;          /* Offset: 0x20, 0x80  IFn (Register Map Note 2) Command Request Registers          */
X    volatile uint32_t CREQ;           
N    __IO uint32_t CMASK;         /* Offset: 0x24, 0x84  IFn Command Mask Register                                    */
X    volatile uint32_t CMASK;          
N    __IO uint32_t MASK1;         /* Offset: 0x28, 0x88  IFn Mask 1 Register                                          */
X    volatile uint32_t MASK1;          
N    __IO uint32_t MASK2;         /* Offset: 0x2C, 0x8C  IFn Mask 2 Register                                          */
X    volatile uint32_t MASK2;          
N    __IO uint32_t ARB1;          /* Offset: 0x30, 0x90  IFn Arbitration 1 Register                                   */
X    volatile uint32_t ARB1;           
N    __IO uint32_t ARB2;          /* Offset: 0x34, 0x94  IFn Arbitration 2 Register                                   */
X    volatile uint32_t ARB2;           
N    __IO uint32_t MCON;          /* Offset: 0x38, 0x98  IFn Message Control Register                                 */
X    volatile uint32_t MCON;           
N    __IO uint32_t DAT_A1;        /* Offset: 0x3C, 0x9C  IFn Data A1 Register (Register Map Note 3)                   */
X    volatile uint32_t DAT_A1;         
N    __IO uint32_t DAT_A2;        /* Offset: 0x40, 0xA0  IFn Data A2 Register (Register Map Note 3)                   */
X    volatile uint32_t DAT_A2;         
N    __IO uint32_t DAT_B1;        /* Offset: 0x44, 0xA4  IFn Data B1 Register (Register Map Note 3)                   */
X    volatile uint32_t DAT_B1;         
N    __IO uint32_t DAT_B2;        /* Offset: 0x48, 0xA8  IFn Data B2 Register (Register Map Note 3)                   */
X    volatile uint32_t DAT_B2;         
N    __I  uint32_t RESERVE[13];   
X    volatile const  uint32_t RESERVE[13];   
N
N} CAN_IF_T;
N
N
N
N
N
Ntypedef struct
N{
N
N
N
N/**
N * @var CAN_T::CON
N * Offset: 0x00  Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |Init      |Init Initialization
N * |        |          |0 = Normal Operation.
N * |        |          |1 = Initialization is started.
N * |[1]     |IE        |Module Interrupt Enable Control
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[2]     |SIE       |Status Change Interrupt Enable Control
N * |        |          |0 = Disabled - No Status Change Interrupt will be generated.
N * |        |          |1 = Enabled - An interrupt will be generated when a message transfer is successfully completed
N * |        |          |or a CAN bus error is detected.
N * |[3]     |EIE       |Error Interrupt Enable Control
N * |        |          |0 = Disabled - No Error Status Interrupt will be generated.
N * |        |          |1 = Enabled - A change in the bits BOff (CAN_STATUS[7]) or EWarn (CAN_STATUS[6]) in the Status
N * |        |          |Register will generate an interrupt.
N * |[5]     |DAR       |Automatic Re-Transmission Disable Control
N * |        |          |0 = Automatic Retransmission of disturbed messages enabled.
N * |        |          |1 = Automatic Retransmission disabled.
N * |[6]     |CCE       |Configuration Change Enable Control
N * |        |          |0 = No write access to the Bit Timing Register.
N * |        |          |1 = Write access to the Bit Timing Register (CAN_BTIME) allowed. (while Init bit (CAN_CON[0]) = 1).
N * |[7]     |Test      |Test Mode Enable Control
N * |        |          |0 = Normal Operation.
N * |        |          |1 = Test Mode.
N * @var CAN_T::STATUS
N * Offset: 0x04  Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[2:0]   |LEC       |Last Error Code (Type Of The Last Error To Occur On The CAN Bus)
N * |        |          |The LEC field holds a code, which indicates the type of the last error to occur on the CAN bus.
N * |        |          |This field will be cleared to '0' when a message has been transferred (reception or
N * |        |          |transmission) without error.
N * |        |          |The unused code '7' may be written by the CPU to check for updates.
N * |        |          |The following table describes the error code.
N * |[3]     |TxOK      |Transmitted A Message Successfully
N * |        |          |0 = Since this bit was reset by the CPU, no message has been successfully transmitted.
N * |        |          |This bit is never reset by the CAN Core.
N * |        |          |1 = Since this bit was last reset by the CPU, a message has been successfully (error free and
N * |        |          |acknowledged by at least one other node) transmitted.
N * |[4]     |RxOK      |Received A Message Successfully
N * |        |          |0 = No message has been successfully received since this bit was last reset by the CPU.
N * |        |          |This bit is never reset by the CAN Core.
N * |        |          |1 = A message has been successfully received since this bit was last reset by the CPU
N * |        |          |(independent of the result of acceptance filtering).
N * |[5]     |EPass     |Error Passive (Read Only)
N * |        |          |0 = The CAN Core is error active.
N * |        |          |1 = The CAN Core is in the error passive state as defined in the CAN Specification.
N * |[6]     |EWarn     |Error Warning Status (Read Only)
N * |        |          |0 = Both error counters are below the error warning limit of 96.
N * |        |          |1 = At least one of the error counters in the EML has reached the error warning limit of 96.
N * |[7]     |BOff      |Bus-Off Status (Read Only)
N * |        |          |0 = The CAN module is not in bus-off state.
N * |        |          |1 = The CAN module is in bus-off state.
N * @var CAN_T::ERR
N * Offset: 0x08  Error Counter Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |TEC       |Transmit Error Counter
N * |        |          |Actual state of the Transmit Error Counter. Values between 0 and 255.
N * |[14:8]  |REC       |Receive Error Counter
N * |        |          |Actual state of the Receive Error Counter. Values between 0 and 127.
N * |[15]    |RP        |Receive Error Passive
N * |        |          |0 = The Receive Error Counter is below the error passive level.
N * |        |          |1 = The Receive Error Counter has reached the error passive level as defined in the CAN
N * |        |          |Specification.
N * @var CAN_T::BTIME
N * Offset: 0x0C  Bit Timing Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[5:0]   |BRP       |Baud Rate Prescaler
N * |        |          |0x01-0x3F: The value by which the oscillator frequency is divided for generating the bit time
N * |        |          |quanta.
N * |        |          |The bit time is built up from a multiple of this quanta.
N * |        |          |Valid values for the Baud Rate Prescaler are [ 0 ... 63 ].
N * |        |          |The actual interpretation by the hardware of this value is such that one more than the value
N * |        |          |programmed here is used.
N * |[7:6]   |SJW       |(Re)Synchronization Jump Width
N * |        |          |0x0-0x3: Valid programmed values are [0 ... 3].
N * |        |          |The actual interpretation by the hardware of this value is such that one more than the value
N * |        |          |programmed here is used.
N * |[11:8]  |TSeg1     |Time Segment Before The Sample Point Minus Sync_Seg
N * |        |          |0x01-0x0F: valid values for TSeg1 are [1 ... 15].
N * |        |          |The actual interpretation by the hardware of this value is such that one more than the value
N * |        |          |programmed is used.
N * |[14:12] |TSeg2     |Time Segment After Sample Point
N * |        |          |0x0-0x7: Valid values for TSeg2 are [0 ... 7].
N * |        |          |The actual interpretation by the hardware of this value is such that one more than the value
N * |        |          |programmed here is used.
N * @var CAN_T::IIDR
N * Offset: 0x10  Interrupt Identifier Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |IntId     |Interrupt Identifier (Indicates The Source Of The Interrupt)
N * |        |          |If several interrupts are pending, the CAN Interrupt Register will point to the pending
N * |        |          |interrupt with the highest priority, disregarding their chronological order.
N * |        |          |An interrupt remains pending until the application software has cleared it.
N * |        |          |If IntId is different from 0x0000 and IE (CAN_IFn_MCON[1]) is set, the IRQ interrupt signal to
N * |        |          |the EIC is active.
N * |        |          |The interrupt remains active until IntId is back to value 0x0000 (the cause of the interrupt is
N * |        |          |reset) or until IE is reset.
N * |        |          |The Status Interrupt has the highest priority.
N * |        |          |Among the message interrupts, the Message Object' s interrupt priority decreases with increasing
N * |        |          |message number.
N * |        |          |A message interrupt is cleared by clearing the Message Object's IntPnd bit (CAN_IFn_MCON[13]).
N * |        |          |The Status Interrupt is cleared by reading the Status Register.
N * @var CAN_T::TEST
N * Offset: 0x14  Test Register (Register Map Note 1)
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1:0]   |Res       |Reserved
N * |        |          |There are reserved bits.
N * |        |          |These bits are always read as '0' and must always be written with '0'.
N * |[2]     |Basic     |Basic Mode
N * |        |          |0 = Basic Mode disabled.
N * |        |          |1= IF1 Registers used as Tx Buffer, IF2 Registers used as Rx Buffer.
N * |[3]     |Silent    |Silent Mode
N * |        |          |0 = Normal operation.
N * |        |          |1 = The module is in Silent Mode.
N * |[4]     |LBack     |Loop Back Mode Enable Control
N * |        |          |0 = Loop Back Mode is disabled.
N * |        |          |1 = Loop Back Mode is enabled.
N * |[6:5]   |Tx10      |Tx[1:0]: Control Of CAN_TX Pin
N * |        |          |00 = Reset value, CAN_TX pin is controlled by the CAN Core.
N * |        |          |01 = Sample Point can be monitored at CAN_TX pin.
N * |        |          |10 = CAN_TX pin drives a dominant ('0') value.
N * |        |          |11 = CAN_TX pin drives a recessive ('1') value.
N * |[7]     |Rx        |Monitors The Actual Value Of CAN_RX Pin (Read Only)
N * |        |          |0 = The CAN bus is dominant (CAN_RX = '0').
N * |        |          |1 = The CAN bus is recessive (CAN_RX = '1').
N * @var CAN_T::BRPE
N * Offset: 0x18  Baud Rate Prescaler Extension Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |BRPE      |BRPE: Baud Rate Prescaler Extension
N * |        |          |0x00-0x0F: By programming BRPE, the Baud Rate Prescaler can be extended to values up to 1023.
N * |        |          |The actual interpretation by the hardware is that one more than the value programmed by BRPE
N * |        |          |(MSBs) and BTIME (LSBs) is used.
N * @var CAN_T::TXREQ1
N * Offset: 0x100  Transmission Request Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |TxRqst[16:1]|Transmission Request Bits 16-1 (Of All Message Objects)
N * |        |          |0 = This Message Object is not waiting for transmission.
N * |        |          |1 = The transmission of this Message Object is requested and is not yet done.
N * |        |          |These bits are read only.
N * @var CAN_T::TXREQ2
N * Offset: 0x104  Transmission Request Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |TxRqst[32:17]|Transmission Request Bits 32-17 (Of All Message Objects)
N * |        |          |0 = This Message Object is not waiting for transmission.
N * |        |          |1 = The transmission of this Message Object is requested and is not yet done.
N * |        |          |These bits are read only.
N * @var CAN_T::NDAT1
N * Offset: 0x120  New Data Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |NewData[16:1]|New Data Bits 16-1 (Of All Message Objects)
N * |        |          |0 = No new data has been written into the data portion of this Message Object by the Message
N * |        |          |Handler since the last time this flag was cleared by the application software.
N * |        |          |1 = The Message Handler or the application software has written new data into the data portion
N * |        |          |of this Message Object.
N * @var CAN_T::NDAT2
N * Offset: 0x124  New Data Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |NewData[32:17]|New Data Bits 32-17 (Of All Message Objects)
N * |        |          |0 = No new data has been written into the data portion of this Message Object by the Message
N * |        |          |Handler since the last time this flag was cleared by the application software.
N * |        |          |1 = The Message Handler or the application software has written new data into the data portion
N * |        |          |of this Message Object.
N * @var CAN_T::IPND1
N * Offset: 0x140  Interrupt Pending Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |IntPnd[16:1]|Interrupt Pending Bits 16-1 (Of All Message Objects)
N * |        |          |0 = This message object is not the source of an interrupt.
N * |        |          |1 = This message object is the source of an interrupt.
N * @var CAN_T::IPND2
N * Offset: 0x144  Interrupt Pending Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |IntPnd[32:17]|Interrupt Pending Bits 32-17(Of All Message Objects)
N * |        |          |0 = This message object is not the source of an interrupt.
N * |        |          |1 = This message object is the source of an interrupt.
N * @var CAN_T::MVLD1
N * Offset: 0x160  Message Valid Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |MsgVal[16:1]|Message Valid Bits 16-1 (Of All Message Objects) (Read Only)
N * |        |          |0 = This Message Object is ignored by the Message Handler.
N * |        |          |1 = This Message Object is configured and should be considered by the Message Handler.
N * |        |          |Ex.
N * |        |          |CAN_MVLD1[0] means Message object No.1 is valid or not.
N * |        |          |If CAN_MVLD1[0] is set, message object No.1 is configured.
N * @var CAN_T::MVLD2
N * Offset: 0x164  Message Valid Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |MsgVal[32:17]|Message Valid Bits 32-17 (Of All Message Objects) (Read Only)
N * |        |          |0 = This Message Object is ignored by the Message Handler.
N * |        |          |1 = This Message Object is configured and should be considered by the Message Handler.
N * |        |          |Ex.CAN_MVLD2[15] means Message object No.32 is valid or not.
N * |        |          |If CAN_MVLD2[15] is set, message object No.32 is configured.
N * @var CAN_T::WU_EN
N * Offset: 0x168  Wake-up Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |WAKUP_EN  |Wake-Up Enable Control
N * |        |          |0 = The wake-up function Disabled.
N * |        |          |1 = The wake-up function Enabled.
N * |        |          |Note: User can wake-up system when there is a falling edge in the CAN_Rx pin.
N * @var CAN_T::WU_STATUS
N * Offset: 0x16C  Wake-up Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |WAKUP_STS |Wake-Up Status
N * |        |          |0 = No wake-up event occurred.
N * |        |          |1 = Wake-up event occurred.
N * |        |          |Note: This bit can be cleared by writing '0'.
N */
N
N    __IO uint32_t CON;           /* Offset: 0x00  Control Register                                                   */
X    volatile uint32_t CON;            
N    __IO uint32_t STATUS;        /* Offset: 0x04  Status Register                                                    */
X    volatile uint32_t STATUS;         
N    __IO uint32_t ERR;           /* Offset: 0x08  Error Counter Register                                             */
X    volatile uint32_t ERR;            
N    __IO uint32_t BTIME;         /* Offset: 0x0C  Bit Timing Register                                                */
X    volatile uint32_t BTIME;          
N    __IO uint32_t IIDR;          /* Offset: 0x10  Interrupt Identifier Register                                      */
X    volatile uint32_t IIDR;           
N    __IO uint32_t TEST;          /* Offset: 0x14  Test Register (Register Map Note 1)                                */
X    volatile uint32_t TEST;           
N    __IO uint32_t BRPE;          /* Offset: 0x18  Baud Rate Prescaler Extension Register                             */
X    volatile uint32_t BRPE;           
N    __I  uint32_t RESERVE0[1];  
X    volatile const  uint32_t RESERVE0[1];  
N    __IO CAN_IF_T IF[2];         /* Offset: 0x20  CAN Interface Control Registers                                    */
X    volatile CAN_IF_T IF[2];          
N    __I  uint32_t RESERVE1[8];  
X    volatile const  uint32_t RESERVE1[8];  
N    __IO uint32_t TXREQ1;        /* Offset: 0x100  Transmission Request Register 1                                   */
X    volatile uint32_t TXREQ1;         
N    __IO uint32_t TXREQ2;        /* Offset: 0x104  Transmission Request Register 2                                   */
X    volatile uint32_t TXREQ2;         
N    __I  uint32_t RESERVE2[6];  
X    volatile const  uint32_t RESERVE2[6];  
N    __IO uint32_t NDAT1;         /* Offset: 0x120  New Data Register 1                                               */
X    volatile uint32_t NDAT1;          
N    __IO uint32_t NDAT2;         /* Offset: 0x124  New Data Register 2                                               */
X    volatile uint32_t NDAT2;          
N    __I  uint32_t RESERVE3[6];  
X    volatile const  uint32_t RESERVE3[6];  
N    __IO uint32_t IPND1;         /* Offset: 0x140  Interrupt Pending Register 1                                      */
X    volatile uint32_t IPND1;          
N    __IO uint32_t IPND2;         /* Offset: 0x144  Interrupt Pending Register 2                                      */
X    volatile uint32_t IPND2;          
N    __I  uint32_t RESERVE4[6];  
X    volatile const  uint32_t RESERVE4[6];  
N    __IO uint32_t MVLD1;         /* Offset: 0x160  Message Valid Register 1                                          */
X    volatile uint32_t MVLD1;          
N    __IO uint32_t MVLD2;         /* Offset: 0x164  Message Valid Register 2                                          */
X    volatile uint32_t MVLD2;          
N    __IO uint32_t WU_EN;         /* Offset: 0x168  Wake-up Enable Register                                           */
X    volatile uint32_t WU_EN;          
N    __IO uint32_t WU_STATUS;     /* Offset: 0x16C  Wake-up Status Register                                           */
X    volatile uint32_t WU_STATUS;      
N
N} CAN_T;
N
N
N
N/**
N    @addtogroup CAN_CONST CAN Bit Field Definition
N    Constant Definitions for CAN Controller
N@{ */
N
N
N/* CAN CON Bit Field Definitions */
N#define CAN_CON_TEST_Pos           7                                    /*!< CAN_T::CON: TEST Position */
N#define CAN_CON_TEST_Msk           (1ul << CAN_CON_TEST_Pos)            /*!< CAN_T::CON: TEST Mask     */
N
N#define CAN_CON_CCE_Pos            6                                    /*!< CAN_T::CON: CCE Position  */
N#define CAN_CON_CCE_Msk            (1ul << CAN_CON_CCE_Pos)             /*!< CAN_T::CON: CCE Mask      */
N
N#define CAN_CON_DAR_Pos            5                                    /*!< CAN_T::CON: DAR Position  */
N#define CAN_CON_DAR_Msk            (1ul << CAN_CON_DAR_Pos)             /*!< CAN_T::CON: DAR Mask      */
N
N#define CAN_CON_EIE_Pos            3                                    /*!< CAN_T::CON: EIE Position  */
N#define CAN_CON_EIE_Msk            (1ul << CAN_CON_EIE_Pos)             /*!< CAN_T::CON: EIE Mask      */
N
N#define CAN_CON_SIE_Pos            2                                    /*!< CAN_T::CON: SIE Position  */
N#define CAN_CON_SIE_Msk            (1ul << CAN_CON_SIE_Pos)             /*!< CAN_T::CON: SIE Mask      */
N
N#define CAN_CON_IE_Pos             1                                    /*!< CAN_T::CON: IE Position   */
N#define CAN_CON_IE_Msk             (1ul << CAN_CON_IE_Pos)              /*!< CAN_T::CON: IE Mask       */
N
N#define CAN_CON_INIT_Pos           0                                    /*!< CAN_T::CON: INIT Position */
N#define CAN_CON_INIT_Msk           (1ul << CAN_CON_INIT_Pos)            /*!< CAN_T::CON: INIT Mask     */
N
N/* CAN STATUS Bit Field Definitions */
N#define CAN_STATUS_BOFF_Pos        7                                    /*!< CAN_T::STATUS: BOFF Position  */
N#define CAN_STATUS_BOFF_Msk        (1ul << CAN_STATUS_BOFF_Pos)         /*!< CAN_T::STATUS: BOFF Mask      */
N
N#define CAN_STATUS_EWARN_Pos       6                                    /*!< CAN_T::STATUS: EWARN Position */
N#define CAN_STATUS_EWARN_Msk       (1ul << CAN_STATUS_EWARN_Pos)        /*!< CAN_T::STATUS: EWARN Mask     */
N
N#define CAN_STATUS_EPASS_Pos       5                                    /*!< CAN_T::STATUS: EPASS Position */
N#define CAN_STATUS_EPASS_Msk       (1ul << CAN_STATUS_EPASS_Pos)        /*!< CAN_T::STATUS: EPASS Mask     */
N
N#define CAN_STATUS_RXOK_Pos        4                                    /*!< CAN_T::STATUS: RXOK Position  */
N#define CAN_STATUS_RXOK_Msk        (1ul << CAN_STATUS_RXOK_Pos)         /*!< CAN_T::STATUS: RXOK Mask      */
N
N#define CAN_STATUS_TXOK_Pos        3                                    /*!< CAN_T::STATUS: TXOK Position  */
N#define CAN_STATUS_TXOK_Msk        (1ul << CAN_STATUS_TXOK_Pos)         /*!< CAN_T::STATUS: TXOK Mask      */
N
N#define CAN_STATUS_LEC_Pos         0                                    /*!< CAN_T::STATUS: LEC Position   */
N#define CAN_STATUS_LEC_Msk         (0x7ul << CAN_STATUS_LEC_Pos)        /*!< CAN_T::STATUS: LEC Mask       */
N
N/* CAN ERR Bit Field Definitions */
N#define CAN_ERR_RP_Pos             15                                   /*!< CAN_T::ERR: RP Position       */
N#define CAN_ERR_RP_Msk             (1ul << CAN_ERR_RP_Pos)              /*!< CAN_T::ERR: RP Mask           */
N
N#define CAN_ERR_REC_Pos            8                                    /*!< CAN_T::ERR: REC Position      */
N#define CAN_ERR_REC_Msk            (0x7Ful << CAN_ERR_REC_Pos)          /*!< CAN_T::ERR: REC Mask          */
N
N#define CAN_ERR_TEC_Pos            0                                    /*!< CAN_T::ERR: TEC Position      */
N#define CAN_ERR_TEC_Msk            (0xFFul << CAN_ERR_TEC_Pos)          /*!< CAN_T::ERR: TEC Mask          */
N
N/* CAN BTIME Bit Field Definitions */
N#define CAN_BTIME_TSEG2_Pos        12                                   /*!< CAN_T::BTIME: TSEG2 Position  */
N#define CAN_BTIME_TSEG2_Msk        (0x7ul << CAN_BTIME_TSEG2_Pos)       /*!< CAN_T::BTIME: TSEG2 Mask      */
N
N#define CAN_BTIME_TSEG1_Pos        8                                    /*!< CAN_T::BTIME: TSEG1 Position  */
N#define CAN_BTIME_TSEG1_Msk        (0xFul << CAN_BTIME_TSEG1_Pos)       /*!< CAN_T::BTIME: TSEG1 Mask      */
N
N#define CAN_BTIME_SJW_Pos          6                                    /*!< CAN_T::BTIME: SJW Position    */
N#define CAN_BTIME_SJW_Msk          (0x3ul << CAN_BTIME_SJW_Pos)         /*!< CAN_T::BTIME: SJW Mask        */
N
N#define CAN_BTIME_BRP_Pos          0                                    /*!< CAN_T::BTIME: BRP Position    */
N#define CAN_BTIME_BRP_Msk          (0x3Ful << CAN_BTIME_BRP_Pos)        /*!< CAN_T::BTIME: BRP Mask        */
N
N/* CAN IIDR Bit Field Definitions */
N#define CAN_IIDR_INTID_Pos         0                                    /*!< CAN_T::IIDR: INTID Position   */
N#define CAN_IIDR_INTID_Msk         (0xFFFFul << CAN_IIDR_INTID_Pos)     /*!< CAN_T::IIDR: INTID Mask       */
N
N/* CAN TEST Bit Field Definitions */
N#define CAN_TEST_RX_Pos            7                                    /*!< CAN_T::TEST: RX Position      */
N#define CAN_TEST_RX_Msk            (1ul << CAN_TEST_RX_Pos)             /*!< CAN_T::TEST: RX Mask          */
N
N#define CAN_TEST_TX_Pos            5                                    /*!< CAN_T::TEST: TX Position      */
N#define CAN_TEST_TX_Msk            (0x3ul << CAN_TEST_TX_Pos)           /*!< CAN_T::TEST: TX Mask          */
N
N#define CAN_TEST_LBACK_Pos         4                                    /*!< CAN_T::TEST: LBACK Position   */
N#define CAN_TEST_LBACK_Msk         (1ul << CAN_TEST_LBACK_Pos)          /*!< CAN_T::TEST: LBACK Mask       */
N
N#define CAN_TEST_SILENT_Pos        3                                    /*!< CAN_T::TEST: Silent Position  */
N#define CAN_TEST_SILENT_Msk        (1ul << CAN_TEST_SILENT_Pos)         /*!< CAN_T::TEST: Silent Mask      */
N
N#define CAN_TEST_BASIC_Pos         2                                    /*!< CAN_T::TEST: Basic Position   */
N#define CAN_TEST_BASIC_Msk         (1ul << CAN_TEST_BASIC_Pos)          /*!< CAN_T::TEST: Basic Mask       */
N
N/* CAN BPRE Bit Field Definitions */
N#define CAN_BRPE_BRPE_Pos          0                                    /*!< CAN_T::BRPE: BRPE Position    */
N#define CAN_BRPE_BRPE_Msk          (0xFul << CAN_BRPE_BRPE_Pos)         /*!< CAN_T::BRPE: BRPE Mask        */
N
N/* CAN IFn_CREQ Bit Field Definitions */
N#define CAN_IF_CREQ_BUSY_Pos       15                                   /*!< CAN_IF_T::CREQ: BUSY Position */
N#define CAN_IF_CREQ_BUSY_Msk       (1ul << CAN_IF_CREQ_BUSY_Pos)        /*!< CAN_IF_T::CREQ: BUSY Mask     */
N
N#define CAN_IF_CREQ_MSGNUM_Pos     0                                    /*!< CAN_IF_T::CREQ: MSGNUM Position */
N#define CAN_IF_CREQ_MSGNUM_Msk     (0x3Ful << CAN_IF_CREQ_MSGNUM_Pos)   /*!< CAN_IF_T::CREQ: MSGNUM Mask     */
N
N/* CAN IFn_CMASK Bit Field Definitions */
N#define CAN_IF_CMASK_WRRD_Pos      7                                    /*!< CAN_IF_T::CMASK: WRRD Position */
N#define CAN_IF_CMASK_WRRD_Msk      (1ul << CAN_IF_CMASK_WRRD_Pos)       /*!< CAN_IF_T::CMASK: WRRD Mask     */
N
N#define CAN_IF_CMASK_MASK_Pos      6                                    /*!< CAN_IF_T::CMASK: MASK Position */
N#define CAN_IF_CMASK_MASK_Msk      (1ul << CAN_IF_CMASK_MASK_Pos)       /*!< CAN_IF_T::CMASK: MASK Mask     */
N
N#define CAN_IF_CMASK_ARB_Pos       5                                    /*!< CAN_IF_T::CMASK: ARB Position  */
N#define CAN_IF_CMASK_ARB_Msk       (1ul << CAN_IF_CMASK_ARB_Pos)        /*!< CAN_IF_T::CMASK: ARB Mask      */
N
N#define CAN_IF_CMASK_CONTROL_Pos   4                                    /*!< CAN_IF_T::CMASK: CONTROL Position */
N#define CAN_IF_CMASK_CONTROL_Msk   (1ul << CAN_IF_CMASK_CONTROL_Pos)    /*!< CAN_IF_T::CMASK: CONTROL Mask */
N
N#define CAN_IF_CMASK_CLRINTPND_Pos 3                                    /*!< CAN_IF_T::CMASK: CLRINTPND Position */
N#define CAN_IF_CMASK_CLRINTPND_Msk (1ul << CAN_IF_CMASK_CLRINTPND_Pos)  /*!< CAN_IF_T::CMASK: CLRINTPND Mask */
N
N#define CAN_IF_CMASK_TXRQSTNEWDAT_Pos 2                                         /*!< CAN_IF_T::CMASK: TXRQSTNEWDAT Position */
N#define CAN_IF_CMASK_TXRQSTNEWDAT_Msk (1ul << CAN_IF_CMASK_TXRQSTNEWDAT_Pos)    /*!< CAN_IF_T::CMASK: TXRQSTNEWDAT Mask     */
N
N#define CAN_IF_CMASK_DATAA_Pos     1                                    /*!< CAN_IF_T::CMASK: DATAA Position */
N#define CAN_IF_CMASK_DATAA_Msk     (1ul << CAN_IF_CMASK_DATAA_Pos)      /*!< CAN_IF_T::CMASK: DATAA Mask     */
N
N#define CAN_IF_CMASK_DATAB_Pos     0                                    /*!< CAN_IF_T::CMASK: DATAB Position */
N#define CAN_IF_CMASK_DATAB_Msk     (1ul << CAN_IF_CMASK_DATAB_Pos)      /*!< CAN_IF_T::CMASK: DATAB Mask     */
N
N/* CAN IFn_MASK1 Bit Field Definitions */
N#define CAN_IF_MASK1_MSK_Pos       0                                    /*!< CAN_IF_T::MASK1: MSK Position   */
N#define CAN_IF_MASK1_MSK_Msk       (0xFFul << CAN_IF_MASK1_MSK_Pos)     /*!< CAN_IF_T::MASK1: MSK Mask       */
N
N/* CAN IFn_MASK2 Bit Field Definitions */
N#define CAN_IF_MASK2_MXTD_Pos      15                                   /*!< CAN_IF_T::MASK2: MXTD Position */
N#define CAN_IF_MASK2_MXTD_Msk      (1ul << CAN_IF_MASK2_MXTD_Pos)       /*!< CAN_IF_T::MASK2: MXTD Mask     */
N
N#define CAN_IF_MASK2_MDIR_Pos      14                                   /*!< CAN_IF_T::MASK2: MDIR Position */
N#define CAN_IF_MASK2_MDIR_Msk      (1ul << CAN_IF_MASK2_MDIR_Pos)       /*!< CAN_IF_T::MASK2: MDIR Mask     */
N
N#define CAN_IF_MASK2_MSK_Pos       0                                    /*!< CAN_IF_T::MASK2: MSK Position */
N#define CAN_IF_MASK2_MSK_Msk       (0x1FFul << CAN_IF_MASK2_MSK_Pos)    /*!< CAN_IF_T::MASK2: MSK Mask     */
N
N/* CAN IFn_ARB1 Bit Field Definitions */
N#define CAN_IF_ARB1_ID_Pos         0                                    /*!< CAN_IF_T::ARB1: ID Position   */
N#define CAN_IF_ARB1_ID_Msk         (0xFFFFul << CAN_IF_ARB1_ID_Pos)     /*!< CAN_IF_T::ARB1: ID Mask       */
N
N/* CAN IFn_ARB2 Bit Field Definitions */
N#define CAN_IF_ARB2_MSGVAL_Pos     15                                   /*!< CAN_IF_T::ARB2: MSGVAL Position */
N#define CAN_IF_ARB2_MSGVAL_Msk     (1ul << CAN_IF_ARB2_MSGVAL_Pos)      /*!< CAN_IF_T::ARB2: MSGVAL Mask     */
N
N#define CAN_IF_ARB2_XTD_Pos        14                                   /*!< CAN_IF_T::ARB2: XTD Position    */
N#define CAN_IF_ARB2_XTD_Msk        (1ul << CAN_IF_ARB2_XTD_Pos)         /*!< CAN_IF_T::ARB2: XTD Mask        */
N
N#define CAN_IF_ARB2_DIR_Pos        13                                   /*!< CAN_IF_T::ARB2: DIR Position    */
N#define CAN_IF_ARB2_DIR_Msk        (1ul << CAN_IF_ARB2_DIR_Pos)         /*!< CAN_IF_T::ARB2: DIR Mask        */
N
N#define CAN_IF_ARB2_ID_Pos         0                                    /*!< CAN_IF_T::ARB2: ID Position     */
N#define CAN_IF_ARB2_ID_Msk         (0x1FFFul << CAN_IF_ARB2_ID_Pos)     /*!< CAN_IF_T::ARB2: ID Mask         */
N
N/* CAN IFn_MCON Bit Field Definitions */
N#define CAN_IF_MCON_NEWDAT_Pos     15                                   /*!< CAN_IF_T::MCON: NEWDAT Position */
N#define CAN_IF_MCON_NEWDAT_Msk     (1ul << CAN_IF_MCON_NEWDAT_Pos)      /*!< CAN_IF_T::MCON: NEWDAT Mask     */
N
N#define CAN_IF_MCON_MSGLST_Pos     14                                   /*!< CAN_IF_T::MCON: MSGLST Position */
N#define CAN_IF_MCON_MSGLST_Msk     (1ul << CAN_IF_MCON_MSGLST_Pos)      /*!< CAN_IF_T::MCON: MSGLST Mask     */
N
N#define CAN_IF_MCON_INTPND_Pos     13                                   /*!< CAN_IF_T::MCON: INTPND Position */
N#define CAN_IF_MCON_INTPND_Msk     (1ul << CAN_IF_MCON_INTPND_Pos)      /*!< CAN_IF_T::MCON: INTPND Mask     */
N
N#define CAN_IF_MCON_UMASK_Pos      12                                   /*!< CAN_IF_T::MCON: UMASK Position  */
N#define CAN_IF_MCON_UMASK_Msk      (1ul << CAN_IF_MCON_UMASK_Pos)       /*!< CAN_IF_T::MCON: UMASK Mask      */
N
N#define CAN_IF_MCON_TXIE_Pos       11                                   /*!< CAN_IF_T::MCON: TXIE Position   */
N#define CAN_IF_MCON_TXIE_Msk       (1ul << CAN_IF_MCON_TXIE_Pos)        /*!< CAN_IF_T::MCON: TXIE Mask       */
N
N#define CAN_IF_MCON_RXIE_Pos       10                                   /*!< CAN_IF_T::MCON: RXIE Position   */
N#define CAN_IF_MCON_RXIE_Msk       (1ul << CAN_IF_MCON_RXIE_Pos)        /*!< CAN_IF_T::MCON: RXIE Mask       */
N
N#define CAN_IF_MCON_RMTEN_Pos      9                                    /*!< CAN_IF_T::MCON: RMTEN Position  */
N#define CAN_IF_MCON_RMTEN_Msk      (1ul << CAN_IF_MCON_RMTEN_Pos)       /*!< CAN_IF_T::MCON: RMTEN Mask      */
N
N#define CAN_IF_MCON_TXRQST_Pos     8                                    /*!< CAN_IF_T::MCON: TXRQST Position */
N#define CAN_IF_MCON_TXRQST_Msk     (1ul << CAN_IF_MCON_TXRQST_Pos)      /*!< CAN_IF_T::MCON: TXRQST Mask     */
N
N#define CAN_IF_MCON_EOB_Pos        7                                    /*!< CAN_IF_T::MCON: EOB Position    */
N#define CAN_IF_MCON_EOB_Msk        (1ul << CAN_IF_MCON_EOB_Pos)         /*!< CAN_IF_T::MCON: EOB Mask        */
N
N#define CAN_IF_MCON_DLC_Pos        0                                    /*!< CAN_IF_T::MCON: DLC Position    */
N#define CAN_IF_MCON_DLC_Msk        (0xFul << CAN_IF_MCON_DLC_Pos)       /*!< CAN_IF_T::MCON: DLC Mask        */
N
N/* CAN IFn_DATA_A1 Bit Field Definitions */
N#define CAN_IF_DAT_A1_DATA1_Pos    8                                    /*!< CAN_IF_T::DAT_A1: DATA1 Position */
N#define CAN_IF_DAT_A1_DATA1_Msk    (0xFFul << CAN_IF_DAT_A1_DATA1_Pos)  /*!< CAN_IF_T::DAT_A1: DATA1 Mask     */
N
N#define CAN_IF_DAT_A1_DATA0_Pos    0                                    /*!< CAN_IF_T::DAT_A1: DATA0 Position */
N#define CAN_IF_DAT_A1_DATA0_Msk    (0xFFul << CAN_IF_DAT_A1_DATA0_Pos)  /*!< CAN_IF_T::DAT_A1: DATA0 Mask     */
N
N/* CAN IFn_DATA_A2 Bit Field Definitions */
N#define CAN_IF_DAT_A2_DATA3_Pos    8                                    /*!< CAN_IF_T::DAT_A1: DATA3 Position */
N#define CAN_IF_DAT_A2_DATA3_Msk    (0xFFul << CAN_IF_DAT_A2_DATA3_Pos)  /*!< CAN_IF_T::DAT_A1: DATA3 Mask     */
N
N#define CAN_IF_DAT_A2_DATA2_Pos    0                                    /*!< CAN_IF_T::DAT_A1: DATA2 Position */
N#define CAN_IF_DAT_A2_DATA2_Msk    (0xFFul << CAN_IF_DAT_A2_DATA2_Pos)  /*!< CAN_IF_T::DAT_A1: DATA2 Mask     */
N
N/* CAN IFn_DATA_B1 Bit Field Definitions */
N#define CAN_IF_DAT_B1_DATA5_Pos    8                                    /*!< CAN_IF_T::DAT_B1: DATA5 Position */
N#define CAN_IF_DAT_B1_DATA5_Msk    (0xFFul << CAN_IF_DAT_B1_DATA5_Pos)  /*!< CAN_IF_T::DAT_B1: DATA5 Mask */
N
N#define CAN_IF_DAT_B1_DATA4_Pos    0                                    /*!< CAN_IF_T::DAT_B1: DATA4 Position */
N#define CAN_IF_DAT_B1_DATA4_Msk    (0xFFul << CAN_IF_DAT_B1_DATA4_Pos)  /*!< CAN_IF_T::DAT_B1: DATA4 Mask */
N
N/* CAN IFn_DATA_B2 Bit Field Definitions */
N#define CAN_IF_DAT_B2_DATA7_Pos    8                                    /*!< CAN_IF_T::DAT_B2: DATA7 Position */
N#define CAN_IF_DAT_B2_DATA7_Msk    (0xFFul << CAN_IF_DAT_B2_DATA7_Pos)  /*!< CAN_IF_T::DAT_B2: DATA7 Mask     */
N
N#define CAN_IF_DAT_B2_DATA6_Pos    0                                    /*!< CAN_IF_T::DAT_B2: DATA6 Position */
N#define CAN_IF_DAT_B2_DATA6_Msk    (0xFFul << CAN_IF_DAT_B2_DATA6_Pos)  /*!< CAN_IF_T::DAT_B2: DATA6 Mask     */
N
N/* CAN IFn_TXRQST1 Bit Field Definitions */
N#define CAN_IF_TXRQST1_TXRQST_Pos  0                                        /*!< CAN_T::TXRQST1: TXRQST Position */
N#define CAN_IF_TXRQST1_TXRQST_Msk  (0xFFFFul << CAN_IF_TXRQST1_TXRQST_Pos)  /*!< CAN_T::TXRQST1: TXRQST Mask     */
N
N/* CAN IFn_TXRQST2 Bit Field Definitions */
N#define CAN_IF_TXRQST2_TXRQST_Pos  0                                        /*!< CAN_T::TXRQST2: TXRQST Position  */
N#define CAN_IF_TXRQST2_TXRQST_Msk  (0xFFFFul << CAN_IF_TXRQST2_TXRQST_Pos)  /*!< CAN_T::TXRQST2: TXRQST Mask      */
N
N/* CAN IFn_NDAT1 Bit Field Definitions */
N#define CAN_IF_NDAT1_NEWDATA_Pos   0                                        /*!< CAN_T::NDAT1: NEWDATA Position */
N#define CAN_IF_NDAT1_NEWDATA_Msk   (0xFFFFul << CAN_IF_NDAT1_NEWDATA_Pos)   /*!< CAN_T::NDAT1: NEWDATA Mask     */
N
N/* CAN IFn_NDAT2 Bit Field Definitions */
N#define CAN_IF_NDAT2_NEWDATA_Pos   0                                        /*!< CAN_T::NDAT2: NEWDATA Position */
N#define CAN_IF_NDAT2_NEWDATA_Msk   (0xFFFFul << CAN_IF_NDAT2_NEWDATA_Pos)   /*!< CAN_T::NDAT2: NEWDATA Mask     */
N
N/* CAN IFn_IPND1 Bit Field Definitions */
N#define CAN_IF_IPND1_INTPND_Pos   0                                         /*!< CAN_T::IPND1: INTPND Position */
N#define CAN_IF_IPND1_INTPND_Msk   (0xFFFFul << CAN_IF_IPND1_INTPND_Pos)     /*!< CAN_T::IPND1: INTPND Mask     */
N
N/* CAN IFn_IPND2 Bit Field Definitions */
N#define CAN_IF_IPND2_INTPND_Pos   0                                         /*!< CAN_T::IPND2: INTPND Position */
N#define CAN_IF_IPND2_INTPND_Msk   (0xFFFFul << CAN_IF_IPND2_INTPND_Pos)     /*!< CAN_T::IPND2: INTPND Mask     */
N
N/* CAN IFn_MVLD1 Bit Field Definitions */
N#define CAN_IF_MVLD1_MSGVAL_Pos   0                                         /*!< CAN_T::MVLD1: MSGVAL Position */
N#define CAN_IF_MVLD1_MSGVAL_Msk   (0xFFFFul << CAN_IF_MVLD1_MSGVAL_Pos)     /*!< CAN_T::MVLD1: MSGVAL Mask     */
N
N/* CAN IFn_MVLD2 Bit Field Definitions */
N#define CAN_IF_MVLD2_MSGVAL_Pos   0                                         /*!< CAN_T::MVLD2: MSGVAL Position */
N#define CAN_IF_MVLD2_MSGVAL_Msk   (0xFFFFul << CAN_IF_MVLD2_MSGVAL_Pos)     /*!< CAN_T::MVLD2: MSGVAL Mask     */
N
N/* CAN WUEN Bit Field Definitions */
N#define CAN_WUEN_WAKUP_EN_Pos     0                                         /*!< CAN_T::WU_EN: WAKUP_EN Position */
N#define CAN_WUEN_WAKUP_EN_Msk    (1ul << CAN_WUEN_WAKUP_EN_Pos)             /*!< CAN_T::WU_EN: WAKUP_EN Mask     */
N
N/* CAN WUSTATUS Bit Field Definitions */
N#define CAN_WUSTATUS_WAKUP_STS_Pos     0                                    /*!< CAN_T::WU_STATUS: WAKUP_STS Position */
N#define CAN_WUSTATUS_WAKUP_STS_Msk    (1ul << CAN_WUSTATUS_WAKUP_STS_Pos)   /*!< CAN_T::WU_STATUS: WAKUP_STS Mask     */
N/*@}*/ /* end of group CAN_CONST */
N/*@}*/ /* end of group CAN */
N
N
N/*---------------------------- Clock Controller ------------------------------*/
N/** @addtogroup CLK System Clock Controller (CLK)
N  Memory Mapped Structure for System Clock Controller
N  @{
N */
N
N
N
Ntypedef struct
N{
N
N
N
N/**
N * @var CLK_T::PWRCON
N * Offset: 0x00  System Power-down Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |XTL12M_EN |External 4~24 MHz High Speed Crystal Enable (HXT) Control (Write Protect)
N * |        |          |The bit default value is set by flash controller user configuration register CFOSC
N * |        |          |(Config0[26:24]).
N * |        |          |When the default clock source is from external 4~24 MHz high speed crystal, this bit is set to 1
N * |        |          |automatically.
N * |        |          |0 = External 4~24 MHz high speed crystal oscillator (HXT) Disabled.
N * |        |          |1 = External 4~24 MHz high speed crystal oscillator (HXT) Enabled.
N * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register.    
N * |[1]     |XTL32K_EN |External 32.768 KHz Low Speed Crystal Enable (LXT) Control (Write Protect)
N * |        |          |0 = External 32.768 kHz low speed crystal oscillator (LXT) Disabled.
N * |        |          |1 = External 32.768 kHz low speed crystal oscillator (LXT) Enabled (Normal operation).
N * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register. 
N * |[2]     |OSC22M_EN |Internal 22.1184 MHz High Speed Oscillator (HIRC) Enable Control (Write Protect)
N * |        |          |0 = Internal 22.1184 MHz high speed oscillator (HIRC) Disabled.
N * |        |          |1 = Internal 22.1184 MHz high speed oscillator (HIRC) Enabled.
N * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register. 
N * |[3]     |OSC10K_EN |Internal 10 KHz Low Speed Oscillator (LIRC) Enable Control (Write Protect)
N * |        |          |0 = Internal 10 kHz low speed oscillator (LIRC) Disabled.
N * |        |          |1 = Internal 10 kHz low speed oscillator (LIRC) Enabled.
N * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register.
N * |[4]     |PD_WU_DLY |Wake-up Delay Counter Enable Control (Write Protect)
N * |        |          |When the chip wakes up from Power-down mode, the clock control will delay certain clock cycles
N * |        |          |to wait system clock stable.
N * |        |          |The delayed clock cycle is 4096 clock cycles when chip work at external 4~24 MHz high speed
N * |        |          |crystal, and 256 clock cycles when chip work at internal 22.1184 MHz high speed oscillator.
N * |        |          |0 = Clock cycles delay Disabled.
N * |        |          |1 = Clock cycles delay Enabled.
N * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register.
N * |[5]     |PD_WU_INT_EN|Power-Down Mode Wake-Up Interrupt Enable Control (Write Protect)
N * |        |          |0 = Power-down mode wake-up interrupt Disabled.
N * |        |          |1 = Power-down mode wake-up interrupt Enabled.
N * |        |          |Note1: The interrupt will occur when both PD_WU_STS and PD_WU_INT_EN are high.
N * |        |          |Note2: This bit is write protected bit. Refer to the REGWRPROT register.
N * |[6]     |PD_WU_STS |Power-Down Mode Wake-Up Interrupt Status
N * |        |          |Set by "Power-down wake-up event", it indicates that resume from Power-down mode.
N * |        |          |The flag is set if the GPIO, USB, UART, WDT, I2C, TIMER, ACMP, BOD or RTC wake-up occurred.
N * |        |          |Write 1 to clear the bit to 0.
N * |        |          |Note: This bit is working only if PD_WU_INT_EN (PWRCON[5]) set to 1.
N * |[7]     |PWR_DOWN_EN|System Power-Down Enable Bit (Write Protect)
N * |        |          |When this bit is set to 1, Power-down mode is enabled and chip Power-down behavior willdepends
N * |        |          |on the PD_WAIT_CPU bit.
N * |        |          |(a) If the PD_WAIT_CPU is 0, then the chip enters Power-down mode immediately after the
N * |        |          |PWR_DOWN_EN bit set.
N * |        |          |(b) if the PD_WAIT_CPU is 1, then the chip keeps active till the CPU sleep mode is also active
N * |        |          |and then the chip enters Power-down mode. (recommend)
N * |        |          |When chip wakes up from Power-down mode, this bit is cleared by hardware.
N * |        |          |User needs to set this bit again for next Power-down.
N * |        |          |In Power-down mode, external 4~24 MHz high speed crystal oscillator and the internal 22.1184 MHz
N * |        |          |high speed oscillator will be disabled in this mode, 
N * |        |          |but the external 32.768 kHz low speed crystal and internal 10 kHz low speed oscillator are not
N * |        |          |controlled by Power-down mode.
N * |        |          |In Power- down mode, the PLL and system clock are disabled, and ignored the clock source
N * |        |          |selection.
N * |        |          |The clocks of peripheral are not controlled by Power-down mode, if the peripheral clock source
N * |        |          |is from external 32.768 kHz low speed crystal oscillator or the internal 10 kHz low speed
N * |        |          |oscillator.
N * |        |          |0 = Chip operating normally or chip in Idle mode because of WFI command.
N * |        |          |1 = Chip enters Power-down mode instantly or waits CPU sleep command WFI.
N * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register.
N * |[8]     |PD_WAIT_CPU|This Bit Control The Power-Down Entry Condition (Write Protect)
N * |        |          |0 = Chip enters Power-down mode when the PWR_DOWN_EN bit is set to 1.
N * |        |          |1 = Chip enters Power- down mode when the both PD_WAIT_CPU and PWR_DOWN_EN bits are set to 1 and
N * |        |          |CPU run WFI instruction.
N * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register.
N * @var CLK_T::AHBCLK
N * Offset: 0x04  AHB Devices Clock Enable Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1]     |PDMA_EN   |PDMA Controller Clock Enable Control
N * |        |          |0 = PDMA peripherial clock Disabled.
N * |        |          |1 = PDMA peripherial clock Enabled.
N * |[2]     |ISP_EN    |Flash ISP Controller Clock Enable Control
N * |        |          |0 = Flash ISP peripheral clock Disabled.
N * |        |          |1 = Flash ISP peripheral clock Enabled.    
N * |[3]     |EBI_EN    |EBI Controller Clock Enable Control
N * |        |          |0 = EBI peripherial clock Disabled.
N * |        |          |1 = EBI peripherial clock Enabled.
N * @var CLK_T::APBCLK
N * Offset: 0x08  APB Devices Clock Enable Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |WDT_EN    |Watchdog Timer Clock Enable Control (Write Protect)
N * |        |          |0 = Watchdog Timer clock Disabled.
N * |        |          |1 = Watchdog Timer clock Enabled.
N * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register.
N * |[1]     |RTC_EN    |Real-Time-Clock APB Interface Clock Enable Control
N * |        |          |This bit is used to control the RTC APB clock only, The RTC peripheral clock source is selected
N * |        |          |from RTC_SEL_10K(CLKSEL2[18]).
N * |        |          |It can be selected to the external 32.768 kHz low speed crystal or Internal 10 kHz low speed
N * |        |          |oscillator.
N * |        |          |0 = RTC clock Disabled.
N * |        |          |1 = RTC clock Enabled.
N * |[2]     |TMR0_EN   |Timer0 Clock Enable Control
N * |        |          |0 = Timer0 clock Disabled.
N * |        |          |1 = Timer0 clock Enabled.
N * |[3]     |TMR1_EN   |Timer1 Clock Enable Control
N * |        |          |0 = Timer1 clock Disabled.
N * |        |          |1 = Timer1 clock Enabled.
N * |[4]     |TMR2_EN   |Timer2 Clock Enable Control
N * |        |          |0 = Timer2 clock Disabled.
N * |        |          |1 = Timer2 clock Enabled.
N * |[5]     |TMR3_EN   |Timer3 Clock Enable Control
N * |        |          |0 = Timer3 clock Disabled.
N * |        |          |1 = Timer3 clock Enabled.
N * |[6]     |FDIV_EN   |Frequency Divider Output Clock Enable Control
N * |        |          |0 = FDIV clock Disabled.
N * |        |          |1 = FDIV clock Enabled.
N * |[8]     |I2C0_EN   |I2C0 Clock Enable Control
N * |        |          |0 = I2C0 clock Disabled.
N * |        |          |1 = I2C0 clock Enabled.
N * |[9]     |I2C1_EN   |I2C1 Clock Enable Control
N * |        |          |0 = I2C1 clock Disabled.
N * |        |          |1 = I2C1 clock Enabled.
N * |[12]    |SPI0_EN   |SPI0 Clock Enable Control
N * |        |          |0 = SPI0 clock Disabled.
N * |        |          |1 = SPI0 clock Enabled.
N * |[13]    |SPI1_EN   |SPI1 Clock Enable Control
N * |        |          |0 = SPI1 clock Disabled.
N * |        |          |1 = SPI1 clock Enabled.
N * |[14]    |SPI2_EN   |SPI2 Clock Enable Control
N * |        |          |0 = SPI2 clock Disabled.
N * |        |          |1 = SPI2 clock Enabled.
N * |[15]    |SPI3_EN   |SPI3 Clock Enable Control
N * |        |          |0 = SPI3 clock Disabled.
N * |        |          |1 = SPI3 clock Enabled.
N * |[16]    |UART0_EN  |UART0 Clock Enable Control
N * |        |          |0 = UART0 clock Disabled.
N * |        |          |1 = UART0 clock Enabled.
N * |[17]    |UART1_EN  |UART1 Clock Enable Control
N * |        |          |0 = UART1 clock Disabled.
N * |        |          |1 = UART1 clock Enabled.
N * |[18]    |UART2_EN  |UART2 Clock Enable Control
N * |        |          |0 = UART2 clock Disabled.
N * |        |          |1 = UART2 clock Enabled.
N * |[20]    |PWM01_EN  |PWM_01 Clock Enable Control
N * |        |          |0 = PWM01 clock Disabled.
N * |        |          |1 = PWM01 clock Enabled.
N * |[21]    |PWM23_EN  |PWM_23 Clock Enable Control
N * |        |          |0 = PWM23 clock Disabled.
N * |        |          |1 = PWM23 clock Enabled.
N * |[22]    |PWM45_EN  |PWM_45 Clock Enable Control
N * |        |          |0 = PWM45 clock Disabled.
N * |        |          |1 = PWM45 clock Enabled.
N * |[23]    |PWM67_EN  |PWM_67 Clock Enable Control
N * |        |          |0 = PWM67 clock Disabled.
N * |        |          |1 = PWM67 clock Enabled.
N * |[24]    |CAN0_EN   |CAN Bus Controller-0 Clock Enable Control
N * |        |          |0 = CAN0 clock Disabled.
N * |        |          |1 = CAN0 clock Enable.
N * |[25]    |CAN1_EN   |CAN Bus Controller-1 Clock Enable Control
N * |        |          |0 = CAN1 clock Disable.
N * |        |          |1 = CAN1 clock Enabled.
N * |[27]    |USBD_EN   |USB 2.0 FS Device Controller Clock Enable Control
N * |        |          |0 = USB clock Disabled.
N * |        |          |1 = USB clock Enabled.
N * |[28]    |ADC_EN    |Analog-Digital-Converter (ADC) Clock Enable Control
N * |        |          |0 = ADC clock Disabled.
N * |        |          |1 = ADC clock Enabled.
N * |[29]    |I2S_EN    |I2S Clock Enable Control
N * |        |          |0 = I2S clock Disabled.
N * |        |          |1 = I2S clock Enabled.
N * |[30]    |ACMP_EN   |Analog Comparator Clock Enable Control
N * |        |          |0 = Analog Comparator clock Disabled.
N * |        |          |1 = Analog Comparator clock Enabled.
N * |[31]    |PS2_EN    |PS/2 Clock Enable Control
N * |        |          |0 = PS/2 clock Disabled.
N * |        |          |1 = PS/2 clock Enabled.
N * @var CLK_T::CLKSTATUS
N * Offset: 0x0C  Clock status monitor Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |XTL12M_STB|External 4~24 MHz High Speed Crystal (HXT) Clock Source Stable Flag (Read Only)
N * |        |          |0 = External 4~24 MHz high speed crystal clock (HXT) is not stable or disabled.
N * |        |          |1 = External 4~24 MHz high speed crystal clock (HXT) is stable and enabled.
N * |[1]     |XTL32K_STB|External 32.768 KHz Low Speed Crystal (LXT) Clock Source Stable Flag(Read Only)
N * |        |          |0 = External 32.768 kHz low speed crystal (LXT) clock is not stable or disabled.
N * |        |          |1 = External 32.768 kHz low speed crystal (LXT) clock is stable and enabled.
N * |[2]     |PLL_STB   |Internal PLL Clock Source Stable Flag (Read Only)
N * |        |          |0 = Internal PLL clock is not stable or disabled.
N * |        |          |1 = Internal PLL clock is stable in normal mode.
N * |[3]     |OSC10K_STB|Internal 10 KHz Low Speed Oscillator (LIRC) Clock Source Stable Flag (Read Only)
N * |        |          |0 = Internal 10 kHz low speed oscillator clock (LIRC) is not stable or disabled.
N * |        |          |1 = Internal 10 kHz low speed oscillator clock (LIRC) is stable and enabled.
N * |[4]     |OSC22M_STB|Internal 22.1184 MHz High Speed Oscillator (HIRC) Clock Source Stable Flag (Read Only)
N * |        |          |0 = Internal 22.1184 MHz high speed oscillator (HIRC) clock is not stable or disabled.
N * |        |          |1 = Internal 22.1184 MHz high speed oscillator (HIRC) clock is stable and enabled.
N * |[7]     |CLK_SW_FAIL|Clock Switching Fail Flag (Read Only)
N * |        |          |0 = Clock switching success.
N * |        |          |1 = Clock switching failure.
N * |        |          |This bit is an index that if current system clock source is match as user defined at HCLK_S
N * |        |          |(CLKSEL[2:0]).
N * |        |          |When user switch system clock, the system clock source will keep old clock until the new clock
N * |        |          |is stable.
N * |        |          |During the period that waiting new clock stable, this bit will be an index shows system clock
N * |        |          |source is not match as user wanted.
N * @var CLK_T::CLKSEL0
N * Offset: 0x10  Clock Source Select Control Register 0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[2:0]   |HCLK_S    |HCLK Clock Source Selection (Write Protect)
N * |        |          |1. Before clock switching, the related clock sources (both pre-select and new-select) must be
N * |        |          |turn on.
N * |        |          |2. The 3-bit default value is reloaded from the value of CFOSC (Config0[26:24]) in user
N * |        |          |configuration register of Flash controller by any reset. Therefore the default value is either
N * |        |          |000b or 111b.
N * |        |          |000 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
N * |        |          |001 = Clock source from external 32.768 kHz low speed crystal oscillator clock.
N * |        |          |010 = Clock source from PLL clock.
N * |        |          |011 = Clock source from internal 10 kHz low speed oscillator clock.
N * |        |          |111 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N * |        |          |Note: These bits are write protected bit. Refer to the REGWRPROT register.
N * |[5:3]   |STCLK_S   |Cortex-M0 SysTick Clock Source Selection (Write Protect)
N * |        |          |If SYST_CSR[2] = 1, SysTick clock source is from HCLK.
N * |        |          |If SYST_CSR[2] = 0, SysTick clock source is defined by STCLK_S(CLKSEL0[5:3]).
N * |        |          |000 = Clock source from external 4~24 MHz high speed crystal clock.
N * |        |          |001 = Clock source from external 32.768 kHz low speed crystal clock.
N * |        |          |010 = Clock source from external 4~24 MHz high speed crystal clock/2.
N * |        |          |011 = Clock source from HCLK/2.
N * |        |          |111 = Clock source from internal 22.1184 MHz high speed oscillator clock/2.
N * |        |          |Note1: These bits are write protected bit. Refer to the REGWRPROT register.
N * |        |          |Note2: if SysTick clock source is not from HCLK (i.e. SYST_CSR[2] = 0), SysTick clock source
N * |        |          |must less than or equal to HCLK/2.
N * @var CLK_T::CLKSEL1
N * Offset: 0x14  Clock Source Select Control Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1:0]   |WDT_S     |Watchdog Timer Clock Source Select (Write Protect)
N * |        |          |00 = Reserved.
N * |        |          |01 = Clock source from external 32.768 kHz low speed crystal oscillator clock.
N * |        |          |10 = Clock source from HCLK/2048 clock.
N * |        |          |11 = Clock source from internal 10 kHz low speed oscillator clock.
N * |        |          |Note: These bits are write protected bit. Refer to the REGWRPROT register.
N * |[3:2]   |ADC_S     |ADC Clock Source Select
N * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
N * |        |          |01 = Clock source from PLL clock.
N * |        |          |10 = Clock source from HCLK.
N * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N * |[4]     |SPI0_S    |SPI0 Clock Source Selection
N * |        |          |0 = Clock source from PLL clock.
N * |        |          |1 = Clock source from HCLK.
N * |[5]     |SPI1_S    |SPI1 Clock Source Selection
N * |        |          |0 = Clock source from PLL clock.
N * |        |          |1 = Clock source from HCLK.
N * |[6]     |SPI2_S    |SPI2 Clock Source Selection
N * |        |          |0 = Clock source from PLL clock.
N * |        |          |1 = Clock source from HCLK.
N * |[7]     |SPI3_S    |SPI3 Clock Source Selection
N * |        |          |0 = Clock source from PLL clock.
N * |        |          |1 = Clock source from HCLK.
N * |[10:8]  |TMR0_S    |TIMER0 Clock Source Selection
N * |        |          |000 = Clock source from external 4~24 MHz high speed crystal clock.
N * |        |          |001 = Clock source from external 32.768 kHz low speed crystal clock.
N * |        |          |010 = Clock source from HCLK.
N * |        |          |011 = Clock source from external trigger.
N * |        |          |101 = Clock source from internal 10 kHz low speed oscillator clock.
N * |        |          |111 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N * |        |          |Others = Reserved.
N * |[14:12] |TMR1_S    |TIMER1 Clock Source Selection
N * |        |          |000 = Clock source from external 4~24 MHz high speed crystal clock.
N * |        |          |001 = Clock source from external 32.768 kHz low speed crystal clock.
N * |        |          |010 = Clock source from HCLK.
N * |        |          |011 = Clock source from external trigger.
N * |        |          |101 = Clock source from internal 10 kHz low speed oscillator clock.
N * |        |          |111 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N * |        |          |Others = Reserved.
N * |[18:16] |TMR2_S    |TIMER2 Clock Source Selection
N * |        |          |000 = Clock source from external 4~24 MHz high speed crystal clock.
N * |        |          |001 = Clock source from external 32.768 kHz low speed crystal clock.
N * |        |          |010 = Clock source from HCLK.
N * |        |          |011 = Clock source from external trigger.
N * |        |          |101 = Clock source from internal 10 kHz low speed oscillator clock.
N * |        |          |111 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N * |        |          |Others = Reserved.
N * |[22:20] |TMR3_S    |TIMER3 Clock Source Selection
N * |        |          |000 = Clock source from external 4~24 MHz high speed crystal clock.
N * |        |          |001 = Clock source from external 32.768 kHz low speed crystal clock.
N * |        |          |010 = Clock source from HCLK.
N * |        |          |011 = Clock source from external trigger.
N * |        |          |101 = Clock source from internal 10 kHz low speed oscillator clock.
N * |        |          |111 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N * |        |          |Others = Reserved.
N * |[25:24] |UART_S    |UART Clock Source Selection
N * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
N * |        |          |01 = Clock source from PLL clock.
N * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N * |[29:28] |PWM01_S   |PWM0 And PWM1 Clock Source Selection
N * |        |          |PWM0 and PWM1 used the same clock source; both of them used the same prescaler.
N * |        |          |The clock source of PWM0 and PWM1 is defined by PWM01_S (CLKSEL1[29:28]) and PWM01_S_E
N * |        |          |(CLKSEL2[8]).
N * |        |          |If PWM01_S_E = 0, the clock source of PWM0 and PWM1 defined by PWM01_S list below:
N * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
N * |        |          |01 = Clock source from external 32.768 kHz low speed crystal oscillator clock.
N * |        |          |10 = Clock source from HCLK.
N * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N * |        |          |If PWM01_S_E = 1, the clock source of PWM0 and PWM1 defined by PWM01_S list below:
N * |        |          |00 = Reserved.
N * |        |          |01 = Reserved.
N * |        |          |10 = Reserved.
N * |        |          |11 = Clock source from internal 10 kHz low speed oscillator clock.
N * |[31:30] |PWM23_S   |PWM2 And PWM3 Clock Source Selection
N * |        |          |PWM2 and PWM3 used the same clock source; both of them used the same prescaler.
N * |        |          |The clock source of PWM2 and PWM3 is defined by PWM23_S (CLKSEL1[31:30]) and PWM23_S_E
N * |        |          |(CLKSEL2[9]).
N * |        |          |If PWM23_S_E = 0, the clock source of PWM2 and PWM3 defined by PWM23_S list below:
N * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
N * |        |          |01 = Clock source from external 32.768 kHz low speed crystal oscillator clock.
N * |        |          |10 = Clock source from HCLK.
N * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N * |        |          |If PWM23_S_E = 1, the clock source of PWM2 and PWM3 defined by PWM23_S list below:
N * |        |          |00 = Reserved.
N * |        |          |01 = Reserved.
N * |        |          |10 = Reserved.
N * |        |          |11 = Clock source from internal 10 kHz low speed oscillator clock.
N * @var CLK_T::CLKDIV
N * Offset: 0x18  Clock Divider Number Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |HCLK_N    |HCLK Clock Divide Number From HCLK Clock Source
N * |        |          |HCLK clock frequency = (HCLK clock source frequency) / (HCLK_N + 1).
N * |[7:4]   |USB_N     |USB Clock Divide Number From PLL Clock
N * |        |          |USB clock frequency = (PLL frequency) / (USB_N + 1).
N * |[11:8]  |UART_N    |UART Clock Divide Number From UART Clock Source
N * |        |          |UART clock frequency = (UART clock source frequency) / (UART_N + 1).
N * |[23:16] |ADC_N     |ADC Clock Divide Number From ADC Clock Source
N * |        |          |ADC clock frequency = (ADC clock source frequency) / (ADC_N + 1).
N * @var CLK_T::CLKSEL2
N * Offset: 0x1C  Clock Source Select Control Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1:0]   |I2S_S     |I2S Clock Source Selection
N * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
N * |        |          |01 = Clock source from PLL clock.
N * |        |          |10 = Clock source from HCLK.
N * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N * |[3:2]   |FRQDIV_S  |Clock Divider Clock Source Selection
N * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
N * |        |          |01 = Clock source from external 32.768 kHz low speed crystal oscillator clock.
N * |        |          |10 = Clock source from HCLK.
N * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N * |[5:4]   |PWM45_S   |PWM4 And PWM5 Clock Source Selection
N * |        |          |PWM4 and PWM5 used the same clock source; both of them used the same prescaler.
N * |        |          |The clock source of PWM4 and PWM5 is defined by PWM45_S (CLKSEL2[5:4]) and PWM45_S_E
N * |        |          |(CLKSEL2[10]).
N * |        |          |If PWM45_S_E = 0, the clock source of PWM4 and PWM5 defined by PWM45_S list below:
N * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
N * |        |          |01 = Clock source from external 32.768 kHz low speed crystal oscillator clock.
N * |        |          |10 = Clock source from HCLK.
N * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N * |        |          |If PWM45_S_E = 1, the clock source of PWM4 and PWM5 defined by PWM45_S list below:
N * |        |          |00 = Reserved.
N * |        |          |01 = Reserved.
N * |        |          |10 = Reserved.
N * |        |          |11 = Clock source from internal 10 kHz low speed oscillator clock.
N * |[7:6]   |PWM67_S   |PWM6 And PWM7 Clock Source Selection
N * |        |          |PWM6 and PWM7 used the sameclock source; both of them used the same prescaler.
N * |        |          |The clock source of PWM6 and PWM7 is defined by PWM67_S (CLKSEL2[7:6]) and PWM67_S_E
N * |        |          |(CLKSEL2[11]).
N * |        |          |If PWM67_S_E = 0, the clock source of PWM6 and PWM7 defined by PWM67_S list below:
N * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
N * |        |          |01 = Clock source from external 32.768 kHz low speed crystal oscillator clock.
N * |        |          |10 = Clock source from HCLK.
N * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N * |        |          |If PWM67_S_E = 1, the clock source of PWM6 and PWM7 defined by PWM67_S list below:
N * |        |          |00 = Reserved.
N * |        |          |01 = Reserved.
N * |        |          |10 = Reserved.
N * |        |          |11 = Clock source from internal 10 kHz low speed oscillator clock.
N * |[8]     |PWM01_S_E |PWM0 And PWM1 Clock Source Selection Extend
N * |        |          |PWM0 and PWM1 used the same clock source; both of them used the same prescaler.
N * |        |          |The clock source of PWM0 and PWM1 is defined by PWM01_S (CLKSEL1[29:28]) and PWM01_S_E
N * |        |          |(CLKSEL2[8]).
N * |        |          |If PWM01_S_E = 0, the clock source of PWM0 and PWM1 defined by PWM01_S list below:
N * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
N * |        |          |01 = Clock source from external 32.768 kHz low speed crystal oscillator clock.
N * |        |          |10 = Clock source from HCLK.
N * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N * |        |          |If PWM01_S_E = 1, the clock source of PWM0 and PWM1 defined by PWM01_S list below:
N * |        |          |00 = Reserved.
N * |        |          |01 = Reserved.
N * |        |          |10 = Reserved.
N * |        |          |11 = Clock source from internal 10 kHz low speed oscillator clock.
N * |[9]     |PWM23_S_E |PWM2 And PWM3 Clock Source Selection Extend
N * |        |          |PWM2 and PWM3 used the same clock source; both of them used the same prescaler.
N * |        |          |The clock source of PWM2 and PWM3 is defined by PWM23_S (CLKSEL1[31:30]) and PWM23_S_E
N * |        |          |(CLKSEL2[9]).
N * |        |          |If PWM23_S_E = 0, the clock source of PWM2 and PWM3 defined by PWM23_S list below:
N * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
N * |        |          |01 = Clock source from external 32.768 kHz low speed crystal oscillator clock.
N * |        |          |10 = Clock source from HCLK.
N * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N * |        |          |If PWM23_S_E = 1, the clock source of PWM2 and PWM3 defined by PWM23_S listbelow:
N * |        |          |00 = Reserved.
N * |        |          |01 = Reserved.
N * |        |          |10 = Reserved.
N * |        |          |11 = Clock source from internal 10 kHz low speed oscillator clock.
N * |[10]    |PWM45_S_E |PWM4 And PWM5 Clock Source Selection Extend
N * |        |          |PWM4 and PWM5 used the same clock source; both of them used the same prescaler.
N * |        |          |The clock source of PWM4 and PWM5 is defined by PWM45_S (CLKSEL2[5:4]) and PWM45_S_E
N * |        |          |(CLKSEL2[10]).
N * |        |          |If PWM45_S_E = 0, the clock source of PWM4 and PWM5 defined by PWM45_S list below:
N * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
N * |        |          |01 = Clock source from external 32.768 kHz low speed crystal oscillator clock.
N * |        |          |10 = Clock source from HCLK.
N * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N * |        |          |If PWM45_S_E = 1, the clock source of PWM4 and PWM5 defined by PWM45_S list below:
N * |        |          |00 = Reserved.
N * |        |          |01 = Reserved.
N * |        |          |10 = Reserved.
N * |        |          |11 = Clock source from internal 10 kHz low speed oscillator clock.
N * |[11]    |PWM67_S_E |PWM6 And PWM7 Clock Source Selection Extend
N * |        |          |PWM6 and PWM7 used the same clock source; both of them used the same prescaler.
N * |        |          |The clock source of PWM6 and PWM7 is defined by PWM67_S (CLKSEL2[7:6]) and PWM67_S_E
N * |        |          |(CLKSEL2[11]).
N * |        |          |If PWM67_S_E = 0, the peripheral clock source of PWM6 and PWM7 defined by PWM67_S list below:
N * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
N * |        |          |01 = Clock source from external 32.768 kHz low speed crystal oscillator clock.
N * |        |          |10 = Clock source from HCLK.
N * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N * |        |          |If PWM67_S_E = 1, the clock source of PWM6 and PWM7 defined by PWM67_S list below:
N * |        |          |00 = Reserved.
N * |        |          |01 = Reserved.
N * |        |          |10 = Reserved.
N * |        |          |11 = Clock source from internal 10 kHz low speed oscillator clock.
N * |[17:16] |WWDT_S    |Window Watchdog Timer Clock Source Selection
N * |        |          |10 = Clock source from HCLK/2048 clock.
N * |        |          |11 = Clock source from internal 10 kHz low speed oscillator clock.
N * |[18]    |RTC_SEL_10K|RTC Clock Source Selection
N * |        |          |0 = External XTL32K.
N * |        |          |1 = Internal IRC 10K.
N * @var CLK_T::PLLCON
N * Offset: 0x20  PLL Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[8:0]   |FB_DV     |PLL Feedback Divider Control Bits
N * |        |          |Refer to the PLL formulas.
N * |[13:9]  |IN_DV     |PLL Input Divider Control Bits
N * |        |          |Refer to the PLL formulas.
N * |[15:14] |OUT_DV    |PLL Output Divider Control Bits
N * |        |          |Refer to the PLL formulas.
N * |[16]    |PD        |Power-Down Mode
N * |        |          |If the PWR_DOWN_EN bit is set to 1 in PWRCON register, the PLL will enter Power-down mode too. 
N * |        |          |0 = PLL is in Normal mode.
N * |        |          |1 = PLL is in Power-down mode (default).
N * |[17]    |BP        |PLL Bypass Control
N * |        |          |0 = PLL is in Normal mode (default).
N * |        |          |1 = PLL clock output is same as PLL source clock input.
N * |[18]    |OE        |PLL OE (FOUT Enable) Control
N * |        |          |0 = PLL FOUT Enabled.
N * |        |          |1 = PLL FOUT is fixed low.
N * |[19]    |PLL_SRC   |PLL Source Clock Selection
N * |        |          |0 = PLL source clock from external 4~24 MHz high speed crystal.
N * |        |          |1 = PLL source clock from internal 22.1184 MHz high speed oscillator.
N * @var CLK_T::FRQDIV
N * Offset: 0x24  Frequency Divider Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |FSEL      |Divider Output Frequency Selection Bits
N * |        |          |The formula of output frequency is Fout = Fin/2(N+1).
N * |        |          |Fin is the input clock frequency.
N * |        |          |Fout is the frequency of divider output clock.
N * |        |          |N is the 4-bit value of FSEL[3:0].
N * |[4]     |DIVIDER_EN|Frequency Divider Enable Bit
N * |        |          |0 = Frequency Divider function Disabled.
N * |        |          |1 = Frequency Divider function Enabled.
N * |[5]     |DIVIDER1  |Frequency Divider One Enable Bit
N * |        |          |0 = Frequency divider will output clock with source frequency divided by FSEL.
N * |        |          |1 = Frequency divider will output clock with source frequency.
N * |[6]     |CLKO_1HZ_EN|Clock Output 1Hz Enable Bit
N * |        |          |0 = 1 Hz clock output for 32K frequency compensation Disabled.
N * |        |          |1 = 1 Hz clock output for 32K frequency compensation Enabled.
N * @var CLK_T::APBCLK1
N * Offset: 0x30  APB Devices Clock Enable Control Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |SC0_EN    |SC0 Clock Enable Control
N * |        |          |0 = SC0 Clock Disabled.
N * |        |          |1 = SC0 Clock Enabled.
N * |[1]     |SC1_EN    |SC1 Clock Enable Control
N * |        |          |0 = SC1 clock Disabled.
N * |        |          |1 = SC1 clock Enabled.
N * |[2]     |SC2_EN    |SC2 Clock Enable Control
N * |        |          |0 = SC2 clock Disabled.
N * |        |          |1 = SC2 clock Enabled.
N * @var CLK_T::CLKSEL3
N * Offset: 0x34  Clock Source Select Control Register 3
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1:0]   |SC0_S     |SC0 Clock Source Selection
N * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
N * |        |          |01 = Clock source from PLL clock.
N * |        |          |10 = HCLK.
N * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N * |[3:2]   |SC1_S     |SC1 Clock Source Selection
N * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
N * |        |          |01 = Clock source from PLL clock.
N * |        |          |10 = HCLK.
N * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N * |[5:4]   |SC2_S     |SC2 Clock Source Selection
N * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
N * |        |          |01 = Clock source from PLL clock.
N * |        |          |10 = HCLK.
N * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
N * @var CLK_T::CLKDIV1
N * Offset: 0x38  Clock Divider Number Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |SC0_N     |SC0 Clock Divide Number From SC0 Clock Source
N * |        |          |The SC0 clock frequency = (SC0 clock source frequency) / (SC0_N + 1).
N * |[15:8]  |SC1_N     |SC1 Clock Divide Number From SC1 Clock Source
N * |        |          |The SC1 clock frequency = (SC1 clock source frequency) / (SC1_N + 1).
N * |[23:16] |SC2_N     |SC2 Clock Divide Number From SC2 Clock Source
N * |        |          |The SC2 clock frequency = (SC2 clock source frequency) / (SC2_N + 1).
N */
N
N    __IO uint32_t PWRCON;        /* Offset: 0x00  System Power-down Control Register                                 */
X    volatile uint32_t PWRCON;         
N    __IO uint32_t AHBCLK;        /* Offset: 0x04  AHB Devices Clock Enable Control Register                          */
X    volatile uint32_t AHBCLK;         
N    __IO uint32_t APBCLK;        /* Offset: 0x08  APB Devices Clock Enable Control Register                          */
X    volatile uint32_t APBCLK;         
N    __IO uint32_t CLKSTATUS;     /* Offset: 0x0C  Clock status monitor Register                                      */
X    volatile uint32_t CLKSTATUS;      
N    __IO uint32_t CLKSEL0;       /* Offset: 0x10  Clock Source Select Control Register 0                             */
X    volatile uint32_t CLKSEL0;        
N    __IO uint32_t CLKSEL1;       /* Offset: 0x14  Clock Source Select Control Register 1                             */
X    volatile uint32_t CLKSEL1;        
N    __IO uint32_t CLKDIV;        /* Offset: 0x18  Clock Divider Number Register                                      */
X    volatile uint32_t CLKDIV;         
N    __IO uint32_t CLKSEL2;       /* Offset: 0x1C  Clock Source Select Control Register 2                             */
X    volatile uint32_t CLKSEL2;        
N    __IO uint32_t PLLCON;        /* Offset: 0x20  PLL Control Register                                               */
X    volatile uint32_t PLLCON;         
N    __IO uint32_t FRQDIV;        /* Offset: 0x24  Frequency Divider Control Register                                 */
X    volatile uint32_t FRQDIV;         
N    __IO uint32_t RESERVE[2];   
X    volatile uint32_t RESERVE[2];   
N    __IO uint32_t APBCLK1;       /* Offset: 0x30  APB Devices Clock Enable Control Register 1                        */
X    volatile uint32_t APBCLK1;        
N    __IO uint32_t CLKSEL3;       /* Offset: 0x34  Clock Source Select Control Register 3                             */
X    volatile uint32_t CLKSEL3;        
N    __IO uint32_t CLKDIV1;       /* Offset: 0x38  Clock Divider Number Register 1                                    */
X    volatile uint32_t CLKDIV1;        
N
N} CLK_T;
N
N
N/**
N    @addtogroup CLK_CONST CLK Bit Field Definition
N    Constant Definitions for CLK Controller
N@{ */
N
N
N/* CLK PWRCON Bit Field Definitions */
N#define CLK_PWRCON_PD_WAIT_CPU_Pos           8                                    /*!< CLK_T::PWRCON: PD_WAIT_CPU Position */
N#define CLK_PWRCON_PD_WAIT_CPU_Msk           (1ul << CLK_PWRCON_PD_WAIT_CPU_Pos)  /*!< CLK_T::PWRCON: PD_WAIT_CPU Mask */
N
N#define CLK_PWRCON_PWR_DOWN_EN_Pos           7                                    /*!< CLK_T::PWRCON: PWR_DOWN_EN Position */
N#define CLK_PWRCON_PWR_DOWN_EN_Msk           (1ul << CLK_PWRCON_PWR_DOWN_EN_Pos)  /*!< CLK_T::PWRCON: PWR_DOWN_EN Mask */
N
N#define CLK_PWRCON_PD_WU_STS_Pos             6                                    /*!< CLK_T::PWRCON: PD_WU_STS Position */
N#define CLK_PWRCON_PD_WU_STS_Msk             (1ul << CLK_PWRCON_PD_WU_STS_Pos)    /*!< CLK_T::PWRCON: PD_WU_STS Mask */
N
N#define CLK_PWRCON_PD_WU_INT_EN_Pos          5                                    /*!< CLK_T::PWRCON: PD_WU_INT_EN Position */
N#define CLK_PWRCON_PD_WU_INT_EN_Msk          (1ul << CLK_PWRCON_PD_WU_INT_EN_Pos) /*!< CLK_T::PWRCON: PD_WU_INT_EN Mask */
N
N#define CLK_PWRCON_PD_WU_DLY_Pos             4                                    /*!< CLK_T::PWRCON: PD_WU_DLY Position */
N#define CLK_PWRCON_PD_WU_DLY_Msk             (1ul << CLK_PWRCON_PD_WU_DLY_Pos)    /*!< CLK_T::PWRCON: PD_WU_DLY Mask */
N
N#define CLK_PWRCON_OSC10K_EN_Pos             3                                    /*!< CLK_T::PWRCON: OSC10K_EN Position */
N#define CLK_PWRCON_OSC10K_EN_Msk             (1ul << CLK_PWRCON_OSC10K_EN_Pos)    /*!< CLK_T::PWRCON: OSC10K_EN Mask */
N#define CLK_PWRCON_IRC10K_EN_Pos             3                                    /*!< CLK_T::PWRCON: IRC10K_EN Position */
N#define CLK_PWRCON_IRC10K_EN_Msk             (1ul << CLK_PWRCON_IRC10K_EN_Pos)    /*!< CLK_T::PWRCON: IRC10K_EN Mask */
N
N#define CLK_PWRCON_OSC22M_EN_Pos             2                                    /*!< CLK_T::PWRCON: OSC22M_EN Position */
N#define CLK_PWRCON_OSC22M_EN_Msk             (1ul << CLK_PWRCON_OSC22M_EN_Pos)    /*!< CLK_T::PWRCON: OSC22M_EN Mask */
N#define CLK_PWRCON_IRC22M_EN_Pos             2                                    /*!< CLK_T::PWRCON: IRC22M_EN Position */
N#define CLK_PWRCON_IRC22M_EN_Msk             (1ul << CLK_PWRCON_IRC22M_EN_Pos)    /*!< CLK_T::PWRCON: IRC22M_EN Mask */
N
N#define CLK_PWRCON_XTL32K_EN_Pos             1                                    /*!< CLK_T::PWRCON: XTL32K_EN Position */
N#define CLK_PWRCON_XTL32K_EN_Msk             (1ul << CLK_PWRCON_XTL32K_EN_Pos)    /*!< CLK_T::PWRCON: XTL32K_EN Mask */
N
N#define CLK_PWRCON_XTL12M_EN_Pos             0                                    /*!< CLK_T::PWRCON: XTL12M_EN Position */
N#define CLK_PWRCON_XTL12M_EN_Msk             (1ul << CLK_PWRCON_XTL12M_EN_Pos)    /*!< CLK_T::PWRCON: XTL12M_EN Mask */
N
N/* CLK AHBCLK Bit Field Definitions */
N#define CLK_AHBCLK_EBI_EN_Pos                3                                    /*!< CLK_T::AHBCLK: EBI_EN Position */
N#define CLK_AHBCLK_EBI_EN_Msk                (1ul << CLK_AHBCLK_EBI_EN_Pos)       /*!< CLK_T::AHBCLK: EBI_EN Mask */
N
N#define CLK_AHBCLK_ISP_EN_Pos                2                                    /*!< CLK_T::AHBCLK: ISP_EN Position */
N#define CLK_AHBCLK_ISP_EN_Msk                (1ul << CLK_AHBCLK_ISP_EN_Pos)       /*!< CLK_T::AHBCLK: ISP_EN Mask */
N
N#define CLK_AHBCLK_PDMA_EN_Pos               1                                    /*!< CLK_T::AHBCLK: PDMA_EN Position */
N#define CLK_AHBCLK_PDMA_EN_Msk               (1ul << CLK_AHBCLK_PDMA_EN_Pos)      /*!< CLK_T::AHBCLK: PDMA_EN Mask */
N
N/* CLK APBCLK Bit Field Definitions */
N#define CLK_APBCLK_PS2_EN_Pos                31                                   /*!< CLK_T::APBCLK: PS2_EN Position */
N#define CLK_APBCLK_PS2_EN_Msk                (1ul << CLK_APBCLK_PS2_EN_Pos)       /*!< CLK_T::APBCLK: PS2_EN Mask */
N
N#define CLK_APBCLK_ACMP_EN_Pos               30                                   /*!< CLK_T::APBCLK: ACMP_EN Position */
N#define CLK_APBCLK_ACMP_EN_Msk               (1ul << CLK_APBCLK_ACMP_EN_Pos)      /*!< CLK_T::APBCLK: ACMP_EN Mask */
N
N#define CLK_APBCLK_I2S_EN_Pos                29                                   /*!< CLK_T::APBCLK: I2S_EN Position */
N#define CLK_APBCLK_I2S_EN_Msk                (1ul << CLK_APBCLK_I2S_EN_Pos)       /*!< CLK_T::APBCLK: I2S_EN Mask */
N
N#define CLK_APBCLK_ADC_EN_Pos                28                                   /*!< CLK_T::APBCLK: ADC_EN Position */
N#define CLK_APBCLK_ADC_EN_Msk                (1ul << CLK_APBCLK_ADC_EN_Pos)       /*!< CLK_T::APBCLK: ADC_EN Mask */
N
N#define CLK_APBCLK_USBD_EN_Pos               27                                   /*!< CLK_T::APBCLK: USBD_EN Position */
N#define CLK_APBCLK_USBD_EN_Msk               (1ul << CLK_APBCLK_USBD_EN_Pos)      /*!< CLK_T::APBCLK: USBD_EN Mask */
N
N#define CLK_APBCLK_CAN1_EN_Pos               25                                   /*!< CLK_T::APBCLK: CAN1_EN Position */
N#define CLK_APBCLK_CAN1_EN_Msk               (1ul << CLK_APBCLK_CAN1_EN_Pos)      /*!< CLK_T::APBCLK: CAN1_EN Mask */
N
N#define CLK_APBCLK_CAN0_EN_Pos               24                                   /*!< CLK_T::APBCLK: CAN0_EN Position */
N#define CLK_APBCLK_CAN0_EN_Msk               (1ul << CLK_APBCLK_CAN0_EN_Pos)      /*!< CLK_T::APBCLK: CAN0_EN Mask */
N
N#define CLK_APBCLK_PWM67_EN_Pos              23                                   /*!< CLK_T::APBCLK: PWM67_EN Position */
N#define CLK_APBCLK_PWM67_EN_Msk              (1ul << CLK_APBCLK_PWM67_EN_Pos)     /*!< CLK_T::APBCLK: PWM67_EN Mask */
N
N#define CLK_APBCLK_PWM45_EN_Pos              22                                   /*!< CLK_T::APBCLK: PWM45_EN Position */
N#define CLK_APBCLK_PWM45_EN_Msk              (1ul << CLK_APBCLK_PWM45_EN_Pos)     /*!< CLK_T::APBCLK: PWM45_EN Mask */
N
N#define CLK_APBCLK_PWM23_EN_Pos              21                                   /*!< CLK_T::APBCLK: PWM23_EN Position */
N#define CLK_APBCLK_PWM23_EN_Msk              (1ul << CLK_APBCLK_PWM23_EN_Pos)     /*!< CLK_T::APBCLK: PWM23_EN Mask */
N
N#define CLK_APBCLK_PWM01_EN_Pos              20                                   /*!< CLK_T::APBCLK: PWM01_EN Position */
N#define CLK_APBCLK_PWM01_EN_Msk              (1ul << CLK_APBCLK_PWM01_EN_Pos)     /*!< CLK_T::APBCLK: PWM01_EN Mask */
N
N#define CLK_APBCLK_UART2_EN_Pos              18                                   /*!< CLK_T::APBCLK: UART2_EN Position */
N#define CLK_APBCLK_UART2_EN_Msk              (1ul << CLK_APBCLK_UART2_EN_Pos)     /*!< CLK_T::APBCLK: UART2_EN Mask */
N
N#define CLK_APBCLK_UART1_EN_Pos              17                                   /*!< CLK_T::APBCLK: UART1_EN Position */
N#define CLK_APBCLK_UART1_EN_Msk              (1ul << CLK_APBCLK_UART1_EN_Pos)     /*!< CLK_T::APBCLK: UART1_EN Mask */
N
N#define CLK_APBCLK_UART0_EN_Pos              16                                   /*!< CLK_T::APBCLK: UART0_EN Position */
N#define CLK_APBCLK_UART0_EN_Msk              (1ul << CLK_APBCLK_UART0_EN_Pos)     /*!< CLK_T::APBCLK: UART0_EN Mask */
N
N#define CLK_APBCLK_SPI3_EN_Pos               15                                   /*!< CLK_T::APBCLK: SPI3_EN Position */
N#define CLK_APBCLK_SPI3_EN_Msk               (1ul << CLK_APBCLK_SPI3_EN_Pos)      /*!< CLK_T::APBCLK: SPI3_EN Mask */
N
N#define CLK_APBCLK_SPI2_EN_Pos               14                                   /*!< CLK_T::APBCLK: SPI2_EN Position */
N#define CLK_APBCLK_SPI2_EN_Msk               (1ul << CLK_APBCLK_SPI2_EN_Pos)      /*!< CLK_T::APBCLK: SPI2_EN Mask */
N
N#define CLK_APBCLK_SPI1_EN_Pos               13                                   /*!< CLK_T::APBCLK: SPI1_EN Position */
N#define CLK_APBCLK_SPI1_EN_Msk               (1ul << CLK_APBCLK_SPI1_EN_Pos)      /*!< CLK_T::APBCLK: SPI1_EN Mask */
N
N#define CLK_APBCLK_SPI0_EN_Pos               12                                   /*!< CLK_T::APBCLK: SPI0_EN Position */
N#define CLK_APBCLK_SPI0_EN_Msk               (1ul << CLK_APBCLK_SPI0_EN_Pos)      /*!< CLK_T::APBCLK: SPI0_EN Mask */
N
N#define CLK_APBCLK_I2C1_EN_Pos               9                                    /*!< CLK_T::APBCLK: I2C1_EN Position */
N#define CLK_APBCLK_I2C1_EN_Msk               (1ul << CLK_APBCLK_I2C1_EN_Pos)      /*!< CLK_T::APBCLK: I2C1_EN Mask */
N
N#define CLK_APBCLK_I2C0_EN_Pos               8                                    /*!< CLK_T::APBCLK: I2C0_EN_ Position */
N#define CLK_APBCLK_I2C0_EN_Msk               (1ul << CLK_APBCLK_I2C0_EN_Pos)      /*!< CLK_T::APBCLK: I2C0_EN_ Mask */
N
N#define CLK_APBCLK_FDIV_EN_Pos               6                                    /*!< CLK_T::APBCLK: FDIV_EN Position */
N#define CLK_APBCLK_FDIV_EN_Msk               (1ul << CLK_APBCLK_FDIV_EN_Pos)      /*!< CLK_T::APBCLK: FDIV_EN Mask */
N
N#define CLK_APBCLK_TMR3_EN_Pos               5                                    /*!< CLK_T::APBCLK: TMR3_EN Position */
N#define CLK_APBCLK_TMR3_EN_Msk               (1ul << CLK_APBCLK_TMR3_EN_Pos)      /*!< CLK_T::APBCLK: TMR3_EN Mask */
N
N#define CLK_APBCLK_TMR2_EN_Pos               4                                    /*!< CLK_T::APBCLK: TMR2_EN Position */
N#define CLK_APBCLK_TMR2_EN_Msk               (1ul << CLK_APBCLK_TMR2_EN_Pos)      /*!< CLK_T::APBCLK: TMR2_EN Mask */
N
N#define CLK_APBCLK_TMR1_EN_Pos               3                                    /*!< CLK_T::APBCLK: TMR1_EN Position */
N#define CLK_APBCLK_TMR1_EN_Msk               (1ul << CLK_APBCLK_TMR1_EN_Pos)      /*!< CLK_T::APBCLK: TMR1_EN Mask */
N
N#define CLK_APBCLK_TMR0_EN_Pos               2                                    /*!< CLK_T::APBCLK: TMR0_EN Position */
N#define CLK_APBCLK_TMR0_EN_Msk               (1ul << CLK_APBCLK_TMR0_EN_Pos)      /*!< CLK_T::APBCLK: TMR0_EN Mask */
N
N#define CLK_APBCLK_RTC_EN_Pos                1                                    /*!< CLK_T::APBCLK: RTC_EN Position */
N#define CLK_APBCLK_RTC_EN_Msk                (1ul << CLK_APBCLK_RTC_EN_Pos)       /*!< CLK_T::APBCLK: RTC_EN Mask */
N
N#define CLK_APBCLK_WDT_EN_Pos                0                                    /*!< CLK_T::APBCLK: WDT_EN Position */
N#define CLK_APBCLK_WDT_EN_Msk                (1ul << CLK_APBCLK_WDT_EN_Pos)       /*!< CLK_T::APBCLK: WDT_EN Mask */
N
N/* CLK APBCLK1 Bit Field Definitions */
N#define CLK_APBCLK1_SC2_EN_Pos                2                                   /*!< CLK_T::APBCLK1: SC2_EN Position */
N#define CLK_APBCLK1_SC2_EN_Msk                (1ul << CLK_APBCLK1_SC2_EN_Pos)     /*!< CLK_T::APBCLK1: SC2_EN Mask */
N
N#define CLK_APBCLK1_SC1_EN_Pos                1                                   /*!< CLK_T::APBCLK1: SC1_EN Position */
N#define CLK_APBCLK1_SC1_EN_Msk                (1ul << CLK_APBCLK1_SC1_EN_Pos)     /*!< CLK_T::APBCLK1: SC1_EN Mask */
N
N#define CLK_APBCLK1_SC0_EN_Pos                0                                   /*!< CLK_T::APBCLK1: SC0_EN Position */
N#define CLK_APBCLK1_SC0_EN_Msk                (1ul << CLK_APBCLK1_SC0_EN_Pos)     /*!< CLK_T::APBCLK1: SC0_EN Mask */
N
N/* CLK CLKSTATUS Bit Field Definitions */
N#define CLK_CLKSTATUS_CLK_SW_FAIL_Pos        7                                        /*!< CLK_T::CLKSTATUS: CLK_SW_FAIL Position */
N#define CLK_CLKSTATUS_CLK_SW_FAIL_Msk        (1ul << CLK_CLKSTATUS_CLK_SW_FAIL_Pos)   /*!< CLK_T::CLKSTATUS: CLK_SW_FAIL Mask */
N
N#define CLK_CLKSTATUS_OSC22M_STB_Pos         4                                        /*!< CLK_T::CLKSTATUS: OSC22M_STB Position */
N#define CLK_CLKSTATUS_OSC22M_STB_Msk         (1ul << CLK_CLKSTATUS_OSC22M_STB_Pos)    /*!< CLK_T::CLKSTATUS: OSC22M_STB Mask */
N#define CLK_CLKSTATUS_IRC22M_STB_Pos         4                                        /*!< CLK_T::CLKSTATUS: IRC22M_STB Position */
N#define CLK_CLKSTATUS_IRC22M_STB_Msk         (1ul << CLK_CLKSTATUS_IRC22M_STB_Pos)    /*!< CLK_T::CLKSTATUS: IRC22M_STB Mask */
N
N#define CLK_CLKSTATUS_OSC10K_STB_Pos         3                                        /*!< CLK_T::CLKSTATUS: OSC10K_STB Position */
N#define CLK_CLKSTATUS_OSC10K_STB_Msk         (1ul << CLK_CLKSTATUS_OSC10K_STB_Pos)    /*!< CLK_T::CLKSTATUS: OSC10K_STB Mask */
N#define CLK_CLKSTATUS_IRC10K_STB_Pos         3                                        /*!< CLK_T::CLKSTATUS: IRC10K_STB Position */
N#define CLK_CLKSTATUS_IRC10K_STB_Msk         (1ul << CLK_CLKSTATUS_IRC10K_STB_Pos)    /*!< CLK_T::CLKSTATUS: IRC10K_STB Mask */
N
N#define CLK_CLKSTATUS_PLL_STB_Pos            2                                        /*!< CLK_T::CLKSTATUS: PLL_STB Position */
N#define CLK_CLKSTATUS_PLL_STB_Msk            (1ul << CLK_CLKSTATUS_PLL_STB_Pos)       /*!< CLK_T::CLKSTATUS: PLL_STB Mask */
N
N#define CLK_CLKSTATUS_XTL32K_STB_Pos         1                                        /*!< CLK_T::CLKSTATUS: XTL32K_STB Position */
N#define CLK_CLKSTATUS_XTL32K_STB_Msk         (1ul << CLK_CLKSTATUS_XTL32K_STB_Pos)    /*!< CLK_T::CLKSTATUS: XTL32K_STB Mask */
N
N#define CLK_CLKSTATUS_XTL12M_STB_Pos         0                                        /*!< CLK_T::CLKSTATUS: XTL12M_STB Position */
N#define CLK_CLKSTATUS_XTL12M_STB_Msk         (1ul << CLK_CLKSTATUS_XTL12M_STB_Pos)    /*!< CLK_T::CLKSTATUS: XTL12M_STB Mask */
N
N/* CLK CLKSEL0 Bit Field Definitions */
N#define CLK_CLKSEL0_STCLK_S_Pos              3                                        /*!< CLK_T::CLKSEL0: STCLK_S Position */
N#define CLK_CLKSEL0_STCLK_S_Msk              (7ul << CLK_CLKSEL0_STCLK_S_Pos)         /*!< CLK_T::CLKSEL0: STCLK_S Mask */
N
N#define CLK_CLKSEL0_HCLK_S_Pos               0                                        /*!< CLK_T::CLKSEL0: HCLK_S Position */
N#define CLK_CLKSEL0_HCLK_S_Msk               (7ul << CLK_CLKSEL0_HCLK_S_Pos)          /*!< CLK_T::CLKSEL0: HCLK_S Mask */
N
N/* CLK CLKSEL1 Bit Field Definitions */
N#define CLK_CLKSEL1_PWM23_S_Pos              30                                       /*!< CLK_T::CLKSEL1: PWM23_S Position */
N#define CLK_CLKSEL1_PWM23_S_Msk              (3ul << CLK_CLKSEL1_PWM23_S_Pos)         /*!< CLK_T::CLKSEL1: PWM23_S Mask */
N
N#define CLK_CLKSEL1_PWM01_S_Pos              28                                       /*!< CLK_T::CLKSEL1: PWM01_S Position */
N#define CLK_CLKSEL1_PWM01_S_Msk              (3ul << CLK_CLKSEL1_PWM01_S_Pos)         /*!< CLK_T::CLKSEL1: PWM01_S Mask */
N
N#define CLK_CLKSEL1_UART_S_Pos               24                                       /*!< CLK_T::CLKSEL1: UART_S Position */
N#define CLK_CLKSEL1_UART_S_Msk               (3ul << CLK_CLKSEL1_UART_S_Pos)          /*!< CLK_T::CLKSEL1: UART_S Mask */
N
N#define CLK_CLKSEL1_TMR3_S_Pos               20                                       /*!< CLK_T::CLKSEL1: TMR3_S Position */
N#define CLK_CLKSEL1_TMR3_S_Msk               (7ul << CLK_CLKSEL1_TMR3_S_Pos)          /*!< CLK_T::CLKSEL1: TMR3_S Mask */
N
N#define CLK_CLKSEL1_TMR2_S_Pos               16                                       /*!< CLK_T::CLKSEL1: TMR2_S Position */
N#define CLK_CLKSEL1_TMR2_S_Msk               (7ul << CLK_CLKSEL1_TMR2_S_Pos)          /*!< CLK_T::CLKSEL1: TMR2_S Mask */
N
N#define CLK_CLKSEL1_TMR1_S_Pos               12                                       /*!< CLK_T::CLKSEL1: TMR1_S Position */
N#define CLK_CLKSEL1_TMR1_S_Msk               (7ul << CLK_CLKSEL1_TMR1_S_Pos)          /*!< CLK_T::CLKSEL1: TMR1_S Mask */
N
N#define CLK_CLKSEL1_TMR0_S_Pos               8                                        /*!< CLK_T::CLKSEL1: TMR0_S Position */
N#define CLK_CLKSEL1_TMR0_S_Msk               (7ul << CLK_CLKSEL1_TMR0_S_Pos)          /*!< CLK_T::CLKSEL1: TMR0_S Mask */
N
N#define CLK_CLKSEL1_SPI3_S_Pos               7                                        /*!< CLK_T::CLKSEL1: SPI3_S Position */
N#define CLK_CLKSEL1_SPI3_S_Msk               (1ul << CLK_CLKSEL1_SPI3_S_Pos)          /*!< CLK_T::CLKSEL1: SPI3_S Mask */
N
N#define CLK_CLKSEL1_SPI2_S_Pos               6                                        /*!< CLK_T::CLKSEL1: SPI2_S Position */
N#define CLK_CLKSEL1_SPI2_S_Msk               (1ul << CLK_CLKSEL1_SPI2_S_Pos)          /*!< CLK_T::CLKSEL1: SPI2_S Mask */
N
N#define CLK_CLKSEL1_SPI1_S_Pos               5                                        /*!< CLK_T::CLKSEL1: SPI1_S Position */
N#define CLK_CLKSEL1_SPI1_S_Msk               (1ul << CLK_CLKSEL1_SPI1_S_Pos)          /*!< CLK_T::CLKSEL1: SPI1_S Mask */
N
N#define CLK_CLKSEL1_SPI0_S_Pos               4                                        /*!< CLK_T::CLKSEL1: SPI0_S Position */
N#define CLK_CLKSEL1_SPI0_S_Msk               (1ul << CLK_CLKSEL1_SPI0_S_Pos)          /*!< CLK_T::CLKSEL1: SPI0_S Mask */
N
N#define CLK_CLKSEL1_ADC_S_Pos                2                                        /*!< CLK_T::CLKSEL1: ADC_S Position */
N#define CLK_CLKSEL1_ADC_S_Msk                (3ul << CLK_CLKSEL1_ADC_S_Pos)           /*!< CLK_T::CLKSEL1: ADC_S Mask */
N
N#define CLK_CLKSEL1_WDT_S_Pos                0                                        /*!< CLK_T::CLKSEL1: WDT_S Position */
N#define CLK_CLKSEL1_WDT_S_Msk                (3ul << CLK_CLKSEL1_WDT_S_Pos)           /*!< CLK_T::CLKSEL1: WDT_S Mask */
N
N/* CLK CLKSEL2 Bit Field Definitions */
N#define CLK_CLKSEL2_RTC_SEL_10K_Pos          18                                       /*!< CLK_T::CLKSEL2: RTC_SEL_10K Position */
N#define CLK_CLKSEL2_RTC_SEL_10K_Msk          (1ul << CLK_CLKSEL2_RTC_SEL_10K_Pos)     /*!< CLK_T::CLKSEL2: RTC_SEL_10K Mask */
N
N#define CLK_CLKSEL2_WWDT_S_Pos               16                                       /*!< CLK_T::CLKSEL2: WWDT_S Position */
N#define CLK_CLKSEL2_WWDT_S_Msk               (3ul << CLK_CLKSEL2_WWDT_S_Pos)          /*!< CLK_T::CLKSEL2: WWDT_S Mask */
N
N#define CLK_CLKSEL2_PWM67_S_E_Pos            11                                       /*!< CLK_T::CLKSEL2: PWM67_S_E Position */
N#define CLK_CLKSEL2_PWM67_S_E_Msk            (1ul << CLK_CLKSEL2_PWM67_S_E_Pos)       /*!< CLK_T::CLKSEL2: PWM67_S_E Mask */
N#define CLK_CLKSEL2_PWM67_S_EXT_Pos          11                                       /*!< CLK_T::CLKSEL2: PWM67_S_E Position */
N#define CLK_CLKSEL2_PWM67_S_EXT_Msk          (1ul << CLK_CLKSEL2_PWM67_S_EXT_Pos)     /*!< CLK_T::CLKSEL2: PWM67_S_E Mask */
N
N#define CLK_CLKSEL2_PWM45_S_E_Pos            10                                       /*!< CLK_T::CLKSEL2: PWM45_S_E Position */
N#define CLK_CLKSEL2_PWM45_S_E_Msk            (1ul << CLK_CLKSEL2_PWM45_S_E_Pos)       /*!< CLK_T::CLKSEL2: PWM45_S_E Mask */
N#define CLK_CLKSEL2_PWM45_S_EXT_Pos          10                                       /*!< CLK_T::CLKSEL2: PWM45_S_EXT Position */
N#define CLK_CLKSEL2_PWM45_S_EXT_Msk          (1ul << CLK_CLKSEL2_PWM45_S_EXT_Pos)     /*!< CLK_T::CLKSEL2: PWM45_S_EXT Mask */
N
N#define CLK_CLKSEL2_PWM23_S_E_Pos            9                                        /*!< CLK_T::CLKSEL2: PWM23_S_E Position */
N#define CLK_CLKSEL2_PWM23_S_E_Msk            (1ul << CLK_CLKSEL2_PWM23_S_E_Pos)       /*!< CLK_T::CLKSEL2: PWM23_S_E Mask */
N#define CLK_CLKSEL2_PWM23_S_EXT_Pos          9                                        /*!< CLK_T::CLKSEL2: PWM23_S_EXT Position */
N#define CLK_CLKSEL2_PWM23_S_EXT_Msk          (1ul << CLK_CLKSEL2_PWM23_S_EXT_Pos)     /*!< CLK_T::CLKSEL2: PWM23_S_EXT Mask */
N
N#define CLK_CLKSEL2_PWM01_S_E_Pos            8                                        /*!< CLK_T::CLKSEL2: PWM01_S_E Position */
N#define CLK_CLKSEL2_PWM01_S_E_Msk            (1ul << CLK_CLKSEL2_PWM01_S_E_Pos)       /*!< CLK_T::CLKSEL2: PWM01_S_E Mask */
N#define CLK_CLKSEL2_PWM01_S_EXT_Pos          8                                        /*!< CLK_T::CLKSEL2: PWM01_S_EXT Position */
N#define CLK_CLKSEL2_PWM01_S_EXT_Msk          (1ul << CLK_CLKSEL2_PWM01_S_EXT_Pos)     /*!< CLK_T::CLKSEL2: PWM01_S_EXT Mask */
N
N#define CLK_CLKSEL2_PWM67_S_Pos              6                                        /*!< CLK_T::CLKSEL2: PWM67_S_ Position */
N#define CLK_CLKSEL2_PWM67_S_Msk              (3ul << CLK_CLKSEL2_PWM67_S_Pos)         /*!< CLK_T::CLKSEL2: PWM67_S_ Mask */
N
N#define CLK_CLKSEL2_PWM45_S_Pos              4                                        /*!< CLK_T::CLKSEL2: PWM45_S Position */
N#define CLK_CLKSEL2_PWM45_S_Msk              (3ul << CLK_CLKSEL2_PWM45_S_Pos)         /*!< CLK_T::CLKSEL2: PWM45_S Mask */
N
N#define CLK_CLKSEL2_FRQDIV_S_Pos             2                                        /*!< CLK_T::CLKSEL2: FRQDIV_S Position */
N#define CLK_CLKSEL2_FRQDIV_S_Msk             (3ul << CLK_CLKSEL2_FRQDIV_S_Pos)        /*!< CLK_T::CLKSEL2: FRQDIV_S Mask */
N
N#define CLK_CLKSEL2_I2S_S_Pos                0                                        /*!< CLK_T::CLKSEL2: I2S_S Position */
N#define CLK_CLKSEL2_I2S_S_Msk                (3ul << CLK_CLKSEL2_I2S_S_Pos)           /*!< CLK_T::CLKSEL2: I2S_S Mask */
N
N/* CLK CLKSEL3 Bit Field Definitions */
N#define CLK_CLKSEL3_SC2_S_Pos                4                                        /*!< CLK_T::CLKSEL3: SC2_S Position */
N#define CLK_CLKSEL3_SC2_S_Msk                (3ul << CLK_CLKSEL3_SC2_S_Pos)           /*!< CLK_T::CLKSEL3: SC2_S Mask */
N
N#define CLK_CLKSEL3_SC1_S_Pos                2                                        /*!< CLK_T::CLKSEL3: SC1_S Position */
N#define CLK_CLKSEL3_SC1_S_Msk                (3ul << CLK_CLKSEL3_SC1_S_Pos)           /*!< CLK_T::CLKSEL3: SC1_S Mask */
N
N#define CLK_CLKSEL3_SC0_S_Pos                0                                        /*!< CLK_T::CLKSEL3: SC0_S Position */
N#define CLK_CLKSEL3_SC0_S_Msk                (3ul << CLK_CLKSEL3_SC0_S_Pos)           /*!< CLK_T::CLKSEL3: SC0_S Mask */
N
N/* CLK CLKDIV Bit Field Definitions */
N#define CLK_CLKDIV_ADC_N_Pos                 16                                       /*!< CLK_T::CLKDIV: ADC_N Position */
N#define CLK_CLKDIV_ADC_N_Msk                 (0xFFul << CLK_CLKDIV_ADC_N_Pos)         /*!< CLK_T::CLKDIV: ADC_N Mask */
N
N#define CLK_CLKDIV_UART_N_Pos                8                                        /*!< CLK_T::CLKDIV: UART_N Position */
N#define CLK_CLKDIV_UART_N_Msk                (0xFul << CLK_CLKDIV_UART_N_Pos)         /*!< CLK_T::CLKDIV: UART_N Mask */
N
N#define CLK_CLKDIV_USB_N_Pos                 4                                        /*!< CLK_T::CLKDIV: USB_N Position */
N#define CLK_CLKDIV_USB_N_Msk                 (0xFul << CLK_CLKDIV_USB_N_Pos)          /*!< CLK_T::CLKDIV: USB_N Mask */
N
N#define CLK_CLKDIV_HCLK_N_Pos                0                                        /*!< CLK_T::CLKDIV: HCLK_N Position */
N#define CLK_CLKDIV_HCLK_N_Msk                (0xFul << CLK_CLKDIV_HCLK_N_Pos)         /*!< CLK_T::CLKDIV: HCLK_N Mask */
N
N/* CLK CLKDIV1 Bit Field Definitions */
N#define CLK_CLKDIV1_SC2_N_Pos                16                                       /*!< CLK_T::CLKDIV: SC2_N Position */
N#define CLK_CLKDIV1_SC2_N_Msk                (0xFFul << CLK_CLKDIV1_SC2_N_Pos)        /*!< CLK_T::CLKDIV: SC2_N Mask */
N
N#define CLK_CLKDIV1_SC1_N_Pos                8                                        /*!< CLK_T::CLKDIV: SC1_N Position */
N#define CLK_CLKDIV1_SC1_N_Msk                (0xFFul << CLK_CLKDIV1_SC1_N_Pos)        /*!< CLK_T::CLKDIV: SC1_N Mask */
N
N#define CLK_CLKDIV1_SC0_N_Pos                0                                        /*!< CLK_T::CLKDIV: SC0_N Position */
N#define CLK_CLKDIV1_SC0_N_Msk                (0xFFul << CLK_CLKDIV1_SC0_N_Pos)        /*!< CLK_T::CLKDIV: SC0_N Mask */
N
N/* CLK PLLCON Bit Field Definitions */
N#define CLK_PLLCON_PLL_SRC_Pos               19                                       /*!< CLK_T::PLLCON: PLL_SRC Position */
N#define CLK_PLLCON_PLL_SRC_Msk               (1ul << CLK_PLLCON_PLL_SRC_Pos)          /*!< CLK_T::PLLCON: PLL_SRC Mask */
N
N#define CLK_PLLCON_OE_Pos                    18                                       /*!< CLK_T::PLLCON: PLL_SRC Position */
N#define CLK_PLLCON_OE_Msk                    (1ul << CLK_PLLCON_OE_Pos)               /*!< CLK_T::PLLCON: PLL_SRC Mask */
N
N#define CLK_PLLCON_BP_Pos                    17                                       /*!< CLK_T::PLLCON: OE Position */
N#define CLK_PLLCON_BP_Msk                    (1ul << CLK_PLLCON_BP_Pos)               /*!< CLK_T::PLLCON: OE Mask */
N
N#define CLK_PLLCON_PD_Pos                    16                                       /*!< CLK_T::PLLCON: PD Position */
N#define CLK_PLLCON_PD_Msk                    (1ul << CLK_PLLCON_PD_Pos)               /*!< CLK_T::PLLCON: PD Mask */
N
N#define CLK_PLLCON_OUT_DV_Pos                14                                       /*!< CLK_T::PLLCON: OUT_DV Position */
N#define CLK_PLLCON_OUT_DV_Msk                (3ul << CLK_PLLCON_OUT_DV_Pos)           /*!< CLK_T::PLLCON: OUT_DV Mask */
N
N#define CLK_PLLCON_IN_DV_Pos                 9                                        /*!< CLK_T::PLLCON: IN_DV Position */
N#define CLK_PLLCON_IN_DV_Msk                 (0x1Ful << CLK_PLLCON_IN_DV_Pos)         /*!< CLK_T::PLLCON: IN_DV Mask */
N
N#define CLK_PLLCON_FB_DV_Pos                 0                                        /*!< CLK_T::PLLCON: FB_DV Position */
N#define CLK_PLLCON_FB_DV_Msk                 (0x1FFul << CLK_PLLCON_FB_DV_Pos)        /*!< CLK_T::PLLCON: FB_DV Mask */
N
N/* CLK FRQDIV Bit Field Definitions */
N#define CLK_FRQDIV_CLKO_1HZ_EN_Pos           6                                        /*!< CLK_T::FRQDIV: CLKO_1HZ_EN Position */
N#define CLK_FRQDIV_CLKO_1HZ_EN_Msk           (1ul << CLK_FRQDIV_CLKO_1HZ_EN_Pos)      /*!< CLK_T::FRQDIV: CLKO_1HZ_EN Mask */
N
N#define CLK_FRQDIV_DIVIDER1_Pos              5                                        /*!< CLK_T::FRQDIV: DIVIDER1 Position */
N#define CLK_FRQDIV_DIVIDER1_Msk              (1ul << CLK_FRQDIV_DIVIDER1_Pos)         /*!< CLK_T::FRQDIV: DIVIDER1 Mask */
N
N#define CLK_FRQDIV_DIVIDER_EN_Pos            4                                        /*!< CLK_T::FRQDIV: DIVIDER_EN Position */
N#define CLK_FRQDIV_DIVIDER_EN_Msk            (1ul << CLK_FRQDIV_DIVIDER_EN_Pos)       /*!< CLK_T::FRQDIV: DIVIDER_EN Mask */
N
N#define CLK_FRQDIV_FSEL_Pos                  0                                        /*!< CLK_T::FRQDIV: FRQDIV_FSEL Position */
N#define CLK_FRQDIV_FSEL_Msk                  (0xFul << CLK_FRQDIV_FSEL_Pos)           /*!< CLK_T::FRQDIV: FRQDIV_FSEL Mask */
N/*@}*/ /* end of group CLK_CONST */
N/*@}*/ /* end of group CLK */
N
N
N
N/*----------------------------- Cyclic Redundancy Check (CRC) Controller -----------------------------*/
N/** @addtogroup CRC Cyclic Redundancy Check Controller (CRC)
N  Memory Mapped Structure for Cyclic Redundancy Check
N  @{
N */
N
N
Ntypedef struct
N{
N
N
N/**
N * @var CRC_T::CTL
N * Offset: 0x00  CRC Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |CRCCEN    |CRC Channel Enable
N * |        |          |0 = No effect.
N * |        |          |1 = CRC operation Enabled.
N * |        |          |Note1: When operating in CRC DMA mode (TRIG_EN (CRC_CTL[23]) = 1), if user clears this bit, the
N * |        |          |DMA operation will be continuous until all CRC DMA operation is done, and the TRIG_EN
N * |        |          |(CRC_CTL[23]) bit will keep 1until all CRC DMA operation done.
N * |        |          |But in this case, the CRC_BLKD_IF (CRC_DMAISR[1])flag will inactive, user can read CRC checksum
N * |        |          |result only if TRIG_EN (CRC_CTL[23]) clears to 0.
N * |        |          |Note2: When operating in CRC DMA mode (TRIG_EN (CRC_CTL[23]) = 1), if user wants to stop the
N * |        |          |transfer immediately, user can write 1 to CRC_RST (CRC_CTL [1]) bit to stop the transmission.
N * |[1]     |CRC_RST   |CRC Engine Reset
N * |        |          |0 = No effect.
N * |        |          |1 = Reset the internal CRC state machine and internal buffer.
N * |        |          |The others contents of CRC_CTL register will not be cleared.
N * |        |          |This bit will be cleared automatically.
N * |        |          |Note: When operated in CPU PIO mode, setting this bit will reload the initial seed value
N * |        |          |(CRC_SEED register).
N * |[23]    |TRIG_EN   |Trigger Enable
N * |        |          |This bit is used to trigger the CRC DMA transfer.
N * |        |          |0 = No effect.
N * |        |          |1 = CRC DMA data read or write transfer Enabled.
N * |        |          |Note1: If this bit asserts which indicates the CRC engine operation in CRC DMA mode, do not fill
N * |        |          |in any data in CRC_WDATA register.
N * |        |          |Note2: When CRC DMA transfer completed, this bit will be cleared automatically.
N * |        |          |Note3: If the bus error occurs when CRC DMA transfer data, all CRC DMA transfer will be stopped.
N * |        |          |Software must reset all DMA channel before trigger DMA again.
N * |[24]    |WDATA_RVS |Write Data Order Reverse
N * |        |          |This bit is used to enable the bit order reverse function for write data value in CRC_WDATA
N * |        |          |register.
N * |        |          |0 = Bit order reverse for CRC write data in Disabled.
N * |        |          |1 = Bit order reverse for CRC write data in Enabled (per byre).
N * |        |          |Note: If the write data is 0xAABBCCDD, the bit order reverse for CRC write data in is 0x55DD33BB
N * |[25]    |CHECKSUM_RVS|Checksum Reverse
N * |        |          |This bit is used to enable the bit order reverse function for write data value in CRC_CHECKSUM
N * |        |          |register.
N * |        |          |0 = Bit order reverse for CRC checksum Disabled.
N * |        |          |1 = Bit order reverse for CRC checksum Enabled.
N * |        |          |Note: If the checksum result is 0XDD7B0F2E, the bit order reverse for CRC checksum is 0x74F0DEBB
N * |[26]    |WDATA_COM |Write Data 1's Complement
N * |        |          |This bit is used to enable the 1's complement function for write data value in CRC_WDATA
N * |        |          |register.
N * |        |          |0 = 1's complement for CRC write data in Disabled.
N * |        |          |1 = 1's complement for CRC write data in Enabled.
N * |[27]    |CHECKSUM_COM|Checksum 1's Complement
N * |        |          |This bit is used to enable the 1's complement function for checksum result in CRC_CHECKSUM
N * |        |          |register.
N * |        |          |0 = 1's complement for CRC checksum Disabled.
N * |        |          |1 = 1's complement for CRC checksum Enabled.
N * |[29:28] |CPU_WDLEN |CPU Write Data Length
N * |        |          |This field indicates the CPU write data length only when operating in CPU PIO mode.
N * |        |          |00 = The write data length is 8-bit mode.
N * |        |          |01 = The write data length is 16-bit mode.
N * |        |          |10 = The write data length is 32-bit mode.
N * |        |          |11 = Reserved.
N * |        |          |Note1: This field is only valid when operating in CPU PIO mode.
N * |        |          |Note2: When the write data length is 8-bit mode, the valid data in CRC_WDATA register is only
N * |        |          |CRC_WDATA [7:0] bits; if the write data length is 16-bit mode, the valid data in CRC_WDATA
N * |        |          |register is only CRC_WDATA [15:0].
N * |[31:30] |CRC_MODE  |CRC Polynomial Mode
N * |        |          |This field indicates the CRC operation polynomial mode.
N * |        |          |00 = CRC-CCITT Polynomial Mode.
N * |        |          |01 = CRC-8 Polynomial Mode.
N * |        |          |10 = CRC-16 Polynomial Mode.
N * |        |          |11 = CRC-32 Polynomial Mode.
N * @var CRC_T::DMASAR
N * Offset: 0x04  CRC DMA Source Address Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |CRC_DMASAR|CRC DMA Transfer Source Address Register
N * |        |          |This field indicates a 32-bit source address of CRC DMA.
N * |        |          |(CRC_DMASAR + CRC_DMABCR) = (CRC_DMACSAR + CRC_DMACBCR).
N * |        |          |Note: The source address must be word alignment
N * @var CRC_T::DMABCR
N * Offset: 0x0C  CRC DMA Transfer Byte Count Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CRC_DMABCR|CRC DMA Transfer Byte Count Register
N * |        |          |This field indicates a 16-bit total transfer byte count number of CRC DMA
N * |        |          |(CRC_DMASAR + CRC_DMABCR) = (CRC_DMACSAR + CRC_DMACBCR).
N * @var CRC_T::DMACSAR
N * Offset: 0x14  CRC DMA Current Source Address Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |CRC_DMACSAR|CRC DMA Current Source Address Register (Read Only)
N * |        |          |This field indicates the current source address where the CRC DMA transfer just occurs.
N * |        |          |(CRC_DMASAR + CRC_DMABCR) = (CRC_DMACSAR + CRC_DMACBCR).
N * @var CRC_T::DMACBCR
N * Offset: 0x1C  CRC DMA Current Transfer Byte Count Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CRC_DMACBCR|CRC DMA Current Remained Byte Count Register (Read Only)
N * |        |          |This field indicates the current remained byte count of CRC DMA.
N * |        |          |(CRC_DMASAR + CRC_DMABCR) = (CRC_DMACSAR + CRC_DMACBCR).
N * |        |          |Note: Setting CRC_RST (CRC_CTL[1]) bit to 1 will clear this register value.
N * @var CRC_T::DMAIER
N * Offset: 0x20  CRC DMA Interrupt Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |CRC_TABORT_IE|CRC DMA Read/Write Target Abort Interrupt Enable
N * |        |          |Enable this bit will generate the CRC DMA Target Abort interrupt signal while CRC_TARBOT_IF
N * |        |          |(CRC_DMAISR[0]) bit is set to 1.
N * |        |          |0 = Target abort interrupt generation Disabled during CRC DMA transfer.
N * |        |          |1 = Target abort interrupt generation Enabled during CRC DMA transfer.
N * |[1]     |CRC_BLKD_IE|CRC DMA Block Transfer Done Interrupt Enable
N * |        |          |Enable this bit will generate the CRC DMA Transfer Done interrupt signal while CRC_BLKD_IF
N * |        |          |(CRC_DMAISR[1]) bit is set to 1.
N * |        |          |0 = Interrupt generator Disabled when CRC DMA transfer done.
N * |        |          |1 = Interrupt generator Enabled when CRC DMA transfer done.
N * @var CRC_T::DMAISR
N * Offset: 0x24  CRC DMA Interrupt Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |CRC_TABORT_IF|CRC DMA Read/Write Target Abort Interrupt Flag
N * |        |          |This bit indicates that CRC bus has error or not during CRC DMA transfer.
N * |        |          |0 = No bus error response received during CRC DMA transfer.
N * |        |          |1 = Bus error response received during CRC DMA transfer.
N * |        |          |It is cleared by writing 1 to it through software.
N * |        |          |Note: The bit filed indicate bus master received error response or not.
N * |        |          |If bus master received error response, it means that CRC transfer target abort is happened.
N * |        |          |DMA will stop transfer and respond this event to software then CRC state machine goes to IDLE
N * |        |          |state.
N * |        |          |When target abort occurred, software must reset DMA before transfer those data again.
N * |[1]     |CRC_BLKD_IF|CRC DMA Block Transfer Done Interrupt Flag
N * |        |          |This bit indicates that CRC DMA transfer has finished or not.
N * |        |          |0 = Not finished if TRIG_EN (CRC_CTL[23]) bit has enabled.
N * |        |          |1 = CRC transfer done if TRIG_EN (CRC_CTL[23]) bit has enabled.
N * |        |          |It is cleared by writing 1 to it through software.
N * |        |          |(When CRC DMA transfer done, TRIG_EN (CRC_CTL[23]) bit will be cleared automatically)
N * @var CRC_T::WDATA
N * Offset: 0x80  CRC Write Data Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |CRC_WDATA |CRC Write Data Register
N * |        |          |When operating in CPU PIO mode, software can write data to this field to perform CRC operation.
N * |        |          |When operating in DMA mode, this field indicates the DMA read data from memory and cannot be
N * |        |          |written.
N * |        |          |Note: When the write data length is 8-bit mode, the valid data in CRC_WDATA register is only
N * |        |          |CRC_WDATA [7:0] bits; if the write data length is 16-bit mode, the valid data in CRC_WDATA
N * |        |          |register is only CRC_WDATA [15:0].
N * @var CRC_T::SEED
N * Offset: 0x84  CRC Seed Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |CRC_SEED  |CRC Seed Register
N * |        |          |This field indicates the CRC seed value.
N * @var CRC_T::CHECKSUM
N * Offset: 0x88  CRC Checksum Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |CRC_CHECKSUM|CRC Checksum Register
N * |        |          |This fields indicates the CRC checksum result
N */
N
N    __IO uint32_t CTL;           /* Offset: 0x00  CRC Control Register                                               */
X    volatile uint32_t CTL;            
N    __IO uint32_t DMASAR;        /* Offset: 0x04  CRC DMA Source Address Register                                    */
X    volatile uint32_t DMASAR;         
N    __I  uint32_t RESERVED0;    
X    volatile const  uint32_t RESERVED0;    
N    __IO uint32_t DMABCR ;       /* Offset: 0x0C  CRC DMA Transfer Byte Count Register                               */
X    volatile uint32_t DMABCR ;        
N    __I  uint32_t RESERVED1;    
X    volatile const  uint32_t RESERVED1;    
N    __I  uint32_t DMACSAR;       /* Offset: 0x14  CRC DMA Current Source Address Register                            */
X    volatile const  uint32_t DMACSAR;        
N    __I  uint32_t RESERVED2;    
X    volatile const  uint32_t RESERVED2;    
N    __I  uint32_t DMACBCR;       /* Offset: 0x1C  CRC DMA Current Transfer Byte Count Register                       */
X    volatile const  uint32_t DMACBCR;        
N    __IO uint32_t DMAIER ;       /* Offset: 0x20  CRC DMA Interrupt Enable Register                                  */
X    volatile uint32_t DMAIER ;        
N    __IO uint32_t DMAISR;        /* Offset: 0x24  CRC DMA Interrupt Status Register                                  */
X    volatile uint32_t DMAISR;         
N    __I  uint32_t RESERVED3[22];
X    volatile const  uint32_t RESERVED3[22];
N    __IO uint32_t WDATA;         /* Offset: 0x80  CRC Write Data Register                                            */
X    volatile uint32_t WDATA;          
N    __IO uint32_t SEED;          /* Offset: 0x84  CRC Seed Register                                                  */
X    volatile uint32_t SEED;           
N    __I  uint32_t CHECKSUM;      /* Offset: 0x88  CRC Checksum Register                                              */
X    volatile const  uint32_t CHECKSUM;       
N
N} CRC_T;
N
N
N/**
N    @addtogroup CRC_CONST CRC Bit Field Definition
N    Constant Definitions for CRC Controller
N@{ */
N
N
N/* CRC CTL Bit Field Definitions */
N#define CRC_CTL_CRC_MODE_Pos            30                                      /*!< CRC_T::CTL: CRC_MODE Position */
N#define CRC_CTL_CRC_MODE_Msk            (0x3ul << CRC_CTL_CRC_MODE_Pos)         /*!< CRC_T::CTL: CRC_MODE Mask */
N
N#define CRC_CTL_CPU_WDLEN_Pos           28                                      /*!< CRC_T::CTL: CPU_WDLEN Position */
N#define CRC_CTL_CPU_WDLEN_Msk           (0x3ul << CRC_CTL_CPU_WDLEN_Pos)        /*!< CRC_T::CTL: CPU_WDLEN Mask */
N
N#define CRC_CTL_CHECKSUM_COM_Pos        27                                      /*!< CRC_T::CTL: CHECKSUM_COM Position */
N#define CRC_CTL_CHECKSUM_COM_Msk        (1ul << CRC_CTL_CHECKSUM_COM_Pos)       /*!< CRC_T::CTL: CHECKSUM_COM Mask */
N
N#define CRC_CTL_WDATA_COM_Pos           26                                      /*!< CRC_T::CTL: WDATA_COM Position */
N#define CRC_CTL_WDATA_COM_Msk           (1ul << CRC_CTL_WDATA_COM_Pos)          /*!< CRC_T::CTL: WDATA_COM Mask */
N
N#define CRC_CTL_CHECKSUM_RVS_Pos        25                                      /*!< CRC_T::CTL: CHECKSUM_RVS Position */
N#define CRC_CTL_CHECKSUM_RVS_Msk        (1ul << CRC_CTL_CHECKSUM_RVS_Pos)       /*!< CRC_T::CTL: CHECKSUM_RVS Mask */
N
N#define CRC_CTL_WDATA_RVS_Pos           24                                      /*!< CRC_T::CTL: WDATA_RVS Position */
N#define CRC_CTL_WDATA_RVS_Msk           (1ul << CRC_CTL_WDATA_RVS_Pos)          /*!< CRC_T::CTL: WDATA_RVS Mask */
N
N#define CRC_CTL_TRIG_EN_Pos             23                                      /*!< CRC_T::CTL: TRIG_EN Position */
N#define CRC_CTL_TRIG_EN_Msk             (1ul << CRC_CTL_TRIG_EN_Pos)            /*!< CRC_T::CTL: TRIG_EN Mask */
N
N#define CRC_CTL_CRC_RST_Pos             1                                       /*!< CRC_T::CTL: CRC_RST Position */
N#define CRC_CTL_CRC_RST_Msk             (1ul << CRC_CTL_CRC_RST_Pos)            /*!< CRC_T::CTL: CRC_RST Mask */
N
N#define CRC_CTL_CRCCEN_Pos              0                                       /*!< CRC_T::CTL: CRCCEN Position */
N#define CRC_CTL_CRCCEN_Msk              (1ul << CRC_CTL_CRCCEN_Pos)             /*!< CRC_T::CTL: CRCCEN Mask */
N
N/* CRC DMASAR Bit Field Definitions */
N#define CRC_DMASAR_CRC_DMASAR_Pos       0                                               /*!< CRC_T::DMASAR: CRC_DMASAR Position */
N#define CRC_DMASAR_CRC_DMASAR_Msk       (0xFFFFFFFFul << CRC_DMASAR_CRC_DMASAR_Pos)     /*!< CRC_T::DMASAR: CRC_DMASAR Mask */
N
N/* CRC DMABCR Bit Field Definitions */
N#define CRC_DMABCR_CRC_DMABCR_Pos       0                                               /*!< CRC_T::DMABCR: CRC_DMABCR Position */
N#define CRC_DMABCR_CRC_DMABCR_Msk       (0xFFFFul << CRC_DMABCR_CRC_DMABCR_Pos)         /*!< CRC_T::DMABCR: CRC_DMABCR Mask */
N
N/* CRC DMACSAR Bit Field Definitions */
N#define CRC_DMACSAR_CRC_DMACSAR_Pos     0                                               /*!< CRC_T::DMACSAR: CRC_DMACSAR Position */
N#define CRC_DMACSAR_CRC_DMACSAR_Msk     (0xFFFFFFFFul << CRC_DMACSAR_CRC_DMACSAR_Pos)   /*!< CRC_T::DMACSAR: CRC_DMACSAR Mask */
N
N/* CRC DMACBCR Bit Field Definitions */
N#define CRC_DMACBCR_CRC_DMACBCR_Pos     0                                               /*!< CRC_T::DMACBCR: DMACBCR Position */
N#define CRC_DMACBCR_CRC_DMACBCR_Msk     (0xFFFFul << CRC_DMACBCR_CRC_DMACBCR_Pos)       /*!< CRC_T::DMACBCR: DMACBCR Mask */
N
N/* CRC DMAIER Bit Field Definitions */
N#define CRC_DMAIER_CRC_BLKD_IE_Pos      1                                               /*!< CRC_T::DMAIER: CRC_BLKD_IE Position */
N#define CRC_DMAIER_CRC_BLKD_IE_Msk      (1ul << CRC_DMAIER_CRC_BLKD_IE_Pos)             /*!< CRC_T::DMAIER: CRC_BLKD_IE Mask */
N
N#define CRC_DMAIER_CRC_TABORT_IE_Pos    0                                               /*!< CRC_T::DMAIER: CRC_TABORT_IE Position */
N#define CRC_DMAIER_CRC_TABORT_IE_Msk    (1ul << CRC_DMAIER_CRC_TABORT_IE_Pos)           /*!< CRC_T::DMAIER: CRC_TABORT_IE Mask */
N
N/* CRC DMAISR Bit Field Definitions */
N#define CRC_DMAISR_CRC_BLKD_IF_Pos      1                                               /*!< CRC_T::DMAISR: CRC_BLKD_IF Position */
N#define CRC_DMAISR_CRC_BLKD_IF_Msk      (1ul << CRC_DMAISR_CRC_BLKD_IF_Pos)             /*!< CRC_T::DMAISR: CRC_BLKD_IF Mask */
N
N#define CRC_DMAISR_CRC_TABORT_IF_Pos    0                                               /*!< CRC_T::DMAISR: CRC_TABORT_IF Position */
N#define CRC_DMAISR_CRC_TABORT_IF_Msk    (1ul << CRC_DMAISR_CRC_TABORT_IF_Pos)           /*!< CRC_T::DMAISR: CRC_TABORT_IF Mask */
N
N/* CRC WDATA Bit Field Definitions */
N#define CRC_WDATA_CRC_WDATA_Pos         0                                               /*!< CRC_T::WDATA: CRC_WDATA Position */
N#define CRC_WDATA_CRC_WDATA_Msk         (0xFFFFFFFFul << CRC_WDATA_CRC_WDATA_Pos)       /*!< CRC_T::WDATA: CRC_WDATA Mask */
N
N/* CRC SEED Bit Field Definitions */
N#define CRC_SEED_CRC_SEED_Pos           0                                               /*!< CRC_T::SEED: CRC_SEED Position */
N#define CRC_SEED_CRC_SEED_Msk           (0xFFFFFFFFul << CRC_SEED_CRC_SEED_Pos)         /*!< CRC_T::SEED: CRC_SEED Mask */
N
N/* CRC CHECKSUM Bit Field Definitions */
N#define CRC_CHECKSUM_CRC_CHECKSUM_Pos   0                                               /*!< CRC_T::CHECKSUM: CRC_CHECKSUM Position */
N#define CRC_CHECKSUM_CRC_CHECKSUM_Msk   (0xFFFFFFFFul << CRC_CHECKSUM_CRC_CHECKSUM_Pos) /*!< CRC_T::CHECKSUM: CRC_CHECKSUM Mask */
N/*@}*/ /* end of group CRC_CONST */
N/*@}*/ /* end of group CRC */
N
N
N/*---------------------- External Bus Interface Controller -------------------------*/
N/**
N    @addtogroup EBI External Bus Interface Controller (EBI)
N    Memory Mapped Structure for EBI Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N/**
N * @var EBI_T::EBICON
N * Offset: 0x00  EBI Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |ExtEN     |EBI Enable
N * |        |          |This bit is the functional enable bit for EBI.
N * |        |          |0 = EBI function is disabled
N * |        |          |1 = EBI function is enabled
N * |[1]     |ExtBW16   |EBI data width 16 bit
N * |        |          |This bit defines if the data bus is 8-bit or 16-bit.
N * |        |          |0 = EBI data width is 8 bit
N * |        |          |1 = EBI data width is 16 bit
N * |[10:8]  |MCLKDIV   |External Output Clock Divider
N * |        |          |The frequency of EBI output clock is controlled by MCLKDIV.
N * |        |          |000 = HCLK/1
N * |        |          |001 = HCLK/2
N * |        |          |010 = HCLK/4
N * |        |          |011 = HCLK/8
N * |        |          |100 = HCLK/16
N * |        |          |101 = HCKL/32
N * |        |          |11X = default
N * |        |          |Notice: Default value of output clock is HCLK/1
N * |[18:16] |ExttALE   |Expand Time of ALE
N * |        |          |The ALE width (tALE) to latch the address can be controlled by ExttALE.
N * |        |          |tALE = (ExttALE + 1) * MCLK
N * @var EBI_T::EXTIME
N * Offset: 0x04  EBI Timing Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:3]   |ExttACC   |EBI Data Accesss Time
N * |        |          |ExttACC define data access time (tACC).
N * |        |          |tACC = (ExttACC + 1) * MCLK
N * |[10:8]  |ExttAHD   |EBI Data Access Hold Time
N * |        |          |ExttAHD define data access hold time (tAHD).
N * |        |          |tAHD = (ExttAHD + 1) * MCLK
N * |[15:12] |ExtIW2X   |Idle State Cycle After Write
N * |        |          |When write action is finish, idle state is inserted and nCS return to high if ExtIW2X is not
N * |        |          |zero.
N * |        |          |Idle state cycle = (ExtIW2X * MCLK)
N * |[27:24] |ExtIR2R   |Idle State Cycle Between Read-Read
N * |        |          |When read action is finish and next action is going to read, idle state is inserted and nCS
N * |        |          |return
N * |        |          |to high if ExtIR2R is not zero.
N * |        |          |Idle state cycle = (ExtIR2R * MCLK)
N * @var EBI_T::EBICON2
N * Offset: 0x08   External Bus Interface General Control Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |WBUFF_EN  |EBI Write Buffer Enable Control
N * |        |          |0 = EBI write buffer Disabled.
N * |        |          |1 = EBI write buffer Enabled.c
N * |[1]     |RAHD_OFF  |Access Hold Time Disable Control When Read
N * |        |          |0 = tAHD is controlled by ExttAHD[2:0] when read through EBI.
N * |        |          |1 = Zero tAHD when read through EBI.
N * |[2]     |WAHD_OFF  |Access Hold Time Disable Control When Write 
N * |        |          |0 = tAHD is controlled by ExttAHD[2:0] when write through EBI.
N * |        |          |1 = Zero tAHD when write through EBI.
N */
N
N    __IO uint32_t EBICON;        /* Offset: 0x00  EBI Control Register                                               */
X    volatile uint32_t EBICON;         
N    __IO uint32_t EXTIME;        /* Offset: 0x04  EBI Timing Control Register                                        */
X    volatile uint32_t EXTIME;         
N    __IO uint32_t EBICON2;       /* Offset: 0x08   External Bus Interface General Control Register 2                 */
X    volatile uint32_t EBICON2;        
N
N} EBI_T;
N
N
N
N/**
N    @addtogroup EBI_CONST EBI Bit Field Definition
N    Constant Definitions for EBI Controller
N@{ */
N
N/* EBI EBICON Bit Field Definitions */
N#define EBI_EBICON_ExttALE_Pos      16                                          /*!< EBI_T::EBICON: ExttALE Position */
N#define EBI_EBICON_ExttALE_Msk      (0x7ul << EBI_EBICON_ExttALE_Pos)           /*!< EBI_T::EBICON: ExttALE Mask */
N
N#define EBI_EBICON_MCLKDIV_Pos      8                                           /*!< EBI_T::EBICON: MCLKDIV Position */
N#define EBI_EBICON_MCLKDIV_Msk      (0x7ul << EBI_EBICON_MCLKDIV_Pos)           /*!< EBI_T::EBICON: MCLKDIV Mask */
N
N#define EBI_EBICON_ExtBW16_Pos      1                                           /*!< EBI_T::EBICON: ExtBW16 Position */
N#define EBI_EBICON_ExtBW16_Msk      (1ul << EBI_EBICON_ExtBW16_Pos)             /*!< EBI_T::EBICON: ExtBW16 Mask */
N
N#define EBI_EBICON_ExtEN_Pos        0                                           /*!< EBI_T::EBICON: ExtEN Position */
N#define EBI_EBICON_ExtEN_Msk        (1ul << EBI_EBICON_ExtEN_Pos)               /*!< EBI_T::EBICON: ExtEN Mask */
N
N/* EBI EXTIME Bit Field Definitions */
N#define EBI_EXTIME_ExtIR2R_Pos      24                                          /*!< EBI_T::EXTIME: ExtIR2R Position */
N#define EBI_EXTIME_ExtIR2R_Msk      (0xFul << EBI_EXTIME_ExtIR2R_Pos)           /*!< EBI_T::EXTIME: ExtIR2R Mask */
N
N#define EBI_EXTIME_ExtIW2X_Pos      12                                          /*!< EBI_T::EXTIME: ExtIW2X Position */
N#define EBI_EXTIME_ExtIW2X_Msk      (0xFul << EBI_EXTIME_ExtIW2X_Pos)           /*!< EBI_T::EXTIME: ExtIW2X Mask */
N
N#define EBI_EXTIME_ExttAHD_Pos      8                                           /*!< EBI_T::EXTIME: ExttAHD Position */
N#define EBI_EXTIME_ExttAHD_Msk      (0x7ul << EBI_EXTIME_ExttAHD_Pos)           /*!< EBI_T::EXTIME: ExttAHD Mask */
N
N#define EBI_EXTIME_ExttACC_Pos      3                                           /*!< EBI_T::EXTIME: ExttACC Position */
N#define EBI_EXTIME_ExttACC_Msk      (0x1Ful << EBI_EXTIME_ExttACC_Pos)          /*!< EBI_T::EXTIME: ExttACC Mask */
N
N/* EBI EBICON2 Bit Field Definitions */
N#define EBI_EBICON2_WAHD_OFF_Pos    2                                           /*!< EBI_T::EBICON2: WAHD_OFF Position */
N#define EBI_EBICON2_WAHD_OFF_Msk    (1ul << EBI_EBICON2_WAHD_OFF_Pos)           /*!< EBI_T::EBICON2: WAHD_OFF Mask */
N
N#define EBI_EBICON2_RAHD_OFF_Pos    1                                           /*!< EBI_T::EBICON2: RAHD_OFF Position */
N#define EBI_EBICON2_RAHD_OFF_Msk    (1ul << EBI_EBICON2_RAHD_OFF_Pos)           /*!< EBI_T::EBICON2: RAHD_OFF Mask */
N
N#define EBI_EBICON2_WBUFF_EN_Pos    0                                           /*!< EBI_T::EBICON2: WBUFF_EN Position */
N#define EBI_EBICON2_WBUFF_EN_Msk    (1ul << EBI_EBICON2_WBUFF_EN_Pos)           /*!< EBI_T::EBICON2: WBUFF_EN Mask */
N/*@}*/ /* end of group EBI_CONST */
N/*@}*/ /* end of group EBI */
N
N/*---------------------- Flash Memory Controller -------------------------*/
N/**
N    @addtogroup FMC Flash Memory Controller (FMC)
N    Memory Mapped Structure for FMC Controller
N@{ */
N
N
N
Ntypedef struct
N{
N
N
N/**
N * @var FMC_T::ISPCON
N * Offset: 0x00  ISP Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |ISPEN     |ISP Enable
N * |        |          |This bit is protected bit. ISP function enable bit. Set this bit to enable ISP function.
N * |        |          |1 = Enable ISP function
N * |        |          |0 = Disable ISP function
N * |[1]     |BS        |Boot Select
N * |        |          |This bit is protected bit. Set/clear this bit to select next booting from LDROM/APROM,
N * |        |          |respectively. This bit also functions as MCU booting status flag, which can be used to check
N * |        |          |where
N * |        |          |MCU booted from. This bit is initiated with the inversed value of CBS in Config0 after power-
N * |        |          |on reset; It keeps the same value at other reset.
N * |        |          |1 = boot from LDROM
N * |        |          |0 = boot from APROM
N * |[4]     |CFGUEN    |Config Update Enable
N * |        |          |Writing this bit to 1 enables s/w to update Config value by ISP procedure regardless of program
N * |        |          |code is running in APROM or LDROM.
N * |        |          |1 = Config update enable
N * |        |          |0 = Config update disable
N * |[5]     |LDUEN     |LDROM Update Enable
N * |        |          |LDROM update enable bit.
N * |        |          |1 = LDROM can be updated when the MCU runs in APROM.
N * |        |          |0 = LDROM cannot be updated
N * |[6]     |ISPFF     |ISP Fail Flag
N * |        |          |This bit is set by hardware when a triggered ISP meets any of the following conditions:
N * |        |          |(1) APROM writes to itself.
N * |        |          |(2) LDROM writes to itself.
N * |        |          |(3) Destination address is illegal, such as over an available range.
N * |        |          |Write 1 to clear.
N * |[7]     |SWRST     |Software Reset
N * |        |          |Writing 1 to this bit to start software reset.
N * |        |          |It is cleared by hardware after reset is finished.
N * |[10:8]  |PT        |Flash Program Time
N * |        |          |000 = 40 us
N * |        |          |001 = 45 us
N * |        |          |010 = 50 us
N * |        |          |011 = 55 us
N * |        |          |100 = 20 us
N * |        |          |101 = 25 us
N * |        |          |110 = 30 us
N * |        |          |111 = 35 us
N * |[14:12] |ET        |Flash Erase Time
N * |        |          |000 = 20 ms (default)
N * |        |          |001 = 25 ms
N * |        |          |010 = 30 ms
N * |        |          |011 = 35 ms
N * |        |          |100 = 3  ms
N * |        |          |101 = 5  ms
N * |        |          |110 = 10 ms
N * |        |          |111 = 15 ms
N * @var FMC_T::ISPADR
N * Offset: 0x04  ISP Address Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |ISPADR    |ISP Address
N * |        |          |NuMicro NUC230/240 series has a maximum of 32Kx32 (128 KB) embedded Flash,
N * |        |          |which supports word program only. ISPADR[1:0] must be kept 00b for ISP operation.
N * @var FMC_T::ISPDAT
N * Offset: 0x08  ISP Data Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |ISPDAT    |ISP Data
N * |        |          |Write data to this register before ISP program operation
N * |        |          |Read data from this register after ISP read operation
N * @var FMC_T::ISPCMD
N * Offset: 0x0C  ISP Command Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[5:0]   |FOEN_FCEN_FCTRL|ISP Command
N * |        |          |ISP command table is shown below:
N * |        |          |Operation Mode, FOEN, FCEN, FCTRL[3:0]
N * |        |          |Read          ,    0,    0, 0000
N * |        |          |Program       ,    1,    0, 0001
N * |        |          |Page Erase    ,    1,    0, 0010
N * @var FMC_T::ISPTRG
N * Offset: 0x10  IISP Trigger Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |ISPGO     |ISP start trigger
N * |        |          |Write 1 to start ISP operation and this bit will be cleared to 0 by hardware automatically when
N * |        |          |ISP
N * |        |          |operation is finish.
N * |        |          |1 = ISP is on going
N * |        |          |0 = ISP done
N * @var FMC_T::DFBADR
N * Offset: 0x14  Data Flash Base Address Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |DFBA      |Data Flash Base Address
N * |        |          |This register indicates data flash start address.
N * |        |          |It is a read only register.
N * |        |          |For 8/16/32/64kB flash memory device, the data flash size is 4kB and it start address is fixed
N * |        |          |at
N * |        |          |0x01F000 by hardware internally.
N * @var FMC_T::FATCON
N * Offset: 0x18  Flash Access Time Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |FPSEN     |Flash Power Save Enable
N * |        |          |If CPU clock is slower than 24 MHz, then s/w can enable flash power saving function.
N * |        |          |1 = Enable flash power saving
N * |        |          |0 = Disable flash power saving
N * |[3:1]   |FATS      |Flash Access Time Window Select
N * |        |          |These bits are used to decide flash sense amplifier active duration.
N * |        |          |000 = 40 ns
N * |        |          |001 = 50 ns
N * |        |          |010 = 60 ns
N * |        |          |011 = 70 ns
N * |        |          |100 = 80 ns
N * |        |          |101 = 90 ns
N * |        |          |110 = 100 ns
N * |        |          |111 = Reserved
N * |[4]     |L_SPEED   |Flash Low Speed Mode Enable
N * |        |          |1 = Flash access always no wait state (zero wait state)
N * |        |          |0 = Insert wait state while Flash access discontinued address.
N * |        |          |Note: Set this bit only when HCLK <= 25MHz. If HCLK > 25MHz, CPU will fetch wrong
N * |        |          |code and cause fail result.
N * @var FMC_T::ISPSTA
N * Offset: 0x40  ISP Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |ISPGO     |ISP Start Trigger (Read Only)
N * |        |          |Write 1 to start ISP operation and this bit will be cleared to 0 by hardware
N * |        |          |automatically when ISP operation is finished.
N * |        |          |0 = ISP operation finished.
N * |        |          |1 = ISP operation progressed.
N * |        |          |Note: This bit is the same as ISPTRG bit0
N * |[2:1]   |CBS       |Chip Boot Selection (Read Only)
N * |        |          |This is a mirror of CBS in Config0.
N * |[6]     |ISPFF     |ISP Fail Flag (Write-protection Bit)
N * |        |          |This bit is set by hardware when a triggered ISP meets any of the following conditions:
N * |        |          |(1) APROM writes to itself.
N * |        |          |(2) LDROM writes to itself.
N * |        |          |(3) CONFIG is erased/programmed when CFGUEN is set to 0
N * |        |          |(4) Destination address is illegal, such as over an available range.
N * |[20:9]  |VECMAP    |Vector Page Mapping Address (Read Only)
N * |        |          |The current flash address space 0x0000_0000~0x0000_01FF is mapping to the address
N * |        |          |{VECMAP[11:0], 9'h000} ~ {VECMAP[11:0], 9'h1FF}
N */
N
N    __IO uint32_t ISPCON;        /* Offset: 0x00  ISP Control Register                                               */
X    volatile uint32_t ISPCON;         
N    __IO uint32_t ISPADR;        /* Offset: 0x04  ISP Address Register                                               */
X    volatile uint32_t ISPADR;         
N    __IO uint32_t ISPDAT;        /* Offset: 0x08  ISP Data Register                                                  */
X    volatile uint32_t ISPDAT;         
N    __IO uint32_t ISPCMD;        /* Offset: 0x0C  ISP Command Register                                               */
X    volatile uint32_t ISPCMD;         
N    __IO uint32_t ISPTRG;        /* Offset: 0x10  IISP Trigger Control Register                                      */
X    volatile uint32_t ISPTRG;         
N    __I  uint32_t DFBADR;        /* Offset: 0x14  Data Flash Base Address Register                                   */
X    volatile const  uint32_t DFBADR;         
N    __IO uint32_t FATCON;        /* Offset: 0x18  Flash Access Time Control Register                                 */
X    volatile uint32_t FATCON;         
N    __I  uint32_t RESERVED[9];  
X    volatile const  uint32_t RESERVED[9];  
N    __IO uint32_t ISPSTA;        /* Offset: 0x40  ISP Status Register                                                */
X    volatile uint32_t ISPSTA;         
N
N} FMC_T;
N
N
N/**
N    @addtogroup FMC_CONST FMC Bit Field Definition
N    Constant Definitions for FMC Controller
N@{ */
N
N
N/* FMC ISPCON Bit Field Definitions */
N#define FMC_ISPCON_ET_Pos                       12                                      /*!< FMC_T::ISPCON: ET Position */
N#define FMC_ISPCON_ET_Msk                       (7ul << FMC_ISPCON_ET_Pos)              /*!< FMC_T::ISPCON: ET Mask     */
N
N#define FMC_ISPCON_PT_Pos                       8                                       /*!< FMC_T::ISPCON: PT Position */
N#define FMC_ISPCON_PT_Msk                       (7ul << FMC_ISPCON_PT_Pos)              /*!< FMC_T::ISPCON: PT Mask     */
N
N#define FMC_ISPCON_ISPFF_Pos                    6                                       /*!< FMC_T::ISPCON: ISPFF Position */
N#define FMC_ISPCON_ISPFF_Msk                    (1ul << FMC_ISPCON_ISPFF_Pos)           /*!< FMC_T::ISPCON: ISPFF Mask */
N
N#define FMC_ISPCON_LDUEN_Pos                    5                                       /*!< FMC_T::ISPCON: LDUEN Position */
N#define FMC_ISPCON_LDUEN_Msk                    (1ul << FMC_ISPCON_LDUEN_Pos)           /*!< FMC_T::ISPCON: LDUEN Mask */
N
N#define FMC_ISPCON_CFGUEN_Pos                   4                                       /*!< FMC_T::ISPCON: CFGUEN Position */
N#define FMC_ISPCON_CFGUEN_Msk                   (1ul << FMC_ISPCON_CFGUEN_Pos)          /*!< FMC_T::ISPCON: CFGUEN Mask */
N
N#define FMC_ISPCON_APUEN_Pos                    3                                       /*!< FMC_T::ISPCON: APUEN Position */
N#define FMC_ISPCON_APUEN_Msk                    (1ul << FMC_ISPCON_APUEN_Pos)           /*!< FMC_T::ISPCON: APUEN Mask */
N
N#define FMC_ISPCON_BS_Pos                       1                                       /*!< FMC_T::ISPCON: BS Position */
N#define FMC_ISPCON_BS_Msk                       (0x1ul << FMC_ISPCON_BS_Pos)            /*!< FMC_T::ISPCON: BS Mask */
N
N#define FMC_ISPCON_ISPEN_Pos                    0                                       /*!< FMC_T::ISPCON: ISPEN Position */
N#define FMC_ISPCON_ISPEN_Msk                    (1ul << FMC_ISPCON_ISPEN_Pos)           /*!< FMC_T::ISPCON: ISPEN Mask */
N
N/* FMC ISPADR Bit Field Definitions */
N#define FMC_ISPADR_ISPADR_Pos                   0                                       /*!< FMC_T::ISPADR: ISPADR Position */
N#define FMC_ISPADR_ISPADR_Msk                   (0xFFFFFFFFul << FMC_ISPADR_ISPADR_Pos) /*!< FMC_T::ISPADR: ISPADR Mask     */
N
N/* FMC ISPADR Bit Field Definitions */
N#define FMC_ISPDAT_ISPDAT_Pos                   0                                       /*!< FMC_T::ISPDAT: ISPDAT Position */
N#define FMC_ISPDAT_ISPDAT_Msk                   (0xFFFFFFFFul << FMC_ISPDAT_ISPDAT_Pos) /*!< FMC_T::ISPDAT: ISPDAT Mask     */
N
N/* FMC ISPCMD Bit Field Definitions */
N#define FMC_ISPCMD_FOEN_Pos                     5                                       /*!< FMC_T::ISPCMD: FOEN Position */
N#define FMC_ISPCMD_FOEN_Msk                     (1ul << FMC_ISPCMD_FOEN_Pos)            /*!< FMC_T::ISPCMD: FOEN Mask */
N
N#define FMC_ISPCMD_FCEN_Pos                     4                                       /*!< FMC_T::ISPCMD: FCEN Position */
N#define FMC_ISPCMD_FCEN_Msk                     (1ul << FMC_ISPCMD_FCEN_Pos)            /*!< FMC_T::ISPCMD: FCEN Mask */
N
N#define FMC_ISPCMD_FCTRL_Pos                    0                                       /*!< FMC_T::ISPCMD: FCTRL Position */
N#define FMC_ISPCMD_FCTRL_Msk                    (0xFul << FMC_ISPCMD_FCTRL_Pos)         /*!< FMC_T::ISPCMD: FCTRL Mask */
N
N/* FMC ISPTRG Bit Field Definitions */
N#define FMC_ISPTRG_ISPGO_Pos                    0                                       /*!< FMC_T::ISPTRG: ISPGO Position */
N#define FMC_ISPTRG_ISPGO_Msk                    (1ul << FMC_ISPTRG_ISPGO_Pos)           /*!< FMC_T::ISPTRG: ISPGO Mask */
N
N/* FMC DFBADR Bit Field Definitions */
N#define FMC_DFBADR_DFBA_Pos                     0                                       /*!< FMC_T::DFBADR: DFBA Position */
N#define FMC_DFBADR_DFBA_Msk                     (0xFFFFFFFFul << FMC_DFBADR_DFBA_Pos)   /*!< FMC_T::DFBADR: DFBA Mask     */
N
N/* FMC FATCON Bit Field Definitions */
N#define FMC_FATCON_FOMSEL1_Pos                  6                                       /*!< FMC_T::FATCON: FOMSEL1 Position */
N#define FMC_FATCON_FOMSEL1_Msk                  (1ul << FMC_FATCON_FOMSEL1_Pos)         /*!< FMC_T::FATCON: FOMSEL1 Mask */
N
N#define FMC_FATCON_FOMSEL0_Pos                  4                                       /*!< FMC_T::FATCON: FOMSEL0 Position */
N#define FMC_FATCON_FOMSEL0_Msk                  (1ul << FMC_FATCON_FOMSEL0_Pos)         /*!< FMC_T::FATCON: FOMSEL0 Mask */
N
N#define FMC_FATCON_FATS_Pos                     1                                       /*!< FMC_T::FATCON: FATS Position */
N#define FMC_FATCON_FATS_Msk                     (7ul << FMC_FATCON_FATS_Pos)            /*!< FMC_T::FATCON: FATS Mask */
N
N#define FMC_FATCON_FPSEN_Pos                    0                                       /*!< FMC_T::FATCON: FPSEN Position */
N#define FMC_FATCON_FPSEN_Msk                    (1ul << FMC_FATCON_FPSEN_Pos)           /*!< FMC_T::FATCON: FPSEN Mask */
N
N
N#define FMC_ISPSTA_ISPGO_Pos                    0                                       /*!< FMC_T::ISPSTA: ISPGO Position */
N#define FMC_ISPSTA_ISPGO_Msk                    (1ul << FMC_ISPSTA_ISPGO_Pos)           /*!< FMC_T::ISPSTA: ISPGO Mask */
N
N#define FMC_ISPSTA_CBS_Pos                      1                                       /*!< FMC_T::ISPSTA: CBS Position */
N#define FMC_ISPSTA_CBS_Msk                      (0x3ul << FMC_ISPSTA_CBS_Pos)           /*!< FMC_T::ISPSTA: CBS Mask */
N
N#define FMC_ISPSTA_ISPFF_Pos                    6                                       /*!< FMC_T::ISPSTA: ISPFF Position */
N#define FMC_ISPSTA_ISPFF_Msk                    (0x3ul << FMC_ISPSTA_ISPFF_Pos)         /*!< FMC_T::ISPSTA: ISPFF Mask */
N
N#define FMC_ISPSTA_VECMAP_Pos                   9                                       /*!< FMC_T::ISPSTA: VECMAP Position */
N#define FMC_ISPSTA_VECMAP_Msk                   (0xFFFul << FMC_ISPSTA_VECMAP_Pos)      /*!< FMC_T::ISPSTA: VECMAP Mask */
N/*@}*/ /* end of group FMC_CONST */
N/*@}*/ /* end of group FMC */
N
N
N/*---------------------- General Purpose Input/Output Controller -------------------------*/
N/**
N    @addtogroup GPIO General Purpose Input/Output Controller (GPIO)
N    Memory Mapped Structure for GPIO Controller
N@{ */
N
N
N
Ntypedef struct
N{
N
N
N/**
N * @var GPIO_T::PMD
N * Offset: 0x00  GPIO Port [A/B/C/D/E/F] Pin I/O Mode Control
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[2n+1:2n]|PMDn     |GPIOx I/O Pin[n] Mode Control
N * |        |          |Determine each I/O mode of GPIOx pins.
N * |        |          |00 = GPIO port [n] pin is in Input mode.
N * |        |          |01 = GPIO port [n] pin is in Push-pull Output mode.
N * |        |          |10 = GPIO port [n] pin is in Open-drain Output mode.
N * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
N * |        |          |Note1: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |        |          |Note2:
N * |        |          |The initial value of this field is defined by CIOINI (Config0[10]).
N * |        |          |If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be Quasi-bidirectional
N * |        |          |mode after chip is powered on.
N * |        |          |If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only mode
N * |        |          |after chip is powered on.
N * @var GPIO_T::OFFD
N * Offset: 0x04  GPIO Port [A/B/C/D/E/F] Pin Digital Input Path Disable Control
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:16] |OFFD      |GPIOx Pin[n] Digital Input Path Disable Control
N * |        |          |Each of these bits is used to control if the digital input path of corresponding GPIO pin is
N * |        |          |disabled.
N * |        |          |If input is analog signal, users can disable GPIO digital input path to avoid current leakage.
N * |        |          |0 = I/O digital input path Enabled.
N * |        |          |1 = I/O digital input path Disabled (digital input tied to low). 
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * @var GPIO_T::DOUT
N * Offset: 0x08  GPIO Port [A/B/C/D/E/F] Data Output Value
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[n]     |DOUTn     |GPIOx Pin[n] Output Value
N * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as
N * |        |          |Push-pull output, open-drain output or quasi-bidirectional mode.
N * |        |          |0 = GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull
N * |        |          |output, Open-drain output or Quasi-bidirectional mode.
N * |        |          |1 = GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull
N * |        |          |output or Quasi-bidirectional mode.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE. 
N * @var GPIO_T::DMASK
N * Offset: 0x0C  GPIO Port [A/B/C/D/E/F] Data Output Write Mask
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[n]     |DMASKn    |Port [A/B/C/D/E/F] Data Output Write Mask
N * |        |          |These bits are used to protect the corresponding register of GPIOx_DOUT bit[n].
N * |        |          |When the DMASK bit[n] is set to 1, the corresponding GPIOx_DOUT[n] bit is protected.
N * |        |          |If the write signal is masked, write data to the protect bit is ignored.
N * |        |          |0 = Corresponding GPIOx_DOUT[n] bit can be updated.
N * |        |          |1 = Corresponding GPIOx_DOUT[n] bit protected.
N * |        |          |Note1: This function only protects the corresponding GPIOx_DOUT[n] bit, and will not protect the
N * |        |          |corresponding bit control register (PAn_PDIO, PBn_PDIO, PCn_PDIO, PDn_PDIO, PEn_PDIO and
N * |        |          |PFn_PDIO). 
N * |        |          |Note2: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * @var GPIO_T::PIN
N * Offset: 0x10  GPIO Port [A/B/C/D/E/F] Pin Value
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[n]     |PINn      |Port [A/B/C/D/E/F] Pin Values
N * |        |          |Each bit of the register reflects the actual status of the respective GPIO pin.
N * |        |          |If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE. 
N * @var GPIO_T::DBEN
N * Offset: 0x14  GPIO Port [A/B/C/D/E/F] De-bounce Enable
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[n]     |DBENn     |Port [A/B/C/D/E/F] Input Signal De-Bounce Enable
N * |        |          |DBEN[n] is used to enable the de-bounce function for each corresponding bit.
N * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the
N * |        |          |input signal transition is seen as the signal bounce and will not trigger the interrupt.
N * |        |          |The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is
N * |        |          |controlled by DBNCECON[3:0].
N * |        |          |0 = Bit[n] de-bounce function Disabled.
N * |        |          |1 = Bit[n] de-bounce function Enabled.
N * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * @var GPIO_T::IMD
N * Offset: 0x18  GPIO Port [A/B/C/D/E/F] Interrupt Mode Control
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[n]     |IMDn      |Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control
N * |        |          |IMD[n] is used to control the interrupt is by level trigger or by edge trigger.
N * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
N * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK.
N * |        |          |clock and generates the interrupt.
N * |        |          |0 = Edge trigger interrupt.
N * |        |          |1 = Level trigger interrupt.
N * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers
N * |        |          |GPIOx_IEN.
N * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
N * |        |          |The de-bounce function is valid only for edge triggered interrupt.
N * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE. 
N * @var GPIO_T::IEN
N * Offset: 0x1C  GPIO Port [A/B/C/D/E/F] Interrupt Enable
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[n]     |IF_ENn    |Port [A/B/C/D/E/F] Interrupt Enable By Input Falling Edge Or Input Level Low
N * |        |          |IF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N * |        |          |Set bit to 1 also enable the pin wake-up function.
N * |        |          |When setting the IF_EN[n] bit to 1:
N * |        |          |If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the
N * |        |          |interrupt.
N * |        |          |If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate
N * |        |          |the interrupt.
N * |        |          |0 = PIN[n] state low-level or high-to-low change interrupt Disabled.
N * |        |          |1 = PIN[n] state low-level or high-to-low change interrupt Enabled.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * |[n+16]  |IR_ENn    |Port [A/B/C/D/E/F] Interrupt Enable By Input Rising Edge Or Input Level High
N * |        |          |IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
N * |        |          |Set bit to 1 also enable the pin wake-up function.
N * |        |          |When setting the IR_EN[n] bit to 1:
N * |        |          |If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the
N * |        |          |interrupt.
N * |        |          |If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate
N * |        |          |the interrupt.
N * |        |          |0 = PIN[n] level-high or low-to-high interrupt Disabled.
N * |        |          |1 = PIN[n] level-high or low-to-high interrupt Enabled.
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
N * @var GPIO_T::ISRC
N * Offset: 0x20  GPIO Port [A/B/C/D/E/F] Interrupt Source Flag
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[n]     |ISRCn     |Port [A/B/C/D/E/F] Interrupt Source Flag
N * |        |          |Read :
N * |        |          |0 = No interrupt at GPIOx[n].
N * |        |          |1 = GPIOx[n] generates an interrupt.
N * |        |          |Write :
N * |        |          |0= No action.
N * |        |          |1= Clear the corresponding pending interrupt. 
N * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE. 
N */
N
N    __IO uint32_t PMD;           /* Offset: 0x00  GPIO Port [A/B/C/D/E/F] Pin I/O Mode Control                       */
X    volatile uint32_t PMD;            
N    __IO uint32_t OFFD;          /* Offset: 0x04  GPIO Port [A/B/C/D/E/F] Pin Digital Input Path Disable Control     */
X    volatile uint32_t OFFD;           
N    __IO uint32_t DOUT;          /* Offset: 0x08  GPIO Port [A/B/C/D/E/F] Data Output Value                          */
X    volatile uint32_t DOUT;           
N    __IO uint32_t DMASK;         /* Offset: 0x0C  GPIO Port [A/B/C/D/E/F] Data Output Write Mask                     */
X    volatile uint32_t DMASK;          
N    __I  uint32_t PIN;           /* Offset: 0x10  GPIO Port [A/B/C/D/E/F] Pin Value                                  */
X    volatile const  uint32_t PIN;            
N    __IO uint32_t DBEN;          /* Offset: 0x14  GPIO Port [A/B/C/D/E/F] De-bounce Enable                           */
X    volatile uint32_t DBEN;           
N    __IO uint32_t IMD;           /* Offset: 0x18  GPIO Port [A/B/C/D/E/F] Interrupt Mode Control                     */
X    volatile uint32_t IMD;            
N    __IO uint32_t IEN;           /* Offset: 0x1C  GPIO Port [A/B/C/D/E/F] Interrupt Enable                           */
X    volatile uint32_t IEN;            
N    __IO uint32_t ISRC;          /* Offset: 0x20  GPIO Port [A/B/C/D/E/F] Interrupt Source Flag                      */
X    volatile uint32_t ISRC;           
N
N} GPIO_T;
N
N
N
N
N
Ntypedef struct
N{
N
N
N/**
N * @var GPIO_DBNCECON_T::DBNCECON
N * Offset: 0x180  External Interrupt De-bounce Control
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |DBCLKSEL  |De-Bounce Sampling Cycle Selection
N * |        |          |0000 = Sample interrupt input once per 1 clocks
N * |        |          |0001 = Sample interrupt input once per 2 clocks
N * |        |          |0010 = Sample interrupt input once per 4 clocks
N * |        |          |0011 = Sample interrupt input once per 8 clocks
N * |        |          |0100 = Sample interrupt input once per 16 clocks
N * |        |          |0101 = Sample interrupt input once per 32 clocks
N * |        |          |0110 = Sample interrupt input once per 64 clocks
N * |        |          |0111 = Sample interrupt input once per 128 clocks
N * |        |          |1000 = Sample interrupt input once per 256 clocks
N * |        |          |1001 = Sample interrupt input once per 2*256 clocks
N * |        |          |1010 = Sample interrupt input once per 4*256clocks
N * |        |          |1011 = Sample interrupt input once per 8*256 clocks
N * |        |          |1100 = Sample interrupt input once per 16*256 clocks
N * |        |          |1101 = Sample interrupt input once per 32*256 clocks
N * |        |          |1110 = Sample interrupt input once per 64*256 clocks
N * |        |          |1111 = Sample interrupt input once per 128*256 clocks
N * |        |          |Sample   interrupt input once per 128*256 clocks
N * |[4]     |DBCLKSRC  |De-Bounce Counter Clock Source Selection
N * |        |          |0 = De-bounce counter clock source is the HCLK.
N * |        |          |1 = De-bounce counter clock source is the internal 10 kHz low speed oscillator.
N * |[5]     |ICLK_ON   |Interrupt Clock On Mode
N * |        |          |0 = Edge detection circuit is active only if I/O pin corresponding GPIOx_IEN bit is set to 1.
N * |        |          |1 = All I/O pins edge detection circuit is always active after reset.
N * |        |          |It is recommended to turn off this bit to save system power if no special application concern.
N */
N
N    __IO uint32_t DBNCECON;      /* Offset: 0x180  External Interrupt De-bounce Control                              */
X    volatile uint32_t DBNCECON;       
N
N} GPIO_DBNCECON_T;
N
N
N/**
N    @addtogroup GPIO_CONST GPIO Bit Field Definition
N    Constant Definitions for GPIO Controller
N@{ */
N
N
N/* GPIO PMD Bit Field Definitions */
N#define GPIO_PMD_PMD15_Pos          30                                          /*!< GPIO_T::PMD: PMD15 Position */
N#define GPIO_PMD_PMD15_Msk          (0x3ul << GPIO_PMD_PMD15_Pos)               /*!< GPIO_T::PMD: PMD15 Mask */
N
N#define GPIO_PMD_PMD14_Pos          28                                          /*!< GPIO_T::PMD: PMD14 Position */
N#define GPIO_PMD_PMD14_Msk          (0x3ul << GPIO_PMD_PMD14_Pos)               /*!< GPIO_T::PMD: PMD14 Mask */
N
N#define GPIO_PMD_PMD13_Pos          26                                          /*!< GPIO_T::PMD: PMD13 Position */
N#define GPIO_PMD_PMD13_Msk          (0x3ul << GPIO_PMD_PMD13_Pos)               /*!< GPIO_T::PMD: PMD13 Mask */
N
N#define GPIO_PMD_PMD12_Pos          24                                          /*!< GPIO_T::PMD: PMD12 Position */
N#define GPIO_PMD_PMD12_Msk          (0x3ul << GPIO_PMD_PMD12_Pos)               /*!< GPIO_T::PMD: PMD12 Mask */
N
N#define GPIO_PMD_PMD11_Pos          22                                          /*!< GPIO_T::PMD: PMD11 Position */
N#define GPIO_PMD_PMD11_Msk          (0x3ul << GPIO_PMD_PMD11_Pos)               /*!< GPIO_T::PMD: PMD11 Mask */
N
N#define GPIO_PMD_PMD10_Pos          20                                          /*!< GPIO_T::PMD: PMD10 Position */
N#define GPIO_PMD_PMD10_Msk          (0x3ul << GPIO_PMD_PMD10_Pos)               /*!< GPIO_T::PMD: PMD10 Mask */
N
N#define GPIO_PMD_PMD9_Pos           18                                          /*!< GPIO_T::PMD: PMD9 Position */
N#define GPIO_PMD_PMD9_Msk           (0x3ul << GPIO_PMD_PMD9_Pos)                /*!< GPIO_T::PMD: PMD9 Mask */
N
N#define GPIO_PMD_PMD8_Pos           16                                          /*!< GPIO_T::PMD: PMD8 Position */
N#define GPIO_PMD_PMD8_Msk           (0x3ul << GPIO_PMD_PMD8_Pos)                /*!< GPIO_T::PMD: PMD8 Mask */
N
N#define GPIO_PMD_PMD7_Pos           14                                          /*!< GPIO_T::PMD: PMD7 Position */
N#define GPIO_PMD_PMD7_Msk           (0x3ul << GPIO_PMD_PMD7_Pos)                /*!< GPIO_T::PMD: PMD7 Mask */
N
N#define GPIO_PMD_PMD6_Pos           12                                          /*!< GPIO_T::PMD: PMD6 Position */
N#define GPIO_PMD_PMD6_Msk           (0x3ul << GPIO_PMD_PMD6_Pos)                /*!< GPIO_T::PMD: PMD6 Mask */
N
N#define GPIO_PMD_PMD5_Pos           10                                          /*!< GPIO_T::PMD: PMD5 Position */
N#define GPIO_PMD_PMD5_Msk           (0x3ul << GPIO_PMD_PMD5_Pos)                /*!< GPIO_T::PMD: PMD5 Mask */
N
N#define GPIO_PMD_PMD4_Pos           8                                           /*!< GPIO_T::PMD: PMD4 Position */
N#define GPIO_PMD_PMD4_Msk           (0x3ul << GPIO_PMD_PMD4_Pos)                /*!< GPIO_T::PMD: PMD4 Mask */
N
N#define GPIO_PMD_PMD3_Pos           6                                           /*!< GPIO_T::PMD: PMD3 Position */
N#define GPIO_PMD_PMD3_Msk           (0x3ul << GPIO_PMD_PMD3_Pos)                /*!< GPIO_T::PMD: PMD3 Mask */
N
N#define GPIO_PMD_PMD2_Pos           4                                           /*!< GPIO_T::PMD: PMD2 Position */
N#define GPIO_PMD_PMD2_Msk           (0x3ul << GPIO_PMD_PMD2_Pos)                /*!< GPIO_T::PMD: PMD2 Mask */
N
N#define GPIO_PMD_PMD1_Pos           2                                           /*!< GPIO_T::PMD: PMD1 Position */
N#define GPIO_PMD_PMD1_Msk           (0x3ul << GPIO_PMD_PMD1_Pos)                /*!< GPIO_T::PMD: PMD1 Mask */
N
N#define GPIO_PMD_PMD0_Pos           0                                           /*!< GPIO_T::PMD: PMD0 Position */
N#define GPIO_PMD_PMD0_Msk           (0x3ul << GPIO_PMD_PMD0_Pos)                /*!< GPIO_T::PMD: PMD0 Mask */
N
N/* GPIO OFFD Bit Field Definitions */
N#define GPIO_OFFD_OFFD_Pos          16                                          /*!< GPIO_T::OFFD: OFFD Position */
N#define GPIO_OFFD_OFFD_Msk          (0xFFFFul << GPIO_OFFD_OFFD_Pos)            /*!< GPIO_T::OFFD: OFFD Mask */
N
N/* GPIO DOUT Bit Field Definitions */
N#define GPIO_DOUT_DOUT_Pos          0                                           /*!< GPIO_T::DOUT: DOUT Position */
N#define GPIO_DOUT_DOUT_Msk          (0xFFFFul << GPIO_DOUT_DOUT_Pos)            /*!< GPIO_T::DOUT: DOUT Mask */
N
N/* GPIO DMASK Bit Field Definitions */
N#define GPIO_DMASK_DMASK_Pos        0                                           /*!< GPIO_T::DMASK: DMASK Position */
N#define GPIO_DMASK_DMASK_Msk        (0xFFFFul << GPIO_DMASK_DMASK_Pos)          /*!< GPIO_T::DMASK: DMASK Mask */
N
N/* GPIO PIN Bit Field Definitions */
N#define GPIO_PIN_PIN_Pos            0                                           /*!< GPIO_T::PIN: PIN Position */
N#define GPIO_PIN_PIN_Msk            (0xFFFFul << GPIO_PIN_PIN_Pos)              /*!< GPIO_T::PIN: PIN Mask */
N
N/* GPIO DBEN Bit Field Definitions */
N#define GPIO_DBEN_DBEN_Pos          0                                           /*!< GPIO_T::DBEN: DBEN Position */
N#define GPIO_DBEN_DBEN_Msk          (0xFFFFul << GPIO_DBEN_DBEN_Pos)            /*!< GPIO_T::DBEN: DBEN Mask */
N
N/* GPIO IMD Bit Field Definitions */
N#define GPIO_IMD_IMD_Pos            0                                           /*!< GPIO_T::IMD: IMD Position */
N#define GPIO_IMD_IMD_Msk            (0xFFFFul << GPIO_IMD_IMD_Pos)              /*!< GPIO_T::IMD: IMD Mask */
N
N/* GPIO IEN Bit Field Definitions */
N#define GPIO_IEN_IR_EN_Pos          16                                          /*!< GPIO_T::IEN: IR_EN Position */
N#define GPIO_IEN_IR_EN_Msk          (0xFFFFul << GPIO_IEN_IR_EN_Pos)            /*!< GPIO_T::IEN: IR_EN Mask */
N
N#define GPIO_IEN_IF_EN_Pos          0                                           /*!< GPIO_T::IEN: IF_EN Position */
N#define GPIO_IEN_IF_EN_Msk          (0xFFFFul << GPIO_IEN_IF_EN_Pos)            /*!< GPIO_T::IEN: IF_EN Mask */
N
N/* GPIO ISRC Bit Field Definitions */
N#define GPIO_ISRC_ISRC_Pos          0                                           /*!< GPIO_T::ISRC: ISRC Position */
N#define GPIO_ISRC_ISRC_Msk          (0xFFFFul << GPIO_ISRC_ISRC_Pos)            /*!< GPIO_T::ISRC: ISRC Mask */
N
N/* GPIO DBNCECON Bit Field Definitions */
N#define GPIO_DBNCECON_ICLK_ON_Pos   5                                           /*!< GPIO_DBNCECON_T::DBNCECON: ICLK_ON  Position */
N#define GPIO_DBNCECON_ICLK_ON_Msk   (1ul << GPIO_DBNCECON_ICLK_ON_Pos)          /*!< GPIO_DBNCECON_T::DBNCECON: ICLK_ON  Mask */
N
N#define GPIO_DBNCECON_DBCLKSRC_Pos  4                                           /*!< GPIO_DBNCECON_T::DBNCECON: DBCLKSRC Position */
N#define GPIO_DBNCECON_DBCLKSRC_Msk  (1ul << GPIO_DBNCECON_DBCLKSRC_Pos)         /*!< GPIO_DBNCECON_T::DBNCECON: DBCLKSRC Mask */
N
N#define GPIO_DBNCECON_DBCLKSEL_Pos  0                                           /*!< GPIO_DBNCECON_T::DBNCECON: DBCLKSEL Position */
N#define GPIO_DBNCECON_DBCLKSEL_Msk  (0xFul << GPIO_DBNCECON_DBCLKSEL_Pos)       /*!< GPIO_DBNCECON_T::DBNCECON: DBCLKSEL Mask */
N/*@}*/ /* end of group GPIO_CONST */
N/*@}*/ /* end of group GPIO */
N
N
N
N/*---------------------- Inter-IC Bus Controller -------------------------*/
N/**
N    @addtogroup I2C Inter-IC Bus Controller (I2C)
N    Memory Mapped Structure for I2C Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N/**
N * @var I2C_T::I2CON
N * Offset: 0x00  I2C Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[2]     |AA        |Assert Acknowledge Control
N * |        |          |When AA =1 prior to address or data received, an acknowledged (low level to I2Cn_SDA) will be
N * |        |          |returned during the acknowledge clock pulse on the I2Cn_SCL line when 
N * |        |          |1. A slave is acknowledging the address sent from master, 
N * |        |          |2. The receiver devices are acknowledging the data sent by transmitter.
N * |        |          |When AA=0 prior to address or data received, a Not acknowledged (high level to I2Cn_SDA) will be
N * |        |          |returned during the acknowledge clock pulse on the I2Cn_SCL line.
N * |[3]     |SI        |I2C Interrupt Flag
N * |        |          |When a new I2C state is present in the I2CSTATUS register, the SI flag is set by hardware, and
N * |        |          |if bit EI (I2CON [7]) is set, the I2C interrupt is requested.
N * |        |          |SI must be cleared by software.
N * |        |          |Clear SI by writing 1 to this bit.
N * |[4]     |STO       |I2C STOP Control
N * |        |          |In Master mode, setting STO to transmit a STOP condition to bus then I2C hardware will check the
N * |        |          |bus condition if a STOP condition is detected this bit will be cleared by hardware
N * |        |          |automatically.
N * |        |          |In a slave mode, setting STO resets I2C hardware to the defined "not addressed" slave mode.
N * |        |          |This means it is NO LONGER in the slave receiver mode to receive data from the master transmit
N * |        |          |device.
N * |[5]     |STA       |I2C START Control
N * |        |          |Setting STA to logic 1 to enter Master mode, the I2C hardware sends a START or repeat START
N * |        |          |condition to bus when the bus is free.
N * |[6]     |ENS1      |I2C Controller Enable
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |        |          |Set to enable I2C serial function controller.
N * |        |          |When ENS1=1 the I2C serial function enables.
N * |        |          |The multi-function pin function of I2Cn_SDA and I2Cn_SCL must set to I2C function first.
N * |[7]     |EI        |Enable Interrupt
N * |        |          |0 = I2C interrupt Disabled.
N * |        |          |1 = I2C interrupt Enabled.
N * @var I2C_T::I2CADDR0
N * Offset: 0x04  I2C Slave Address Register0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |GC        |General Call Function
N * |        |          |0 = General Call Function Disabled.
N * |        |          |1 = General Call Function Enabled.
N * |[7:1]   |I2CADDR   |I2C Address Register
N * |        |          |The content of this register is irrelevant when I2C is in Master mode.
N * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own address.
N * |        |          |The I2C hardware will react if either of the address is matched.
N * @var I2C_T::I2CDAT
N * Offset: 0x08  I2C Data Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |I2CDAT    |I2C Data Register
N * |        |          |Bit [7:0] is located with the 8-bit transferred data of I2C serial port.
N * @var I2C_T::I2CSTATUS
N * Offset: 0x0C  I2C Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |I2CSTATUS |I2C Status Register
N * |        |          |The status register of I2C:
N * |        |          |The three least significant bits are always 0.
N * |        |          |The five most significant bits contain the status code.
N * |        |          |There are 26 possible status codes.
N * |        |          |When I2CSTATUS contains F8H, no serial interrupt is requested.
N * |        |          |All other I2CSTATUS values correspond to defined I2C states.
N * |        |          |When each of these states is entered, a status interrupt is requested (SI = 1).
N * |        |          |A valid status code is present in I2CSTATUS one cycle after SI is set by hardware and is still
N * |        |          |present one cycle after SI has been reset by software.
N * |        |          |In addition, states 00H stands for a Bus Error.
N * |        |          |A Bus Error occurs when a START or STOP condition is present at an illegal position in the
N * |        |          |formation frame.
N * |        |          |Example of illegal position are during the serial transfer of an address byte, a data byte or an
N * |        |          |acknowledge bit.
N * @var I2C_T::I2CLK
N * Offset: 0x10  I2C Clock Divided Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |I2CLK     |I2C clock divided Register
N * |        |          |The I2C clock rate bits: Data Baud Rate of I2C = (system clock) / (4x (I2CLK+1)).
N * |        |          |Note: The minimum value of I2CLK is 4.
N * @var I2C_T::I2CTOC
N * Offset: 0x14  I2C Time-out Counter Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |TIF       |Time-out Flag
N * |        |          |This bit is set by H/W when I2C time-out happened and it can interrupt CPU if I2C interrupt
N * |        |          |enable bit (EI) is set to 1.
N * |        |          |Note: Write 1 to clear this bit.
N * |[1]     |DIV4      |Time-out Counter Input Clock Divided by 4
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |        |          |When Enabled, The time-out period is extend 4 times.
N * |[2]     |ENTI      |Time-out Counter Enable/Disable
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |        |          |When Enabled, the 14-bit time-out counter will start counting when SI is clear.
N * |        |          |Setting flag SI to high will reset counter and re-start up counting after SI is cleared.
N * @var I2C_T::I2CADDR1
N * Offset: 0x18  I2C Slave Address Register1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |GC        |General Call Function
N * |        |          |0 = General Call Function Disabled.
N * |        |          |1 = General Call Function Enabled.
N * |[7:1]   |I2CADDR   |I2C Address Register
N * |        |          |The content of this register is irrelevant when I2C is in Master mode.
N * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own address.
N * |        |          |The I2C hardware will react if either of the address is matched.
N * @var I2C_T::I2CADDR2
N * Offset: 0x1C  I2C Slave Address Register2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |GC        |General Call Function
N * |        |          |0 = General Call Function Disabled.
N * |        |          |1 = General Call Function Enabled.
N * |[7:1]   |I2CADDR   |I2C Address Register
N * |        |          |The content of this register is irrelevant when I2C is in Master mode.
N * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own address.
N * |        |          |The I2C hardware will react if either of the address is matched.
N * @var I2C_T::I2CADDR3
N * Offset: 0x20  I2C Slave Address Register3
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |GC        |General Call Function
N * |        |          |0 = General Call Function Disabled.
N * |        |          |1 = General Call Function Enabled.
N * |[7:1]   |I2CADDR   |I2C Address Register
N * |        |          |The content of this register is irrelevant when I2C is in Master mode.
N * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own address.
N * |        |          |The I2C hardware will react if either of the address is matched.
N * @var I2C_T::I2CADM0
N * Offset: 0x24  I2C Slave Address Mask Register0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:1]   |I2CADM    |I2C Address Mask Register
N * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address
N * |        |          |register.).
N * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
N * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
N * |        |          |When the bit in the address mask register is set to one, it means the received corresponding
N * |        |          |address bit is don't-care.
N * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact
N * |        |          |the same as address register.
N * @var I2C_T::I2CADM1
N * Offset: 0x28  I2C Slave Address Mask Register1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:1]   |I2CADM    |I2C Address Mask Register
N * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address
N * |        |          |register.).
N * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
N * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
N * |        |          |When the bit in the address mask register is set to one, it means the received corresponding
N * |        |          |address bit is don't-care.
N * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact
N * |        |          |the same as address register.
N * @var I2C_T::I2CADM2
N * Offset: 0x2C  I2C Slave Address Mask Register2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:1]   |I2CADM    |I2C Address Mask Register
N * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address
N * |        |          |register.).
N * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
N * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
N * |        |          |When the bit in the address mask register is set to one, it means the received corresponding
N * |        |          |address bit is don't-care.
N * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact
N * |        |          |the same as address register.
N * @var I2C_T::I2CADM3
N * Offset: 0x30  I2C Slave Address Mask Register3
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:1]   |I2CADM    |I2C Address Mask Register
N * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address
N * |        |          |register.).
N * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
N * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
N * |        |          |When the bit in the address mask register is set to one, it means the received corresponding
N * |        |          |address bit is don't-care.
N * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact
N * |        |          |the same as address register.
N * @var I2C_T::I2CWKUPCON
N * Offset: 0x3C  I2C Wake-up Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |WKUPEN    |I2C Wake-up Enable
N * |        |          |0 = I2C wake-up function Disabled.
N * |        |          |1= I2C wake-up function Enabled.
N * @var I2C_T::I2CWKUPSTS
N * Offset: 0x40  I2C Wake-up Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |WKUPIF    |I2C Wake-up Flag
N * |        |          |When chip is woken up from Power-down mode by I2C, this bit is set to 1.
N * |        |          |Software can write 1 to clear this bit.
N */
N
N    __IO uint32_t I2CON;         /* Offset: 0x00  I2C Control Register                                               */
X    volatile uint32_t I2CON;          
N    __IO uint32_t I2CADDR0;      /* Offset: 0x04  I2C Slave Address Register0                                        */
X    volatile uint32_t I2CADDR0;       
N    __IO uint32_t I2CDAT;        /* Offset: 0x08  I2C Data Register                                                  */
X    volatile uint32_t I2CDAT;         
N    __I  uint32_t I2CSTATUS;     /* Offset: 0x0C  I2C Status Register                                                */
X    volatile const  uint32_t I2CSTATUS;      
N    __IO uint32_t I2CLK;         /* Offset: 0x10  I2C Clock Divided Register                                         */
X    volatile uint32_t I2CLK;          
N    __IO uint32_t I2CTOC;        /* Offset: 0x14  I2C Time-out Counter Register                                      */
X    volatile uint32_t I2CTOC;         
N    __IO uint32_t I2CADDR1;      /* Offset: 0x18  I2C Slave Address Register1                                        */
X    volatile uint32_t I2CADDR1;       
N    __IO uint32_t I2CADDR2;      /* Offset: 0x1C  I2C Slave Address Register2                                        */
X    volatile uint32_t I2CADDR2;       
N    __IO uint32_t I2CADDR3;      /* Offset: 0x20  I2C Slave Address Register3                                        */
X    volatile uint32_t I2CADDR3;       
N    __IO uint32_t I2CADM0;       /* Offset: 0x24  I2C Slave Address Mask Register0                                   */
X    volatile uint32_t I2CADM0;        
N    __IO uint32_t I2CADM1;       /* Offset: 0x28  I2C Slave Address Mask Register1                                   */
X    volatile uint32_t I2CADM1;        
N    __IO uint32_t I2CADM2;       /* Offset: 0x2C  I2C Slave Address Mask Register2                                   */
X    volatile uint32_t I2CADM2;        
N    __IO uint32_t I2CADM3;       /* Offset: 0x30  I2C Slave Address Mask Register3                                   */
X    volatile uint32_t I2CADM3;        
N    __I  uint32_t RESERVED0[2]; 
X    volatile const  uint32_t RESERVED0[2]; 
N    __IO uint32_t I2CWKUPCON;    /* Offset: 0x3C  I2C Wake-up Control Register                                       */
X    volatile uint32_t I2CWKUPCON;     
N    __IO uint32_t I2CWKUPSTS;    /* Offset: 0x40  I2C Wake-up Status Register                                        */
X    volatile uint32_t I2CWKUPSTS;     
N
N} I2C_T;
N
N
N/**
N    @addtogroup I2C_CONST I2C Bit Field Definition
N    Constant Definitions for I2C Controller
N@{ */
N
N
N
N/* I2C I2CON Bit Field Definitions */
N#define I2C_I2CON_EI_Pos                        7                                       /*!< I2C_T::I2CON: EI Position */
N#define I2C_I2CON_EI_Msk                        (1ul << I2C_I2CON_EI_Pos)               /*!< I2C_T::I2CON: EI Mask */
N
N#define I2C_I2CON_ENS1_Pos                      6                                       /*!< I2C_T::I2CON: ENS1 Position */
N#define I2C_I2CON_ENS1_Msk                      (1ul << I2C_I2CON_ENS1_Pos)             /*!< I2C_T::I2CON: ENS1 Mask */
N
N#define I2C_I2CON_STA_Pos                       5                                       /*!< I2C_T::I2CON: STA Position */
N#define I2C_I2CON_STA_Msk                       (1ul << I2C_I2CON_STA_Pos)              /*!< I2C_T::I2CON: STA Mask */
N
N#define I2C_I2CON_STO_Pos                       4                                       /*!< I2C_T::I2CON: STO Position */
N#define I2C_I2CON_STO_Msk                       (1ul << I2C_I2CON_STO_Pos)              /*!< I2C_T::I2CON: STO Mask */
N
N#define I2C_I2CON_SI_Pos                        3                                       /*!< I2C_T::I2CON: SI Position */
N#define I2C_I2CON_SI_Msk                        (1ul << I2C_I2CON_SI_Pos)               /*!< I2C_T::I2CON: SI Mask */
N
N#define I2C_I2CON_AA_Pos                        2                                       /*!< I2C_T::I2CON: AA Position */
N#define I2C_I2CON_AA_Msk                        (1ul << I2C_I2CON_AA_Pos)               /*!< I2C_T::I2CON: AA Mask */
N
N/* I2C I2CADDR Bit Field Definitions */
N#define I2C_I2CADDR_I2CADDR_Pos                 1                                       /*!< I2C_T::I2CADDR1: I2CADDR Position */
N#define I2C_I2CADDR_I2CADDR_Msk                 (0x7Ful << I2C_I2CADDR_I2CADDR_Pos)     /*!< I2C_T::I2CADDR1: I2CADDR Mask */
N
N#define I2C_I2CADDR_GC_Pos                      0                                       /*!< I2C_T::I2CADDR1: GC Position */
N#define I2C_I2CADDR_GC_Msk                      (1ul << I2C_I2CADDR_GC_Pos)             /*!< I2C_T::I2CADDR1: GC Mask */
N
N/* I2C I2CDAT Bit Field Definitions */
N#define I2C_I2CDAT_I2CDAT_Pos                   0                                       /*!< I2C_T::I2CDAT: I2CDAT Position */
N#define I2C_I2CDAT_I2CDAT_Msk                   (0xFFul << I2C_I2CDAT_I2CDAT_Pos)       /*!< I2C_T::I2CDAT: I2CDAT Mask */
N
N/* I2C I2CSTATUS Bit Field Definitions */
N#define I2C_I2CSTATUS_I2CSTATUS_Pos             0                                       /*!< I2C_T::I2CSTATUS: I2CSTATUS Position */
N#define I2C_I2CSTATUS_I2CSTATUS_Msk             (0xFFul << I2C_I2CSTATUS_I2CSTATUS_Pos) /*!< I2C_T::I2CSTATUS: I2CSTATUS Mask */
N
N/* I2C I2CLK Bit Field Definitions */
N#define I2C_I2CLK_I2CLK_Pos                     0                                       /*!< I2C_T::I2CLK: I2CLK Position */
N#define I2C_I2CLK_I2CLK_Msk                     (0xFFul << I2C_I2CLK_I2CLK_Pos)         /*!< I2C_T::I2CLK: I2CLK Mask */
N
N/* I2C I2CTOC Bit Field Definitions */
N#define I2C_I2CTOC_ENTI_Pos                     2                                       /*!< I2C_T::I2CTOC: ENTI Position */
N#define I2C_I2CTOC_ENTI_Msk                     (1ul << I2C_I2CTOC_ENTI_Pos)            /*!< I2C_T::I2CTOC: ENTI Mask */
N
N#define I2C_I2CTOC_DIV4_Pos                     1                                       /*!< I2C_T::I2CTOC: DIV4 Position */
N#define I2C_I2CTOC_DIV4_Msk                     (1ul << I2C_I2CTOC_DIV4_Pos)            /*!< I2C_T::I2CTOC: DIV4 Mask */
N
N#define I2C_I2CTOC_TIF_Pos                      0                                       /*!< I2C_T::I2CTOC: TIF Position */
N#define I2C_I2CTOC_TIF_Msk                      (1ul << I2C_I2CTOC_TIF_Pos)             /*!< I2C_T::I2CTOC: TIF Mask */
N
N/* I2C I2CADM Bit Field Definitions */
N#define I2C_I2CADM_I2CADM_Pos                   1                                       /*!< I2C_T::I2CADM0: I2CADM Position */
N#define I2C_I2CADM_I2CADM_Msk                   (0x7Ful << I2C_I2CADM_I2CADM_Pos)       /*!< I2C_T::I2CADM0: I2CADM Mask */
N
N/* I2C I2CWKUPCON Bit Field Definitions */
N#define I2C_I2CWKUPCON_WKUPEN_Pos               0                                       /*!< I2C_T::I2CWKUPCON: WKUPEN Position */
N#define I2C_I2CWKUPCON_WKUPEN_Msk               (1ul << I2C_I2CWKUPCON_WKUPEN_Pos)      /*!< I2C_T::I2CWKUPCON: WKUPEN Mask */
N
N/* I2C I2CWKUPSTS Bit Field Definitions */
N#define I2C_I2CWKUPSTS_WKUPIF_Pos               0                                       /*!< I2C_T::I2CWKUPSTS: WKUPIF Position */
N#define I2C_I2CWKUPSTS_WKUPIF_Msk               (1ul << I2C_I2CWKUPSTS_WKUPIF_Pos)      /*!< I2C_T::I2CWKUPSTS: WKUPIF Mask */
N/*@}*/ /* end of group I2C_CONST */
N/*@}*/ /* end of group I2C */
N
N
N
N/*----------------------------- I2S Controller -------------------------------*/
N/** @addtogroup I2S Integrated Interchip Sound(I2S)
N  Memory Mapped Structure for I2S Interface Controller
N  @{
N */
N
N
Ntypedef struct
N{
N
N
N/**
N * @var I2S_T::CON
N * Offset: 0x00  I2S Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |I2SEN     |I2S Controller Enable
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[1]     |TXEN      |Transmit Enable
N * |        |          |0 = Data transmit Disabled.
N * |        |          |1 = Data transmit Enabled.
N * |[2]     |RXEN      |Receive Enable
N * |        |          |0 = Data receiving Disabled.
N * |        |          |1 = Data receiving Enabled.
N * |[3]     |MUTE      |Transmit Mute Enable
N * |        |          |0 = Transmit data is shifted from buffer.
N * |        |          |1 = Send zero on transmit channel.
N * |[5:4]   |WORDWIDTH |Word Width
N * |        |          |00 = data is 8-bit word.
N * |        |          |01 = data is 16-bit word.
N * |        |          |10 = data is 24-bit word.
N * |        |          |11 = data is 32-bit word.
N * |[6]     |MONO      |Monaural Data
N * |        |          |0 = Data is stereo format.
N * |        |          |1 = Data is monaural format.
N * |[7]     |FORMAT    |Data Format
N * |        |          |0 = I2S data format.
N * |        |          |1 = MSB justified data format.
N * |[8]     |SLAVE     |Slave Mode
N * |        |          |I2S can operate as master or slave.
N * |        |          |For Master mode, I2S_BCLK and I2S_LRCLK pins are output mode and send bit clock from NuMicro
N * |        |          |NUC230_240 series to Audio CODEC chip.
N * |        |          |In Slave mode, I2S_BCLK and I2S_LRCLK pins are input mode and I2S_BCLK and I2S_LRCLK signals are
N * |        |          |received from outer Audio CODEC chip.
N * |        |          |0 = Master mode.
N * |        |          |1 = Slave mode.
N * |[11:9]  |TXTH      |Transmit FIFO Threshold Level
N * |        |          |If the count of remaining data word (32 bits) in transmit FIFO is equal to or less than
N * |        |          |threshold level then TXTHF (I2SSTATUS[18]) is set.
N * |        |          |000 = 0 word data in transmit FIFO.
N * |        |          |001 = 1 word data in transmit FIFO.
N * |        |          |010 = 2 words data in transmit FIFO.
N * |        |          |011 = 3 words data in transmit FIFO.
N * |        |          |100 = 4 words data in transmit FIFO.
N * |        |          |101 = 5 words data in transmit FIFO.
N * |        |          |110 = 6 words data in transmit FIFO.
N * |        |          |111 = 7 words data in transmit FIFO.
N * |[14:12] |RXTH      |Receive FIFO Threshold Level
N * |        |          |When the count of received data word(s) in buffer is equal to or higher than threshold level,
N * |        |          |RXTHF (I2SSTATUS[10]) will be set.
N * |        |          |000 = 1 word data in receive FIFO.
N * |        |          |001 = 2 word data in receive FIFO.
N * |        |          |010 = 3 word data in receive FIFO.
N * |        |          |011 = 4 word data in receive FIFO.
N * |        |          |100 = 5 word data in receive FIFO.
N * |        |          |101 = 6 word data in receive FIFO.
N * |        |          |110 = 7 word data in receive FIFO.
N * |        |          |111 = 8 word data in receive FIFO.
N * |[15]    |MCLKEN    |Master Clock Enable
N * |        |          |If MCLKEN is set to 1, I2S controller will generate master clock on I2S_MCLK pin for external
N * |        |          |audio devices.
N * |        |          |0 = Master clock Disabled.
N * |        |          |1 = Master clock Enabled.
N * |[16]    |RCHZCEN   |Right Channel Zero Cross Detection Enable
N * |        |          |If this bit is set to 1, when right channel data sign bit change or next shift data bits are all
N * |        |          |0 then RZCF flag in I2SSTATUS register is set to 1.
N * |        |          |This function is only available in transmit operation.
N * |        |          |0 = Right channel zero cross detection Disabled.
N * |        |          |1 = Right channel zero cross detection Enabled.
N * |[17]    |LCHZCEN   |Left Channel Zero Cross Detection Enable
N * |        |          |If this bit is set to 1, when left channel data sign bit changes or next shift data bits are all
N * |        |          |0 then LZCF flag in I2SSTATUS register is set to 1.
N * |        |          |This function is only available in transmit operation.
N * |        |          |0 = Left channel zero cross detection Disabled.
N * |        |          |1 = Left channel zero cross detection Enabled.
N * |[18]    |CLR_TXFIFO|Clear Transmit FIFO
N * |        |          |Write 1 to clear transmit FIFO, internal pointer is reset to FIFO start point, and TX_LEVEL[3:0]
N * |        |          |returns to 0 and
N * |        |          |transmit FIFO becomes empty but data in transmit FIFO is not changed.
N * |        |          |This bit is cleared by hardware automatically. Returns 0 on read.
N * |[19]    |CLR_RXFIFO|Clear Receive FIFO
N * |        |          |Write 1 to clear receive FIFO, internal pointer is reset to FIFO start point, and RX_LEVEL[3:0]
N * |        |          |returns 0 and receive FIFO becomes empty.
N * |        |          |This bit is cleared by hardware automatically. Returns 0 on read.
N * |[20]    |TXDMA     |Enable Transmit DMA
N * |        |          |When TX DMA is enabled, I2S request DMA to transfer data from SRAM to transmit FIFO if FIFO is
N * |        |          |not full.
N * |        |          |0 = TX DMA Disabled.
N * |        |          |1 = TX DMA Enabled.
N * |[21]    |RXDMA     |Enable Receive DMA
N * |        |          |When RX DMA is enabled, I2S requests DMA to transfer data from receive FIFO to SRAM if FIFO is
N * |        |          |not empty.
N * |        |          |0 = RX DMA Disabled.
N * |        |          |1 = RX DMA Enabled.
N * |[23]    |RXLCH     |Receive Left Channel Enable
N * |        |          |When monaural format is selected (MONO = 1), I2S controller will receive right channel data if
N * |        |          |RXLCH is set to 0,
N * |        |          |and receive left channel data if RXLCH is set to 1.
N * |        |          |0 = Receive right channel data in Mono mode.
N * |        |          |1 = Receive left channel data in Mono mode.
N * @var I2S_T::CLKDIV
N * Offset: 0x04  I2S Clock Divider Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[2:0]   |MCLK_DIV  |Master Clock Divider
N * |        |          |If MCLKEN is set to 1, I2S controller will generate master clock for external audio devices.
N * |        |          |The master clock rate, F_MCLK, is determined by the following expressions.
N * |        |          |If MCLK_DIV >= 1, F_MCLK = F_I2SCLK/(2x(MCLK_DIV)).
N * |        |          |If MCLK_DIV = 0, F_MCLK = F_I2SCLK.
N * |        |          |F_I2SCLK is the frequency of I2S peripheral clock.
N * |        |          |In general, the master clock rate is 256 times sampling clock rate.
N * |[15:8]  |BCLK_DIV  |Bit Clock Divider
N * |        |          |The I2S controller will generate bit clock in Master mode.
N * |        |          |The bit clock rate, F_BCLK, is determined by the following expression.
N * |        |          |F_BCLK = F_I2SCLK /(2x(BCLK_DIV + 1)) , where F_I2SCLK is the frequency of I2S peripheral clock.
N * @var I2S_T::IE
N * Offset: 0x08  I2S Interrupt Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |RXUDFIE   |Receive FIFO Underflow Interrupt Enable
N * |        |          |0 = Interrupt Disabled.
N * |        |          |1 = Interrupt Enabled.
N * |[1]     |RXOVFIE   |Receive FIFO Overflow Interrupt Enable
N * |        |          |0 = Interrupt Disabled.
N * |        |          |1 = Interrupt Enabled.
N * |[2]     |RXTHIE    |Receive FIFO Threshold Level Interrupt Enable
N * |        |          |When the count of data words in receive FIFO is equal to or higher than RXTH (I2SCON[14:12]) and
N * |        |          |this bit is set to 1, receive FIFO threshold level interrupt will be asserted.
N * |        |          |0 = Interrupt Disabled.
N * |        |          |1 = Interrupt Enabled.
N * |[8]     |TXUDFIE   |Transmit FIFO Underflow Interrupt Enable
N * |        |          |Interrupt occurs if this bit is set to 1 and the transmit FIFO underflow flag is set to 1.
N * |        |          |0 = Interrupt Disabled.
N * |        |          |1 = Interrupt Enabled.
N * |[9]     |TXOVFIE   |Transmit FIFO Overflow Interrupt Enable
N * |        |          |Interrupt occurs if this bit is set to 1 and the transmit FIFO overflow flag is set to 1
N * |        |          |0 = Interrupt Disabled.
N * |        |          |1 = Interrupt Enabled.
N * |[10]    |TXTHIE    |Transmit FIFO Threshold Level Interrupt Enable
N * |        |          |Interrupt occurs if this bit is set to 1 and the count of data words in transmit FIFO is less
N * |        |          |than TXTH (I2SCON[11:9]).
N * |        |          |0 = Interrupt Disabled.
N * |        |          |1 = Interrupt Enabled.
N * |[11]    |RZCIE     |Right Channel Zero-Cross Interrupt Enable
N * |        |          |Interrupt occurs if this bit is set to 1 and right channel zero-cross event is detected.
N * |        |          |0 = Interrupt Disabled.
N * |        |          |1 = Interrupt Enabled.
N * |[12]    |LZCIE     |Left Channel Zero-Cross Interrupt Enable
N * |        |          |Interrupt occurs if this bit is set to 1 and left channel zero-cross event is detected.
N * |        |          |0 = Interrupt Disabled.
N * |        |          |1 = Interrupt Enabled.
N * @var I2S_T::STATUS
N * Offset: 0x0C  I2S Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |I2SINT    |I2S Interrupt Flag
N * |        |          |This bit is wire-OR of I2STXINT and I2SRXINT bits.
N * |        |          |0 = No I2S interrupt.
N * |        |          |1 = I2S interrupt.
N * |        |          |Note: This bit is read only.
N * |[1]     |I2SRXINT  |I2S Receive Interrupt
N * |        |          |0 = No receive interrupt.
N * |        |          |1 = Receive interrupt.
N * |        |          |Note: This bit is read only.
N * |[2]     |I2STXINT  |I2S Transmit Interrupt
N * |        |          |0 = No transmit interrupt.
N * |        |          |1 = Transmit interrupt.
N * |        |          |Note: This bit is read only.
N * |[3]     |RIGHT     |Right Channel
N * |        |          |This bit indicates current transmit data is belong to which channel
N * |        |          |0 = Left channel.
N * |        |          |1 = Right channel.
N * |        |          |Note: This bit is read only.
N * |[8]     |RXUDF     |Receive FIFO Underflow Flag
N * |        |          |Underflow event will occur if read the empty receive FIFO.
N * |        |          |0 = No underflow event occurred.
N * |        |          |1 = Underflow.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * |[9]     |RXOVF     |Receive FIFO Overflow Flag
N * |        |          |When receive FIFO is full and hardware attempt to write data to receive FIFO, this bit will be
N * |        |          |set to 1, data in 1st buffer will be overwrote.
N * |        |          |0 = No overflow.
N * |        |          |1 = Overflow.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * |[10]    |RXTHF     |Receive FIFO Threshold Flag
N * |        |          |When data word(s) in receive FIFO is equal to or larger than threshold value set in RXTH
N * |        |          |(I2SCON[14:12]).
N * |        |          |The RXTHF bit becomes to 1.
N * |        |          |It keeps at 1 till RX_LEVEL (I2SSTATUS[27:24]) is less than RXTH.
N * |        |          |0 = Data word(s) in FIFO is less than threshold level.
N * |        |          |1 = Data word(s) in FIFO is equal to or larger than threshold level.
N * |        |          |Note: This bit is read only.
N * |[11]    |RXFULL    |Receive FIFO Full
N * |        |          |This bit reflects the count of data in receive FIFO is 8
N * |        |          |0 = Not full.
N * |        |          |1 = Full.
N * |        |          |Note: This bit is read only.
N * |[12]    |RXEMPTY   |Receive FIFO Empty
N * |        |          |This bit reflects the count of data in receive FIFO is 0
N * |        |          |0 = Not empty.
N * |        |          |1 = Empty.
N * |        |          |Note: This bit is read only.
N * |[16]    |TXUDF     |Transmit FIFO Underflow Flag
N * |        |          |If transmit FIFO is empty and hardware reads data from transmit FIFO. This bit will be set to 1.
N * |        |          |0 = No underflow.
N * |        |          |1 = Underflow.
N * |        |          |Note: Software can write 1 to clear this bit to 0.
N * |[17]    |TXOVF     |Transmit FIFO Overflow Flag
N * |        |          |This bit will be set to 1 if writes data to transmit FIFO when transmit FIFO is full.
N * |        |          |0 = No overflow.
N * |        |          |1 = Overflow.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * |[18]    |TXTHF     |Transmit FIFO Threshold Flag
N * |        |          |When the count of data stored in transmit-FIFO is equal to or less than threshold value set in
N * |        |          |TXTH (I2SCON[11:9]).
N * |        |          |The TXTHF bit becomes to 1.
N * |        |          |It keeps at 1 till TX_LEVEL (I2SSTATUS[31:28]) is larger than TXTH.
N * |        |          |0 = Data word(s) in FIFO is larger than threshold level.
N * |        |          |1 = Data word(s) in FIFO is equal to or less than threshold level.
N * |        |          |Note: This bit is read only.
N * |[19]    |TXFULL    |Transmit FIFO Full
N * |        |          |This bit reflects data word number in transmit FIFO is 8
N * |        |          |0 = Not full.
N * |        |          |1 = Full.
N * |        |          |Note: This bit is read only.
N * |[20]    |TXEMPTY   |Transmit FIFO Empty
N * |        |          |This bit reflects data word number in transmit FIFO is 0
N * |        |          |0 = Not empty.
N * |        |          |1 = Empty.
N * |        |          |Note: This bit is read only.
N * |[21]    |TXBUSY    |Transmit Busy
N * |        |          |This bit is cleared to 0 when all data in transmit FIFO and shift buffer is shifted out.
N * |        |          |And set to 1 when 1st data is load to shift buffer.
N * |        |          |0 = Transmit shift buffer is empty.
N * |        |          |1 = Transmit shift buffer is not empty.
N * |        |          |Note: This bit is read only.
N * |[22]    |RZCF      |Right Channel Zero-Cross Flag
N * |        |          |It indicates the sign bit of right channel sample data is changed or all data bits are 0.
N * |        |          |0 = No zero-cross.
N * |        |          |1 = Right channel zero-cross event is detected.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * |[23]    |LZCF      |Left Channel Zero-Cross Flag
N * |        |          |It indicates the sign bit of left channel sample data is changed or all data bits are 0.
N * |        |          |0 = No zero-cross.
N * |        |          |1 = Left channel zero-cross event is detected.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * |[27:24] |RX_LEVEL  |Receive FIFO Level
N * |        |          |These bits indicate word number in receive FIFO
N * |        |          |0000 = No data.
N * |        |          |0001 = 1 word in receive FIFO.
N * |        |          |....
N * |        |          |1000 = 8 words in receive FIFO.
N * |[31:28] |TX_LEVEL  |Transmit FIFO Level
N * |        |          |These bits indicate word number in transmit FIFO
N * |        |          |0000 = No data.
N * |        |          |0001 = 1 word in transmit FIFO.
N * |        |          |....
N * |        |          |1000 = 8 words in transmit FIFO.
N * @var I2S_T::TXFIFO
N * Offset: 0x10  I2S Transmit FIFO Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |TXFIFO    |Transmit FIFO Register
N * |        |          |I2S contains 8 words (8x32 bits) data buffer for data transmit.
N * |        |          |Write data to this register to prepare data for transmission.
N * |        |          |The remaining word number is indicated by TX_LEVEL (I2SSTATUS[31:28]).
N * @var I2S_T::RXFIFO
N * Offset: 0x14  I2S Receive FIFO Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |RXFIFO    |Receive FIFO Register
N * |        |          |I2S contains 8 words (8x32 bits) data buffer for data receive.
N * |        |          |Read this register to get data of receive FIFO.
N * |        |          |The remaining data word number is indicated by RX_LEVEL (I2SSTATUS[27:24]).
N */
N
N    __IO uint32_t CON;           /* Offset: 0x00  I2S Control Register                                               */
X    volatile uint32_t CON;            
N    __IO uint32_t CLKDIV;        /* Offset: 0x04  I2S Clock Divider Control Register                                 */
X    volatile uint32_t CLKDIV;         
N    __IO uint32_t IE;            /* Offset: 0x08  I2S Interrupt Enable Register                                      */
X    volatile uint32_t IE;             
N    __IO uint32_t STATUS;        /* Offset: 0x0C  I2S Status Register                                                */
X    volatile uint32_t STATUS;         
N    __O  uint32_t TXFIFO;        /* Offset: 0x10  I2S Transmit FIFO Register                                         */
X    volatile  uint32_t TXFIFO;         
N    __I  uint32_t RXFIFO;        /* Offset: 0x14  I2S Receive FIFO Register                                          */
X    volatile const  uint32_t RXFIFO;         
N
N} I2S_T;
N
N
N
N/**
N    @addtogroup I2S_CONST I2S Bit Field Definition
N    Constant Definitions for I2S Controller
N@{ */
N
N
N/* I2S I2SCON Bit Field Definitions */
N#define I2S_CON_RXLCH_Pos                    23                                   /*!< I2S_T::CON: RXLCH Position         */
N#define I2S_CON_RXLCH_Msk                    (1ul << I2S_CON_RXLCH_Pos)           /*!< I2S_T::CON: RXLCH Mask             */
N
N#define I2S_CON_RXDMA_Pos                    21                                   /*!< I2S_T::CON: RXDMA Position         */
N#define I2S_CON_RXDMA_Msk                    (1ul << I2S_CON_RXDMA_Pos)           /*!< I2S_T::CON: RXDMA Mask             */
N
N#define I2S_CON_TXDMA_Pos                    20                                   /*!< I2S_T::CON: TXDMA Position         */
N#define I2S_CON_TXDMA_Msk                    (1ul << I2S_CON_TXDMA_Pos)           /*!< I2S_T::CON: TXDMA Mask             */
N
N#define I2S_CON_CLR_RXFIFO_Pos               19                                   /*!< I2S_T::CON: CLR_RXFIFO Position    */
N#define I2S_CON_CLR_RXFIFO_Msk               (1ul << I2S_CON_CLR_RXFIFO_Pos)      /*!< I2S_T::CON: CLR_RXFIFO Mask        */
N
N#define I2S_CON_CLR_TXFIFO_Pos               18                                   /*!< I2S_T::CON: CLR_TXFIFO Position    */
N#define I2S_CON_CLR_TXFIFO_Msk               (1ul << I2S_CON_CLR_TXFIFO_Pos)      /*!< I2S_T::CON: CLR_TXFIFO Mask        */
N
N#define I2S_CON_LCHZCEN_Pos                  17                                   /*!< I2S_T::CON: LCHZCEN Position       */
N#define I2S_CON_LCHZCEN_Msk                  (1ul << I2S_CON_LCHZCEN_Pos)         /*!< I2S_T::CON: LCHZCEN Mask           */
N
N#define I2S_CON_RCHZCEN_Pos                  16                                   /*!< I2S_T::CON: RCHZCEN Position       */
N#define I2S_CON_RCHZCEN_Msk                  (1ul << I2S_CON_RCHZCEN_Pos)         /*!< I2S_T::CON: RCHZCEN Mask           */
N
N#define I2S_CON_MCLKEN_Pos                   15                                   /*!< I2S_T::CON: MCLKEN Position        */
N#define I2S_CON_MCLKEN_Msk                   (1ul << I2S_CON_MCLKEN_Pos)          /*!< I2S_T::CON: MCLKEN Mask            */
N
N#define I2S_CON_RXTH_Pos                     12                                   /*!< I2S_T::CON: RXTH Position          */
N#define I2S_CON_RXTH_Msk                     (7ul << I2S_CON_RXTH_Pos)            /*!< I2S_T::CON: RXTH Mask              */
N
N#define I2S_CON_TXTH_Pos                     9                                    /*!< I2S_T::CON: TXTH Position          */
N#define I2S_CON_TXTH_Msk                     (7ul << I2S_CON_TXTH_Pos)            /*!< I2S_T::CON: TXTH Mask              */
N
N#define I2S_CON_SLAVE_Pos                    8                                    /*!< I2S_T::CON: SLAVE Position         */
N#define I2S_CON_SLAVE_Msk                    (1ul << I2S_CON_SLAVE_Pos)           /*!< I2S_T::CON: SLAVE Mask             */
N
N#define I2S_CON_FORMAT_Pos                   7                                    /*!< I2S_T::CON: FORMAT Position        */
N#define I2S_CON_FORMAT_Msk                   (1ul << I2S_CON_FORMAT_Pos)          /*!< I2S_T::CON: FORMAT Mask            */
N
N#define I2S_CON_MONO_Pos                     6                                    /*!< I2S_T::CON: MONO Position          */
N#define I2S_CON_MONO_Msk                     (1ul << I2S_CON_MONO_Pos)            /*!< I2S_T::CON: MONO Mask              */
N
N#define I2S_CON_WORDWIDTH_Pos                4                                    /*!< I2S_T::CON: WORDWIDTH Position     */
N#define I2S_CON_WORDWIDTH_Msk                (3ul << I2S_CON_WORDWIDTH_Pos)       /*!< I2S_T::CON: WORDWIDTH Mask         */
N
N#define I2S_CON_MUTE_Pos                     3                                    /*!< I2S_T::CON: MUTE Position          */
N#define I2S_CON_MUTE_Msk                     (1ul << I2S_CON_MUTE_Pos)            /*!< I2S_T::CON: MUTE Mask              */
N
N#define I2S_CON_RXEN_Pos                     2                                    /*!< I2S_T::CON: RXEN Position          */
N#define I2S_CON_RXEN_Msk                     (1ul << I2S_CON_RXEN_Pos)            /*!< I2S_T::CON: RXEN Mask              */
N
N#define I2S_CON_TXEN_Pos                     1                                    /*!< I2S_T::CON: TXEN Position          */
N#define I2S_CON_TXEN_Msk                     (1ul << I2S_CON_TXEN_Pos)            /*!< I2S_T::CON: TXEN Mask              */
N
N#define I2S_CON_I2SEN_Pos                    0                                    /*!< I2S_T::CON: I2SEN Position         */
N#define I2S_CON_I2SEN_Msk                    (1ul << I2S_CON_I2SEN_Pos)           /*!< I2S_T::CON: I2SEN Mask             */
N
N/* I2S I2SCLKDIV Bit Field Definitions */
N#define I2S_CLKDIV_BCLK_DIV_Pos              8                                    /*!< I2S_T::CLKDIV: BCLK_DIV Position   */
N#define I2S_CLKDIV_BCLK_DIV_Msk              (0xFFul << I2S_CLKDIV_BCLK_DIV_Pos)  /*!< I2S_T::CLKDIV: BCLK_DIV Mask       */
N
N#define I2S_CLKDIV_MCLK_DIV_Pos              0                                    /*!< I2S_T::CLKDIV: MCLK_DIV Position   */
N#define I2S_CLKDIV_MCLK_DIV_Msk              (7ul << I2S_CLKDIV_MCLK_DIV_Pos)     /*!< I2S_T::CLKDIV: MCLK_DIV Mask       */
N
N/* I2S I2SIE Bit Field Definitions */
N#define I2S_IE_LZCIE_Pos                     12                                   /*!< I2S_T::IE: LZCIE Position          */
N#define I2S_IE_LZCIE_Msk                     (1ul << I2S_IE_LZCIE_Pos)            /*!< I2S_T::IE: LZCIE Mask              */
N
N#define I2S_IE_RZCIE_Pos                     11                                   /*!< I2S_T::IE: RZCIE Position          */
N#define I2S_IE_RZCIE_Msk                     (1ul << I2S_IE_RZCIE_Pos)            /*!< I2S_T::IE: RZCIE Mask              */
N
N#define I2S_IE_TXTHIE_Pos                    10                                   /*!< I2S_T::IE: TXTHIE Position         */
N#define I2S_IE_TXTHIE_Msk                    (1ul << I2S_IE_TXTHIE_Pos)           /*!< I2S_T::IE: TXTHIE Mask             */
N
N#define I2S_IE_TXOVFIE_Pos                   9                                    /*!< I2S_T::IE: TXOVFIE Position        */
N#define I2S_IE_TXOVFIE_Msk                   (1ul << I2S_IE_TXOVFIE_Pos)          /*!< I2S_T::IE: TXOVFIE Mask            */
N
N#define I2S_IE_TXUDFIE_Pos                   8                                    /*!< I2S_T::IE: TXUDFIE Position        */
N#define I2S_IE_TXUDFIE_Msk                   (1ul << I2S_IE_TXUDFIE_Pos)          /*!< I2S_T::IE: TXUDFIE Mask            */
N
N#define I2S_IE_RXTHIE_Pos                    2                                    /*!< I2S_T::IE: RXTHIE Position         */
N#define I2S_IE_RXTHIE_Msk                    (1ul << I2S_IE_RXTHIE_Pos)           /*!< I2S_T::IE: RXTHIE Mask             */
N
N#define I2S_IE_RXOVFIE_Pos                   1                                    /*!< I2S_T::IE: RXOVFIE Position        */
N#define I2S_IE_RXOVFIE_Msk                   (1ul << I2S_IE_RXOVFIE_Pos)          /*!< I2S_T::IE: RXOVFIE Mask            */
N
N#define I2S_IE_RXUDFIE_Pos                   0                                    /*!< I2S_T::IE: RXUDFIE Position        */
N#define I2S_IE_RXUDFIE_Msk                   (1ul << I2S_IE_RXUDFIE_Pos)          /*!< I2S_T::IE: RXUDFIE Mask            */
N
N
N/* I2S I2SSTATUS Bit Field Definitions */
N#define I2S_STATUS_TX_LEVEL_Pos              28                                      /*!< I2S_T::STATUS: TX_LEVEL Position   */
N#define I2S_STATUS_TX_LEVEL_Msk              (0xFul << I2S_STATUS_TX_LEVEL_Pos)   /*!< I2S_T::STATUS: TX_LEVEL Mask       */
N
N#define I2S_STATUS_RX_LEVEL_Pos              24                                   /*!< I2S_T::STATUS: RX_LEVEL Position   */
N#define I2S_STATUS_RX_LEVEL_Msk              (0xFul << I2S_STATUS_RX_LEVEL_Pos)   /*!< I2S_T::STATUS: RX_LEVEL Mask       */
N
N#define I2S_STATUS_LZCF_Pos                  23                                      /*!< I2S_T::STATUS: LZCF Position       */
N#define I2S_STATUS_LZCF_Msk                  (1ul << I2S_STATUS_LZCF_Pos)         /*!< I2S_T::STATUS: LZCF Mask           */
N
N#define I2S_STATUS_RZCF_Pos                  22                                   /*!< I2S_T::STATUS: RZCF Position       */
N#define I2S_STATUS_RZCF_Msk                  (1ul << I2S_STATUS_RZCF_Pos)         /*!< I2S_T::STATUS: RZCF Mask           */
N
N#define I2S_STATUS_TXBUSY_Pos                21                                   /*!< I2S_T::STATUS: TXBUSY Position     */
N#define I2S_STATUS_TXBUSY_Msk                (1ul << I2S_STATUS_TXBUSY_Pos)       /*!< I2S_T::STATUS: TXBUSY Mask         */
N
N#define I2S_STATUS_TXEMPTY_Pos               20                                   /*!< I2S_T::STATUS: TXEMPTY Position    */
N#define I2S_STATUS_TXEMPTY_Msk               (1ul << I2S_STATUS_TXEMPTY_Pos)      /*!< I2S_T::STATUS: TXEMPTY Mask        */
N
N#define I2S_STATUS_TXFULL_Pos                19                                   /*!< I2S_T::STATUS: TXFULL Position     */
N#define I2S_STATUS_TXFULL_Msk                (1ul << I2S_STATUS_TXFULL_Pos)       /*!< I2S_T::STATUS: TXFULL Mask         */
N
N#define I2S_STATUS_TXTHF_Pos                 18                                   /*!< I2S_T::STATUS: TXTHF Position      */
N#define I2S_STATUS_TXTHF_Msk                 (1ul << I2S_STATUS_TXTHF_Pos)        /*!< I2S_T::STATUS: TXTHF Mask          */
N
N#define I2S_STATUS_TXOVF_Pos                 17                                   /*!< I2S_T::STATUS: TXOVF Position      */
N#define I2S_STATUS_TXOVF_Msk                 (1ul << I2S_STATUS_TXOVF_Pos)        /*!< I2S_T::STATUS: TXOVF Mask          */
N
N#define I2S_STATUS_TXUDF_Pos                 16                                   /*!< I2S_T::STATUS: TXUDF Position      */
N#define I2S_STATUS_TXUDF_Msk                 (1ul << I2S_STATUS_TXUDF_Pos)        /*!< I2S_T::STATUS: TXUDF Mask          */
N
N#define I2S_STATUS_RXEMPTY_Pos               12                                   /*!< I2S_T::STATUS: RXEMPTY Position    */
N#define I2S_STATUS_RXEMPTY_Msk               (1ul << I2S_STATUS_RXEMPTY_Pos)      /*!< I2S_T::STATUS: RXEMPTY Mask        */
N
N#define I2S_STATUS_RXFULL_Pos                11                                   /*!< I2S_T::STATUS: RXFULL Position     */
N#define I2S_STATUS_RXFULL_Msk                (1ul << I2S_STATUS_RXFULL_Pos)       /*!< I2S_T::STATUS: RXFULL Mask         */
N
N#define I2S_STATUS_RXTHF_Pos                 10                                   /*!< I2S_T::STATUS: RXTHF Position      */
N#define I2S_STATUS_RXTHF_Msk                 (1ul << I2S_STATUS_RXTHF_Pos)        /*!< I2S_T::STATUS: RXTHF Mask          */
N
N#define I2S_STATUS_RXOVF_Pos                 9                                    /*!< I2S_T::STATUS: RXOVF Position      */
N#define I2S_STATUS_RXOVF_Msk                 (1ul << I2S_STATUS_RXOVF_Pos)        /*!< I2S_T::STATUS: RXOVF Mask          */
N
N#define I2S_STATUS_RXUDF_Pos                 8                                    /*!< I2S_T::STATUS: RXUDF Position      */
N#define I2S_STATUS_RXUDF_Msk                 (1ul << I2S_STATUS_RXUDF_Pos)        /*!< I2S_T::STATUS: RXUDF Mask          */
N
N#define I2S_STATUS_RIGHT_Pos                 3                                    /*!< I2S_T::STATUS: RIGHT Position      */
N#define I2S_STATUS_RIGHT_Msk                 (1ul << I2S_STATUS_RIGHT_Pos)        /*!< I2S_T::STATUS: RIGHT Mask          */
N
N#define I2S_STATUS_I2STXINT_Pos              2                                    /*!< I2S_T::STATUS: I2STXINT Position   */
N#define I2S_STATUS_I2STXINT_Msk              (1ul << I2S_STATUS_I2STXINT_Pos)     /*!< I2S_T::STATUS: I2STXINT Mask       */
N
N#define I2S_STATUS_I2SRXINT_Pos              1                                    /*!< I2S_T::STATUS: I2SRXINT Position   */
N#define I2S_STATUS_I2SRXINT_Msk              (1ul << I2S_STATUS_I2SRXINT_Pos)     /*!< I2S_T::STATUS: I2SRXINT Mask       */
N
N#define I2S_STATUS_I2SINT_Pos                0                                    /*!< I2S_T::STATUS: I2SINT Position     */
N#define I2S_STATUS_I2SINT_Msk                (1ul << I2S_STATUS_I2SINT_Pos)       /*!< I2S_T::STATUS: I2SINT Mask         */
N/*@}*/ /* end of group I2S_CONST */
N/*@}*/ /* end of group I2S */
N
N
N
N/*---------------------- Peripheral Direct Memory Access Controller -------------------------*/
N/**
N    @addtogroup PDMA Peripheral Direct Memory Access Controller (PDMA)
N    Memory Mapped Structure for PDMA Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N/**
N * @var PDMA_T::CSR
N * Offset: 0x00  PDMA Channel x Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |PDMACEN   |PDMA Channel Enable
N * |        |          |Setting this bit to 1 enables PDMA operation.
N * |        |          |If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.
N * |        |          |Note: SW_RST(PDMA_CSRx[1], x= 0~8) will clear this bit.
N * |[1]     |SW_RST    |Software Engine Reset
N * |        |          |0 = No effect.
N * |        |          |1 = Reset the internal state machine, pointers and internal buffer.
N * |        |          |The contents of control register will not be cleared.
N * |        |          |This bit will be automatically cleared after few clock cycles.
N * |[3:2]   |MODE_SEL  |PDMA Mode Selection
N * |        |          |00 = Memory to Memory mode (Memory-to-Memory).
N * |        |          |01 = Peripheral to Memory mode (Peripheral-to-Memory).
N * |        |          |10 = Memory to Peripheral mode (Memory-to-Peripheral).
N * |[5:4]   |SAD_SEL   |Transfer Source Address Direction Selection
N * |        |          |00 = Transfer source address is increasing successively.
N * |        |          |01 = Reserved.
N * |        |          |10 = Transfer source address is fixed (This feature can be used when data where transferred from
N * |        |          |a single source to multiple destinations).
N * |        |          |11 = Reserved.
N * |[7:6]   |DAD_SEL   |Transfer Destination Address Direction Selection
N * |        |          |00 = Transfer destination address is increasing successively.
N * |        |          |01 = Reserved.
N * |        |          |10 = Transfer destination address is fixed.
N * |        |          |(This feature can be used when data where transferred from multiple sources to a single
N * |        |          |destination).
N * |        |          |11 = Reserved.
N * |[20:19] |APB_TWS   |Peripheral Transfer Width Selection
N * |        |          |00 = One word (32-bit) is transferred for every PDMA operation.
N * |        |          |01 = One byte (8-bit) is transferred for every PDMA operation.
N * |        |          |10 = One half-word (16-bit) is transferred for every PDMA operation.
N * |        |          |11 = Reserved.
N * |        |          |Note: This field is meaningful only when MODE_SEL (PDMA_CSRx[3:2]) is Peripheral to Memory mode
N * |        |          |(Peripheral-to-Memory) or Memory to Peripheral mode (Memory-to-Peripheral).
N * |[23]    |TRIG_EN   |Trigger Enable
N * |        |          |0 = No effect.
N * |        |          |1 = PDMA data read or write transfer Enabled.
N * |        |          |Note: When PDMA transfer completed, this bit will be cleared automatically.
N * |        |          |If the bus error occurs, all PDMA transfer will be stopped.
N * |        |          |Software must reset all PDMA channel, and then trigger again.
N * @var PDMA_T::SAR
N * Offset: 0x04  PDMA Channel x Source Address Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |PDMA_SAR  |PDMA Transfer Source Address Register
N * |        |          |This field indicates a 32-bit source address of PDMA.
N * |        |          |Note: The source address must be word alignment.
N * @var PDMA_T::DAR
N * Offset: 0x08  PDMA Channel x Destination Address Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |PDMA_DAR  |PDMA Transfer Destination Address Register
N * |        |          |This field indicates a 32-bit destination address of PDMA.
N * |        |          |Note: The destination address must be word alignment
N * @var PDMA_T::BCR
N * Offset: 0x0C  PDMA Channel x Transfer Byte Count Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |PDMA_BCR  |PDMA Transfer Byte Count Register
N * |        |          |This field indicates a 16-bit transfer byte count number of PDMA; it must be word alignment.
N * @var PDMA_T::POINT
N * Offset: 0x10  PDMA Channel x Internal buffer pointer Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |PDMA_POINT|PDMA Internal Buffer Pointer Register (Read Only)
N * |        |          |This field indicates the internal buffer pointer.
N * @var PDMA_T::CSAR
N * Offset: 0x14  PDMA Channel x Current Source Address Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |PDMA_CSAR |PDMA Current Source Address Register (Read Only)
N * |        |          |This field indicates the source address where the PDMA transfer just occurred.
N * @var PDMA_T::CDAR
N * Offset: 0x18  PDMA Channel x Current Destination Address Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |PDMA_CDAR |PDMA Current Destination Address Register (Read Only)
N * |        |          |This field indicates the destination address where the PDMA transfer just occurred.
N * @var PDMA_T::CBCR
N * Offset: 0x1C  PDMA Channel x Current Transfer Byte Count Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |PDMA_CBCR |PDMA Current Byte Count Register (Read Only)
N * |        |          |This field indicates the current remained byte count of PDMA.
N * |        |          |Note: This field value will be cleared to 0, when software set SW_RST (PDMA_CSRx[1]) to "1".
N * @var PDMA_T::IER
N * Offset: 0x20  PDMA Channel x Interrupt Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |TABORT_IE |PDMA Read/Write Target Abort Interrupt Enable
N * |        |          |0 = Target abort interrupt generation Disabled during PDMA transfer.
N * |        |          |1 = Target abort interrupt generation Enabled during PDMA transfer.
N * |[1]     |BLKD_IE   |PDMA Block Transfer Done Interrupt Enable
N * |        |          |0 = Interrupt generator Disabled when PDMA transfer is done.
N * |        |          |1 = Interrupt generator Enabled when PDMA transfer is done.
N * @var PDMA_T::ISR
N * Offset: 0x24  PDMA Channel x Interrupt Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |TABORT_IF |PDMA Read/Write Target Abort Interrupt Flag
N * |        |          |Write 1 to clear this bit to 0.
N * |        |          |0 = No bus ERROR response received.
N * |        |          |1 = Bus ERROR response received.
N * |        |          |Note: This bit filed indicates bus master received ERROR response or not.
N * |        |          |If bus master received ERROR response, it means that target abort is happened.
N * |        |          |PDMA controller will stop transfer and respond this event to software then goes to IDLE state.
N * |        |          |When target abort occurred, software must reset PDMA, and then transfer those data again.
N * |[1]     |BLKD_IF   |PDMA Block Transfer Done Interrupt Flag
N * |        |          |This bit indicates that PDMA has finished all transfers.
N * |        |          |0 = Not finished.
N * |        |          |1 = Done.
N * |        |          |Write 1 to clear this bit to 0.
N * @var PDMA_T::SBUF
N * Offset: 0x80  PDMA Channel x Shared Buffer FIFO x Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |PDMA_SBUF0|PDMA Shared Buffer FIFO 0 (Read Only)
N * |        |          |Each channel has its own 1 word internal buffer.
N */
N
N    __IO uint32_t CSR;           /* Offset: 0x00  PDMA Channel x Control Register                                    */
X    volatile uint32_t CSR;            
N    __IO uint32_t SAR;           /* Offset: 0x04  PDMA Channel x Source Address Register                             */
X    volatile uint32_t SAR;            
N    __IO uint32_t DAR;           /* Offset: 0x08  PDMA Channel x Destination Address Register                        */
X    volatile uint32_t DAR;            
N    __IO uint32_t BCR;           /* Offset: 0x0C  PDMA Channel x Transfer Byte Count Register                        */
X    volatile uint32_t BCR;            
N    __I  uint32_t POINT;         /* Offset: 0x10  PDMA Channel x Internal buffer pointer Register                    */
X    volatile const  uint32_t POINT;          
N    __I  uint32_t CSAR;          /* Offset: 0x14  PDMA Channel x Current Source Address Register                     */
X    volatile const  uint32_t CSAR;           
N    __I  uint32_t CDAR;          /* Offset: 0x18  PDMA Channel x Current Destination Address Register                */
X    volatile const  uint32_t CDAR;           
N    __I  uint32_t CBCR;          /* Offset: 0x1C  PDMA Channel x Current Transfer Byte Count Register                */
X    volatile const  uint32_t CBCR;           
N    __IO uint32_t IER;           /* Offset: 0x20  PDMA Channel x Interrupt Enable Register                           */
X    volatile uint32_t IER;            
N    __IO uint32_t ISR;           /* Offset: 0x24  PDMA Channel x Interrupt Status Register                           */
X    volatile uint32_t ISR;            
N    __I  uint32_t RESERVE[22];  
X    volatile const  uint32_t RESERVE[22];  
N    __I  uint32_t SBUF;          /* Offset: 0x80  PDMA Channel x Shared Buffer FIFO x Register                       */
X    volatile const  uint32_t SBUF;           
N
N} PDMA_T;
N
N
N
N
N
Ntypedef struct
N{
N
N
N/**
N * @var PDMA_GCR_T::GCRCSR
N * Offset: 0x00  PDMA Global Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[8]     |CLK0_EN   |PDMA Controller Channel 0 Clock Enable Control
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[9]     |CLK1_EN   |PDMA Controller Channel 1 Clock Enable Control
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[10]    |CLK2_EN   |PDMA Controller Channel 2 Clock Enable Control
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[11]    |CLK3_EN   |PDMA Controller Channel 3 Clock Enable Control
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[12]    |CLK4_EN   |PDMA Controller Channel 4 Clock Enable Control
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[13]    |CLK5_EN   |PDMA Controller Channel 5 Clock Enable Control
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[14]    |CLK6_EN   |PDMA Controller Channel 6 Clock Enable Control
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[15]    |CLK7_EN   |PDMA Controller Channel 7 Clock Enable Control
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[16]    |CLK8_EN   |PDMA Controller Channel 8 Clock Enable Control
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[24]    |CRC_CLK_EN|CRC Controller Clock Enable Control
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * @var PDMA_GCR_T::PDSSR0
N * Offset: 0x04  PDMA Service Selection Control Register 0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |SPI0_RXSEL|PDMA SPI0 RX Selection
N * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral SPI0 RX.
N * |        |          |Software can change the channel RX setting by this field.
N * |        |          |For example, SPI0_RXSEL (PDMA_PDSSR0[3:0]) = 0110, that means SPI0_RX is connected to PDMA_CH6.
N * |        |          |0000: CH0
N * |        |          |0001: CH1
N * |        |          |0010: CH2
N * |        |          |0011: CH3
N * |        |          |0100: CH4
N * |        |          |0101: CH5
N * |        |          |0110: CH6
N * |        |          |0111: CH7
N * |        |          |1000: CH8
N * |        |          |Others : Reserved
N * |[7:4]   |SPI0_TXSEL|PDMA SPI0 TX Selection
N * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral SPI0 TX.
N * |        |          |Software can configure the TX channel setting by this field.
N * |        |          |The channel configuration is the same as SPI0_RXSEL (PDMA_PDSSR0[3:0]) field.
N * |        |          |Please refer to the explanation of SPI0_RXSEL (PDMA_PDSSR0[3:0]).
N * |[11:8]  |SPI1_RXSEL|PDMA SPI1 RX Selection
N * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral SPI1 RX.
N * |        |          |Software can configure the RX channel setting by this field.
N * |        |          |The channel configuration is the same as SPI0_RXSEL (PDMA_PDSSR0[3:0]) field.
N * |        |          |Please refer to the explanation of SPI0_RXSEL (PDMA_PDSSR0[3:0]).
N * |[15:12] |SPI1_TXSEL|PDMA SPI1 TX Selection
N * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral SPI1 TX.
N * |        |          |Software can configure the TX channel setting by this field.
N * |        |          |The channel configuration is the same as SPI0_RXSEL (PDMA_PDSSR0[3:0]) field.
N * |        |          |Please refer to the explanation of SPI0_RXSEL (PDMA_PDSSR0[3:0]).
N * |[19:16] |SPI2_RXSEL|PDMA SPI2 RX Selection
N * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral SPI2 RX.
N * |        |          |Software can configure the RX channel setting by this field.
N * |        |          |The channel configuration is the same as SPI0_RXSEL (PDMA_PDSSR0[3:0]) field.
N * |        |          |Please refer to the explanation of SPI0_RXSEL (PDMA_PDSSR0[3:0]).
N * |[23:20] |SPI2_TXSEL|PDMA SPI2 TX Selection
N * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral SPI2 TX.
N * |        |          |Software can configure the TX channel setting by this field.
N * |        |          |The channel configuration is the same as SPI0_RXSEL (PDMA_PDSSR0[3:0]) field.
N * |        |          |Please refer to the explanation of SPI0_RXSEL (PDMA_PDSSR0[3:0]).
N * |[27:24] |SPI3_RXSEL|PDMA SPI3 RX Selection
N * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral SPI3 RX.
N * |        |          |Software can configure the RX channel setting by this field.
N * |        |          |The channel configuration is the same as SPI0_RXSEL (PDMA_PDSSR0[3:0]) field.
N * |        |          |Please refer to the explanation of SPI0_RXSEL (PDMA_PDSSR0[3:0]).
N * |[31:28] |SPI3_TXSEL|PDMA SPI3 TX Selection
N * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral SPI3 TX.
N * |        |          |Software can configure the TX channel setting by this field.
N * |        |          |The channel configuration is the same as SPI0_RXSEL (PDMA_PDSSR0[3:0]) field.
N * |        |          |Please refer to the explanation of SPI0_RXSEL (PDMA_PDSSR0[3:0]).
N * @var PDMA_GCR_T::PDSSR1
N * Offset: 0x08  PDMA Service Selection Control Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |UART0_RXSEL|PDMA UART0 RX Selection
N * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral UART0 RX.
N * |        |          |Software can change the channel RX setting by this field.
N * |        |          |For example, UART0_RXSEL (PDMA_PDSSR1[3:0]) = 0110, which means UART0_RX is connected to
N * |        |          |PDMA_CH6.
N * |        |          |0000: CH0
N * |        |          |0001: CH1
N * |        |          |0010: CH2
N * |        |          |0011: CH3
N * |        |          |0100: CH4
N * |        |          |0101: CH5
N * |        |          |0110: CH6
N * |        |          |0111: CH7
N * |        |          |1000: CH8
N * |        |          |Others : Reserved
N * |[7:4]   |UART0_TXSEL|PDMA UART0 TX Selection
N * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral UART0 TX.
N * |        |          |Software can configure the TX channel setting by this field.
N * |        |          |The channel configuration is the same as UART0_RXSEL (PDMA_PDSSR1[3:0]) field.
N * |        |          |Please refer to the explanation of UART0_RXSEL (PDMA_PDSSR1[3:0]).
N * |[11:8]  |UART1_RXSEL|PDMA UART1 RX Selection
N * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral UART1 RX.
N * |        |          |Software can configure the RX channel setting by this field.
N * |        |          |The channel configuration is the same as UART0_RXSEL (PDMA_PDSSR1[3:0]) field.
N * |        |          |Please refer to the explanation of UART0_RXSEL (PDMA_PDSSR1[3:0]).
N * |[15:12] |UART1_TXSEL|PDMA UART1 TX Selection
N * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral UART1 TX.
N * |        |          |Software can configure the TX channel setting by this field.
N * |        |          |The channel configuration is the same as UART0_RXSEL (PDMA_PDSSR1[3:0]) field.
N * |        |          |Please refer to the explanation of UART0_RXSEL (PDMA_PDSSR1[3:0]).
N * |[27:24] |ADC_RXSEL |PDMA ADC RX Selection
N * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral ADC RX.
N * |        |          |Software can configure the RX channel setting by this field.
N * |        |          |The channel configuration is the same as UART0_RXSEL (PDMA_PDSSR1[3:0]) field.
N * |        |          |Please refer to the explanation of UART0_RXSEL (PDMA_PDSSR1[3:0]).
N * @var PDMA_GCR_T::GCRISR
N * Offset: 0x0C  PDMA Global Interrupt Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |INTR0     |Interrupt Status Of Channel 0
N * |        |          |This bit is the interrupt status of PDMA channel0.
N * |        |          |Note: This bit is read only
N * |[1]     |INTR1     |Interrupt Status Of Channel 1
N * |        |          |This bit is the interrupt status of PDMA channel1.
N * |        |          |Note: This bit is read only
N * |[2]     |INTR2     |Interrupt Status Of Channel 2
N * |        |          |This bit is the interrupt status of PDMA channel2.
N * |        |          |Note: This bit is read only
N * |[3]     |INTR3     |Interrupt Status Of Channel 3
N * |        |          |This bit is the interrupt status of PDMA channel3.
N * |        |          |Note: This bit is read only
N * |[4]     |INTR4     |Interrupt Status Of Channel 4
N * |        |          |This bit is the interrupt status of PDMA channel4.
N * |        |          |Note: This bit is read only
N * |[5]     |INTR5     |Interrupt Status Of Channel 5
N * |        |          |This bit is the interrupt status of PDMA channel5.
N * |        |          |Note: This bit is read only
N * |[6]     |INTR6     |Interrupt Status Of Channel 6
N * |        |          |This bit is the interrupt status of PDMA channel6.
N * |        |          |Note: This bit is read only
N * |[7]     |INTR7     |Interrupt Status Of Channel 7
N * |        |          |This bit is the interrupt status of PDMA channel7.
N * |        |          |Note: This bit is read only
N * |[8]     |INTR8     |Interrupt Status Of Channel 8
N * |        |          |This bit is the interrupt status of PDMA channel8.
N * |        |          |Note: This bit is read only
N * |[16]    |INTRCRC   |Interrupt Status Of CRC Controller
N * |        |          |This bit is the interrupt status of CRC controller
N * |        |          |Note: This bit is read only
N * |[31]    |INTR      |Interrupt Status
N * |        |          |This bit is the interrupt status of PDMA controller.
N * |        |          |Note: This bit is read only
N * @var PDMA_GCR_T::PDSSR2
N * Offset: 0x10  PDMA Service Selection Control Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |I2S_RXSEL |PDMA I2S RX Selection
N * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral I2S RX.
N * |        |          |Software can change the channel RX setting by this field.
N * |        |          |For example: I2S_RXSEL (PDMA_PDSSR2[3:0]) = 0110, that means I2S_RX is connected to PDMA_CH6.
N * |        |          |0000: CH0
N * |        |          |0001: CH1
N * |        |          |0010: CH2
N * |        |          |0011: CH3
N * |        |          |0100: CH4
N * |        |          |0101: CH5
N * |        |          |0110: CH6
N * |        |          |0111: CH7
N * |        |          |1000: CH8
N * |        |          |Others : Reserved
N * |[7:4]   |I2S_TXSEL |PDMA I2S TX Selection
N * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral I2S TX.
N * |        |          |Software can configure the TX channel setting by this field.
N * |        |          |The channel configuration is the same as I2S_RXSEL (PDMA_PDSSR2[3:0]) field.
N * |        |          |Please refer to the explanation of I2S_RXSEL (PDMA_PDSSR2[3:0]).
N */
N
N    __IO uint32_t GCRCSR;        /* Offset: 0x00  PDMA Global Control Register                                       */
X    volatile uint32_t GCRCSR;         
N    __IO uint32_t PDSSR0;        /* Offset: 0x04  PDMA Service Selection Control Register 0                          */
X    volatile uint32_t PDSSR0;         
N    __IO uint32_t PDSSR1;        /* Offset: 0x08  PDMA Service Selection Control Register 1                          */
X    volatile uint32_t PDSSR1;         
N    __IO uint32_t GCRISR;        /* Offset: 0x0C  PDMA Global Interrupt Status Register                              */
X    volatile uint32_t GCRISR;         
N    __IO uint32_t PDSSR2;        /* Offset: 0x10  PDMA Service Selection Control Register 2                          */
X    volatile uint32_t PDSSR2;         
N
N} PDMA_GCR_T;
N
N
N
N/**
N    @addtogroup PDMA_CONST PDMA Bit Field Definition
N    Constant Definitions for GPIO Controller
N@{ */
N
N
N/* PDMA CSR Bit Field Definitions */
N#define PDMA_CSR_TRIG_EN_Pos                        23                              /*!< PDMA_T::CSR: TRIG_EN Position */
N#define PDMA_CSR_TRIG_EN_Msk                        (1ul << PDMA_CSR_TRIG_EN_Pos)   /*!< PDMA_T::CSR: TRIG_EN Mask */
N
N#define PDMA_CSR_APB_TWS_Pos                        19                              /*!< PDMA_T::CSR: APB_TWS Position */
N#define PDMA_CSR_APB_TWS_Msk                        (3ul << PDMA_CSR_APB_TWS_Pos)   /*!< PDMA_T::CSR: APB_TWS Mask */
N
N#define PDMA_CSR_DAD_SEL_Pos                        6                               /*!< PDMA_T::CSR: DAD_SEL Position */
N#define PDMA_CSR_DAD_SEL_Msk                        (3ul << PDMA_CSR_DAD_SEL_Pos)   /*!< PDMA_T::CSR: DAD_SEL Mask */
N
N#define PDMA_CSR_SAD_SEL_Pos                        4                               /*!< PDMA_T::CSR: SAD_SEL Position */
N#define PDMA_CSR_SAD_SEL_Msk                        (3ul << PDMA_CSR_SAD_SEL_Pos)   /*!< PDMA_T::CSR: SAD_SEL Mask */
N
N#define PDMA_CSR_MODE_SEL_Pos                       2                               /*!< PDMA_T::CSR: MODE_SEL Position */
N#define PDMA_CSR_MODE_SEL_Msk                       (3ul << PDMA_CSR_MODE_SEL_Pos)  /*!< PDMA_T::CSR: MODE_SEL Mask */
N
N#define PDMA_CSR_SW_RST_Pos                         1                               /*!< PDMA_T::CSR: SW_RST Position */
N#define PDMA_CSR_SW_RST_Msk                         (1ul << PDMA_CSR_SW_RST_Pos)    /*!< PDMA_T::CSR: SW_RST Mask */
N
N#define PDMA_CSR_PDMACEN_Pos                        0                               /*!< PDMA_T::CSR: PDMACEN Position */
N#define PDMA_CSR_PDMACEN_Msk                        (1ul << PDMA_CSR_PDMACEN_Pos)   /*!< PDMA_T::CSR: PDMACEN Mask */
N
N/* PDMA BCR Bit Field Definitions */
N#define PDMA_BCR_BCR_Pos                            0                               /*!< PDMA_T::BCR: BCR Position */
N#define PDMA_BCR_BCR_Msk                            (0xFFFFul << PDMA_BCR_BCR_Pos)  /*!< PDMA_T::BCR: BCR Mask */
N
N/* PDMA POINT Bit Field Definitions */
N#define PDMA_POINT_POINT_Pos                        0                               /*!< PDMA_T::POINT: POINT Position */
N#define PDMA_POINT_POINT_Msk                        (0xFul << PDMA_POINT_POINT_Pos) /*!< PDMA_T::POINT: POINT Mask */
N
N/* PDMA CBCR Bit Field Definitions */
N#define PDMA_CBCR_CBCR_Pos                          0                                   /*!< PDMA_T::CBCR: CBCR Position */
N#define PDMA_CBCR_CBCR_Msk                          (0xFFFFul << PDMA_CBCR_CBCR_Pos)    /*!< PDMA_T::CBCR: CBCR Mask */
N
N
N/* PDMA IER Bit Field Definitions */
N#define PDMA_IER_BLKD_IE_Pos                        1                               /*!< PDMA_T::IER: BLKD_IE Position */
N#define PDMA_IER_BLKD_IE_Msk                        (1ul << PDMA_IER_BLKD_IE_Pos)   /*!< PDMA_T::IER: BLKD_IE Mask */
N
N#define PDMA_IER_TABORT_IE_Pos                      0                               /*!< PDMA_T::IER: TABORT_IE Position */
N#define PDMA_IER_TABORT_IE_Msk                      (1ul << PDMA_IER_TABORT_IE_Pos) /*!< PDMA_T::IER: TABORT_IE Mask */
N
N/* PDMA ISR Bit Field Definitions */
N#define PDMA_ISR_BLKD_IF_Pos                        1                               /*!< PDMA_T::ISR: BLKD_IF Position */
N#define PDMA_ISR_BLKD_IF_Msk                        (1ul << PDMA_ISR_BLKD_IF_Pos)   /*!< PDMA_T::ISR: BLKD_IF Mask */
N
N#define PDMA_ISR_TABORT_IF_Pos                      0                               /*!< PDMA_T::ISR: TABORT_IF Position */
N#define PDMA_ISR_TABORT_IF_Msk                      (1ul << PDMA_ISR_TABORT_IF_Pos) /*!< PDMA_T::ISR: TABORT_IF Mask */
N
N/* PDMA GCRCSR Bit Field Definitions */
N#define PDMA_GCRCSR_CRC_CLK_EN_Pos                  24                                  /*!< PDMA_GCR_T::GCRCSR: CRC_CLK_EN Position */
N#define PDMA_GCRCSR_CRC_CLK_EN_Msk                  (1ul << PDMA_GCRCSR_CRC_CLK_EN_Pos) /*!< PDMA_GCR_T::GCRCSR: CRC_CLK_EN Mask */
N
N#define PDMA_GCRCSR_CLK8_EN_Pos                     16                                  /*!< PDMA_GCR_T::GCRCSR: CLK8_EN Position */
N#define PDMA_GCRCSR_CLK8_EN_Msk                     (1ul << PDMA_GCRCSR_CLK8_EN_Pos)    /*!< PDMA_GCR_T::GCRCSR: CLK8_EN Mask */
N
N#define PDMA_GCRCSR_CLK7_EN_Pos                     15                                  /*!< PDMA_GCR_T::GCRCSR: CLK7_EN Position */
N#define PDMA_GCRCSR_CLK7_EN_Msk                     (1ul << PDMA_GCRCSR_CLK7_EN_Pos)    /*!< PDMA_GCR_T::GCRCSR: CLK7_EN Mask */
N
N#define PDMA_GCRCSR_CLK6_EN_Pos                     14                                  /*!< PDMA_GCR_T::GCRCSR: CLK6_EN Position */
N#define PDMA_GCRCSR_CLK6_EN_Msk                     (1ul << PDMA_GCRCSR_CLK6_EN_Pos)    /*!< PDMA_GCR_T::GCRCSR: CLK6_EN Mask */
N
N#define PDMA_GCRCSR_CLK5_EN_Pos                     13                                  /*!< PDMA_GCR_T::GCRCSR: CLK5_EN Position */
N#define PDMA_GCRCSR_CLK5_EN_Msk                     (1ul << PDMA_GCRCSR_CLK5_EN_Pos)    /*!< PDMA_GCR_T::GCRCSR: CLK5_EN Mask */
N
N#define PDMA_GCRCSR_CLK4_EN_Pos                     12                                  /*!< PDMA_GCR_T::GCRCSR: CLK4_EN Position */
N#define PDMA_GCRCSR_CLK4_EN_Msk                     (1ul << PDMA_GCRCSR_CLK4_EN_Pos)    /*!< PDMA_GCR_T::GCRCSR: CLK4_EN Mask */
N
N#define PDMA_GCRCSR_CLK3_EN_Pos                     11                                  /*!< PDMA_GCR_T::GCRCSR: CLK3_EN Position */
N#define PDMA_GCRCSR_CLK3_EN_Msk                     (1ul << PDMA_GCRCSR_CLK3_EN_Pos)    /*!< PDMA_GCR_T::GCRCSR: CLK3_EN Mask */
N
N#define PDMA_GCRCSR_CLK2_EN_Pos                     10                                  /*!< PDMA_GCR_T::GCRCSR: CLK2_EN Position */
N#define PDMA_GCRCSR_CLK2_EN_Msk                     (1ul << PDMA_GCRCSR_CLK2_EN_Pos)    /*!< PDMA_GCR_T::GCRCSR: CLK2_EN Mask */
N
N#define PDMA_GCRCSR_CLK1_EN_Pos                     9                                   /*!< PDMA_GCR_T::GCRCSR: CLK1_EN Position */
N#define PDMA_GCRCSR_CLK1_EN_Msk                     (1ul << PDMA_GCRCSR_CLK1_EN_Pos)    /*!< PDMA_GCR_T::GCRCSR: CLK1_EN Mask */
N
N#define PDMA_GCRCSR_CLK0_EN_Pos                     8                                   /*!< PDMA_GCR_T::GCRCSR: CLK0_EN Position */
N#define PDMA_GCRCSR_CLK0_EN_Msk                     (1ul << PDMA_GCRCSR_CLK0_EN_Pos)    /*!< PDMA_GCR_T::GCRCSR: CLK0_EN Mask */
N
N/* PDMA PDSSR0 Bit Field Definitions */
N#define PDMA_PDSSR0_SPI3_TXSEL_Pos                  28                                      /*!< PDMA_GCR_T::PDSSR0: SPI3_TXSEL Position */
N#define PDMA_PDSSR0_SPI3_TXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI3_TXSEL_Pos)   /*!< PDMA_GCR_T::PDSSR0: SPI3_TXSEL Mask */
N
N#define PDMA_PDSSR0_SPI3_RXSEL_Pos                  24                                      /*!< PDMA_GCR_T::PDSSR0: SPI3_RXSEL Position */
N#define PDMA_PDSSR0_SPI3_RXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI3_RXSEL_Pos)   /*!< PDMA_GCR_T::PDSSR0: SPI3_RXSEL Mask */
N
N#define PDMA_PDSSR0_SPI2_TXSEL_Pos                  20                                      /*!< PDMA_GCR_T::PDSSR0: SPI2_TXSEL Position */
N#define PDMA_PDSSR0_SPI2_TXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI2_TXSEL_Pos)   /*!< PDMA_GCR_T::PDSSR0: SPI2_TXSEL Mask */
N
N#define PDMA_PDSSR0_SPI2_RXSEL_Pos                  16                                      /*!< PDMA_GCR_T::PDSSR0: SPI2_RXSEL Position */
N#define PDMA_PDSSR0_SPI2_RXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI2_RXSEL_Pos)   /*!< PDMA_GCR_T::PDSSR0: SPI2_RXSEL Mask */
N
N#define PDMA_PDSSR0_SPI1_TXSEL_Pos                  12                                      /*!< PDMA_GCR_T::PDSSR0: SPI1_TXSEL Position */
N#define PDMA_PDSSR0_SPI1_TXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI1_TXSEL_Pos)   /*!< PDMA_GCR_T::PDSSR0: SPI1_TXSEL Mask */
N
N#define PDMA_PDSSR0_SPI1_RXSEL_Pos                  8                                       /*!< PDMA_GCR_T::PDSSR0: SPI1_RXSEL Position */
N#define PDMA_PDSSR0_SPI1_RXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI1_RXSEL_Pos)   /*!< PDMA_GCR_T::PDSSR0: SPI1_RXSEL Mask */
N
N#define PDMA_PDSSR0_SPI0_TXSEL_Pos                  4                                       /*!< PDMA_GCR_T::PDSSR0: SPI0_TXSEL Position */
N#define PDMA_PDSSR0_SPI0_TXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI0_TXSEL_Pos)   /*!< PDMA_GCR_T::PDSSR0: SPI0_TXSEL Mask */
N
N#define PDMA_PDSSR0_SPI0_RXSEL_Pos                  0                                       /*!< PDMA_GCR_T::PDSSR0: SPI0_RXSEL Position */
N#define PDMA_PDSSR0_SPI0_RXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI0_RXSEL_Pos)   /*!< PDMA_GCR_T::PDSSR0: SPI0_RXSEL Mask */
N
N/* PDMA PDSSR1 Bit Field Definitions */
N#define PDMA_PDSSR1_ADC_RXSEL_Pos                   24                                      /*!< PDMA_GCR_T::PDSSR1: ADC_RXSEL Position */
N#define PDMA_PDSSR1_ADC_RXSEL_Msk                   (0xFul << PDMA_PDSSR1_ADC_RXSEL_Pos)    /*!< PDMA_GCR_T::PDSSR1: ADC_RXSEL Mask */
N
N#define PDMA_PDSSR1_UART1_TXSEL_Pos                 12                                      /*!< PDMA_GCR_T::PDSSR1: UART1_TXSEL Position */
N#define PDMA_PDSSR1_UART1_TXSEL_Msk                 (0xFul << PDMA_PDSSR1_UART1_TXSEL_Pos)  /*!< PDMA_GCR_T::PDSSR1: UART1_TXSEL Mask */
N
N#define PDMA_PDSSR1_UART1_RXSEL_Pos                 8                                       /*!< PDMA_GCR_T::PDSSR1: UART1_RXSEL Position */
N#define PDMA_PDSSR1_UART1_RXSEL_Msk                 (0xFul << PDMA_PDSSR1_UART1_RXSEL_Pos)  /*!< PDMA_GCR_T::PDSSR1: UART1_RXSEL Mask */
N
N#define PDMA_PDSSR1_UART0_TXSEL_Pos                 4                                       /*!< PDMA_GCR_T::PDSSR1: UART0_TXSEL Position */
N#define PDMA_PDSSR1_UART0_TXSEL_Msk                 (0xFul << PDMA_PDSSR1_UART0_TXSEL_Pos)  /*!< PDMA_GCR_T::PDSSR1: UART0_TXSEL Mask */
N
N#define PDMA_PDSSR1_UART0_RXSEL_Pos                 0                                       /*!< PDMA_GCR_T::PDSSR1: UART0_RXSEL Position */
N#define PDMA_PDSSR1_UART0_RXSEL_Msk                 (0xFul << PDMA_PDSSR1_UART0_RXSEL_Pos)  /*!< PDMA_GCR_T::PDSSR1: UART0_RXSEL Mask */
N
N/* PDMA GCRISR Bit Field Definitions */
N#define PDMA_GCRISR_INTR_Pos                        31                              /*!< PDMA_GCR_T::GCRISR: INTR Position */
N#define PDMA_GCRISR_INTR_Msk                        (1ul << PDMA_GCRISR_INTR_Pos)   /*!< PDMA_GCR_T::GCRISR: INTR Mask */
N
N#define PDMA_GCRISR_INTRCRC_Pos                     16                               /*!< PDMA_GCR_T::GCRISR: INTRCRC Position */
N#define PDMA_GCRISR_INTRCRC_Msk                     (1ul << PDMA_GCRISR_INTRCRC_Pos) /*!< PDMA_GCR_T::GCRISR: INTRCRC Mask */
N
N#define PDMA_GCRISR_INTR8_Pos                       8                               /*!< PDMA_GCR_T::GCRISR: INTR8 Position */
N#define PDMA_GCRISR_INTR8_Msk                       (1ul << PDMA_GCRISR_INTR8_Pos)  /*!< PDMA_GCR_T::GCRISR: INTR8 Mask */
N
N#define PDMA_GCRISR_INTR7_Pos                       7                               /*!< PDMA_GCR_T::GCRISR: INTR7 Position */
N#define PDMA_GCRISR_INTR7_Msk                       (1ul << PDMA_GCRISR_INTR7_Pos)  /*!< PDMA_GCR_T::GCRISR: INTR7 Mask */
N
N#define PDMA_GCRISR_INTR6_Pos                       6                               /*!< PDMA_GCR_T::GCRISR: INTR6 Position */
N#define PDMA_GCRISR_INTR6_Msk                       (1ul << PDMA_GCRISR_INTR6_Pos)  /*!< PDMA_GCR_T::GCRISR: INTR6 Mask */
N
N#define PDMA_GCRISR_INTR5_Pos                       5                               /*!< PDMA_GCR_T::GCRISR: INTR5 Position */
N#define PDMA_GCRISR_INTR5_Msk                       (1ul << PDMA_GCRISR_INTR5_Pos)  /*!< PDMA_GCR_T::GCRISR: INTR5 Mask */
N
N#define PDMA_GCRISR_INTR4_Pos                       4                               /*!< PDMA_GCR_T::GCRISR: INTR4 Position */
N#define PDMA_GCRISR_INTR4_Msk                       (1ul << PDMA_GCRISR_INTR4_Pos)  /*!< PDMA_GCR_T::GCRISR: INTR4 Mask */
N
N#define PDMA_GCRISR_INTR3_Pos                       3                               /*!< PDMA_GCR_T::GCRISR: INTR3 Position */
N#define PDMA_GCRISR_INTR3_Msk                       (1ul << PDMA_GCRISR_INTR3_Pos)  /*!< PDMA_GCR_T::GCRISR: INTR3 Mask */
N
N#define PDMA_GCRISR_INTR2_Pos                       2                               /*!< PDMA_GCR_T::GCRISR: INTR2 Position */
N#define PDMA_GCRISR_INTR2_Msk                       (1ul << PDMA_GCRISR_INTR2_Pos)  /*!< PDMA_GCR_T::GCRISR: INTR2 Mask */
N
N#define PDMA_GCRISR_INTR1_Pos                       1                               /*!< PDMA_GCR_T::GCRISR: INTR1 Position */
N#define PDMA_GCRISR_INTR1_Msk                       (1ul << PDMA_GCRISR_INTR1_Pos)  /*!< PDMA_GCR_T::GCRISR: INTR1 Mask */
N
N#define PDMA_GCRISR_INTR0_Pos                       0                               /*!< PDMA_GCR_T::GCRISR: INTR0 Position */
N#define PDMA_GCRISR_INTR0_Msk                       (1ul << PDMA_GCRISR_INTR0_Pos)  /*!< PDMA_GCR_T::GCRISR: INTR0 Mask */
N
N/* PDMA PDSSR2 Bit Field Definitions */
N#define PDMA_PDSSR2_I2S_TXSEL_Pos                   4                                       /*!< PDMA_GCR_T::PDSSR2: I2S_TXSEL Position */
N#define PDMA_PDSSR2_I2S_TXSEL_Msk                   (0xFul << PDMA_PDSSR2_I2S_TXSEL_Pos)    /*!< PDMA_GCR_T::PDSSR2: I2S_TXSEL Mask */
N
N#define PDMA_PDSSR2_I2S_RXSEL_Pos                   0                                       /*!< PDMA_GCR_T::PDSSR2: I2S_RXSEL Position */
N#define PDMA_PDSSR2_I2S_RXSEL_Msk                   (0xFul << PDMA_PDSSR2_I2S_RXSEL_Pos)    /*!< PDMA_GCR_T::PDSSR2: I2S_RXSEL Mask */
N/*@}*/ /* end of group PDMA_CONST */
N/*@}*/ /* end of group DMA */
N
N
N/*------------------------------ PS2 Controller ------------------------------*/
N/** @addtogroup PS2 PS2 Serial Interface(PS2)
N  Memory Mapped Structure for PS2 Serial Interface Controller
N  @{
N */
N
N
Ntypedef struct
N{
N
N
N/**
N * @var PS2_T::PS2CON
N * Offset: 0x00  PS/2 Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |PS2EN     |Enable PS/2 Device
N * |        |          |Enable PS/2 device controller
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[1]     |TXINTEN   |Enable Transmit Interrupt
N * |        |          |0 = Data transmit complete interrupt Disabled.
N * |        |          |1 = Data transmit complete interrupt Enabled.
N * |[2]     |RXINTEN   |Enable Receive Interrupt
N * |        |          |0 = Data receive complete interrupt Disabled.
N * |        |          |1 = Data receive complete interrupt Enabled.
N * |[6:3]   |TXFIFO_DEPTH|Transmit Data FIFO Depth
N * |        |          |There are 16 bytes buffer for data transmit.
N * |        |          |Software can define the FIFO depth from 1 to 16 bytes depends on application needs.
N * |        |          |0 = 1 byte.
N * |        |          |1 = 2 bytes.
N * |        |          |...
N * |        |          |14 = 15 bytes.
N * |        |          |15 = 16 bytes.
N * |[7]     |ACK       |Acknowledge Enable
N * |        |          |0 = Always send acknowledge to host at 12th clock for host to device communication.
N * |        |          |1 = If parity bit error or stop bit is not received correctly, acknowledge bit will not be sent
N * |        |          |to host at 12th clock.
N * |[8]     |CLRFIFO   |Clear TX FIFO
N * |        |          |Write 1 to this bit to terminate device to host transmission.
N * |        |          |The TXEMPTY(PS2STATUS[7]) bit will be set to 1 and pointer BYTEIDEX(PS2STATUS[11:8]) is reset to
N * |        |          |0 regardless there is residue data in buffer or not.
N * |        |          |The buffer content is not been cleared.
N * |        |          |0 = Not active.
N * |        |          |1 = Clear FIFO.
N * |[9]     |OVERRIDE  |Software Override PS/2 CLK/DATA Pin State
N * |        |          |0 = PS2_CLK and PS2_DATA pins are controlled by internal state machine.
N * |        |          |1 = PS2_CLK and PS2_DATA pins are controlled by software.
N * |[10]    |FPS2CLK   |Force PS2CLK Line
N * |        |          |It forces PS2_CLK line high or low regardless of the internal state of the device controller if
N * |        |          |OVERRIDE(PS2CON[9]) is set to 1.
N * |        |          |0 = Force PS2_CLK line low.
N * |        |          |1 = Force PS2_CLK line high.
N * |[11]    |FPS2DAT   |Force PS2DATA Line
N * |        |          |It forces PS2_DATA high or low regardless of the internal state of the device controller if
N * |        |          |OVERRIDE (PS2CON[9]) is set to 1.
N * |        |          |0 = Force PS2_DATA low.
N * |        |          |1 = Force PS2_DATA high.
N * @var PS2_T::PS2TXDATA0
N * Offset: 0x04  PS/2 Transmit Data Register 0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |PS2TXDATAx|Transmit Data
N * |        |          |Writing data to this register starts in device to host communication if bus is in IDLE state.
N * |        |          |Software must enable PS2EN(PS2CON[0]) before writing data to TX buffer.
N * @var PS2_T::PS2TXDATA1
N * Offset: 0x08  PS/2 Transmit Data Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |PS2TXDATAx|Transmit Data
N * |        |          |Writing data to this register starts in device to host communication if bus is in IDLE state.
N * |        |          |Software must enable PS2EN(PS2CON[0]) before writing data to TX buffer.
N * @var PS2_T::PS2TXDATA2
N * Offset: 0x0C  PS/2 Transmit Data Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |PS2TXDATAx|Transmit Data
N * |        |          |Writing data to this register starts in device to host communication if bus is in IDLE state.
N * |        |          |Software must enable PS2EN(PS2CON[0]) before writing data to TX buffer.
N * @var PS2_T::PS2TXDATA3
N * Offset: 0x10  PS/2 Transmit Data Register 3
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |PS2TXDATAx|Transmit Data
N * |        |          |Writing data to this register starts in device to host communication if bus is in IDLE state.
N * |        |          |Software must enable PS2EN(PS2CON[0]) before writing data to TX buffer.
N * @var PS2_T::PS2RXDATA
N * Offset: 0x14  PS/2 Receive Data Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |RXDATA    |Received Data
N * |        |          |For host to device communication, after acknowledge bit is sent, the received data is copied
N * |        |          |from receive shift register to PS2RXDATA register.
N * |        |          |CPU must read this register before next byte reception complete, otherwise the data will be
N * |        |          |overwritten and RXOVF(PS2STATUS[6]) bit will be set to 1.
N * @var PS2_T::PS2STATUS
N * Offset: 0x18  PS/2 Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |PS2CLK    |CLK Pin State
N * |        |          |This bit reflects the status of the PS2_CLK line after synchronizing.
N * |[1]     |PS2DATA   |DATA Pin State
N * |        |          |This bit reflects the status of the PS2_DATA line after synchronizing and sampling.
N * |[2]     |FRAMERR   |Frame Error
N * |        |          |For host to device communication, this bit sets to 1 if STOP bit (logic 1) is not received.
N * |        |          |If frame error occurs, the PS/2_DATA line may keep at low state after 12th clock.
N * |        |          |At this moment, software overrides PS2_CLK to send clock till PS2_DATA release to high state.
N * |        |          |After that, device sends a "Resend" command to host.
N * |        |          |0 = No frame error.
N * |        |          |1 = Frame error occur.
N * |        |          |Write 1 to clear this bit.
N * |[3]     |RXPARITY  |Received Parity
N * |        |          |This bit reflects the parity bit for the last received data byte (odd parity).
N * |        |          |This bit is read only.
N * |[4]     |RXBUSY    |Receive Busy
N * |        |          |This bit indicates that the PS/2 device is currently receiving data.
N * |        |          |0 = Idle.
N * |        |          |1 = Currently receiving data.
N * |        |          |This bit is read only.
N * |[5]     |TXBUSY    |Transmit Busy
N * |        |          |This bit indicates that the PS/2 device is currently sending data.
N * |        |          |0 = Idle.
N * |        |          |1 = Currently sending data.
N * |        |          |This bit is read only.
N * |[6]     |RXOVF     |RX Buffer Overwrite
N * |        |          |0 = No overwrite.
N * |        |          |1 = Data in PS2RXDATA register is overwritten by new received data.
N * |        |          |Write 1 to clear this bit.
N * |[7]     |TXEMPTY   |TX FIFO Empty
N * |        |          |When software writes data to PS2TXDATA0-3, the TXEMPTY bit is cleared to 0 immediately if
N * |        |          |PS2EN(PS2CON[0]) is enabled.
N * |        |          |When transmitted data byte number is equal to FIFODEPTH(PS2CON[6:3]) then TXEMPTY bit is set to
N * |        |          |1.
N * |        |          |0 = There is data to be transmitted.
N * |        |          |1 = FIFO is empty.
N * |        |          |This bit is read only.
N * |[11:8]  |BYTEIDX   |Byte Index
N * |        |          |It indicates which data byte in transmit data shift register.
N * |        |          |When all data in FIFO is transmitted and it will be cleared to 0.
N * |        |          |This bit is read only.
N * |        |          |BYTEIDX,    DATA Transmit , BYTEIDX,    DATA Transmit
N * |        |          |0000   , PS2TXDATA0[ 7: 0], 1000   , PS2TXDATA2[ 7: 0],
N * |        |          |0001   , PS2TXDATA0[15: 8], 1001   , PS2TXDATA2[15: 8],
N * |        |          |0010   , PS2TXDATA0[23:16], 1010   , PS2TXDATA2[23:16],
N * |        |          |0011   , PS2TXDATA0[31:24], 1011   , PS2TXDATA2[31:24],
N * |        |          |0100   , PS2TXDATA1[ 7: 0], 1100   , PS2TXDATA3[ 7: 0],
N * |        |          |0101   , PS2TXDATA1[15: 8], 1101   , PS2TXDATA3[15: 8],
N * |        |          |0110   , PS2TXDATA1[23:16], 1110   , PS2TXDATA3[23:16],
N * |        |          |0111   , PS2TXDATA1[31:24], 1111   , PS2TXDATA3[31:24],
N * @var PS2_T::PS2INTID
N * Offset: 0x1C  PS/2 Interrupt Identification Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |RXINT     |Receive Interrupt
N * |        |          |This bit is set to 1 when acknowledge bit is sent for Host to device communication.
N * |        |          |Interrupt occurs if RXINTEN(PS2CON[2]) bit is set to 1.
N * |        |          |0 = No interrupt.
N * |        |          |1 = Receive interrupt occurs.
N * |        |          |Write 1 to clear this bit to 0.
N * |[1]     |TXINT     |Transmit Interrupt
N * |        |          |This bit is set to 1 after STOP bit is transmitted.
N * |        |          |Interrupt occur if TXINTEN(PS2CON[1]) bit is set to 1.
N * |        |          |0 = No interrupt.
N * |        |          |1 = Transmit interrupt occurs.
N * |        |          |Write 1 to clear this bit to 0.
N */
N
N    __IO uint32_t PS2CON;        /* Offset: 0x00  PS/2 Control Register                                              */
X    volatile uint32_t PS2CON;         
N    __IO uint32_t PS2TXDATA0;    /* Offset: 0x04  PS/2 Transmit Data Register 0                                      */
X    volatile uint32_t PS2TXDATA0;     
N    __IO uint32_t PS2TXDATA1;    /* Offset: 0x08  PS/2 Transmit Data Register 1                                      */
X    volatile uint32_t PS2TXDATA1;     
N    __IO uint32_t PS2TXDATA2;    /* Offset: 0x0C  PS/2 Transmit Data Register 2                                      */
X    volatile uint32_t PS2TXDATA2;     
N    __IO uint32_t PS2TXDATA3;    /* Offset: 0x10  PS/2 Transmit Data Register 3                                      */
X    volatile uint32_t PS2TXDATA3;     
N    __IO uint32_t PS2RXDATA;     /* Offset: 0x14  PS/2 Receive Data Register                                         */
X    volatile uint32_t PS2RXDATA;      
N    __IO uint32_t PS2STATUS;     /* Offset: 0x18  PS/2 Status Register                                               */
X    volatile uint32_t PS2STATUS;      
N    __IO uint32_t PS2INTID;      /* Offset: 0x1C  PS/2 Interrupt Identification Register                             */
X    volatile uint32_t PS2INTID;       
N
N} PS2_T;
N
N
N
N/**
N    @addtogroup PS2_CONST PS2 Bit Field Definition
N    Constant Definitions for PS2 Controller
N@{ */
N
N
N/* PS2 PS2CON Bit Field Definitions */
N#define PS2_PS2CON_PS2EN_Pos                       0                                        /*!< PS2_T::PS2CON: PS2EN Position */
N#define PS2_PS2CON_PS2EN_Msk                       (1ul << PS2_PS2CON_PS2EN_Pos)            /*!< PS2_T::PS2CON: PS2EN Mask */
N
N#define PS2_PS2CON_TXINTEN_Pos                     1                                        /*!< PS2_T::PS2CON: TXINTEN Position */
N#define PS2_PS2CON_TXINTEN_Msk                     (1ul << PS2_PS2CON_TXINTEN_Pos)          /*!< PS2_T::PS2CON: TXINTEN Mask */
N
N#define PS2_PS2CON_RXINTEN_Pos                     2                                        /*!< PS2_T::PS2CON: RXINTEN Position */
N#define PS2_PS2CON_RXINTEN_Msk                     (1ul << PS2_PS2CON_RXINTEN_Pos)          /*!< PS2_T::PS2CON: RXINTEN Mask */
N
N#define PS2_PS2CON_TXFIFO_DEPTH_Pos                3                                        /*!< PS2_T::PS2CON: TXFIFO_DEPTH Position */
N#define PS2_PS2CON_TXFIFO_DEPTH_Msk                (0xFul << PS2_PS2CON_TXFIFO_DEPTH_Pos)   /*!< PS2_T::PS2CON: TXFIFO_DEPTH Mask */
N
N#define PS2_PS2CON_ACK_Pos                         7                                        /*!< PS2_T::PS2CON: ACK Position */
N#define PS2_PS2CON_ACK_Msk                         (1ul << PS2_PS2CON_ACK_Pos)              /*!< PS2_T::PS2CON: ACK Mask */
N
N#define PS2_PS2CON_CLRFIFO_Pos                     8                                        /*!< PS2_T::PS2CON: CLRFIFO Position */
N#define PS2_PS2CON_CLRFIFO_Msk                     (1ul << PS2_PS2CON_CLRFIFO_Pos)          /*!< PS2_T::PS2CON: CLRFIFO Mask */
N
N#define PS2_PS2CON_OVERRIDE_Pos                    9                                        /*!< PS2_T::PS2CON: OVERRIDE Position */
N#define PS2_PS2CON_OVERRIDE_Msk                    (1ul << PS2_PS2CON_OVERRIDE_Pos)         /*!< PS2_T::PS2CON: OVERRIDE Mask */
N
N#define PS2_PS2CON_FPS2CLK_Pos                     10                                       /*!< PS2_T::PS2CON: FPS2CLK Position */
N#define PS2_PS2CON_FPS2CLK_Msk                     (1ul << PS2_PS2CON_FPS2CLK_Pos)          /*!< PS2_T::PS2CON: FPS2CLK Mask */
N
N#define PS2_PS2CON_FPS2DAT_Pos                     11                                       /*!< PS2_T::PS2CON: FPS2DAT Position */
N#define PS2_PS2CON_FPS2DAT_Msk                     (1ul << PS2_PS2CON_FPS2DAT_Pos)          /*!< PS2_T::PS2CON: FPS2DAT Mask */
N
N/* PS/2 PS2RXDATA Bit Field Definitions */
N#define PS2_PS2RXDATA_RXDATA_Pos                   0                                        /*!< PS2_T::PS2RXDATA: RXDATA Position */
N#define PS2_PS2RXDATA_RXDATA_Msk                   (0xFFul << PS2_PS2RXDATA_RXDATA_Pos)     /*!< PS2_T::PS2RXDATA: RXDATA Mask */
N
N/* PS/2 PS2STATUS Bit Field Definitions */
N#define PS2_PS2STATUS_PS2CLK_Pos                   0                                        /*!< PS2_T::PS2STATUS: PS2CLK Position */
N#define PS2_PS2STATUS_PS2CLK_Msk                   (1ul << PS2_PS2STATUS_PS2CLK_Pos)        /*!< PS2_T::PS2STATUS: PS2CLK Mask */
N
N#define PS2_PS2STATUS_PS2DATA_Pos                  1                                        /*!< PS2_T::PS2STATUS: PS2DATA Position */
N#define PS2_PS2STATUS_PS2DATA_Msk                  (1ul << PS2_PS2STATUS_PS2DATA_Pos)       /*!< PS2_T::PS2STATUS: PS2DATA Mask */
N
N#define PS2_PS2STATUS_FRAMERR_Pos                  2                                        /*!< PS2_T::PS2STATUS: FRAMERR Position */
N#define PS2_PS2STATUS_FRAMERR_Msk                  (1ul << PS2_PS2STATUS_FRAMERR_Pos)       /*!< PS2_T::PS2STATUS: FRAMERR Mask */
N
N#define PS2_PS2STATUS_RXPARITY_Pos                 3                                        /*!< PS2_T::PS2STATUS: RXPARITY Position */
N#define PS2_PS2STATUS_RXPARITY_Msk                 (1ul << PS2_PS2STATUS_RXPARITY_Pos)      /*!< PS2_T::PS2STATUS: RXPARITY Mask */
N
N#define PS2_PS2STATUS_RXBUSY_Pos                   4                                        /*!< PS2_T::PS2STATUS: RXBUSY Position */
N#define PS2_PS2STATUS_RXBUSY_Msk                   (1ul << PS2_PS2STATUS_RXBUSY_Pos)        /*!< PS2_T::PS2STATUS: RXBUSY Mask */
N
N#define PS2_PS2STATUS_TXBUSY_Pos                   5                                        /*!< PS2_T::PS2STATUS: TXBUSY Position */
N#define PS2_PS2STATUS_TXBUSY_Msk                   (1ul << PS2_PS2STATUS_TXBUSY_Pos)        /*!< PS2_T::PS2STATUS: TXBUSY Mask */
N
N#define PS2_PS2STATUS_RXOVF_Pos                    6                                        /*!< PS2_T::PS2STATUS: RXOVF Position */
N#define PS2_PS2STATUS_RXOVF_Msk                    (1ul << PS2_PS2STATUS_RXOVF_Pos)         /*!< PS2_T::PS2STATUS: RXOVF Mask */
N
N#define PS2_PS2STATUS_TXEMPTY_Pos                  7                                        /*!< PS2_T::PS2STATUS: TXEMPTY Position */
N#define PS2_PS2STATUS_TXEMPTY_Msk                  (1ul << PS2_PS2STATUS_TXEMPTY_Pos)       /*!< PS2_T::PS2STATUS: TXEMPTY Mask */
N
N#define PS2_PS2STATUS_BYTEIDX_Pos                  8                                        /*!< PS2_T::PS2STATUS: BYTEIDX Position */
N#define PS2_PS2STATUS_BYTEIDX_Msk                  (0xFul << PS2_PS2STATUS_BYTEIDX_Pos)     /*!< PS2_T::PS2STATUS: BYTEIDX Mask */
N
N/* PS/2 PS2INTID Bit Field Definitions */
N#define PS2_PS2INTID_RXINT_Pos                     0                                        /*!< PS2_T::PS2INTID: RXINT Position */
N#define PS2_PS2INTID_RXINT_Msk                     (1ul << PS2_PS2INTID_RXINT_Pos)          /*!< PS2_T::PS2INTID: RXINT Mask */
N
N#define PS2_PS2INTID_TXINT_Pos                     1                                        /*!< PS2_T::PS2INTID: TXINT Position */
N#define PS2_PS2INTID_TXINT_Msk                     (1ul << PS2_PS2INTID_TXINT_Pos)          /*!< PS2_T::PS2INTID: TXINT Mask */
N/*@}*/ /* end of group PS2_CONST */
N/*@}*/ /* end of group PS2 */
N
N
N/*---------------------- Pulse Width Modulation Controller -------------------------*/
N/**
N    @addtogroup PWM Pulse Width Modulation Controller (PWM)
N    Memory Mapped Structure for PWM Controller
N@{ */
N
N
N
Ntypedef struct
N{
N
N
N/**
N * @var PWM_T::PPR
N * Offset: 0x00  PWM Prescaler Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits     |Field     |Descriptions
N * | :----:  | :----:   | :---- |
N * |[7:0]    |CP01      |Clock Prescaler 0 (PWM-Timer 0 / 1 For Group A And PWM-Timer 4 / 5 For Group B)
N * |         |          |Clock input is divided by (CP01 + 1) before it is fed to the corresponding PWM-timer
N * |         |          |If CP01=0, then the clock prescaler 0 output clock will be stopped.
N * |         |          |So corresponding PWM-timer will also be stopped.
N * |[15:8]   |CP23      |Clock Prescaler 2 (PWM-Timer2 / 3 For Group A And PWM-Timer 6 / 7 For Group B)
N * |         |          |Clock input is divided by (CP23 + 1) before it is fed to the corresponding PWM-timer
N * |         |          |If CP23=0, then the clock prescaler 2 output clock will be stopped.
N * |         |          |So corresponding PWM-timer will also be stopped.
N * |[23:16]  |DZI01     |Dead-Zone Interval For Pair Of Channel 0 And Channel 1 (PWM0 And PWM1 Pair For PWM Group A, PWM4 And PWM5 Pair For PWM Group B)
N * |         |          |These 8-bit determine the Dead-zone length.
N * |        |          |The unit time of Dead-zone length = [(prescale+1)*(clock source divider)]/ PWMxy_CLK (where xy
N * |        |          |could be 01 or 45, depends on selected PWM channel.).
N * |[31:24]  |DZI23     |Dead-Zone Interval For Pair Of Channel2 And Channel3 (PWM2 And PWM3 Pair For PWM Group A, PWM6 And PWM7 Pair For PWM Group B)
N * |         |          |These 8-bit determine the Dead-zone length.
N * |        |          |The unit time of Dead-zone length = [(prescale+1)*(clock source divider)]/ PWMxy_CLK (where xy
N * |        |          |could be 23 or 67, depends on selected PWM channel.).
N * @var PWM_T::CSR
N * Offset: 0x04  PWM Clock Source Divider Select Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits      |Field     |Descriptions
N * | :----:   | :----:   | :---- |
N * |[2:0]     |CSR0      |Timer 0 Clock Source Selection(PWM timer 0 for group A and PWM timer 4 for group B)
N * |          |          |Select clock input for timer.
N * |          |          |(Table is the same as CSR3)
N * |[6:4]     |CSR1      |Timer 1 Clock Source Selection(PWM timer 1 for group A and PWM timer 5 for group B)
N * |          |          |Select clock input for timer.
N * |          |          |(Table is the same as CSR3)
N * |[10:8]    |CSR2      |Timer 2 Clock Source Selection(PWM timer 2 for group A and PWM timer 6 for group B)
N * |          |          |Select clock input for timer.
N * |          |          |(Table is the same as CSR3)
N * |[14:12]   |CSR3      |Timer 3 Clock Source Selection (PWM timer 3 for group A and PWM timer 7 for group B)
N * |          |          |Select clock input for timer.
N * |          |          |CSRx[2:0] = Input clock divider
N * |          |          |100 = 1
N * |          |          |011 = 16
N * |          |          |010 = 8
N * |          |          |001 = 4
N * |          |          |000 = 2
N * @var PWM_T::PCR
N * Offset: 0x08  PWM Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits     |Field         |Descriptions
N * | :----:  | :----:       | :---- |
N * |[0]      |CH0EN         |PWM-Timer 0 Enable (PWM Timer 0 For Group A And PWM Timer 4 For Group B)
N * |         |              |0 = The corresponding PWM-Timer stops running.
N * |         |              |1 = The corresponding PWM-Timer starts running.
N * |[1]      |CH0PINV       |PWM-Timer 0 Output Polar Inverse Enable (PWM Timer 0 For Group A And PWM Timer 4 For Group B)
N * |         |              |0 = PWM0 output polar inverse Disabled.
N * |         |              |1 = PWM0 output polar inverse Enabled.
N * |[2]      |CH0INV        |PWM-Timer 0 Output Inverter Enable (PWM Timer 0 For Group A And PWM Timer 4 For Group B)
N * |         |              |0 = Inverter Disabled.
N * |         |              |1 = Inverter Enabled.
N * |[3]      |CH0MOD        |PWM-Timer 0 Auto-Reload/One-Shot Mode (PWM Timer 0 For Group A And PWM Timer 4 For Group B)
N * |         |              |0 = One-shot mode.
N * |         |              |1 = Auto-reload mode.
N * |         |              |Note: If there is a transition at this bit, it will cause CNR0 and CMR0 be cleared.
N * |[4]      |DZEN01        |Dead-Zone 0 Generator Enable (PWM0 And PWM1 Pair For PWM Group A, PWM4 And PWM5 Pair For PWM Group B)
N * |         |              |0 = Disabled.
N * |         |              |1 = Enabled.
N * |        |          |Note: When Dead-zone generator is enabled, the pair of PWM0 and PWM1 becomes a complementary
N * |        |          |pair for PWM group A and the pair of PWM4 and PWM5 becomes a complementary pair for PWM group B.
N * |[5]      |DZEN23        |Dead-Zone 2 Generator Enable (PWM2 And PWM3 Pair For PWM Group A, PWM6 And PWM7 Pair For PWM Group B)
N * |         |              |0 = Disabled.
N * |         |              |1 = Enabled.
N * |        |          |Note: When Dead-zone generator is enabled, the pair of PWM2 and PWM3 becomes a complementary
N * |        |          |pair for PWM group A and the pair of PWM6 and PWM7 becomes a complementary pair for PWM group B.
N * |[8]      |CH1EN         |PWM-Timer 1 Enable (PWM Timer 1 For Group A And PWM Timer 5 For Group B)
N * |         |              |0 = Corresponding PWM-Timer Stopped.
N * |         |              |1 = Corresponding PWM-Timer Start Running.
N * |[9]      |CH1PINV       |PWM-Timer 1 Output Polar Inverse Enable (PWM Timer 1 For Group A And PWM Timer 5 For Group B)
N * |         |              |0 = PWM1 output polar inverse Disabled.
N * |         |              |1 = PWM1 output polar inverse Enabled.
N * |[10]     |CH1INV        |PWM-Timer 1 Output Inverter Enable (PWM Timer 1 For Group A And PWM Timer 5 For Group B)
N * |         |              |0 = Inverter Disable.
N * |         |              |1 = Inverter Enable.
N * |[11]     |CH1MOD        |PWM-Timer 1 Auto-Reload/One-Shot Mode (PWM Timer 1 For Group A And PWM Timer 5 For Group B)
N * |         |              |0 = One-shot mode.
N * |         |              |1 = Auto-reload mode.
N * |         |              |Note: If there is a transition at this bit, it will cause CNR1 and CMR1 be cleared.
N * |[16]     |CH2EN         |PWM-Timer 2 Enable (PWM Timer 2 For Group A And PWM Timer 6 For Group B)
N * |         |              |0 = Corresponding PWM-Timer Stopped.
N * |         |              |1 = Corresponding PWM-Timer Start Running.
N * |[17]     |CH2PINV       |PWM-Timer 2 Output Polar Inverse Enable (PWM Timer 2 For Group A And PWM Timer 6 For Group B)
N * |         |              |0 = PWM2 output polar inverse Disabled.
N * |         |              |1 = PWM2 output polar inverse Enabled.
N * |[18]     |CH2INV        |PWM-Timer 2 Output Inverter Enable (PWM Timer 2 For Group A And PWM Timer 6 For Group B)
N * |         |              |0 = Inverter Disabled.
N * |         |              |1 = Inverter Enabled.
N * |[19]     |CH2MOD        |PWM-Timer 2 Auto-Reload/One-Shot Mode (PWM Timer 2 For Group A And PWM Timer 6 For Group B)
N * |         |              |0 = One-shot mode.
N * |         |              |1 = Auto-reload mode.
N * |         |              |Note: If there is a transition at this bit, it will cause CNR2 and CMR2 be cleared.
N * |[24]     |CH3EN         |PWM-Timer 3 Enable (PWM Timer 3 For Group A And PWM Timer 7 For Group B)
N * |         |              |0 = Corresponding PWM-Timer Stopped.
N * |         |              |1 = Corresponding PWM-Timer Start Running.
N * |[25]     |CH3PINV       |PWM-Timer 3 Output Polar Inverse Enable (PWM Timer 3 For Group A And PWM Timer 7 For Group B)
N * |         |              |0 = PWM3 output polar inverse Disable.
N * |         |              |1 = PWM3 output polar inverse Enable.
N * |[26]     |CH3INV        |PWM-Timer 3 Output Inverter Enable (PWM Timer 3 For Group A And PWM Timer 7 For Group B)
N * |         |              |0 = Inverter Disabled.
N * |         |              |1 = Inverter Enabled.
N * |[27]     |CH3MOD        |PWM-Timer 3 Auto-Reload/One-Shot Mode (PWM Timer 3 For Group A And PWM Timer 7 For Group B)
N * |         |              |0 = One-shot mode.
N * |         |              |1 = Auto-reload mode.
N * |         |              |Note: If there is a transition at this bit, it will cause CNR3 and CMR3 be cleared.
N * |[30]     |PWM01TYPE     |PWM01 Aligned Type Selection Bit (PWM0 And PWM1 Pair For PWM Group A, PWM4 And PWM5 Pair For PWM Group B)
N * |         |              |0 = Edge-aligned type.
N * |         |              |1 = Center-aligned type.
N * |[31]     |PWM23TYPE     |PWM23 Aligned Type Selection Bit (PWM2 And PWM3 Pair For PWM Group A, PWM6 And PWM7 Pair For PWM Group B)
N * |         |              |0 = Edge-aligned type.
N * |         |              |1 = Center-aligned type.
N * @var PWM_T::CNR0
N * Offset: 0x0C  PWM Counter Register 0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CNRx      |PWM Timer Loaded Value
N * |        |          |CNR determines the PWM period.
N * |        |          |PWM frequency = PWMxy_CLK/[(prescale+1)*(clock divider)*(CNR+1)]; where xy, could be 01, 23, 45
N * |        |          |or 67, depends on selected PWM channel.
N * |        |          |For Edge-aligned type:
N * |        |          | Duty ratio = (CMR+1)/(CNR+1).
N * |        |          | CMR >= CNR: PWM output is always high.
N * |        |          | CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
N * |        |          | CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit.
N * |        |          |For Center-aligned type:
N * |        |          | Duty ratio = [(2 x CMR) + 1]/[2 x (CNR+1)].
N * |        |          | CMR > CNR: PWM output is always high.
N * |        |          | CMR <= CNR: PWM low width = 2 x (CNR-CMR) + 1 unit; PWM high width = (2 x CMR) + 1 unit.
N * |        |          | CMR = 0: PWM low width = 2 x CNR + 1 unit; PWM high width = 1 unit.
N * |        |          |(Unit = one PWM clock cycle).
N * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
N * |        |          |Note: When PWM operating at Center-aligned type, CNR value should be set between 0x0000 to
N * |        |          |0xFFFE.
N * |        |          |If CNR equal to 0xFFFF, the PWM will work unpredictable.
N * |        |          |Note: When CNR value is set to 0, PWM output is always high.
N * @var PWM_T::CMR0
N * Offset: 0x0C  PWM Counter Register 0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CNRx      |PWM Timer Loaded Value
N * |        |          |CNR determines the PWM period.
N * |        |          |PWM frequency = PWMxy_CLK/[(prescale+1)*(clock divider)*(CNR+1)]; where xy, could be 01, 23, 45
N * |        |          |or 67, depends on selected PWM channel.
N * |        |          |For Edge-aligned type:
N * |        |          | Duty ratio = (CMR+1)/(CNR+1).
N * |        |          | CMR >= CNR: PWM output is always high.
N * |        |          | CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
N * |        |          | CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit.
N * |        |          |For Center-aligned type:
N * |        |          | Duty ratio = [(2 x CMR) + 1]/[2 x (CNR+1)].
N * |        |          | CMR > CNR: PWM output is always high.
N * |        |          | CMR <= CNR: PWM low width = 2 x (CNR-CMR) + 1 unit; PWM high width = (2 x CMR) + 1 unit.
N * |        |          | CMR = 0: PWM low width = 2 x CNR + 1 unit; PWM high width = 1 unit.
N * |        |          |(Unit = one PWM clock cycle).
N * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
N * |        |          |Note: When PWM operating at Center-aligned type, CNR value should be set between 0x0000 to
N * |        |          |0xFFFE.
N * |        |          |If CNR equal to 0xFFFF, the PWM will work unpredictable.
N * |        |          |Note: When CNR value is set to 0, PWM output is always high.
N * @var PWM_T::PDR0
N * Offset: 0x14  PWM Data Register 0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |PDRx      |PWM Data Register
N * |        |          |User can monitor PDR to know the current value in 16-bit counter.
N * @var PWM_T::CNR1
N * Offset: 0x18  PWM Counter Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CNRx      |PWM Timer Loaded Value
N * |        |          |CNR determines the PWM period.
N * |        |          |PWM frequency = PWMxy_CLK/[(prescale+1)*(clock divider)*(CNR+1)]; where xy, could be 01, 23, 45
N * |        |          |or 67, depends on selected PWM channel.
N * |        |          |For Edge-aligned type:
N * |        |          | Duty ratio = (CMR+1)/(CNR+1).
N * |        |          | CMR >= CNR: PWM output is always high.
N * |        |          | CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
N * |        |          | CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit.
N * |        |          |For Center-aligned type:
N * |        |          | Duty ratio = [(2 x CMR) + 1]/[2 x (CNR+1)].
N * |        |          | CMR > CNR: PWM output is always high.
N * |        |          | CMR <= CNR: PWM low width = 2 x (CNR-CMR) + 1 unit; PWM high width = (2 x CMR) + 1 unit.
N * |        |          | CMR = 0: PWM low width = 2 x CNR + 1 unit; PWM high width = 1 unit.
N * |        |          |(Unit = one PWM clock cycle).
N * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
N * |        |          |Note: When PWM operating at Center-aligned type, CNR value should be set between 0x0000 to
N * |        |          |0xFFFE.
N * |        |          |If CNR equal to 0xFFFF, the PWM will work unpredictable.
N * |        |          |Note: When CNR value is set to 0, PWM output is always high.
N * @var PWM_T::CMR1
N * Offset: 0x1C  PWM Comparator Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CMRx      |PWM Comparator Register
N * |        |          |CMR determines the PWM duty.
N * |        |          |PWM frequency = PWMxy_CLK/[(prescale+1)*(clock divider)*(CNR+1)]; where xy, could be 01, 23, 45
N * |        |          |or 67, depends on selected PWM channel.
N * |        |          |For Edge-aligned type:
N * |        |          | Duty ratio = (CMR+1)/(CNR+1).
N * |        |          | CMR >= CNR: PWM output is always high.
N * |        |          | CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
N * |        |          | CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit.
N * |        |          |For Center-aligned type:
N * |        |          | Duty ratio = [(2 x CMR) + 1]/[2 x (CNR+1)].
N * |        |          | CMR > CNR: PWM output is always high.
N * |        |          | CMR <= CNR: PWM low width = 2 x (CNR-CMR) + 1 unit; PWM high width = (2 x CMR) + 1 unit.
N * |        |          | CMR = 0: PWM low width = 2 x CNR + 1 unit; PWM high width = 1 unit.
N * |        |          |(Unit = one PWM clock cycle).
N * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
N * @var PWM_T::PDR1
N * Offset: 0x20  PWM Data Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |PDRx      |PWM Data Register
N * |        |          |User can monitor PDR to know the current value in 16-bit counter.
N * @var PWM_T::CNR2
N * Offset: 0x24  PWM Counter Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CNRx      |PWM Timer Loaded Value
N * |        |          |CNR determines the PWM period.
N * |        |          |PWM frequency = PWMxy_CLK/[(prescale+1)*(clock divider)*(CNR+1)]; where xy, could be 01, 23, 45
N * |        |          |or 67, depends on selected PWM channel.
N * |        |          |For Edge-aligned type:
N * |        |          | Duty ratio = (CMR+1)/(CNR+1).
N * |        |          | CMR >= CNR: PWM output is always high.
N * |        |          | CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
N * |        |          | CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit.
N * |        |          |For Center-aligned type:
N * |        |          | Duty ratio = [(2 x CMR) + 1]/[2 x (CNR+1)].
N * |        |          | CMR > CNR: PWM output is always high.
N * |        |          | CMR <= CNR: PWM low width = 2 x (CNR-CMR) + 1 unit; PWM high width = (2 x CMR) + 1 unit.
N * |        |          | CMR = 0: PWM low width = 2 x CNR + 1 unit; PWM high width = 1 unit.
N * |        |          |(Unit = one PWM clock cycle).
N * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
N * |        |          |Note: When PWM operating at Center-aligned type, CNR value should be set between 0x0000 to
N * |        |          |0xFFFE.
N * |        |          |If CNR equal to 0xFFFF, the PWM will work unpredictable.
N * |        |          |Note: When CNR value is set to 0, PWM output is always high.
N * @var PWM_T::CMR2
N * Offset: 0x28  PWM Comparator Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CMRx      |PWM Comparator Register
N * |        |          |CMR determines the PWM duty.
N * |        |          |PWM frequency = PWMxy_CLK/[(prescale+1)*(clock divider)*(CNR+1)]; where xy, could be 01, 23, 45
N * |        |          |or 67, depends on selected PWM channel.
N * |        |          |For Edge-aligned type:
N * |        |          | Duty ratio = (CMR+1)/(CNR+1).
N * |        |          | CMR >= CNR: PWM output is always high.
N * |        |          | CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
N * |        |          | CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit.
N * |        |          |For Center-aligned type:
N * |        |          | Duty ratio = [(2 x CMR) + 1]/[2 x (CNR+1)].
N * |        |          | CMR > CNR: PWM output is always high.
N * |        |          | CMR <= CNR: PWM low width = 2 x (CNR-CMR) + 1 unit; PWM high width = (2 x CMR) + 1 unit.
N * |        |          | CMR = 0: PWM low width = 2 x CNR + 1 unit; PWM high width = 1 unit.
N * |        |          |(Unit = one PWM clock cycle).
N * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
N * @var PWM_T::PDR2
N * Offset: 0x2C  PWM Data Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |PDRx      |PWM Data Register
N * |        |          |User can monitor PDR to know the current value in 16-bit counter.
N * @var PWM_T::CNR3
N * Offset: 0x30  PWM Counter Register 3
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CNRx      |PWM Timer Loaded Value
N * |        |          |CNR determines the PWM period.
N * |        |          |PWM frequency = PWMxy_CLK/[(prescale+1)*(clock divider)*(CNR+1)]; where xy, could be 01, 23, 45
N * |        |          |or 67, depends on selected PWM channel.
N * |        |          |For Edge-aligned type:
N * |        |          | Duty ratio = (CMR+1)/(CNR+1).
N * |        |          | CMR >= CNR: PWM output is always high.
N * |        |          | CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
N * |        |          | CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit.
N * |        |          |For Center-aligned type:
N * |        |          | Duty ratio = [(2 x CMR) + 1]/[2 x (CNR+1)].
N * |        |          | CMR > CNR: PWM output is always high.
N * |        |          | CMR <= CNR: PWM low width = 2 x (CNR-CMR) + 1 unit; PWM high width = (2 x CMR) + 1 unit.
N * |        |          | CMR = 0: PWM low width = 2 x CNR + 1 unit; PWM high width = 1 unit.
N * |        |          |(Unit = one PWM clock cycle).
N * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
N * |        |          |Note: When PWM operating at Center-aligned type, CNR value should be set between 0x0000 to
N * |        |          |0xFFFE.
N * |        |          |If CNR equal to 0xFFFF, the PWM will work unpredictable.
N * |        |          |Note: When CNR value is set to 0, PWM output is always high.
N * @var PWM_T::CMR3
N * Offset: 0x34  PWM Comparator Register 3
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CMRx      |PWM Comparator Register
N * |        |          |CMR determines the PWM duty.
N * |        |          |PWM frequency = PWMxy_CLK/[(prescale+1)*(clock divider)*(CNR+1)]; where xy, could be 01, 23, 45
N * |        |          |or 67, depends on selected PWM channel.
N * |        |          |For Edge-aligned type:
N * |        |          | Duty ratio = (CMR+1)/(CNR+1).
N * |        |          | CMR >= CNR: PWM output is always high.
N * |        |          | CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
N * |        |          | CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit.
N * |        |          |For Center-aligned type:
N * |        |          | Duty ratio = [(2 x CMR) + 1]/[2 x (CNR+1)].
N * |        |          | CMR > CNR: PWM output is always high.
N * |        |          | CMR <= CNR: PWM low width = 2 x (CNR-CMR) + 1 unit; PWM high width = (2 x CMR) + 1 unit.
N * |        |          | CMR = 0: PWM low width = 2 x CNR + 1 unit; PWM high width = 1 unit.
N * |        |          |(Unit = one PWM clock cycle).
N * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
N * @var PWM_T::PDR3
N * Offset: 0x38  PWM Data Register 3
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |PDRx      |PWM Data Register
N * |        |          |User can monitor PDR to know the current value in 16-bit counter.
N * @var PWM_T::PBCR
N * Offset: 0x3C  PWM Backward Compatible Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |BCn       |PWM Backward Compatible Register
N * |        |          |0 = Configure write 0 to clear CFLRI0~3 and CRLRI0~3.
N * |        |          |1 = Configure write 1 to clear CFLRI0~3 and CRLRI0~3.
N * |        |          |Refer to the CCR0/CCR2 register bit 6, 7, 22, 23 description
N * |        |          |Note: It is recommended that this bit be set to 1 to prevent CFLRIx and CRLRIx from being
N * |        |          |cleared when writing CCR0/CCR2.
N * @var PWM_T::PIER
N * Offset: 0x40  PWM Interrupt Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |PWMIE0    |PWM Channel 0 Period Interrupt Enable
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[1]     |PWMIE1    |PWM Channel 1 Period Interrupt Enable
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[2]     |PWMIE2    |PWM Channel 2 Period Interrupt Enable
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[3]     |PWMIE3    |PWM Channel 3 Period Interrupt Enable
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[8]     |PWMDIE0   |PWM Channel 0 Duty Interrupt Enable
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[9]     |PWMDIE1   |PWM Channel 1 Duty Interrupt Enable
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[10]    |PWMDIE2   |PWM Channel 2 Duty Interrupt Enable
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[11]    |PWMDIE3   |PWM Channel 3 Duty Interrupt Enable
N * |        |          |0 = Disabled.
N * |        |          |1 = Enabled.
N * |[16]    |INT01TYPE |PWM01 Interrupt Period Type Selection Bit (PWM0 And PWM1 Pair For PWM Group A, PWM4 And PWM5 Pair For PWM Group B)
N * |        |          |0 = PWMIFn will be set if PWM counter underflow.
N * |        |          |1 = PWMIFn will be set if PWM counter matches CNRn register.
N * |        |          |Note: This bit is effective when PWM in Center-aligned type only.
N * |[17]    |INT23TYPE |PWM23 Interrupt Period Type Selection Bit (PWM2 And PWM3 Pair For PWM Group A, PWM6 And PWM7 Pair For PWM Group B)
N * |        |          |0 = PWMIFn will be set if PWM counter underflow.
N * |        |          |1 = PWMIFn will be set if PWM counter matches CNRn register.
N * |        |          |Note: This bit is effective when PWM in Center-aligned type only.
N * @var PWM_T::PIIR
N * Offset: 0x44  PWM Interrupt Indication Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |PWMIF0    |PWM Channel 0 Period Interrupt Status
N * |        |          |This bit is set by hardware when PWM0 counter reaches the requirement of interrupt (depend on
N * |        |          |INT01TYPE bit of PIER register), software can write 1 to clear this bit to 0.
N * |[1]     |PWMIF1    |PWM Channel 1 Period Interrupt Status
N * |        |          |This bit is set by hardware when PWM1 counter reaches the requirement of interrupt (depend on
N * |        |          |INT01TYPE bit of PIER register), software can write 1 to clear this bit to 0.
N * |[2]     |PWMIF2    |PWM Channel 2 Period Interrupt Status
N * |        |          |This bit is set by hardware when PWM2 counter reaches the requirement of interrupt (depend on
N * |        |          |INT23TYPE bit of PIER register), software can write 1 to clear this bit to 0.
N * |[3]     |PWMIF3    |PWM Channel 3 Period Interrupt Status
N * |        |          |This bit is set by hardware when PWM3 counter reaches the requirement of interrupt (depend on
N * |        |          |INT23TYPE bit of PIER register), software can write 1 to clear this bit to 0.
N * |[8]     |PWMDIF0   |PWM Channel 0 Duty Interrupt Flag
N * |        |          |Flag is set by hardware when channel 0 PWM counter down count and reaches CMR0, software can
N * |        |          |clear this bit by writing a one to it.
N * |        |          |Note: If CMR equal to CNR, this flag is not working in Edge-aligned type selection
N * |[9]     |PWMDIF1   |PWM Channel 1 Duty Interrupt Flag
N * |        |          |Flag is set by hardware when channel 1 PWM counter down count and reaches CMR1, software can
N * |        |          |clear this bit by writing a one to it.
N * |        |          |Note: If CMR equal to CNR, this flag is not working in Edge-aligned type selection
N * |[10]    |PWMDIF2   |PWM Channel 2 Duty Interrupt Flag
N * |        |          |Flag is set by hardware when channel 2 PWM counter down count and reaches CMR2, software can
N * |        |          |clear this bit by writing a one to it.
N * |        |          |Note: If CMR equal to CNR, this flag is not working in Edge-aligned type selection
N * |[11]    |PWMDIF3   |PWM Channel 3 Duty Interrupt Flag
N * |        |          |Flag is set by hardware when channel 3 PWM counter down count and reaches CMR3, software can
N * |        |          |clear this bit by writing a one to it.
N * |        |          |Note: If CMR equal to CNR, this flag is not working in Edge-aligned type selection
N * @var PWM_T::CCR0
N * Offset: 0x50  PWM Capture Control Register 0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |INV0      |Channel 0 Inverter Enable
N * |        |          |0 = Inverter Disabled.
N * |        |          |1 = Inverter Enabled. Reverse the input signal from GPIO before fed to Capture timer
N * |[1]     |CRL_IE0   |Channel 0 Rising Latch Interrupt Enable
N * |        |          |0 = Rising latch interrupt Disabled.
N * |        |          |1 = Rising latch interrupt Enabled.
N * |        |          |When Enabled, if Capture detects PWM group channel 0 has rising transition, Capture will issue
N * |        |          |an Interrupt.
N * |[2]     |CFL_IE0   |Channel 0 Falling Latch Interrupt Enable
N * |        |          |0 = Falling latch interrupt Disabled.
N * |        |          |1 = Falling latch interrupt Enabled.
N * |        |          |When Enabled, if Capture detects PWM group channel 0 has falling transition, Capture will issue
N * |        |          |an Interrupt.
N * |[3]     |CAPCH0EN  |Channel 0 Capture Function Enable
N * |        |          |0 = Capture function on PWM group channel 0 Disabled.
N * |        |          |1 = Capture function on PWM group channel 0 Enabled.
N * |        |          |When Enabled, Capture latched the PWM-counter value and saved to CRLR (Rising latch) and CFLR
N * |        |          |(Falling latch).
N * |        |          |When Disabled, Capture does not update CRLR and CFLR, and disable PWM group channel 0 Interrupt.
N * |[4]     |CAPIF0    |Channel 0 Capture Interrupt Indication Flag
N * |        |          |If PWM group channel 0 rising latch interrupt is enabled (CRL_IE0 = 1), a rising transition
N * |        |          |occurs at PWM group channel 0 will result in CAPIF0 to high; Similarly, a falling transition
N * |        |          |will cause CAPIF0 to be set high if PWM group channel 0 falling latch interrupt is enabled
N * |        |          |(CFL_IE0 = 1).
N * |        |          |Write 1 to clear this bit to 0.
N * |[6]     |CRLRI0    |CRLR0 Latched Indicator Bit
N * |        |          |When PWM group input channel 0 has a rising transition, CRLR0 was latched with the value of PWM
N * |        |          |down-counter and this bit is set by hardware.
N * |        |          |Software can write 0 to clear this bit to 0 if the BCn bit is 0, and can write 1 to clear this
N * |        |          |bit to 0 if the BCn bit is 1.
N * |[7]     |CFLRI0    |CFLR0 Latched Indicator Bit
N * |        |          |When PWM group input channel 0 has a falling transition, CFLR0 was latched with the value of PWM
N * |        |          |down-counter and this bit is set by hardware.
N * |        |          |Software can write 0 to clear this bit to 0 if the BCn bit is 0, and can write 1 to clear this
N * |        |          |bit to0 if BCn bit is 1.
N * |[16]    |INV1      |Channel 1 Inverter Enable
N * |        |          |0 = Inverter Disabled.
N * |        |          |1 = Inverter Enabled. Reverse the input signal from GPIO before fed to Capture timer
N * |[17]    |CRL_IE1   |Channel 1 Rising Latch Interrupt Enable
N * |        |          |0 = Rising latch interrupt Disabled.
N * |        |          |1 = Rising latch interrupt Enabled.
N * |        |          |When Enabled, if Capture detects PWM group channel 1 has rising transition, Capture will issue
N * |        |          |an Interrupt.
N * |[18]    |CFL_IE1   |Channel 1 Falling Latch Interrupt Enable
N * |        |          |0 = Falling latch interrupt Disabled.
N * |        |          |1 = Falling latch interrupt Enabled.
N * |        |          |When Enabled, if Capture detects PWM group channel 1 has falling transition, Capture will issue
N * |        |          |an Interrupt.
N * |[19]    |CAPCH1EN  |Channel 1 Capture Function Enable
N * |        |          |0 = Capture function on PWM group channel 1 Disabled.
N * |        |          |1 = Capture function on PWM group channel 1 Enabled.
N * |        |          |When Enabled, Capture latched the PWM-counter and saved to CRLR (Rising latch) and CFLR (Falling
N * |        |          |latch).
N * |        |          |When Disabled, Capture does not update CRLR and CFLR, and disable PWM group channel 1 Interrupt.
N * |[20]    |CAPIF1    |Channel 1 Capture Interrupt Indication Flag
N * |        |          |If PWM group channel 1 rising latch interrupt is enabled (CRL_IE1 = 1), a rising transition
N * |        |          |occurs at PWM group channel 1 will result in CAPIF1 to high; Similarly, a falling transition
N * |        |          |will cause CAPIF1 to be set high if PWM group channel 1 falling latch interrupt is enabled
N * |        |          |(CFL_IE1 = 1).
N * |        |          |Write 1 to clear this bit to 0.
N * |[22]    |CRLRI1    |CRLR1 Latched Indicator Bit
N * |        |          |When PWM group input channel 1 has a rising transition, CRLR1 was latched with the value of PWM
N * |        |          |down-counter and this bit is set by hardware.
N * |        |          |Software can write 0 to clear this bit to 0 if BCn bit is 0, and can write 1 to clear this bit
N * |        |          |to0 if BCn bit is 1.
N * |[23]    |CFLRI1    |CFLR1 Latched Indicator Bit
N * |        |          |When PWM group input channel 1 has a falling transition, CFLR1 was latched with the value of PWM
N * |        |          |down-counter and this bit is set by hardware.
N * |        |          |Software can write 0 to clear this bit to 0 if BCn bit is 0, and can write 1 to clear this bit
N * |        |          |to 0 if BCn bit is 1.
N * @var PWM_T::CCR2
N * Offset: 0x54  PWM Capture Control Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |INV2      |Channel 2 Inverter Enable
N * |        |          |0 = Inverter Disabled.
N * |        |          |1 = Inverter Enabled. Reverse the input signal from GPIO before fed to Capture timer
N * |[1]     |CRL_IE2   |Channel 2 Rising Latch Interrupt Enable
N * |        |          |0 = Rising latch interrupt Disabled.
N * |        |          |1 = Rising latch interrupt Enabled.
N * |        |          |When Enabled, if Capture detects PWM group channel 2 has rising transition, Capture will issue
N * |        |          |an Interrupt.
N * |[2]     |CFL_IE2   |Channel 2 Falling Latch Interrupt Enable
N * |        |          |0 = Falling latch interrupt Disabled.
N * |        |          |1 = Falling latch interrupt Enabled.
N * |        |          |When Enabled, if Capture detects PWM group channel 2 has falling transition, Capture will issue
N * |        |          |an Interrupt.
N * |[3]     |CAPCH2EN  |Channel 2 Capture Function Enable
N * |        |          |0 = Capture function on PWM group channel 2 Disabled.
N * |        |          |1 = Capture function on PWM group channel 2 Enabled.
N * |        |          |When Enabled, Capture latched the PWM-counter value and saved to CRLR (Rising latch) and CFLR
N * |        |          |(Falling latch).
N * |        |          |When Disabled, Capture does not update CRLR and CFLR, and disable PWM group channel 2 Interrupt.
N * |[4]     |CAPIF2    |Channel 2 Capture Interrupt Indication Flag
N * |        |          |If PWM group channel 2 rising latch interrupt is enabled (CRL_IE2=1), a rising transition occurs
N * |        |          |at PWM group channel 2 will result in CAPIF2 to high; Similarly, a falling transition will cause
N * |        |          |CAPIF2 to be set high if PWM group channel 2 falling latch interrupt is enabled (CFL_IE2=1).
N * |        |          |Write 1 to clear this bit to 0
N * |[6]     |CRLRI2    |CRLR2 Latched Indicator Bit
N * |        |          |When PWM group input channel 2 has a rising transition, CRLR2 was latched with the value of PWM
N * |        |          |down-counter and this bit is set by hardware.
N * |        |          |Software can write 0 to clear this bit to 0 if the BCn bit is 0, and can write 1 to clear this
N * |        |          |bit to 0 if the BCn bit is 1.
N * |[7]     |CFLRI2    |CFLR2 Latched Indicator Bit
N * |        |          |When PWM group input channel 2 has a falling transition, CFLR2 was latched with the value of PWM
N * |        |          |down-counter and this bit is set by hardware.
N * |        |          |Software can write 0 to clear this bit to 0 if BCn bit is 0, and can write 1 to clear this bit
N * |        |          |to 0 if the BCn bit is 1.
N * |[16]    |INV3      |Channel 3 Inverter Enable
N * |        |          |0 = Inverter Disabled.
N * |        |          |1 = Inverter Enabled. Reverse the input signal from GPIO before fed to Capture timer
N * |[17]    |CRL_IE3   |Channel 3 Rising Latch Interrupt Enable
N * |        |          |0 = Rising latch interrupt Disabled.
N * |        |          |1 = Rising latch interrupt Enabled.
N * |        |          |When Enabled, if Capture detects PWM group channel 3 has rising transition, Capture will issue
N * |        |          |an Interrupt.
N * |[18]    |CFL_IE3   |Channel 3 Falling Latch Interrupt Enable
N * |        |          |0 = Falling latch interrupt Disabled.
N * |        |          |1 = Falling latch interrupt Enabled.
N * |        |          |When Enabled, if Capture detects PWM group channel 3 has falling transition, Capture will issue
N * |        |          |an Interrupt.
N * |[19]    |CAPCH3EN  |Channel 3 Capture Function Enable
N * |        |          |0 = Capture function on PWM group channel 3 Disabled.
N * |        |          |1 = Capture function on PWM group channel 3 Enabled.
N * |        |          |When Enabled, Capture latched the PWM-counter and saved to CRLR (Rising latch) and CFLR (Falling
N * |        |          |latch).
N * |        |          |When Disabled, Capture does not update CRLR and CFLR, and disable PWM group channel 3 Interrupt.
N * |[20]    |CAPIF3    |Channel 3 Capture Interrupt Indication Flag
N * |        |          |If PWM group channel 3 rising latch interrupt is enabled (CRL_IE3=1), a rising transition occurs
N * |        |          |at PWM group channel 3 will result in CAPIF3 to high; Similarly, a falling transition will cause
N * |        |          |CAPIF3 to be set high if PWM group channel 3 falling latch interrupt is enabled (CFL_IE3=1).
N * |        |          |Write 1 to clear this bit to 0
N * |[22]    |CRLRI3    |CRLR3 Latched Indicator Bit
N * |        |          |When PWM group input channel 3 has a rising transition, CRLR3 was latched with the value of PWM
N * |        |          |down-counter and this bit is set by hardware.
N * |        |          |Software can write 0 to clear this bit to 0 if the BCn bit is 0, and can write 1 to clear this
N * |        |          |bit to 0 if the BCn bit is 1.
N * |[23]    |CFLRI3    |CFLR3 Latched Indicator Bit
N * |        |          |When PWM group input channel 3 has a falling transition, CFLR3 was latched with the value of PWM
N * |        |          |down-counter and this bit is set by hardware.
N * |        |          |Software can write 0 to clear this bit to 0 if the BCn bit is 0, and can write 1 to clear this
N * |        |          |bit to 0 if the BCn bit is 1.
N * @var PWM_T::CRLR0
N * Offset: 0x58  PWM Capture Rising Latch Register (Channel 0)
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CRLRx     |Capture Rising Latch Register
N * |        |          |Latch the PWM counter when Channel 0/1/2/3 has rising transition.
N * @var PWM_T::CFLR0
N * Offset: 0x5C  PWM Capture Falling Latch Register (Channel 0)
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CFLRx     |Capture Falling Latch Register
N * |        |          |Latch the PWM counter when Channel 0/1/2/3 has Falling transition.
N * @var PWM_T::CRLR1
N * Offset: 0x60  PWM Capture Rising Latch Register (Channel 1)
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CRLRx     |Capture Rising Latch Register
N * |        |          |Latch the PWM counter when Channel 0/1/2/3 has rising transition.
N * @var PWM_T::CFLR1
N * Offset: 0x64  PWM Capture Falling Latch Register (Channel 1)
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CFLRx     |Capture Falling Latch Register
N * |        |          |Latch the PWM counter when Channel 0/1/2/3 has Falling transition.
N * @var PWM_T::CRLR2
N * Offset: 0x68  PWM Capture Rising Latch Register (Channel 2)
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CRLRx     |Capture Rising Latch Register
N * |        |          |Latch the PWM counter when Channel 0/1/2/3 has rising transition.
N * @var PWM_T::CFLR2
N * Offset: 0x6C  PWM Capture Falling Latch Register (Channel 2)
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CFLRx     |Capture Falling Latch Register
N * |        |          |Latch the PWM counter when Channel 0/1/2/3 has Falling transition.
N * @var PWM_T::CRLR3
N * Offset: 0x70  PWM Capture Rising Latch Register (Channel 3)
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CRLRx     |Capture Rising Latch Register
N * |        |          |Latch the PWM counter when Channel 0/1/2/3 has rising transition.
N * @var PWM_T::CFLR3
N * Offset: 0x74  PWM Capture Falling Latch Register (Channel 3)
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |CFLRx     |Capture Falling Latch Register
N * |        |          |Latch the PWM counter when Channel 0/1/2/3 has Falling transition.
N * @var PWM_T::CAPENR
N * Offset: 0x78  PWM Capture Input 0~3 Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |CINEN0    |Channel 0 Capture Input Enable
N * |        |          |0 = PWM Channel 0 capture input path Disabled.
N * |        |          |The input of PWM channel 0 capture function is always regarded as 0.
N * |        |          |1 = PWM Channel 0 capture input path Enabled.
N * |        |          |The input of PWM channel 0 capture function comes from correlative multifunction pin if GPIO
N * |        |          |multi-function is set as PWM0.
N * |[1]     |CINEN1    |Channel 1 Capture Input Enable
N * |        |          |0 = PWM Channel 1 capture input path Disabled.
N * |        |          |The input of PWM channel 1 capture function is always regarded as 0.
N * |        |          |1 = PWM Channel 1 capture input path Enabled.
N * |        |          |The input of PWM channel 1 capture function comes from correlative multifunction pin if GPIO
N * |        |          |multi-function is set as PWM1.
N * |[2]     |CINEN2    |Channel 2 Capture Input Enable
N * |        |          |0 = PWM Channel 2 capture input path Disabled.
N * |        |          |The input of PWM channel 2 capture function is always regarded as 0.
N * |        |          |1 = PWM Channel 2 capture input path Enabled.
N * |        |          |The input of PWM channel 2 capture function comes from correlative multifunction pin if GPIO
N * |        |          |multi-function is set as PWM2.
N * |[3]     |CINEN3    |Channel 3 Capture Input Enable
N * |        |          |0 = PWM Channel 3 capture input path Disabled.
N * |        |          |The input of PWM channel 3 capture function is always regarded as 0.
N * |        |          |1 = PWM Channel 3 capture input path Enabled.
N * |        |          |The input of PWM channel 3 capture function comes from correlative multifunction pin if GPIO
N * |        |          |multi-function is set as PWM3.
N * @var PWM_T::POE
N * Offset: 0x7C  PWM Output Enable for Channel 0~3
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |POE0      |Channel 0 Output Enable Register
N * |        |          |0 = PWM channel 0 output to pin Disabled.
N * |        |          |1 = PWM channel 0 output to pin Enabled.
N * |        |          |Note: The corresponding GPIO pin must also be switched to PWM function
N * |[1]     |POE1      |Channel 1 Output Enable Register
N * |        |          |0 = PWM channel 1 output to pin Disabled.
N * |        |          |1 = PWM channel 1 output to pin Enabled.
N * |        |          |Note: The corresponding GPIO pin must also be switched to PWM function
N * |[2]     |POE2      |Channel 2 Output Enable Register
N * |        |          |0 = PWM channel 2 output to pin Disabled.
N * |        |          |1 = PWM channel 2 output to pin Enabled.
N * |        |          |Note: The corresponding GPIO pin must also be switched to PWM function
N * |[3]     |POE3      |Channel 3 Output Enable Register
N * |        |          |0 = PWM channel 3 output to pin Disabled.
N * |        |          |1 = PWM channel 3 output to pin Enabled.
N * |        |          |Note: The corresponding GPIO pin must also be switched to PWM function
N * @var PWM_T::TCON
N * Offset: 0x80  PWM Trigger Control for Channel 0~3
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |PWM0TEN   |Channel 0 Center-Aligned Trigger Enable Register
N * |        |          |0 = PWM channel 0 trigger ADC function Disabled.
N * |        |          |1 = PWM channel 0 trigger ADC function Enabled.
N * |        |          |PWM can trigger ADC to start conversion when PWM counter up count to CNR if this bit is set to
N * |        |          |1.
N * |        |          |Note: This function is only supported when PWM operating at Center-aligned type.
N * |[1]     |PWM1TEN   |Channel 1 Center-Aligned Trigger Enable Register
N * |        |          |0 = PWM channel 1 trigger ADC function Disabled.
N * |        |          |1 = PWM channel 1 trigger ADC function Enabled.
N * |        |          |PWM can trigger ADC to start conversion when PWM counter up count to CNR if this bit is set to
N * |        |          |1.
N * |        |          |Note: This function is only supported when PWM operating at Center-aligned type.
N * |[2]     |PWM2TEN   |Channel 2 Center-Aligned Trigger Enable Register
N * |        |          |0 = PWM channel 2 trigger ADC function Disabled.
N * |        |          |1 = PWM channel 2 trigger ADC function Enabled.
N * |        |          |PWM can trigger ADC to start conversion when PWM counter up count to CNR if this bit is set to
N * |        |          |1.
N * |        |          |Note: This function is only supported when PWM operating at Center-aligned type.
N * |[3]     |PWM3TEN   |Channel 3 Center-Aligned Trigger Enable Register
N * |        |          |0 = PWM channel 3 trigger ADC function Disabled.
N * |        |          |1 = PWM channel 3 trigger ADC function Enabled.
N * |        |          |PWM can trigger ADC to start conversion when PWM counter up count to CNR if this bit is set to
N * |        |          |1.
N * |        |          |Note: This function is only supported when PWM operating at Center-aligned type.
N * @var PWM_T::TSTATUS
N * Offset: 0x84  PWM Trigger Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |PWM0TF    |Channel 0 Center-Aligned Trigger Flag
N * |        |          |For Center-aligned Operating mode, this bit is set to 1 by hardware when PWM counter up counts
N * |        |          |to CNR if PWM0TEN bit is set to 1.
N * |        |          |After this bit is set to 1, ADC will start conversion if ADC triggered source is selected by
N * |        |          |PWM.
N * |        |          |Software can write 1 to clear this bit.
N * |[1]     |PWM1TF    |Channel 1 Center-Aligned Trigger Flag
N * |        |          |For Center-aligned Operating mode, this bit is set to 1 by hardware when PWM counter up count to
N * |        |          |CNR if PWM1TEN bit is set to 1.
N * |        |          |After this bit is set to 1, ADC will start conversion if ADC triggered source is selected by
N * |        |          |PWM.
N * |        |          |Software can write 1 to clear this bit.
N * |[2]     |PWM2TF    |Channel 2 Center-Aligned Trigger Flag
N * |        |          |For Center-aligned Operating mode, this bit is set to 1 by hardware when PWM counter up count to
N * |        |          |CNR if PWM2TEN bit is set to 1.
N * |        |          |After this bit is set to 1, ADC will start conversion if ADC triggered source is selected by
N * |        |          |PWM.
N * |        |          |Software can write 1 to clear this bit.
N * |[3]     |PWM3TF    |Channel 3 Center-Aligned Trigger Flag
N * |        |          |For Center-aligned Operating mode, this bit is set to 1 by hardware when PWM counter up count to
N * |        |          |CNR if PWM3TEN bit is set to 1.
N * |        |          |After this bit is set to 1, ADC will start conversion if ADC triggered source is selected by
N * |        |          |PWM.
N * |        |          |Software can write 1 to clear this bit.
N * @var PWM_T::SYNCBUSY0
N * Offset: 0x88  PWM0 Synchronous Busy Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |S_BUSY    |PWM Synchronous Busy
N * |        |          |When software writes CNR0/CMR0/PPR or switches PWM0 operation mode (PCR[3]), PWM will have a
N * |        |          |busy time to update these values completely because PWM clock may be different from system clock
N * |        |          |domain.
N * |        |          |Software needs to check this busy status before writing CNR0/CMR0/PPR or switching PWM0
N * |        |          |operation mode (PCR[3]) to make sure previous setting has been updated completely.
N * |        |          |This bit will be set when software writes CNR0/CMR0/PPR or switches PWM0 operation mode (PCR[3])
N * |        |          |and will be cleared by hardware automatically when PWM update these value completely.
N * @var PWM_T::SYNCBUSY1
N * Offset: 0x8C  PWM1 Synchronous Busy Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |S_BUSY    |PWM Synchronous Busy
N * |        |          |When Software writes CNR1/CMR1/PPR or switches PWM1 operation mode (PCR[11]), PWM will have a
N * |        |          |busy time to update these values completely because PWM clock may be different from system clock
N * |        |          |domain.
N * |        |          |Software needs to check this busy status before writing CNR1/CMR1/PPR or switching PWM1
N * |        |          |operation mode (PCR[11]) to make sure previous setting has been updated completely.
N * |        |          |This bit will be set when software writes CNR1/CMR1/PPR or switches PWM1 operation mode
N * |        |          |(PCR[11]) and will be cleared by hardware automatically when PWM update these value completely.
N * @var PWM_T::SYNCBUSY2
N * Offset: 0x90  PWM2 Synchronous Busy Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |S_BUSY    |PWM Synchronous Busy
N * |        |          |When Software writes CNR2/CMR2/PPR or switch PWM2 operation mode (PCR[19]), PWM will have a busy
N * |        |          |time to update these values completely because PWM clock may be different from system clock
N * |        |          |domain.
N * |        |          |Software needs to check this busy status before writing CNR2/CMR2/PPR or switching PWM2
N * |        |          |operation mode (PCR[19]) to make sure previous setting has been updated completely.
N * |        |          |This bit will be set when software writes CNR2/CMR2/PPR or switch PWM2 operation mode (PCR[19])
N * |        |          |and will be cleared by hardware automatically when PWM update these value completely.
N * @var PWM_T::SYNCBUSY3
N * Offset: 0x94  PWM3 Synchronous Busy Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |S_BUSY    |PWM Synchronous Busy
N * |        |          |When Software writes CNR3/CMR3/PPR or switch PWM3 operation mode (PCR[27]), PWM will have a busy
N * |        |          |time to update these values completely because PWM clock may be different from system clock
N * |        |          |domain.
N * |        |          |Software need to check this busy status before writing CNR3/CMR3/PPR or switching PWM3 operation
N * |        |          |mode (PCR[27]) to make sure previous setting has been updated completely.
N * |        |          |This bit will be set when Software writes CNR3/CMR3/PPR or switch PWM3 operation mode (PCR[27])
N * |        |          |and will be cleared by hardware automatically when PWM update these value completely.
N */
N
N    __IO uint32_t PPR;           /* Offset: 0x00  PWM Prescaler Register                                             */
X    volatile uint32_t PPR;            
N    __IO uint32_t CSR;           /* Offset: 0x04  PWM Clock Source Divider Select Register                           */
X    volatile uint32_t CSR;            
N    __IO uint32_t PCR;           /* Offset: 0x08  PWM Control Register                                               */
X    volatile uint32_t PCR;            
N    __IO uint32_t CNR0;          /* Offset: 0x0C  PWM Counter Register 0                                             */
X    volatile uint32_t CNR0;           
N    __IO uint32_t CMR0;          /* Offset: 0x0C  PWM Counter Register 0                                             */
X    volatile uint32_t CMR0;           
N    __I  uint32_t PDR0;          /* Offset: 0x14  PWM Data Register 0                                                */
X    volatile const  uint32_t PDR0;           
N    __IO uint32_t CNR1;          /* Offset: 0x18  PWM Counter Register 1                                             */
X    volatile uint32_t CNR1;           
N    __IO uint32_t CMR1;          /* Offset: 0x1C  PWM Comparator Register 1                                          */
X    volatile uint32_t CMR1;           
N    __I  uint32_t PDR1;          /* Offset: 0x20  PWM Data Register 1                                                */
X    volatile const  uint32_t PDR1;           
N    __IO uint32_t CNR2;          /* Offset: 0x24  PWM Counter Register 2                                             */
X    volatile uint32_t CNR2;           
N    __IO uint32_t CMR2;          /* Offset: 0x28  PWM Comparator Register 2                                          */
X    volatile uint32_t CMR2;           
N    __I  uint32_t PDR2;          /* Offset: 0x2C  PWM Data Register 2                                                */
X    volatile const  uint32_t PDR2;           
N    __IO uint32_t CNR3;          /* Offset: 0x30  PWM Counter Register 3                                             */
X    volatile uint32_t CNR3;           
N    __IO uint32_t CMR3;          /* Offset: 0x34  PWM Comparator Register 3                                          */
X    volatile uint32_t CMR3;           
N    __I  uint32_t PDR3;          /* Offset: 0x38  PWM Data Register 3                                                */
X    volatile const  uint32_t PDR3;           
N    __IO uint32_t PBCR;          /* Offset: 0x3C  PWM Backward Compatible Register                                   */
X    volatile uint32_t PBCR;           
N    __IO uint32_t PIER;          /* Offset: 0x40  PWM Interrupt Enable Register                                      */
X    volatile uint32_t PIER;           
N    __IO uint32_t PIIR;          /* Offset: 0x44  PWM Interrupt Indication Register                                  */
X    volatile uint32_t PIIR;           
N    __I  uint32_t RESERVE1[2];  
X    volatile const  uint32_t RESERVE1[2];  
N    __IO uint32_t CCR0;          /* Offset: 0x50  PWM Capture Control Register 0                                     */
X    volatile uint32_t CCR0;           
N    __IO uint32_t CCR2;          /* Offset: 0x54  PWM Capture Control Register 2                                     */
X    volatile uint32_t CCR2;           
N    __IO uint32_t CRLR0;         /* Offset: 0x58  PWM Capture Rising Latch Register (Channel 0)                      */
X    volatile uint32_t CRLR0;          
N    __IO uint32_t CFLR0;         /* Offset: 0x5C  PWM Capture Falling Latch Register (Channel 0)                     */
X    volatile uint32_t CFLR0;          
N    __IO uint32_t CRLR1;         /* Offset: 0x60  PWM Capture Rising Latch Register (Channel 1)                      */
X    volatile uint32_t CRLR1;          
N    __IO uint32_t CFLR1;         /* Offset: 0x64  PWM Capture Falling Latch Register (Channel 1)                     */
X    volatile uint32_t CFLR1;          
N    __IO uint32_t CRLR2;         /* Offset: 0x68  PWM Capture Rising Latch Register (Channel 2)                      */
X    volatile uint32_t CRLR2;          
N    __IO uint32_t CFLR2;         /* Offset: 0x6C  PWM Capture Falling Latch Register (Channel 2)                     */
X    volatile uint32_t CFLR2;          
N    __IO uint32_t CRLR3;         /* Offset: 0x70  PWM Capture Rising Latch Register (Channel 3)                      */
X    volatile uint32_t CRLR3;          
N    __IO uint32_t CFLR3;         /* Offset: 0x74  PWM Capture Falling Latch Register (Channel 3)                     */
X    volatile uint32_t CFLR3;          
N    __IO uint32_t CAPENR;        /* Offset: 0x78  PWM Capture Input 0~3 Enable Register                              */
X    volatile uint32_t CAPENR;         
N    __IO uint32_t POE;           /* Offset: 0x7C  PWM Output Enable for Channel 0~3                                  */
X    volatile uint32_t POE;            
N    __IO uint32_t TCON;          /* Offset: 0x80  PWM Trigger Control for Channel 0~3                                */
X    volatile uint32_t TCON;           
N    __IO uint32_t TSTATUS;       /* Offset: 0x84  PWM Trigger Status Register                                        */
X    volatile uint32_t TSTATUS;        
N    __IO uint32_t SYNCBUSY0;     /* Offset: 0x88  PWM0 Synchronous Busy Status Register                              */
X    volatile uint32_t SYNCBUSY0;      
N    __IO uint32_t SYNCBUSY1;     /* Offset: 0x8C  PWM1 Synchronous Busy Status Register                              */
X    volatile uint32_t SYNCBUSY1;      
N    __IO uint32_t SYNCBUSY2;     /* Offset: 0x90  PWM2 Synchronous Busy Status Register                              */
X    volatile uint32_t SYNCBUSY2;      
N    __IO uint32_t SYNCBUSY3;     /* Offset: 0x94  PWM3 Synchronous Busy Status Register                              */
X    volatile uint32_t SYNCBUSY3;      
N
N} PWM_T;
N
N
N/**
N    @addtogroup PWM_CONST PWM Bit Field Definition
N    Constant Definitions for PWM Controller
N@{ */
N
N
N/* PWM PPR Bit Field Definitions */
N#define PWM_PPR_DZI23_Pos                       24                                  /*!< PWM_T::PPR: DZI23 Position */
N#define PWM_PPR_DZI23_Msk                       (0xFFul << PWM_PPR_DZI23_Pos)       /*!< PWM_T::PPR: DZI23 Mask */
N
N#define PWM_PPR_DZI01_Pos                       16                                  /*!< PWM_T::PPR: DZI01 Position */
N#define PWM_PPR_DZI01_Msk                       (0xFFul << PWM_PPR_DZI01_Pos)       /*!< PWM_T::PPR: DZI01 Mask */
N
N#define PWM_PPR_CP23_Pos                        8                                   /*!< PWM_T::PPR: CP23 Position */
N#define PWM_PPR_CP23_Msk                        (0xFFul << PWM_PPR_CP23_Pos)        /*!< PWM_T::PPR: CP23 Mask */
N
N#define PWM_PPR_CP01_Pos                        0                                   /*!< PWM_T::PPR: CP01 Position */
N#define PWM_PPR_CP01_Msk                        (0xFFul << PWM_PPR_CP01_Pos)        /*!< PWM_T::PPR: CP01 Mask */
N
N/* PWM CSR Bit Field Definitions */
N#define PWM_CSR_CSR3_Pos                        12                                  /*!< PWM_T::CSR: CSR3 Position */
N#define PWM_CSR_CSR3_Msk                        (7ul << PWM_CSR_CSR3_Pos)           /*!< PWM_T::CSR: CSR3 Mask */
N
N#define PWM_CSR_CSR2_Pos                        8                                   /*!< PWM_T::CSR: CSR2 Position */
N#define PWM_CSR_CSR2_Msk                        (7ul << PWM_CSR_CSR2_Pos)           /*!< PWM_T::CSR: CSR2 Mask */
N
N#define PWM_CSR_CSR1_Pos                        4                                   /*!< PWM_T::CSR: CSR1 Position */
N#define PWM_CSR_CSR1_Msk                        (7ul << PWM_CSR_CSR1_Pos)           /*!< PWM_T::CSR: CSR1 Mask */
N
N#define PWM_CSR_CSR0_Pos                        0                                   /*!< PWM_T::CSR: CSR0 Position */
N#define PWM_CSR_CSR0_Msk                        (7ul << PWM_CSR_CSR0_Pos)           /*!< PWM_T::CSR: CSR0 Mask */
N
N/* PWM PCR Bit Field Definitions */
N#define PWM_PCR_PWM23TYPE_Pos                   31                                  /*!< PWM_T::PCR: PWM23TYPE Position */
N#define PWM_PCR_PWM23TYPE_Msk                   (1ul << PWM_PCR_PWM23TYPE_Pos)      /*!< PWM_T::PCR: PWM23TYPE Mask */
N
N#define PWM_PCR_PWM01TYPE_Pos                   30                                  /*!< PWM_T::PCR: PWM01TYPE Position */
N#define PWM_PCR_PWM01TYPE_Msk                   (1ul << PWM_PCR_PWM01TYPE_Pos)      /*!< PWM_T::PCR: PWM01TYPE Mask */
N
N#define PWM_PCR_CH3MOD_Pos                      27                                  /*!< PWM_T::PCR: CH3MOD Position */
N#define PWM_PCR_CH3MOD_Msk                      (1ul << PWM_PCR_CH3MOD_Pos)         /*!< PWM_T::PCR: CH3MOD Mask */
N
N#define PWM_PCR_CH3INV_Pos                      26                                  /*!< PWM_T::PCR: CH3INV Position */
N#define PWM_PCR_CH3INV_Msk                      (1ul << PWM_PCR_CH3INV_Pos)         /*!< PWM_T::PCR: CH3INV Mask */
N
N#define PWM_PCR_CH3PINV_Pos                     25                                  /*!< PWM_T::PCR: CH3PINV Position */
N#define PWM_PCR_CH3PINV_Msk                     (1ul << PWM_PCR_CH3PINV_Pos)        /*!< PWM_T::PCR: CH3PINV Mask */
N
N#define PWM_PCR_CH3EN_Pos                       24                                  /*!< PWM_T::PCR: CH3EN Position */
N#define PWM_PCR_CH3EN_Msk                       (1ul << PWM_PCR_CH3EN_Pos)          /*!< PWM_T::PCR: CH3EN Mask */
N
N#define PWM_PCR_CH2MOD_Pos                      19                                  /*!< PWM_T::PCR: CH2MOD Position */
N#define PWM_PCR_CH2MOD_Msk                      (1ul << PWM_PCR_CH2MOD_Pos)         /*!< PWM_T::PCR: CH2MOD Mask */
N
N#define PWM_PCR_CH2INV_Pos                      18                                  /*!< PWM_T::PCR: CH2INV Position */
N#define PWM_PCR_CH2INV_Msk                      (1ul << PWM_PCR_CH2INV_Pos)         /*!< PWM_T::PCR: CH2INV Mask */
N
N#define PWM_PCR_CH2PINV_Pos                     17                                  /*!< PWM_T::PCR: CH2PINV Position */
N#define PWM_PCR_CH2PINV_Msk                     (1ul << PWM_PCR_CH2PINV_Pos)        /*!< PWM_T::PCR: CH2PINV Mask */
N
N#define PWM_PCR_CH2EN_Pos                       16                                  /*!< PWM_T::PCR: CH2EN Position */
N#define PWM_PCR_CH2EN_Msk                       (1ul << PWM_PCR_CH2EN_Pos)          /*!< PWM_T::PCR: CH2EN Mask */
N
N#define PWM_PCR_CH1MOD_Pos                      11                                  /*!< PWM_T::PCR: CH1MOD Position */
N#define PWM_PCR_CH1MOD_Msk                      (1ul << PWM_PCR_CH1MOD_Pos)         /*!< PWM_T::PCR: CH1MOD Mask */
N
N#define PWM_PCR_CH1INV_Pos                      10                                  /*!< PWM_T::PCR: CH1INV Position */
N#define PWM_PCR_CH1INV_Msk                      (1ul << PWM_PCR_CH1INV_Pos)         /*!< PWM_T::PCR: CH1INV Mask */
N
N#define PWM_PCR_CH1PINV_Pos                     9                                   /*!< PWM_T::PCR: CH1PINV Position */
N#define PWM_PCR_CH1PINV_Msk                     (1ul << PWM_PCR_CH1PINV_Pos)        /*!< PWM_T::PCR: CH1PINV Mask */
N
N#define PWM_PCR_CH1EN_Pos                       8                                   /*!< PWM_T::PCR: CH1EN Position */
N#define PWM_PCR_CH1EN_Msk                       (1ul << PWM_PCR_CH1EN_Pos)          /*!< PWM_T::PCR: CH1EN Mask */
N
N#define PWM_PCR_DZEN23_Pos                      5                                   /*!< PWM_T::PCR: DZEN23 Position */
N#define PWM_PCR_DZEN23_Msk                      (1ul << PWM_PCR_DZEN23_Pos)         /*!< PWM_T::PCR: DZEN23 Mask */
N
N#define PWM_PCR_DZEN01_Pos                      4                                   /*!< PWM_T::PCR: DZEN01 Position */
N#define PWM_PCR_DZEN01_Msk                      (1ul << PWM_PCR_DZEN01_Pos)         /*!< PWM_T::PCR: DZEN01 Mask */
N
N#define PWM_PCR_CH0MOD_Pos                      3                                   /*!< PWM_T::PCR: CH0MOD Position */
N#define PWM_PCR_CH0MOD_Msk                      (1ul << PWM_PCR_CH0MOD_Pos)         /*!< PWM_T::PCR: CH0MOD Mask */
N
N#define PWM_PCR_CH0INV_Pos                      2                                   /*!< PWM_T::PCR: CH0INV Position */
N#define PWM_PCR_CH0INV_Msk                      (1ul << PWM_PCR_CH0INV_Pos)         /*!< PWM_T::PCR: CH0INV Mask */
N
N#define PWM_PCR_CH0PINV_Pos                      1                                  /*!< PWM_T::PCR: CH0PINV Position */
N#define PWM_PCR_CH0PINV_Msk                     (1ul << PWM_PCR_CH0PINV_Pos)        /*!< PWM_T::PCR: CH0PINV Mask */
N
N#define PWM_PCR_CH0EN_Pos                       0                                   /*!< PWM_T::PCR: CH0EN Position */
N#define PWM_PCR_CH0EN_Msk                       (1ul << PWM_PCR_CH0EN_Pos)          /*!< PWM_T::PCR: CH0EN Mask */
N
N/* PWM CNR Bit Field Definitions */
N#define PWM_CNR_CNR_Pos                         0                                   /*!< PWM_T::CNR0: CNR Position */
N#define PWM_CNR_CNR_Msk                         (0xFFFFul << PWM_CNR_CNR_Pos)       /*!< PWM_T::CNR0: CNR Mask */
N
N/* PWM CMR Bit Field Definitions */
N#define PWM_CMR_CMR_Pos                         0                                   /*!< PWM_T::CMR0: CMR Position */
N#define PWM_CMR_CMR_Msk                         (0xFFFFul << PWM_CMR_CMR_Pos)       /*!< PWM_T::CMR0: CMR Mask */
N
N/* PWM PDR Bit Field Definitions */
N#define PWM_PDR_PDR_Pos                         0                                   /*!< PWM_T::PDR0: PDR Position */
N#define PWM_PDR_PDR_Msk                         (0xFFFFul << PWM_PDR_PDR_Pos)       /*!< PWM_T::PDR0: PDR Mask */
N
N/* PWM PBCR Bit Field Definitions */
N#define PWM_PBCR_BCn_Pos                         0                                  /*!< PWM_T::PBCR: BCn Position */
N#define PWM_PBCR_BCn_Msk                         (1ul << PWM_PBCR_BCn_Pos)          /*!< PWM_T::PBCR: BCn Mask */
N
N/* PWM PIER Bit Field Definitions */
N
N#define PWM_PIER_INT23TYPE_Pos                  17                                  /*!< PWM_T::PIER: INT23TYPE Position */
N#define PWM_PIER_INT23TYPE_Msk                     (1ul << PWM_PIER_INT23TYPE_Pos)  /*!< PWM_T::PIER: INT23TYPE Mask */
N
N#define PWM_PIER_INT01TYPE_Pos                  16                                  /*!< PWM_T::PIER: INT01TYPE Position */
N#define PWM_PIER_INT01TYPE_Msk                     (1ul << PWM_PIER_INT01TYPE_Pos)  /*!< PWM_T::PIER: INT01TYPE Mask */
N
N#define PWM_PIER_PWMDIE3_Pos                    11                                  /*!< PWM_T::PIER: PWMDIE3 Position */
N#define PWM_PIER_PWMDIE3_Msk                     (1ul << PWM_PIER_PWMDIE3_Pos)      /*!< PWM_T::PIER: PWMDIE3 Mask */
N
N#define PWM_PIER_PWMDIE2_Pos                    10                                  /*!< PWM_T::PIER: PWMDIE2 Position */
N#define PWM_PIER_PWMDIE2_Msk                     (1ul << PWM_PIER_PWMDIE2_Pos)      /*!< PWM_T::PIER: PWMDIE2 Mask */
N
N#define PWM_PIER_PWMDIE1_Pos                    9                                   /*!< PWM_T::PIER: PWMDIE1 Position */
N#define PWM_PIER_PWMDIE1_Msk                     (1ul << PWM_PIER_PWMDIE1_Pos)      /*!< PWM_T::PIER: PWMDIE1 Mask */
N
N#define PWM_PIER_PWMDIE0_Pos                    8                                   /*!< PWM_T::PIER: PWMDIE0 Position */
N#define PWM_PIER_PWMDIE0_Msk                     (1ul << PWM_PIER_PWMDIE0_Pos)      /*!< PWM_T::PIER: PWMDIE0 Mask */
N
N#define PWM_PIER_PWMIE3_Pos                     3                                   /*!< PWM_T::PIER: PWMIE3 Position */
N#define PWM_PIER_PWMIE3_Msk                     (1ul << PWM_PIER_PWMIE3_Pos)        /*!< PWM_T::PIER: PWMIE3 Mask */
N
N#define PWM_PIER_PWMIE2_Pos                     2                                   /*!< PWM_T::PIER: PWMIE2 Position */
N#define PWM_PIER_PWMIE2_Msk                     (1ul << PWM_PIER_PWMIE2_Pos)        /*!< PWM_T::PIER: PWMIE2 Mask */
N
N#define PWM_PIER_PWMIE1_Pos                     1                                   /*!< PWM_T::PIER: PWMIE1 Position */
N#define PWM_PIER_PWMIE1_Msk                     (1ul << PWM_PIER_PWMIE1_Pos)        /*!< PWM_T::PIER: PWMIE1 Mask */
N
N#define PWM_PIER_PWMIE0_Pos                     0                                   /*!< PWM_T::PIER: PWMIE0 Position */
N#define PWM_PIER_PWMIE0_Msk                     (1ul << PWM_PIER_PWMIE0_Pos)        /*!< PWM_T::PIER: PWMIE0 Mask */
N
N/* PWM PIIR Bit Field Definitions */
N#define PWM_PIIR_PWMDIF3_Pos                    11                                  /*!< PWM_T::PIIR: PWMDIF3 Position */
N#define PWM_PIIR_PWMDIF3_Msk                    (1ul << PWM_PIIR_PWMDIF3_Pos)       /*!< PWM_T::PIIR: PWMDIF3 Mask */
N
N#define PWM_PIIR_PWMDIF2_Pos                    10                                  /*!< PWM_T::PIIR: PWMDIF2 Position */
N#define PWM_PIIR_PWMDIF2_Msk                    (1ul << PWM_PIIR_PWMDIF2_Pos)       /*!< PWM_T::PIIR: PWMDIF2 Mask */
N
N#define PWM_PIIR_PWMDIF1_Pos                    9                                   /*!< PWM_T::PIIR: PWMDIF1 Position */
N#define PWM_PIIR_PWMDIF1_Msk                    (1ul << PWM_PIIR_PWMDIF1_Pos)       /*!< PWM_T::PIIR: PWMDIF1 Mask */
N
N#define PWM_PIIR_PWMDIF0_Pos                    8                                   /*!< PWM_T::PIIR: PWMDIF0 Position */
N#define PWM_PIIR_PWMDIF0_Msk                    (1ul << PWM_PIIR_PWMDIF0_Pos)       /*!< PWM_T::PIIR: PWMDIF0 Mask */
N
N#define PWM_PIIR_PWMIF3_Pos                     3                                   /*!< PWM_T::PIIR: PWMIF3 Position */
N#define PWM_PIIR_PWMIF3_Msk                     (1ul << PWM_PIIR_PWMIF3_Pos)        /*!< PWM_T::PIIR: PWMIF3 Mask */
N
N#define PWM_PIIR_PWMIF2_Pos                     2                                   /*!< PWM_T::PIIR: PWMIF2 Position */
N#define PWM_PIIR_PWMIF2_Msk                     (1ul << PWM_PIIR_PWMIF2_Pos)        /*!< PWM_T::PIIR: PWMIF2 Mask */
N
N#define PWM_PIIR_PWMIF1_Pos                     1                                   /*!< PWM_T::PIIR: PWMIF1 Position */
N#define PWM_PIIR_PWMIF1_Msk                     (1ul << PWM_PIIR_PWMIF1_Pos)        /*!< PWM_T::PIIR: PWMIF1 Mask */
N
N#define PWM_PIIR_PWMIF0_Pos                     0                                   /*!< PWM_T::PIIR: PWMIF0 Position */
N#define PWM_PIIR_PWMIF0_Msk                     (1ul << PWM_PIIR_PWMIF0_Pos)        /*!< PWM_T::PIIR: PWMIF0 Mask */
N
N/* PWM CCR0 Bit Field Definitions */
N#define PWM_CCR0_CFLRI1_Pos                     23                                  /*!< PWM_T::CCR0: CFLRI1 Position */
N#define PWM_CCR0_CFLRI1_Msk                     (1ul << PWM_CCR0_CFLRI1_Pos)        /*!< PWM_T::CCR0: CFLRI1 Mask */
N
N#define PWM_CCR0_CRLRI1_Pos                     22                                  /*!< PWM_T::CCR0: CRLRI1 Position */
N#define PWM_CCR0_CRLRI1_Msk                     (1ul << PWM_CCR0_CRLRI1_Pos)        /*!< PWM_T::CCR0: CRLRI1 Mask */
N
N#define PWM_CCR0_CAPIF1_Pos                     20                                  /*!< PWM_T::CCR0: CAPIF1 Position */
N#define PWM_CCR0_CAPIF1_Msk                     (1ul << PWM_CCR0_CAPIF1_Pos)        /*!< PWM_T::CCR0: CAPIF1 Mask */
N
N#define PWM_CCR0_CAPCH1EN_Pos                   19                                  /*!< PWM_T::CCR0: CAPCH1EN Position */
N#define PWM_CCR0_CAPCH1EN_Msk                   (1ul << PWM_CCR0_CAPCH1EN_Pos)      /*!< PWM_T::CCR0: CAPCH1EN Mask */
N
N#define PWM_CCR0_CFL_IE1_Pos                    18                                  /*!< PWM_T::CCR0: CFL_IE1 Position */
N#define PWM_CCR0_CFL_IE1_Msk                    (1ul << PWM_CCR0_CFL_IE1_Pos)       /*!< PWM_T::CCR0: CFL_IE1 Mask */
N
N#define PWM_CCR0_CRL_IE1_Pos                    17                                  /*!< PWM_T::CCR0: CRL_IE1 Position */
N#define PWM_CCR0_CRL_IE1_Msk                    (1ul << PWM_CCR0_CRL_IE1_Pos)       /*!< PWM_T::CCR0: CRL_IE1 Mask */
N
N#define PWM_CCR0_INV1_Pos                       16                                  /*!< PWM_T::CCR0: INV1 Position */
N#define PWM_CCR0_INV1_Msk                       (1ul << PWM_CCR0_INV1_Pos)          /*!< PWM_T::CCR0: INV1 Mask */
N
N#define PWM_CCR0_CFLRI0_Pos                     7                                   /*!< PWM_T::CCR0: CFLRI0 Position */
N#define PWM_CCR0_CFLRI0_Msk                     (1ul << PWM_CCR0_CFLRI0_Pos)        /*!< PWM_T::CCR0: CFLRI0 Mask */
N
N#define PWM_CCR0_CRLRI0_Pos                     6                                   /*!< PWM_T::CCR0: CRLRI0 Position */
N#define PWM_CCR0_CRLRI0_Msk                     (1ul << PWM_CCR0_CRLRI0_Pos)        /*!< PWM_T::CCR0: CRLRI0 Mask */
N
N#define PWM_CCR0_CAPIF0_Pos                     4                                   /*!< PWM_T::CCR0: CAPIF0 Position */
N#define PWM_CCR0_CAPIF0_Msk                     (1ul << PWM_CCR0_CAPIF0_Pos)        /*!< PWM_T::CCR0: CAPIF0 Mask */
N
N#define PWM_CCR0_CAPCH0EN_Pos                   3                                   /*!< PWM_T::CCR0: CAPCH0EN Position */
N#define PWM_CCR0_CAPCH0EN_Msk                   (1ul << PWM_CCR0_CAPCH0EN_Pos)      /*!< PWM_T::CCR0: CAPCH0EN Mask */
N
N#define PWM_CCR0_CFL_IE0_Pos                    2                                   /*!< PWM_T::CCR0: CFL_IE0 Position */
N#define PWM_CCR0_CFL_IE0_Msk                    (1ul << PWM_CCR0_CFL_IE0_Pos)       /*!< PWM_T::CCR0: CFL_IE0 Mask */
N
N#define PWM_CCR0_CRL_IE0_Pos                    1                                   /*!< PWM_T::CCR0: CRL_IE0 Position */
N#define PWM_CCR0_CRL_IE0_Msk                    (1ul << PWM_CCR0_CRL_IE0_Pos)       /*!< PWM_T::CCR0: CRL_IE0 Mask */
N
N#define PWM_CCR0_INV0_Pos                       0                                   /*!< PWM_T::CCR0: INV0 Position */
N#define PWM_CCR0_INV0_Msk                       (1ul << PWM_CCR0_INV0_Pos)          /*!< PWM_T::CCR0: INV0 Mask */
N
N/* PWM CCR2 Bit Field Definitions */
N#define PWM_CCR2_CFLRI3_Pos                     23                                  /*!< PWM_T::CCR2: CFLRI3 Position */
N#define PWM_CCR2_CFLRI3_Msk                     (1ul << PWM_CCR2_CFLRI3_Pos)        /*!< PWM_T::CCR2: CFLRI3 Mask */
N
N#define PWM_CCR2_CRLRI3_Pos                     22                                  /*!< PWM_T::CCR2: CRLRI3 Position */
N#define PWM_CCR2_CRLRI3_Msk                     (1ul << PWM_CCR2_CRLRI3_Pos)        /*!< PWM_T::CCR2: CRLRI3 Mask */
N
N#define PWM_CCR2_CAPIF3_Pos                     20                                  /*!< PWM_T::CCR2: CAPIF3 Position */
N#define PWM_CCR2_CAPIF3_Msk                     (1ul << PWM_CCR2_CAPIF3_Pos)        /*!< PWM_T::CCR2: CAPIF3 Mask */
N
N#define PWM_CCR2_CAPCH3EN_Pos                   19                                  /*!< PWM_T::CCR2: CAPCH3EN Position */
N#define PWM_CCR2_CAPCH3EN_Msk                   (1ul << PWM_CCR2_CAPCH3EN_Pos)      /*!< PWM_T::CCR2: CAPCH3EN Mask */
N
N#define PWM_CCR2_CFL_IE3_Pos                    18                                  /*!< PWM_T::CCR2: CFL_IE3 Position */
N#define PWM_CCR2_CFL_IE3_Msk                    (1ul << PWM_CCR2_CFL_IE3_Pos)       /*!< PWM_T::CCR2: CFL_IE3 Mask */
N
N#define PWM_CCR2_CRL_IE3_Pos                    17                                  /*!< PWM_T::CCR2: CRL_IE3 Position */
N#define PWM_CCR2_CRL_IE3_Msk                    (1ul << PWM_CCR2_CRL_IE3_Pos)       /*!< PWM_T::CCR2: CRL_IE3 Mask */
N
N#define PWM_CCR2_INV3_Pos                       16                                  /*!< PWM_T::CCR2: INV3 Position */
N#define PWM_CCR2_INV3_Msk                       (1ul << PWM_CCR2_INV3_Pos)          /*!< PWM_T::CCR2: INV3 Mask */
N
N#define PWM_CCR2_CFLRI2_Pos                     7                                   /*!< PWM_T::CCR2: CFLRI2 Position */
N#define PWM_CCR2_CFLRI2_Msk                     (1ul << PWM_CCR2_CFLRI2_Pos)        /*!< PWM_T::CCR2: CFLRI2 Mask */
N
N#define PWM_CCR2_CRLRI2_Pos                     6                                   /*!< PWM_T::CCR2: CRLRI2 Position */
N#define PWM_CCR2_CRLRI2_Msk                     (1ul << PWM_CCR2_CRLRI2_Pos)        /*!< PWM_T::CCR2: CRLRI2 Mask */
N
N#define PWM_CCR2_CAPIF2_Pos                     4                                   /*!< PWM_T::CCR2: CAPIF2 Position */
N#define PWM_CCR2_CAPIF2_Msk                     (1ul << PWM_CCR2_CAPIF2_Pos)        /*!< PWM_T::CCR2: CAPIF2 Mask */
N
N#define PWM_CCR2_CAPCH2EN_Pos                   3                                   /*!< PWM_T::CCR2: CAPCH2EN Position */
N#define PWM_CCR2_CAPCH2EN_Msk                   (1ul << PWM_CCR2_CAPCH2EN_Pos)      /*!< PWM_T::CCR2: CAPCH2EN Mask */
N
N#define PWM_CCR2_CFL_IE2_Pos                    2                                   /*!< PWM_T::CCR2: CFL_IE2 Position */
N#define PWM_CCR2_CFL_IE2_Msk                    (1ul << PWM_CCR2_CFL_IE2_Pos)       /*!< PWM_T::CCR2: CFL_IE2 Mask */
N
N#define PWM_CCR2_CRL_IE2_Pos                    1                                   /*!< PWM_T::CCR2: CRL_IE2 Position */
N#define PWM_CCR2_CRL_IE2_Msk                    (1ul << PWM_CCR2_CRL_IE2_Pos)       /*!< PWM_T::CCR2: CRL_IE2 Mask */
N
N#define PWM_CCR2_INV2_Pos                       0                                   /*!< PWM_T::CCR2: INV2 Position */
N#define PWM_CCR2_INV2_Msk                       (1ul << PWM_CCR2_INV2_Pos)          /*!< PWM_T::CCR2: INV2 Mask */
N
N/* PWM CRLR Bit Field Definitions */
N#define PWM_CRLR_CRLR_Pos                       0                                   /*!< PWM_T::CRLR0: CRLR Position */
N#define PWM_CRLR_CRLR_Msk                       (0xFFFFul << PWM_CRLR_CRLR_Pos)     /*!< PWM_T::CRLR0: CRLR Mask */
N
N/* PWM CFLR Bit Field Definitions */
N#define PWM_CFLR_CFLR_Pos                       0                                   /*!< PWM_T::CFLR0: CFLR Position */
N#define PWM_CFLR_CFLR_Msk                       (0xFFFFul << PWM_CFLR_CFLR_Pos)     /*!< PWM_T::CFLR0: CFLR Mask */
N
N/* PWM CAPENR Bit Field Definitions */
N#define PWM_CAPENR_CINEN3_Pos                   3                                   /*!< PWM_T::CAPENR: CINEN3 Position */
N#define PWM_CAPENR_CINEN3_Msk                   (1ul << PWM_CAPENR_CINEN3_Pos)      /*!< PWM_T::CAPENR: CINEN3 Mask */
N
N#define PWM_CAPENR_CINEN2_Pos                   2                                   /*!< PWM_T::CAPENR: CINEN2 Position */
N#define PWM_CAPENR_CINEN2_Msk                   (1ul << PWM_CAPENR_CINEN2_Pos)      /*!< PWM_T::CAPENR: CINEN2 Mask */
N
N#define PWM_CAPENR_CINEN1_Pos                   1                                   /*!< PWM_T::CAPENR: CINEN1 Position */
N#define PWM_CAPENR_CINEN1_Msk                   (1ul << PWM_CAPENR_CINEN1_Pos)      /*!< PWM_T::CAPENR: CINEN1 Mask */
N
N#define PWM_CAPENR_CINEN0_Pos                   0                                   /*!< PWM_T::CAPENR: CINEN0 Position */
N#define PWM_CAPENR_CINEN0_Msk                   (1ul << PWM_CAPENR_CINEN0_Pos)      /*!< PWM_T::CAPENR: CINEN0 Mask */
N
N/* PWM POE Bit Field Definitions */
N#define PWM_POE_POE3_Pos                        3                                   /*!< PWM_T::POE: POE3 Position */
N#define PWM_POE_POE3_Msk                        (1ul << PWM_POE_POE3_Pos)           /*!< PWM_T::POE: POE3 Mask */
N
N#define PWM_POE_POE2_Pos                        2                                   /*!< PWM_T::POE: POE2 Position */
N#define PWM_POE_POE2_Msk                        (1ul << PWM_POE_POE2_Pos)           /*!< PWM_T::POE: POE2 Mask */
N
N#define PWM_POE_POE1_Pos                        1                                   /*!< PWM_T::POE: POE1 Position */
N#define PWM_POE_POE1_Msk                        (1ul << PWM_POE_POE1_Pos)           /*!< PWM_T::POE: POE1 Mask */
N
N#define PWM_POE_POE0_Pos                        0                                   /*!< PWM_T::POE: POE0 Position */
N#define PWM_POE_POE0_Msk                        (1ul << PWM_POE_POE0_Pos)           /*!< PWM_T::POE: POE0 Mask */
N
N/* PWM TCON Bit Field Definitions */
N
N#define PWM_TCON_PWM3TEN_Pos                    3                                   /*!< PWM_T::TCON: PWM3TEN Position */
N#define PWM_TCON_PWM3TEN_Msk                    (1ul << PWM_TCON_PWM3TEN_Pos)       /*!< PWM_T::TCON: PWM3TEN Mask */
N
N#define PWM_TCON_PWM2TEN_Pos                    2                                   /*!< PWM_T::TCON: PWM2TEN Position */
N#define PWM_TCON_PWM2TEN_Msk                    (1ul << PWM_TCON_PWM2TEN_Pos)       /*!< PWM_T::TCON: PWM2TEN Mask */
N
N#define PWM_TCON_PWM1TEN_Pos                    1                                   /*!< PWM_T::TCON: PWM1TEN Position */
N#define PWM_TCON_PWM1TEN_Msk                    (1ul << PWM_TCON_PWM1TEN_Pos)       /*!< PWM_T::TCON: PWM1TEN Mask */
N
N#define PWM_TCON_PWM0TEN_Pos                    0                                   /*!< PWM_T::TCON: PWM0TEN Position */
N#define PWM_TCON_PWM0TEN_Msk                    (1ul << PWM_TCON_PWM0TEN_Pos)       /*!< PWM_T::TCON: PWM0TEN Mask */
N
N/* PWM TSTATUS Bit Field Definitions */
N
N#define PWM_TSTATUS_PWM3TF_Pos                  3                                   /*!< PWM_T::TSTATUS: PWM3TF Position */
N#define PWM_TSTATUS_PWM3TF_Msk                  (1ul << PWM_TSTATUS_PWM3TF_Pos)     /*!< PWM_T::TSTATUS: PWM3TF Mask */
N
N#define PWM_TSTATUS_PWM2TF_Pos                  2                                   /*!< PWM_T::TSTATUS: PWM2TF Position */
N#define PWM_TSTATUS_PWM2TF_Msk                  (1ul << PWM_TSTATUS_PWM2TF_Pos)     /*!< PWM_T::TSTATUS: PWM2TF Mask */
N
N#define PWM_TSTATUS_PWM1TF_Pos                  1                                   /*!< PWM_T::TSTATUS: PWM1TF Position */
N#define PWM_TSTATUS_PWM1TF_Msk                  (1ul << PWM_TSTATUS_PWM1TF_Pos)     /*!< PWM_T::TSTATUS: PWM1TF Mask */
N
N#define PWM_TSTATUS_PWM0TF_Pos                  0                                   /*!< PWM_T::TSTATUS: PWM0TF Position */
N#define PWM_TSTATUS_PWM0TF_Msk                  (1ul << PWM_TSTATUS_PWM0TF_Pos)     /*!< PWM_T::TSTATUS: PWM0TF Mask */
N
N/* PWM SYNCBUSY0 Bit Field Definitions */
N#define PWM_SYNCBUSY0_S_BUSY_Pos                0                                   /*!< PWM_T::SYNCBUSY0: S_BUSY Position */
N#define PWM_SYNCBUSY0_S_BUSY_Msk                (1ul << PWM_SYNCBUSY0_S_BUSY_Pos)   /*!< PWM_T::SYNCBUSY0: S_BUSY Mask */
N
N/* PWM SYNCBUSY1 Bit Field Definitions */
N#define PWM_SYNCBUSY1_S_BUSY_Pos                0                                   /*!< PWM_T::SYNCBUSY1: S_BUSY Position */
N#define PWM_SYNCBUSY1_S_BUSY_Msk                (1ul << PWM_SYNCBUSY1_S_BUSY_Pos)   /*!< PWM_T::SYNCBUSY1: S_BUSY Mask */
N
N/* PWM SYNCBUSY2 Bit Field Definitions */
N#define PWM_SYNCBUSY2_S_BUSY_Pos                0                                   /*!< PWM_T::SYNCBUSY2: S_BUSY Position */
N#define PWM_SYNCBUSY2_S_BUSY_Msk                (1ul << PWM_SYNCBUSY2_S_BUSY_Pos)   /*!< PWM_T::SYNCBUSY2: S_BUSY Mask */
N
N/* PWM SYNCBUSY3 Bit Field Definitions */
N#define PWM_SYNCBUSY3_S_BUSY_Pos                0                                   /*!< PWM_T::SYNCBUSY3: S_BUSY Position */
N#define PWM_SYNCBUSY3_S_BUSY_Msk                (1ul << PWM_SYNCBUSY3_S_BUSY_Pos)   /*!< PWM_T::SYNCBUSY3: S_BUSY Mask */
N/*@}*/ /* end of group PWM_CONST */
N/*@}*/ /* end of group PWM */
N
N
N/*---------------------- Real Time Clock Controller -------------------------*/
N/**
N    @addtogroup RTC Real Time Clock Controller (RTC)
N    Memory Mapped Structure for RTC Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N/**
N * @var RTC_T::INIR
N * Offset: 0x00  RTC Initiation Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |INIR0_Active|RTC Active Status (Read Only)
N * |        |          |0 = RTC is at reset state.
N * |        |          |1 = RTC is at normal active state.
N * |[31:1]  |INIR[31:1]|RTC Initiation
N * |        |          |When RTC block is powered on, RTC is at reset state.
N * |        |          |User has to write a number (0xa5eb1357) to INIR to make RTC leaving reset state.
N * |        |          |Once the INIR is written as 0xa5eb1357, the RTC will be in un-reset state permanently.
N * |        |          |The INIR is a write-only field and read value will be always 0.
N * @var RTC_T::AER
N * Offset: 0x04  RTC Access Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |AER       |RTC Register Access Enable Password (Write Only)
N * |        |          |Writing 0xA965 to this register will enable RTC access and keep 1024 RTC clocks.
N * |[16]    |ENF       |RTC Register Access Enable Flag (Read Only)
N * |        |          |0 = RTC register read/write access Disabled.
N * |        |          |1 = RTC register read/write access Enabled.
N * |        |          |This bit will be set after AER[15:0] is load a 0xA965, and will be cleared automatically after
N * |        |          |1024 RTC clocks.
N * @var RTC_T::FCR
N * Offset: 0x08  RTC Frequency Compensation Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[5:0]   |FRACTION  |Fraction Part
N * |        |          |Formula = (fraction part of detected value) x 60.
N * |        |          |Note: Digit in FCR must be expressed as hexadecimal number.
N * |[11:8]  |INTEGER   |Integer Part
N * @var RTC_T::TLR
N * Offset: 0x0C  Time Loading Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |1SEC      |1-Sec Time Digit (0~9)
N * |[6:4]   |10SEC     |10-Sec Time Digit (0~5)
N * |[11:8]  |1MIN      |1-Min Time Digit (0~9)
N * |[14:12] |10MIN     |10-Min Time Digit (0~5)
N * |[19:16] |1HR       |1-Hour Time Digit (0~9)
N * |[21:20] |10HR      |10-Hour Time Digit (0~2)
N * @var RTC_T::CLR
N * Offset: 0x10  Calendar Loading Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |1DAY      |1-Day Calendar Digit (0~9)
N * |[5:4]   |10DAY     |10-Day Calendar Digit (0~3)
N * |[11:8]  |1MON      |1-Month Calendar Digit (0~9)
N * |[12]    |10MON     |10-Month Calendar Digit (0~1)
N * |[19:16] |1YEAR     |1-Year Calendar Digit (0~9)
N * |[23:20] |10YEAR    |10-Year Calendar Digit (0~9)
N * @var RTC_T::TSSR
N * Offset: 0x14  Time Scale Selection Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |24H_12H   |24-Hour / 12-Hour Time Scale Selection
N * |        |          |It indicates that RTC TLR and TAR counter are in 24-hour time scale or 12-hour time scale.
N * |        |          |0 = 24-hour time scale selected.
N * |        |          |1 = 24-hour time scale selected.
N * @var RTC_T::DWR
N * Offset: 0x18  Day of the Week Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[2:0]   |DWR       |Day Of The Week Register
N * |        |          |000 = Sunday.
N * |        |          |001 = Monday.
N * |        |          |010 = Tuesday.
N * |        |          |011 = Wednesday.
N * |        |          |100 = Thursday.
N * |        |          |101 = Friday.
N * |        |          |110 = Saturday.
N * |        |          |111 = Reserved.
N * @var RTC_T::TAR
N * Offset: 0x1C  Time Alarm Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |1SEC      |1-Sec Time Digit of Alarm Setting (0~9)
N * |[6:4]   |10SEC     |10-Sec Time Digit of Alarm Setting (0~5)
N * |[11:8]  |1MIN      |1-Min Time Digit of Alarm Setting (0~9)
N * |[14:12] |10MIN     |10-Min Time Digit of Alarm Setting (0~5)
N * |[19:16] |1HR       |1-Hour Time Digit of Alarm Setting (0~9)
N * |[21:20] |10HR      |10-Hour Time Digit of Alarm Setting (0~2)
N * @var RTC_T::CAR
N * Offset: 0x20  Calendar Alarm Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |1DAY      |1-Day Calendar Digit of Alarm Setting (0~9)
N * |[5:4]   |10DAY     |10-Day Calendar Digit of Alarm Setting (0~3)
N * |[11:8]  |1MON      |1-Month Calendar Digit of Alarm Setting (0~9)
N * |[12]    |10MON     |10-Month Calendar Digit of Alarm Setting (0~1)
N * |[19:16] |1YEAR     |1-Year Calendar Digit of Alarm Setting (0~9)
N * |[23:20] |10YEAR    |10-Year Calendar Digit of Alarm Setting (0~9)
N * @var RTC_T::LIR
N * Offset: 0x24  Leap Year Indicator Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |LIR       |Leap Year Indication Register (Read Only)
N * |        |          |0 = This year is not a leap year.
N * |        |          |1 = This year is a leap year.
N * @var RTC_T::RIER
N * Offset: 0x28  RTC Interrupt Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |AIER      |Alarm Interrupt Enable
N * |        |          |This bit is used to enable/disable RTC Alarm Interrupt, and generate an interrupt signal if AIF
N * |        |          |(RIIR[0] RTC Alarm Interrupt Flag) is set to 1.
N * |        |          |0 = RTC Alarm Interrupt Disabled.
N * |        |          |1 = RTC Alarm Interrupt Enabled.
N * |        |          |Note: This bit will also trigger a wake-up event while system runs in Idle/Power-down mode and
N * |        |          |RTC Alarm Interrupt signal generated.
N * |[1]     |TIER      |Time Tick Interrupt Enable
N * |        |          |This bit is used to enable/disable RTC Time Tick Interrupt, and generate an interrupt signal if
N * |        |          |TIF (RIIR[1] RTC Time Tick Interrupt Flag) is set to 1.
N * |        |          |0 = RTC Time Tick Interrupt Disabled.
N * |        |          |1 = RTC Time Tick Interrupt Enabled.
N * |        |          |Note: This bit will also trigger a wake-up event while system runs in Idle/Power-down mode and
N * |        |          |RTC Time Tick Interrupt signal generated.
N * |[2]     |SNOOPIER  |Snoop Detection Interrupt Enable
N * |        |          |This bit is used to enable/disable RTC Snoop Detection Interrupt, and generate an interrupt
N * |        |          |signal if SNOOPIF (RIIR[2] RTC Snoop Detection Interrupt Flag) is set to 1.
N * |        |          |0 = Snoop detected interrupt Disabled.
N * |        |          |1 = Snoop detected interrupt Enabled.
N * |        |          |Note: This bit will also trigger a wake-up event while system runs in Idle/Power-down mode and
N * |        |          |RTC Snoop Interrupt signal generated.
N * @var RTC_T::RIIR
N * Offset: 0x2C  RTC Interrupt Indicator Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |AIF       |RTC Alarm Interrupt Flag
N * |        |          |When RTC time counters TLR and CLR match the alarm setting time registers TAR and CAR, this bit
N * |        |          |will be set to 1 and an interrupt will be generated if RTC Alarm Interrupt enabled AIER
N * |        |          |(RIER[0]) is set to 1.
N * |        |          |Chip will be wake-up if RTC Alarm Interrupt is enabled when chip is at Power-down mode.
N * |        |          |0 = Alarm condition is not matched.
N * |        |          |1 = Alarm condition is matched.
N * |        |          |Note: Write 1 to clear this bit.
N * |[1]     |TIF       |RTC Time Tick Interrupt Flag
N * |        |          |When RTC time tick happened, this bit will be set to 1 and an interrupt will be generated if RTC
N * |        |          |Tick Interrupt enabled TIER (RIER[1]) is set to 1.
N * |        |          |Chip will also be wake-up if RTC Tick Interrupt is enabled and this bit is set to 1 when chip is
N * |        |          |running at Power-down mode.
N * |        |          |0 = Tick condition does not occur.
N * |        |          |1 = Tick condition occur.
N * |        |          |Note: Write 1 to clear to clear this bit.
N * |[2]     |SNOOPIF   |Snoop Detection Interrupt Flag
N * |        |          |When snooper pin transition event is detected, this bit is set to 1 and an interrupt is
N * |        |          |generated if Snoop Detection Interrupt enabled SNOOPIER (RIER[2]) is set to1.
N * |        |          |Chip will be wake-up from Power-down mode if Snoop Detection Interrupt is enabled.
N * |        |          |0 = No snoop event is detected.
N * |        |          |1 = Snoop event is detected.
N * |        |          |Note: Write 1 to clear this bit.
N * @var RTC_T::TTR
N * Offset: 0x30  RTC Time Tick Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[2:0]   |TTR       |Time Tick Register
N * |        |          |These bits are used to select RTC time tick period for Periodic Time Tick Interrupt request.
N * |        |          |000 = Time tick is 1 second.
N * |        |          |001 = Time tick is 1/2 second.
N * |        |          |010 = Time tick is 1/4 second.
N * |        |          |011 = Time tick is 1/8 second.
N * |        |          |100 = Time tick is 1/16 second.
N * |        |          |101 = Time tick is 1/32 second.
N * |        |          |110 = Time tick is 1/64 second.
N * |        |          |111 = Time tick is 1/28 second.
N * |        |          |Note: This register can be read back after the RTC register access enable bit ENF (AER[16]) is
N * |        |          |active.
N * @var RTC_T::SPRCTL
N * Offset: 0x3C  RTC Spare Functional Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |SNOOPEN   |Snoop Detection Enable
N * |        |          |0 = Snoop detection function Disabled.
N * |        |          |1 = Snoop detection function Enabled.
N * |[1]     |SNOOPLEVEL|Snoop Detection Level Selection
N * |        |          |This bit controls snoop detect event is high level/rising edge or low level/falling edge.
N * |        |          |0 = Low level/Falling edge detection.
N * |        |          |1 = High level/Rising edge detection.
N * |[2]     |SPREN     |SPR Register Enable
N * |        |          |0 = Spare register is Disabled.
N * |        |          |1 = Spare register is Enabled.
N * |        |          |Note: When spare register is disabled, RTC SPR0 ~ SPR19 cannot be accessed.
N * |[3]     |SNOOPMODE |Snoop Detection Mode Selection
N * |        |          |This bit controls snoop detect event is edge or level detection.
N * |        |          |0 = Level detection.
N * |        |          |1 = Edge detection.
N * |[5]     |SPRCFLG   |Spare Register Clear Flag
N * |        |          |This bit indicates if the SPR0 ~ SPR19 content is cleared when snoop specify event is detected.
N * |        |          |0 = Spare register content is not cleared.
N * |        |          |1 = Spare register content is cleared.
N * |        |          |Note: Writes 1 to clear this bit.
N * |[7]     |SPRRDY    |SPR Register Ready
N * |        |          |This bit indicates if the registers SPRCTL, SPR0 ~ SPR19 are ready to be accessed.
N * |        |          |After user writing registers SPRCTL, SPR0 ~ SPR19, read this bit to check if these registers are
N * |        |          |updated done is necessary.
N * |        |          |0 = SPRCTL, SPR0 ~ SPR19 updating is in progress.
N * |        |          |1 = SPRCTL, SPR0 ~ SPR19 are updated done and ready to be accessed.
N * |        |          |Note: This bit is read only and any write to it won't take any effect.
N * @var RTC_T::SPR
N * Offset: 0x40  RTC Spare Register 0 ~ 19
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |SPARE     |SPARE Register
N * |        |          |This field is used to store back-up information defined by software.
N * |        |          |This field will be cleared by hardware automatically once a snooper pin event is detected.
N * |        |          |Before store back-up information in to SPARE register, software should write 0xA965 to AER to
N * |        |          |make sure register read/write enable.
N */
N
N    __IO uint32_t INIR;          /* Offset: 0x00  RTC Initiation Register                                            */
X    volatile uint32_t INIR;           
N    __IO uint32_t AER;           /* Offset: 0x04  RTC Access Enable Register                                         */
X    volatile uint32_t AER;            
N    __IO uint32_t FCR;           /* Offset: 0x08  RTC Frequency Compensation Register                                */
X    volatile uint32_t FCR;            
N    __IO uint32_t TLR;           /* Offset: 0x0C  Time Loading Register                                              */
X    volatile uint32_t TLR;            
N    __IO uint32_t CLR;           /* Offset: 0x10  Calendar Loading Register                                          */
X    volatile uint32_t CLR;            
N    __IO uint32_t TSSR;          /* Offset: 0x14  Time Scale Selection Register                                      */
X    volatile uint32_t TSSR;           
N    __IO uint32_t DWR;           /* Offset: 0x18  Day of the Week Register                                           */
X    volatile uint32_t DWR;            
N    __IO uint32_t TAR;           /* Offset: 0x1C  Time Alarm Register                                                */
X    volatile uint32_t TAR;            
N    __IO uint32_t CAR;           /* Offset: 0x20  Calendar Alarm Register                                            */
X    volatile uint32_t CAR;            
N    __I  uint32_t LIR;           /* Offset: 0x24  Leap Year Indicator Register                                       */
X    volatile const  uint32_t LIR;            
N    __IO uint32_t RIER;          /* Offset: 0x28  RTC Interrupt Enable Register                                      */
X    volatile uint32_t RIER;           
N    __IO uint32_t RIIR;          /* Offset: 0x2C  RTC Interrupt Indicator Register                                   */
X    volatile uint32_t RIIR;           
N    __IO uint32_t TTR;           /* Offset: 0x30  RTC Time Tick Register                                             */
X    volatile uint32_t TTR;            
N    __I  uint32_t RESERVED[2];  
X    volatile const  uint32_t RESERVED[2];  
N    __IO uint32_t SPRCTL;        /* Offset: 0x3C  RTC Spare Functional Control Register                              */
X    volatile uint32_t SPRCTL;         
N    __IO uint32_t SPR[20];       /* Offset: 0x40  RTC Spare Register 0 ~ 19                                          */
X    volatile uint32_t SPR[20];        
N
N} RTC_T;
N
N
N/**
N    @addtogroup RTC_CONST RTC Bit Field Definition
N    Constant Definitions for RTC Controller
N@{ */
N
N
N
N/* RTC INIR Bit Field Definitions */
N#define RTC_INIR_INIR_Pos       0                                               /*!< RTC_T::INIR: INIR Position */
N#define RTC_INIR_INIR_Msk       (0xFFFFFFFFul << RTC_INIR_INIR_Pos)             /*!< RTC_T::INIR: INIR Mask */
N
N#define RTC_INIR_ACTIVE_Pos     0                                               /*!< RTC_T::INIR: ACTIVE Position */
N#define RTC_INIR_ACTIVE_Msk     (1ul << RTC_INIR_ACTIVE_Pos)                    /*!< RTC_T::INIR: ACTIVE Mask */
N
N/* RTC AER Bit Field Definitions */
N#define RTC_AER_ENF_Pos         16                                              /*!< RTC_T::AER: ENF Position */
N#define RTC_AER_ENF_Msk         (1ul << RTC_AER_ENF_Pos)                        /*!< RTC_T::AER: ENF Mask */
N
N#define RTC_AER_AER_Pos         0                                               /*!< RTC_T::AER: AER Position */
N#define RTC_AER_AER_Msk         (0xFFFFul << RTC_AER_AER_Pos)                   /*!< RTC_T::AER: AER Mask */
N
N/* RTC FCR Bit Field Definitions */
N#define RTC_FCR_INTEGER_Pos     8                                               /*!< RTC_T::FCR: INTEGER Position */
N#define RTC_FCR_INTEGER_Msk     (0xFul << RTC_FCR_INTEGER_Pos)                  /*!< RTC_T::FCR: INTEGER Mask */
N
N#define RTC_FCR_FRACTION_Pos    0                                               /*!< RTC_T::FCR: FRACTION Position */
N#define RTC_FCR_FRACTION_Msk    (0x3Ful << RTC_FCR_FRACTION_Pos)                /*!< RTC_T::FCR: FRACTION Mask */
N
N/* RTC TLR Bit Field Definitions */
N#define RTC_TLR_10HR_Pos        20                                              /*!< RTC_T::TLR: 10HR Position */
N#define RTC_TLR_10HR_Msk        (0x3ul << RTC_TLR_10HR_Pos)                     /*!< RTC_T::TLR: 10HR Mask */
N
N#define RTC_TLR_1HR_Pos         16                                              /*!< RTC_T::TLR: 1HR Position */
N#define RTC_TLR_1HR_Msk         (0xFul << RTC_TLR_1HR_Pos)                      /*!< RTC_T::TLR: 1HR Mask */
N
N#define RTC_TLR_10MIN_Pos       12                                              /*!< RTC_T::TLR: 10MIN Position */
N#define RTC_TLR_10MIN_Msk       (0x7ul << RTC_TLR_10MIN_Pos)                    /*!< RTC_T::TLR: 10MIN Mask */
N
N#define RTC_TLR_1MIN_Pos        8                                               /*!< RTC_T::TLR: 1MIN Position */
N#define RTC_TLR_1MIN_Msk        (0xFul << RTC_TLR_1MIN_Pos)                     /*!< RTC_T::TLR: 1MIN Mask */
N
N#define RTC_TLR_10SEC_Pos       4                                               /*!< RTC_T::TLR: 10SEC Position */
N#define RTC_TLR_10SEC_Msk       (0x7ul << RTC_TLR_10SEC_Pos)                    /*!< RTC_T::TLR: 10SEC Mask */
N
N#define RTC_TLR_1SEC_Pos        0                                               /*!< RTC_T::TLR: 1SEC Position */
N#define RTC_TLR_1SEC_Msk        (0xFul << RTC_TLR_1SEC_Pos)                     /*!< RTC_T::TLR: 1SEC Mask */
N
N/* RTC CLR Bit Field Definitions */
N#define RTC_CLR_10YEAR_Pos      20                                              /*!< RTC_T::CLR: 10YEAR Position */
N#define RTC_CLR_10YEAR_Msk      (0xFul << RTC_CLR_10YEAR_Pos)                   /*!< RTC_T::CLR: 10YEAR Mask */
N
N#define RTC_CLR_1YEAR_Pos       16                                              /*!< RTC_T::CLR: 1YEAR Position */
N#define RTC_CLR_1YEAR_Msk       (0xFul << RTC_CLR_1YEAR_Pos)                    /*!< RTC_T::CLR: 1YEAR Mask */
N
N#define RTC_CLR_10MON_Pos       12                                              /*!< RTC_T::CLR: 10MON Position */
N#define RTC_CLR_10MON_Msk       (1ul << RTC_CLR_10MON_Pos)                      /*!< RTC_T::CLR: 10MON Mask */
N
N#define RTC_CLR_1MON_Pos        8                                               /*!< RTC_T::CLR: 1MON Position */
N#define RTC_CLR_1MON_Msk        (0xFul << RTC_CLR_1MON_Pos)                     /*!< RTC_T::CLR: 1MON Mask */
N
N#define RTC_CLR_10DAY_Pos       4                                               /*!< RTC_T::CLR: 10DAY Position */
N#define RTC_CLR_10DAY_Msk       (0x3ul << RTC_CLR_10DAY_Pos)                    /*!< RTC_T::CLR: 10DAY Mask */
N
N#define RTC_CLR_1DAY_Pos        0                                               /*!< RTC_T::CLR: 1DAY Position */
N#define RTC_CLR_1DAY_Msk        (0xFul << RTC_CLR_1DAY_Pos)                     /*!< RTC_T::CLR: 1DAY Mask */
N
N/* RTC TSSR Bit Field Definitions */
N#define RTC_TSSR_24H_12H_Pos    0                                               /*!< RTC_T::TSSR: 24H_12H Position */
N#define RTC_TSSR_24H_12H_Msk    (1ul << RTC_TSSR_24H_12H_Pos)                   /*!< RTC_T::TSSR: 24H_12H Mask */
N
N/* RTC DWR Bit Field Definitions */
N#define RTC_DWR_DWR_Pos         0                                               /*!< RTC_T::DWR: DWR Position */
N#define RTC_DWR_DWR_Msk         (0x7ul << RTC_DWR_DWR_Pos)                      /*!< RTC_T::DWR: DWR Mask */
N
N/* RTC TAR Bit Field Definitions */
N#define RTC_TAR_10HR_Pos        20                                              /*!< RTC_T::TAR: 10HR Position */
N#define RTC_TAR_10HR_Msk        (0x3ul << RTC_TAR_10HR_Pos)                     /*!< RTC_T::TAR: 10HR Mask */
N
N#define RTC_TAR_1HR_Pos         16                                              /*!< RTC_T::TAR: 1HR Position */
N#define RTC_TAR_1HR_Msk         (0xFul << RTC_TAR_1HR_Pos)                      /*!< RTC_T::TAR: 1HR Mask */
N
N#define RTC_TAR_10MIN_Pos       12                                              /*!< RTC_T::TAR: 10MIN Position */
N#define RTC_TAR_10MIN_Msk       (0x7ul << RTC_TAR_10MIN_Pos)                    /*!< RTC_T::TAR: 10MIN Mask */
N
N#define RTC_TAR_1MIN_Pos        8                                               /*!< RTC_T::TAR: 1MIN Position */
N#define RTC_TAR_1MIN_Msk        (0xFul << RTC_TAR_1MIN_Pos)                     /*!< RTC_T::TAR: 1MIN Mask */
N
N#define RTC_TAR_10SEC_Pos       4                                               /*!< RTC_T::TAR: 10SEC Position */
N#define RTC_TAR_10SEC_Msk       (0x7ul << RTC_TAR_10SEC_Pos)                    /*!< RTC_T::TAR: 10SEC Mask */
N
N#define RTC_TAR_1SEC_Pos        0                                               /*!< RTC_T::TAR: 1SEC Position */
N#define RTC_TAR_1SEC_Msk        (0xFul << RTC_TAR_1SEC_Pos)                     /*!< RTC_T::TAR: 1SEC Mask */
N
N/* RTC CAR Bit Field Definitions */
N#define RTC_CAR_10YEAR_Pos      20                                              /*!< RTC_T::CAR: 10YEAR Position */
N#define RTC_CAR_10YEAR_Msk      (0xFul << RTC_CAR_10YEAR_Pos)                   /*!< RTC_T::CAR: 10YEAR Mask */
N
N#define RTC_CAR_1YEAR_Pos       16                                              /*!< RTC_T::CAR: 1YEAR Position */
N#define RTC_CAR_1YEAR_Msk       (0xFul << RTC_CAR_1YEAR_Pos)                    /*!< RTC_T::CAR: 1YEAR Mask */
N
N#define RTC_CAR_10MON_Pos       12                                              /*!< RTC_T::CAR: 10MON Position */
N#define RTC_CAR_10MON_Msk       (1ul << RTC_CAR_10MON_Pos)                      /*!< RTC_T::CAR: 10MON Mask */
N
N#define RTC_CAR_1MON_Pos        8                                               /*!< RTC_T::CAR: 1MON Position */
N#define RTC_CAR_1MON_Msk        (0xFul << RTC_CAR_1MON_Pos)                     /*!< RTC_T::CAR: 1MON Mask */
N
N#define RTC_CAR_10DAY_Pos       4                                               /*!< RTC_T::CAR: 10DAY Position */
N#define RTC_CAR_10DAY_Msk       (0x3ul << RTC_CAR_10DAY_Pos)                    /*!< RTC_T::CAR: 10DAY Mask */
N
N#define RTC_CAR_1DAY_Pos        0                                               /*!< RTC_T::CAR: 1DAY Position */
N#define RTC_CAR_1DAY_Msk        (0xFul << RTC_CAR_1DAY_Pos)                     /*!< RTC_T::CAR: 1DAY Mask */
N
N/* RTC LIR Bit Field Definitions */
N#define RTC_LIR_LIR_Pos         0                                               /*!< RTC_T::LIR: LIR Position */
N#define RTC_LIR_LIR_Msk         (1ul << RTC_LIR_LIR_Pos)                        /*!< RTC_T::LIR: LIR Mask */
N
N/* RTC RIER Bit Field Definitions */
N#define RTC_RIER_SNOOPIER_Pos   2                                               /*!< RTC_T::RIER: SNOOPIER Position */
N#define RTC_RIER_SNOOPIER_Msk   (1ul << RTC_RIER_SNOOPIER_Pos)                  /*!< RTC_T::RIER: SNOOPIER Mask */
N
N#define RTC_RIER_TIER_Pos       1                                               /*!< RTC_T::RIER: TIER Position */
N#define RTC_RIER_TIER_Msk       (1ul << RTC_RIER_TIER_Pos)                      /*!< RTC_T::RIER: TIER Mask */
N
N#define RTC_RIER_AIER_Pos       0                                               /*!< RTC_T::RIER: AIER Position */
N#define RTC_RIER_AIER_Msk       (1ul << RTC_RIER_AIER_Pos)                      /*!< RTC_T::RIER: AIER Mask */
N
N/* RTC RIIR Bit Field Definitions */
N#define RTC_RIIR_SNOOPIF_Pos    2                                               /*!< RTC_T::RIIR: SNOOPIF Position */
N#define RTC_RIIR_SNOOPIF_Msk    (1ul << RTC_RIIR_SNOOPIF_Pos)                   /*!< RTC_T::RIIR: SNOOPIF Mask */
N
N#define RTC_RIIR_TIF_Pos        1                                               /*!< RTC_T::RIIR: TIF Position */
N#define RTC_RIIR_TIF_Msk        (1ul << RTC_RIIR_TIF_Pos)                       /*!< RTC_T::RIIR: TIF Mask */
N
N#define RTC_RIIR_AIF_Pos        0                                               /*!< RTC_T::RIIR: AIF Position */
N#define RTC_RIIR_AIF_Msk        (1ul << RTC_RIIR_AIF_Pos)                       /*!< RTC_T::RIIR: AIF Mask */
N
N/* RTC TTR Bit Field Definitions */
N#define RTC_TTR_TTR_Pos         0                                               /*!< RTC_T::TTR: TTR Position */
N#define RTC_TTR_TTR_Msk         (0x7ul << RTC_TTR_TTR_Pos)                      /*!< RTC_T::TTR: TTR Mask */
N
N/* RTC SPRCTL Bit Field Definitions */
N#define RTC_SPRCTL_SPRRDY_Pos       7                                           /*!< RTC_T::SPRCTL: SPRRDY Position */
N#define RTC_SPRCTL_SPRRDY_Msk       (1ul << RTC_SPRCTL_SPRRDY_Pos)              /*!< RTC_T::SPRCTL: SPRRDY Mask */
N
N#define RTC_SPRCTL_SPRCFLG_Pos      5                                           /*!< RTC_T::SPRCTL: SPRCFLG Position */
N#define RTC_SPRCTL_SPRCFLG_Msk      (1ul << RTC_SPRCTL_SPRCFLG_Pos)             /*!< RTC_T::SPRCTL: SPRCFLG Mask */
N
N#define RTC_SPRCTL_SNOOPMODE_Pos    3                                           /*!< RTC_T::SPRCTL: SNOOPMODE Position */
N#define RTC_SPRCTL_SNOOPMODE_Msk    (1ul << RTC_SPRCTL_SNOOPMODE_Pos)           /*!< RTC_T::SPRCTL: SNOOPMODE Mask */
N
N#define RTC_SPRCTL_SPREN_Pos        2                                           /*!< RTC_T::SPRCTL: SPREN Position */
N#define RTC_SPRCTL_SPREN_Msk        (1ul << RTC_SPRCTL_SPREN_Pos)               /*!< RTC_T::SPRCTL: SPREN Mask */
N
N#define RTC_SPRCTL_SNOOPLEVEL_Pos   1                                           /*!< RTC_T::SPRCTL: SNOOPLEVEL Position */
N#define RTC_SPRCTL_SNOOPLEVEL_Msk   (1ul << RTC_SPRCTL_SNOOPLEVEL_Pos)          /*!< RTC_T::SPRCTL: SNOOPLEVEL Mask */
N
N#define RTC_SPRCTL_SNOOPEN_Pos      0                                           /*!< RTC_T::SPRCTL: SNOOPEN Position */
N#define RTC_SPRCTL_SNOOPEN_Msk      (1ul << RTC_SPRCTL_SNOOPEN_Pos)             /*!< RTC_T::SPRCTL: SNOOPEN Mask */
N/*@}*/ /* end of group RTC_CONST */
N/*@}*/ /* end of group RTC */
N
N
N/*---------------------- Smart Card Host Interface Controller -------------------------*/
N/**
N    @addtogroup SC Smart Card Host Interface Controller (SC)
N    Memory Mapped Structure for SC Controller
N@{ */
N
N
N
Ntypedef struct
N{
N
N
N    /**
N * @var SC_T::RBR
N * Offset: 0x00  SC Receiving Buffer Register.
N    * ---------------------------------------------------------------------------------------------------
N    * |Bits    |Field     |Descriptions
N    * | :----: | :----:   | :---- |
N    * |[7:0]   |RBR       |Receiving Buffer
N    * |        |          |By reading RBR, the SC will return an 8-bit received data.
N * @var SC_T::THR
N * Offset: 0x00  SC Transmit Holding Register
N     * ---------------------------------------------------------------------------------------------------
N     * |Bits    |Field     |Descriptions
N     * | :----: | :----:   | :---- |
N     * |[7:0]   |THR       |Transmit Holding Buffer
N     * |        |          |By writing data to THR, the SC will send out an 8-bit data.
N     * |        |          |Note: If SC_CEN(SC_CTL[0]) is not enabled, THR cannot be programmed.
N * @var SC_T::CTL
N * Offset: 0x04  SC Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |SC_CEN    |SC Engine Enable Control
N * |        |          |Set this bit to 1 to enable SC operation.
N * |        |          |If this bit is cleared, SC will force all transition to IDLE state.
N * |[1]     |DIS_RX    |RX Transition Disable Control
N * |        |          |0 = The receiver Enabled.
N * |        |          |1 = The receiver Disabled.
N * |        |          |Note:
N * |        |          |If AUTO_CON_EN (SC_CTL[3])is enabled, these fields must be ignored.
N * |[2]     |DIS_TX    |TX Transition Disable Control
N * |        |          |0 = The transceiver Enabled.
N * |        |          |1 = The transceiver Disabled.
N * |[3]     |AUTO_CON_EN|Auto Convention Enable Control
N * |        |          |0 = Auto-convention Disabled.
N * |        |          |1 = Auto-convention Enabled.
N * |        |          |When hardware receives TS in answer to reset state and the TS is direct convention,
N * |        |          |CON_SEL(SC_CTL[5:4]) will be set to 00 automatically, otherwise if the TS is inverse convention,
N * |        |          |and CON_SEL (SC_CTL[5:4]) will be set to 11.
N * |        |          |If software enables auto convention function, the setting step must be done before Answer to
N * |        |          |Reset state and the first data must be 0x3B or 0x3F.
N * |        |          |After hardware received first data and stored it at buffer, hardware will decided the convention
N * |        |          |and change the CON_SEL (SC_CTL[5:4]) bits automatically.
N * |        |          |If the first data is not 0x3B or 0x3F, hardware will generate an interrupt INT_ACON_ERR (if
N * |        |          |ACON_ERR IE (SC_IER[10]) = 1) to CPU.
N * |[5:4]   |CON_SEL   |Convention Selection
N * |        |          |00 = Direct convention.
N * |        |          |01 = Reserved.
N * |        |          |10 = Reserved.
N * |        |          |11 = Inverse convention.
N * |        |          |Note:
N * |        |          |If AUTO_CON_EN(SC_CTL[3]) enabled, this fields are ignored.
N * |[7:6]   |RX_FTRI_LEV|Rx Buffer Trigger Level
N * |        |          |When the number of bytes in the receiving buffer equals the RX_FTRI_LEV, the RDA_IF will be set
N * |        |          |(if IER [RDA_IEN] is enabled, an interrupt will be generated).
N * |        |          |00 = INTR_RDA Trigger Level with 01 Bytes.
N * |        |          |01 = INTR_RDA Trigger Level with 02 Bytes.
N * |        |          |10 = INTR_RDA Trigger Level with 03 Bytes.
N * |        |          |11 = Reserved.
N * |[12:8]  |BGT       |Block Guard Time (BGT)
N * |        |          |Block guard time means the minimum bit length between the leading edges of two consecutive
N * |        |          |characters between different transfer directions.
N * |        |          |This field indicates the counter for the bit length of block guard time.
N * |        |          |According to ISO7816-3, in T = 0 mode, software must fill 15 (real block guard time = 16.5) to
N * |        |          |this field; in T = 1 mode, software must fill 21 (real block guard time = 22.5) to it.
N * |        |          |Note:
N * |        |          |The real block guard time is BGT + 1.
N * |[14:13] |TMR_SEL   |Timer Selection
N * |        |          |00 = All internal timer function Disabled.
N * |        |          |01 = Internal 24 bit timer Enabled.
N * |        |          |Software can configure it by setting SC_TMR0 [23:0].
N * |        |          |SC_TMR1 and SC_TMR2 will be ignored in this mode.
N * |        |          |10 = internal 24 bit timer and 8 bit internal timer Enabled.
N * |        |          |Software can configure the 24 bit timer by setting SC_TMR0 [23:0] and configure the 8 bit timer
N * |        |          |by setting SC_TMR1[7:0].
N * |        |          |SC_TMR2 will be ignored in this mode.
N * |        |          |11 = Internal 24 bit timer and two 8 bit timers Enabled.
N * |        |          |Software can configure them by setting SC_TMR0 [23:0], SC_TMR1 [7:0] and SC_TMR2 [7:0].
N * |[15]    |SLEN      |Stop Bit Length
N * |        |          |This field indicates the length of stop bit.
N * |        |          |0 = The stop bit length is 2 ETU.
N * |        |          |1= The stop bit length is 1 ETU.
N * |        |          |Note:
N * |        |          |The default stop bit length is 2. SMC and UART adopts SLEN to program the stop bit length
N * |[18:16] |RX_ERETRY |RX Error Retry Count Number
N * |        |          |This field indicates the maximum number of receiver retries that are allowed when parity error
N * |        |          |has occurred
N * |        |          |Note1: The real retry number is RX_ERETRY + 1, so 8 is the maximum retry number.
N * |        |          |Note2: This field cannot be changed when RX_ERETRY_EN enabled.
N * |        |          |The change flow is to disable RX_ETRTRY_EN first and then fill in new retry value.
N * |[19]    |RX_ERETRY_EN|RX Error Retry Enable Control
N * |        |          |This bit enables receiver retry function when parity error has occurred.
N * |        |          |0 = RX error retry function Disabled.
N * |        |          |1 = RX error retry function Enabled.
N * |        |          |Note: Software must fill in the RX_ERETRY value before enabling this bit.
N * |[22:20] |TX_ERETRY |TX Error Retry Count Number
N * |        |          |This field indicates the maximum number of transmitter retries that are allowed when parity
N * |        |          |error has occurred.
N * |        |          |Note1: The real retry number is TX_ERETRY + 1, so 8 is the maximum retry number.
N * |        |          |Note2: This field cannot be changed when TX_ERETRY_EN enabled.
N * |        |          |The change flow is to disable TX_ETRTRY_EN first and then fill in new retry value.
N * |[23]    |TX_ERETRY_EN|TX Error Retry Enable Control
N * |        |          |This bit enables transmitter retry function when parity error has occurred.
N * |        |          |0 = TX error retry function Disabled.
N * |        |          |1 = TX error retry function Enabled.
N * |[25:24] |CD_DEB_SEL|Card Detect De-Bounce Selection
N * |        |          |This field indicates the card detect de-bounce selection.
N * |        |          |00 = De-bounce sample card insert once per 384 (128 * 3) engine clocks and de-bounce sample card
N * |        |          |removal once per 128 engine clocks.
N * |        |          |01 = De-bounce sample card insert once per 192 (64 * 3) engine clocks and de-bounce sample card
N * |        |          |removal once per 64 engine clocks.
N * |        |          |10 = De-bounce sample card insert once per 96 (32 * 3) engine clocks and de-bounce sample card
N * |        |          |removal once per 32 engine clocks.
N * |        |          |11 = De-bounce sample card insert once per 48 (16 * 3) engine clocks and de-bounce sample card
N * |        |          |removal once per 16 engine clocks.
N * |[30]    |SYNC      |SYNC Flag Indicator
N * |        |          |Due to synchronization, software should check this bit before writing a new value to RX_ERETRY
N * |        |          |and TX_ERETRY.
N * |        |          |0 = synchronizing is completion, user can write new data to RX_ERETRY and TX_ERETRY.
N * |        |          |1 = Last value is synchronizing.
N * |        |          |Note: This bit is read only.
N * @var SC_T::ALTCTL
N * Offset: 0x08  SC Alternate Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |TX_RST    |TX Software Reset
N * |        |          |When TX_RST is set, all the bytes in the transmit buffer and TX internal state machine will be
N * |        |          |cleared.
N * |        |          |0 = No effect.
N * |        |          |1 = Reset the TX internal state machine and pointers.
N * |        |          |Note:
N * |        |          |This bit will be auto cleared after reset is complete.
N * |[1]     |RX_RST    |Rx Software Reset
N * |        |          |When RX_RST is set, all the bytes in the receiver buffer and Rx internal state machine will be
N * |        |          |cleared.
N * |        |          |0 = No effect.
N * |        |          |1 = Reset the Rx internal state machine and pointers.
N * |        |          |Note:
N * |        |          |This bit will be auto cleared after reset is complete.
N * |[2]     |DACT_EN   |Deactivation Sequence Generator Enable Control
N * |        |          |This bit enables SC controller to initiate the card by deactivation sequence
N * |        |          |0 = No effect.
N * |        |          |1 = Deactivation sequence generator Enabled.
N * |        |          |Note1:
N * |        |          |When the deactivation sequence completed, this bit will be cleared automatically and the
N * |        |          |INIT_IS(SC_ISR[8]) will be set to 1.
N * |        |          |Note2:
N * |        |          |This field will be cleared by TX_RST (SC_ALTCTL[0]) and RX_RST(SC_ALTCTL[1]).
N * |        |          |So don't fill this bit, TX_RST, and RX_RST at the same time.
N * |        |          |Note3:
N * |        |          |If SC_CEN (SC_CTL[0]) is not enabled, this filed cannot be programmed.
N * |[3]     |ACT_EN    |Activation Sequence Generator Enable Control
N * |        |          |This bit enables SC controller to initiate the card by activation sequence
N * |        |          |0 = No effect.
N * |        |          |1 = Activation sequence generator Enabled.
N * |        |          |Note1:
N * |        |          |When the activation sequence completed, this bit will be cleared automatically and the
N * |        |          |INIT_IS(SC_ISR[8]) will be set to 1.
N * |        |          |Note2:
N * |        |          |This field will be cleared by TX_RST(SC_ALTCTL[0]) and RX_RST(SC_ALTCTL[1]), so don't fill this
N * |        |          |bit, TX_RST(SC_ALTCTL[0]), and RX_RST(SC_ALTCTL[1]) at the same time.
N * |        |          |Note3:
N * |        |          |If SC_CEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.
N * |[4]     |WARST_EN  |Warm Reset Sequence Generator Enable Control
N * |        |          |This bit enables SC controller to initiate the card by warm reset sequence
N * |        |          |0 = No effect.
N * |        |          |1 = Warm reset sequence generator Enabled.
N * |        |          |Note1:
N * |        |          |When the warm reset sequence completed, this bit will be cleared automatically and the
N * |        |          |INIT_IS(SC_ISR[8]) will be set to 1.
N * |        |          |Note2:
N * |        |          |This field will be cleared by TX_RST(SC_ALTCTL[0]) and RX_RST(SC_ALTCTL[1]), so don't fill this
N * |        |          |bit, TX_RST, and RX_RST at the same time.
N * |        |          |Note3:
N * |        |          |If SC_CEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.
N * |[5]     |TMR0_SEN  |Internal Timer0 Start Enable Control
N * |        |          |This bit enables Timer 0 to start counting.
N * |        |          |Software can fill 0 to stop it and set 1 to reload and count.
N * |        |          |0 = Stops counting.
N * |        |          |1 = Start counting.
N * |        |          |Note1:
N * |        |          |This field is used for internal 24 bit timer when TMR_SEL (SC_CTL[14:13]) = 01.
N * |        |          |Note2:
N * |        |          |If the operation mode is not in auto-reload mode (SC_TMR0[26] = 0), this bit will be
N * |        |          |auto-cleared by hardware.
N * |        |          |Note3:
N * |        |          |This field will be cleared by TX_RST(SC_ALTCTL[0]) and RX_RST(SC_ALTCTL[1]).
N * |        |          |So don't fill this bit, TX_RST and RX_RST at the same time.
N * |        |          |Note4: If SC_CEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.
N * |[6]     |TMR1_SEN  |Internal Timer1 Start Enable Control
N * |        |          |This bit enables Timer 1 to start counting.
N * |        |          |Software can fill 0 to stop it and set 1 to reload and count.
N * |        |          |0 = Stops counting.
N * |        |          |1 = Start counting.
N * |        |          |Note1:
N * |        |          |This field is used for internal 8 bit timer when TMR_SEL(SC_CTL[14:13]) = 10 or
N * |        |          |TMR_SEL(SC_CTL[14:13]) = 11.
N * |        |          |Don't filled TMR1_SEN when TMR_SEL(SC_CTL[14:13]) = 00 or TMR_SEL(SC_CTL[14:13]) = 01.
N * |        |          |Note2:
N * |        |          |If the operation mode is not in auto-reload mode (SC_TMR1[26] = 0), this bit will be
N * |        |          |auto-cleared by hardware.
N * |        |          |Note3:
N * |        |          |This field will be cleared by TX_RST(SC_ALTCTL[0]) and RX_RST(SC_ALTCTL[1]), so don't fill this
N * |        |          |bit, TX_RST(SC_ALTCTL[0]), and RX_RST(SC_ALTCTL[1]) at the same time.
N * |        |          |Note4:
N * |        |          |If SC_CEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.
N * |[7]     |TMR2_SEN  |Internal Timer2 Start Enable Control
N * |        |          |This bit enables Timer 2 to start counting.
N * |        |          |Software can fill 0 to stop it and set 1 to reload and count.
N * |        |          |0 = Stops counting.
N * |        |          |1 = Start counting.
N * |        |          |Note1:
N * |        |          |This field is used for internal 8 bit timer when TMR_SEL(SC_CTL[14:13]) = 11.
N * |        |          |Don't filled TMR2_SEN when TMR_SEL(SC_CTL[14:13]) = 00 or TMR_SEL(SC_CTL[14:13]) = 01 or
N * |        |          |TMR_SEL(SC_CTL[14:13]) = 10.
N * |        |          |Note2:
N * |        |          |If the operation mode is not in auto-reload mode (SC_TMR2[26] = 0), this bit will be
N * |        |          |auto-cleared by hardware.
N * |        |          |Note3:
N * |        |          |This field will be cleared by TX_RST(SC_ALTCTL[0]) and RX_RST(SC_ALTCTL[1]).
N * |        |          |So don't fill this bit, TX_RST(SC_ALTCTL[0]), and RX_RST(SC_ALTCTL[1]) at the same time.
N * |        |          |Note4:
N * |        |          |If SC_CEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.
N * |[9:8]   |INIT_SEL  |Initial Timing Selection
N * |        |          |This fields indicates the timing of hardware initial state (activation or warm-reset or
N * |        |          |deactivation).
N * |        |          |Unit: SC clock
N * |        |          |Activation: refer to SC Activation Sequence in Figure 5-100.
N * |        |          |Warm-reset: refer to Warm-Reset Sequence in Figure 5-101.
N * |        |          |Deactivation: refer to Deactivation Sequence in Figure 5-102.
N * |[12]    |RX_BGT_EN |Receiver Block Guard Time Function Enable Control
N * |        |          |0 = Receiver block guard time function Disabled.
N * |        |          |1 = Receiver block guard time function Enabled.
N * |[13]    |TMR0_ATV  |Internal Timer0 Active State (Read Only)
N * |        |          |This bit indicates the timer counter status of timer0.
N * |        |          |0 = Timer0 is not active.
N * |        |          |1 = Timer0 is active.
N * |[14]    |TMR1_ATV  |Internal Timer1 Active State (Read Only)
N * |        |          |This bit indicates the timer counter status of timer1.
N * |        |          |0 = Timer1 is not active.
N * |        |          |1 = Timer1 is active.
N * |[15]    |TMR2_ATV  |Internal Timer2 Active State (Read Only)
N * |        |          |This bit indicates the timer counter status of timer2.
N * |        |          |0 = Timer2 is not active.
N * |        |          |1 = Timer2 is active.
N * |[16]    |OUTSEL    |Smartcard Data Pin Output Mode Selection
N * |        |          |Use this bit to select smartcard data pin (SC_DATA) output mode
N * |        |          |0 = Quasi mode.
N * |        |          |1 = Open-drain mode.
N * @var SC_T::EGTR
N * Offset: 0x0C  SC Extend Guard Time Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |EGT       |Extended Guard Time
N * |        |          |This field indicates the extended guard timer value.
N * |        |          |Note:
N * |        |          |The counter is ETU base and the real extended guard time is EGT.
N * @var SC_T::RFTMR
N * Offset: 0x10  SC Receive buffer Time-out Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[8:0]   |RFTM      |SC Receiver Buffer Time-Out (ETU Base)
N * |        |          |The time-out counter resets and starts counting whenever the RX buffer received a new data word.
N * |        |          |Once the counter decrease to 1 and no new data is received or CPU does not read data by reading
N * |        |          |SC_RBR buffer, a receiver time-out interrupt INT_RTMR will be generated(if RTMR_IE(SC_IER[9]) = 1).
N * |        |          |Note1: The counter unit is ETU based and the interval of time-out is RFTM + 0.5
N * |        |          |Note2: Fill all 0 to this field indicates to disable this function.
N * @var SC_T::ETUCR
N * Offset: 0x14  SC ETU Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[11:0]  |ETU_RDIV  |ETU Rate Divider
N * |        |          |The field indicates the clock rate divider.
N * |        |          |The real ETU is ETU_RDIV + 1.
N * |        |          |Note:
N * |        |          |Software can configure this field, but this field must be greater than 0x004.
N * |[15]    |COMPEN_EN |Compensation Mode Enable Control
N * |        |          |This bit enables clock compensation function.
N * |        |          |When this bit enabled, hardware will alternate between n clock cycles and n-1 clock cycles,
N * |        |          |where n is the value to be written into the ETU_RDIV .
N * |        |          |0 = Compensation function Disabled.
N * |        |          |1 = Compensation function Enabled.
N * @var SC_T::IER
N * Offset: 0x18  SC Interrupt Enable Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |RDA_IE    |Receive Data Reach Interrupt Enable Control
N * |        |          |This field is used for received data reaching trigger level RX_FTRI_LEV (SC_CTL[7:6]) interrupt
N * |        |          |enable.
N * |        |          |0 = Receive data reach trigger level interrupt Disabled.
N * |        |          |1 = Receive data reach trigger level interrupt Enabled.
N * |[1]     |TXBE_IE   |Transmit Buffer Empty Interrupt Enable Control
N * |        |          |This field is used for transmit buffer empty interrupt enable.
N * |        |          |0 = Transmit buffer empty interrupt Disabled.
N * |        |          |1 = Transmit buffer empty interrupt Enabled.
N * |[2]     |TERR_IE   |Transfer Error Interrupt Enable Control
N * |        |          |This field is used for transfer error interrupt enable.
N * |        |          |The transfer error states is at SC_SR register which includes receiver break error
N * |        |          |RX_EBR_F(SC_SR[6]), frame error RX_EFR_F(SC_SR[5]), parity error RX_EPA_F(SC_SR[4]), receiver
N * |        |          |buffer overflow error RX_OVER_F(SC_SR[0]), transmit buffer overflow error TX_OVER_F(SC_SR[8]),
N * |        |          |receiver retry over limit error RX_OVER_REERR(SC_SR[22]) and transmitter retry over limit error
N * |        |          |TX_OVER_REERR(SC_SR[30]).
N * |        |          |0 = Transfer error interrupt Disabled.
N * |        |          |1 = Transfer error interrupt Enabled.
N * |[3]     |TMR0_IE   |Timer0 Interrupt Enable Control
N * |        |          |This field is used to enable TMR0 interrupt enable.
N * |        |          |0 = Timer0 interrupt Disabled.
N * |        |          |1 = Timer0 interrupt Enabled.
N * |[4]     |TMR1_IE   |Timer1 Interrupt Enable Control
N * |        |          |This field is used to enable the TMR1 interrupt.
N * |        |          |0 = Timer1 interrupt Disabled.
N * |        |          |1 = Timer1 interrupt Enabled.
N * |[5]     |TMR2_IE   |Timer2 Interrupt Enable Control
N * |        |          |This field is used for TMR2 interrupt enable.
N * |        |          |0 = Timer2 interrupt Disabled.
N * |        |          |1 = Timer2 interrupt Enabled.
N * |[6]     |BGT_IE    |Block Guard Time Interrupt Enable Control
N * |        |          |This field is used for block guard time interrupt enable.
N * |        |          |0 = Block guard time Disabled.
N * |        |          |1 = Block guard time Enabled.
N * |[7]     |CD_IE     |Card Detect Interrupt Enable Control
N * |        |          |This field is used for card detect interrupt enable. The card detect status is
N * |        |          |CD_INS_F(SC_SR[12])
N * |        |          |0 = Card detect interrupt Disabled.
N * |        |          |1 = Card detect interrupt Enabled.
N * |[8]     |INIT_IE   |Initial End Interrupt Enable Control
N * |        |          |This field is used for activation (ACT_EN(SC_ALTCTL[3] = 1)), deactivation ((DACT_EN
N * |        |          |SC_ALTCTL[2]) = 1) and warm reset (WARST_EN (SC_ALTCTL [4])) sequence interrupt enable.
N * |        |          |0 = Initial end interrupt Disabled.
N * |        |          |1 = Initial end interrupt Enabled.
N * |[9]     |RTMR_IE   |Receiver Buffer Time-Out Interrupt Enable Control
N * |        |          |This field is used for receiver buffer time-out interrupt enable.
N * |        |          |0 = Receiver buffer time-out interrupt Disabled.
N * |        |          |1 = Receiver buffer time-out interrupt Enabled.
N * |[10]    |ACON_ERR_IE|Auto Convention Error Interrupt Enable Control
N * |        |          |This field is used for auto-convention error interrupt enable.
N * |        |          |0 = Auto-convention error interrupt Disabled.
N * |        |          |1 = Auto-convention error interrupt Enabled.
N * @var SC_T::ISR
N * Offset: 0x1C  SC Interrupt Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |RDA_IS    |Receive Data Reach Interrupt Status Flag (Read Only)
N * |        |          |This field is used for received data reaching trigger level RX_FTRI_LEV (SC_CTL[7:6]) interrupt
N * |        |          |status flag.
N * |        |          |Note: This field is the status flag of received data reaching RX_FTRI_LEV (SC_CTL[7:6]).
N * |        |          |If software reads data from SC_RBR and receiver buffer data byte number is less than RX_FTRI_LEV
N * |        |          |(SC_CTL[7:6]), this bit will be cleared automatically.
N * |[1]     |TBE_IS    |Transmit Buffer Empty Interrupt Status Flag (Read Only)
N * |        |          |This field is used for transmit buffer empty interrupt status flag.
N * |        |          |Note: This field is the status flag of transmit buffer empty state.
N * |        |          |If software wants to clear this bit, software must write data to THR(SC_THR[7:0]) buffer and
N * |        |          |then this bit will be cleared automatically.
N * |[2]     |TERR_IS   |Transfer Error Interrupt Status Flag (Read Only)
N * |        |          |This field is used for transfer error interrupt status flag.
N * |        |          |The transfer error states is at SC_SR register which includes receiver break error
N * |        |          |RX_EBR_F(SC_SR[6]), 
N * |        |          |frame error RX_EFR_F(SC_TRSR[5]), parity error RX_EPA_F(SC_TRSR[4]) and receiver buffer overflow
N * |        |          |error RX_OVER_F(SC_TRSR[0]), 
N * |        |          |transmit buffer overflow error TX_OVER_F(SC_TRSR[8]), receiver retry over limit error
N * |        |          |RX_OVER_REERR(SC_TRSR[22]) and transmitter retry over limit error TX_OVER_REERR(SC_TRSR[30]).
N * |        |          |Note: This field is the status flag of
N * |        |          |RX_EBR_F(SC_TRSR[6]), RX_EFR_F(SC_TRSR[5]), RX_EPA_F(SC_TRSR[4]), RX_OVER_F(SC_TRSR[0]),
N * |        |          |TX_OVER_F(SC_TRSR[8]), RX_OVER_REERR(SC_TRSR[22]) or TX_OVER_REERR(SC_TRSR[30]).
N * |        |          |So, if software wants to clear this bit, software must write 1 to each field.
N * |[3]     |TMR0_IS   |Timer0 Interrupt Status Flag (Read Only)
N * |        |          |This field is used for TMR0 interrupt status flag.
N * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
N * |[4]     |TMR1_IS   |Timer1 Interrupt Status Flag (Read Only)
N * |        |          |This field is used for TMR1 interrupt status flag.
N * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
N * |[5]     |TMR2_IS   |Timer2 Interrupt Status Flag (Read Only)
N * |        |          |This field is used for TMR2 interrupt status flag.
N * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
N * |[6]     |BGT_IS    |Block   Guard Time Interrupt Status Flag (Read Only)
N * |        |          |This field   is used for block guard time interrupt status flag.
N * |        |          |Note1: This bit is valid when RX_BGT_EN   (SC_ALTCTL[12]) is enabled.
N * |        |          |Note2: This bit is read only, but it can be cleared by   writing "1" to it.
N * |[7]     |CD_IS     |Card Detect Interrupt Status Flag (Read Only)
N * |        |          |This field is used for card detect interrupt status flag.
N * |        |          |The card detect status is CD_INS_F (SC_SR[12]) and CD_REM_F(SC_SR[11]).
N * |        |          |Note:
N * |        |          |This field is the status flag of CD_INS_F(SC_SR[12]) or CD_REM_F(SC_TRSR[11])].
N * |        |          |So if software wants to clear this bit, software must write 1 to this field.
N * |[8]     |INIT_IS   |Initial End Interrupt Status Flag (Read Only)
N * |        |          |This field is used for activation (ACT_EN(SC_ALTCTL[3])), deactivation (DACT_EN (SC_ALTCTL[2]))
N * |        |          |and warm reset (WARST_EN (SC_ALTCTL[4])) sequence interrupt status flag.
N * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
N * |[9]     |RTMR_IS   |Receiver Buffer Time-Out Interrupt Status Flag (Read Only)
N * |        |          |This field is used for receiver buffer time-out interrupt status flag.
N * |        |          |Note: This field is the status flag of receiver buffer time-out state.
N * |        |          |If software wants to clear this bit, software must read all receiver buffer remaining data by
N * |        |          |reading SC_RBR buffer,.
N * |[10]    |ACON_ERR_IS|Auto Convention Error Interrupt Status Flag (Read Only)
N * |        |          |This field indicates auto convention sequence error.
N * |        |          |If the received TS at ATR state is neither 0x3B nor 0x3F, this bit will be set.
N * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
N * @var SC_T::TRSR
N * Offset: 0x20  SC Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |RX_OVER_F |RX Overflow Error Status Flag (Read Only)
N * |        |          |This bit is set when RX buffer overflow.
N * |        |          |If the number of received bytes is greater than Rx Buffer size (4 bytes), this bit will be set.
N * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
N * |[1]     |RX_EMPTY_F|Receiver Buffer Empty Status Flag(Read Only)
N * |        |          |This bit indicates RX buffer empty or not.
N * |        |          |When the last byte of Rx buffer has been read by CPU, hardware sets this bit high.
N * |        |          |It will be cleared when SC receives any new data.
N * |[2]     |RX_FULL_F |Receiver Buffer Full Status Flag (Read Only)
N * |        |          |This bit indicates RX buffer full or not.
N * |        |          |This bit is set when RX pointer is equal to 4, otherwise it is cleared by hardware.
N * |[4]     |RX_EPA_F  |Receiver Parity Error Status Flag (Read Only)
N * |        |          |This bit is set to logic 1 whenever the received character does not have a valid
N * |        |          |"parity bit".
N * |        |          |Note1:
N * |        |          |This bit is read only, but it can be cleared by writing 1 to it.
N * |        |          |Note2:
N * |        |          |If CPU sets receiver retries function by setting RX_ERETRY_EN(SC_CTL[19]) , hardware will not
N * |        |          |set this flag.
N * |[5]     |RX_EFR_F  |Receiver Frame Error Status Flag (Read Only)
N * |        |          |This bit is set to logic 1 whenever the received character does not have a valid "stop bit"
N * |        |          |(that is, the stop bit following the last data bit or parity bit is detected as logic 0).
N * |        |          |Note1:
N * |        |          |This bit is read only, but it can be cleared by writing 1 to it.
N * |        |          |Note2:
N * |        |          |If CPU sets receiver retries function by setting RX_ERETRY_EN(SC_CTL[19]) , hardware will not
N * |        |          |set this flag.
N * |[6]     |RX_EBR_F  |Receiver Break Error Status Flag (Read Only)
N * |        |          |This bit is set to logic 1 whenever the received data input (RX) held in the "spacing state"
N * |        |          |(logic 0) is longer than a full word transmission time (that is, the total time of "start bit" +
N * |        |          |data bits + parity + stop bits).
N * |        |          |Note1:
N * |        |          |This bit is read only, but it can be cleared by writing 1 to it.
N * |        |          |Note2:
N * |        |          |If CPU sets receiver retries function by setting RX_ERETRY_EN(SC_CTL[19]) , hardware will not
N * |        |          |set this flag.
N * |[8]     |TX_OVER_F |TX Overflow Error Interrupt Status Flag (Read Only)
N * |        |          |If TX buffer is full, an additional write to THR(SC_THR[7:0]) will cause this bit be set to "1"
N * |        |          |by hardware.
N * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
N * |[9]     |TX_EMPTY_F|Transmit Buffer Empty Status Flag (Read Only)
N * |        |          |This bit indicates TX buffer empty or not.
N * |        |          |When the last byte of TX buffer has been transferred to Transmitter Shift Register, hardware
N * |        |          |sets this bit high.
N * |        |          |It will be cleared when writing data into THR(SC_THR[7:0]) (TX buffer not empty).
N * |[10]    |TX_FULL_F |Transmit Buffer Full Status Flag (Read Only)
N * |        |          |This bit indicates TX buffer full or not.This bit is set when TX pointer is equal to 4,
N * |        |          |otherwise is cleared by hardware.
N * |[17:16] |RX_POINT_F|Receiver Buffer Pointer Status Flag (Read Only)
N * |        |          |This field indicates the RX buffer pointer status flag.
N * |        |          |When SC receives one byte from external device, RX_POINT_F(SC_SR[17:16]) increases one.
N * |        |          |When one byte of RX buffer is read by CPU, RX_POINT_F(SC_SR[17:16]) decreases one.
N * |[21]    |RX_REERR  |Receiver Retry Error (Read Only)
N * |        |          |This bit is set by hardware when RX has any error and retries transfer.
N * |        |          |Note1: This bit is read only, but it can be cleared by writing 1 to it.
N * |        |          |Note2 This bit is a flag and cannot generate any interrupt to CPU.
N * |        |          |Note3: If CPU enables receiver retry function by setting RX_ERETRY_EN
N * |        |          |(SC_CTL[19]) , the RX_EPA_F(SC_TRSR[4]) flag will be ignored (hardware will not set
N * |        |          |RX_EPA_F(SC_TRSR[4])).
N * |[22]    |RX_OVER_REERR|Receiver Over Retry Error (Read Only)
N * |        |          |This bit is set by hardware when RX transfer error retry over retry number limit.
N * |        |          |Note1: This bit is read only, but it can be cleared by writing 1 to it.
N * |        |          |Note2: If CPU enables receiver retries function by setting RX_ERETRY_EN
N * |        |          |(SC_CTL[19]), the RX_EPA_F(SC_TRSR[4]) flag will be ignored (hardware will not set
N * |        |          |RX_EPA_F(SC_TRSR[4])).
N * |[23]    |RX_ATV    |Receiver In Active Status Flag (Read Only)
N * |        |          |This bit is set by hardware when RX transfer is in active.
N * |        |          |This bit is cleared automatically when RX transfer is finished.
N * |[25:24] |TX_POINT_F|Transmit Buffer Pointer Status Flag (Read Only)
N * |        |          |This field indicates the TX buffer pointer status flag.
N * |        |          |When CPU writes data into SC_THR, TX_POINT_F increases one.
N * |        |          |When one byte of TX Buffer is transferred to transmitter shift register, TX_POINT_F decreases
N * |        |          |one.
N * |[29]    |TX_REERR  |Transmitter Retry Error (Read Only)
N * |        |          |This bit is set by hardware when transmitter re-transmits.
N * |        |          |Note1: This bit is read only, but it can be cleared by writing 1 to it.
N * |        |          |Note2 This bit is a flag and cannot generate any interrupt to CPU.
N * |[30]    |TX_OVER_REERR|Transmitter Over Retry Error (Read Only)
N * |        |          |This bit is set by hardware when transmitter re-transmits over retry number limitation.
N * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
N * |[31]    |TX_ATV    |Transmit In Active Status Flag (Read Only)
N * |        |          |0 = This bit is cleared automatically when TX transfer is finished or the last byte transmission
N * |        |          |has completed.
N * |        |          |1 = This bit is set by hardware when TX transfer is in active and the STOP bit of the last byte
N * |        |          |has been transmitted.
N * @var SC_T::PINCSR
N * Offset: 0x24  SC Pin Control State Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |POW_EN    |SC_POW_EN Pin Signal
N * |        |          |Software can set POW_EN (SC_PINCSR[0]) and POW_INV (SC_PINCSR[11])to decide SC_PWR pin is in
N * |        |          |high or low level.
N * |        |          |Write this field to drive SC_PWR pin
N * |        |          |Refer POW_INV (SC_PINCSR[11]) description for programming SC_PWR pin voltage level.
N * |        |          |Read this field to get SC_PWR pin status.
N * |        |          |0 = SC_PWR pin status is low.
N * |        |          |1 = SC_PWR pin status is high.
N * |        |          |Note: When operating at activation, warm reset or deactivation mode, this bit will be changed
N * |        |          |automatically.
N * |        |          |So don't fill this field when operating in these modes.
N * |[1]     |SC_RST    |SC_RST Pin Signal
N * |        |          |This bit is the pin status of SC_RST but user can drive SC_RST pin to high or low by setting
N * |        |          |this bit.
N * |        |          |Write this field to drive SC_RST pin.
N * |        |          |0 = Drive SC_RST pin to low.
N * |        |          |1 = Drive SC_RST pin to high.
N * |        |          |Read this field to get SC_RST pin status.
N * |        |          |0 = SC_RST pin status is low.
N * |        |          |1 = SC_RST pin status is high.
N * |        |          |Note: When operating at activation, warm reset or deactivation mode, this bit will be changed
N * |        |          |automatically.
N * |        |          |So don't fill this field when operating in these modes.
N * |[2]     |CD_REM_F  |Card Detect Removal Status Of SC_CD Pin (Read Only)
N * |        |          |This bit is set whenever a card has been removed.
N * |        |          |0 = No effect.
N * |        |          |1 = Card removed.
N * |        |          |Note1: This bit is read only, but it can be cleared by writing "1" to it.
N * |        |          |Note2: Card detect engine will start after SC_CEN (SC_CTL[0] )set.
N * |[3]     |CD_INS_F  |Card Detect Insert Status Of SC_CD Pin (Read Only)
N * |        |          |This bit is set whenever card has been inserted.
N * |        |          |0 = No effect.
N * |        |          |1 = Card insert.
N * |        |          |Note1: This bit is read only, but it can be cleared by writing "1" to it.
N * |        |          |Note2: The
N * |        |          |card detect engine will start after SC_CEN (SC_CTL[0] )set.
N * |[4]     |CD_PIN_ST |Card Detect Status Of SC_CD Pin Status (Read Only)
N * |        |          |This bit is the pin status flag of SC_CD
N * |        |          |0 = The SC_CD pin state at low.
N * |        |          |1 = The SC_CD pin state at high.
N * |[6]     |CLK_KEEP  |SC Clock Enable Control
N * |        |          |0 = SC clock generation Disabled.
N * |        |          |1 = SC clock always keeps free running.
N * |        |          |Note: When operating in activation, warm reset or deactivation mode, this bit will be changed
N * |        |          |automatically.
N * |        |          |So don't fill this field when operating in these modes.
N * |[7]     |ADAC_CD_EN|Auto Deactivation When Card Removal
N * |        |          |0 = Auto deactivation Disabled when hardware detected the card removal.
N * |        |          |1 = Auto deactivation Enabled when hardware detected the card removal.
N * |        |          |Note: When the card is removed, hardware will stop any process and then do deactivation sequence
N * |        |          |(if this bit be setting).
N * |        |          |If this process completes.
N * |        |          |Hardware will generate an initial end.
N * |        |          |interrupt to CPU.
N * |[8]     |SC_OEN_ST |SC Data Output Enable Pin Status (Read Only)
N * |        |          |This bit is the pin status of SC_DATA_OEN
N * |        |          |0 = The SC_DATA_OEN pin state at low.
N * |        |          |1 = The SC_DATA_OEN pin state at high.
N * |[9]     |SC_DATA_O |SC Data Output Pin
N * |        |          |This bit is the pin status of SC_DATA_O but user can drive SC_DATA_O pin to high or low by
N * |        |          |setting this bit.
N * |        |          |0 = Drive SC_DATA_O pin to low.
N * |        |          |1 = Drive SC_DATA_O pin to high.
N * |        |          |Note: When SC is at activation, warm reset or deactivation mode, this bit will be changed
N * |        |          |automatically.
N * |        |          |So don't fill this field when SC is in these modes.
N * |[10]    |CD_LEV    |Card Detect Level
N * |        |          |0 = When hardware detects the card detect pin from high to low, it indicates a card is detected.
N * |        |          |1 = When hardware detects the card detect pin from low to high, it indicates a card is detected.
N * |        |          |Note: Software must select card detect level before Smart Card engine is enabled
N * |[11]    |POW_INV   |SC_POW Pin Inverse
N * |        |          |This bit is used for inverse the SC_POW pin.
N * |        |          |There are four kinds of combination for SC_POW pin setting by POW_INV(SC_PINCSR[11]) and
N * |        |          |POW_EN(SC_PINCSR[0]).
N * |        |          |POW_INV (SC_PINCSR[11]) is bit 1 and POW_EN(SC_PINCSR[0]) is bit 0 for SC_POW_Pin as high or low
N * |        |          |voltage selection.
N * |        |          |00 = SC_POW_ Pin is 0.
N * |        |          |01 = SC_POW _Pin is 1.
N * |        |          |10 = SC_POW _Pin is 1.
N * |        |          |11 = SC_POW_ Pin is 0.
N * |        |          |Note: Software must select POW_INV (SC_PINCSR[11]) before Smart Card is enabled by SC_CEN
N * |        |          |(SC_CTL[0]).
N * |[16]    |SC_DATA_I_ST|SC Data Pin Status (Read Only)
N * |        |          |This bit is the pin status of SC_DATA
N * |        |          |0 = The SC_DATA pin is low.
N * |        |          |1 = The SC_DATA pin is high.
N * |[30]    |SYNC      |SYNC Flag Indicator
N * |        |          |Due to synchronization, software should check this bit when writing a new value to SC_PINCSR
N * |        |          |register.
N * |        |          |0 = Synchronizing is completion, user can write new data to SC_PINCSR register.
N * |        |          |1 = Last value is synchronizing.
N * |        |          |Note: This bit is read only.
N * @var SC_T::TMR0
N * Offset: 0x28  SC Internal Timer Control Register 0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[23:0]  |CNT0      |Timer 0 Counter Value (ETU Base)
N * |        |          |This field indicates the internal timer operation values.
N * |[27:24] |MODE      |Timer 0 Operation Mode Selection
N * |        |          |This field indicates the internal 24-bit timer operation selection.
N * |        |          |Refer to 5.15.5.4 for programming Timer0
N * @var SC_T::TMR1
N * Offset: 0x2C  SC Internal Timer Control Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |CNT1      |Timer 1 Counter Value (ETU Base)
N * |        |          |This field indicates the internal timer operation values.
N * |[27:24] |MODE      |Timer 1 Operation Mode Selection
N * |        |          |This field indicates the internal 8-bit timer operation selection.
N * |        |          |Refer to 5.15.5.4 for programming Timer1
N * @var SC_T::TMR2
N * Offset: 0x30  SC Internal Timer Control Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |CNT2      |Timer 2 Counter Value (ETU Base)
N * |        |          |This field indicates the internal timer operation values.
N * |[27:24] |MODE      |Timer 2 Operation Mode Selection
N * |        |          |This field indicates the internal 8-bit timer operation selection
N * |        |          |Refer to 5.15.5.4 for programming Timer2
N * @var SC_T::UACTL
N * Offset: 0x34  SC UART Mode Control Register.
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |UA_MODE_EN|UART Mode Enable Control
N * |        |          |0 = Smart Card mode.
N * |        |          |1 = UART mode.
N * |        |          |Note1: When operating in UART mode, user must set CON_SEL (SC_CTL[5:4]) = 00 and
N * |        |          |AUTO_CON_EN(SC_CTL[3]) = 0.
N * |        |          |Note2: When operating in Smart Card mode, user must set UA_MODE_EN(SC_UACTL [0]) = 00.
N * |        |          |Note3: When UART is enabled, hardware will generate a reset to reset FIFO and internal state
N * |        |          |machine.
N * |[5:4]   |DATA_LEN10|Data Length
N * |        |          |00 = Character Data Length is 8 bits.
N * |        |          |01 = Character Data Length is 7 bits.
N * |        |          |10 = Character Data length is 6 bits.
N * |        |          |11 = Character Data Length is 5 bits.
N * |        |          |Note: In smart card mode, this DATA_LEN must be '00'
N * |[6]     |PBDIS     |Parity Bit Disable Control
N * |        |          |0 = Parity bit is generated or checked between the "last data word bit" and "stop bit" of the
N * |        |          |serial data.
N * |        |          |1 = Parity bit is not generated (transmitting data) or checked (receiving data) during transfer.
N * |        |          |Note: In smart card mode, this field must be '0' (default setting is with parity bit)
N * |[7]     |OPE       |Odd Parity Enable Control
N * |        |          |0 = Even number of logic 1's are transmitted or check the data word and parity bits in receiving
N * |        |          |mode.
N * |        |          |1 = Odd number of logic 1's are transmitted or check the data word and parity bits in receiving
N * |        |          |mode.
N * |        |          |Note: This bit has effect only when PBDIS bit is '0'.
N * @var SC_T::TDRA
N * Offset: 0x38  SC Timer Current Data Register A
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[23:0]  |TDR0      |Timer0 Current Data value(Read Only)
N * |        |          |This field indicates the current count values of timer0.
N * @var SC_T::TDRB
N * Offset: 0x3C  SC Timer Current Data Register B
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |TDR1      |Timer1 Current Data value(Read Only)
N * |        |          |This field indicates the current count values of timer1.
N * |[15:8]  |TDR2      |Timer2 Current Data value (Read Only)
N * |        |          |This field indicates the current count values of timer2.
N */
N    
N    union {
N    __I  uint32_t RBR;           /* Offset: 0x00  SC Receiving Buffer Register.                                      */
X    volatile const  uint32_t RBR;            
N    __O  uint32_t THR;           /* Offset: 0x00  SC Transmit Holding Register                                       */
X    volatile  uint32_t THR;            
N    };
N    __IO uint32_t CTL;           /* Offset: 0x04  SC Control Register                                                */
X    volatile uint32_t CTL;            
N    __IO uint32_t ALTCTL;        /* Offset: 0x08  SC Alternate Control Register                                      */
X    volatile uint32_t ALTCTL;         
N    __IO uint32_t EGTR;          /* Offset: 0x0C  SC Extend Guard Time Register                                      */
X    volatile uint32_t EGTR;           
N    __IO uint32_t RFTMR;         /* Offset: 0x10  SC Receive buffer Time-out Register                                */
X    volatile uint32_t RFTMR;          
N    __IO uint32_t ETUCR;         /* Offset: 0x14  SC ETU Control Register                                            */
X    volatile uint32_t ETUCR;          
N    __IO uint32_t IER;           /* Offset: 0x18  SC Interrupt Enable Control Register                               */
X    volatile uint32_t IER;            
N    __IO uint32_t ISR;           /* Offset: 0x1C  SC Interrupt Status Register                                       */
X    volatile uint32_t ISR;            
N    __IO uint32_t TRSR;          /* Offset: 0x20  SC Status Register                                                 */
X    volatile uint32_t TRSR;           
N    __IO uint32_t PINCSR;        /* Offset: 0x24  SC Pin Control State Register                                      */
X    volatile uint32_t PINCSR;         
N    __IO uint32_t TMR0;          /* Offset: 0x28  SC Internal Timer Control Register 0                               */
X    volatile uint32_t TMR0;           
N    __IO uint32_t TMR1;          /* Offset: 0x2C  SC Internal Timer Control Register 1                               */
X    volatile uint32_t TMR1;           
N    __IO uint32_t TMR2;          /* Offset: 0x30  SC Internal Timer Control Register 2                               */
X    volatile uint32_t TMR2;           
N    __IO uint32_t UACTL;         /* Offset: 0x34  SC UART Mode Control Register.                                     */
X    volatile uint32_t UACTL;          
N    __I  uint32_t TDRA;          /* Offset: 0x38  SC Timer Current Data Register A                                   */
X    volatile const  uint32_t TDRA;           
N    __I  uint32_t TDRB;          /* Offset: 0x3C  SC Timer Current Data Register B                                   */
X    volatile const  uint32_t TDRB;           
N
N} SC_T;
N
N
N/**
N    @addtogroup SC_CONST SC Bit Field Definition
N    Constant Definitions for SC Controller
N@{ */
N
N
N/* SC RBR Bit Field Definitions */
N#define SC_RBR_RBR_Pos                      0                                /*!< SC_T::RBR: RBR Position */
N#define SC_RBR_RBR_Msk                      (0xFFul << SC_RBR_RBR_Pos)       /*!< SC_T::RBR: RBR Mask */
N
N/* SC THR Bit Field Definitions */
N#define SC_THR_THR_Pos                      0                                /*!< SC_T::THR: THR Position */
N#define SC_THR_THR_Msk                      (0xFFul << SC_THR_THR_Pos)       /*!< SC_T::THR: THR Mask */
N
N/* SC CTL Bit Field Definitions */
N#define SC_CTL_SYNC_Pos                     30                               /*!< SC_T::CTL: SYNC Position */
N#define SC_CTL_SYNC_Msk                     (1ul << SC_CTL_SYNC_Pos)   /*!< SC_T::CTL: SYNC Mask */
N
N#define SC_CTL_CD_DEB_SEL_Pos               24                               /*!< SC_T::CTL: CD_DEB_SEL Position */
N#define SC_CTL_CD_DEB_SEL_Msk               (3ul << SC_CTL_CD_DEB_SEL_Pos)   /*!< SC_T::CTL: CD_DEB_SEL Mask */
N
N#define SC_CTL_TX_ERETRY_EN_Pos             23                               /*!< SC_T::CTL: TX_ERETRY_EN Position */
N#define SC_CTL_TX_ERETRY_EN_Msk             (1ul << SC_CTL_TX_ERETRY_EN_Pos) /*!< SC_T::CTL: TX_ERETRY_EN Mask */
N
N#define SC_CTL_TX_ERETRY_Pos                20                               /*!< SC_T::CTL: TX_ERETRY Position */
N#define SC_CTL_TX_ERETRY_Msk                (7ul << SC_CTL_TX_ERETRY_Pos)    /*!< SC_T::CTL: TX_ERETRY Mask */
N
N#define SC_CTL_RX_ERETRY_EN_Pos             19                               /*!< SC_T::CTL: RX_ERETRY_EN Position */
N#define SC_CTL_RX_ERETRY_EN_Msk             (1ul << SC_CTL_RX_ERETRY_EN_Pos) /*!< SC_T::CTL: RX_ERETRY_EN Mask */
N
N#define SC_CTL_RX_ERETRY_Pos                16                               /*!< SC_T::CTL: RX_ERETRY Position */
N#define SC_CTL_RX_ERETRY_Msk                (7ul << SC_CTL_RX_ERETRY_Pos)    /*!< SC_T::CTL: RX_ERETRY Mask */
N
N#define SC_CTL_SLEN_Pos                     15                               /*!< SC_T::CTL: SLEN Position */
N#define SC_CTL_SLEN_Msk                     (1ul << SC_CTL_SLEN_Pos)         /*!< SC_T::CTL: SLEN Mask */
N
N#define SC_CTL_TMR_SEL_Pos                  13                               /*!< SC_T::CTL: TMR_SEL Position */
N#define SC_CTL_TMR_SEL_Msk                  (3ul << SC_CTL_TMR_SEL_Pos)      /*!< SC_T::CTL: TMR_SEL Mask */
N
N#define SC_CTL_BGT_Pos                      8                                /*!< SC_T::CTL: BGT Position */
N#define SC_CTL_BGT_Msk                      (0x1Ful << SC_CTL_BGT_Pos)       /*!< SC_T::CTL: BGT Mask */
N
N#define SC_CTL_RX_FTRI_LEV_Pos              6                                /*!< SC_T::CTL: RX_FTRI_LEV Position */
N#define SC_CTL_RX_FTRI_LEV_Msk              (3ul << SC_CTL_RX_FTRI_LEV_Pos)  /*!< SC_T::CTL: RX_FTRI_LEV Mask */
N
N#define SC_CTL_CON_SEL_Pos                  4                                /*!< SC_T::CTL: CON_SEL Position */
N#define SC_CTL_CON_SEL_Msk                  (3ul << SC_CTL_CON_SEL_Pos)      /*!< SC_T::CTL: CON_SEL Mask */
N
N#define SC_CTL_AUTO_CON_EN_Pos              3                                /*!< SC_T::CTL: AUTO_CON_EN Position */
N#define SC_CTL_AUTO_CON_EN_Msk              (1ul << SC_CTL_AUTO_CON_EN_Pos)  /*!< SC_T::CTL: AUTO_CON_EN Mask */
N
N#define SC_CTL_DIS_TX_Pos                   2                                /*!< SC_T::CTL: DIS_TX Position */
N#define SC_CTL_DIS_TX_Msk                   (1ul << SC_CTL_DIS_TX_Pos)       /*!< SC_T::CTL: DIS_TX Mask */
N
N#define SC_CTL_DIS_RX_Pos                   1                                /*!< SC_T::CTL: DIS_RX Position */
N#define SC_CTL_DIS_RX_Msk                   (1ul << SC_CTL_DIS_RX_Pos)       /*!< SC_T::CTL: DIS_RX Mask */
N
N#define SC_CTL_SC_CEN_Pos                   0                                /*!< SC_T::CTL: SC_CEN Position */
N#define SC_CTL_SC_CEN_Msk                   (1ul << SC_CTL_SC_CEN_Pos)       /*!< SC_T::CTL: SC_CEN Mask */
N
N/* SC ALTCTL Bit Field Definitions */
N#define SC_ALTCTL_OUTSEL_Pos                16                               /*!< SC_T::ALTCTL: OUTSEL Position */
N#define SC_ALTCTL_OUTSEL_Msk                (1ul << SC_ALTCTL_OUTSEL_Pos)   /*!< SC_T::ALTCTL: OUTSEL Mask */
N
N#define SC_ALTCTL_TMR2_ATV_Pos              15                               /*!< SC_T::ALTCTL: TMR2_ATV Position */
N#define SC_ALTCTL_TMR2_ATV_Msk              (1ul << SC_ALTCTL_TMR2_ATV_Pos)  /*!< SC_T::ALTCTL: TMR2_ATV Mask */
N
N#define SC_ALTCTL_TMR1_ATV_Pos              14                               /*!< SC_T::ALTCTL: TMR1_ATV Position */
N#define SC_ALTCTL_TMR1_ATV_Msk              (1ul << SC_ALTCTL_TMR1_ATV_Pos)  /*!< SC_T::ALTCTL: TMR1_ATV Mask */
N
N#define SC_ALTCTL_TMR0_ATV_Pos              13                               /*!< SC_T::ALTCTL: TMR0_ATV Position */
N#define SC_ALTCTL_TMR0_ATV_Msk              (1ul << SC_ALTCTL_TMR0_ATV_Pos)  /*!< SC_T::ALTCTL: TMR0_ATV Mask */
N
N#define SC_ALTCTL_RX_BGT_EN_Pos             12                               /*!< SC_T::ALTCTL: RX_BGT_EN Position */
N#define SC_ALTCTL_RX_BGT_EN_Msk             (1ul << SC_ALTCTL_RX_BGT_EN_Pos) /*!< SC_T::ALTCTL: RX_BGT_EN Mask */
N
N#define SC_ALTCTL_INIT_SEL_Pos              8                                /*!< SC_T::ALTCTL: INIT_SEL Position */
N#define SC_ALTCTL_INIT_SEL_Msk              (3ul << SC_ALTCTL_INIT_SEL_Pos)  /*!< SC_T::ALTCTL: INIT_SEL Mask */
N
N#define SC_ALTCTL_TMR2_SEN_Pos              7                                /*!< SC_T::ALTCTL: TMR2_SEN Position */
N#define SC_ALTCTL_TMR2_SEN_Msk              (1ul << SC_ALTCTL_TMR2_SEN_Pos)  /*!< SC_T::ALTCTL: TMR2_SEN Mask */
N
N#define SC_ALTCTL_TMR1_SEN_Pos              6                                /*!< SC_T::ALTCTL: TMR1_SEN Position */
N#define SC_ALTCTL_TMR1_SEN_Msk              (1ul << SC_ALTCTL_TMR1_SEN_Pos)  /*!< SC_T::ALTCTL: TMR1_SEN Mask */
N
N#define SC_ALTCTL_TMR0_SEN_Pos              5                                /*!< SC_T::ALTCTL: TMR0_SEN Position */
N#define SC_ALTCTL_TMR0_SEN_Msk              (1ul << SC_ALTCTL_TMR0_SEN_Pos)  /*!< SC_T::ALTCTL: TMR0_SEN Mask */
N
N#define SC_ALTCTL_WARST_EN_Pos              4                                /*!< SC_T::ALTCTL: WARST_EN Position */
N#define SC_ALTCTL_WARST_EN_Msk              (1ul << SC_ALTCTL_WARST_EN_Pos)  /*!< SC_T::ALTCTL: WARST_EN Mask */
N
N#define SC_ALTCTL_ACT_EN_Pos                3                                /*!< SC_T::ALTCTL: ACT_EN Position */
N#define SC_ALTCTL_ACT_EN_Msk                (1ul << SC_ALTCTL_ACT_EN_Pos)    /*!< SC_T::ALTCTL: ACT_EN Mask */
N
N#define SC_ALTCTL_DACT_EN_Pos               2                                /*!< SC_T::ALTCTL: DACT_EN Position */
N#define SC_ALTCTL_DACT_EN_Msk               (1ul << SC_ALTCTL_DACT_EN_Pos)   /*!< SC_T::ALTCTL: DACT_EN Mask */
N
N#define SC_ALTCTL_RX_RST_Pos                1                                /*!< SC_T::ALTCTL: RX_RST Position */
N#define SC_ALTCTL_RX_RST_Msk                (1ul << SC_ALTCTL_RX_RST_Pos)    /*!< SC_T::ALTCTL: RX_RST Mask */
N
N#define SC_ALTCTL_TX_RST_Pos                0                                /*!< SC_T::ALTCTL: TX_RST Position */
N#define SC_ALTCTL_TX_RST_Msk                (1ul << SC_ALTCTL_TX_RST_Pos)    /*!< SC_T::ALTCTL: TX_RST Mask */
N
N/* SC EGTR Bit Field Definitions */
N#define SC_EGTR_EGT_Pos                     0                               /*!< SC_T::EGTR: EGT Position */
N#define SC_EGTR_EGT_Msk                     (0xFFul << SC_EGTR_EGT_Pos)     /*!< SC_T::EGTR: EGT Mask */
N
N/* SC RFTMR Bit Field Definitions */
N#define SC_RFTMR_RFTM_Pos                   0                               /*!< SC_T::RFTMR: RFTM Position */
N#define SC_RFTMR_RFTM_Msk                   (0x1FFul << SC_RFTMR_RFTM_Pos)  /*!< SC_T::RFTMR: RFTM Mask */
N
N/* SC ETUCR Bit Field Definitions */
N#define SC_ETUCR_COMPEN_EN_Pos              15                               /*!< SC_T::ETUCR: COMPEN_EN Position */
N#define SC_ETUCR_COMPEN_EN_Msk              (1ul << SC_ETUCR_COMPEN_EN_Pos)  /*!< SC_T::ETUCR: COMPEN_EN Mask */
N
N#define SC_ETUCR_ETU_RDIV_Pos               0                                   /*!< SC_T::ETUCR: ETU_RDIV Position */
N#define SC_ETUCR_ETU_RDIV_Msk               (0xFFFul << SC_ETUCR_ETU_RDIV_Pos)  /*!< SC_T::ETUCR: ETU_RDIV Mask */
N
N/* SC IER Bit Field Definitions */
N#define SC_IER_ACON_ERR_IE_Pos              10                                  /*!< SC_T::IER: ACON_ERR_IE Position */
N#define SC_IER_ACON_ERR_IE_Msk              (1ul << SC_IER_ACON_ERR_IE_Pos)     /*!< SC_T::IER: ACON_ERR_IE Mask */
N
N#define SC_IER_RTMR_IE_Pos                  9                               /*!< SC_T::IER: RTMR_IE Position */
N#define SC_IER_RTMR_IE_Msk                  (1ul << SC_IER_RTMR_IE_Pos)     /*!< SC_T::IER: RTMR_IE Mask */
N
N#define SC_IER_INIT_IE_Pos                  8                               /*!< SC_T::IER: INIT_IE Position */
N#define SC_IER_INIT_IE_Msk                  (1ul << SC_IER_INIT_IE_Pos)     /*!< SC_T::IER: INIT_IE Mask */
N
N#define SC_IER_CD_IE_Pos                    7                               /*!< SC_T::IER: CD_IE Position */
N#define SC_IER_CD_IE_Msk                    (1ul << SC_IER_CD_IE_Pos)       /*!< SC_T::IER: CD_IE Mask */
N
N#define SC_IER_BGT_IE_Pos                   6                               /*!< SC_T::IER: BGT_IE Position */
N#define SC_IER_BGT_IE_Msk                   (1ul << SC_IER_BGT_IE_Pos)      /*!< SC_T::IER: BGT_IE Mask */
N
N#define SC_IER_TMR2_IE_Pos                  5                               /*!< SC_T::IER: TMR2_IE Position */
N#define SC_IER_TMR2_IE_Msk                  (1ul << SC_IER_TMR2_IE_Pos)     /*!< SC_T::IER: TMR2_IE Mask */
N
N#define SC_IER_TMR1_IE_Pos                  4                               /*!< SC_T::IER: TMR1_IE Position */
N#define SC_IER_TMR1_IE_Msk                  (1ul << SC_IER_TMR1_IE_Pos)     /*!< SC_T::IER: TMR1_IE Mask */
N
N#define SC_IER_TMR0_IE_Pos                  3                               /*!< SC_T::IER: TMR0_IE Position */
N#define SC_IER_TMR0_IE_Msk                  (1ul << SC_IER_TMR0_IE_Pos)     /*!< SC_T::IER: TMR0_IE Mask */
N
N#define SC_IER_TERR_IE_Pos                  2                               /*!< SC_T::IER: TERR_IE Position */
N#define SC_IER_TERR_IE_Msk                  (1ul << SC_IER_TERR_IE_Pos)     /*!< SC_T::IER: TERR_IE Mask */
N
N#define SC_IER_TBE_IE_Pos                   1                               /*!< SC_T::IER: TBE_IE Position */
N#define SC_IER_TBE_IE_Msk                   (1ul << SC_IER_TBE_IE_Pos)      /*!< SC_T::IER: TBE_IE Mask */
N
N#define SC_IER_RDA_IE_Pos                   0                               /*!< SC_T::IER: RDA_IE Position */
N#define SC_IER_RDA_IE_Msk                   (1ul << SC_IER_RDA_IE_Pos)      /*!< SC_T::IER: RDA_IE Mask */
N
N/* SC ISR Bit Field Definitions */
N#define SC_ISR_ACON_ERR_IS_Pos              10                              /*!< SC_T::ISR: ACON_ERR_IS Position */
N#define SC_ISR_ACON_ERR_IS_Msk              (1ul << SC_ISR_ACON_ERR_IS_Pos) /*!< SC_T::ISR: ACON_ERR_IS Mask */
N
N#define SC_ISR_RTMR_IS_Pos                  9                               /*!< SC_T::ISR: RTMR_IS Position */
N#define SC_ISR_RTMR_IS_Msk                  (1ul << SC_ISR_RTMR_IS_Pos)     /*!< SC_T::ISR: RTMR_IS Mask */
N
N#define SC_ISR_INIT_IS_Pos                  8                               /*!< SC_T::ISR: INIT_IS Position */
N#define SC_ISR_INIT_IS_Msk                  (1ul << SC_ISR_INIT_IS_Pos)     /*!< SC_T::ISR: INIT_IS Mask */
N
N#define SC_ISR_CD_IS_Pos                    7                               /*!< SC_T::ISR: CD_IS Position */
N#define SC_ISR_CD_IS_Msk                    (1ul << SC_ISR_CD_IS_Pos)       /*!< SC_T::ISR: CD_IS Mask */
N
N#define SC_ISR_BGT_IS_Pos                   6                               /*!< SC_T::ISR: BGT_IS Position */
N#define SC_ISR_BGT_IS_Msk                   (1ul << SC_ISR_BGT_IS_Pos)      /*!< SC_T::ISR: BGT_IS Mask */
N
N#define SC_ISR_TMR2_IS_Pos                  5                               /*!< SC_T::ISR: TMR2_IS Position */
N#define SC_ISR_TMR2_IS_Msk                  (1ul << SC_ISR_TMR2_IS_Pos)     /*!< SC_T::ISR: TMR2_IS Mask */
N
N#define SC_ISR_TMR1_IS_Pos                  4                               /*!< SC_T::ISR: TMR1_IS Position */
N#define SC_ISR_TMR1_IS_Msk                  (1ul << SC_ISR_TMR1_IS_Pos)     /*!< SC_T::ISR: TMR1_IS Mask */
N
N#define SC_ISR_TMR0_IS_Pos                  3                               /*!< SC_T::ISR: TMR0_IS Position */
N#define SC_ISR_TMR0_IS_Msk                  (1ul << SC_ISR_TMR0_IS_Pos)     /*!< SC_T::ISR: TMR0_IS Mask */
N
N#define SC_ISR_TERR_IS_Pos                  2                               /*!< SC_T::ISR: TERR_IS Position */
N#define SC_ISR_TERR_IS_Msk                  (1ul << SC_ISR_TERR_IS_Pos)     /*!< SC_T::ISR: TERR_IS Mask */
N
N#define SC_ISR_TBE_IS_Pos                   1                               /*!< SC_T::ISR: TXBE_IS Position */
N#define SC_ISR_TBE_IS_Msk                   (1ul << SC_ISR_TBE_IS_Pos)      /*!< SC_T::ISR: TXBE_IS Mask */
N
N#define SC_ISR_RDA_IS_Pos                   0                               /*!< SC_T::ISR: RDA_IS Position */
N#define SC_ISR_RDA_IS_Msk                   (1ul << SC_ISR_RDA_IS_Pos)      /*!< SC_T::ISR: RDA_IS Mask */
N
N
N/* SC TRSR Bit Field Definitions */
N#define SC_TRSR_TX_ATV_Pos                  31                              /*!< SC_T::TRSR: TX_ATV Position */
N#define SC_TRSR_TX_ATV_Msk                  (1ul << SC_TRSR_TX_ATV_Pos)     /*!< SC_T::TRSR: TX_ATV Mask */
N
N#define SC_TRSR_TX_OVER_REERR_Pos           30                                  /*!< SC_T::TRSR: TX_OVER_REERR Position */
N#define SC_TRSR_TX_OVER_REERR_Msk           (1ul << SC_TRSR_TX_OVER_REERR_Pos)  /*!< SC_T::TRSR: TX_OVER_REERR Mask */
N
N#define SC_TRSR_TX_REERR_Pos                29                               /*!< SC_T::TRSR: TX_REERR Position */
N#define SC_TRSR_TX_REERR_Msk                (1ul << SC_TRSR_TX_REERR_Pos)    /*!< SC_T::TRSR: TX_REERR Mask */
N
N#define SC_TRSR_TX_POINT_F_Pos              24                               /*!< SC_T::TRSR: TX_POINT_F Position */
N#define SC_TRSR_TX_POINT_F_Msk              (3ul << SC_TRSR_TX_POINT_F_Pos)  /*!< SC_T::TRSR: TX_POINT_F Mask */
N
N#define SC_TRSR_RX_ATV_Pos                  23                               /*!< SC_T::TRSR: RX_ATV Position */
N#define SC_TRSR_RX_ATV_Msk                  (1ul << SC_TRSR_RX_ATV_Pos)      /*!< SC_T::TRSR: RX_ATV Mask */
N
N#define SC_TRSR_RX_OVER_REERR_Pos           22                                  /*!< SC_T::TRSR: RX_OVER_REERR Position */
N#define SC_TRSR_RX_OVER_REERR_Msk           (1ul << SC_TRSR_RX_OVER_REERR_Pos)  /*!< SC_T::TRSR: RX_OVER_REERR Mask */
N
N#define SC_TRSR_RX_REERR_Pos                21                                  /*!< SC_T::TRSR: RX_REERR Position */
N#define SC_TRSR_RX_REERR_Msk                (1ul << SC_TRSR_RX_REERR_Pos)       /*!< SC_T::TRSR: RX_REERR Mask */
N
N#define SC_TRSR_RX_POINT_F_Pos              16                                  /*!< SC_T::TRSR: RX_POINT_F Position */
N#define SC_TRSR_RX_POINT_F_Msk              (3ul << SC_TRSR_RX_POINT_F_Pos)     /*!< SC_T::TRSR: RX_POINT_F Mask */
N
N#define SC_TRSR_TX_FULL_F_Pos               10                                  /*!< SC_T::TRSR: TX_FULL_F Position */
N#define SC_TRSR_TX_FULL_F_Msk               (1ul << SC_TRSR_TX_FULL_F_Pos)      /*!< SC_T::TRSR: TX_FULL_F Mask */
N
N#define SC_TRSR_TX_EMPTY_F_Pos              9                                   /*!< SC_T::TRSR: TX_EMPTY_F Position */
N#define SC_TRSR_TX_EMPTY_F_Msk              (1ul << SC_TRSR_TX_EMPTY_F_Pos)     /*!< SC_T::TRSR: TX_EMPTY_F Mask */
N
N#define SC_TRSR_TX_OVER_F_Pos               8                                   /*!< SC_T::TRSR: TX_OVER_F Position */
N#define SC_TRSR_TX_OVER_F_Msk               (1ul << SC_TRSR_TX_OVER_F_Pos)      /*!< SC_T::TRSR: TX_OVER_F Mask */
N
N#define SC_TRSR_RX_EBR_F_Pos                6                                   /*!< SC_T::TRSR: RX_EBR_F Position */
N#define SC_TRSR_RX_EBR_F_Msk                (1ul << SC_TRSR_RX_EBR_F_Pos)       /*!< SC_T::TRSR: RX_EBR_F Mask */
N
N#define SC_TRSR_RX_EFR_F_Pos                5                                   /*!< SC_T::TRSR: RX_EFR_F Position */
N#define SC_TRSR_RX_EFR_F_Msk                (1ul << SC_TRSR_RX_EFR_F_Pos)       /*!< SC_T::TRSR: RX_EFR_F Mask */
N
N#define SC_TRSR_RX_EPA_F_Pos                4                                   /*!< SC_T::TRSR: RX_EPA_F Position */
N#define SC_TRSR_RX_EPA_F_Msk                (1ul << SC_TRSR_RX_EPA_F_Pos)       /*!< SC_T::TRSR: RX_EPA_F Mask */
N
N#define SC_TRSR_RX_FULL_F_Pos               2                                   /*!< SC_T::TRSR: RX_FULL_F Position */
N#define SC_TRSR_RX_FULL_F_Msk               (1ul << SC_TRSR_RX_FULL_F_Pos)      /*!< SC_T::TRSR: RX_FULL_F Mask */
N
N#define SC_TRSR_RX_EMPTY_F_Pos              1                                   /*!< SC_T::TRSR: RX_EMPTY_F Position */
N#define SC_TRSR_RX_EMPTY_F_Msk              (1ul << SC_TRSR_RX_EMPTY_F_Pos)     /*!< SC_T::TRSR: RX_EMPTY_F Mask */
N
N#define SC_TRSR_RX_OVER_F_Pos               0                                   /*!< SC_T::TRSR: RX_OVER_F Position */
N#define SC_TRSR_RX_OVER_F_Msk               (1ul << SC_TRSR_RX_OVER_F_Pos)      /*!< SC_T::TRSR: RX_OVER_F Mask */
N
N/* SC PINCSR Bit Field Definitions */
N#define SC_PINCSR_SYNC_Pos                  30                                  /*!< SC_T::PINCSR: SYNC Position */
N#define SC_PINCSR_SYNC_Msk                  (1ul << SC_PINCSR_SYNC_Pos)         /*!< SC_T::PINCSR: SYNC Mask */
N
N#define SC_PINCSR_SC_DATA_I_ST_Pos          16                                  /*!< SC_T::PINCSR: SC_DATA_I_ST Position */
N#define SC_PINCSR_SC_DATA_I_ST_Msk          (1ul << SC_PINCSR_SC_DATA_I_ST_Pos) /*!< SC_T::PINCSR: SC_DATA_I_ST Mask */
N
N#define SC_PINCSR_POW_INV_Pos               11                                  /*!< SC_T::PINCSR: POW_INV Position */
N#define SC_PINCSR_POW_INV_Msk               (1ul << SC_PINCSR_POW_INV_Pos)      /*!< SC_T::PINCSR: POW_INV Mask */
N
N#define SC_PINCSR_CD_LEV_Pos                10                                  /*!< SC_T::PINCSR: CD_LEV Position */
N#define SC_PINCSR_CD_LEV_Msk                (1ul << SC_PINCSR_CD_LEV_Pos)       /*!< SC_T::PINCSR: CD_LEV Mask */
N
N#define SC_PINCSR_SC_DATA_O_Pos             9                                   /*!< SC_T::PINCSR: SC_DATA_O Position */
N#define SC_PINCSR_SC_DATA_O_Msk             (1ul << SC_PINCSR_SC_DATA_O_Pos)    /*!< SC_T::PINCSR: SC_DATA_O Mask */
N
N#define SC_PINCSR_SC_OEN_ST_Pos             8                                   /*!< SC_T::PINCSR: SC_OEN_ST Position */
N#define SC_PINCSR_SC_OEN_ST_Msk             (1ul << SC_PINCSR_SC_OEN_ST_Pos)    /*!< SC_T::PINCSR: SC_OEN_ST Mask */
N
N#define SC_PINCSR_ADAC_CD_EN_Pos            7                                   /*!< SC_T::PINCSR: ADAC_CD_EN Position */
N#define SC_PINCSR_ADAC_CD_EN_Msk            (1ul << SC_PINCSR_ADAC_CD_EN_Pos)   /*!< SC_T::PINCSR: ADAC_CD_EN Mask */
N
N#define SC_PINCSR_CLK_KEEP_Pos              6                                   /*!< SC_T::PINCSR: CLK_KEEP Position */
N#define SC_PINCSR_CLK_KEEP_Msk              (1ul << SC_PINCSR_CLK_KEEP_Pos)     /*!< SC_T::PINCSR: CLK_KEEP Mask */
N
N#define SC_PINCSR_CD_PIN_ST_Pos             4                                   /*!< SC_T::PINCSR: CD_PIN_ST Position */
N#define SC_PINCSR_CD_PIN_ST_Msk             (1ul << SC_PINCSR_CD_PIN_ST_Pos)    /*!< SC_T::PINCSR: CD_PIN_ST Mask */
N
N#define SC_PINCSR_CD_INS_F_Pos              3                                   /*!< SC_T::PINCSR: CD_INS_F Position */
N#define SC_PINCSR_CD_INS_F_Msk              (1ul << SC_PINCSR_CD_INS_F_Pos)     /*!< SC_T::PINCSR: CD_INS_F Mask */
N
N#define SC_PINCSR_CD_REM_F_Pos              2                                   /*!< SC_T::PINCSR: CD_REM_F Position */
N#define SC_PINCSR_CD_REM_F_Msk              (1ul << SC_PINCSR_CD_REM_F_Pos)     /*!< SC_T::PINCSR: CD_REM_F Mask */
N
N#define SC_PINCSR_SC_RST_Pos                1                                   /*!< SC_T::PINCSR: SC_RST Position */
N#define SC_PINCSR_SC_RST_Msk                (1ul << SC_PINCSR_SC_RST_Pos)       /*!< SC_T::PINCSR: SC_RST Mask */
N
N#define SC_PINCSR_POW_EN_Pos                0                                   /*!< SC_T::PINCSR: POW_EN Position */
N#define SC_PINCSR_POW_EN_Msk                (1ul << SC_PINCSR_POW_EN_Pos)       /*!< SC_T::PINCSR: POW_EN Mask */
N
N/* SC TMR0 Bit Field Definitions */
N#define SC_TMR0_MODE_Pos                    24                              /*!< SC_T::TMR0: MODE Position */
N#define SC_TMR0_MODE_Msk                    (0xFul << SC_TMR0_MODE_Pos)     /*!< SC_T::TMR0: MODE Mask */
N
N#define SC_TMR0_CNT_Pos                     0                               /*!< SC_T::TMR0: CNT Position */
N#define SC_TMR0_CNT_Msk                     (0xFFFFFFul << SC_TMR0_CNT_Pos) /*!< SC_T::TMR0: CNT Mask */
N
N/* SC TMR1 Bit Field Definitions */
N#define SC_TMR1_MODE_Pos                    24                              /*!< SC_T::TMR1: MODE Position */
N#define SC_TMR1_MODE_Msk                    (0xFul << SC_TMR1_MODE_Pos)     /*!< SC_T::TMR1: MODE Mask */
N
N#define SC_TMR1_CNT_Pos                     0                               /*!< SC_T::TMR1: CNT Position */
N#define SC_TMR1_CNT_Msk                     (0xFFul << SC_TMR1_CNT_Pos)     /*!< SC_T::TMR1: CNT Mask */
N
N/* SC TMR2 Bit Field Definitions */
N#define SC_TMR2_MODE_Pos                    24                              /*!< SC_T::TMR2: MODE Position */
N#define SC_TMR2_MODE_Msk                    (0xFul << SC_TMR2_MODE_Pos)     /*!< SC_T::TMR2: MODE Mask */
N
N#define SC_TMR2_CNT_Pos                     0                               /*!< SC_T::TMR2: CNT Position */
N#define SC_TMR2_CNT_Msk                     (0xFFul << SC_TMR2_CNT_Pos)     /*!< SC_T::TMR2: CNT Mask */
N
N/* SC UACTL Bit Field Definitions */
N#define SC_UACTL_OPE_Pos                   7                                /*!< SC_T::UACTL: OPE Position */
N#define SC_UACTL_OPE_Msk                   (1ul << SC_UACTL_OPE_Pos)        /*!< SC_T::UACTL: OPE Mask */
N
N#define SC_UACTL_PBDIS_Pos                 6                                /*!< SC_T::UACTL: PBDIS Position */
N#define SC_UACTL_PBDIS_Msk                 (1ul << SC_UACTL_PBDIS_Pos)      /*!< SC_T::UACTL: PBDIS Mask */
N
N#define SC_UACTL_DATA_LEN_Pos              4                                /*!< SC_T::UACTL: DATA_LEN Position */
N#define SC_UACTL_DATA_LEN_Msk              (3ul << SC_UACTL_DATA_LEN_Pos)   /*!< SC_T::UACTL: DATA_LEN Mask */
N
N#define SC_UACTL_UA_MODE_EN_Pos            0                                /*!< SC_T::UACTL: UA_MODE_EN Position */
N#define SC_UACTL_UA_MODE_EN_Msk            (1ul << SC_UACTL_UA_MODE_EN_Pos) /*!< SC_T::UACTL: UA_MODE_EN Mask */
N
N/* SC TDRA Bit Field Definitions */
N#define SC_TDRA_TDR0_Pos                    0                                   /*!< SC_T::TDRA: TDR0 Position */
N#define SC_TDRA_TDR0_Msk                    (0xFFFFFFul << SC_TDRA_TDR0_Pos)    /*!< SC_T::TDRA: TDR0 Mask */
N
N/* SC TDRB Bit Field Definitions */
N#define SC_TDRB_TDR2_Pos                    8                               /*!< SC_T::TDRB: TDR2 Position */
N#define SC_TDRB_TDR2_Msk                    (0xFFul << SC_TDRB_TDR2_Pos)    /*!< SC_T::TDRB: TDR2 Mask */
N
N#define SC_TDRB_TDR1_Pos                    0                               /*!< SC_T::TDRB: TDR1 Position */
N#define SC_TDRB_TDR1_Msk                    (0xFFul << SC_TDRB_TDR1_Pos)    /*!< SC_T::TDRB: TDR1 Mask */
N
N/*@}*/ /* end of group SC_CONST */
N/*@}*/ /* end of group SMARTCARD */
N
N
N/*---------------------- Serial Peripheral Interface Controller -------------------------*/
N/**
N    @addtogroup SPI Serial Peripheral Interface Controller (SPI)
N    Memory Mapped Structure for SPI Controller
N@{ */
N
N
N
Ntypedef struct
N{
N
N
N/**
N * @var SPI_T::CNTRL
N * Offset: 0x00  Control and Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |GO_BUSY   |SPI Transfer Control Bit And Busy Status
N * |        |          |0 = Data transfer stopped.
N * |        |          |1 = In Master mode, writing 1 to this bit to start the SPI data transfer; in Slave mode,
N * |        |          |    writing 1 to this bit indicates that the slave is ready to communicate with a master.
N * |        |          |If FIFO mode is disabled, during the data transfer, this bit keeps the value of 1.
N * |        |          |As the transfer is finished, this bit will be cleared automatically.
N * |        |          |Software can read this bit to check if the SPI is in busy status.
N * |        |          |In FIFO mode, this bit will be controlled by hardware.
N * |        |          |Software should not modify this bit.
N * |        |          |In Slave mode, this bit always returns 1 when this register is read by software.
N * |        |          |In Master mode, this bit reflects the busy or idle status of SPI.
N * |        |          |Note:
N * |        |          |1. When FIFO mode is disabled, all configurations should be set before writing 1 to this GO_BUSY
N * |        |          |bit.
N * |        |          |2. When FIFO mode is disabled and the software uses TX or RX PDMA function to transfer data,
N * |        |          |this bit
N * |        |          |   will be cleared after the PDMA finishes the data transfer.
N * |[1]     |RX_NEG    |Receive On Negative Edge
N * |        |          |0 = Received data input signal is latched on the rising edge of SPI bus clock.
N * |        |          |1 = Received data input signal is latched on the falling edge of SPI bus clock.
N * |[2]     |TX_NEG    |Transmit On Negative Edge
N * |        |          |0 = Transmitted data output signal is changed on the rising edge of SPI bus clock.
N * |        |          |1 = Transmitted data output signal is changed on the falling edge of SPI bus clock.
N * |[7:3]   |TX_BIT_LEN|Transmit Bit Length
N * |        |          |This field specifies how many bits can be transmitted / received in one transaction.
N * |        |          |The minimum bit length is 8 bits and can up to 32 bits.
N * |        |          |TX_BIT_LEN = 0x08 ... 8 bits.
N * |        |          |TX_BIT_LEN = 0x09 ... 9 bits.
N * |        |          |......
N * |        |          |TX_BIT_LEN = 0x1F ... 31 bits.
N * |        |          |TX_BIT_LEN = 0x00 ... 32 bits.
N * |[10]    |LSB       |Send LSB First
N * |        |          |0 = The MSB, which bit of transmit/receive register depends on the setting of TX_BIT_LEN, is
N * |        |          |transmitted/received first.
N * |        |          |1 = The LSB, bit 0 of the SPI TX0/1 register, is sent first to the SPI data output pin, and the
N * |        |          |first bit received from
N * |        |          | the SPI data input pin will be put in the LSB position of the RX register (bit 0 of SPI_RX0/1).
N * |[11]    |CLKP      |Clock Polarity
N * |        |          |0 = SPI bus clock is idle low.
N * |        |          |1 = SPI bus clock is idle high.
N * |[15:12] |SP_CYCLE  |Suspend Interval (Master Only)
N * |        |          |The four bits provide configurable suspend interval between two successive transmit/receive
N * |        |          |transaction in a transfer.
N * |        |          |The definition of the suspend interval is the interval between the last clock edge of the
N * |        |          |preceding transaction word
N * |        |          |and the first clock edge of the following transaction word.
N * |        |          |The default value is 0x3.
N * |        |          |The period of the suspend interval is obtained according to the following equation.
N * |        |          |(SP_CYCLE[3:0] + 0.5) * period of SPI bus clock cycle
N * |        |          |Example:
N * |        |          |SP_CYCLE = 0x0 ... 0.5 SPI bus clock cycle.
N * |        |          |SP_CYCLE = 0x1 ... 1.5 SPI bus clock cycle.
N * |        |          |......
N * |        |          |SP_CYCLE = 0xE ... 14.5 SPI bus clock cycle.
N * |        |          |SP_CYCLE = 0xF ... 15.5 SPI bus clock cycle.
N * |        |          |If the variable clock function is enabled and the transmit FIFO buffer is not empty, the minimum
N * |        |          |period of suspend
N * |        |          |interval between the successive transactions is (6.5 + SP_CYCLE) * SPI bus clock cycle.
N * |[16]    |IF        |Unit Transfer Interrupt Flag
N * |        |          |0 = No transaction has been finished since this bit was cleared to 0.
N * |        |          |1 = SPI controller has finished one unit transfer.
N * |        |          |Note: This bit will be cleared by writing 1 to itself.
N * |[17]    |IE        |Unit Transfer Interrupt Enable
N * |        |          |0 = SPI unit transfer interrupt Disabled.
N * |        |          |1 = SPI unit transfer interrupt Enabled.
N * |[18]    |SLAVE     |Slave Mode Enable
N * |        |          |0 = Master mode.
N * |        |          |1 = Slave mode.
N * |[19]    |REORDER   |Byte Reorder Function Enable
N * |        |          |0 = Byte Reorder function Disabled.
N * |        |          |1 = Byte Reorder function Enabled.
N * |        |          |A byte suspend interval will be inserted among each byte.
N * |        |          |The period of the byte suspend interval depends on the setting of SP_CYCLE.
N * |        |          |Note:
N * |        |          |1. Byte Reorder function is only available if TX_BIT_LEN is defined as 16, 24, and 32 bits.
N * |        |          |2. In Slave mode with level-trigger configuration, the slave select pin must be kept at active
N * |        |          |state during the
N * |        |          |   byte suspend interval.
N * |        |          |3. The Byte Reorder function is not supported when the variable bus clock function or Dual I/O
N * |        |          |mode is enabled.
N * |[21]    |FIFO      |FIFO Mode Enable
N * |        |          |0 = FIFO mode Disabled.
N * |        |          |1 = FIFO mode Enabled.
N * |        |          |Note:
N * |        |          |1. Before enabling FIFO mode, the other related settings should be set in advance.
N * |        |          |2. In Master mode, if the FIFO mode is enabled, the GO_BUSY bit will be set to 1 automatically
N * |        |          |after writing data
N * |        |          | to the transmit FIFO buffer; the GO_BUSY bit will be cleared to 0 automatically when the SPI
N * |        |          |controller is in idle.
N * |        |          | If all data stored at transmit FIFO buffer are sent out, the TX_EMPTY bit will be set to 1 and
N * |        |          |the GO_BUSY bit will be cleared to 0.
N * |        |          |3. After clearing this bit to 0, user must wait for at least 2 peripheral clock periods before
N * |        |          |setting this bit to 1 again.
N * |[22]    |TWOB      |2-Bit Transfer Mode Enable
N * |        |          |0 = 2-bit Transfer mode Disabled.
N * |        |          |1 = 2-bit Transfer mode Enabled.
N * |        |          |Note: When 2-bit Transfer mode is enabled, the serial transmitted 2-bit data are from SPI_TX1/0,
N * |        |          |and the received 2-bit data input are put in SPI_RX1/0.
N * |[23]    |VARCLK_EN |Variable Clock Enable (Master Only)
N * |        |          |0 = SPI clock output frequency is fixed and decided only by the value of DIVIDER.
N * |        |          |1 = SPI clock output frequency is variable.
N * |        |          |The output frequency is decided by the value of VARCLK, DIVIDER, and DIVIDER2.
N * |        |          |Note: When this VARCLK_EN bit is set to 1, the setting of TX_BIT_LEN must be programmed as 0x10
N * |        |          |(16-bit mode).
N * |[24]    |RX_EMPTY  |Receive FIFO Buffer Empty Indicator (Read Only)
N * |        |          |It is a mutual mirror bit of SPI_STATUS[24].
N * |        |          |0 = Receive FIFO buffer is not empty.
N * |        |          |1 = Receive FIFO buffer is empty.
N * |[25]    |RX_FULL   |Receive FIFO Buffer Full Indicator (Read Only)
N * |        |          |It is a mutual mirror bit of SPI_STATUS[25].
N * |        |          |0 = Receive FIFO buffer is not full.
N * |        |          |1 = Receive FIFO buffer is full.
N * |[26]    |TX_EMPTY  |Transmit FIFO Buffer Empty Indicator (Read Only)
N * |        |          |It is a mutual mirror bit of SPI_STATUS[26].
N * |        |          |0 = Transmit FIFO buffer is not empty.
N * |        |          |1 = Transmit FIFO buffer is empty.
N * |[27]    |TX_FULL   |Transmit FIFO Buffer Full Indicator (Read Only)
N * |        |          |It is a mutual mirror bit of SPI_STATUS[27].
N * |        |          |0 = Transmit FIFO buffer is not full.
N * |        |          |1 = Transmit FIFO buffer is full.
N * @var SPI_T::DIVIDER
N * Offset: 0x04  Clock Divider Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |DIVIDER   |Clock Divider 1 Register
N * |        |          |The value in this field is the frequency divider for generating the SPI peripheral clock and the
N * |        |          |SPI bus clock of SPI master.
N * |        |          |The frequency is obtained according to the following equation.
N * |        |          |If the bit of BCn, SPI_CNTRL2[31], is set to 0,
N * |        |          |   SPI peripheral clock frequency = system clock frequency / (DIVIDER + 1) / 2
N * |        |          |else if BCn is set to 1,
N * |        |          |   SPI peripheral clock frequency = SPI peripheral clock source frequency / (DIVIDER + 1)
N * |        |          |The SPI peripheral clock source is defined in the CLKSEL1 register.
N * |[23:16] |DIVIDER2  |Clock Divider 2 Register (Master Only)
N * |        |          |The value in this field is the 2nd frequency divider for generating the second clock of the
N * |        |          |variable clock function.
N * |        |          |The frequency is obtained according to the following equation:
N * |        |          |   f_clk2 = SPI peripheral clock frequency / (DIVIDER2 + 1) / 2
N * |        |          |If the VARCLK_EN bit is cleared to 0, this setting is unmeaning.
N * @var SPI_T::SSR
N * Offset: 0x08  Slave Select Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1:0]   |SSR       |Slave Select Control Bits (Master Only)
N * |        |          |If AUTOSS bit is cleared, writing 1 to any bit of this field sets the proper SPIn_SPISS0/1
N * |        |          |line to an active state and writing 0 sets the line back to inactive state.
N * |        |          |If the AUTOSS bit is set, writing 0 to any bit location of this field will keep the
N * |        |          |corresponding
N * |        |          |SPIn_SPISS0/1 line at inactive state; writing 1 to any bit location of this field will select
N * |        |          |appropriate SPIn_SPISS0/1 line to be automatically driven to active state for the duration of
N * |        |          |the
N * |        |          |transmit/receive, and will be driven to inactive state for the rest of the time.
N * |        |          |The active state of SPIn_SPISS0/1 is specified in SS_LVL.
N * |        |          |Note: SPIn_SPISS0 is defined as the slave select input in Slave mode.
N * |[2]     |SS_LVL    |Slave Select Active Level
N * |        |          |This bit defines the active status of slave select signal (SPIn_SPISS0/1).
N * |        |          |0 = The slave select signal SPIn_SPISS0/1 is active on low-level/falling-edge.
N * |        |          |1 = The slave select signal SPIn_SPISS0/1 is active on high-level/rising-edge.
N * |[3]     |AUTOSS    |Automatic Slave Select Function Enable (Master Only)
N * |        |          |0 = If this bit is cleared, slave select signals will be asserted/de-asserted by setting
N * |        |          |/clearing
N * |        |          |    the corresponding bits of SPI_SSR[1:0].
N * |        |          |1 = If this bit is set, SPIn_SPISS0/1 signals will be generated automatically.
N * |        |          | It means that device/slave select signal, which is set in SPI_SSR[1:0], will be asserted by the
N * |        |          | SPI controller when transmit/receive is started, and will be de-asserted after each
N * |        |          |transmit/receive is finished.
N * |[4]     |SS_LTRIG  |Slave Select Level Trigger Enable (Slave Only)
N * |        |          |0 = Slave select signal is edge-trigger.
N * |        |          |    This is the default value.
N * |        |          |    The SS_LVL bit decides the signal is active after a falling-edge or rising-edge.
N * |        |          |1 = Slave select signal is level-trigger.
N * |        |          |    The SS_LVL bit decides the signal is active low or active high.
N * |[5]     |LTRIG_FLAG|Level Trigger Accomplish Flag
N * |        |          |In Slave mode, this bit indicates whether the received bit number meets the requirement or not
N * |        |          |after the current transaction done.
N * |        |          |0 = Transferred bit length of one transaction does not meet the specified requirement.
N * |        |          |1 = Transferred bit length meets the specified requirement which defined in TX_BIT_LEN.
N * |        |          |Note: This bit is READ only.
N * |        |          |As the GO_BUSY bit is set to 1 by software, the LTRIG_FLAG will be cleared to 0 after 4 SPI
N * |        |          |peripheral clock periods plus 1 system clock period.
N * |        |          |In FIFO mode, this bit has no meaning.
N * @var SPI_T::RX
N * Offset: 0x10  Data Receive Register 0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |RX        |Data Receive Register
N * |        |          |The data receive register holds the datum received from SPI data input pin.
N * |        |          |If FIFO mode is disabled, the last received data can be accessed through software by reading
N * |        |          |this register.
N * |        |          |If the FIFO bit is set as 1 and the RX_EMPTY bit, SPI_CNTRL[24] or SPI_STATUS[24], is not set to
N * |        |          |1, the receive
N * |        |          |FIFO buffer can be accessed through software by reading this register. This is a read-only
N * |        |          |register.
N * @var SPI_T::TX
N * Offset: 0x20  Data Transmit Register 0
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |TX        |Data Transmit Register
N * |        |          |The data transmit registers hold the data to be transmitted in the next transfer.
N * |        |          |The number of valid bits depends on the setting of transmit bit length field of the SPI_CNTRL
N * |        |          |register.
N * |        |          |For example, if TX_BIT_LEN is set to 0x08, the bits TX[7:0] will be transmitted in next
N * |        |          |transfer.
N * |        |          |If TX_BIT_LEN is set to 0x00, the SPI controller will perform a 32-bit transfer.
N * |        |          |Note 1: When the SPI controller is configured as a slave device and FIFO mode is disabled, if
N * |        |          |the SPI
N * |        |          | controller attempts to transmit data to a master, the transmit data register should be updated
N * |        |          |        by software before setting the GO_BUSY bit to 1.
N * |        |          |Note 2: In Master mode, SPI controller will start to transfer after 5 peripheral clock cycles
N * |        |          |after user writes to this register.
N * @var SPI_T::VARCLK
N * Offset: 0x34  Variable Clock Pattern Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |VARCLK    |Variable Clock Pattern
N * |        |          |This register defines the clock pattern of the SPI transfer.
N * |        |          |If the variable clock function is disabled, this setting is unmeaning.
N * @var SPI_T::DMA
N * Offset: 0x38  SPI DMA Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |TX_DMA_GO |Transmit DMA Start
N * |        |          |Setting this bit to 1 will start the transmit PDMA process.
N * |        |          |SPI controller will issue request to PDMA controller automatically.
N * |        |          |Hardware will clear this bit to 0 automatically after PDMA transfer done.
N * |        |          |If the SPI transmit PDMA function is used to transfer data, the GO_BUSY bit should not be set to
N * |        |          |1 by software.
N * |        |          |The PDMA control logic of SPI controller will set it automatically whenever necessary.
N * |        |          |In Slave mode and when FIFO mode is disabled, the minimal suspend interval between two
N * |        |          |successive transactions
N * |        |          |must be larger than (8 SPI clock periods + 14 APB clock periods) for edge-trigger mode or
N * |        |          |(9.5 SPI clock periods + 14 APB clock periods) for level-trigger mode.
N * |        |          |If the 2-bit Transfer mode is enabled, additional 18 APB clock periods for the above conditions
N * |        |          |is required.
N * |[1]     |RX_DMA_GO |Receive DMA Start
N * |        |          |Setting this bit to 1 will start the receive PDMA process.
N * |        |          |The SPI controller will issue request to PDMA controller automatically when the SPI receive
N * |        |          |buffer is not empty.
N * |        |          |This bit will be cleared to 0 by hardware automatically after PDMA transfer is done.
N * |        |          |If the software uses the receive PDMA function to access the received data of SPI and does not
N * |        |          |use the transmit
N * |        |          |PDMA function, the GO_BUSY bit should be set by software.
N * |        |          |Enabling FIFO mode is recommended if the software uses more than one PDMA channel to transfer
N * |        |          |data.
N * |        |          |In Slave mode and when FIFO mode is disabled, if the software only uses one PDMA channel for SPI
N * |        |          |receive PDMA
N * |        |          |function and the other PDMA channels are not in use, the minimal suspend interval between two
N * |        |          |successive
N * |        |          |transactions must be larger than (9 SPI slave peripheral clock periods + 4 APB clock periods)
N * |        |          |for Edge-trigger
N * |        |          |mode or (9.5 SPI slave peripheral clock periods + 4 APB clock periods) for Level-trigger mode.
N * |[2]     |PDMA_RST  |PDMA Reset
N * |        |          |0 = No effect.
N * |        |          |1 = Reset the PDMA control logic of the SPI controller. This bit will be cleared to 0
N * |        |          |automatically.
N * @var SPI_T::CNTRL2
N * Offset: 0x3C  Control and Status Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[8]     |NOSLVSEL  |Slave 3-Wire Mode Enable
N * |        |          |This is used to ignore the slave select signal in Slave mode.
N * |        |          |The SPI controller can work with 3-wire interface including SPIn_CLK, SPIn_MISO, and SPIn_MOSI.
N * |        |          |0 = 4-wire bi-direction interface.
N * |        |          |1 = 3-wire bi-direction interface.
N * |        |          |Note: In Slave 3-wire mode, the SS_LTRIG, SPI_SSR[4] will be set as 1 automatically.
N * |[9]     |SLV_ABORT |Slave 3-Wire Mode Abort Control
N * |        |          |In normal operation, there is an interrupt event when the received data meet the required bits
N * |        |          |which defined in TX_BIT_LEN.
N * |        |          |If the received bits are less than the requirement and there is no more SPI clock input over the
N * |        |          |one transfer time in
N * |        |          |Slave 3-wire mode, the user can set this bit to force the current transfer done and then the
N * |        |          |user can get a transfer done interrupt event.
N * |        |          |Note: This bit will be cleared to 0 automatically by hardware after it is set to 1 by software.
N * |[10]    |SSTA_INTEN|Slave 3-Wire Mode Start Interrupt Enable
N * |        |          |Used to enable interrupt when the transfer has started in Slave 3-wire mode.
N * |        |          |If there is no transfer done interrupt over the time period which is defined by user after the
N * |        |          |transfer start,
N * |        |          |the user can set the SLV_ABORT bit to force the transfer done.
N * |        |          |0 = Transaction start interrupt Disabled.
N * |        |          |1 = Transaction start interrupt Enabled.
N * |        |          |It will be cleared to 0 as the current transfer is done or the SLV_START_INTSTS bit is cleared.
N * |[11]    |SLV_START_INTSTS|Slave 3-Wire Mode Start Interrupt Status
N * |        |          |This bit indicates if a transaction has started in Slave 3-wire mode.
N * |        |          |It is a mutual mirror bit of SPI_STATUS[11].
N * |        |          |0 = Slave has not detected any SPI clock transition since the SSTA_INTEN bit was set to 1.
N * |        |          |1 = A transaction has started in Slave 3-wire mode.
N * |        |          |It will be cleared automatically when a transaction is done or by writing 1 to this bit.
N * |[12]    |DUAL_IO_DIR|Dual I/O Mode Direction Control
N * |        |          |0 = Dual Input mode.
N * |        |          |1 = Dual Output mode.
N * |[13]    |DUAL_IO_EN|Dual I/O Mode Enable
N * |        |          |0 = Dual I/O mode Disabled.
N * |        |          |1 = Dual I/O mode Enabled.
N * |[16]    |SS_INT_OPT|Slave Select Inactive Interrupt Option
N * |        |          |This setting is only available if the SPI controller is configured as level trigger slave
N * |        |          |device.
N * |        |          |0 = As the slave select signal goes to inactive level, the IF bit will NOT be set to 1.
N * |        |          |1 = As the slave select signal goes to inactive level, the IF bit will be set to 1.
N * |[31]    |BCn       |SPI Peripheral Clock Backward Compatible Option
N * |        |          |0 = Backward compatible clock configuration.
N * |        |          |1 = Clock configuration is not backward compatible.
N * |        |          |Refer to the description of SPI_DIVIDER register for details.
N * @var SPI_T::FIFO_CTL
N * Offset: 0x40  SPI FIFO Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |RX_CLR    |Clear Receive FIFO Buffer
N * |        |          |0 = No effect.
N * |        |          |1 = Clear receive FIFO buffer.
N * |        |          |The RX_FULL flag will be cleared to 0 and the RX_EMPTY flag will be set to 1.
N * |        |          |This bit will be cleared to 0 by hardware after it is set to 1 by software.
N * |[1]     |TX_CLR    |Clear Transmit FIFO Buffer
N * |        |          |0 = No effect.
N * |        |          |1 = Clear transmit FIFO buffer.
N * |        |          |The TX_FULL flag will be cleared to 0 and the TX_EMPTY flag will be set to 1.
N * |        |          |This bit will be cleared to 0 by hardware after it is set to 1 by software.
N * |[2]     |RX_INTEN  |Receive Threshold Interrupt Enable
N * |        |          |0 = RX threshold interrupt Disabled.
N * |        |          |1 = RX threshold interrupt Enabled.
N * |[3]     |TX_INTEN  |Transmit Threshold Interrupt Enable
N * |        |          |0 = TX threshold interrupt Disabled.
N * |        |          |1 = TX threshold interrupt Enabled.
N * |[6]     |RXOV_INTEN|Receive FIFO Overrun Interrupt Enable
N * |        |          |0 = Receive FIFO overrun interrupt Disabled.
N * |        |          |1 = Receive FIFO overrun interrupt Enabled.
N * |[21]    |TIMEOUT_INTEN|Receive FIFO Time-Out Interrupt Enable
N * |        |          |0 = Time-out interrupt Disabled.
N * |        |          |1 = Time-out interrupt Enabled.
N * |[26:24] |RX_THRESHOLD|Receive FIFO Threshold
N * |        |          |If the valid data count of the receive FIFO buffer is larger than the RX_THRESHOLD setting,
N * |        |          |the RX_INTSTS bit will be set to 1, else the RX_INTSTS bit will be cleared to 0.
N * |[30:28] |TX_THRESHOLD|Transmit FIFO Threshold
N * |        |          |If the valid data count of the transmit FIFO buffer is less than or equal to the TX_THRESHOLD
N * |        |          |setting, the TX_INTSTS bit will be set to 1, else the TX_INTSTS bit will be cleared to 0.
N * @var SPI_T::STATUS
N * Offset: 0x44  SPI Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |RX_INTSTS |Receive FIFO Threshold Interrupt Status (Read Only)
N * |        |          |0 = The valid data count within the Rx FIFO buffer is smaller than or equal to the setting value
N * |        |          |of RX_THRESHOLD.
N * |        |          |1 = The valid data count within the receive FIFO buffer is larger than the setting value of
N * |        |          |RX_THRESHOLD.
N * |        |          |Note: If RX_INTEN = 1 and RX_INTSTS = 1, the SPI controller will generate a SPI interrupt
N * |        |          |request.
N * |[2]     |RX_OVERRUN|Receive FIFO Overrun Status
N * |        |          |When the receive FIFO buffer is full, the follow-up data will be dropped and this bit will be
N * |        |          |set to 1.
N * |        |          |Note: This bit will be cleared by writing 1 to itself.
N * |[4]     |TX_INTSTS |Transmit FIFO Threshold Interrupt Status (Read Only)
N * |        |          |0 = The valid data count within the transmit FIFO buffer is larger than the setting value of
N * |        |          |TX_THRESHOLD.
N * |        |          |1 = The valid data count within the transmit FIFO buffer is less than or equal to the setting
N * |        |          |value of TX_THRESHOLD.
N * |        |          |Note: If TX_INTEN = 1 and TX_INTSTS = 1, the SPI controller will generate a SPI interrupt
N * |        |          |request.
N * |[11]    |SLV_START_INTSTS|Slave Start Interrupt Status
N * |        |          |It is used to dedicate if a transaction has started in Slave 3-wire mode.
N * |        |          |It is a mutual mirror bit of SPI_CNTRL2[11].
N * |        |          |0 = Slave has not detected any SPI clock transition since the SSTA_INTEN bit was set to 1.
N * |        |          |1 = A transaction has started in Slave 3-wire mode.
N * |        |          |It will be cleared as a transaction is done or by writing 1 to this bit.
N * |[15:12] |RX_FIFO_COUNT|Receive FIFO Data Count (Read Only)
N * |        |          |This bit field indicates the valid data count of receive FIFO buffer.
N * |[16]    |IF        |SPI Unit Transfer Interrupt Flag
N * |        |          |It is a mutual mirror bit of SPI_CNTRL[16].
N * |        |          |0 = No transaction has been finished since this bit was cleared to 0.
N * |        |          |1 = SPI controller has finished one unit transfer.
N * |        |          |Note: This bit will be cleared by writing 1 to itself.
N * |[20]    |TIMEOUT   |Time-Out Interrupt Flag
N * |        |          |0 = No receive FIFO time-out event.
N * |        |          |1 = Receive FIFO buffer is not empty and no read operation on receive FIFO buffer over 64 SPI
N * |        |          |clock
N * |        |          |period in Master mode or over 576 SPI peripheral clock period in Slave mode.
N * |        |          |When the received FIFO buffer is read by software, the time-out status will be cleared
N * |        |          |automatically.
N * |        |          |Note: This bit will be cleared by writing 1 to itself.
N * |[24]    |RX_EMPTY  |Receive FIFO Buffer Empty Indicator (Read Only)
N * |        |          |It is a mutual mirror bit of SPI_CNTRL[24].
N * |        |          |0 = Receive FIFO buffer is not empty.
N * |        |          |1 = Receive FIFO buffer is empty.
N * |[25]    |RX_FULL   |Receive FIFO Buffer Empty Indicator (Read Only)
N * |        |          |It is a mutual mirror bit of SPI_CNTRL[25].
N * |        |          |0 = Receive FIFO buffer is not empty.
N * |        |          |1 = Receive FIFO buffer is empty.
N * |[26]    |TX_EMPTY  |Transmit FIFO Buffer Empty Indicator (Read Only)
N * |        |          |It is a mutual mirror bit of SPI_CNTRL[26].
N * |        |          |0 = Transmit FIFO buffer is not empty.
N * |        |          |1 = Transmit FIFO buffer is empty.
N * |[27]    |TX_FULL   |Transmit FIFO Buffer Full Indicator (Read Only)
N * |        |          |It is a mutual mirror bit of SPI_CNTRL[27].
N * |        |          |0 = Transmit FIFO buffer is not full.
N * |        |          |1 = Transmit FIFO buffer is full.
N * |[31:28] |TX_FIFO_COUNT|Transmit FIFO Data Count (Read Only)
N * |        |          |This bit field indicates the valid data count of transmit FIFO buffer.
N */
N
N    __IO uint32_t CNTRL;         /* Offset: 0x00  Control and Status Register                                        */
X    volatile uint32_t CNTRL;          
N    __IO uint32_t DIVIDER;       /* Offset: 0x04  Clock Divider Register                                             */
X    volatile uint32_t DIVIDER;        
N    __IO uint32_t SSR;           /* Offset: 0x08  Slave Select Register                                              */
X    volatile uint32_t SSR;            
N    __I  uint32_t RESERVE0;     
X    volatile const  uint32_t RESERVE0;     
N    __I  uint32_t RX[2];         /* Offset: 0x10  Data Receive Register 0                                            */
X    volatile const  uint32_t RX[2];          
N    __I  uint32_t RESERVE1;     
X    volatile const  uint32_t RESERVE1;     
N    __I  uint32_t RESERVE2;     
X    volatile const  uint32_t RESERVE2;     
N    __O  uint32_t TX[2];         /* Offset: 0x14  Data Receive Register 1                                            */
X    volatile  uint32_t TX[2];          
N    __I  uint32_t RESERVE3;     
X    volatile const  uint32_t RESERVE3;     
N    __I  uint32_t RESERVE4;     
X    volatile const  uint32_t RESERVE4;     
N    __I  uint32_t RESERVE5;     
X    volatile const  uint32_t RESERVE5;     
N    __IO uint32_t VARCLK;        /* Offset: 0x20  Data Transmit Register 0                                           */
X    volatile uint32_t VARCLK;         
N    __IO uint32_t DMA;           /* Offset: 0x24  Data Transmit Register 1                                           */
X    volatile uint32_t DMA;            
N    __IO uint32_t CNTRL2;        /* Offset: 0x34  Variable Clock Pattern Register                                    */
X    volatile uint32_t CNTRL2;         
N    __IO uint32_t FIFO_CTL;      /* Offset: 0x38  SPI DMA Control Register                                           */
X    volatile uint32_t FIFO_CTL;       
N    __IO uint32_t STATUS;        /* Offset: 0x3C  Control and Status Register 2                                      */
X    volatile uint32_t STATUS;         
N
N} SPI_T;
N
N
N
N/**
N    @addtogroup SPI_CONST SPI Bit Field Definition
N    Constant Definitions for SPI Controller
N@{ */
N
N
N/* SPI_CNTRL Bit Field Definitions */
N#define SPI_CNTRL_TX_FULL_Pos      27                                     /*!< SPI_T::CNTRL: TX_FULL Position */
N#define SPI_CNTRL_TX_FULL_Msk      (1ul << SPI_CNTRL_TX_FULL_Pos)         /*!< SPI_T::CNTRL: TX_FULL Mask     */
N
N#define SPI_CNTRL_TX_EMPTY_Pos     26                                     /*!< SPI_T::CNTRL: TX_EMPTY Position */
N#define SPI_CNTRL_TX_EMPTY_Msk     (1ul << SPI_CNTRL_TX_EMPTY_Pos)        /*!< SPI_T::CNTRL: TX_EMPTY Mask     */
N
N#define SPI_CNTRL_RX_FULL_Pos      25                                     /*!< SPI_T::CNTRL: RX_FULL Position */
N#define SPI_CNTRL_RX_FULL_Msk      (1ul << SPI_CNTRL_RX_FULL_Pos)         /*!< SPI_T::CNTRL: RX_FULL Mask     */
N
N#define SPI_CNTRL_RX_EMPTY_Pos     24                                     /*!< SPI_T::CNTRL: RX_EMPTY Position */
N#define SPI_CNTRL_RX_EMPTY_Msk     (1ul << SPI_CNTRL_RX_EMPTY_Pos)        /*!< SPI_T::CNTRL: RX_EMPTY Mask     */
N
N#define SPI_CNTRL_VARCLK_EN_Pos    23                                     /*!< SPI_T::CNTRL: VARCLK_EN Position */
N#define SPI_CNTRL_VARCLK_EN_Msk    (1ul << SPI_CNTRL_VARCLK_EN_Pos)       /*!< SPI_T::CNTRL: VARCLK_EN Mask     */
N
N#define SPI_CNTRL_TWOB_Pos         22                                     /*!< SPI_T::CNTRL: TWOB Position */
N#define SPI_CNTRL_TWOB_Msk         (1ul << SPI_CNTRL_TWOB_Pos)            /*!< SPI_T::CNTRL: TWOB Mask     */
N
N#define SPI_CNTRL_FIFO_Pos         21                                     /*!< SPI_T::CNTRL: FIFO Position */
N#define SPI_CNTRL_FIFO_Msk         (1ul << SPI_CNTRL_FIFO_Pos)            /*!< SPI_T::CNTRL: FIFO Mask     */
N
N#define SPI_CNTRL_REORDER_Pos      19                                     /*!< SPI_T::CNTRL: REORDER Position */
N#define SPI_CNTRL_REORDER_Msk      (1ul << SPI_CNTRL_REORDER_Pos)         /*!< SPI_T::CNTRL: REORDER Mask     */
N
N#define SPI_CNTRL_SLAVE_Pos        18                                     /*!< SPI_T::CNTRL: SLAVE Position */
N#define SPI_CNTRL_SLAVE_Msk        (1ul << SPI_CNTRL_SLAVE_Pos)           /*!< SPI_T::CNTRL: SLAVE Mask     */
N
N#define SPI_CNTRL_IE_Pos           17                                     /*!< SPI_T::CNTRL: IE Position */
N#define SPI_CNTRL_IE_Msk           (1ul << SPI_CNTRL_IE_Pos)              /*!< SPI_T::CNTRL: IE Mask     */
N
N#define SPI_CNTRL_IF_Pos           16                                     /*!< SPI_T::CNTRL: IF Position */
N#define SPI_CNTRL_IF_Msk           (1ul << SPI_CNTRL_IF_Pos)              /*!< SPI_T::CNTRL: IF Mask     */
N
N#define SPI_CNTRL_SP_CYCLE_Pos     12                                     /*!< SPI_T::CNTRL: SP_CYCLE Position */
N#define SPI_CNTRL_SP_CYCLE_Msk     (0xFul << SPI_CNTRL_SP_CYCLE_Pos)      /*!< SPI_T::CNTRL: SP_CYCLE Mask     */
N
N#define SPI_CNTRL_CLKP_Pos         11                                     /*!< SPI_T::CNTRL: CLKP Position */
N#define SPI_CNTRL_CLKP_Msk         (1ul << SPI_CNTRL_CLKP_Pos)            /*!< SPI_T::CNTRL: CLKP Mask     */
N
N#define SPI_CNTRL_LSB_Pos          10                                     /*!< SPI_T::CNTRL: LSB Position */
N#define SPI_CNTRL_LSB_Msk          (1ul << SPI_CNTRL_LSB_Pos)             /*!< SPI_T::CNTRL: LSB Mask     */
N
N#define SPI_CNTRL_TX_BIT_LEN_Pos   3                                      /*!< SPI_T::CNTRL: TX_BIT_LEN Position */
N#define SPI_CNTRL_TX_BIT_LEN_Msk   (0x1Ful << SPI_CNTRL_TX_BIT_LEN_Pos)   /*!< SPI_T::CNTRL: TX_BIT_LEN Mask     */
N
N#define SPI_CNTRL_TX_NEG_Pos       2                                      /*!< SPI_T::CNTRL: TX_NEG Position */
N#define SPI_CNTRL_TX_NEG_Msk       (1ul << SPI_CNTRL_TX_NEG_Pos)          /*!< SPI_T::CNTRL: TX_NEG Mask     */
N
N#define SPI_CNTRL_RX_NEG_Pos       1                                      /*!< SPI_T::CNTRL: RX_NEG Position */
N#define SPI_CNTRL_RX_NEG_Msk       (1ul << SPI_CNTRL_RX_NEG_Pos)          /*!< SPI_T::CNTRL: RX_NEG Mask     */
N
N#define SPI_CNTRL_GO_BUSY_Pos      0                                      /*!< SPI_T::CNTRL: GO_BUSY Position */
N#define SPI_CNTRL_GO_BUSY_Msk      (1ul << SPI_CNTRL_GO_BUSY_Pos)         /*!< SPI_T::CNTRL: GO_BUSY Mask     */
N
N/* SPI_DIVIDER Bit Field Definitions */
N#define SPI_DIVIDER_DIVIDER2_Pos   16                                     /*!< SPI_T::DIVIDER: DIVIDER2 Position */
N#define SPI_DIVIDER_DIVIDER2_Msk   (0xFFul << SPI_DIVIDER_DIVIDER2_Pos)   /*!< SPI_T::DIVIDER: DIVIDER2 Mask */
N
N#define SPI_DIVIDER_DIVIDER_Pos    0                                      /*!< SPI_T::DIVIDER: DIVIDER Position */
N#define SPI_DIVIDER_DIVIDER_Msk    (0xFFul << SPI_DIVIDER_DIVIDER_Pos)    /*!< SPI_T::DIVIDER: DIVIDER Mask */
N
N/* SPI_SSR Bit Field Definitions */
N#define SPI_SSR_LTRIG_FLAG_Pos     5                                 /*!< SPI_T::SSR: LTRIG_FLAG Position */
N#define SPI_SSR_LTRIG_FLAG_Msk     (1ul << SPI_SSR_LTRIG_FLAG_Pos)   /*!< SPI_T::SSR: LTRIG_FLAG Mask */
N
N#define SPI_SSR_SS_LTRIG_Pos       4                                 /*!< SPI_T::SSR: SS_LTRIG Position */
N#define SPI_SSR_SS_LTRIG_Msk       (1ul << SPI_SSR_SS_LTRIG_Pos)     /*!< SPI_T::SSR: SS_LTRIG Mask */
N
N#define SPI_SSR_AUTOSS_Pos         3                                 /*!< SPI_T::SSR: AUTOSS Position */
N#define SPI_SSR_AUTOSS_Msk         (1ul << SPI_SSR_AUTOSS_Pos)       /*!< SPI_T::SSR: AUTOSS Mask */
N
N#define SPI_SSR_SS_LVL_Pos         2                                 /*!< SPI_T::SSR: SS_LVL Position */
N#define SPI_SSR_SS_LVL_Msk         (1ul << SPI_SSR_SS_LVL_Pos)       /*!< SPI_T::SSR: SS_LVL Mask */
N
N#define SPI_SSR_SSR_Pos            0                                 /*!< SPI_T::SSR: SSR Position */
N#define SPI_SSR_SSR_Msk            (3ul << SPI_SSR_SSR_Pos)          /*!< SPI_T::SSR: SSR Mask */
N
N/* SPI_DMA Bit Field Definitions */
N#define SPI_DMA_PDMA_RST_Pos   2                                     /*!< SPI_T::DMA: PDMA_RST Position */
N#define SPI_DMA_PDMA_RST_Msk   (1ul << SPI_DMA_PDMA_RST_Pos)         /*!< SPI_T::DMA: PDMA_RST Mask */
N
N#define SPI_DMA_RX_DMA_GO_Pos   1                                    /*!< SPI_T::DMA: RX_DMA_GO Position */
N#define SPI_DMA_RX_DMA_GO_Msk   (1ul << SPI_DMA_RX_DMA_GO_Pos)       /*!< SPI_T::DMA: RX_DMA_GO Mask */
N
N#define SPI_DMA_TX_DMA_GO_Pos   0                                    /*!< SPI_T::DMA: TX_DMA_GO Position */
N#define SPI_DMA_TX_DMA_GO_Msk   (1ul << SPI_DMA_TX_DMA_GO_Pos)       /*!< SPI_T::DMA: TX_DMA_GO Mask */
N
N/* SPI_CNTRL2 Bit Field Definitions */
N#define SPI_CNTRL2_BCn_Pos   31                                                      /*!< SPI_T::CNTRL2: BCn Position */
N#define SPI_CNTRL2_BCn_Msk   (1ul << SPI_CNTRL2_BCn_Pos)                             /*!< SPI_T::CNTRL2: BCn Mask */
N
N#define SPI_CNTRL2_SS_INT_OPT_Pos   16                                               /*!< SPI_T::CNTRL2: SS_INT_OPT Position */
N#define SPI_CNTRL2_SS_INT_OPT_Msk   (1ul << SPI_CNTRL2_SS_INT_OPT_Pos)               /*!< SPI_T::CNTRL2: SS_INT_OPT Mask */
N
N#define SPI_CNTRL2_DUAL_IO_EN_Pos   13                                               /*!< SPI_T::CNTRL2: DUAL_IO_EN Position */
N#define SPI_CNTRL2_DUAL_IO_EN_Msk   (1ul << SPI_CNTRL2_DUAL_IO_EN_Pos)               /*!< SPI_T::CNTRL2: DUAL_IO_EN Mask */
N
N#define SPI_CNTRL2_DUAL_IO_DIR_Pos   12                                              /*!< SPI_T::CNTRL2: DUAL_IO_DIR Position */
N#define SPI_CNTRL2_DUAL_IO_DIR_Msk   (1ul << SPI_CNTRL2_DUAL_IO_DIR_Pos)             /*!< SPI_T::CNTRL2: DUAL_IO_DIR Mask */
N
N#define SPI_CNTRL2_SLV_START_INTSTS_Pos   11                                         /*!< SPI_T::CNTRL2: SLV_START_INTSTS Position */
N#define SPI_CNTRL2_SLV_START_INTSTS_Msk   (1ul << SPI_CNTRL2_SLV_START_INTSTS_Pos)   /*!< SPI_T::CNTRL2: SLV_START_INTSTS Mask */
N
N#define SPI_CNTRL2_SSTA_INTEN_Pos   10                                               /*!< SPI_T::CNTRL2: SSTA_INTEN Position */
N#define SPI_CNTRL2_SSTA_INTEN_Msk   (1ul << SPI_CNTRL2_SSTA_INTEN_Pos)               /*!< SPI_T::CNTRL2: SSTA_INTEN Mask */
N
N#define SPI_CNTRL2_SLV_ABORT_Pos    9                                                /*!< SPI_T::CNTRL2: SLV_ABORT Position */
N#define SPI_CNTRL2_SLV_ABORT_Msk    (1ul << SPI_CNTRL2_SLV_ABORT_Pos)                /*!< SPI_T::CNTRL2: SLV_ABORT Mask */
N
N#define SPI_CNTRL2_NOSLVSEL_Pos     8                                                /*!< SPI_T::CNTRL2: NOSLVSEL Position */
N#define SPI_CNTRL2_NOSLVSEL_Msk     (1ul << SPI_CNTRL2_NOSLVSEL_Pos)                 /*!< SPI_T::CNTRL2: NOSLVSEL Mask */
N
N/* SPI_FIFO_CTL Bit Field Definitions */
N#define SPI_FIFO_CTL_TX_THRESHOLD_Pos   28                                         /*!< SPI_T::FIFO_CTL: TX_THRESHOLD Position */
N#define SPI_FIFO_CTL_TX_THRESHOLD_Msk   (7ul << SPI_FIFO_CTL_TX_THRESHOLD_Pos)     /*!< SPI_T::FIFO_CTL: TX_THRESHOLD Mask */
N
N#define SPI_FIFO_CTL_RX_THRESHOLD_Pos   24                                         /*!< SPI_T::FIFO_CTL: RX_THRESHOLD Position */
N#define SPI_FIFO_CTL_RX_THRESHOLD_Msk   (7ul << SPI_FIFO_CTL_RX_THRESHOLD_Pos)     /*!< SPI_T::FIFO_CTL: RX_THRESHOLD Mask */
N
N#define SPI_FIFO_CTL_TIMEOUT_INTEN_Pos   21                                        /*!< SPI_T::FIFO_CTL: TIMEOUT_INTEN Position */
N#define SPI_FIFO_CTL_TIMEOUT_INTEN_Msk   (1ul << SPI_FIFO_CTL_TIMEOUT_INTEN_Pos)   /*!< SPI_T::FIFO_CTL: TIMEOUT_INTEN Mask */
N
N#define SPI_FIFO_CTL_RXOV_INTEN_Pos    6                                           /*!< SPI_T::FIFO_CTL: RXOV_INTEN Position */
N#define SPI_FIFO_CTL_RXOV_INTEN_Msk    (1ul << SPI_FIFO_CTL_RXOV_INTEN_Pos)        /*!< SPI_T::FIFO_CTL: RXOV_INTEN Mask */
N
N#define SPI_FIFO_CTL_TX_INTEN_Pos    3                                             /*!< SPI_T::FIFO_CTL: TX_INTEN Position */
N#define SPI_FIFO_CTL_TX_INTEN_Msk    (1ul << SPI_FIFO_CTL_TX_INTEN_Pos)            /*!< SPI_T::FIFO_CTL: TX_INTEN Mask */
N
N#define SPI_FIFO_CTL_RX_INTEN_Pos    2                                             /*!< SPI_T::FIFO_CTL: RX_INTEN Position */
N#define SPI_FIFO_CTL_RX_INTEN_Msk    (1ul << SPI_FIFO_CTL_RX_INTEN_Pos)            /*!< SPI_T::FIFO_CTL: RX_INTEN Mask */
N
N#define SPI_FIFO_CTL_TX_CLR_Pos     1                                              /*!< SPI_T::FIFO_CTL: TX_CLR Position */
N#define SPI_FIFO_CTL_TX_CLR_Msk     (1ul << SPI_FIFO_CTL_TX_CLR_Pos)               /*!< SPI_T::FIFO_CTL: TX_CLR Mask */
N
N#define SPI_FIFO_CTL_RX_CLR_Pos      0                                             /*!< SPI_T::FIFO_CTL: RX_CLR Position */
N#define SPI_FIFO_CTL_RX_CLR_Msk      (1ul << SPI_FIFO_CTL_RX_CLR_Pos)              /*!< SPI_T::FIFO_CTL: RX_CLR Mask */
N
N/* SPI_STATUS Bit Field Definitions */
N#define SPI_STATUS_TX_FIFO_COUNT_Pos   28                                            /*!< SPI_T::STATUS: TX_FIFO_COUNT Position */
N#define SPI_STATUS_TX_FIFO_COUNT_Msk   (0xFul << SPI_STATUS_TX_FIFO_COUNT_Pos)       /*!< SPI_T::STATUS: TX_FIFO_COUNT Mask */
N
N#define SPI_STATUS_TX_FULL_Pos   27                                                  /*!< SPI_T::STATUS: TX_FULL Position */
N#define SPI_STATUS_TX_FULL_Msk   (1ul << SPI_STATUS_TX_FULL_Pos)                     /*!< SPI_T::STATUS: TX_FULL Mask */
N
N#define SPI_STATUS_TX_EMPTY_Pos   26                                                 /*!< SPI_T::STATUS: TX_EMPTY Position */
N#define SPI_STATUS_TX_EMPTY_Msk   (1ul << SPI_STATUS_TX_EMPTY_Pos)                   /*!< SPI_T::STATUS: TX_EMPTY Mask */
N
N#define SPI_STATUS_RX_FULL_Pos   25                                                  /*!< SPI_T::STATUS: RX_FULL Position */
N#define SPI_STATUS_RX_FULL_Msk   (1ul << SPI_STATUS_RX_FULL_Pos)                     /*!< SPI_T::STATUS: RX_FULL Mask */
N
N#define SPI_STATUS_RX_EMPTY_Pos   24                                                 /*!< SPI_T::STATUS: RX_EMPTY Position */
N#define SPI_STATUS_RX_EMPTY_Msk   (1ul << SPI_STATUS_RX_EMPTY_Pos)                   /*!< SPI_T::STATUS: RX_EMPTY Mask */
N
N#define SPI_STATUS_TIMEOUT_Pos   20                                                  /*!< SPI_T::STATUS: TIMEOUT Position */
N#define SPI_STATUS_TIMEOUT_Msk   (1ul << SPI_STATUS_TIMEOUT_Pos)                     /*!< SPI_T::STATUS: TIMEOUT Mask */
N
N#define SPI_STATUS_IF_Pos   16                                                       /*!< SPI_T::STATUS: IF Position */
N#define SPI_STATUS_IF_Msk   (1ul << SPI_STATUS_IF_Pos)                               /*!< SPI_T::STATUS: IF Mask     */
N
N#define SPI_STATUS_RX_FIFO_COUNT_Pos   12                                            /*!< SPI_T::STATUS: RX_FIFO_COUNT Position */
N#define SPI_STATUS_RX_FIFO_COUNT_Msk   (0xFul << SPI_STATUS_RX_FIFO_COUNT_Pos)       /*!< SPI_T::STATUS: RX_FIFO_COUNT Mask */
N
N#define SPI_STATUS_SLV_START_INTSTS_Pos   11                                         /*!< SPI_T::STATUS: SLV_START_INTSTS Position */
N#define SPI_STATUS_SLV_START_INTSTS_Msk   (1ul << SPI_STATUS_SLV_START_INTSTS_Pos)   /*!< SPI_T::STATUS: SLV_START_INTSTS Mask */
N
N#define SPI_STATUS_TX_INTSTS_Pos   4                                                 /*!< SPI_T::STATUS: TX_INTSTS Position */
N#define SPI_STATUS_TX_INTSTS_Msk   (1ul << SPI_STATUS_TX_INTSTS_Pos)                 /*!< SPI_T::STATUS: TX_INTSTS Mask */
N
N#define SPI_STATUS_RX_OVERRUN_Pos   2                                                /*!< SPI_T::STATUS: RX_OVERRUN Position */
N#define SPI_STATUS_RX_OVERRUN_Msk   (1ul << SPI_STATUS_RX_OVERRUN_Pos)               /*!< SPI_T::STATUS: RX_OVERRUN Mask */
N
N#define SPI_STATUS_RX_INTSTS_Pos   0                                                 /*!< SPI_T::STATUS: RX_INTSTS Position */
N#define SPI_STATUS_RX_INTSTS_Msk   (1ul << SPI_STATUS_RX_INTSTS_Pos)                 /*!< SPI_T::STATUS: RX_INTSTS Mask */
N/*@}*/ /* end of group SPI_CONST */
N/*@}*/ /* end of group SPI */
N
N
N
N
N/*---------------------- System Manger Controller -------------------------*/
N/**
N    @addtogroup SYS System Manger Controller (SYS)
N    Memory Mapped Structure for SYS Controller
N@{ */
N
N
N
Ntypedef struct
N{
N
N
N
N/**
N * @var GCR_T::PDID
N * Offset: 0x00  Part Device Identification Number Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |PDID      |Part Device Identification Number
N * |        |          |This register reflects device part number code.
N * |        |          |Software can read this register to identify which device is used.
N * @var GCR_T::RSTSRC
N * Offset: 0x04  System Reset Source Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |RSTS_POR  |Power-on Reset Flag
N * |        |          |The RSTS_POR flag is set by the "reset signal" from the Power-On Reset (POR) controller or bit
N * |        |          |CHIP_RST (IPRSTC1[0]) to indicate the previous reset source.
N * |        |          |0 = No reset from POR or CHIP_RST (IPRSTC1[0]).
N * |        |          |1 = Power-on Reset (POR) or CHIP_RST (IPRSTC1[0]) had issued the reset signal to reset the
N * |        |          |system.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * |[1]     |RSTS_RESET|Reset Pin Reset Flag
N * |        |          |The RSTS_RESET flag is set by the "Reset Signal" from the /RESET pin to indicate the previous
N * |        |          |reset source.
N * |        |          |0 = No reset from /RESET pin.
N * |        |          |1 = The Pin /RESET had issued the reset signal to reset the system.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * |[2]     |RSTS_WDT  |Watchdog Reset Flag
N * |        |          |The RSTS_WDT flag is set by The "Reset Signal" from the Watchdog Timer to indicate the previous
N * |        |          |reset source
N * |        |          |0 = No reset from watchdog timer.
N * |        |          |1 = The watchdog timer had issued the reset signal to reset the system.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * |[3]     |RSTS_LVR  |Low Voltage Reset Flag
N * |        |          |The RSTS_LVR flag Is Set By The "Reset Signal" From The Low-Voltage-Reset Controller To Indicate
N * |        |          |The Previous Reset Source
N * |        |          |0 = No reset from LVR.
N * |        |          |1 = The LVR controller had issued the reset signal to reset the system.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * |[4]     |RSTS_BOD  |Brown-out Detector Reset Flag
N * |        |          |The RSTS_BOD flag is set by the "Reset Signal" from the Brown-Out Detector to indicate the
N * |        |          |previous reset source.
N * |        |          |0 = No reset from BOD.
N * |        |          |1 = The BOD had issued the reset signal to reset the system.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * |[5]     |RSTS_SYS  |System Reset Flag
N * |        |          |The RSTS_SYS flag is set by the "Reset Signal" from the Cortex-M0 kernel to indicate the
N * |        |          |previous reset source.
N * |        |          |0 = No reset from Cortex-M0.
N * |        |          |1 = The Cortex-M0 had issued the reset signal to reset the system by writing 1 to bit
N * |        |          |SYSRESETREQ (AIRCR[2], Application Interrupt and Reset Control Register, address = 0xE000ED0C)
N * |        |          |in system control registers of Cortex-M0 kernel.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * |[7]     |RSTS_CPU  |CPU Reset Flag
N * |        |          |The RSTS_CPU flag is set by hardware if software writes CPU_RST (IPRSTC1[1]) 1 to reset
N * |        |          |Cortex-M0 CPU kernel and flash. Memory Controller (FMC)
N * |        |          |0 = No reset from CPU.
N * |        |          |1 = Cortex-M0 CPU kernel and FMC are reset by software setting CPU_RST(IPRSTC1[1]) to 1.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * @var GCR_T::IPRSTC1
N * Offset: 0x08  IP Reset Control Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |CHIP_RST  |CHIP One-Shot Reset (Write Protect)
N * |        |          |Setting this bit will reset the whole chip, including CPU kernel and all peripherals, and this
N * |        |          |bit will automatically return to 0 after the 2 clock cycles.
N * |        |          |The CHIP_RST is the same as the POR reset, all the chip controllers are reset and the chip
N * |        |          |setting from flash are also reload.
N * |        |          |0 = CHIP normal operation.
N * |        |          |1 = CHIP one-shot reset.
N * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register.
N * |[1]     |CPU_RST   |CPU Kernel One-Shot Reset (Write Protect)
N * |        |          |Setting this bit will only reset the CPU kernel and Flash Memory Controller(FMC), and this bit
N * |        |          |will automatically return 0 after the two clock cycles.
N * |        |          |0 = CPU normal operation.
N * |        |          |1 = CPU one-shot reset.
N * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register.
N * |[2]     |PDMA_RST  |PDMA Controller Reset (Write Protect)
N * |        |          |Setting this bit to 1 will generate a reset signal to the PDMA.
N * |        |          |User need to set this bit to 0 to release from reset state.
N * |        |          |0 = PDMA controller normal operation.
N * |        |          |1 = PDMA controller reset.
N * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register.
N * |[3]     |EBI_RST   |EBI Controller Reset (Write Protect)
N * |        |          |Setting this bit to 1 will generate a reset signal to the EBI.
N * |        |          |User need to set this bit to 0 to release from reset state.
N * |        |          |0 = EBI controller normal operation.
N * |        |          |1 = EBI controller reset.
N * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register.
N * @var GCR_T::IPRSTC2
N * Offset: 0x0C  IP Reset Control Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1]     |GPIO_RST  |GPIO Controller Reset
N * |        |          |0 = GPIO controller normal operation.
N * |        |          |1 = GPIO controller reset.
N * |[2]     |TMR0_RST  |Timer0 Controller Reset
N * |        |          |0 = Timer0 controller normal operation.
N * |        |          |1 = Timer0 controller reset.
N * |[3]     |TMR1_RST  |Timer1 Controller Reset
N * |        |          |0 = Timer1 controller normal operation.
N * |        |          |1 = Timer1 controller reset.
N * |[4]     |TMR2_RST  |Timer2 Controller Reset
N * |        |          |0 = Timer2 controller normal operation.
N * |        |          |1 = Timer2 controller reset.
N * |[5]     |TMR3_RST  |Timer3 Controller Reset
N * |        |          |0 = Timer3 controller normal operation.
N * |        |          |1 = Timer3 controller reset.
N * |[8]     |I2C0_RST  |I2C0 Controller Reset
N * |        |          |0 = I2C0 controller normal operation.
N * |        |          |1 = I2C0 controller reset.
N * |[9]     |I2C1_RST  |I2C1 Controller Reset
N * |        |          |0 = I2C1 controller normal operation.
N * |        |          |1 = I2C1 controller reset.
N * |[12]    |SPI0_RST  |SPI0 Controller Reset
N * |        |          |0 = SPI0 controller normal operation.
N * |        |          |1 = SPI0 controller reset.
N * |[13]    |SPI1_RST  |SPI1 Controller Reset
N * |        |          |0 = SPI1 controller normal operation.
N * |        |          |1 = SPI1 controller reset.
N * |[14]    |SPI2_RST  |SPI2 Controller Reset
N * |        |          |0 = SPI2 controller normal operation.
N * |        |          |1 = SPI2 controller reset.
N * |[15]    |SPI3_RST  |SPI3 Controller Reset
N * |        |          |0 = SPI3 controller normal operation.
N * |        |          |1 = SPI3 controller reset.
N * |[16]    |UART0_RST |UART0 Controller Reset
N * |        |          |0 = UART0 controller normal operation.
N * |        |          |1 = UART0 controller reset.
N * |[17]    |UART1_RST |UART1 Controller Reset
N * |        |          |0 = UART1 controller normal operation.
N * |        |          |1 = UART1 controller reset.
N * |[18]    |UART2_RST |UART2 Controller Reset
N * |        |          |0 = UART2 controller normal operation.
N * |        |          |1 = UART2 controller reset.
N * |[20]    |PWM03_RST |PWM03 Controller Reset
N * |        |          |0 = PWM03 controller normal operation.
N * |        |          |1 = PWM03 controller reset.
N * |[21]    |PWM47_RST |PWM47 Controller Reset
N * |        |          |0 = PWM47 controller normal operation.
N * |        |          |1 = PWM47 controller reset.
N * |[22]    |ACMP_RST  |Analog Comparator Controller Reset
N * |        |          |0 = Analog Comparator controller normal operation.
N * |        |          |1 = Analog Comparator controller reset.
N * |[23]    |PS2_RST   |PS/2 Controller Reset
N * |        |          |0 = PS/2 controller normal operation.
N * |        |          |1 = PS/2 controller reset.
N * |[24]    |CAN0_RST  |CAN0 Controller Reset
N * |        |          |0 = CAN0 controller normal operation.
N * |        |          |1 = CAN0 controller reset.
N * |[25]    |CAN1_RST  |CAN1 Controller Reset
N * |        |          |0 = CAN1 controller normal operation.
N * |        |          |1 = CAN1 controller reset.
N * |[27]    |USBD_RST  |USB Device Controller Reset
N * |        |          |0 = USB device controller normal operation.
N * |        |          |1 = USB device controller reset.
N * |[28]    |ADC_RST   |ADC Controller Reset
N * |        |          |0 = ADC controller normal operation.
N * |        |          |1 = ADC controller reset.
N * |[29]    |I2S_RST   |I2S Controller Reset
N * |        |          |0 = I2S controller normal operation.
N * |        |          |1 = I2S controller reset.
N * @var GCR_T::IPRSTC3
N * Offset: 0x10  IP Reset Control Register 3
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |SC0_RST   |SC0 Controller Reset
N * |        |          |0 = SC0 controller normal operation.
N * |        |          |1 = SC0 controller reset.
N * |[1]     |SC1_RST   |SC1 Controller Reset
N * |        |          |0 = SC1 controller normal operation.
N * |        |          |1 = SC1 controller reset.
N * |[2]     |SC2_RST   |SC2 Controller Reset
N * |        |          |0 = SC2 controller normal operation.
N * |        |          |1 = SC2 controller reset.
N * @var GCR_T::BODCR
N * Offset: 0x18  Brown-out Detector Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |BOD_EN    |Brown-Out Detector Enable Bit (Write Protect)
N * |        |          |The default value is set by flash memory controller user configuration register CBODEN
N * |        |          |(Config0[23]) bit.
N * |        |          |0 = Brown-out Detector function Disabled.
N * |        |          |1 = Brown-out Detector function Enabled.
N * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register.
N * |[2:1]   |BOD_VL    |Brown-Out Detector Threshold Voltage Selection (Write Protect)
N * |        |          |The default value is set by flash controller user configuration register CBOV (Config0[22:21])
N * |        |          |bit.
N * |        |          |00 = Brown-out voltage is 2.2V.
N * |        |          |01 = Brown-out voltage is 2.7V.
N * |        |          |10 = Brown-out voltage is 3.7V.
N * |        |          |11 = Brown-out voltage is 4.4V.
N * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register.
N * |[3]     |BOD_RSTEN |Brown-out Reset Enable Control (Write Protect)
N * |        |          |0 = Brown-out "INTERRUPT" function Enabled.
N * |        |          |While the BOD function is enabled (BOD_EN high) and BOD interrupt function is enabled (BOD_RSTEN
N * |        |          |low), BOD will assert an interrupt if BOD_OUT is high.
N * |        |          |BOD interrupt will keep till to the BOD_EN set to 0. BOD interrupt can be blocked by disabling
N * |        |          |the NVIC BOD interrupt or disabling BOD function (set BOD_EN low).
N * |        |          |1 = Brown-out "RESET" function Enabled.
N * |        |          |Note1: While the Brown-out Detector function is enabled (BOD_EN high) and BOD reset function is
N * |        |          |enabled (BOD_RSTEN high), BOD will assert a signal to reset chip when the detected voltage is
N * |        |          |lower than the threshold (BOD_OUT high).
N * |        |          |Note2: The default value is set by flash controller user configuration register CBORST
N * |        |          |(Config0[20]) bit.
N * |        |          |Note3: This bit is write protected bit. Refer to the REGWRPROT register.
N * |[4]     |BOD_INTF  |Brown-out Detector Interrupt Flag
N * |        |          |0 = Brown-out Detector does not detect any voltage draft at VDD down through or up through the
N * |        |          |voltage of BOD_VL setting.
N * |        |          |1 = When Brown-out Detector detects the VDD is dropped down through the voltage of BOD_VL
N * |        |          |setting or the VDD is raised up through the voltage of BOD_VL setting, this bit is set to 1 and
N * |        |          |the Brown-out interrupt is requested if Brown-out interrupt is enabled.
N * |        |          |Note: Write 1 to clear this bit to 0.
N * |[5]     |BOD_LPM   |Brown-out Detector Low Power Mode (Write Protection)
N * |        |          |0 = BOD operated in Normal mode (default).
N * |        |          |1 = BOD Low Power mode Enabled.
N * |        |          |Note1: The BOD consumes about 100 uA in Normal mode, and the low power mode can reduce the
N * |        |          |current to about 1/10 but slow the BOD response.
N * |        |          |Note2: This bit is write protected bit. Refer to the REGWRPROT register.
N * |[6]     |BOD_OUT   |Brown-out Detector Output Status
N * |        |          |0 = Brown-out Detector output status is 0. It means the detected voltage is higher than BOD_VL
N * |        |          |setting or BOD_EN is 0.
N * |        |          |1 = Brown-out Detector output status is 1. It means the detected voltage is lower than BOD_VL
N * |        |          |setting. If the BOD_EN is 0, BOD function disabled, this bit always responds to 0.
N * |[7]     |LVR_EN    |Low Voltage Reset Enable Bit (Write Protect)
N * |        |          |The LVR function reset the chip when the input power voltage is lower than LVR circuit setting.
N * |        |          |LVR function is enabled by default.
N * |        |          |0 = Low Voltage Reset function Disabled.
N * |        |          |1 = Low Voltage Reset function Enabled - After enabling the bit, the LVR function will be active
N * |        |          |with 100us delay for LVR output stable (default).
N * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register.
N * @var GCR_T::TEMPCR
N * Offset: 0x1C  Temperature Sensor Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |VTEMP_EN  |Temperature Sensor Enable Control
N * |        |          |This bit is used to enable/disable temperature sensor function.
N * |        |          |0 = Temperature sensor function Disabled (default).
N * |        |          |1 = Temperature sensor function Enabled.
N * |        |          |Note: After this bit is set to 1, the value of temperature can be obtained from ADC conversion
N * |        |          |result by ADC channel selecting channel 7 and alternative multiplexer channel selecting
N * |        |          |temperature sensor.
N * |        |          |Please refer to the ADC function chapter for detail ADC conversion functional description.
N * @var GCR_T::PORCR
N * Offset: 0x24  Power-on-Reset Controller Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |POR_DIS_CODE|Power-on Reset Enable Control (Write Protect)
N * |        |          |When powered on, the POR circuit generates a reset signal to reset the whole chip function, but
N * |        |          |noise on the power may cause the POR active again.
N * |        |          |User can disable internal POR circuit to avoid unpredictable noise to cause chip reset by
N * |        |          |writing 0x5AA5 to this field.
N * |        |          |The POR function will be active again when this field is set to another value or chip is reset
N * |        |          |by other reset source, including:
N * |        |          |nRESET, Watchdog, LVR reset, BOD reset, ICE reset command and the software-chip reset function.
N * |        |          |Note: These bits are write protected bit. Refer to the REGWRPROT register.
N * @var GCR_T::GPA_MFP
N * Offset: 0x30  GPIOA Multiple Function and Input Type Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |GPA_MFP0  |PA.0 Pin Function Selection
N * |        |          |Bit PA0_SC0PWR (ALT_MFP1[2]) and GPA_MFP[0] determine the PA.0 function.
N * |        |          |(PA0_SC0PWR, GPA_MFP0) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = ADC0 function is selected.
N * |        |          |(1, 1) = SC0_PWR function is selected.  
N * |[1]     |GPA_MFP1  |PA.1 Pin Function Selection
N * |        |          |Bit EBI_HB_EN[4] (ALT_MFP[20]), EBI_EN (ALT_MFP[11]), PA1_SC0RST (ALT_MFP1[3]) and GPA_MFP[1]
N * |        |          |determine the PA.1 function.
N * |        |          |(EBI_HB_EN[4], EBI_EN, PA1_SC0RST, GPA_MFP1) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = ADC1 function is selected.
N * |        |          |(0, 0, 1, 1) = SC0_RST function is selected.
N * |        |          |(1, 1, 0, 1) = AD12 function is selected.          
N * |[2]     |GPA_MFP2  |PA.2 Pin Function Selection
N * |        |          |Bits EBI_HB_EN[3] (ALT_MFP[19]), EBI_EN (ALT_MFP[11]), PA2_SC0CLK (ALT_MFP1[0]) and GPA_MFP[2]
N * |        |          |determine the PA.2 function.
N * |        |          |(EBI_HB_EN[3], EBI_EN, PA2_SC0CLK, GPA_MFP2) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = ADC2 function is selected.
N * |        |          |(0, 0, 1, 1) = SC0_CLK/UART3_TXD function is selected.
N * |        |          |(1, 1, 0, 1) = AD11 function is selected.         
N * |[3]     |GPA_MFP3  |PA.3 Pin Function Selection   
N * |        |          |Bits EBI_HB_EN[2] (ALT_MFP[18]), EBI_EN (ALT_MFP[11]), PA3_SC0DAT (ALT_MFP1[1]) and GPA_MFP[3]
N * |        |          |determine the PA.3 function.
N * |        |          |(EBI_HB_EN[2], EBI_EN, PA3_SC0DAT, GPA_MFP3) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = ADC3 function is selected.
N * |        |          |(0, 0, 1, 1) = SC0_DAT/UART3_RXD function is selected.
N * |        |          |(1, 1, 0, 1) = AD10 function is selected.
N * |[4]     |GPA_MFP4  |PA.4 Pin Function Selection     
N * |        |          |Bits EBI_HB_EN[1] (ALT_MFP[17]), EBI_EN (ALT_MFP[11]), PA4_SC1PWR (ALT_MFP1[7]) and GPA_MFP[4]
N * |        |          |determine the PA.4 function.
N * |        |          |(EBI_HB_EN[1], EBI_EN, PA4_SC1PWR, GPA_MFP4) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = ADC4 function is selected.
N * |        |          |(0, 0, 1, 1) = SC1_PWR function is selected.
N * |        |          |(1, 1, 0, 1) = AD9 function is selected.     
N * |[5]     |GPA_MFP5  |PA.5 Pin Function Selection    
N * |        |          |Bits EBI_HB_EN[0] (ALT_MFP[16]), EBI_EN (ALT_MFP[11]),PA5_SC1RST (ALT_MFP1[8]) and GPA_MFP[5]
N * |        |          |determine the PA.5 function.
N * |        |          |(EBI_HB_EN[0], EBI_EN, PA5_SC1RST, GPA_MFP5) value and function mapping is as following list,
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = ADC5 function is selected.
N * |        |          |(0, 0, 1, 1) = SC1_RST function is selected.
N * |        |          |(1, 1, 0, 1) = AD8 function is selected.     
N * |[6]     |GPA_MFP6  |PA.6 Pin Function Selection
N * |        |          |Bits EBI_EN (ALT_MFP[11]), PA6_SC1CLK (ALT_MFP1[5]) and GPA_MFP[6] determine the PA.6 function.
N * |        |          |(EBI_EN, PA6_SC1CLK, GPA_MFP6) value and function mapping is as following list.
N * |        |          |(0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 1) = ADC6 function is selected.
N * |        |          |(0, 1, 1) = SC1_CLK/UART4_TXD function is selected.
N * |        |          |(1, 0, 1) = AD7 function is selected.     
N * |[7]     |GPA_MFP7  |PA.7 Pin Function Selection
N * |        |          |Bits EBI_EN (ALT_MFP[11]), PA7_SC1DAT (ALT_MFP1[6]), PA7_S21 (ALT_MFP[2]) and GPA_MFP[7]
N * |        |          |determine the PA.7 function.
N * |        |          |(EBI_EN, PA7_SC1DAT, PA7_S21, GPA_MFP7) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = ADC7 function is selected.
N * |        |          |(0, 0, 1, 1) = SPI2_SS1 function is selected.
N * |        |          |(0, 1, 0, 1) = SC1_DAT/UART4_RXD function is selected.
N * |        |          |(1, 0, 0, 1) = AD6 function is selected.     
N * |[8]     |GPA_MFP8  |PA.8 Pin Function Selection
N * |        |          |Bit GPA_MFP[8] determines the PA.8 function.
N * |        |          |0 = GPIO function is selected to the pin PA.8.
N * |        |          |1 = I2C0_SDA function is selected to the pin PA.8.
N * |[10]    |GPA_MFP9  |PA.9 Pin Function Selection
N * |        |          |Bit GPA_MFP[9] determines the PA.9 function.
N * |        |          |0 = GPIO function is selected.
N * |        |          |1 = I2C0_SCL function is selected.
N * |[10]    |GPA_MFP10 |PA.10 Pin Function Selection
N * |        |          |Bits EBI_EN (ALT_MFP[11]), PA10_11_CAN1 (ALT_MFP[28]) and GPA_MFP[10] determine the PA.10
N * |        |          |function.
N * |        |          |(EBI_EN, PA10_11_CAN1, GPA_MFP10) value and function mapping is as following list.
N * |        |          |(0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 1) = I2C1_SDA function is selected.
N * |        |          |(0, 1, 1) = CAN1_TXD function is selected.
N * |        |          |(1, 0, 1) =nWR(EBI) function is selected.     
N * |[11]    |GPA_MFP11 |PA.11 Pin Function Selection
N * |        |          |Bits EBI_EN (ALT_MFP[11]), PA10_11_CAN1 (ALT_MFP[28]) and GPA_MFP[11] determine the PA.11
N * |        |          |function.
N * |        |          |(EBI_EN, PA10_11_CAN1, GPA_MFP11) value and function mapping is as following list.
N * |        |          |(0,0, 0) = GPIO function is selected.
N * |        |          |(0,0, 1) = I2C1_SCL function is selected.
N * |        |          |(0, 1, 1) = CAN1_RXD function is selected.
N * |        |          |(1, 0, 1) = nRD(EBI) function is selected.     
N * |[12]    |GPA_MFP12 |PA.12 Pin Function Selection
N * |        |          |Bits EBI_HB_EN[5] (ALT_MFP[21]), EBI_EN (ALT_MFP[11]), PA12_SC2DAT (ALT_MFP1[11]) and
N * |        |          |GPA_MFP[12] determine the PA.12 function.
N * |        |          |(EBI_HB_EN[5], EBI_EN, PA12_SC2DAT, GPA_MFP12) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = PWM0 function is selected.
N * |        |          |(0, 0, 1, 1) = SC2_DAT/UART5_RXD function is selected.
N * |        |          |(1, 1, 0, 1) = AD13 function is selected.       
N * |[13]    |GPA_MFP13 |PA.13 Pin Function Selection     
N * |        |          |Bits EBI_HB_EN[6] (ALT_MFP[22]), EBI_EN (ALT_MFP[11]), PA13_SC2CLK (ALT_MFP1[10]) and
N * |        |          |GPA_MFP[13] determine the PA.13 function.
N * |        |          |(EBI_HB_EN[6], EBI_EN, PA13_SC2CLK, GPA_MFP13) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = PWM1 function is selected.
N * |        |          |(0, 0, 1, 1) = SC2_CLK/UART5_TXD function is selected.
N * |        |          |(1, 1, 0, 1) = AD14 function is selected.        
N * |[14]    |GPA_MFP14 |PA.14 Pin Function Selection
N * |        |          |Bits EBI_HB_EN[7] (ALT_MFP[23]), EBI_EN (ALT_MFP[11]), PA14_SC2RST (ALT_MFP1[13]) and
N * |        |          |GPA_MFP[14] determine the PA.14 function.
N * |        |          |(EBI_HB_EN , EBI_EN, PA14_SC2RST, GPA_MFP14) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = PWM2 function is selected.
N * |        |          |(0, 0, 1, 1) = SC2_RST function is selected.
N * |        |          |(1, 1, 0, 1) = AD15 function is selected.        
N * |[15]    |GPA_MFP15 |PA.15 Pin Function Selection     
N * |        |          |Bits PA15_SC2PWR (ALT_MFP1[12]), PA15_I2SMCLK (ALT_MFP[9]) and GPA_MFP[15] determine the PA.15
N * |        |          |function.
N * |        |          |(PA15_SC2PWR, PA15_I2SMCLK, GPA_MFP15) value and function mapping is as following list.
N * |        |          |(0, 0, 0) = GPIOA function is selected.
N * |        |          |(0, 0, 1) = PWM3 function is selected.
N * |        |          |(0, 1, 1) = I2S_MCLK function is selected.
N * |        |          |(1, 0, 1) = SC2_PWR function is selected.         
N * |[31:16] |GPA_TYPEn |Trigger Function Selection
N * |        |          |0 = GPIOA[15:0] I/O input Schmitt Trigger function Disabled.
N * |        |          |1 = GPIOA[15:0] I/O input Schmitt Trigger function Enabled.
N * @var GCR_T::GPB_MFP
N * Offset: 0x34  GPIOB Multiple Function and Input Type Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |GPB_MFP0  |PB.0 Pin Function Selection     
N * |        |          |Bit GPB_MFP[0] determines the PB.0 function.
N * |        |          |0 = GPIO function is selected to the pin PB.0.
N * |        |          |1 = UART0_RXD function is selected to the pin PB.0.       
N * |[1]     |GPB_MFP1  |PB.1 Pin Function Selection
N * |        |          |Bit GPB_MFP[1] determines the PB.1 function.
N * |        |          |0 = GPIO function is selected to the pin PB.1.
N * |        |          |1 = UART0_TXD function is selected to the pin PB.1.     
N * |[2]     |GPB_MFP2  |PB.2 Pin Function Selection
N * |        |          |Bits EBI_nWRL_EN (ALT_MFP[13]), EBI_EN (ALT_MFP[11]), PB2_TM2 (ALT_MFP2[4]), PB2_CPO0
N * |        |          |(ALT_MFP[30]), PB2_T2EX (ALT_MFP[26]) and GPB_MFP[2] determine the PB.2 function.
N * |        |          |(EBI_nWRL_EN, EBI_EN, PB2_TM2, PB2_CPO0, PB2_T2EX, GPB_MFP2) value and function mapping is as
N * |        |          |following list.
N * |        |          |(0, 0, 0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 0, 0, 1) = UART0_nRTS function is selected.
N * |        |          |(0, 0, 0, 0, 1, 1) = TM2_EXT function is selected.
N * |        |          |(0, 0, 0, 1, 0, 1) = ACMP0_O function is selected.
N * |        |          |(0, 0, 1, 0, 0, 1) = TM2 function is selected.
N * |        |          |(1, 1, 0, 0, 0, 1) = nWRL(EBI) function is selected.     
N * |[3]     |GPB_MFP3  |PB.3 Pin Function Selection
N * |        |          |PB3_SC2CD (ALT_MFP1[14]), PB3_T3EX (ALT_MFP[27]) and GPB_MFP[3] determine the PB.3 function.
N * |        |          |(EBI_nWRH_EN, EBI_EN, PB3_TM3, PB3_SC2CD, PB3_T3EX, GPB_MFP3) value and function mapping is as
N * |        |          |following list.
N * |        |          |(0, 0, 0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 0, 0, 1) = UART0_nCTS function is selected.
N * |        |          |(0, 0, 0, 0, 1, 1) = TM3_EXT function is selected.
N * |        |          |(0, 0, 0, 1, 0, 1) = SC2_CD function is selected.
N * |        |          |(0, 0, 1, 0, 0, 1) = TM3 function is selected.
N * |        |          |(1, 1, 0, 0, 0, 1) = nWRH(EBI) function is selected.              
N * |[4]     |GPB_MFP4  |PB.4 Pin Function Selection
N * |        |          |Bit GPB_MFP[4] determines the PB.4 function.
N * |        |          |0 = GPIO function is selected to the pin PB.4.
N * |        |          |1 = UART1_RXD function is selected to the pin PB.4.     
N * |[5]     |GPB_MFP5  |PB 5 Pin Function Selection
N * |        |          |Bit GPB_MFP[5] determines the PB.5 function.
N * |        |          |0 = GPIO function is selected to the pin PB.5.
N * |        |          |1 = UART1_TXD function is selected to the pin PB.5.     
N * |[6]     |GPB_MFP6  |PB.6 Pin Function Selection 
N * |        |          |Bit EBI_EN (ALT_MFP[11]), GPB_MFP[6] determines the PB.6 function.
N * |        |          |(EBI_EN, GPB_MFP6) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected to the pin PB.6.
N * |        |          |(0, 1) = UART1_nRTS function is selected to the pin PB.6.
N * |        |          |(1, 1) = ALE(EBI) function is selected to the pin PB.6.
N * |[7]     |GPB_MFP7  |PB.7 Pin Function Selection
N * |        |          |Bit EBI_EN (ALT_MFP[11]), GPB_MFP[7] determines the PB.7 function.
N * |        |          |(EBI_EN, GPB_MFP7) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected to the pin PB.7.
N * |        |          |(0, 1) = UART1_nCTS function is selected to the pin PB.7.
N * |        |          |(1, 1) = nCS(EBI) function is selected to the pin PB.7.         
N * |[8]     |GPB_MFP8  |PB.8 Pin Function Selection
N * |        |          |Bits PB8_CLKO (ALT_MFP[29]) and GPB_MFP[8] determine the PB.8 function.
N * |        |          |(PB8_CLKO, GPB_MFP8) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = TM0 function is selected.
N * |        |          |(1, 1) = CLKO function is selected.          
N * |[9]     |GPB_MFP9  |PB.9 Pin Function Selection
N * |        |          |Bits PB9_S11 (ALT_MFP[1]) and GPB_MFP[9] determine the PB.9 function.
N * |        |          |(PB9_S11, GPB_MFP9) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = TM1 function is selected.
N * |        |          |(1, 1) = SPI1_SS1 function is selected.         
N * |[10]    |GPB_MFP10 |PB.10 Pin Function Selection
N * |        |          |Bits PB10_S01 (ALT_MFP[0]) and GPB_MFP[10] determine the PB.10 function.
N * |        |          |(PB10_S01, GPB_MFP10) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = TM2 function is selected.
N * |        |          |(1, 1) = SPI0_SS1 function is selected.     
N * |[11]    |GPB_MFP11 |PB.11 Pin Function Selection
N * |        |          |Bits PB11_PWM4 (ALT_MFP[4]) and GPB_MFP[11] determine the PB.11 function.
N * |        |          |(PB11_PWM4, GPB_MFP11) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = TM3 function is selected.     
N * |        |          |(1, 1) = PWM4 function is selected.     
N * |[13]    |GPB_MFP13 |PB.13 Pin Function Selection
N * |        |          |Bit EBI_EN (ALT_MFP[11]), GPB_MFP[13] determines the PB.13 function.
N * |        |          |(EBI_EN, GPB_MFP13) value and function mapping is as following list
N * |        |          |(0, 0) = GPIO function is selected to the pin PB.13.
N * |        |          |(0, 1) = ACMP1_O function is selected to the pin PB.13.
N * |        |          |(1, 1) = AD1 function is selected.     
N * |[14]    |GPB_MFP14 |PB.14 Pin Function Selection
N * |        |          |Bits PB14_15_EBI (ALT_MFP2[1]), PB14_S31 (ALT_MFP[3]) and GPB_MFP[14] determine the PB.14
N * |        |          |function.
N * |        |          |(PB14_15_EBI , PB14_S31, GPB_MFP14) value and function mapping is as following list
N * |        |          |(0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 1) = INT0 function is selected.
N * |        |          |(0, 1, 1) = SPI3_SS1 function is selected.
N * |        |          |(1, 0, 1) = AD0 function is selected.     
N * |[15]    |GPB_MFP15 |PB.15 Pin Function Selection
N * |        |          |Bits PB14_15_EBI (ALT_MFP2[1]), PB15_T0EX (ALT_MFP[24]), PB15_TM0 (ALT_MFP2[2]) and GPB_MFP[15]
N * |        |          |determine the PB.15 function.
N * |        |          |(PB14_15_EBI, PB15_T0EX, PB15_TM0, GPB_MFP15) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = INT1 function is selected.
N * |        |          |(0 ,0, 1, 1) = TM0 function is selected.
N * |        |          |(0, 1, 0, 1) = TM0_EXT function is selected.
N * |        |          |(1, 0, 0, 1) = AD6 function is selected.     
N * |[31:16] |GPB_TYPEn |Trigger Function Selection
N * |        |          |0 = GPIOB[15:0] I/O input Schmitt Trigger function Disabled.
N * |        |          |1 = GPIOB[15:0] I/O input Schmitt Trigger function Enabled.
N * @var GCR_T::GPC_MFP
N * Offset: 0x38  GPIOC Multiple Function and Input Type Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |GPC_MFP0  |PC.0 Pin Function Selection
N * |        |          |Bits PC0_I2SLRCLK (ALT_MFP[5]) and GPC_MFP[0] determine the PC.0 function.
N * |        |          |(PC0_I2SLRCLK, GPC_MFP0) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = SPI0_SS0 function is selected.
N * |        |          |(1, 1) = I2S_LRCK function is selected.          
N * |[1]     |GPC_MFP1  |PC.1 Pin Function Selection
N * |        |          |Bits PC1_I2SBCLK (ALT_MFP[6]) and GPC_MFP[1] determine the PC.1 function.
N * |        |          |(PC1_I2SBCLK, GPC_MFP1) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = SPI0_CLK function is selected.
N * |        |          |(1, 1) = I2S_BCLK function is selected.     
N * |[2]     |GPC_MFP2  |PC.2 Pin Function Selection
N * |        |          |Bits PC2_I2SDI (ALT_MFP[7]) and GPC_MFP[2] determine the PC.2 function.
N * |        |          |(PC2_I2SDI, GPC_MFP2) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = SPI0_MISO0 function is selected.
N * |        |          |(1, 1) = I2S_DI function is selected.
N * |[3]     |GPC_MFP3  |PC.3 Pin Function Selection
N * |        |          |Bits PC3_I2SDO (ALT_MFP[8]) and GPC_MFP[3] determine the PC.3 function.
N * |        |          |(PC3_I2SDO, GPC_MFP3) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = SPI0_MOSI0 function is selected.
N * |        |          |(1, 1) = I2S_DO function is selected.     
N * |[4]     |GPC_MFP4  |PC.4 Pin Function Selection
N * |        |          |Bit GPC_MFP[9] determines the PC.4 function.
N * |        |          |0 = GPIO function is selected to the pin PC.4.
N * |        |          |1 = SPI0_MISO1 function is selected to the pin PC.4.     
N * |[5]     |GPC_MFP5  |PC.5 Pin Function Selection
N * |        |          |Bit GPC_MFP[9] determines the PC.5 function.
N * |        |          |0 = GPIO function is selected to the pin PC.5.
N * |        |          |1 = SPI0_MOSI1 function is selected to the pin PC.5.     
N * |[6]     |GPC_MFP6  |PC.6 Pin Function Selection
N * |        |          |Bits EBI_EN (ALT_MFP[11]). PC6_SC0CD (ALT_MFP1[4]) and GPC_MFP[6] determine the PC.6 function.
N * |        |          |(EBI_EN, PC6_SC0CD, GPC_MFP6) value and function mapping is as following list.
N * |        |          |(0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 1) = ACMP0_P function is selected.
N * |        |          |(0, 1, 1) = SC0_CD function is selected.
N * |        |          |(1, 0, 1) = AD4 function is selected.     
N * |[7]     |GPC_MFP7  |PC.7 Pin Function Selection
N * |        |          |Bits EBI_EN (ALT_MFP[11]), PC7_SC1CD (ALT_MFP1[9]) and GPC_MFP[7] determine the PC.7 function.
N * |        |          |(EBI_EN, PC7_SC1CD, GPC_MFP7) value and function mapping is as following list.
N * |        |          |(0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 1) = ACMP0_N function is selected.
N * |        |          |(0, 1, 1) = SC1_CD function is selected.
N * |        |          |(1, 0, 1) = AD5 function is selected.      
N * |[8]     |GPC_MFP8  |PC.8 Pin Function Selection
N * |        |          |Bits EBI_MCLK_EN (ALT_MFP[12]), EBI_EN (ALT_MFP[11]), GPC_MFP[8] determine the PC.8 function.
N * |        |          |(EBI_MCLK_EN, EBI_EN, GPC_MFP8) value and function mapping is as following list.
N * |        |          |(0, 0, 0) = GPIO function is selected to the pin PC.8.
N * |        |          |(0, 0 ,1) = SPI1_SS0 function is selected to the pin PC.8.
N * |        |          |(1, 1, 1) = MCLK(EBI) function is selected to the pin PC.8.     
N * |[9]     |GPC_MFP9  |PC.9 Pin Function Selection
N * |        |          |Bit GPC_MFP[9] determines the PC.9 function.
N * |        |          |0 = GPIO function is selected to the pin PC.9.
N * |        |          |1 = SPI1_CLK function is selected to the pin PC.9.          
N * |[10]    |GPC_MFP10 |PC.10 Pin Function Selection
N * |        |          |Bit GPC_MFP[10] determines the PC.10 function.
N * |        |          |0 = GPIO function is selected to the pin PC.10.
N * |        |          |1 = SPI1_MISO0 function is selected to the pin PC.10.    
N * |[11]    |GPC_MFP11 |PC.11 Pin Function Selection
N * |        |          |Bit GPC_MFP[11] determines the PC.11 function.
N * |        |          |0 = GPIO function is selected to the pin PC.11.
N * |        |          |1 = SPI1_MOSI0 function is selected to the pin PC.11.        
N * |[12]    |GPC_MFP12 |PC.12 Pin Function Selection
N * |        |          |Bit GPC_MFP[12] determines the PC.12 function.
N * |        |          |0 = GPIO function is selected to the pin PC.12.
N * |        |          |1 = SPI1_MISO1 function is selected to the pin PC.12.      
N * |[13]    |GPC_MFP13 |PC.13 Pin Function Selection
N * |        |          |Bit GPC_MFP[13] determines the PC.13 function.
N * |        |          |0 = GPIO function is selected to the pin PC.13.
N * |        |          |1 = SPI1_MOSI1 function is selected to the pin PC.13.     
N * |[14]    |GPC_MFP14 |PC.14 Pin Function Selection
N * |        |          |Bits EBI_EN (ALT_MFP[11]) and GPC_MFP[14] determine the PC.14 function.
N * |        |          |(EBI_EN, GPC_MFP14) value and function mapping is as following list
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = ACMP1_P function is selected.
N * |        |          |(1, 1) = AD2 function is selected.       
N * |[15]    |GPC_MFP15 |PC.15 Pin Function Selection
N * |        |          |Bits EBI_EN (ALT_MFP[11]) and GPC_MFP[15] determine the PC.15 function.
N * |        |          |(EBI_EN, GPC_MFP15) value and function mapping is as following list
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = ACMP1_N function is selected.
N * |        |          |(1, 1) = AD3 function is selected.        
N * |[31:16] |GPC_TYPEn |Trigger Function Selection
N * |        |          |0 = GPIOC[15:0] I/O input Schmitt Trigger function Disabled.
N * |        |          |1 = GPIOC[15:0] I/O input Schmitt Trigger function Enabled.
N * @var GCR_T::GPD_MFP
N * Offset: 0x3C  GPIOD Multiple Function and Input Type Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |GPD_MFP0  |PD.0 Pin Function Selection
N * |        |          |Bit GPD_MFP[0] determines the PD.0 function.
N * |        |          |0 = GPIO function is selected to the pin PD.0.
N * |        |          |1 = SPI2_SS0 function is selected to the pin PD.0.     
N * |[1]     |GPD_MFP1  |PD.1 Pin Function Selection
N * |        |          |Bit GPD_MFP[1] determines the PD.1 function.
N * |        |          |0 = GPIO function is selected to the pin PD.1.
N * |        |          |1 = SPI2_CLK function is selected to the pin PD.1.
N * |[2]     |GPD_MFP2  |PD.2 Pin Function Selection
N * |        |          |Bit GPD_MFP[2] determines the PD.2 function.
N * |        |          |0 = GPIO function is selected to the pin PD.2.
N * |        |          |1 = SPI2_MISO0 function is selected to the pin PD.2.     
N * |[3]     |GPD_MFP3  |PD.3 Pin Function Selection
N * |        |          |Bit GPD_MFP[3] determines the PD.3 function.
N * |        |          |0 = GPIO function is selected to the pin PD.3.
N * |        |          |1 = SPI2_MOSI0 function is selected to the pin PD.3.     
N * |[4]     |GPD_MFP4  |PD.4 Pin Function Selection
N * |        |          |Bit GPD_MFP[4] determines the PD.4 function.
N * |        |          |0 = GPIO function is selected to the pin PD.4.
N * |        |          |1 = SPI2_MISO1 function is selected to the pin PD.4.     
N * |[5]     |GPD_MFP5  |PD.5 Pin Function Selection
N * |        |          |Bit GPD_MFP[9] determines the PD.5 function.
N * |        |          |0 = GPIO function is selected to the pin PD.5.
N * |        |          |1 = SPI2_MOSI1 function is selected to the pin PD.5.     
N * |[6]     |GPD_MFP6  |PD.6 Pin Function Selection
N * |        |          |Bit GPD_MFP[9] determines the PD.6 function.
N * |        |          |0 = The GPIO function is selected to the pin PD.6.
N * |        |          |1 = The CAN0_RXD function is selected to the pin PD.6.     .
N * |[7]     |GPD_MFP7  |PD.7 Pin Function Selection
N * |        |          |Bit GPD_MFP[7] determines the PD.7 function.
N * |        |          |0 = The GPIO function is selected to the pin PD.7.
N * |        |          |1 = The CAN0_TXD function is selected to the pin PD.7.     
N * |[8]     |GPD_MFP8  |PD.8 Pin Function Selection
N * |        |          |Bit GPD_MFP[8] determines the PD.8 function.
N * |        |          |0 = GPIO function is selected to the pin PD.8.
N * |        |          |1 = SPI3_SS0 function is selected to the pin PD.8.     
N * |[9]     |GPD_MFP9  |PD.9 Pin Function Selection
N * |        |          |Bit GPD_MFP[9] determines the PD.9 function.
N * |        |          |0 = GPIO is function is selected to the pin PD.9.
N * |        |          |1 = SPI3_CLK function is selected to the pin PD.9.     
N * |[10]    |GPD_MFP10 |PD.10 Pin Function Selection
N * |        |          |Bit GPD_MFP[10] determines the PD.10 function.
N * |        |          |0 = GPIO function is selected to the pin PD.10.
N * |        |          |1 = SPI3_MISO0 function is selected to the pin PD.10.     
N * |[11]    |GPD_MFP11 |PD.11 Pin Function Selection
N * |        |          |Bit GPD_MFP[11] determines the PD.11 function.
N * |        |          |0 = GPIO function is selected to the pin PD.11.
N * |        |          |1 = SPI3_MOSI0 function is selected to the pin PD.11.     
N * |[12]    |GPD_MFP12 |PD.12 Pin Function Selection
N * |        |          |Bit GPD_MFP[12] determines the PD.12 function.
N * |        |          |0 = GPIO function is selected to the pin PD.12.
N * |        |          |1 = SPI3_MISO1 function is selected to the pin PD.12.     
N * |[13]    |GPD_MFP13 |PD.13 Pin Function Selection
N * |        |          |Bit GPD_MFP[13] determines the PD.13 function.
N * |        |          |0 = GPIO function is selected to the pin PD.13.
N * |        |          |1 = SPI3_MOSI1 function is selected to the pin PD.13.     
N * |[14]    |GPD_MFP14 |PD.14 Pin Function Selection
N * |        |          |Bits PD14_15_CAN1 (ALT_MFP2[0]) and GPD_MFP[14] determine the PD.14 function.
N * |        |          |(PD14_15_CAN1, GPD_MFP14) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = UART2_RXD function is selected.
N * |        |          |(1, 1) = CAN1_RXD function is selected.     
N * |[15]    |GPD_MFP15 |PD.15 Pin Function Selection
N * |        |          |Bits PD14_15_CAN1 (ALT_MFP2[0]) and GPD_MFP[15] determine the PD.15 function.
N * |        |          |(PD14_15_CAN1, GPD_MFP15) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = UART2_TXD function is selected.
N * |        |          |(1, 1) = CAN1_TXD function is selected.     
N * |[31:16] |GPD_TYPEn |Trigger Function Selection
N * |        |          |0 = GPIOD[15:0] I/O input Schmitt Trigger function Disabled.
N * |        |          |1 = GPIOD[15:0] I/O input Schmitt Trigger function Enabled.
N * @var GCR_T::GPE_MFP
N * Offset: 0x40  GPIOE Multiple Function and Input Type Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |GPE_MFP0  |PE.0 Pin Function Selection
N * |        |          |Bit GPE_MFP[0] determines the PE.0 function.
N * |        |          |0 = GPIO function is selected to the pin PE.0.
N * |        |          |1 = PWM6 function is selected to the pin PE.0.     
N * |[1]     |GPE_MFP1  |PE.1 Pin Function Selection
N * |        |          |Bit GPE_MFP[1] determines the PE.1 function.
N * |        |          |0 = GPIO function is selected to the pin PE.1.
N * |        |          |1 = PWM7 function is selected to the pin PE.1.     
N * |[5]     |GPE_MFP5  |PE.5 Pin Function Selection
N * |        |          |Bits PE5_T1EX (ALT_MFP[25]), PE5_TM1 (ALT_MFP2[3]) and GPE_MFP5 determine the PE.5 function.
N * |        |          |(PE5_T1EX, GPE_MFP5) value and function mapping is as following list.
N * |        |          |(0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 1) = PWM5 function is selected.
N * |        |          |(1, 0, 1) = TM1_EXT function is selected.
N * |        |          |(0, 1, 1) = TM1 function is selected.     
N * |[31:16] |GPE_TYPEn |Trigger Function Selection
N * |        |          |0 = GPIOD[15:0] I/O input Schmitt Trigger function Disabled.
N * |        |          |1 = GPIOD[15:0] I/O input Schmitt Trigger function Enabled.
N * @var GCR_T::GPF_MFP
N * Offset: 0x44  GPIOF Multiple Function and Input Type Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |GPF_MFP0  |PF.0 Pin Function Selection
N * |        |          |Bit GPF_MFP[0] determines the PF.0 function
N * |        |          |0 = GPIO function is selected to the pin PF.0.
N * |        |          |1 = XT1_OUT function is selected to the pin PF.0.
N * |        |          |Note: This bit is read only and is decided by user configuration CGPFMFP (CONFIG0[27]).     
N * |[1]     |GPF_MFP1  |PF.1 Pin Function Selection
N * |        |          |Bit GPF_MFP[1] determines the PF.1 function.
N * |        |          |0 = GPIO function is selected to the pin PF.1.
N * |        |          |1 = XT1_IN function is selected to the pin PF.1.
N * |        |          |Note: This bit is read only and is decided by user configuration CGPFMFP (CONFIG0[27]).     
N * |[2]     |GPF_MFP2  |PF.2 Pin Function Selection
N * |        |          |Bit GPF_MFP[2] determines the PF.2 function.
N * |        |          |0 = GPIO function is selected to the pin PF.2.
N * |        |          |1 = PS/2_DAT function is selected to the pin PF.2.     
N * |[3]     |GPF_MFP3  |PF.3 Pin Function Selection
N * |        |          |Bit GPF_MFP[3] determines the PF.3 function.
N * |        |          |0 = GPIO function is selected to the pin PF.3.
N * |        |          |1 = PS/2_CLK function is selected to the pin PF.3.     
N * |[19:16] |GPF_TYPEn |Trigger Function Selection
N * |        |          |0 = GPIOF[3:0] I/O input Schmitt Trigger function Disabled.
N * |        |          |1 = GPIOF[3:0] I/O input Schmitt Trigger function Enabled.
N * @var GCR_T::ALT_MFP
N * Offset: 0x50  Alternative Multiple Function Pin Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |PB10_S01  |PB.10 Pin Alternative Function Selection
N * |        |          |Bits PB10_S01 (ALT_MFP[0]) and GPB_MFP[10] determine the PB.10 function.
N * |        |          |(PB10_S01, GPB_MFP10) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = TM2 function is selected.
N * |        |          |(1, 1) = SPI0_SS1 function is selected.       
N * |[1]     |PB9_S11   |PB.9 Pin Alternative Function Selection
N * |        |          |Bits PB9_S11 (ALT_MFP[1]) and GPB_MFP[9] determine the PB.9 function.
N * |        |          |(PB9_S11, GPB_MFP9) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = TM1 function is selected.
N * |        |          |(1, 1) = SPI1_SS1 function is selected.           
N * |[2]     |PA7_S21   |PA.7 Pin Alternative Function Selection
N * |        |          |Bits EBI_EN (ALT_MFP[11]), PA7_SC1DAT (ALT_MFP1[6]), PA7_S21 (ALT_MFP[2]) and GPA_MFP[7]
N * |        |          |determine the PA.7 function.
N * |        |          |(EBI_EN, PA7_SC1DAT, PA7_S21, GPA_MFP7) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = ADC7 function is selected.
N * |        |          |(0, 0, 1, 1) = SPI2_SS1 function is selected.
N * |        |          |(0, 1, 0, 1) = SC1_DAT/UART4_RXD function is selected.
N * |        |          |(1, 0, 0, 1) = AD6 function is selected.                  
N * |[3]     |PB14_S31  |PB.14 Pin Alternative Function Selection
N * |        |          |Bits PB14_15_EBI (ALT_MFP2[1]), PB14_S31 (ALT_MFP[3]) and GPB_MFP[14] determine the PB.14
N * |        |          |function.
N * |        |          |(PB14_15_EBI , PB14_S31, GPB_MFP14) value and function mapping is as following list
N * |        |          |(0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 1) = INT0 function is selected.
N * |        |          |(0, 1, 1) = SPI3_SS1 function is selected.
N * |        |          |(1, 0, 1) = AD0 function is selected.    
N * |[4]     |PB11_PWM4 |PB.11 Pin Alternative Function Selection     
N * |        |          |Bits PB11_PWM4 (ALT_MFP[4]) and GPB_MFP[11] determine the PB.11 function.
N * |        |          |(PB11_PWM4, GPB_MFP11) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = TM3 function is selected.     
N * |        |          |(1, 1) = PWM4 function is selected.      
N * |[5]     |PC0_I2SLRCLK|PC.0 Pin Alternative Function Selection
N * |        |          |Bits PC0_I2SLRCLK (ALT_MFP[5]) and GPC_MFP[0] determine the PC.0 function.
N * |        |          |(PC0_I2SLRCLK, GPC_MFP0) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = SPI0_SS0 function is selected.
N * |        |          |(1, 1) = I2S_LRCK function is selected.         
N * |[6]     |PC1_I2SBCLK|PC.1 Pin Alternative Function Selection
N * |        |          |Bits PC0_I2SLRCLK (ALT_MFP[5]) and GPC_MFP[0] determine the PC.0 function.
N * |        |          |(PC0_I2SLRCLK, GPC_MFP0) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = SPI0_SS0 function is selected.
N * |        |          |(1, 1) = I2S_LRCK function is selected.         
N * |[7]     |PC2_I2SDI |PC.2 Pin Alternative Function Selection
N * |        |          |Bits PC2_I2SDI (ALT_MFP[7]) and GPC_MFP[2] determine the PC.2 function.
N * |        |          |(PC2_I2SDI, GPC_MFP2) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = SPI0_MISO0 function is selected.
N * |        |          |(1, 1) = I2S_DI function is selected.     
N * |[8]     |PC3_I2SDO |PC.3 Pin Alternative Function Selection
N * |        |          |Bits PC3_I2SDO (ALT_MFP[8]) and GPC_MFP[3] determine the PC.3 function.
N * |        |          |(PC3_I2SDO, GPC_MFP3) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = SPI0_MOSI0 function is selected.
N * |        |          |(1, 1) = I2S_DO function is selected. 
N * |[9]     |PA15_I2SMCLK|PA.15 Pin Alternative Function Selection
N * |        |          |Bits PA15_SC2PWR (ALT_MFP1[12]), PA15_I2SMCLK (ALT_MFP[9]) and GPA_MFP[15] determine the PA.15
N * |        |          |function.
N * |        |          |(PA15_SC2PWR, PA15_I2SMCLK, GPA_MFP15) value and function mapping is as following list.
N * |        |          |(0, 0, 0) = GPIOA function is selected.
N * |        |          |(0, 0, 1) = PWM3 function is selected.
N * |        |          |(0, 1, 1) = I2S_MCLK function is selected.
N * |        |          |(1, 0, 1) = SC2_PWR function is selected.  
N * |[11]    |EBI_EN    |EBI Pin Function Selection
N * |        |          |EBI_EN is use to switch GPIO function to EBI function (AD[15:0], ALE, RE, WE, CS, MCLK), it need
N * |        |          |additional registers EBI_EN[7:0] and EBI_MCLK_EN for some GPIO to switch to EBI
N * |        |          |function(AD[15:8], MCLK).
N * |[12]    |EBI_MCLK_EN|PC.8 Pin Alternative Function Selection
N * |        |          |Bits EBI_MCLK_EN (ALT_MFP[12]), EBI_EN (ALT_MFP[11]), GPC_MFP[8] determine the PC.8 function.
N * |        |          |(EBI_MCLK_EN, EBI_EN, GPC_MFP8) value and function mapping is as following list.
N * |        |          |(0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0 ,1) = SPI1_SS0 function is selected.
N * |        |          |(1, 1, 1) = MCLK(EBI) function is selected.
N * |[13]    |EBI_nWRL_EN|PB.2 Pin Alternative Function Selection
N * |        |          |Bits EBI_nWRL_EN (ALT_MFP[13]), EBI_EN (ALT_MFP[11]), PB2_TM2 (ALT_MFP2[4]), PB2_CPO0
N * |        |          |(ALT_MFP[30]), PB2_T2EX (ALT_MFP[26]) and GPB_MFP[2] determine the PB.2 function.
N * |        |          |(EBI_nWRL_EN, EBI_EN, PB2_TM2, PB2_CPO0, PB2_T2EX, GPB_MFP2) value and function mapping is as
N * |        |          |following list.
N * |        |          |(0, 0, 0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 0, 0, 1) = UART0_nRTS function is selected.
N * |        |          |(0, 0, 0, 0, 1, 1) = TM2_EXT function is selected.
N * |        |          |(0, 0, 0, 1, 0, 1) = ACMP0_O function is selected.
N * |        |          |(0, 0, 1, 0, 0, 1) = TM2 function is selected.
N * |        |          |(1, 1, 0, 0, 0, 1) = nWRL(EBI) function is selected. 
N * |[14]    |EBI_nWRH_EN|PB.3 Pin Alternative Function Selection
N * |        |          |PB3_SC2CD (ALT_MFP1[14]), PB3_T3EX (ALT_MFP[27]) and GPB_MFP[3] determine the PB.3 function.
N * |        |          |(EBI_nWRH_EN, EBI_EN, PB3_TM3, PB3_SC2CD, PB3_T3EX, GPB_MFP3) value and function mapping is as
N * |        |          |following list.
N * |        |          |(0, 0, 0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 0, 0, 1) = UART0_nCTS function is selected.
N * |        |          |(0, 0, 0, 0, 1, 1) = TM3_EXT function is selected.
N * |        |          |(0, 0, 0, 1, 0, 1) = SC2_CD function is selected.
N * |        |          |(0, 0, 1, 0, 0, 1) = TM3 function is selected.
N * |        |          |(1, 1, 0, 0, 0, 1) = nWRH(EBI) function is selected.   
N * |[16]    |EBI_HB_EN[0]|PA.5 Pin Alternative Function Selection
N * |        |          |Bits EBI_HB_EN[0] (ALT_MFP[16]), EBI_EN (ALT_MFP[11]),PA5_SC1RST (ALT_MFP1[8]) and GPA_MFP[5]
N * |        |          |determine the PA.5 function.
N * |        |          |(EBI_HB_EN[0], EBI_EN, PA5_SC1RST, GPA_MFP5) value and function mapping is as following list,
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = ADC5 function is selected.
N * |        |          |(0, 0, 1, 1) = SC1_RST function is selected.
N * |        |          |(1, 1, 0, 1) = AD8 function is selected.    
N * |[17]    |EBI_HB_EN[1]|PA.4 Pin Alternative Function Selection
N * |        |          |Bits EBI_HB_EN[1] (ALT_MFP[17]), EBI_EN (ALT_MFP[11]), PA4_SC1PWR (ALT_MFP1[7]) and GPA_MFP[4]
N * |        |          |determine the PA.4 function.
N * |        |          |(EBI_HB_EN[1], EBI_EN, PA4_SC1PWR, GPA_MFP4) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = ADC4 function is selected.
N * |        |          |(0, 0, 1, 1) = SC1_PWR function is selected.
N * |        |          |(1, 1, 0, 1) = AD9 function is selected.        
N * |[18]    |EBI_HB_EN[2]|PA.3 Pin Alternative Function Selection
N * |        |          |Bits EBI_HB_EN[2] (ALT_MFP[18]), EBI_EN (ALT_MFP[11]), PA3_SC0DAT (ALT_MFP1[1]) and GPA_MFP[3]
N * |        |          |determine the PA.3 function.
N * |        |          |(EBI_HB_EN[2], EBI_EN, PA3_SC0DAT, GPA_MFP3) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = ADC3 function is selected.
N * |        |          |(0, 0, 1, 1) = SC0_DAT/UART3_RXD function is selected.
N * |        |          |(1, 1, 0, 1) = AD10 function is selected.
N * |[19]    |EBI_HB_EN[3]|PA.2 Pin Alternative Function Selection
N * |        |          |Bits EBI_HB_EN[3] (ALT_MFP[19]), EBI_EN (ALT_MFP[11]), PA2_SC0CLK (ALT_MFP1[0]) and GPA_MFP[2]
N * |        |          |determine the PA.2 function.
N * |        |          |(EBI_HB_EN[3], EBI_EN, PA2_SC0CLK, GPA_MFP2) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = ADC2 function is selected.
N * |        |          |(0, 0, 1, 1) = SC0_CLK/UART3_TXD function is selected.
N * |        |          |(1, 1, 0, 1) = AD11 function is selected.   
N * |[20]    |EBI_HB_EN[4]|PA.1 Pin Alternative Function Selection
N * |        |          |Bit EBI_HB_EN[4] (ALT_MFP[20]), EBI_EN (ALT_MFP[11]), PA1_SC0RST (ALT_MFP1[3]) and GPA_MFP[1]
N * |        |          |determine the PA.1 function.
N * |        |          |(EBI_HB_EN[4], EBI_EN, PA1_SC0RST, GPA_MFP1) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = ADC1 function is selected.
N * |        |          |(0, 0, 1, 1) = SC0_RST function is selected.
N * |        |          |(1, 1, 0, 1) = AD12 function is selected.   
N * |[21]    |EBI_HB_EN[5]|PA.12 Pin Alternative Function Selection
N * |        |          |Bits EBI_HB_EN[5] (ALT_MFP[21]), EBI_EN (ALT_MFP[11]), PA12_SC2DAT (ALT_MFP1[11]) and
N * |        |          |GPA_MFP[12] determine the PA.12 function.
N * |        |          |(EBI_HB_EN[5], EBI_EN, PA12_SC2DAT, GPA_MFP12) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = PWM0 function is selected.
N * |        |          |(0, 0, 1, 1) = SC2_DAT/UART5_RXD function is selected.
N * |        |          |(1, 1, 0, 1) = AD13 function is selected.
N * |[22]    |EBI_HB_EN[6]|PA.13 Pin Alternative Function Selection
N * |        |          |Bits EBI_HB_EN[6] (ALT_MFP[22]), EBI_EN (ALT_MFP[11]), PA13_SC2CLK (ALT_MFP1[10]) and
N * |        |          |GPA_MFP[13] determine the PA.13 function.
N * |        |          |(EBI_HB_EN[6], EBI_EN, PA13_SC2CLK, GPA_MFP13) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = PWM1 function is selected.
N * |        |          |(0, 0, 1, 1) = SC2_CLK/UART5_TXD function is selected.
N * |        |          |(1, 1, 0, 1) = AD14 function is selected. 
N * |[23]    |EBI_HB_EN[7]|PA.14 Pin Alternative Function Selection     
N * |        |          |Bits EBI_HB_EN[7] (ALT_MFP[23]), EBI_EN (ALT_MFP[11]), PA14_SC2RST (ALT_MFP1[13]) and
N * |        |          |GPA_MFP[14] determine the PA.14 function.
N * |        |          |(EBI_HB_EN , EBI_EN, PA14_SC2RST, GPA_MFP14) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = PWM2 function is selected.
N * |        |          |(0, 0, 1, 1) = SC2_RST function is selected.
N * |        |          |(1, 1, 0, 1) = AD15 function is selected.       
N * |[24]    |PB15_T0EX |PB.15 Pin Alternative Function Selection  
N * |        |          |Bits PB14_15_EBI (ALT_MFP2[1]), PB15_T0EX (ALT_MFP[24]), PB15_TM0 (ALT_MFP2[2]) and GPB_MFP[15]
N * |        |          |determine the PB.15 function.
N * |        |          |(PB14_15_EBI, PB15_T0EX, PB15_TM0, GPB_MFP15) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = INT1 function is selected.
N * |        |          |(0 ,0, 1, 1) = TM0 function is selected.
N * |        |          |(0, 1, 0, 1) = TM0_EXT function is selected.
N * |        |          |(1, 0, 0, 1) = AD6 function is selected.  
N * |[25]    |PE5_T1EX  |PE.5 Pin Alternative Function Selection
N * |        |          |Bits PE5_T1EX (ALT_MFP[25]), PE5_TM1 (ALT_MFP2[3]) and GPE_MFP5 determine the PE.5 function.
N * |        |          |(PE5_T1EX, GPE_MFP5) value and function mapping is as following list.
N * |        |          |(0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 1) = PWM5 function is selected.
N * |        |          |(1, 0, 1) = TM1_EXT function is selected.
N * |        |          |(0, 1, 1) = TM1 function is selected.        
N * |[26]    |PB2_T2EX  |PB.2 Pin Alternative Function Selection
N * |        |          |Bits PB2_TM2 (ALT_MFP2[4]), PB2_CPO0 (ALT_MFP[30]), PB2_T2EX (ALT_MFP[26]) and GPB_MFP[2]
N * |        |          |determine the PB.2 function.
N * |        |          |(PB2_TM2, PB2_CPO0, PB2_T2EX, GPB_MFP2) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = UART0_nRTS function is selected.
N * |        |          |(0, 0, 1, 1) = TM2_EXT function is selected.
N * |        |          |(0, 1, 0, 1) = ACMP0_O function is selected.          
N * |[27]    |PB3_T3EX  |PB.3 Pin Alternative Function Selection
N * |        |          |Bits PB3_TM3 (ALT_MFP2[5]), PB3_SC2CD (ALT_MFP1[14]), PB3_T3EX (ALT_MFP[27]) and GPB_MFP[3]
N * |        |          |determine the PB.3 function.
N * |        |          |(PB3_TM3, PB3_SC2CD, PB3_T3EX, GPB_MFP3) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = UART0_nCTS function is selected.
N * |        |          |(0, 0, 1, 1) = TM3_EXT function is selected.
N * |        |          |(0, 1, 0, 1) = SC2_CD function is selected.
N * |        |          |(1, 0, 0, 1) = TM3 function is selected.            
N * |[28]    |PA10_11_CAN1|PA.10 and PA.11 Pin Alternative Function Selection
N * |        |          |Bits PA10_11_CAN1 (ALT_MFP[28]) and GPA_MFP[10] determine the PA.10 function.
N * |        |          |(PA10_11_CAN1, GPA_MFP10) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = I2C1_SDA function is selected.
N * |        |          |(1, 1) = CAN1_TXD function is selected.
N * |        |          |Bits PA10_11_CAN1 (ALT_MFP[28]) and GPA_MFP[11] determine the PA.11 function.
N * |        |          |(PA10_11_CAN1, GPA_MFP11) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = I2C1_SCL function is selected.
N * |        |          |(1, 1) = CAN1_RXD function is selected.          
N * |[29]    |PB8_CLKO  |PB.8 Pin Alternative Function Selection
N * |        |          |Bits PB8_CLKO (ALT_MFP[29]) and GPB_MFP[8] determine the PB.8 function.
N * |        |          |(PB8_CLKO, GPB_MFP8) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = TM0 function is selected.
N * |        |          |(1, 1) = CLKO function is selected.                   
N * |[30]    |PB2_CPO0  |PB.2 Pin Alternative Function Selection
N * |        |          |Bits PB2_TM2 (ALT_MFP2[4]), PB2_CPO0 (ALT_MFP[30]), PB2_T2EX (ALT_MFP[26]) and GPB_MFP[2]
N * |        |          |determine the PB.2 function.
N * |        |          |(PB2_TM2, PB2_CPO0, PB2_T2EX, GPB_MFP2) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = UART0_nRTS function is selected.
N * |        |          |(0, 0, 1, 1) = TM2_EXT function is selected.
N * |        |          |(0, 1, 0, 1) = ACMP0_O function is selected.
N * @var GCR_T::ALT_MFP1
N * Offset: 0x58  Alternative Multiple Function Pin Control Register 1
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |PA2_SC0CLK|PA.2 Pin Alternative Function Selection
N * |        |          |Bits EBI_HB_EN[3] (ALT_MFP[19]), EBI_EN (ALT_MFP[11]), PA2_SC0CLK (ALT_MFP1[0]) and GPA_MFP[2]
N * |        |          |determine the PA.2 function.
N * |        |          |(EBI_HB_EN[3], EBI_EN, PA2_SC0CLK, GPA_MFP2) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = ADC2 function is selected.
N * |        |          |(0, 0, 1, 1) = SC0_CLK/UART3_TXD function is selected.
N * |        |          |(1, 1, 0, 1) = AD11 function is selected.               
N * |[1]     |PA3_SC0DAT|PA.3 Pin Alternative Function Selection 
N * |        |          |Bits EBI_HB_EN[2] (ALT_MFP[18]), EBI_EN (ALT_MFP[11]), PA3_SC0DAT (ALT_MFP1[1]) and GPA_MFP[3]
N * |        |          |determine the PA.3 function.
N * |        |          |(EBI_HB_EN[2], EBI_EN, PA3_SC0DAT, GPA_MFP3) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = ADC3 function is selected.
N * |        |          |(0, 0, 1, 1) = SC0_DAT/UART3_RXD function is selected.
N * |        |          |(1, 1, 0, 1) = AD10 function is selected.   
N * |[2]     |PA0_SC0PWR|PA.0 Pin Alternative Function Selection
N * |        |          |Bit PA0_SC0PWR (ALT_MFP1[2]) and GPA_MFP[0] determine the PA.0 function.
N * |        |          |(PA0_SC0PWR, GPA_MFP0) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = ADC0 function is selected.
N * |        |          |(1, 1) = SC0_PWR function is selected.  
N * |[3]     |PA1_SC0RST|PA.1 Pin Alternative Function Selection     
N * |        |          |Bit EBI_HB_EN[4] (ALT_MFP[20]), EBI_EN (ALT_MFP[11]), PA1_SC0RST (ALT_MFP1[3]) and GPA_MFP[1]
N * |        |          |determine the PA.1 function.
N * |        |          |(EBI_HB_EN[4], EBI_EN, PA1_SC0RST, GPA_MFP1) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = ADC1 function is selected.
N * |        |          |(0, 0, 1, 1) = SC0_RST function is selected.
N * |        |          |(1, 1, 0, 1) = AD12 function is selected.       
N * |[4]     |PC6_SC0CD |PC.6 Pin Alternative Function Selection
N * |        |          |Bits EBI_EN (ALT_MFP[11]). PC6_SC0CD (ALT_MFP1[4]) and GPC_MFP[6] determine the PC.6 function.
N * |        |          |(EBI_EN, PC6_SC0CD, GPC_MFP6) value and function mapping is as following list.
N * |        |          |(0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 1) = ACMP0_P function is selected.
N * |        |          |(0, 1, 1) = SC0_CD function is selected.
N * |        |          |(1, 0, 1) = AD4 function is selected.        
N * |[5]     |PA6_SC1CLK|PA.6 Pin Alternative Function Selection     
N * |        |          |Bits EBI_EN (ALT_MFP[11]), PA6_SC1CLK (ALT_MFP1[5]) and GPA_MFP[6] determine the PA.6 function.
N * |        |          |(EBI_EN, PA6_SC1CLK, GPA_MFP6) value and function mapping is as following list.
N * |        |          |(0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 1) = ADC6 function is selected.
N * |        |          |(0, 1, 1) = SC1_CLK/UART4_TXD function is selected.
N * |        |          |(1, 0, 1) = AD7 function is selected.          
N * |[6]     |PA7_SC1DAT|PA.7 Pin Alternative Function Selection
N * |        |          |Bits EBI_EN (ALT_MFP[11]), PA7_SC1DAT (ALT_MFP1[6]), PA7_S21 (ALT_MFP[2]) and GPA_MFP[7]
N * |        |          |determine the PA.7 function.
N * |        |          |(EBI_EN, PA7_SC1DAT, PA7_S21, GPA_MFP7) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = ADC7 function is selected.
N * |        |          |(0, 0, 1, 1) = SPI2_SS1 function is selected.
N * |        |          |(0, 1, 0, 1) = SC1_DAT/UART4_RXD function is selected.
N * |        |          |(1, 0, 0, 1) = AD6 function is selected.          
N * |[7]     |PA4_SC1PWR|PA.4 Pin Alternative Function Selection
N * |        |          |Bits EBI_HB_EN[1] (ALT_MFP[17]), EBI_EN (ALT_MFP[11]), PA4_SC1PWR (ALT_MFP1[7]) and GPA_MFP[4]
N * |        |          |determine the PA.4 function.
N * |        |          |(EBI_HB_EN[1], EBI_EN, PA4_SC1PWR, GPA_MFP4) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = ADC4 function is selected.
N * |        |          |(0, 0, 1, 1) = SC1_PWR function is selected.
N * |        |          |(1, 1, 0, 1) = AD9 function is selected.     
N * |[8]     |PA5_SC1RST|PA.5 Pin Alternative Function Selection
N * |        |          |Bits EBI_HB_EN[0] (ALT_MFP[16]), EBI_EN (ALT_MFP[11]),PA5_SC1RST (ALT_MFP1[8]) and GPA_MFP[5]
N * |        |          |determine the PA.5 function.
N * |        |          |(EBI_HB_EN[0], EBI_EN, PA5_SC1RST, GPA_MFP5) value and function mapping is as following list,
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = ADC5 function is selected.
N * |        |          |(0, 0, 1, 1) = SC1_RST function is selected.
N * |        |          |(1, 1, 0, 1) = AD8 function is selected.     
N * |[9]     |PC7_SC1CD |PC.7 Pin Alternative Function Selection     
N * |        |          |Bits EBI_EN (ALT_MFP[11]), PC7_SC1CD (ALT_MFP1[9]) and GPC_MFP[7] determine the PC.7 function.
N * |        |          |(EBI_EN, PC7_SC1CD, GPC_MFP7) value and function mapping is as following list.
N * |        |          |(0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 1) = ACMP0_N function is selected.
N * |        |          |(0, 1, 1) = SC1_CD function is selected.
N * |        |          |(1, 0, 1) = AD5 function is selected.   
N * |[10]    |PA13_SC2CLK|PA.13 Pin Alternative Function Selection 
N * |        |          |Bits EBI_HB_EN[6] (ALT_MFP[22]), EBI_EN (ALT_MFP[11]), PA13_SC2CLK (ALT_MFP1[10]) and
N * |        |          |GPA_MFP[13] determine the PA.13 function.
N * |        |          |(EBI_HB_EN[6], EBI_EN, PA13_SC2CLK, GPA_MFP13) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = PWM1 function is selected.
N * |        |          |(0, 0, 1, 1) = SC2_CLK/UART5_TXD function is selected.
N * |        |          |(1, 1, 0, 1) = AD14 function is selected.         
N * |[11]    |PA12_SC2DAT|PA.12 Pin Alternative Function Selection 
N * |        |          |Bits EBI_HB_EN[5] (ALT_MFP[21]), EBI_EN (ALT_MFP[11]), PA12_SC2DAT (ALT_MFP1[11]) and
N * |        |          |GPA_MFP[12] determine the PA.12 function.
N * |        |          |(EBI_HB_EN[5], EBI_EN, PA12_SC2DAT, GPA_MFP12) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = PWM0 function is selected.
N * |        |          |(0, 0, 1, 1) = SC2_DAT/UART5_RXD function is selected.
N * |        |          |(1, 1, 0, 1) = AD13 function is selected.           
N * |[12]    |PA15_SC2PWR|PA.15 Pin Alternative Function Selection
N * |        |          |Bits PA15_SC2PWR (ALT_MFP1[12]), PA15_I2SMCLK (ALT_MFP[9]) and GPA_MFP[15] determine the PA.15
N * |        |          |function.
N * |        |          |(PA15_SC2PWR, PA15_I2SMCLK, GPA_MFP15) value and function mapping is as following list.
N * |        |          |(0, 0, 0) = GPIOA function is selected.
N * |        |          |(0, 0, 1) = PWM3 function is selected.
N * |        |          |(0, 1, 1) = I2S_MCLK function is selected.
N * |        |          |(1, 0, 1) = SC2_PWR function is selected.             
N * |[13]    |PA14_SC2RST|PA.14 Pin Alternative Function Selection
N * |        |          |Bits EBI_HB_EN[7] (ALT_MFP[23]), EBI_EN (ALT_MFP[11]), PA14_SC2RST (ALT_MFP1[13]) and
N * |        |          |GPA_MFP[14] determine the PA.14 function.
N * |        |          |(EBI_HB_EN , EBI_EN, PA14_SC2RST, GPA_MFP14) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = PWM2 function is selected.
N * |        |          |(0, 0, 1, 1) = SC2_RST function is selected.
N * |        |          |(1, 1, 0, 1) = AD15 function is selected.             
N * |[14]    |PB3_SC2CD |PB.3 Pin Alternative Function Selection
N * |        |          |PB3_SC2CD (ALT_MFP1[14]), PB3_T3EX (ALT_MFP[27]) and GPB_MFP[3] determine the PB.3 function.
N * |        |          |(EBI_nWRH_EN, EBI_EN, PB3_TM3, PB3_SC2CD, PB3_T3EX, GPB_MFP3) value and function mapping is as
N * |        |          |following list.
N * |        |          |(0, 0, 0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 0, 0, 1) = UART0_nCTS function is selected.
N * |        |          |(0, 0, 0, 0, 1, 1) = TM3_EXT function is selected.
N * |        |          |(0, 0, 0, 1, 0, 1) = SC2_CD function is selected.
N * |        |          |(0, 0, 1, 0, 0, 1) = TM3 function is selected.
N * |        |          |(1, 1, 0, 0, 0, 1) = nWRH(EBI) function is selected.
N * @var GCR_T::ALT_MFP2
N * Offset: 0x5C  Alternative Multiple Function Pin Control Register 2
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |PD14_15_CAN1|PD.14 and PD.15 Pin Alternative Function Selection     
N * |        |          |Bits PD14_15_CAN1 (ALT_MFP2[0]) and GPD_MFP[14] determine the PD.14 function.
N * |        |          |(PD14_15_CAN1, GPD_MFP14) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = UART2_RXD function is selected.
N * |        |          |(1, 1) = CAN1_RXD function is selected.     
N * |        |          |Bits PD14_15_CAN1 (ALT_MFP2[0]) and GPD_MFP[15] determine the PD.15 function.
N * |        |          |(PD14_15_CAN1, GPD_MFP15) value and function mapping is as following list.
N * |        |          |(0, 0) = GPIO function is selected.
N * |        |          |(0, 1) = UART2_TXD function is selected.
N * |        |          |(1, 1) = CAN1_TXD function is selected.    
N * |[0]     |PB14_15_EBI|PB.14 and PB.15 Pin Alternative Function Selection 
N * |        |          |Bits PB14_15_EBI (ALT_MFP2[1]), PB14_S31 (ALT_MFP[3]) and GPB_MFP[14] determine the PB.14
N * |        |          |function.
N * |        |          |(PB14_15_EBI , PB14_S31, GPB_MFP14) value and function mapping is as following list
N * |        |          |(0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 1) = INT0 function is selected.
N * |        |          |(0, 1, 1) = SPI3_SS1 function is selected.
N * |        |          |(1, 0, 1) = AD0 function is selected.     
N * |        |          |Bits PB14_15_EBI (ALT_MFP2[1]), PB15_T0EX (ALT_MFP[24]), PB15_TM0 (ALT_MFP2[2]) and GPB_MFP[15]
N * |        |          |determine the PB.15 function.
N * |        |          |(PB14_15_EBI, PB15_T0EX, PB15_TM0, GPB_MFP15) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = INT1 function is selected.
N * |        |          |(0 ,0, 1, 1) = TM0 function is selected.
N * |        |          |(0, 1, 0, 1) = TM0_EXT function is selected.
N * |        |          |(1, 0, 0, 1) = AD6 function is selected.  
N * |[2]     |PB15_TM0  |PB.15 Pin Alternative Function Selection 
N * |        |          |Bits PB14_15_EBI (ALT_MFP2[1]), PB15_T0EX (ALT_MFP[24]), PB15_TM0 (ALT_MFP2[2]) and GPB_MFP[15]
N * |        |          |determine the PB.15 function.
N * |        |          |(PB14_15_EBI, PB15_T0EX, PB15_TM0, GPB_MFP15) value and function mapping is as following list.
N * |        |          |(0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 1) = INT1 function is selected.
N * |        |          |(0 ,0, 1, 1) = TM0 function is selected.
N * |        |          |(0, 1, 0, 1) = TM0_EXT function is selected.
N * |        |          |(1, 0, 0, 1) = AD6 function is selected.  
N * |[3]     |PE5_TM1   |PE.5 Pin Alternative Function Selection      
N * |        |          |Bits PE5_T1EX (ALT_MFP[25]), PE5_TM1 (ALT_MFP2[3]) and GPE_MFP5 determine the PE.5 function.
N * |        |          |(PE5_T1EX, GPE_MFP5) value and function mapping is as following list.
N * |        |          |(0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 1) = PWM5 function is selected.
N * |        |          |(1, 0, 1) = TM1_EXT function is selected.
N * |        |          |(0, 1, 1) = TM1 function is selected.         
N * |[4]     |PB2_TM2   |PB.2 Pin Alternative Function Selection 
N * |        |          |Bits EBI_nWRL_EN (ALT_MFP[13]), EBI_EN (ALT_MFP[11]), PB2_TM2 (ALT_MFP2[4]), PB2_CPO0
N * |        |          |(ALT_MFP[30]), PB2_T2EX (ALT_MFP[26]) and GPB_MFP[2] determine the PB.2 function.
N * |        |          |(EBI_nWRL_EN, EBI_EN, PB2_TM2, PB2_CPO0, PB2_T2EX, GPB_MFP2) value and function mapping is as
N * |        |          |following list.
N * |        |          |(0, 0, 0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 0, 0, 1) = UART0_nRTS function is selected.
N * |        |          |(0, 0, 0, 0, 1, 1) = TM2_EXT function is selected.
N * |        |          |(0, 0, 0, 1, 0, 1) = ACMP0_O function is selected.
N * |        |          |(0, 0, 1, 0, 0, 1) = TM2 function is selected.
N * |        |          |(1, 1, 0, 0, 0, 1) = nWRL(EBI) function is selected.     
N * |[5]     |PB3_TM3   |PB.2 Pin Alternative Function Selection 
N * |        |          |PB3_SC2CD (ALT_MFP1[14]), PB3_T3EX (ALT_MFP[27]) and GPB_MFP[3] determine the PB.3 function.
N * |        |          |(EBI_nWRH_EN, EBI_EN, PB3_TM3, PB3_SC2CD, PB3_T3EX, GPB_MFP3) value and function mapping is as
N * |        |          |following list.
N * |        |          |(0, 0, 0, 0, 0, 0) = GPIO function is selected.
N * |        |          |(0, 0, 0, 0, 0, 1) = UART0_nCTS function is selected.
N * |        |          |(0, 0, 0, 0, 1, 1) = TM3_EXT function is selected.
N * |        |          |(0, 0, 0, 1, 0, 1) = SC2_CD function is selected.
N * |        |          |(0, 0, 1, 0, 0, 1) = TM3 function is selected.
N * |        |          |(1, 1, 0, 0, 0, 1) = nWRH(EBI) function is selected.
N * @var GCR_T::IRCTRIMCTL
N * Offset: 0x80  IRC Trim Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1:0]   |TRIM_SEL  |Trim Frequency Selection
N * |        |          |This field indicates the target frequency of internal 22.1184 MHz high speed oscillator will
N * |        |          |trim to precise 22.1184MHz or 24MHz automatically.
N * |        |          |If no any target frequency is selected (TRIM_SEL is 00), the HIRC auto trim function is
N * |        |          |disabled.
N * |        |          |During auto trim operation, if clock error detected because of CLKERR_STOP_EN is set to 1 or
N * |        |          |trim retry limitation counts reached, this field will be cleared to 00 automatically.
N * |        |          |00 = HIRC auto trim function Disabled.
N * |        |          |01 = HIRC auto trim function Enabled and HIRC trimmed to 22.1184 MHz.
N * |        |          |10 = HIRC auto trim function Enabled and HIRC trimmed to 24 MHz.
N * |        |          |11 = Reserved.
N * |[5:4]   |TRIM_LOOP |Trim Calculation Loop
N * |        |          |This field defines that trim value calculation is based on how many 32.768 kHz clocks in.
N * |        |          |For example, if TRIM_LOOP is set as 00, auto trim circuit will calculate trim value based on the
N * |        |          |average frequency difference in 4 32.768 kHz clock.
N * |        |          |00 = Trim value calculation is based on average difference in 4 clocks.
N * |        |          |01 = Trim value calculation is based on average difference in 8 clocks.
N * |        |          |10 = Trim value calculation is based on average difference in 16 clocks.
N * |        |          |11 = Trim value calculation is based on average difference in 32 clocks.
N * |[7:6]   |TRIM_RETRY_CNT|Trim Value Update Limitation Count
N * |        |          |The field defines that how many times of HIRC trim value is updated by auto trim circuit before
N * |        |          |the HIRC frequency locked.
N * |        |          |Once the HIRC locked, the internal trim value update counter will be reset.
N * |        |          |If the trim value update counter reached this limitation value and frequency of HIRC still
N * |        |          |doesn't lock, the auto trim operation will be disabled and TRIM_SEL will be cleared to 00.
N * |        |          |00 = Trim retry count limitation is 64.
N * |        |          |01 = Trim retry count limitation is 128.
N * |        |          |10 = Trim retry count limitation is 256.
N * |        |          |11 = Trim retry count limitation is 512.
N * |[8]     |CLKERR_STOP_EN|Clock Error Stop Enable
N * |        |          |When this bit is set to 0, the trim operation is keep going if clock is inaccuracy.
N * |        |          |When this bit is set to 1, the trim operation is stopped if clock is inaccuracy.
N * @var GCR_T::IRCTRIMIEN
N * Offset: 0x84  IRC Trim Interrupt Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1]     |TRIM_FAIL_IEN|Trim Failure Interrupt Enable
N * |        |          |This bit controls if an interrupt will be triggered while HIRC trim value update limitation
N * |        |          |count reached and HIRC frequency still not locked on target frequency set by TRIM_SEL
N * |        |          |(IRCTRIMCTL[1:0]).
N * |        |          |If this bit is high and TRIM_FAIL_INT (IRCTRIMINT[1]) is set during auto trim operation.
N * |        |          |An interrupt will be triggered to notify that HIRC trim value update limitation count was
N * |        |          |reached.
N * |        |          |0 = TRIM_FAIL_INT (IRCTRIMINT[1]) status to trigger an interrupt to CPU Disabled.
N * |        |          |1 = TRIM_FAIL_INT (IRCTRIMINT[1]) status to trigger an interrupt to CPU Enabled.
N * |[2]     |CLKERR_IEN|Clock Error Interrupt Enable
N * |        |          |This bit controls if CPU would get an interrupt while clock is inaccuracy during auto trim
N * |        |          |operation.
N * |        |          |If this bit is set to1, and CLKERR_INT (IRCTRIMINT[2]) is set during auto trim operation.
N * |        |          |An interrupt will be triggered to notify the clock frequency is inaccuracy.
N * |        |          |0 = CLKERR_INT (IRCTRIMINT[2]) status to trigger an interrupt to CPU Disabled.
N * |        |          |1 = CLKERR_INT (IRCTRIMINT[2]) status to trigger an interrupt to CPU Enabled.
N * @var GCR_T::IRCTRIMINT
N * Offset: 0x88  IRC Trim Interrupt Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |FREQ_LOCK |HIRC Frequency Lock Status
N * |        |          |This bit indicates the internal 22.1184 MHz high speed oscillator frequency is locked.
N * |        |          |This is a status bit and doesn't trigger any interrupt.
N * |[1]     |TRIM_FAIL_INT|Trim Failure Interrupt Status
N * |        |          |This bit indicates that internal 22.1184 MHz high speed oscillator trim value update limitation
N * |        |          |count reached and the internal 22.1184 MHz high speed oscillator clock frequency still doesn't
N * |        |          |be locked.
N * |        |          |Once this bit is set, the auto trim operation stopped and TRIM_SEL (IRCTRIMCTL [1:0]) will be
N * |        |          |cleared to 00 by hardware automatically.
N * |        |          |If this bit is set and TRIM_FAIL_IEN (IRCTRIMIEN[1]) is high, an interrupt will be triggered to
N * |        |          |notify that HIRC trim value update limitation count was reached.
N * |        |          |Write 1 to clear this to 0.
N * |        |          |0 = Trim value update limitation count did not reach.
N * |        |          |1 = Trim value update limitation count reached and internal 22.1184 MHz high speed oscillator
N * |        |          |frequency was still not locked.
N * |[2]     |CLKERR_INT|Clock Error Interrupt Status
N * |        |          |When the frequency of external 32.768 kHz low speed crystal or internal 22.1184 MHz high speed
N * |        |          |oscillator is shift larger to unreasonable value, this bit will be set and to be an indicate
N * |        |          |that clock frequency is inaccuracy
N * |        |          |Once this bit is set to 1, the auto trim operation stopped and TRIM_SEL (IRCTRIMCTL [1:0]) will
N * |        |          |be cleared to 00 by hardware automatically if CLKERR_STOP_EN (IRCTRIMCTL [8]) is set to 1.
N * |        |          |If this bit is set and CLKERR_IEN (IRCTRIMIEN [2]) is high, an interrupt will be triggered to
N * |        |          |notify the clock frequency is inaccuracy.
N * |        |          |Write 1 to clear this to 0.
N * |        |          |0 = Clock frequency is accurate.
N * |        |          |1 = Clock frequency is inaccurate.
N * @var GCR_T::REGWRPROT
N * Offset: 0x100  Register Write Protection Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |REGPROTDIS|Register Write-Protection Disable Index (Read Only)
N * |        |          |0 = Write-protection is enabled for writing protected registers.
N * |        |          |Any write to the protected register is ignored.
N * |        |          |1 = Write-protection is disabled for writing protected registers.
N * |        |          |The Protected registers are:
N * |        |          |IPRSTC1: address 0x5000_0008
N * |        |          |BODCR: address 0x5000_0018
N * |        |          |PORCR: address 0x5000_0024
N * |        |          |PWRCON: address 0x5000_0200 (bit[6] is not protected for power wake-up interrupt clear)
N * |        |          |APBCLK bit[0]: address 0x5000_0208 (bit[0] is watchdog clock enable)
N * |        |          |CLKSEL0: address 0x5000_0210 (for HCLK and CPU STCLK clock source selection)
N * |        |          |CLKSEL1 bit[1:0]: address 0x5000_0214 (for watchdog clock source selection)
N * |        |          |NMI_SEL bit[8]: address 0x5000_0380 (for NMI_EN clock source selection)
N * |        |          |ISPCON: address 0x5000_C000 (Flash ISP Control register)
N * |        |          |ISPTRG: address 0x5000_C010 (ISP Trigger Control register)
N * |        |          |WTCR: address 0x4000_4000
N * |        |          |FATCON: address 0x5000_C018
N * |        |          |Note: The bits which are write-protected will be noted as" (Write Protect)" beside the
N * |        |          |description.
N * |[7:0]   |REGWRPROT |Register Write-Protection Code (Write Only)
N * |        |          |Some registers have write-protection function.
N * |        |          |Writing these registers have to disable the protected function by writing the sequence value
N * |        |          |"59h", "16h", "88h" to this field.
N * |        |          |After this sequence is completed, the REGPROTDIS bit will be set to 1 and write-protection
N * |        |          |registers can be normal write.
N */
N
N    __I  uint32_t PDID;          /* Offset: 0x00  Part Device Identification Number Register                         */
X    volatile const  uint32_t PDID;           
N    __IO uint32_t RSTSRC;        /* Offset: 0x04  System Reset Source Register                                       */
X    volatile uint32_t RSTSRC;         
N    __IO uint32_t IPRSTC1;       /* Offset: 0x08  IP Reset Control Register 1                                        */
X    volatile uint32_t IPRSTC1;        
N    __IO uint32_t IPRSTC2;       /* Offset: 0x0C  IP Reset Control Register 2                                        */
X    volatile uint32_t IPRSTC2;        
N    __IO uint32_t IPRSTC3;       /* Offset: 0x10  IP Reset Control Register 3                                        */
X    volatile uint32_t IPRSTC3;        
N    __I  uint32_t RESERVE0;     
X    volatile const  uint32_t RESERVE0;     
N    __IO uint32_t BODCR;         /* Offset: 0x18  Brown-out Detector Control Register                                */
X    volatile uint32_t BODCR;          
N    __IO uint32_t TEMPCR;        /* Offset: 0x1C  Temperature Sensor Control Register                                */
X    volatile uint32_t TEMPCR;         
N    __I  uint32_t RESERVE1;     
X    volatile const  uint32_t RESERVE1;     
N    __IO uint32_t PORCR;         /* Offset: 0x24  Power-on-Reset Controller Register                                 */
X    volatile uint32_t PORCR;          
N    __I  uint32_t RESERVE2[2];  
X    volatile const  uint32_t RESERVE2[2];  
N    __IO uint32_t GPA_MFP;       /* Offset: 0x30  GPIOA Multiple Function and Input Type Control Register            */
X    volatile uint32_t GPA_MFP;        
N    __IO uint32_t GPB_MFP;       /* Offset: 0x34  GPIOB Multiple Function and Input Type Control Register            */
X    volatile uint32_t GPB_MFP;        
N    __IO uint32_t GPC_MFP;       /* Offset: 0x38  GPIOC Multiple Function and Input Type Control Register            */
X    volatile uint32_t GPC_MFP;        
N    __IO uint32_t GPD_MFP;       /* Offset: 0x3C  GPIOD Multiple Function and Input Type Control Register            */
X    volatile uint32_t GPD_MFP;        
N    __IO uint32_t GPE_MFP;       /* Offset: 0x40  GPIOE Multiple Function and Input Type Control Register            */
X    volatile uint32_t GPE_MFP;        
N    __IO uint32_t GPF_MFP;       /* Offset: 0x44  GPIOF Multiple Function and Input Type Control Register            */
X    volatile uint32_t GPF_MFP;        
N    __I  uint32_t RESERVE3[2];  
X    volatile const  uint32_t RESERVE3[2];  
N    __IO uint32_t ALT_MFP;       /* Offset: 0x50  Alternative Multiple Function Pin Control Register                 */
X    volatile uint32_t ALT_MFP;        
N    __I  uint32_t RESERVE4;     
X    volatile const  uint32_t RESERVE4;     
N    __IO uint32_t ALT_MFP1;      /* Offset: 0x58  Alternative Multiple Function Pin Control Register 1               */
X    volatile uint32_t ALT_MFP1;       
N    __IO uint32_t ALT_MFP2;      /* Offset: 0x5C  Alternative Multiple Function Pin Control Register 2               */
X    volatile uint32_t ALT_MFP2;       
N    __I  uint32_t RESERVE5[8];  
X    volatile const  uint32_t RESERVE5[8];  
N    __IO uint32_t IRCTRIMCTL;    /* Offset: 0x80  IRC Trim Control Register                                          */
X    volatile uint32_t IRCTRIMCTL;     
N    __IO uint32_t IRCTRIMIEN;    /* Offset: 0x84  IRC Trim Interrupt Enable Register                                 */
X    volatile uint32_t IRCTRIMIEN;     
N    __IO uint32_t IRCTRIMINT;    /* Offset: 0x88  IRC Trim Interrupt Status Register                                 */
X    volatile uint32_t IRCTRIMINT;     
N    __I  uint32_t RESERVE6[29]; 
X    volatile const  uint32_t RESERVE6[29]; 
N    __IO uint32_t REGWRPROT;     /* Offset: 0x100  Register Write Protection Register                                */
X    volatile uint32_t REGWRPROT;      
N
N} GCR_T;
N
N
N/**
N    @addtogroup SYS_CONST SYS Bit Field Definition
N    Constant Definitions for SYS Controller
N@{ */
N
N
N/* GCR RSTSRC Bit Field Definitions */
N#define SYS_RSTSRC_RSTS_CPU_Pos                 7                                   /*!< GCR_T::RSTSRC: RSTS_CPU Position */
N#define SYS_RSTSRC_RSTS_CPU_Msk                 (1ul << SYS_RSTSRC_RSTS_CPU_Pos)    /*!< GCR_T::RSTSRC: RSTS_CPU Mask */
N
N#define SYS_RSTSRC_RSTS_SYS_Pos                 5                                   /*!< GCR_T::RSTSRC: RSTS_SYS Position */
N#define SYS_RSTSRC_RSTS_SYS_Msk                 (1ul << SYS_RSTSRC_RSTS_SYS_Pos)    /*!< GCR_T::RSTSRC: RSTS_SYS Mask */
N
N#define SYS_RSTSRC_RSTS_BOD_Pos                 4                                   /*!< GCR_T::RSTSRC: RSTS_BOD Position */
N#define SYS_RSTSRC_RSTS_BOD_Msk                 (1ul << SYS_RSTSRC_RSTS_BOD_Pos)    /*!< GCR_T::RSTSRC: RSTS_BOD Mask */
N
N#define SYS_RSTSRC_RSTS_LVR_Pos                 3                                   /*!< GCR_T::RSTSRC: RSTS_LVR Position */
N#define SYS_RSTSRC_RSTS_LVR_Msk                 (1ul << SYS_RSTSRC_RSTS_LVR_Pos)    /*!< GCR_T::RSTSRC: RSTS_LVR Mask */
N
N#define SYS_RSTSRC_RSTS_WDT_Pos                 2                                   /*!< GCR_T::RSTSRC: RSTS_WDT Position */
N#define SYS_RSTSRC_RSTS_WDT_Msk                 (1ul << SYS_RSTSRC_RSTS_WDT_Pos)    /*!< GCR_T::RSTSRC: RSTS_WDT Mask */
N
N#define SYS_RSTSRC_RSTS_RESET_Pos               1                                   /*!< GCR_T::RSTSRC: RSTS_RESET Position */
N#define SYS_RSTSRC_RSTS_RESET_Msk               (1ul << SYS_RSTSRC_RSTS_RESET_Pos)  /*!< GCR_T::RSTSRC: RSTS_RESET Mask */
N
N#define SYS_RSTSRC_RSTS_POR_Pos                 0                                   /*!< GCR_T::RSTSRC: RSTS_POR Position */
N#define SYS_RSTSRC_RSTS_POR_Msk                 (1ul << SYS_RSTSRC_RSTS_POR_Pos)    /*!< GCR_T::RSTSRC: RSTS_POR Mask */
N
N/* GCR IPRSTC1 Bit Field Definitions */
N#define SYS_IPRSTC1_EBI_RST_Pos                 3                                   /*!< GCR_T::IPRSTC1: EBI_RST Position */
N#define SYS_IPRSTC1_EBI_RST_Msk                 (1ul << SYS_IPRSTC1_EBI_RST_Pos)    /*!< GCR_T::IPRSTC1: EBI_RST Mask */
N
N#define SYS_IPRSTC1_PDMA_RST_Pos                2                                   /*!< GCR_T::IPRSTC1: PDMA_RST Position */
N#define SYS_IPRSTC1_PDMA_RST_Msk                (1ul << SYS_IPRSTC1_PDMA_RST_Pos)   /*!< GCR_T::IPRSTC1: PDMA_RST Mask */
N
N#define SYS_IPRSTC1_CPU_RST_Pos                 1                                   /*!< GCR_T::IPRSTC1: CPU_RST Position */
N#define SYS_IPRSTC1_CPU_RST_Msk                 (1ul << SYS_IPRSTC1_CPU_RST_Pos)    /*!< GCR_T::IPRSTC1: CPU_RST Mask */
N
N#define SYS_IPRSTC1_CHIP_RST_Pos                0                                   /*!< GCR_T::IPRSTC1: CHIP_RST Position */
N#define SYS_IPRSTC1_CHIP_RST_Msk                (1ul << SYS_IPRSTC1_CHIP_RST_Pos)   /*!< GCR_T::IPRSTC1: CHIP_RST Mask */
N
N/* GCR IPRSTC2 Bit Field Definitions */
N#define SYS_IPRSTC2_I2S_RST_Pos                 29                                  /*!< GCR_T::IPRSTC2: I2S_RST Position */
N#define SYS_IPRSTC2_I2S_RST_Msk                 (1ul << SYS_IPRSTC2_I2S_RST_Pos)    /*!< GCR_T::IPRSTC2: I2S_RST Mask */
N
N#define SYS_IPRSTC2_ADC_RST_Pos                 28                                  /*!< GCR_T::IPRSTC2: ADC_RST Position */
N#define SYS_IPRSTC2_ADC_RST_Msk                 (1ul << SYS_IPRSTC2_ADC_RST_Pos)    /*!< GCR_T::IPRSTC2: ADC_RST Mask */
N
N#define SYS_IPRSTC2_USBD_RST_Pos                27                                  /*!< GCR_T::IPRSTC2: USBD_RST Position */
N#define SYS_IPRSTC2_USBD_RST_Msk                (1ul << SYS_IPRSTC2_USBD_RST_Pos)   /*!< GCR_T::IPRSTC2: USBD_RST Mask */
N
N#define SYS_IPRSTC2_CAN1_RST_Pos                25                                  /*!< GCR_T::IPRSTC2: CAN1_RST Position */
N#define SYS_IPRSTC2_CAN1_RST_Msk                (1ul << SYS_IPRSTC2_CAN1_RST_Pos)   /*!< GCR_T::IPRSTC2: CAN1_RST Mask */
N
N#define SYS_IPRSTC2_CAN0_RST_Pos                24                                  /*!< GCR_T::IPRSTC2: CAN0_RST Position */
N#define SYS_IPRSTC2_CAN0_RST_Msk                (1ul << SYS_IPRSTC2_CAN0_RST_Pos)   /*!< GCR_T::IPRSTC2: CAN0_RST Mask */
N
N#define SYS_IPRSTC2_PS2_RST_Pos                 23                                  /*!< GCR_T::IPRSTC2: PS2_RST Position */
N#define SYS_IPRSTC2_PS2_RST_Msk                 (1ul << SYS_IPRSTC2_PS2_RST_Pos)    /*!< GCR_T::IPRSTC2: PS2_RST Mask */
N
N#define SYS_IPRSTC2_ACMP_RST_Pos                22                                  /*!< GCR_T::IPRSTC2: ACMP_RST Position */
N#define SYS_IPRSTC2_ACMP_RST_Msk                (1ul << SYS_IPRSTC2_ACMP_RST_Pos)   /*!< GCR_T::IPRSTC2: ACMP_RST Mask */
N
N#define SYS_IPRSTC2_PWM47_RST_Pos               21                                  /*!< GCR_T::IPRSTC2: PWM47_RST Position */
N#define SYS_IPRSTC2_PWM47_RST_Msk               (1ul << SYS_IPRSTC2_PWM47_RST_Pos)  /*!< GCR_T::IPRSTC2: PWM47_RST Mask */
N
N#define SYS_IPRSTC2_PWM03_RST_Pos               20                                  /*!< GCR_T::IPRSTC2: PWM03_RST Position */
N#define SYS_IPRSTC2_PWM03_RST_Msk               (1ul << SYS_IPRSTC2_PWM03_RST_Pos)  /*!< GCR_T::IPRSTC2: PWM03_RST Mask */
N
N#define SYS_IPRSTC2_UART2_RST_Pos               18                                  /*!< GCR_T::IPRSTC2: UART2_RST Position */
N#define SYS_IPRSTC2_UART2_RST_Msk               (1ul << SYS_IPRSTC2_UART2_RST_Pos)  /*!< GCR_T::IPRSTC2: UART2_RST Mask */
N
N#define SYS_IPRSTC2_UART1_RST_Pos               17                                  /*!< GCR_T::IPRSTC2: UART1_RST Position */
N#define SYS_IPRSTC2_UART1_RST_Msk               (1ul << SYS_IPRSTC2_UART1_RST_Pos)  /*!< GCR_T::IPRSTC2: UART1_RST Mask */
N
N#define SYS_IPRSTC2_UART0_RST_Pos               16                                  /*!< GCR_T::IPRSTC2: UART0_RST Position */
N#define SYS_IPRSTC2_UART0_RST_Msk               (1ul << SYS_IPRSTC2_UART0_RST_Pos)  /*!< GCR_T::IPRSTC2: UART0_RST Mask */
N
N#define SYS_IPRSTC2_SPI3_RST_Pos                15                                  /*!< GCR_T::IPRSTC2: SPI3_RST Position */
N#define SYS_IPRSTC2_SPI3_RST_Msk                (1ul << SYS_IPRSTC2_SPI3_RST_Pos)   /*!< GCR_T::IPRSTC2: SPI3_RST Mask */
N
N#define SYS_IPRSTC2_SPI2_RST_Pos                14                                  /*!< GCR_T::IPRSTC2: SPI2_RST Position */
N#define SYS_IPRSTC2_SPI2_RST_Msk                (1ul << SYS_IPRSTC2_SPI2_RST_Pos)   /*!< GCR_T::IPRSTC2: SPI2_RST Mask */
N
N#define SYS_IPRSTC2_SPI1_RST_Pos                13                                  /*!< GCR_T::IPRSTC2: SPI1_RST Position */
N#define SYS_IPRSTC2_SPI1_RST_Msk                (1ul << SYS_IPRSTC2_SPI1_RST_Pos)   /*!< GCR_T::IPRSTC2: SPI1_RST Mask */
N
N#define SYS_IPRSTC2_SPI0_RST_Pos                12                                  /*!< GCR_T::IPRSTC2: SPI0_RST Position */
N#define SYS_IPRSTC2_SPI0_RST_Msk                (1ul << SYS_IPRSTC2_SPI0_RST_Pos)   /*!< GCR_T::IPRSTC2: SPI0_RST Mask */
N
N#define SYS_IPRSTC2_I2C1_RST_Pos                9                                   /*!< GCR_T::IPRSTC2: I2C1_RST Position */
N#define SYS_IPRSTC2_I2C1_RST_Msk                (1ul << SYS_IPRSTC2_I2C1_RST_Pos)   /*!< GCR_T::IPRSTC2: I2C1_RST Mask */
N
N#define SYS_IPRSTC2_I2C0_RST_Pos                8                                   /*!< GCR_T::IPRSTC2: I2C0_RST Position */
N#define SYS_IPRSTC2_I2C0_RST_Msk                (1ul << SYS_IPRSTC2_I2C0_RST_Pos)   /*!< GCR_T::IPRSTC2: I2C0_RST Mask */
N
N#define SYS_IPRSTC2_TMR3_RST_Pos                5                                   /*!< GCR_T::IPRSTC2: TMR3_RST Position */
N#define SYS_IPRSTC2_TMR3_RST_Msk                (1ul << SYS_IPRSTC2_TMR3_RST_Pos)   /*!< GCR_T::IPRSTC2: TMR3_RST Mask */
N
N#define SYS_IPRSTC2_TMR2_RST_Pos                4                                   /*!< GCR_T::IPRSTC2: TMR2_RST Position */
N#define SYS_IPRSTC2_TMR2_RST_Msk                (1ul << SYS_IPRSTC2_TMR2_RST_Pos)   /*!< GCR_T::IPRSTC2: TMR2_RST Mask */
N
N#define SYS_IPRSTC2_TMR1_RST_Pos                3                                   /*!< GCR_T::IPRSTC2: TMR1_RST Position */
N#define SYS_IPRSTC2_TMR1_RST_Msk                (1ul << SYS_IPRSTC2_TMR1_RST_Pos)   /*!< GCR_T::IPRSTC2: TMR1_RST Mask */
N
N#define SYS_IPRSTC2_TMR0_RST_Pos                2                                   /*!< GCR_T::IPRSTC2: TMR0_RST Position */
N#define SYS_IPRSTC2_TMR0_RST_Msk                (1ul << SYS_IPRSTC2_TMR0_RST_Pos)   /*!< GCR_T::IPRSTC2: TMR0_RST Mask */
N
N#define SYS_IPRSTC2_GPIO_RST_Pos                1                                   /*!< GCR_T::IPRSTC2: GPIO_RST Position */
N#define SYS_IPRSTC2_GPIO_RST_Msk                (1ul << SYS_IPRSTC2_GPIO_RST_Pos)   /*!< GCR_T::IPRSTC2: GPIO_RST Mask */
N
N/* GCR IPRSTC3 Bit Field Definitions */
N#define SYS_IPRSTC3_SC2_RST_Pos                 2                                   /*!< GCR_T::IPRSTC3: SC2_RST Position */
N#define SYS_IPRSTC3_SC2_RST_Msk                 (1ul << SYS_IPRSTC3_SC2_RST_Pos)    /*!< GCR_T::IPRSTC3: SC2_RST Mask */
N
N#define SYS_IPRSTC3_SC1_RST_Pos                 1                                   /*!< GCR_T::IPRSTC3: SC1_RST Position */
N#define SYS_IPRSTC3_SC1_RST_Msk                 (1ul << SYS_IPRSTC3_SC1_RST_Pos)    /*!< GCR_T::IPRSTC3: SC1_RST Mask */
N
N#define SYS_IPRSTC3_SC0_RST_Pos                 0                                   /*!< GCR_T::IPRSTC3: SC0_RST Position */
N#define SYS_IPRSTC3_SC0_RST_Msk                 (1ul << SYS_IPRSTC3_SC0_RST_Pos)    /*!< GCR_T::IPRSTC3: SC0_RST Mask */
N
N/* GCR BODCR Bit Field Definitions */
N#define SYS_BODCR_LVR_EN_Pos                    7                                   /*!< GCR_T::BODCR: LVR_EN Position */
N#define SYS_BODCR_LVR_EN_Msk                    (1ul << SYS_BODCR_LVR_EN_Pos)       /*!< GCR_T::BODCR: LVR_EN Mask */
N
N#define SYS_BODCR_BOD_OUT_Pos                   6                                   /*!< GCR_T::BODCR: BOD_OUT Position */
N#define SYS_BODCR_BOD_OUT_Msk                   (1ul << SYS_BODCR_BOD_OUT_Pos)      /*!< GCR_T::BODCR: BOD_OUT Mask */
N
N#define SYS_BODCR_BOD_LPM_Pos                   5                                   /*!< GCR_T::BODCR: BOD_LPM Position */
N#define SYS_BODCR_BOD_LPM_Msk                   (1ul << SYS_BODCR_BOD_LPM_Pos)      /*!< GCR_T::BODCR: BOD_LPM Mask */
N
N#define SYS_BODCR_BOD_INTF_Pos                  4                                   /*!< GCR_T::BODCR: BOD_INTF Position */
N#define SYS_BODCR_BOD_INTF_Msk                  (1ul << SYS_BODCR_BOD_INTF_Pos)     /*!< GCR_T::BODCR: BOD_INTF Mask */
N
N#define SYS_BODCR_BOD_RSTEN_Pos                 3                                   /*!< GCR_T::BODCR: BOD_RSTEN Position */
N#define SYS_BODCR_BOD_RSTEN_Msk                 (1ul << SYS_BODCR_BOD_RSTEN_Pos)    /*!< GCR_T::BODCR: BOD_RSTEN Mask */
N
N#define SYS_BODCR_BOD_VL_Pos                    1                                   /*!< GCR_T::BODCR: BOD_VL Position */
N#define SYS_BODCR_BOD_VL_Msk                    (3ul << SYS_BODCR_BOD_VL_Pos)       /*!< GCR_T::BODCR: BOD_VL Mask */
N
N#define SYS_BODCR_BOD_EN_Pos                    0                                   /*!< GCR_T::BODCR: BOD_EN Position */
N#define SYS_BODCR_BOD_EN_Msk                    (1ul << SYS_BODCR_BOD_EN_Pos)       /*!< GCR_T::BODCR: BOD_EN Mask */
N
N/* GCR TEMPCR Bit Field Definitions */
N#define SYS_TEMPCR_VTEMP_EN_Pos                 0                                   /*!< GCR_T::TEMPCR: VTEMP_EN Position */
N#define SYS_TEMPCR_VTEMP_EN_Msk                 (1ul << SYS_TEMPCR_VTEMP_EN_Pos)    /*!< GCR_T::TEMPCR: VTEMP_EN Mask */
N
N/* GCR PORCR Bit Field Definitions */
N#define SYS_PORCR_POR_DIS_CODE_Pos              0                                           /*!< GCR_T::PORCR: POR_DIS_CODE Position */
N#define SYS_PORCR_POR_DIS_CODE_Msk              (0xFFFFul << SYS_PORCR_POR_DIS_CODE_Pos)    /*!< GCR_T::PORCR: POR_DIS_CODE Mask */
N
N/* GCR GPAMFP Bit Field Definitions */
N#define SYS_GPA_MFP_GPA_TYPE_Pos                 16                                         /*!< GCR_T::GPA_MFP: GPA_TYPE Position */
N#define SYS_GPA_MFP_GPA_TYPE_Msk                 (0xFFFFul << SYS_GPA_MFP_GPA_TYPE_Pos)     /*!< GCR_T::GPA_MFP: GPA_TYPE Mask */
N
N#define SYS_GPA_MFP_GPA_MFP_Pos                  0                                          /*!< GCR_T::GPA_MFP: GPA_MFP Position */
N#define SYS_GPA_MFP_GPA_MFP_Msk                  (0xFFFFul << SYS_GPA_MFP_GPA_MFP_Pos)      /*!< GCR_T::GPA_MFP: GPA_MFP Mask */
N
N
N/* GCR GPBMFP Bit Field Definitions */
N#define SYS_GPB_MFP_GPB_TYPE_Pos                 16                                         /*!< GCR_T::GPB_MFP: GPB_TYPE Position */
N#define SYS_GPB_MFP_GPB_TYPE_Msk                 (0xFFFFul << SYS_GPB_MFP_GPB_TYPE_Pos)     /*!< GCR_T::GPB_MFP: GPB_TYPE Mask */
N
N#define SYS_GPB_MFP_GPB_MFP_Pos                  0                                          /*!< GCR_T::GPB_MFP: GPB_MFP Position */
N#define SYS_GPB_MFP_GPB_MFP_Msk                  (0xFFFFul << SYS_GPB_MFP_GPB_MFP_Pos)      /*!< GCR_T::GPB_MFP: GPB_MFP Mask */
N
N/* GCR GPCMFP Bit Field Definitions */
N#define SYS_GPC_MFP_GPC_TYPE_Pos                 16                                         /*!< GCR_T::GPC_MFP: GPC_TYPE Position */
N#define SYS_GPC_MFP_GPC_TYPE_Msk                 (0xFFFFul << SYS_GPC_MFP_GPC_TYPE_Pos)     /*!< GCR_T::GPC_MFP: GPC_TYPE Mask */
N
N#define SYS_GPC_MFP_GPC_MFP_Pos                  0                                          /*!< GCR_T::GPC_MFP: GPC_MFP Position */
N#define SYS_GPC_MFP_GPC_MFP_Msk                  (0xFFFFul << SYS_GPC_MFP_GPC_MFP_Pos)      /*!< GCR_T::GPC_MFP: GPC_MFP Mask */
N
N/* GCR GPDMFP Bit Field Definitions */
N#define SYS_GPD_MFP_GPD_TYPE_Pos                 16                                         /*!< GCR_T::GPD_MFP: GPD_TYPE Position */
N#define SYS_GPD_MFP_GPD_TYPE_Msk                 (0xFFFFul << SYS_GPD_MFP_GPD_TYPE_Pos)     /*!< GCR_T::GPD_MFP: GPD_TYPE Mask */
N
N#define SYS_GPD_MFP_GPD_MFP_Pos                  0                                          /*!< GCR_T::GPD_MFP: GPD_MFP Position */
N#define SYS_GPD_MFP_GPD_MFP_Msk                  (0xFFFFul << SYS_GPD_MFP_GPD_MFP_Pos)      /*!< GCR_T::GPD_MFP: GPD_MFP Mask */
N
N/* GCR GPEMFP Bit Field Definitions */
N#define SYS_GPE_MFP_GPE_TYPE_Pos                 16                                         /*!< GCR_T::GPE_MFP: GPE_TYPE Position */
N#define SYS_GPE_MFP_GPE_TYPE_Msk                 (0xFFFFul << SYS_GPE_MFP_GPE_TYPE_Pos)     /*!< GCR_T::GPE_MFP: GPE_TYPE Mask */
N
N#define SYS_GPE_MFP_GPE_MFP5_Pos                 5                                          /*!< GCR_T::GPE_MFP: GPE_MFP5 Position */
N#define SYS_GPE_MFP_GPE_MFP5_Msk                 (1ul << SYS_GPE_MFP_GPE_MFP5_Pos)          /*!< GCR_T::GPE_MFP: GPE_MFP5 Mask */
N
N#define SYS_GPE_MFP_GPE_MFP1_Pos                 1                                          /*!< GCR_T::GPE_MFP: GPE_MFP1 Position */
N#define SYS_GPE_MFP_GPE_MFP1_Msk                 (1ul << SYS_GPE_MFP_GPE_MFP1_Pos)          /*!< GCR_T::GPE_MFP: GPE_MFP1 Mask */
N
N#define SYS_GPE_MFP_GPE_MFP0_Pos                 0                                          /*!< GCR_T::GPE_MFP: GPE_MFP0 Position */
N#define SYS_GPE_MFP_GPE_MFP0_Msk                 (1ul << SYS_GPE_MFP_GPE_MFP0_Pos)          /*!< GCR_T::GPE_MFP: GPE_MFP0 Mask */
N
N/* GCR GPFMFP Bit Field Definitions */
N#define SYS_GPF_MFP_GPF_TYPE_Pos                 16                                         /*!< GCR_T::GPF_MFP: GPF_TYPE Position */
N#define SYS_GPF_MFP_GPF_TYPE_Msk                 (0xFul << SYS_GPF_MFP_GPF_TYPE_Pos)        /*!< GCR_T::GPF_MFP: GPF_TYPE Mask */
N
N#define SYS_GPF_MFP_GPF_MFP3_Pos                 3                                          /*!< GCR_T::GPF_MFP: GPF_MFP3 Position */
N#define SYS_GPF_MFP_GPF_MFP3_Msk                 (1ul << SYS_GPF_MFP_GPF_MFP3_Pos)          /*!< GCR_T::GPF_MFP: GPF_MFP3 Mask */
N
N#define SYS_GPF_MFP_GPF_MFP2_Pos                 2                                          /*!< GCR_T::GPF_MFP: GPF_MFP2 Position */
N#define SYS_GPF_MFP_GPF_MFP2_Msk                 (1ul << SYS_GPF_MFP_GPF_MFP2_Pos)          /*!< GCR_T::GPF_MFP: GPF_MFP2 Mask */
N
N#define SYS_GPF_MFP_GPF_MFP1_Pos                 1                                          /*!< GCR_T::GPF_MFP: GPF_MFP1 Position */
N#define SYS_GPF_MFP_GPF_MFP1_Msk                 (1ul << SYS_GPF_MFP_GPF_MFP1_Pos)          /*!< GCR_T::GPF_MFP: GPF_MFP1 Mask */
N
N#define SYS_GPF_MFP_GPF_MFP0_Pos                 0                                          /*!< GCR_T::GPF_MFP: GPF_MFP0 Position */
N#define SYS_GPF_MFP_GPF_MFP0_Msk                 (1ul << SYS_GPF_MFP_GPF_MFP0_Pos)          /*!< GCR_T::GPF_MFP: GPF_MFP0 Mask */
N
N/* GCR ALTMFP Bit Field Definitions */
N#define SYS_ALT_MFP_PB2_CPO0_Pos                 30                                         /*!< GCR_T::ALT_MFP: PB2_CPO0 Position */
N#define SYS_ALT_MFP_PB2_CPO0_Msk                 (1ul << SYS_ALT_MFP_PB2_CPO0_Pos)          /*!< GCR_T::ALT_MFP: PB2_CPO0 Mask */
N
N#define SYS_ALT_MFP_PB8_CLKO_Pos                 29                                         /*!< GCR_T::ALT_MFP: PB8_CLKO Position */
N#define SYS_ALT_MFP_PB8_CLKO_Msk                 (1ul << SYS_ALT_MFP_PB8_CLKO_Pos)          /*!< GCR_T::ALT_MFP: PB8_CLKO Mask */
N
N#define SYS_ALT_MFP_PA10_11_CAN1_Pos             28                                         /*!< GCR_T::ALT_MFP: PA10_11_CAN1 Position */
N#define SYS_ALT_MFP_PA10_11_CAN1_Msk             (1ul << SYS_ALT_MFP_PA10_11_CAN1_Pos)      /*!< GCR_T::ALT_MFP: PA10_11_CAN1 Mask */
N
N#define SYS_ALT_MFP_PB3_T3EX_Pos                 27                                         /*!< GCR_T::ALT_MFP: PB3_T3EX Position */
N#define SYS_ALT_MFP_PB3_T3EX_Msk                 (1ul << SYS_ALT_MFP_PB3_T3EX_Pos)          /*!< GCR_T::ALT_MFP: PB3_T3EX Mask */
N
N#define SYS_ALT_MFP_PB2_T2EX_Pos                 26                                         /*!< GCR_T::ALT_MFP: PB2_T2EX Position */
N#define SYS_ALT_MFP_PB2_T2EX_Msk                 (1ul << SYS_ALT_MFP_PB2_T2EX_Pos)          /*!< GCR_T::ALT_MFP: PB3_T3EX Mask */
N
N#define SYS_ALT_MFP_PE5_T1EX_Pos                 25                                         /*!< GCR_T::ALT_MFP: PE5_T1EX Position */
N#define SYS_ALT_MFP_PE5_T1EX_Msk                 (1ul << SYS_ALT_MFP_PE5_T1EX_Pos)          /*!< GCR_T::ALT_MFP: PE5_T1EX Mask */
N
N#define SYS_ALT_MFP_PB15_T0EX_Pos                24                                         /*!< GCR_T::ALT_MFP: PB15_T0EX Position */
N#define SYS_ALT_MFP_PB15_T0EX_Msk                (1ul << SYS_ALT_MFP_PB15_T0EX_Pos)         /*!< GCR_T::ALT_MFP: PB15_T0EX Mask */
N
N#define SYS_ALT_MFP_EBI_HB_EN_Pos                16                                         /*!< GCR_T::ALT_MFP: EBI_HB_EN Position */
N#define SYS_ALT_MFP_EBI_HB_EN_Msk                (0xFFul << SYS_ALT_MFP_EBI_HB_EN_Pos)      /*!< GCR_T::ALT_MFP: EBI_HB_EN Mask */
N
N#define SYS_ALT_MFP_EBI_nWRH_EN_Pos              14                                         /*!< GCR_T::ALT_MFP: EBI_nWRH_EN Position */
N#define SYS_ALT_MFP_EBI_nWRH_EN_Msk              (1ul << SYS_ALT_MFP_EBI_nWRH_EN_Pos)       /*!< GCR_T::ALT_MFP: EBI_nWRH_EN Mask */
N
N#define SYS_ALT_MFP_EBI_nWRL_EN_Pos              13                                         /*!< GCR_T::ALT_MFP: EBI_nWRL_EN Position */
N#define SYS_ALT_MFP_EBI_nWRL_EN_Msk              (1ul << SYS_ALT_MFP_EBI_nWRL_EN_Pos)       /*!< GCR_T::ALT_MFP: EBI_nWRL_EN Mask */
N
N#define SYS_ALT_MFP_EBI_MCLK_EN_Pos              12                                         /*!< GCR_T::ALT_MFP: EBI_MCLK_EN Position */
N#define SYS_ALT_MFP_EBI_MCLK_EN_Msk              (1ul << SYS_ALT_MFP_EBI_MCLK_EN_Pos)       /*!< GCR_T::ALT_MFP: EBI_MCLK_EN Mask */
N
N#define SYS_ALT_MFP_EBI_EN_Pos                   11                                         /*!< GCR_T::ALT_MFP: EBI_EN Position */
N#define SYS_ALT_MFP_EBI_EN_Msk                   (1ul << SYS_ALT_MFP_EBI_EN_Pos)            /*!< GCR_T::ALT_MFP: EBI_EN Mask */
N
N#define SYS_ALT_MFP_PA15_I2SMCLK_Pos             9                                          /*!< GCR_T::ALT_MFP: PA15_I2SMCLK Position */
N#define SYS_ALT_MFP_PA15_I2SMCLK_Msk             (1ul << SYS_ALT_MFP_PA15_I2SMCLK_Pos)      /*!< GCR_T::ALT_MFP: PA15_I2SMCLK Mask */
N
N#define SYS_ALT_MFP_PC3_I2SDO_Pos                8                                          /*!< GCR_T::ALT_MFP: PC3_I2SDO Position */
N#define SYS_ALT_MFP_PC3_I2SDO_Msk                (1ul << SYS_ALT_MFP_PC3_I2SDO_Pos)         /*!< GCR_T::ALT_MFP: PC3_I2SDO Mask */
N
N#define SYS_ALT_MFP_PC2_I2SDI_Pos                7                                          /*!< GCR_T::ALT_MFP: PC2_I2SDI Position */
N#define SYS_ALT_MFP_PC2_I2SDI_Msk                (1ul << SYS_ALT_MFP_PC2_I2SDI_Pos)         /*!< GCR_T::ALT_MFP: PC2_I2SDI Mask */
N
N#define SYS_ALT_MFP_PC1_I2SBCLK_Pos              6                                          /*!< GCR_T::ALT_MFP: PC1_I2SBCLK Position */
N#define SYS_ALT_MFP_PC1_I2SBCLK_Msk              (1ul << SYS_ALT_MFP_PC1_I2SBCLK_Pos)       /*!< GCR_T::ALT_MFP: PC1_I2SBCLK Mask */
N
N#define SYS_ALT_MFP_PC0_I2SLRCLK_Pos             5                                          /*!< GCR_T::ALT_MFP: PC0_I2SLRCLK Position */
N#define SYS_ALT_MFP_PC0_I2SLRCLK_Msk             (1ul << SYS_ALT_MFP_PC0_I2SLRCLK_Pos)      /*!< GCR_T::ALT_MFP: PC0_I2SLRCLK Mask */
N
N#define SYS_ALT_MFP_PB11_PWM4_Pos                4                                          /*!< GCR_T::ALT_MFP: PB11_PWM4 Position */
N#define SYS_ALT_MFP_PB11_PWM4_Msk                (1ul << SYS_ALT_MFP_PB11_PWM4_Pos)         /*!< GCR_T::ALT_MFP: PB11_PWM4 Mask */
N
N#define SYS_ALT_MFP_PB14_S31_Pos                 3                                          /*!< GCR_T::ALT_MFP: PB14_S31 Position */
N#define SYS_ALT_MFP_PB14_S31_Msk                 (1ul << SYS_ALT_MFP_PB14_S31_Pos)          /*!< GCR_T::ALT_MFP: PB14_S31 Mask */
N
N#define SYS_ALT_MFP_PA7_S21_Pos                  2                                          /*!< GCR_T::ALT_MFP: PA7_S21 Position */
N#define SYS_ALT_MFP_PA7_S21_Msk                  (1ul << SYS_ALT_MFP_PA7_S21_Pos)           /*!< GCR_T::ALT_MFP: PA7_S21 Mask */
N
N#define SYS_ALT_MFP_PB9_S11_Pos                  1                                          /*!< GCR_T::ALT_MFP: PB9_S11 Position */
N#define SYS_ALT_MFP_PB9_S11_Msk                  (1ul << SYS_ALT_MFP_PB9_S11_Pos)           /*!< GCR_T::ALT_MFP: PB9_S11 Mask */
N
N#define SYS_ALT_MFP_PB10_S01_Pos                 0                                          /*!< GCR_T::ALT_MFP: PB10_S01 Position */
N#define SYS_ALT_MFP_PB10_S01_Msk                 (1ul << SYS_ALT_MFP_PB10_S01_Pos)          /*!< GCR_T::ALT_MFP: PB10_S01 Mask */
N
N/* GCR ALTMFP1 Bit Field Definitions */
N#define SYS_ALT_MFP1_PB3_SC2CD_Pos              14                                          /*!< GCR_T::ALT_MFP1: PB3_SC2CD Position */
N#define SYS_ALT_MFP1_PB3_SC2CD_Msk              (1ul << SYS_ALT_MFP1_PB3_SC2CD_Pos)         /*!< GCR_T::ALT_MFP1: PB3_SC2CD Mask */
N
N#define SYS_ALT_MFP1_PA14_SC2RST_Pos            13                                          /*!< GCR_T::ALT_MFP1: PA14_SC2RST Position */
N#define SYS_ALT_MFP1_PA14_SC2RST_Msk            (1ul << SYS_ALT_MFP1_PA14_SC2RST_Pos)       /*!< GCR_T::ALT_MFP1: PA14_SC2RST Mask */
N
N#define SYS_ALT_MFP1_PA15_SC2PWR_Pos            12                                          /*!< GCR_T::ALT_MFP1: PA15_SC2PWR Position */
N#define SYS_ALT_MFP1_PA15_SC2PWR_Msk            (1ul << SYS_ALT_MFP1_PA15_SC2PWR_Pos)       /*!< GCR_T::ALT_MFP1: PA15_SC2PWR Mask */
N
N#define SYS_ALT_MFP1_PA12_SC2DAT_Pos            11                                          /*!< GCR_T::ALT_MFP1: PA12_SC2DAT Position */
N#define SYS_ALT_MFP1_PA12_SC2DAT_Msk            (1ul << SYS_ALT_MFP1_PA12_SC2DAT_Pos)        /*!< GCR_T::ALT_MFP1: PA12_SC2DAT Mask */
N
N#define SYS_ALT_MFP1_PA13_SC2CLK_Pos            10                                          /*!< GCR_T::ALT_MFP1: PA13_SC2CLK Position */
N#define SYS_ALT_MFP1_PA13_SC2CLK_Msk            (1ul << SYS_ALT_MFP1_PA13_SC2CLK_Pos)        /*!< GCR_T::ALT_MFP1: PA13_SC2CLK Mask */
N
N#define SYS_ALT_MFP1_PC7_SC1CD_Pos              9                                          /*!< GCR_T::ALT_MFP1: PC7_SC1CD Position */
N#define SYS_ALT_MFP1_PC7_SC1CD_Msk              (1ul << SYS_ALT_MFP1_PC7_SC1CD_Pos)        /*!< GCR_T::ALT_MFP1: PC7_SC1CD Mask */
N
N#define SYS_ALT_MFP1_PA5_SC1RST_Pos             8                                           /*!< GCR_T::ALT_MFP1: PA5_SC1RST Position */
N#define SYS_ALT_MFP1_PA5_SC1RST_Msk             (1ul << SYS_ALT_MFP1_PA5_SC1RST_Pos)        /*!< GCR_T::ALT_MFP1: PA5_SC1RST Mask */
N
N#define SYS_ALT_MFP1_PA4_SC1PWR_Pos             7                                           /*!< GCR_T::ALT_MFP1: PA4_SC1PWR Position */
N#define SYS_ALT_MFP1_PA4_SC1PWR_Msk             (1ul << SYS_ALT_MFP1_PA4_SC1PWR_Pos)        /*!< GCR_T::ALT_MFP1: PA4_SC1PWR Mask */
N
N#define SYS_ALT_MFP1_PA7_SC1DAT_Pos             6                                           /*!< GCR_T::ALT_MFP1: PA7_SC1DAT Position */
N#define SYS_ALT_MFP1_PA7_SC1DAT_Msk             (1ul << SYS_ALT_MFP1_PA7_SC1DAT_Pos)        /*!< GCR_T::ALT_MFP1: PA7_SC1DAT Mask */
N
N#define SYS_ALT_MFP1_PA6_SC1CLK_Pos             5                                           /*!< GCR_T::ALT_MFP1: PA6_SC1CLK Position */
N#define SYS_ALT_MFP1_PA6_SC1CLK_Msk             (1ul << SYS_ALT_MFP1_PA6_SC1CLK_Pos)        /*!< GCR_T::ALT_MFP1: PA6_SC1CLK Mask */
N
N#define SYS_ALT_MFP1_PC6_SC0CD_Pos              4                                           /*!< GCR_T::ALT_MFP1: PC6_SC0CD Position */
N#define SYS_ALT_MFP1_PC6_SC0CD_Msk              (1ul << SYS_ALT_MFP1_PC6_SC0CD_Pos)         /*!< GCR_T::ALT_MFP1: PC6_SC0CD Mask */
N
N#define SYS_ALT_MFP1_PA1_SC0RST_Pos             3                                           /*!< GCR_T::ALT_MFP1: PA1_SC0RST Position */
N#define SYS_ALT_MFP1_PA1_SC0RST_Msk             (1ul << SYS_ALT_MFP1_PA1_SC0RST_Pos)        /*!< GCR_T::ALT_MFP1: PA1_SC0RST Mask */
N
N#define SYS_ALT_MFP1_PA0_SC0PWR_Pos             2                                           /*!< GCR_T::ALT_MFP1: PA0_SC0PWR Position */
N#define SYS_ALT_MFP1_PA0_SC0PWR_Msk             (1ul << SYS_ALT_MFP1_PA0_SC0PWR_Pos)        /*!< GCR_T::ALT_MFP1: PA0_SC0PWR Mask */
N
N#define SYS_ALT_MFP1_PA3_SC0DAT_Pos             1                                           /*!< GCR_T::ALT_MFP1: PA3_SC0DAT Position */
N#define SYS_ALT_MFP1_PA3_SC0DAT_Msk             (1ul << SYS_ALT_MFP1_PA3_SC0DAT_Pos)        /*!< GCR_T::ALT_MFP1: PA3_SC0DAT Mask */
N
N#define SYS_ALT_MFP1_PA2_SC0CLK_Pos             0                                           /*!< GCR_T::ALT_MFP1: PA2_SC0CLK Position */
N#define SYS_ALT_MFP1_PA2_SC0CLK_Msk             (1ul << SYS_ALT_MFP1_PA2_SC0CLK_Pos)        /*!< GCR_T::ALT_MFP1: PA2_SC0CLK Mask */
N
N/* GCR ALTMFP2 Bit Field Definitions */
N#define SYS_ALT_MFP2_PB3_TM3_Pos                5                                           /*!< GCR_T::ALT_MFP2: PB3_TM3 Position */
N#define SYS_ALT_MFP2_PB3_TM3_Msk                (1ul << SYS_ALT_MFP2_PB3_TM3_Pos)           /*!< GCR_T::ALT_MFP2: PB3_TM3 Mask */
N
N#define SYS_ALT_MFP2_PB2_TM2_Pos                4                                           /*!< GCR_T::ALT_MFP2: PB2_TM2 Position */
N#define SYS_ALT_MFP2_PB2_TM2_Msk                (1ul << SYS_ALT_MFP2_PB2_TM2_Pos)           /*!< GCR_T::ALT_MFP2: PB2_TM2 Mask */
N
N#define SYS_ALT_MFP2_PE5_TM1_Pos                3                                           /*!< GCR_T::ALT_MFP2: PE5_TM1 Position */
N#define SYS_ALT_MFP2_PE5_TM1_Msk                (1ul << SYS_ALT_MFP2_PE5_TM1_Pos)           /*!< GCR_T::ALT_MFP2: PE5_TM1 Mask */
N
N#define SYS_ALT_MFP2_PB15_TM0_Pos               2                                           /*!< GCR_T::ALT_MFP2: PB15_TM0 Position */
N#define SYS_ALT_MFP2_PB15_TM0_Msk               (1ul << SYS_ALT_MFP2_PB15_TM0_Pos)          /*!< GCR_T::ALT_MFP2: PB15_TM0 Mask */
N
N#define SYS_ALT_MFP2_PB14_15_EBI_Pos            0                                           /*!< GCR_T::ALT_MFP2: PB14_15_EBI Position */
N#define SYS_ALT_MFP2_PB14_15_EBI_Msk            (1ul << SYS_ALT_MFP2_PB14_15_EBI_Pos)       /*!< GCR_T::ALT_MFP2: PB14_15_EBI Mask */
N
N#define SYS_ALT_MFP2_PD14_15_CAN1_Pos           0                                           /*!< GCR_T::ALT_MFP2: PD14_15_CAN1 Position */
N#define SYS_ALT_MFP2_PD14_15_CAN1_Msk           (1ul << SYS_ALT_MFP2_PD14_15_CAN1_Pos)      /*!< GCR_T::ALT_MFP2: PD14_15_CAN1 Mask */
N
N/* GCR IRCTRIMCTL Bit Field Definitions */
N#define SYS_IRCTRIMCTL_CLKERR_STOP_EN_Pos       8                                           /*!< GCR_T::IRCTRIMCTL: CLKERR_STOP_EN Position */
N#define SYS_IRCTRIMCTL_CLKERR_STOP_EN_Msk       (1ul << SYS_IRCTRIMCTL_CLKERR_STOP_EN_Pos)  /*!< GCR_T::IRCTRIMCTL: CLKERR_STOP_EN Mask */
N
N#define SYS_IRCTRIMCTL_TRIM_RETRY_CNT_Pos       6                                           /*!< GCR_T::IRCTRIMCTL: TRIM_RETRY_CNT Position */
N#define SYS_IRCTRIMCTL_TRIM_RETRY_CNT_Msk       (3ul << SYS_IRCTRIMCTL_TRIM_RETRY_CNT_Pos)  /*!< GCR_T::IRCTRIMCTL: TRIM_RETRY_CNT Mask */
N
N#define SYS_IRCTRIMCTL_TRIM_LOOP_Pos            4                                           /*!< GCR_T::IRCTRIMCTL: TRIM_LOOP Position */
N#define SYS_IRCTRIMCTL_TRIM_LOOP_Msk            (3ul << SYS_IRCTRIMCTL_TRIM_LOOP_Pos)       /*!< GCR_T::IRCTRIMCTL: TRIM_LOOP Mask */
N
N#define SYS_IRCTRIMCTL_TRIM_SEL_Pos             0                                           /*!< GCR_T::IRCTRIMCTL: TRIM_SEL Position */
N#define SYS_IRCTRIMCTL_TRIM_SEL_Msk             (3ul << SYS_IRCTRIMCTL_TRIM_SEL_Pos)        /*!< GCR_T::IRCTRIMCTL: TRIM_SEL Mask */
N
N/* GCR IRCTRIMIEN Bit Field Definitions */
N#define SYS_IRCTRIMIEN_CLKERR_IEN_Pos           2                                           /*!< GCR_T::IRCTRIMIEN: CLKERR_IEN Position */
N#define SYS_IRCTRIMIEN_CLKERR_IEN_Msk           (1ul << SYS_IRCTRIMIEN_CLKERR_IEN_Pos)      /*!< GCR_T::IRCTRIMIEN: CLKERR_IEN Mask */
N
N#define SYS_IRCTRIMIEN_TRIM_FAIL_IEN_Pos        1                                           /*!< GCR_T::IRCTRIMIEN: TRIM_FAIL_IEN Position */
N#define SYS_IRCTRIMIEN_TRIM_FAIL_IEN_Msk        (1ul << SYS_IRCTRIMIEN_TRIM_FAIL_IEN_Pos)   /*!< GCR_T::IRCTRIMIEN: TRIM_FAIL_IEN Mask */
N
N/* GCR IRCTRIMINT Bit Field Definitions */
N#define SYS_IRCTRIMINT_CLKERR_INT_Pos           2                                           /*!< GCR_T::IRCTRIMINT: CLKERR_INT Position */
N#define SYS_IRCTRIMINT_CLKERR_INT_Msk           (1ul << SYS_IRCTRIMINT_CLKERR_INT_Pos)      /*!< GCR_T::IRCTRIMINT: CLKERR_INT Mask */
N
N#define SYS_IRCTRIMINT_TRIM_FAIL_INT_Pos        1                                           /*!< GCR_T::IRCTRIMINT: TRIM_FAIL_INT Position */
N#define SYS_IRCTRIMINT_TRIM_FAIL_INT_Msk        (1ul << SYS_IRCTRIMINT_TRIM_FAIL_INT_Pos)   /*!< GCR_T::IRCTRIMINT: TRIM_FAIL_INT Mask */
N
N#define SYS_IRCTRIMINT_FREQ_LOCK_Pos            0                                           /*!< GCR_T::IRCTRIMINT: FREQ_LOCK Position */
N#define SYS_IRCTRIMINT_FREQ_LOCK_Msk            (1ul << SYS_IRCTRIMINT_FREQ_LOCK_Pos)       /*!< GCR_T::IRCTRIMINT: FREQ_LOCK Mask */
N
N/* GCR REGWRPROT Bit Field Definitions */
N#define SYS_REGWRPROT_REGWRPROT_Pos             0                                           /*!< GCR_T::REGWRPROT: REGWRPROT Position */
N#define SYS_REGWRPROT_REGWRPROT_Msk             (0xFFul << SYS_REGWRPROT_REGWRPROT_Pos)     /*!< GCR_T::REGWRPROT: REGWRPROT Mask */
N
N#define SYS_REGWRPROT_REGPROTDIS_Pos            0                                       /*!< GCR_T::REGWRPROT: REGPROTDIS Position */
N#define SYS_REGWRPROT_REGPROTDIS_Msk            (1ul << SYS_REGWRPROT_REGPROTDIS_Pos)   /*!< GCR_T::REGWRPROT: REGPROTDIS Mask */
N/*@}*/ /* end of group SYS_CONST */
N
N
N
Ntypedef struct
N{
N
N/**
N * @var GCR_INT_T::IRQSRC[32]
N * Offset: 0x00-0x7C  IRQn(n=0~31) Interrupt Source Identity Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[5:0]   |INT_SRC   |Interrupt Source Identity
N * |        |          |IRQ_SRC[0].0 - BOD INT
N * |        |          |IRQ_SRC[1].0 - WDT INT
N * |        |          |IRQ_SRC[1].1 - WWDT INT
N * |        |          |IRQ_SRC[2].0 - EINT0, external interrupt 0 from PB.14
N * |        |          |IRQ_SRC[3].0 - EINT1, external interrupt 1 from PB.15
N * |        |          |IRQ_SRC[4].0 - GPA INT
N * |        |          |IRQ_SRC[4].1 - GPB INT
N * |        |          |IRQ_SRC[5].0 - GPC INT
N * |        |          |IRQ_SRC[5].1 - GPD INT
N * |        |          |IRQ_SRC[5].2 - GPE INT
N * |        |          |IRQ_SRC[5].3 - GPF INT
N * |        |          |IRQ_SRC[6].0 - PWM0 INT
N * |        |          |IRQ_SRC[6].1 - PWM1 INT
N * |        |          |IRQ_SRC[6].2 - PWM2 INT
N * |        |          |IRQ_SRC[6].3 - PWM3 INT
N * |        |          |IRQ_SRC[7].0 - PWM4 INT
N * |        |          |IRQ_SRC[7].1 - PWM5 INT
N * |        |          |IRQ_SRC[7].2 - PWM6 INT
N * |        |          |IRQ_SRC[7].3 - PWM7 INT
N * |        |          |IRQ_SRC[8].0 - TMR0 INT
N * |        |          |IRQ_SRC[9].0 - TMR1 INT
N * |        |          |IRQ_SRC[10].0 - TMR2 INT
N * |        |          |IRQ_SRC[11].0 - TMR3 INT
N * |        |          |IRQ_SRC[12].0 - UART0 INT
N * |        |          |IRQ_SRC[12].1 - UART2 INT
N * |        |          |IRQ_SRC[13].0 - UART1 INT
N * |        |          |IRQ_SRC[14].0 - SPI0 INT
N * |        |          |IRQ_SRC[15].0 - SPI1 INT
N * |        |          |IRQ_SRC[16].0 - SPI2 INT
N * |        |          |IRQ_SRC[17].0 - SPI3 INT
N * |        |          |IRQ_SRC[18].0 - I2C0 INT
N * |        |          |IRQ_SRC[19].0 - I2C1 INT
N * |        |          |IRQ_SRC[22].0 - SC0 INT
N * |        |          |IRQ_SRC[22].1 - SC1 INT
N * |        |          |IRQ_SRC[22].2 - SC2 INT
N * |        |          |IRQ_SRC[23].0 - USB INT
N * |        |          |IRQ_SRC[24].0 - PS2 INT
N * |        |          |IRQ_SRC[25].0 - ACMP INT
N * |        |          |IRQ_SRC[26].0 - PDMA INT
N * |        |          |IRQ_SRC[27].0 - I2S INT
N * |        |          |IRQ_SRC[28].0 - Power Down Wake up INT
N * |        |          |IRQ_SRC[29].0 - ADC INT
N * |        |          |IRQ_SRC[30].0 - IRC INT
N * |        |          |IRQ_SRC[31].0 - RTC INT
N * @var GCR_INT_T::NMISEL
N * Offset: 0x80  NMI Interrupt Source Select Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[4:0]   |NMI_SEL   |NMI interrupt source selection
N * |        |          |The NMI interrupt to Cortex-M0 can be selected from one of IRQ0~IRQ31 by setting NMI_SEL with
N * |        |          |IRQ number.
N * |        |          |The default NMI interrupt is assigned as IRQ0 interrupt if NMI is enabled by setting NMI_SEL[8].
N * |[8]     |NMI_EN    |NMI interrupt enable (Write Protect)
N * |        |          |0 = IRQ0~31 assigned to NMI interrupt Disabled. (NMI still can be software triggered by setting
N * |        |          |its pending flag.)
N * |        |          |1 = IRQ0~31 assigned to NMI interrupt Enabled.
N * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register.
N * @var GCR_INT_T::MCUIRQ
N * Offset: 0x84  MCU Interrupt Request Source Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |MCU_IRQ   |MCU IRQ Source Register
N * |        |          |The MCU_IRQ collects all the interrupts from the peripherals and generates the synchronous
N * |        |          |interrupt to Cortex-M0.
N * |        |          |When the MCU_IRQ[n] is 0:
N * |        |          |0 = No effect.
N * |        |          |1 = Generate an interrupt to Cortex_M0 NVIC[n].
N * |        |          |When the MCU_IRQ[n] is 1 (means an interrupt is assert):
N * |        |          |0 = No effect.
N * |        |          |1 = Clear the interrupt and MCU_IRQ[n].
N * @var GCR_INT_T::MCUIRQCR
N * Offset: 0x88  MCU Interrupt Request Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |FAST_IRQ  |Fast IRQ Latency Enable
N * |        |          |0 = MCU IRQ latency is fixed at 13 clock cycles of HCLK, 
N * |        |          |    MCU will enter IRQ handler after this fixed latency when interrupt happened.
N * |        |          |1 = MCU IRQ latency will not fixed, MCU will enter IRQ handler as soon as possible when
N * |        |          |interrupt happened.
N */
N
N    __I  uint32_t IRQSRC[32];   /* Offset: 0x00-0x7C  IRQn(n=0~31) Interrupt Source Identity Register               */
X    volatile const  uint32_t IRQSRC[32];    
N    __IO uint32_t NMISEL;       /* Offset: 0x80  NMI Interrupt Source Select Control Register                       */
X    volatile uint32_t NMISEL;        
N    __IO uint32_t MCUIRQ;       /* Offset: 0x84  MCU Interrupt Request Source Register                              */
X    volatile uint32_t MCUIRQ;        
N    __IO uint32_t MCUIRQCR;     /* Offset: 0x88  MCU MCU Interrupt Request Control Register                         */ 
X    volatile uint32_t MCUIRQCR;       
N
N} GCR_INT_T;
N
N
N/**
N    @addtogroup INT_CONST INT Bit Field Definition
N    Constant Definitions for INT Controller
N@{ */
N
N
N/* INT IRQSRC Bit Field Definitions */
N#define INT_IRQSRC_INT_SRC_Pos                  0                                   /*!< GCR_INT_T::IRQSRC: INT_SRC Position */
N#define INT_IRQSRC_INT_SRC_Msk                  (0xFul << INT_IRQSRC_INT_SRC_Pos)
N
N/* INT NMISEL Bit Field Definitions */
N#define INT_NMISEL_NMI_EN_Pos                   8                                   /*!< GCR_INT_T::NMISEL: NMI_EN Position */
N#define INT_NMISEL_NMI_EN_Msk                   (1ul << INT_NMISEL_NMI_EN_Pos)      /*!< GCR_INT_T::NMISEL: NMI_EN Mask */
N
N#define INT_NMISEL_NMI_SEL_Pos                  0                                   /*!< GCR_INT_T::NMISEL: NMI_SEL Position */
N#define INT_NMISEL_NMI_SEL_Msk                  (0x1Ful << INT_NMISEL_NMI_SEL_Pos)  /*!< GCR_INT_T::NMISEL: NMI_SEL Mask */
N
N/* INT MCUIRQ Bit Field Definitions */
N#define INT_MCUIRQ_MCU_IRQ_Pos                  0                                           /*!< GCR_INT_T::MCUIRQ: MCU_IRQ Position */
N#define INT_MCUIRQ_MCU_IRQ_Msk                  (0xFFFFFFFFul << INT_MCUIRQ_MCU_IRQ_Pos)    /*!< GCR_INT_T::MCUIRQ: MCU_IRQ Mask */
N
N/* INT MCUIRQCR Bit Field Definitions */
N#define INT_MCUIRQCR_MCU_IRQ_Pos                0                                   /*!< GCR_INT_T::MCUIRQCR: FAST_IRQ Position */
N#define INT_MCUIRQCR_MCU_IRQ_Msk                (1ul << INT_MCUIRQCR_MCU_IRQ_Pos)   /*!< GCR_INT_T::MCUIRQCR: FAST_IRQ Mask */
N
N/*@}*/ /* end of group INT_CONST */
N/*@}*/ /* end of group SYS */
N
N
N/*---------------------- Timer Controller -------------------------*/
N/**
N    @addtogroup TIMER Timer Controller (TIMER)
N    Memory Mapped Structure for TMR Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N/**
N * @var TIMER_T::TCSR
N * Offset: 0x00  Timer Control and Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |PRESCALE  |Prescale Counter
N * |        |          |Timer input clock source is divided by (PRESCALE+1) before it is fed to the Timer up counter.
N * |        |          |If this field is 0 (PRESCALE = 0), then there is no scaling.
N * |[16]    |TDR_EN    |Data Load Enable Control
N * |        |          |When TDR_EN is set, TDR (Timer Data Register) will be updated continuously with the 24-bit
N * |        |          |up-timer value as the timer is counting.
N * |        |          |0 = Timer Data Register update Disabled.
N * |        |          |1 = Timer Data Register update Enabled while Timer counter is active.
N * |[23]    |WAKE_EN   |Wake Up Function Enable Control
N * |        |          |0 = Wake-up trigger event Disabled.
N * |        |          |1 = Wake-up trigger event Enabled.
N * |[24]    |CTB       |Counter Mode Enable Control
N * |        |          |This bit is for external counting pin function enabled.
N * |        |          |When timer is used as an event counter, this bit should be set to 1 and select HCLK as timer
N * |        |          |clock source.
N * |        |          |0 = External counter mode Disabled.
N * |        |          |1 = External counter mode Enabled.
N * |[25]    |CACT      |Timer Active Status (Read Only)
N * |        |          |This bit indicates the 24-bit up counter status.
N * |        |          |0 = 24-bit up counter is not active.
N * |        |          |1 = 24-bit up counter is active.
N * |[26]    |CRST      |Timer Reset
N * |        |          |0 = No effect.
N * |        |          |1 = Reset 8-bit prescale counter, 24-bit up counter value and CEN bit if CACT is 1.
N * |[28:27] |MODE      |Timer Operating Mode
N * |        |          |00 = The Timer controller is operated in One-shot mode.
N * |        |          |01 = The Timer controller is operated in Periodic mode.
N * |        |          |10 = The Timer controller is operated in Toggle-output mode.
N * |        |          |11 = The Timer controller is operated in Continuous Counting mode.
N * |[29]    |IE        |Interrupt Enable Control
N * |        |          |0 = Timer Interrupt function Disabled.
N * |        |          |1 = Timer Interrupt function Enabled.
N * |        |          |If this bit is enabled, when the timer interrupt flag (TISR[0] TIF) is set to 1, the timer
N * |        |          |interrupt signal is generated and inform to CPU.
N * |[30]    |CEN       |Timer Enable Control
N * |        |          |0 = Stops/Suspends counting.
N * |        |          |1 = Starts counting.
N * |        |          |Note1: In stop status, and then set CEN to 1 will enable the 24-bit up counter to keep counting
N * |        |          |from the last stop counting value.
N * |        |          |Note2: This bit is auto-cleared by hardware in one-shot mode (TCSR [28:27] = 00) when the timer
N * |        |          |interrupt flag (TISR[0] TIF) is generated.
N * |[31]    |DBGACK_TMR|ICE Debug Mode Acknowledge Disable (Write Protect)
N * |        |          |0 = ICE debug mode acknowledgement effects TIMER counting.
N * |        |          |TIMER counter will be held while CPU is held by ICE.
N * |        |          |1 = ICE debug mode acknowledgement Disabled.
N * |        |          |TIMER counter will keep going no matter CPU is held by ICE or not.
N * @var TIMER_T::TCMPR
N * Offset: 0x04  Timer Compare Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[23:0]  |TCMP      |Timer Compared Value
N * |        |          |TCMP is a 24-bit compared value register.
N * |        |          |When the internal 24-bit up counter value is equal to TCMP value, the TIF flag will set to 1.
N * |        |          |Time-out period = (Period of Timer clock input) * (8-bit PRESCALE + 1) * (24-bit TCMP).
N * |        |          |Note1: Never write 0x0 or 0x1 in TCMP field, or the core will run into unknown state.
N * |        |          |Note2: When timer is operating at continuous counting mode, the 24-bit up counter will keep
N * |        |          |counting continuously even if user writes a new value into TCMP field.
N * |        |          |But if timer is operating at other modes, the 24-bit up counter will restart counting and using
N * |        |          |newest TCMP value to be the timer compared value if user writes a new value into TCMP field.
N * @var TIMER_T::TISR
N * Offset: 0x08  Timer Interrupt Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |TIF       |Timer Interrupt Flag
N * |        |          |This bit indicates the interrupt flag status of Timer while TDR value reaches to TCMP value.
N * |        |          |0 = No effect.
N * |        |          |1 = TDR value matches the TCMP value.
N * |        |          |Note: This bit is cleared by writing 1 to it.
N * |[1]     |TWF       |Timer Wake-Up Flag
N * |        |          |This bit indicates the interrupt wake-up flag status of Timer.
N * |        |          |0 = Timer does not cause CPU wake-up.
N * |        |          |1 = CPU wake-up from Idle or Power-down mode if Timer time-out interrupt signal generated.
N * |        |          |Note: This bit is cleared by writing 1 to it.
N * @var TIMER_T::TDR
N * Offset: 0x0C  Timer Data Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[23:0]  |TDR       |Timer Data Register
N * |        |          |If TDR_EN (TCSR[16]) is set to 1, TDR register will be updated continuously to monitor 24-bit up
N * |        |          |counter value.
N * @var TIMER_T::TCAP
N * Offset: 0x10  Timer Capture Data Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[23:0]  |TCAP      |Timer Capture Data Register
N * |        |          |When TEXIF flag is set to 1, the current TDR value will be auto-loaded into this TCAP filed
N * |        |          |immediately.
N * @var TIMER_T::TEXCON
N * Offset: 0x14  Timer External Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |TX_PHASE  |Timer External Count Pin Phase Detect Selection
N * |        |          |This bit indicates the detection phase of TMx pin.
N * |        |          |0 = A falling edge of TMx pin will be counted.
N * |        |          |1 = A rising edge of TMx pin will be counted.
N * |[2:1]   |TEX_EDGE  |Timer External Capture Pin Edge Detect Selection
N * |        |          |00 = A 1 to 0 transition on TMx_EXT pin will be detected.
N * |        |          |01 = A 0 to 1 transition on TMx_EXT pin will be detected.
N * |        |          |10 = Either 1 to 0 or 0 to 1 transition on TMx_EXT pin will be detected.
N * |        |          |11 = Reserved.
N * |[3]     |TEXEN     |Timer External Pin Function Enable
N * |        |          |This bit enables the RSTCAPSEL function on the TxEX pin.
N * |        |          |0 = RSTCAPSEL function of TxEX pin will be ignored.
N * |        |          |1 = RSTCAPSEL function of TxEX pin is active.
N * |[4]     |RSTCAPSEL |Timer External Reset Counter / Timer External Capture Mode Selection
N * |        |          |0 = Transition on TMx_EXT
N * |        |          |pin is using to save the TDR value into TCAP value if TEXIF flag is set to 1.
N * |        |          |1 = Transition on TMx_EXT pin is using to reset the 24-bit up counter.
N * |[5]     |TEXIEN    |Timer External Capture Interrupt Enable Control
N * |        |          |0 = TMx_EXT pin detection Interrupt Disabled.
N * |        |          |1 = TMx_EXT pin detection Interrupt Enabled.
N * |        |          |If TEXIEN enabled, Timer will raise an external capture interrupt signal and inform to CPU while
N * |        |          |TEXIF flag is set to 1.
N * |[6]     |TEXDB     |Timer External Capture Input Pin De-Bounce Enable Control
N * |        |          |0 = TMx_EXT pin de-bounce Disabled.
N * |        |          |1 = TMx_EXT pin de-bounce Enabled.
N * |        |          |If this bit is enabled, the edge detection of TMx_EXT pin is detected with de-bounce circuit.
N * |[7]     |TCDB      |Timer External Counter Input Pin De-Bounce Enable Control
N * |        |          |0 = TMx pin de-bounce Disabled.
N * |        |          |1 = TMx pin de-bounce Enabled.
N * |        |          |If this bit is enabled, the edge detection of TMx pin is detected with de-bounce circuit.
N * @var TIMER_T::TEXISR
N * Offset: 0x18  Timer External Interrupt Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |TEXIF     |Timer External Capture Interrupt Flag
N * |        |          |This bit indicates the external capture interrupt flag status.
N * |        |          |When TEXEN enabled, TMx_EXT pin selected as external capture function, and a transition on
N * |        |          |TMx_EXT pin matched the TEX_EDGE setting, this flag will set to 1 by hardware.
N * |        |          |0 = TMx_EXT pin interrupt did not occur.
N * |        |          |1 = TMx_EXT pin interrupt occurred.
N * |        |          |Note: This bit is cleared by writing 1 to it.
N */
N
N    __IO uint32_t TCSR;          /* Offset: 0x00  Timer Control and Status Register                                  */
X    volatile uint32_t TCSR;           
N    __IO uint32_t TCMPR;         /* Offset: 0x04  Timer Compare Register                                             */
X    volatile uint32_t TCMPR;          
N    __IO uint32_t TISR;          /* Offset: 0x08  Timer Interrupt Status Register                                    */
X    volatile uint32_t TISR;           
N    __I  uint32_t TDR;           /* Offset: 0x0C  Timer Data Register                                                */
X    volatile const  uint32_t TDR;            
N    __I  uint32_t TCAP;          /* Offset: 0x10  Timer Capture Data Register                                        */
X    volatile const  uint32_t TCAP;           
N    __IO uint32_t TEXCON;        /* Offset: 0x14  Timer External Control Register                                    */
X    volatile uint32_t TEXCON;         
N    __IO uint32_t TEXISR;        /* Offset: 0x18  Timer External Interrupt Status Register                           */
X    volatile uint32_t TEXISR;         
N
N} TIMER_T;
N
N
N/**
N    @addtogroup TIMER_CONST TIMER Bit Field Definition
N    Constant Definitions for TIMER Controller
N@{ */
N
N
N/* TIMER TCSR Bit Field Definitions */
N#define TIMER_TCSR_DBGACK_TMR_Pos   31                                          /*!< TIMER_T::TCSR: DBGACK_TMR Position */
N#define TIMER_TCSR_DBGACK_TMR_Msk   (1ul << TIMER_TCSR_DBGACK_TMR_Pos)          /*!< TIMER_T::TCSR: DBGACK_TMR Mask */
N
N#define TIMER_TCSR_CEN_Pos          30                                          /*!< TIMER_T::TCSR: CEN Position */
N#define TIMER_TCSR_CEN_Msk          (1ul << TIMER_TCSR_CEN_Pos)                 /*!< TIMER_T::TCSR: CEN Mask */
N
N#define TIMER_TCSR_IE_Pos           29                                          /*!< TIMER_T::TCSR: IE Position */
N#define TIMER_TCSR_IE_Msk           (1ul << TIMER_TCSR_IE_Pos)                  /*!< TIMER_T::TCSR: IE Mask */
N
N#define TIMER_TCSR_MODE_Pos         27                                          /*!< TIMER_T::TCSR: MODE Position */
N#define TIMER_TCSR_MODE_Msk         (0x3ul << TIMER_TCSR_MODE_Pos)              /*!< TIMER_T::TCSR: MODE Mask */
N
N#define TIMER_TCSR_CRST_Pos         26                                          /*!< TIMER_T::TCSR: CRST Position */
N#define TIMER_TCSR_CRST_Msk         (1ul << TIMER_TCSR_CRST_Pos)                /*!< TIMER_T::TCSR: CRST Mask */
N
N#define TIMER_TCSR_CACT_Pos         25                                          /*!< TIMER_T::TCSR: CACT Position */
N#define TIMER_TCSR_CACT_Msk         (1ul << TIMER_TCSR_CACT_Pos)                /*!< TIMER_T::TCSR: CACT Mask */
N
N#define TIMER_TCSR_CTB_Pos          24                                          /*!< TIMER_T::TCSR: CTB Position */
N#define TIMER_TCSR_CTB_Msk          (1ul << TIMER_TCSR_CTB_Pos)                 /*!< TIMER_T::TCSR: CTB Mask */
N
N#define TIMER_TCSR_WAKE_EN_Pos      23                                          /*!< TIMER_T::TCSR: WAKE_EN Position */
N#define TIMER_TCSR_WAKE_EN_Msk      (1ul << TIMER_TCSR_WAKE_EN_Pos)             /*!< TIMER_T::TCSR: WAKE_EN Mask */
N
N#define TIMER_TCSR_TDR_EN_Pos       16                                          /*!< TIMER_T::TCSR: TDR_EN Position */
N#define TIMER_TCSR_TDR_EN_Msk       (1ul << TIMER_TCSR_TDR_EN_Pos)              /*!< TIMER_T::TCSR: TDR_EN Mask */
N
N#define TIMER_TCSR_PRESCALE_Pos     0                                           /*!< TIMER_T::TCSR: PRESCALE Position */
N#define TIMER_TCSR_PRESCALE_Msk     (0xFFul << TIMER_TCSR_PRESCALE_Pos)         /*!< TIMER_T::TCSR: PRESCALE Mask */
N
N/* TIMER TCMPR Bit Field Definitions */
N#define TIMER_TCMP_TCMP_Pos         0                                           /*!< TIMER_T::TCMPR: TCMP Position */
N#define TIMER_TCMP_TCMP_Msk         (0xFFFFFFul << TIMER_TCMP_TCMP_Pos)         /*!< TIMER_T::TCMPR: TCMP Mask */
N
N/* TIMER TISR Bit Field Definitions */
N#define TIMER_TISR_TWF_Pos          1                                           /*!< TIMER_T::TISR: TWF Position */
N#define TIMER_TISR_TWF_Msk          (1ul << TIMER_TISR_TWF_Pos)                 /*!< TIMER_T::TISR: TWF Mask */
N
N#define TIMER_TISR_TIF_Pos          0                                           /*!< TIMER_T::TISR: TIF Position */
N#define TIMER_TISR_TIF_Msk          (1ul << TIMER_TISR_TIF_Pos)                 /*!< TIMER_T::TISR: TIF Mask */
N
N/* TIMER TDR Bit Field Definitions */
N#define TIMER_TDR_TDR_Pos           0                                           /*!< TIMER_T::TDR: TDR Position */
N#define TIMER_TDR_TDR_Msk           (0xFFFFFFul << TIMER_TDR_TDR_Pos)           /*!< TIMER_T::TDR: TDR Mask */
N
N/* TIMER TCAP Bit Field Definitions */
N#define TIMER_TCAP_TCAP_Pos         0                                           /*!< TIMER_T::TCAP: TCAP Position */
N#define TIMER_TCAP_TCAP_Msk         (0xFFFFFFul << TIMER_TCAP_TCAP_Pos)         /*!< TIMER_T::TCAP: TCAP Mask */
N
N/* TIMER TEXCON Bit Field Definitions */
N#define TIMER_TEXCON_TCDB_Pos       7                                           /*!< TIMER_T::TEXCON: TCDB Position */
N#define TIMER_TEXCON_TCDB_Msk       (1ul << TIMER_TEXCON_TCDB_Pos)              /*!< TIMER_T::TEXCON: TCDB Mask */
N
N#define TIMER_TEXCON_TEXDB_Pos      6                                           /*!< TIMER_T::TEXCON: TEXDB Position */
N#define TIMER_TEXCON_TEXDB_Msk      (1ul << TIMER_TEXCON_TEXDB_Pos)             /*!< TIMER_T::TEXCON: TEXDB Mask */
N
N#define TIMER_TEXCON_TEXIEN_Pos     5                                           /*!< TIMER_T::TEXCON: TEXIEN Position */
N#define TIMER_TEXCON_TEXIEN_Msk     (1ul << TIMER_TEXCON_TEXIEN_Pos)            /*!< TIMER_T::TEXCON: TEXIEN Mask */
N
N#define TIMER_TEXCON_RSTCAPSEL_Pos  4                                           /*!< TIMER_T::TEXCON: RSTCAPSEL Position */
N#define TIMER_TEXCON_RSTCAPSEL_Msk  (1ul << TIMER_TEXCON_RSTCAPSEL_Pos)         /*!< TIMER_T::TEXCON: RSTCAPSEL Mask */
N
N#define TIMER_TEXCON_TEXEN_Pos      3                                           /*!< TIMER_T::TEXCON: TEXEN Position */
N#define TIMER_TEXCON_TEXEN_Msk      (1ul << TIMER_TEXCON_TEXEN_Pos)             /*!< TIMER_T::TEXCON: TEXEN Mask */
N
N#define TIMER_TEXCON_TEX_EDGE_Pos   1                                           /*!< TIMER_T::TEXCON: TEX_EDGE Position */
N#define TIMER_TEXCON_TEX_EDGE_Msk   (0x3ul << TIMER_TEXCON_TEX_EDGE_Pos)        /*!< TIMER_T::TEXCON: TEX_EDGE Mask */
N
N#define TIMER_TEXCON_TX_PHASE_Pos   0                                           /*!< TIMER_T::TEXCON: TX_PHASE Position */
N#define TIMER_TEXCON_TX_PHASE_Msk   (1ul << TIMER_TEXCON_TX_PHASE_Pos)          /*!< TIMER_T::TEXCON: TX_PHASE Mask */
N
N/* TIMER TEXISR Bit Field Definitions */
N#define TIMER_TEXISR_TEXIF_Pos      0                                           /*!< TIMER_T::TEXISR: TEXIF Position */
N#define TIMER_TEXISR_TEXIF_Msk      (1ul << TIMER_TEXISR_TEXIF_Pos)             /*!< TIMER_T::TEXISR: TEXIF Mask */
N/*@}*/ /* end of group TIMER_CONST */
N/*@}*/ /* end of group TIMER */
N
N
N/*---------------------- Universal Asynchronous Receiver/Transmitter Controller -------------------------*/
N/**
N    @addtogroup UART Universal Asynchronous Receiver/Transmitter Controller (UART)
N    Memory Mapped Structure for UART Controller
N@{ */
N
N
N
Ntypedef struct
N{
N
N/**
N * @var UART_T::DATA
N * Offset: 0x00  UART Data Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |DATA      |Data Register
N * |        |          |By writing to this register, the UART will send out an 8-bit data through the UART_TXD pin (LSB
N * |        |          |first).
N * |        |          |By reading this register, the UART will return an 8-bit data received from UART_RXD pin (LSB
N * |        |          |first).
N * @var UART_T::THR
N * Offset: 0x00  UART Transmit Holding Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |THR       |Transmit Holding Register
N * |        |          |By writing to this register, the UART will send out an 8-bit data through the UART_TXD pin (LSB
N * |        |          |first).
N * @var UART_T::RBR
N * Offset: 0x00  UART Receive Buffer Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |RBR       |Receive Buffer Register (Read Only)
N * |        |          |By reading this register, the UART will return an 8-bit data received from UART_RXD pin (LSB
N * |        |          |first).
N * @var UART_T::IER
N * Offset: 0x04  UART Interrupt Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |RDA_IEN   |Receive Data Available Interrupt Enable Control
N * |        |          |0 = RDA_INT Masked off.
N * |        |          |1 = RDA_INT Enabled.
N * |[1]     |THRE_IEN  |Transmit Holding Register Empty Interrupt Enable Control
N * |        |          |0 = THRE_INT Masked off.
N * |        |          |1 = THRE_INT Enabled.
N * |[2]     |RLS_IEN   |Receive Line Status Interrupt Enable Control
N * |        |          |0 = RLS_INT Masked off.
N * |        |          |1 = RLS_INT Enabled
N * |[3]     |MODEM_IEN |Modem Status Interrupt Enable Control (Not Available In UART2 Channel)
N * |        |          |0 = MODEM_INT Masked off.
N * |        |          |1 = MODEM_INT Enabled.
N * |[4]     |TOUT_IEN  |RX Time-Out Interrupt Enable Control
N * |        |          |0 = TOUT_INT Masked off.
N * |        |          |1 = TOUT_INT Enabled.
N * |[5]     |BUF_ERR_IEN|Buffer Error Interrupt Enable Control
N * |        |          |0 = BUF_ERR_INT Masked off.
N * |        |          |1 = BUF_ERR_INT Enabled.
N * |[6]     |WAKE_EN   |UART Wake-Up Function Enable (Not Available In UART2 Channel)
N * |        |          |0 = UART wake-up function Disabled.
N * |        |          |1 = UART wake-up function Enabled, when the chip is in Power-down mode, an external CTS
N * |        |          |change will wake-up chip from Power-down mode.
N * |[8]     |LIN_IEN   |LIN Bus Interrupt Enable
N * |        |          |0 = Lin bus interrupt Disabled.
N * |        |          |1 = Lin bus interrupt Enabled.
N * |        |          |Note: This field is used for LIN function mode.
N * |[11]    |TIME_OUT_EN|Time-Out Counter Enable
N * |        |          |0 = Time-out counter Disabled.
N * |        |          |1 = Time-out counter Enabled.
N * |[12]    |AUTO_RTS_EN|RTS Auto Flow Control Enable (Not Available in UART2 Channel)
N * |        |          |0 = RTS auto flow control Disabled.
N * |        |          |1 = RTS auto flow control Enabled.
N * |        |          |When RTS auto-flow is enabled, if the number of bytes in the RX FIFO equals the RTS_TRI_LEV
N * |        |          |(UA_FCR [19:16]), the UART will de-assert RTS signal.
N * |[13]    |AUTO_CTS_EN|CTS Auto Flow Control Enable (Not Available in UART2 Channel)
N * |        |          |0 = CTS auto flow control Disabled.
N * |        |          |1 = CTS auto flow control Enabled.
N * |        |          |When CTS auto-flow is enabled, the UART will send data to external device when CTS input
N * |        |          |assert (UART will not send data to device until CTS is asserted).
N * |[14]    |DMA_TX_EN |TX DMA Enable (Not Available In UART2 Channel)
N * |        |          |This bit can enable or disable TX DMA service.
N * |        |          |0 = TX DMA Disabled.
N * |        |          |1 = TX DMA Enabled.
N * |[15]    |DMA_RX_EN |RX DMA Enable (Not Available In UART2 Channel)
N * |        |          |This bit can enable or disable RX DMA service.
N * |        |          |0 = RX DMA Disabled.
N * |        |          |1 = RX DMA Enabled.
N * @var UART_T::FCR
N * Offset: 0x08  UART FIFO Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1]     |RFR       |RX Field Software Reset
N * |        |          |When RFR is set, all the byte in the receiver FIFO and RX internal state machine are cleared.
N * |        |          |0 = No effect.
N * |        |          |1 = Reset the RX internal state machine and pointers.
N * |        |          |Note: This bit will automatically clear at least 3 UART peripheral clock cycles.
N * |[2]     |TFR       |TX Field Software Reset
N * |        |          |When TFR is set, all the byte in the transmit FIFO and TX internal state machine are cleared.
N * |        |          |0 = No effect.
N * |        |          |1 = Reset the TX internal state machine and pointers.
N * |        |          |Note: This bit will automatically clear at least 3 UART peripheral clock cycles.
N * |[7:4]   |RFITL     |RX FIFO Interrupt Trigger Level
N * |        |          |When the number of bytes in the receive FIFO equals the RFITL, the RDA_IF will be set (if
N * |        |          |RDA_IEN (UA_IER[0]) enabled, and an interrupt will be generated).
N * |        |          |0000 = RX FIFO Interrupt Trigger Level is 1 byte.
N * |        |          |0001 = RX FIFO Interrupt Trigger Level is 4 bytes.
N * |        |          |0010 = RX FIFO Interrupt Trigger Level is 8 bytes.
N * |        |          |0011 = RX FIFO Interrupt Trigger Level is 14 bytes.
N * |        |          |0100 = RX FIFO Interrupt Trigger Level is 30/14 bytes (High Speed/Normal Speed).
N * |        |          |0101 = RX FIFO Interrupt Trigger Level is 46/14 bytes (High Speed/Normal Speed).
N * |        |          |0110 = RX FIFO Interrupt Trigger Level is 62/14 bytes (High Speed/Normal Speed).
N * |        |          |Other = Reserved.
N * |[8]     |RX_DIS    |Receiver Disable Register
N * |        |          |The receiver is disabled or not (set 1 to disable receiver).
N * |        |          |0 = Receiver Enabled.
N * |        |          |1 = Receiver Disabled.
N * |        |          |Note: This field is used for RS-485 Normal Multi-drop mode. It should be programmed before
N * |        |          |RS485_NMM (UA_ALT_CSR[8]) is programmed.
N * |[19:16] |RTS_TRI_LEV|RTS Trigger Level For Auto-Flow Control Use (Not Available In UART2 Channel)
N * |        |          |0000 = RTS Trigger Level is 1 byte.
N * |        |          |0001 = RTS Trigger Level is 4 bytes.
N * |        |          |0010 = RTS Trigger Level is 8 bytes.
N * |        |          |0011 = RTS Trigger Level is 14 bytes.
N * |        |          |0100 = RTS Trigger Level is 30/14 bytes (High Speed/Normal Speed).
N * |        |          |0101 = RTS Trigger Level is 46/14 bytes (High Speed/Normal Speed).
N * |        |          |0110 = RTS Trigger Level is 62/14 bytes (High Speed/Normal Speed).
N * |        |          |Other = Reserved.
N * |        |          |Note: This field is used for RTS auto-flow control.
N * @var UART_T::LCR
N * Offset: 0x0C  UART Line Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1:0]   |WLS       |Word Length Selection
N * |        |          |00 = Word length is 5-bit.
N * |        |          |01 = Word length is 6-bit.
N * |        |          |10 = Word length is 7-bit
N * |        |          |11 = Word length is 8-bit
N * |[2]     |NSB       |Number Of "STOP Bit"
N * |        |          |0 = One " STOP bit" is generated in the transmitted data.
N * |        |          |1 = When select 5-bit word length, 1.5 "STOP bit" is generated in the transmitted data.
N * |        |          |When select 6-,7- and 8-bit word length, 2 "STOP bit" is generated in the transmitted data.
N * |[3]     |PBE       |Parity Bit Enable
N * |        |          |0 = No parity bit.
N * |        |          |1 = Parity bit is generated on each outgoing character and is checked on each incoming data.
N * |[4]     |EPE       |Even Parity Enable
N * |        |          |0 = Odd number of logic 1's is transmitted and checked in each word.
N * |        |          |1 = Even number of logic 1's is transmitted and checked in each word.
N * |        |          |This bit has effect only when PBE (UA_LCR[3]) is set.
N * |[5]     |SPE       |Stick Parity Enable
N * |        |          |0 = Stick parity Disabled.
N * |        |          |1 = If PBE (UA_LCR[3]) and EBE (UA_LCR[4]) are logic 1, the parity bit is transmitted and
N * |        |          |checked as logic 0.
N * |        |          |If PBE (UA_LCR[3]) is 1 and EBE (UA_LCR[4]) is 0 then the parity bit is transmitted and checked
N * |        |          |as 1.
N * |[6]     |BCB       |Break Control Bit
N * |        |          |When this bit is set to logic 1, the serial data output (TX) is forced to the Spacing State
N * |        |          |(logic 0).
N * |        |          |This bit acts only on TX and has no effect on the transmitter logic.
N * @var UART_T::MCR
N * Offset: 0x10  UART Modem Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1]     |RTS       |RTS (Request-To-Send) Signal Control (Not Available In UART2 Channel)
N * |        |          |This bit is direct control internal RTS signal active or not, and then drive the RTS pin output
N * |        |          |with LEV_RTS bit configuration.
N * |        |          |0 = RTS signal is active.
N * |        |          |1 = RTS signal is inactive.
N * |        |          |Note1: This RTS signal control bit is not effective when RTS auto-flow control is enabled in
N * |        |          |UART function mode.
N * |        |          |Note2: This RTS signal control bit is not effective when RS-485 auto direction mode (AUD) is
N * |        |          |enabled in RS-485 function mode.
N * |[9]     |LEV_RTS   |RTS Pin Active Level (Not Available In UART2 Channel)
N * |        |          |This bit defines the active level state of RTS pin output.
N * |        |          |0 = RTS pin output is high level active.
N * |        |          |1 = RTS pin output is low level active.
N * |[13]    |RTS_ST    |RTS Pin State (Read Only) (Not Available In UART2 Channel)
N * |        |          |This bit mirror from RTS pin output of voltage logic status.
N * |        |          |0 = RTS pin output is low level voltage logic state.
N * |        |          |1 = RTS pin output is high level voltage logic state.
N * @var UART_T::MSR
N * Offset: 0x14  UART Modem Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |DCTSF     |Detect CTS State Change Flag (Not Available In UART2 Channel)
N * |        |          |This bit is set whenever CTS input has change state, and it will generate Modem interrupt to CPU
N * |        |          |when MODEM_IEN (UA_IER [3]) is set to 1.
N * |        |          |0 = CTS input has not change state.
N * |        |          |1 = CTS input has change state.
N * |        |          |Note: This bit can be cleared by writing "1" to it.
N * |[4]     |CTS_ST    |CTS Pin Status (Read Only) (Not Available In UART2 Channel)
N * |        |          |This bit mirror from CTS pin input of voltage logic status.
N * |        |          |0 = CTS pin input is low level voltage logic state.
N * |        |          |1 = CTS pin input is high level voltage logic state.
N * |        |          |Note: This bit echoes when UART Controller peripheral clock is enabled, and CTS multi-function
N * |        |          |port is selected.
N * |[8]     |LEV_CTS   |CTS Pin Active Level
N * |        |          |This bit defines the active level state of CTS pin input.
N * |        |          |0 = CTS pin input is high level active.
N * |        |          |1 = CTS pin input is low level active.
N * @var UART_T::FSR
N * Offset: 0x18  UART FIFO Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |RX_OVER_IF|RX Overflow Error Interrupt Flag
N * |        |          |This bit is set when RX FIFO overflow.
N * |        |          |If the number of bytes of received data is greater than RX_FIFO (UA_RBR) size, 64/16/16 bytes of
N * |        |          |UART0/UART1/UART2, this bit will be set.
N * |        |          |0 = RX FIFO is not overflow.
N * |        |          |1 = RX FIFO is overflow.
N * |        |          |Note: This bit can be cleared by writing "1" to it.
N * |[3]     |RS485_ADD_DETF|RS-485 Address Byte Detection Flag 
N * |        |          |0 = Receiver detects a data that is not an address bit (bit 9 ='1').
N * |        |          |1 = Receiver detects a data that is an address bit (bit 9 ='1').
N * |        |          |Note1: This field is used for RS-485 function mode and RS485_ADD_EN (UA_ALT_CSR[15]) is set to 1
N * |        |          |to enable Address detection mode.
N * |        |          |Note2: This bit can be cleared by writing '1' to it.
N * |[4]     |PEF       |Parity Error Flag 
N * |        |          |This bit is set to logic 1 whenever the received character does not have a valid "parity bit",
N * |        |          |and is reset whenever the CPU writes 1 to this bit.
N * |        |          |0 = No parity error is generated.
N * |        |          |1 = Parity error is generated.
N * |        |          |Note: This bit can be cleared by writing "1" to it.
N * |[5]     |FEF       |Framing Error Flag
N * |        |          |This bit is set to logic 1 whenever the received character does not have a valid "stop bit"
N * |        |          |(that is, the stop bit following the last data bit or parity bit is detected as logic 0), and is
N * |        |          |reset whenever the CPU writes 1 to this bit.
N * |        |          |0 = No framing error is generated.
N * |        |          |1 = Framing error is generated.
N * |        |          |Note: This bit can be cleared by writing "1" to it.
N * |[6]     |BIF       |Break Interrupt Flag
N * |        |          |This bit is set to logic 1 whenever the received data input(RX) is held in the "spacing state"
N * |        |          |(logic 0) for longer than a full word transmission time (that is, the total time of "start bit"
N * |        |          |+ data bits + parity + stop bits) and is reset whenever the CPU writes 1 to this bit.
N * |        |          |0 = No Break interrupt is generated.
N * |        |          |1 = Break interrupt is generated.
N * |        |          |Note: This bit can be cleared by writing "1" to it.
N * |[13:8]  |RX_POINTER|RX FIFO Pointer (Read Only)
N * |        |          |This field indicates the RX FIFO Buffer Pointer.
N * |        |          |When UART receives one byte from external device, then RX_POINTER increases one.
N * |        |          |When one byte of RX FIFO is read by CPU, then RX_POINTER decreases one.
N * |        |          |The Maximum value shown in RX_POINTER is 63/15/15 (UART0/UART1/UART2).
N * |        |          |When the using level of RX FIFO Buffer equal to 64/16/16, the RX_FULL bit is set to 1 and
N * |        |          |RX_POINTER will show 0.
N * |        |          |As one byte of RX FIFO is read by CPU, the RX_FULL bit is cleared to 0 and RX_POINTER will show
N * |        |          |63/15/15 (UART0/UART1/UART2).
N * |[14]    |RX_EMPTY  |Receiver FIFO Empty (Read Only)
N * |        |          |This bit initiate RX FIFO empty or not.
N * |        |          |0 = RX FIFO is not empty.
N * |        |          |1 = RX FIFO is empty.
N * |        |          |Note: When the last byte of RX FIFO has been read by CPU, hardware sets this bit high. It will
N * |        |          |be cleared when UART receives any new data.
N * |[15]    |RX_FULL   |Receiver FIFO Full (Read Only)
N * |        |          |This bit initiates RX FIFO is full or not.
N * |        |          |0 = RX FIFO is not full.
N * |        |          |1 = RX FIFO is full.
N * |        |          |Note: This bit is set when the number of usage in RX FIFO Buffer is equal to
N * |        |          |64/16/16(UART0/UART1/UART2), otherwise is cleared by hardware.
N * |[21:16] |TX_POINTER|TX FIFO Pointer (Read Only)
N * |        |          |This field indicates the TX FIFO Buffer Pointer.
N * |        |          |When CPU writes one byte into UA_THR, then TX_POINTER increases one.
N * |        |          |When one byte of TX FIFO is transferred to Transmitter Shift Register, then TX_POINTER decreases
N * |        |          |one.
N * |        |          |The Maximum value shown in TX_POINTER is 63/15/15 (UART0/UART1/UART2).
N * |        |          |When the using level of TX FIFO Buffer equal to 64/16/16, the TX_FULL bit is set to 1 and
N * |        |          |TX_POINTER will show 0.
N * |        |          |As one byte of TX FIFO is transferred to Transmitter Shift Register, the TX_FULL bit is cleared
N * |        |          |to 0 and TX_POINTER will show 63/15/15 (UART0/UART1/UART2).
N * |[22]    |TX_EMPTY  |Transmitter FIFO Empty (Read Only)
N * |        |          |This bit indicates TX FIFO empty or not.
N * |        |          |0 = TX FIFO is not empty.
N * |        |          |1 = TX FIFO is empty.
N * |        |          |Note: When the last byte of TX FIFO has been transferred to Transmitter Shift Register, hardware
N * |        |          |sets this bit high. It will be cleared when writing data into THR (TX FIFO not empty).
N * |[23]    |TX_FULL   |Transmitter FIFO Full (Read Only)
N * |        |          |This bit indicates TX FIFO full or not.
N * |        |          |0 = TX FIFO is not full.
N * |        |          |1 = TX FIFO is full.
N * |        |          |This bit is set when the number of usage in TX FIFO Buffer is equal to
N * |        |          |64/16/16(UART0/UART1/UART2), otherwise is cleared by hardware.
N * |[24]    |TX_OVER_IF|TX Overflow Error Interrupt Flag 
N * |        |          |If TX FIFO (UA_THR) is full, an additional write to UA_THR will cause this bit to logic 1.
N * |        |          |0 = TX FIFO is not overflow.
N * |        |          |1 = TX FIFO is overflow.
N * |        |          |Note: This bit can be cleared by writing "1" to it.
N * |[28]    |TE_FLAG   |Transmitter Empty Flag (Read Only)
N * |        |          |This bit is set by hardware when TX FIFO (UA_THR) is empty and the STOP bit of the last byte has
N * |        |          |been transmitted.
N * |        |          |0 = TX FIFO is not empty.
N * |        |          |1 = TX FIFO is empty.
N * |        |          |Note: This bit is cleared automatically when TX FIFO is not empty or the last byte transmission
N * |        |          |has not completed.
N * @var UART_T::ISR
N * Offset: 0x1C  UART Interrupt Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |RDA_IF    |Receive Data Available Interrupt Flag (Read Only)
N * |        |          |When the number of bytes in the RX FIFO equals the RFITL then the RDA_IF(UA_ISR[0]) will be set.
N * |        |          |If RDA_IEN (UA_IER [0]) is enabled, the RDA interrupt will be generated.
N * |        |          |0 = No RDA interrupt flag is generated.
N * |        |          |1 = RDA interrupt flag is generated.
N * |        |          |Note: This bit is read only and it will be cleared when the number of unread bytes of RX FIFO
N * |        |          |drops below the threshold level RFITL(UA_FCR[7:4]).
N * |[1]     |THRE_IF   |Transmit Holding Register Empty Interrupt Flag (Read Only)
N * |        |          |This bit is set when the last data of TX FIFO is transferred to Transmitter Shift Register.
N * |        |          |If THRE_IEN (UA_IER[1]) is enabled, the THRE interrupt will be generated.
N * |        |          |0 = No THRE interrupt flag is generated.
N * |        |          |1 = THRE interrupt flag is generated.
N * |        |          |Note: This bit is read only and it will be cleared when writing data into THR (TX FIFO not
N * |        |          |empty).
N * |[2]     |RLS_IF    |Receive Line Interrupt Flag
N * |        |          |This bit is set when the RX receive data have parity error, frame error or break error (at least
N * |        |          |one of 3 bits, BIF(UA_FSR[6]), FEF(UA_FSR[5]) and PEF(UA_FSR[4]), is set).
N * |        |          |If RLS_IEN (UA_IER [2]) is enabled, the RLS interrupt will be generated.
N * |        |          |0 = No RLS interrupt flag is generated.
N * |        |          |1 = RLS interrupt flag is generated.
N * |        |          |Note1: In RS-485 function mode, this field is set include receiver detect and received address
N * |        |          |byte character (bit9 = '1') bit. At the same time, the bit of RS485_ADD_DETF(UA_FSR[3]) is also
N * |        |          |set.
N * |        |          |Note2: This bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]), FEF(UA_FSR[5]) and
N * |        |          |PEF(UA_FSR[4]) are cleared.
N * |        |          |Note3: In RS-485 function mode, this bit is read only and reset to 0 when all bits of
N * |        |          |BIF(UA_FSR[6]) , FEF(UA_FSR[5]) and PEF(UA_FSR[4]) and RS485_ADD_DETF (UA_FSR[3]) are cleared.
N * |[3]     |MODEM_IF  |MODEM Interrupt Flag (Read Only) (Not Available In UART2 Channel)
N * |        |          |This bit is set when the CTS pin has state change (DCTSF (UA_MSR[0]) = 1).
N * |        |          |If MODEM_IEN (UA_IER [3]) is enabled, the Modem interrupt will be generated.
N * |        |          |0 = No Modem interrupt flag is generated.
N * |        |          |1 = Modem interrupt flag is generated.
N * |        |          |Note: This bit is read only and reset to 0 when bit DCTSF is cleared by a write 1 on
N * |        |          |DCTSF(UA_MSR[0]).
N * |[4]     |TOUT_IF   |Time-out Interrupt Flag (Read Only)
N * |        |          |This bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the
N * |        |          |time-out counter equal to TOIC(UA_TOR[7:0]).
N * |        |          |If TOUT_IEN (UA_IER [4]) is enabled, the Time-out interrupt will be generated.
N * |        |          |0 = No Time-out interrupt flag is generated.
N * |        |          |1 = Time-out interrupt flag is generated.
N * |        |          |Note: This bit is read only and user can read UA_RBR (RX is in active) to clear it.
N * |[5]     |BUF_ERR_IF|Buffer Error Interrupt Flag (Read Only)
N * |        |          |This bit is set when the TX FIFO or RX FIFO overflows (TX_OVER_IF (UA_FSR[24]) or RX_OVER_IF
N * |        |          |(UA_FSR[0]) is set).
N * |        |          |When BUF_ERR_IF (UA_ISR[5])is set, the transfer is not correct.
N * |        |          |If BUF_ERR_IEN (UA_IER [8]) is enabled, the buffer error interrupt will be generated.
N * |        |          |0 = No buffer error interrupt flag is generated.
N * |        |          |1 = Buffer error interrupt flag is generated.
N * |        |          |Note: This bit is read only and reset to 0 when all bits of TX_OVER_IF(UA_FSR[24]) and
N * |        |          |RX_OVER_IF(UA_FSR[0]) are cleared.
N * |[7]     |LIN_IF    |LIN Bus Flag (Read Only)
N * |        |          |This bit is set when LIN slave header detect (LINS_HDET_F (UA_LIN_SR[0] = 1)), LIN break detect
N * |        |          |(LIN_BKDET_F(UA_LIN_SR[9]=1)), 
N * |        |          |bit error detect (BIT_ERR_F(UA_LIN_SR[9])=1), LIN slave ID parity error
N * |        |          |(LINS_IDPERR_F(UA_LIN_SR[2]) = 1) or LIN slave header error detect (LINS_HERR_F (UA_LIN_SR[1])).
N * |        |          |If LIN_ IEN (UA_IER [8]) is enabled the LIN interrupt will be generated.
N * |        |          |0 = None of LINS_HDET_F, LIN_BKDET_F, BIT_ERR_F, LINS_IDPERR_F and LINS_HERR_F is generated.
N * |        |          |1 = At least one of LINS_HDET_F, LIN_BKDET_F, BIT_ERR_F, LINS_IDPERR_F and LINS_HERR_F is
N * |        |          |generated.
N * |        |          |Note: This bit is read only. This bit is cleared when LINS_HDET_F(UA_LIN_SR[0]),
N * |        |          |LIN_BKDET_F(UA_LIN_SR[9]), BIT_ERR_F(UA_LIN_SR[9]), LINS_IDPENR_F (UA_LIN_SR[2]) and
N * |        |          |LINS_HERR_F(UA_LIN_SR[1]) all are cleared.
N * |[8]     |RDA_INT   |Receive Data Available Interrupt Indicator (Read Only)
N * |        |          |This bit is set if RDA_IEN (UA_IER[0]) and RDA_IF (UA_ISR[0]) are both set to 1.
N * |        |          |0 = No RDA interrupt is generated.
N * |        |          |1 = RDA interrupt is generated.
N * |[9]     |THRE_INT  |Transmit Holding Register Empty Interrupt Indicator (Read Only)
N * |        |          |This bit is set if THRE_IEN (UA_IER[1])and THRE_IF(UA_SR[1]) are both set to 1.
N * |        |          |0 = No THRE interrupt is generated.
N * |        |          |1 = THRE interrupt is generated.
N * |[10]    |RLS_INT   |Receive Line Status Interrupt Indicator (Read Only)
N * |        |          |This bit is set if RLS_IEN (UA_IER[2]) and RLS_IF(UA_ISR[2]) are both set to 1.
N * |        |          |0 = No RLS interrupt is generated.
N * |        |          |1 = RLS interrupt is generated
N * |[11]    |MODEM_INT |MODEM Status Interrupt Indicator (Read Only) (Not Available In UART2 Channel)
N * |        |          |This bit is set if MODEM_IEN(UA_IER[3]) and MODEM_IF(UA_ISR[4]) are both set to 1
N * |        |          |0 = No Modem interrupt is generated.
N * |        |          |1 = Modem interrupt is generated.
N * |[12]    |TOUT_INT  |Time-Out Interrupt Indicator (Read Only)
N * |        |          |This bit is set if TOUT_IEN(UA_IER[4]) and TOUT_IF(UA_ISR[4]) are both set to 1.
N * |        |          |0 = No Time-Out interrupt is generated.
N * |        |          |1 = Time-Out interrupt is generated.
N * |[13]    |BUF_ERR_INT|Buffer Error Interrupt Indicator (Read Only)
N * |        |          |This bit is set if BUF_ERR_IEN(UA_IER[5]) and BUF_ERR_IF(UA_ISR[5]) are both set to 1.
N * |        |          |0 = No buffer error interrupt is generated.
N * |        |          |1 = Buffer error interrupt is generated.
N * |[15]    |LIN_INT   |LIN Bus Interrupt Indicator (Read Only)
N * |        |          |This bit is set if LIN_IEN (UA_IER[8]) and LIN _IF(UA_ISR[7]) are both set to 1.
N * |        |          |0 = No LIN Bus interrupt is generated.
N * |        |          |1 = The LIN Bus interrupt is generated.
N * |[18]    |HW_RLS_IF |In DMA Mode, Receive Line Status Flag (Read Only)
N * |        |          |This bit is set when the RX receive data have parity error, frame error or break error (at least
N * |        |          |one of 3 bits, BIF (UA_FSR[6]), FEF (UA_FSR[5]) and PEF (UA_FSR[4]) is set).
N * |        |          |If RLS_IEN (UA_IER [2]) is enabled, the RLS interrupt will be generated.
N * |        |          |0 = No RLS interrupt flag is generated in DMA mode.
N * |        |          |1 = RLS interrupt flag is generated in DMA mode.
N * |        |          |Note1: In RS-485 function mode, this field include receiver detect any address byte received
N * |        |          |address byte character (bit9 = '1') bit.
N * |        |          |Note2: In UART function mode, this bit is read only and reset to 0 when all bits of
N * |        |          |BIF(UA_FSR[6]) , FEF(UA_FSR[5]) and PEF(UA_FSR[4]) are cleared.
N * |        |          |Note3: In RS-485 function mode, this bit is read only and reset to 0 when all bits of
N * |        |          |BIF(UA_FSR[6]) , FEF(UA_FSR[5]) and PEF(UA_FSR[4]) and RS485_ADD_DETF (UA_FSR[3]) are cleared.
N * |[19]    |HW_MODEM_IF|In DMA Mode, MODEM Interrupt Flag (Read Only) (Not Available In UART2 Channel)
N * |        |          |This bit is set when the CTS pin has state change (DCTSF (US_MSR[0] =1)).
N * |        |          |If MODEM_IEN (UA_IER [3]) is enabled, the Modem interrupt will be generated.
N * |        |          |0 = No Modem interrupt flag is generated in DMA mode.
N * |        |          |1 = Modem interrupt flag is generated in DMA mode.
N * |        |          |Note: This bit is read only and reset to 0 when the bit DCTSF(US_MSR[0]) is cleared by writing 1
N * |        |          |on DCTSF (US_MSR[0]).
N * |[20]    |HW_TOUT_IF|In DMA Mode, Time-Out Interrupt Flag (Read Only)
N * |        |          |This bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the
N * |        |          |time-out counter equal to TOIC (UA_TOR[7:0]).
N * |        |          |If TOUT_IEN (UA_IER [4]) is enabled, the Tout interrupt will be generated.
N * |        |          |0 = No Time-out interrupt flag is generated in DMA mode.
N * |        |          |1 = Time-out interrupt flag is generated in DMA mode.
N * |        |          |Note: This bit is read only and user can read UA_RBR (RX is in active) to clear it.
N * |[21]    |HW_BUF_ERR_IF|In DMA Mode, Buffer Error Interrupt Flag (Read Only)
N * |        |          |This bit is set when the TX or RX FIFO overflows (TX_OVER_IF (UA__FSR[24]) or RX_OVER_IF
N * |        |          |(UA_FSR[0]) is set).
N * |        |          |When BUF_ERR_IF (UA_ISR[5]) is set, the transfer maybe is not correct.
N * |        |          |If BUF_ERR_IEN (UA_IER [5]) is enabled, the buffer error interrupt will be generated.
N * |        |          |0 = No buffer error interrupt flag is generated in DMA mode.
N * |        |          |1 = Buffer error interrupt flag is generated in DMA mode.
N * |        |          |Note: This bit is cleared when both TX_OVER_IF (UA_FSR[24]]) and RX_OVER_IF (UA_FSR[0]) are
N * |        |          |cleared.
N * |[26]    |HW_RLS_INT|In DMA Mode, Receive Line Status Interrupt Indicator (Read Only)
N * |        |          |This bit is set if RLS_IEN (UA_IER[2])and HW_RLS_IF(UA_ISR[18]) are both set to 1.
N * |        |          |0 = No RLS interrupt is generated in DMA mode.
N * |        |          |1 = RLS interrupt is generated in DMA mode.
N * |[27]    |HW_MODEM_INT|In DMA Mode, MODEM Status Interrupt Indicator (Read Only) (Not Available In UART2 Channel)
N * |        |          |This bit is set if MODEM_IEN(UA_IER[3]) and HW_MODEM_IF(UA_ ISR[3]) are both set to 1.
N * |        |          |0 = No Modem interrupt is generated in DMA mode.
N * |        |          |1 = Modem interrupt is generated in DMA mode.
N * |[28]    |HW_TOUT_INT|In DMA Mode, Time-Out Interrupt Indicator (Read Only)
N * |        |          |This bit is set if TOUT_IEN (UA_IER[4])and HW_TOUT_IF(UA_ISR[20]) are both set to 1.
N * |        |          |0 = No Tout interrupt is generated in DMA mode.
N * |        |          |1 = Tout interrupt is generated in DMA mode.
N * |[29]    |HW_BUF_ERR_INT|In DMA Mode, Buffer Error Interrupt Indicator (Read Only)
N * |        |          |This bit is set if BUF_ERR_IEN (UA_IER[5]) and HW_BUF_ERR_IF (UA_ISR[5])are both set to 1.
N * |        |          |0 = No buffer error interrupt is generated in DMA mode.
N * |        |          |1 = Buffer error interrupt is generated in DMA mode.
N * @var UART_T::TOR
N * Offset: 0x20  UART Time-out Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7:0]   |TOIC      |Time-out Interrupt Comparator
N * |        |          |The time-out counter resets and starts counting (the counting clock = baud rate) whenever the RX
N * |        |          |FIFO receives a new data word.
N * |        |          |Once the content of time-out counter is equal to that of time-out interrupt comparator (TOIC
N * |        |          |(UA_TOR[7:0])), a receiver time-out interrupt is generated if TOUT_IEN (UA_IER [4]) enabled.
N * |        |          |A new incoming data word or RX FIFO empty will clear TOUT_IF(UA_IER[4]).
N * |        |          |In order to avoid receiver time-out interrupt generation immediately during one character is
N * |        |          |being received, TOIC (UA_TOR[7:0]) value should be set between 40 and 255.
N * |        |          |So, for example, if TOIC (UA_TOR[7:0]) is set with 40, the time-out interrupt is generated after
N * |        |          |four characters are not received when 1 stop bit and no parity check is set for UART transfer.
N * |[15:8]  |DLY       |TX Delay Time Value
N * |        |          |This field is used to programming the transfer delay time between the last stop bit and next
N * |        |          |start bit.
N * @var UART_T::BAUD
N * Offset: 0x24  UART Baud Rate Divisor Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[15:0]  |BRD       |Baud Rate Divider
N * |        |          |The field indicates the baud rate divider.
N * |[27:24] |DIVIDER_X |Divider X
N * |        |          |The baud rate divider M = X+1.
N * |[28]    |DIV_X_ONE |Divider X Equal To 1
N * |        |          |0 = Divider M is X+1 (the equation of M = X+1, but DIVIDER_X[27:24] must >= 8).
N * |        |          |1 = Divider M is 1.
N * |[29]    |DIV_X_EN  |Divider X Enable
N * |        |          |The BRD = Baud Rate Divider, and the baud rate equation is
N * |        |          |Baud Rate = Clock / [M * (BRD + 2)]; The default value of M is 16.
N * |        |          |0 = Divider X Disabled (the equation of M = 16).
N * |        |          |1 = Divider X Enabled (the equation of M = X+1, but DIVIDER_X [27:24] must >= 8).
N * |        |          |Note: In IrDA mode, this bit must disable.
N * @var UART_T::IRCR
N * Offset: 0x28  UART IrDA Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1]     |TX_SELECT |IrDA Receiver/Transmitter Selection Enable Control
N * |        |          |0 = IrDA Transmitter Disabled and Receiver Enabled.
N * |        |          |1 = IrDA Transmitter Enabled and Receiver Disabled.
N * |[5]     |INV_TX    |IrDA inverse Transmitting Output Signal Control
N * |        |          |0 = None inverse transmitting signal.
N * |        |          |1 = Inverse transmitting output signal.
N * |[6]     |INV_RX    |IrDA inverse Receive Input Signal Control
N * |        |          |0 = None inverse receiving input signal.
N * |        |          |1 = Inverse receiving input signal.
N * @var UART_T::ALT_CSR
N * Offset: 0x2C  UART Alternate Control/Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |LIN_BKFL  |UART LIN Break Field Length
N * |        |          |This field indicates a 4-bit LIN TX break field count.
N * |        |          |Note1: This break field length is UA_LIN_BKFL + 1
N * |        |          |Note2: According to LIN spec, the reset value is 0xC (break field length = 13).
N * |[6]     |LIN_RX_EN |LIN RX Enable
N * |        |          |0 = LIN RX mode Disabled.
N * |        |          |1 = LIN RX mode Enabled.
N * |[7]     |LIN_TX_EN |LIN TX Break Mode Enable
N * |        |          |0 = LIN TX Break mode Disabled.
N * |        |          |1 = LIN TX Break mode Enabled.
N * |        |          |Note: When TX break field transfer operation finished, this bit will be cleared automatically.
N * |[8]     |RS485_NMM |RS-485 Normal Multi-Drop Operation Mode (NMM)
N * |        |          |0 = RS-485 Normal Multi-drop Operation mode (NMM) Disabled.
N * |        |          |1 = RS-485 Normal Multi-drop Operation mode (NMM) Enabled.
N * |        |          |Note: It cannot be active with RS-485_AAD operation mode.
N * |[9]     |RS485_AAD |RS-485 Auto Address Detection Operation Mode (AAD)
N * |        |          |0 = RS-485 Auto Address Detection Operation mode (AAD) Disabled.
N * |        |          |1 = RS-485 Auto Address Detection Operation mode (AAD) Enabled.
N * |        |          |Note: It cannot be active with RS-485_NMM operation mode.
N * |[10]    |RS485_AUD |RS-485 Auto Direction Mode (AUD)
N * |        |          |0 = RS-485 Auto Direction Operation mode (AUO) Disabled.
N * |        |          |1 = RS-485 Auto Direction Operation mode (AUO) Enabled.
N * |        |          |Note: It can be active with RS-485_AAD or RS-485_NMM operation mode.
N * |[15]    |RS485_ADD_EN|RS-485 Address Detection Enable
N * |        |          |This bit is used to enable RS-485 Address Detection mode.
N * |        |          |0 = Address detection mode Disabled.
N * |        |          |1 = Address detection mode Enabled.
N * |        |          |Note: This bit is used for RS-485 any operation mode.
N * |[31:24] |ADDR_MATCH|Address Match Value Register
N * |        |          |This field contains the RS-485 address match values.
N * |        |          |Note: This field is used for RS-485 auto address detection mode.
N * @var UART_T::FUN_SEL
N * Offset: 0x30  UART Function Select Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1:0]   |FUN_SEL   |Function Select Enable
N * |        |          |00 = UART function Enabled.
N * |        |          |01 = LIN function Enabled.
N * |        |          |10 = IrDA function Enabled.
N * |        |          |11 = RS-485 function Enabled.
N * @var UART_T::LIN_CTL
N * Offset: 0x34  UART LIN Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |LINS_EN   |LIN Slave Mode Enable Control
N * |        |          |0 = LIN slave mode Disabled.
N * |        |          |1 = LIN slave mode Enabled.
N * |[1]     |LINS_HDET_EN|LIN Slave Header Detection Enable Control
N * |        |          |0 = LIN slave header detection Disabled.
N * |        |          |1 = LIN slave header detection Enabled.
N * |        |          |Note1: This bit only valid when in LIN slave mode (LINS_EN (UA_LIN_CTL[0]) = 1).
N * |        |          |Note2: In LIN function mode, when detect header field (break + sync + frame ID), LINS_HDET_F
N * |        |          |(UA_LIN_SR [0]) flag will be asserted. If the LIN_IEN (UA_IER[8]) = 1, an interrupt will be
N * |        |          |generated.
N * |[2]     |LINS_ARS_EN|LIN Slave Automatic Resynchronization Mode Enable Control
N * |        |          |0 = LIN automatic resynchronization Disabled.
N * |        |          |1 = LIN automatic resynchronization Enabled.
N * |        |          |Note1: This bit only valid when in LIN slave mode (LINS_EN (UA_LIN_CTL[0]) = 1).
N * |        |          |Note2: When operation in Automatic Resynchronization mode, the baud rate setting must be mode2
N * |        |          |(BAUD_M1 (UA_BAUD [29]) and BAUD_M0 (UA_BAUD [28]) must be 1). 
N * |        |          |(Slave mode with automatic resynchronization).
N * |[3]     |LINS_DUM_EN|LIN Slave Divider Update Method Enable Control
N * |        |          |0 = UA_BAUD updated is written by software (if no automatic resynchronization update occurs at
N * |        |          |the same time).
N * |        |          |1 = UA_BAUD is updated at the next received character. User must set the bit before checksum
N * |        |          |reception.
N * |        |          |Note1: This bit only valid when in LIN slave mode (LINS_EN (UA_LIN_CTL[0]) = 1).
N * |        |          |Note2: This bit used for LIN Slave Automatic Resynchronization mode.
N * |        |          |(for Non-Automatic Resynchronization mode, this bit should be kept cleared).
N * |        |          |(Slave mode with automatic resynchronization).
N * |[4]     |LIN_MUTE_EN|LIN Mute Mode Enable Control
N * |        |          |0 = LIN mute mode Disabled.
N * |        |          |1 = LIN mute mode Enabled.
N * |        |          |Note: The exit from mute mode condition and each control and interactions of this field are
N * |        |          |explained in (LIN slave mode).
N * |[8]     |LIN_SHD   |LIN TX Send Header Enable Control
N * |        |          |The LIN TX header can be "break field" or "break and sync field" or "break, sync and frame ID
N * |        |          |field", it is depend on setting LIN_HEAD_SEL (UA_LIN_CTL[23:22]).
N * |        |          |0 = Send LIN TX header Disabled.
N * |        |          |1 = Send LIN TX header Enabled.
N * |        |          |Note1: These registers are shadow registers of LIN_SHD (UA_ALT_CSR [7]); user can read/write it
N * |        |          |by setting LIN_SHD (UA_ALT_CSR [7]) or LIN_SHD (UA_LIN_CTL [8]).
N * |        |          |Note2: When transmitter header field (it may be "break" or "break + sync" or "break + sync +
N * |        |          |frame ID" selected by LIN_HEAD_SEL (UA_LIN_CTL[23:22]) field) transfer operation finished, this
N * |        |          |bit will be cleared automatically.
N * |[9]     |LIN_IDPEN |LIN ID Parity Enable Control
N * |        |          |0 = LIN frame ID parity Disabled.
N * |        |          |1 = LIN frame ID parity Enabled.
N * |        |          |Note1: This bit can be used for LIN master to sending header field LIN_SHD (UA_LIN_CTL[8]) = 1
N * |        |          |and LIN_HEAD_SEL (UA_LIN_CTL[23:22]) = 10 or be used for enable LIN slave received frame ID
N * |        |          |parity checked.
N * |        |          |Note2: This bit is only use when the operation header transmitter is in LIN_HEAD_SEL
N * |        |          |(UA_LIN_CTL[23:22]) = 10.
N * |[10]    |LIN_BKDET_EN|LIN Break Detection Enable Control
N * |        |          |When detect consecutive dominant greater than 11 bits, and are followed by a delimiter
N * |        |          |character, the LIN_BKDET_F (UA_LIN_SR[8]) flag is set in UA_LIN_SR register at the end of break
N * |        |          |field.
N * |        |          |If the LIN_IEN (UA_IER [8])=1, an interrupt will be generated.
N * |        |          |0 = LIN break detection Disabled.
N * |        |          |1 = LIN break detection Enabled.
N * |[11]    |LIN_RX_DIS|LIN Receiver Disable Control
N * |        |          |If the receiver is enabled (LIN_RX_DIS (UA_LIN_CTL[11]) = 0), all received byte data will be
N * |        |          |accepted and stored in the RX-FIFO, and if the receiver is disabled (LIN_RX_DIS (UA_LIN_CTL[11])
N * |        |          |= 1), all received byte data will be ignore.
N * |        |          |0 = LIN receiver Enabled.
N * |        |          |1 = LIN receiver Disabled.
N * |        |          |Note: This bit is only valid when operating in LIN function mode (FUN_SEL (UA_FUN_SEL[1:0]) =
N * |        |          |01).
N * |[12]    |BIT_ERR_EN|Bit Error Detect Enable Control
N * |        |          |0 = Bit error detection function Disabled.
N * |        |          |1 = Bit error detection Enabled.
N * |        |          |Note: In LIN function mode, when occur bit error, the BIT_ERR_F (UA_LIN_SR[9]) flag will be
N * |        |          |asserted. If the LIN_IEN (UA_IER[8]) = 1, an interrupt will be generated.
N * |[19:16] |LIN_BKFL  |LIN Break Field Length
N * |        |          |This field indicates a 4-bit LIN TX break field count.
N * |        |          |Note1: These registers are shadow registers of LIN_BKFL, User can read/write it by setting
N * |        |          |LIN_BKFL (UA_ALT_CSR[3:0]) or LIN_BKFL (UA_LIN_CTL[19:16]).
N * |        |          |Note2: This break field length is LIN_BKFL + 1.
N * |        |          |Note3: According to LIN spec, the reset value is 12 (break field length = 13).
N * |[21:20] |LIN_BS_LEN|LIN Break/Sync Delimiter Length
N * |        |          |00 = The LIN break/sync delimiter length is 1 bit time.
N * |        |          |10 = The LIN break/sync delimiter length is 2 bit time.
N * |        |          |10 = The LIN break/sync delimiter length is 3 bit time.
N * |        |          |11 = The LIN break/sync delimiter length is 4 bit time.
N * |        |          |Note: This bit used for LIN master to sending header field.
N * |[23:22] |LIN_HEAD_SEL|LIN Header Select
N * |        |          |00 = The LIN header includes "break field".
N * |        |          |01 = The LIN header includes "break field" and "sync field".
N * |        |          |10 = The LIN header includes "break field", "sync field" and "frame ID field".
N * |        |          |11 = Reserved.
N * |        |          |Note: This bit is used to master mode for LIN to send header field (LIN_SHD (UA_LIN_CTL [8]) = 1)
N * |        |          |or used to slave to indicates exit from mute mode condition (LIN_MUTE_EN (UA_LIN_CTL[4]) = 1).
N * |[31:24] |LIN_PID   |LIN PID Register
N * |        |          |This field contains the LIN frame ID value when in LIN function mode, the frame ID parity can be
N * |        |          |generated by software or hardware depends on LIN_IDPEN (UA_LIN_CTL[9]) = 1.
N * |        |          |If the parity generated by hardware, user fill ID0~ID5, (LIN_PID [29:24] )hardware will
N * |        |          |calculate P0 (LIN_PID[30]) and P1 (LIN_PID[31]), otherwise user must filled frame ID and parity
N * |        |          |in this field.
N * |        |          |Note1: User can fill any 8-bit value to this field and the bit 24 indicates ID0 (LSB first).
N * |        |          |Note2: This field can be used for LIN master mode or slave mode.
N * @var UART_T::LIN_SR
N * Offset: 0x38  UART LIN Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |LINS_HDET_F|LIN Slave Header Detection Flag
N * |        |          |This bit is set by hardware when a LIN header is detected in LIN slave mode and be cleared by
N * |        |          |writing 1 to it.
N * |        |          |0 = LIN header not detected.
N * |        |          |1 = LIN header detected (break + sync + frame ID).
N * |        |          |Note1: This bit is can be cleared by writing 1 to it.
N * |        |          |Note2: This bit is only valid when in LIN slave mode (LINS_EN (UA_LIN_CTL [0]) = 1) and enable
N * |        |          |LIN slave header detection function (LINS_HDET_EN (UA_LIN_CTL [1])).
N * |        |          |Note3: When enable ID parity check LIN_IDPEN (UA_LIN_CTL [9]), if hardware detect complete
N * |        |          |header ("break + sync + frame ID"), the LINS_HEDT_F will be set whether the frame ID correct or
N * |        |          |not.
N * |[1]     |LINS_HERR_F|LIN Slave Header Error Flag
N * |        |          |This bit is set by hardware when a LIN header error is detected in LIN slave mode and be cleared
N * |        |          |by writing 1 to it.
N * |        |          |The header errors include "break delimiter is too short (less than 0.5 bit time)", "frame error
N * |        |          |in sync field or Identifier field", "sync field data is not 0x55 in Non-Automatic
N * |        |          |Resynchronization mode", "sync field deviation error with Automatic Resynchronization mode",
N * |        |          |"sync field measure time-out with Automatic Resynchronization mode" and "LIN header reception
N * |        |          |time-out".
N * |        |          |0 = LIN header error not detected.
N * |        |          |1 = LIN header error detected.
N * |        |          |Note1: This bit can be cleared by writing 1 to it.
N * |        |          |Note2: This bit is only valid when UART is operated in LIN slave mode (LINS_EN (UA_LIN_CTL [0])
N * |        |          |= 1) and enables LIN slave header detection function (LINS_HDET_EN (UA_LIN_CTL [1])).
N * |[2]     |LINS_IDPERR_F|LIN Slave ID Parity Error Flag
N * |        |          |This bit is set by hardware when receipted frame ID parity is not correct.
N * |        |          |0 = No active.
N * |        |          |1 = Receipted frame ID parity is not correct.
N * |        |          |Note1: This bit iscan be cleared by writing "1" to it.
N * |        |          |Note2: This bit is only valid when in LIN slave mode (LINS_EN (UA_LIN_CTL [0])= 1) and enable
N * |        |          |LIN frame ID parity check function LIN_IDPEN (UA_LIN_CTL [9]).
N * |[3]     |LINS_SYNC_F|LIN Slave Sync Field
N * |        |          |This bit indicates that the LIN sync field is being analyzed in Automatic Resynchronization
N * |        |          |mode.
N * |        |          |When the receiver header have some error been detect, user must reset the internal circuit to
N * |        |          |re-search new frame header by writing 1 to this bit.
N * |        |          |0 = The current character is not at LIN sync state.
N * |        |          |1 = The current character is at LIN sync state.
N * |        |          |Note1: This bit is only valid when in LIN Slave mode (LINS_EN(UA_LIN_CTL[0]) = 1).
N * |        |          |Note2: This bitcan be cleared by writing 1 to it.
N * |        |          |Note3: When writing 1 to it, hardware will reload the initial baud rate and re-search a new
N * |        |          |frame header.
N * |[8]     |LIN_BKDET_F|LIN Break Detection Flag
N * |        |          |This bit is set by hardware when a break is detected and be cleared by writing 1 to it through
N * |        |          |software.
N * |        |          |0 = LIN break not detected.
N * |        |          |1 = LIN break detected.
N * |        |          |Note1: This bitcan be cleared by writing 1 to it.
N * |        |          |Note2: This bit is only valid when LIN break detection function is enabled (LIN_BKDET_EN
N * |        |          |(UA_LIN_CTL[10]) =1).
N * |[9]     |BIT_ERR_F |Bit Error Detect Status Flag
N * |        |          |At TX transfer state, hardware will monitoring the bus state, if the input pin (SIN) state not
N * |        |          |equals to the output pin (SOUT) state, BIT_ERR_F (UA_LIN_SR[9]) will be set.
N * |        |          |When occur bit error, if the LIN_IEN (UA_IER[8]) = 1, an interrupt will be generated.
N * |        |          |Note1: This bit iscan be cleared by writing 1 to it.
N * |        |          |Note2: This bit is only valid when enable bit error detection function (BIT_ERR_EN (UA_LIN_CTL
N * |        |          |[12]) = 1).
N */
N
N    union {
N        __IO uint32_t DATA;          /* Offset: 0x00  UART Data Register                                                 */
X        volatile uint32_t DATA;           
N        __IO uint32_t THR;           /* Offset: 0x00  UART Transmit Holding Register                                     */
X        volatile uint32_t THR;            
N        __IO uint32_t RBR;           /* Offset: 0x00  UART Receive Buffer Register                                       */
X        volatile uint32_t RBR;            
N    };
N    __IO uint32_t IER;           /* Offset: 0x04  UART Interrupt Enable Register                                     */
X    volatile uint32_t IER;            
N    __IO uint32_t FCR;           /* Offset: 0x08  UART FIFO Control Register                                         */
X    volatile uint32_t FCR;            
N    __IO uint32_t LCR;           /* Offset: 0x0C  UART Line Control Register                                         */
X    volatile uint32_t LCR;            
N    __IO uint32_t MCR;           /* Offset: 0x10  UART Modem Control Register                                        */
X    volatile uint32_t MCR;            
N    __IO uint32_t MSR;           /* Offset: 0x14  UART Modem Status Register                                         */
X    volatile uint32_t MSR;            
N    __IO uint32_t FSR;           /* Offset: 0x18  UART FIFO Status Register                                          */
X    volatile uint32_t FSR;            
N    __IO uint32_t ISR;           /* Offset: 0x1C  UART Interrupt Status Register                                     */
X    volatile uint32_t ISR;            
N    __IO uint32_t TOR;           /* Offset: 0x20  UART Time-out Register                                             */
X    volatile uint32_t TOR;            
N    __IO uint32_t BAUD;          /* Offset: 0x24  UART Baud Rate Divisor Register                                    */
X    volatile uint32_t BAUD;           
N    __IO uint32_t IRCR;          /* Offset: 0x28  UART IrDA Control Register                                         */
X    volatile uint32_t IRCR;           
N    __IO uint32_t ALT_CSR;       /* Offset: 0x2C  UART Alternate Control/Status Register                             */
X    volatile uint32_t ALT_CSR;        
N    __IO uint32_t FUN_SEL;       /* Offset: 0x30  UART Function Select Register                                      */
X    volatile uint32_t FUN_SEL;        
N    __IO uint32_t LIN_CTL;       /* Offset: 0x34  UART LIN Control Register                                          */
X    volatile uint32_t LIN_CTL;        
N    __IO uint32_t LIN_SR;        /* Offset: 0x38  UART LIN Status Register                                           */
X    volatile uint32_t LIN_SR;         
N    
N
N} UART_T;
N
N
N
N/**
N    @addtogroup UART_CONST UART Bit Field Definition
N    Constant Definitions for UART Controller
N@{ */
N
N
N/* UART THR Bit Field Definitions */
N#define UART_THR_THR_Pos         0                                          /*!< UART_T::THR: THR Position  */
N#define UART_THR_THR_Msk        (0xFul << UART_THR_THR_Pos)                 /*!< UART_T::THR: THR Mask      */
N
N/* UART RBR Bit Field Definitions */
N#define UART_RBR_RBR_Pos         0                                          /*!< UART_T::RBR: RBR Posistion */
N#define UART_RBR_RBR_Msk        (0xFul << UART_RBR_RBR_Pos)                 /*!< UART_T::RBR: RBR Mask      */
N
N/* UART IER Bit Field Definitions */
N#define UART_IER_DMA_RX_EN_Pos      15                                      /*!< UART_T::IER: RX DMA Enable Posistion */
N#define UART_IER_DMA_RX_EN_Msk      (1ul << UART_IER_DMA_RX_EN_Pos)         /*!< UART_T::IER: RX DMA Enable Mask      */
N
N#define UART_IER_DMA_TX_EN_Pos      14                                      /*!< UART_T::IER: TX DMA Enable Posistion */
N#define UART_IER_DMA_TX_EN_Msk      (1ul << UART_IER_DMA_TX_EN_Pos)         /*!< UART_T::IER: TX DMA Enable Mask      */
N
N#define UART_IER_AUTO_CTS_EN_Pos    13                                      /*!< UART_T::IER: AUTO_CTS_EN Posistion      */
N#define UART_IER_AUTO_CTS_EN_Msk    (1ul << UART_IER_AUTO_CTS_EN_Pos)       /*!< UART_T::IER: AUTO_CTS_EN Mask           */
N
N#define UART_IER_AUTO_RTS_EN_Pos    12                                      /*!< UART_T::IER: AUTO_RTS_EN Posistion      */
N#define UART_IER_AUTO_RTS_EN_Msk    (1ul << UART_IER_AUTO_RTS_EN_Pos)       /*!< UART_T::IER: AUTO_RTS_EN Mask           */
N
N#define UART_IER_TIME_OUT_EN_Pos    11                                      /*!< UART_T::IER: TIME_OUT_EN Posistion      */
N#define UART_IER_TIME_OUT_EN_Msk    (1ul << UART_IER_TIME_OUT_EN_Pos)       /*!< UART_T::IER: TIME_OUT_EN Mask           */
N
N#define UART_IER_LIN_IEN_Pos        8                                       /*!< UART_T::IER: LIN_IEN Posistion          */
N#define UART_IER_LIN_IEN_Msk        (1ul << UART_IER_LIN_IEN_Pos)           /*!< UART_T::IER: LIN_IEN Mask               */
N
N#define UART_IER_WAKE_EN_Pos        6                                       /*!< UART_T::IER: WAKE_EN Posistion          */
N#define UART_IER_WAKE_EN_Msk        (1ul << UART_IER_WAKE_EN_Pos)           /*!< UART_T::IER: WAKE_EN Mask               */
N
N#define UART_IER_BUF_ERR_IEN_Pos    5                                       /*!< UART_T::IER: BUF_ERR_IEN Posistion      */
N#define UART_IER_BUF_ERR_IEN_Msk    (1ul << UART_IER_BUF_ERR_IEN_Pos)       /*!< UART_T::IER: BUF_ERR_IEN Mask           */
N
N#define UART_IER_TOUT_IEN_Pos        4                                      /*!< UART_T::IER: TOUT_IEN Posistion          */
N#define UART_IER_TOUT_IEN_Msk        (1ul << UART_IER_TOUT_IEN_Pos)         /*!< UART_T::IER: TOUT_IEN Mask               */
N
N#define UART_IER_MODEM_IEN_Pos      3                                       /*!< UART_T::IER: MODEM_IEN Posistion        */
N#define UART_IER_MODEM_IEN_Msk      (1ul << UART_IER_MODEM_IEN_Pos)         /*!< UART_T::IER: MODEM_IEN Mask             */
N
N#define UART_IER_RLS_IEN_Pos        2                                       /*!< UART_T::IER: RLS_IEN Posistion          */
N#define UART_IER_RLS_IEN_Msk        (1ul << UART_IER_RLS_IEN_Pos)           /*!< UART_T::IER: RLS_IEN Mask               */
N
N#define UART_IER_THRE_IEN_Pos       1                                       /*!< UART_T::IER: THRE_IEN Posistion         */
N#define UART_IER_THRE_IEN_Msk       (1ul << UART_IER_THRE_IEN_Pos)          /*!< UART_T::IER: THRE_IEN Mask              */
N
N#define UART_IER_RDA_IEN_Pos        0                                       /*!< UART_T::IER: RDA_IEN Position           */
N#define UART_IER_RDA_IEN_Msk        (1ul << UART_IER_RDA_IEN_Pos)           /*!< UART_T::IER: RDA_IEN Mask               */
N
N/* UART FCR Bit Field Definitions */
N#define UART_FCR_RTS_TRI_LEV_Pos    16                                      /*!< UART_T::FCR: RTS_TRI_LEV Position       */
N#define UART_FCR_RTS_TRI_LEV_Msk    (0xFul << UART_FCR_RTS_TRI_LEV_Pos)     /*!< UART_T::FCR: RTS_TRI_LEV Mask           */
N
N#define UART_FCR_RX_DIS_Pos         8                                       /*!< UART_T::FCR: RX_DIS Position            */
N#define UART_FCR_RX_DIS_Msk         (1ul << UART_FCR_RX_DIS_Pos)            /*!< UART_T::FCR: RX_DIS Mask                */
N
N#define UART_FCR_RFITL_Pos          4                                       /*!< UART_T::FCR: RFITL Position             */
N#define UART_FCR_RFITL_Msk          (0xFul << UART_FCR_RFITL_Pos)           /*!< UART_T::FCR: RFITL Mask                 */
N
N#define UART_FCR_TFR_Pos            2                                       /*!< UART_T::FCR: TFR Position               */
N#define UART_FCR_TFR_Msk            (1ul << UART_FCR_TFR_Pos)               /*!< UART_T::FCR: TFR Mask                   */
N
N#define UART_FCR_RFR_Pos            1                                       /*!< UART_T::FCR: RFR Position               */
N#define UART_FCR_RFR_Msk            (1ul << UART_FCR_RFR_Pos)               /*!< UART_T::FCR: RFR Mask                   */
N
N/* UART LCR Bit Field Definitions */
N#define UART_LCR_BCB_Pos            6                                       /*!< UART_T::LCR: BCB Position               */
N#define UART_LCR_BCB_Msk            (1ul << UART_LCR_BCB_Pos)               /*!< UART_T::LCR: BCB Mask                   */
N
N#define UART_LCR_SPE_Pos            5                                       /*!< UART_T::LCR: SPE Position               */
N#define UART_LCR_SPE_Msk            (1ul << UART_LCR_SPE_Pos)               /*!< UART_T::LCR: SPE Mask                   */
N
N#define UART_LCR_EPE_Pos            4                                       /*!< UART_T::LCR: EPE Position               */
N#define UART_LCR_EPE_Msk            (1ul << UART_LCR_EPE_Pos)               /*!< UART_T::LCR: EPE Mask                   */
N
N#define UART_LCR_PBE_Pos            3                                       /*!< UART_T::LCR: PBE Position               */
N#define UART_LCR_PBE_Msk            (1ul << UART_LCR_PBE_Pos)               /*!< UART_T::LCR: PBE Mask                   */
N
N#define UART_LCR_NSB_Pos            2                                       /*!< UART_T::LCR: NSB Position               */
N#define UART_LCR_NSB_Msk            (1ul << UART_LCR_NSB_Pos)               /*!< UART_T::LCR: NSB Mask                   */
N
N#define UART_LCR_WLS_Pos            0                                       /*!< UART_T::LCR: WLS Position               */
N#define UART_LCR_WLS_Msk            (0x3ul << UART_LCR_WLS_Pos)             /*!< UART_T::LCR: WLS Mask                   */
N
N/* UART MCR Bit Field Definitions */
N#define UART_MCR_RTS_ST_Pos         13                                      /*!< UART_T::MCR: RTS_ST Position            */
N#define UART_MCR_RTS_ST_Msk         (1ul << UART_MCR_RTS_ST_Pos)            /*!< UART_T::MCR: RTS_ST Mask                */
N
N#define UART_MCR_LEV_RTS_Pos        9                                       /*!< UART_T::MCR: LEV_RTS Position           */
N#define UART_MCR_LEV_RTS_Msk        (1ul << UART_MCR_LEV_RTS_Pos)           /*!< UART_T::MCR: LEV_RTS Mask               */
N
N#define UART_MCR_RTS_Pos            1                                       /*!< UART_T::MCR: RTS Position               */
N#define UART_MCR_RTS_Msk            (1ul << UART_MCR_RTS_Pos)               /*!< UART_T::MCR: RTS Mask                   */
N
N/* UART MSR Bit Field Definitions */
N#define UART_MSR_LEV_CTS_Pos        8                                       /*!< UART_T::MSR: LEV_CTS Position           */
N#define UART_MSR_LEV_CTS_Msk        (1ul << UART_MSR_LEV_CTS_Pos)           /*!< UART_T::MSR: LEV_CTS Mask               */
N
N#define UART_MSR_CTS_ST_Pos         4                                       /*!< UART_T::MSR: CTS_ST Position            */
N#define UART_MSR_CTS_ST_Msk         (1ul << UART_MSR_CTS_ST_Pos)            /*!< UART_T::MSR: CTS_ST Mask                */
N
N#define UART_MSR_DCTSF_Pos          0                                       /*!< UART_T::MSR: DCTST Position             */
N#define UART_MSR_DCTSF_Msk          (1ul << UART_MSR_DCTSF_Pos)             /*!< UART_T::MSR: DCTST Mask                 */
N
N
N/* UART FSR Bit Field Definitions */
N#define UART_FSR_TE_FLAG_Pos        28                                      /*!< UART_T::FSR: TE_FLAG Position           */
N#define UART_FSR_TE_FLAG_Msk        (1ul << UART_FSR_TE_FLAG_Pos)           /*!< UART_T::FSR: TE_FLAG Mask               */
N
N#define UART_FSR_TX_OVER_IF_Pos     24                                      /*!< UART_T::FSR: TX_OVER_IF Position        */
N#define UART_FSR_TX_OVER_IF_Msk     (1ul << UART_FSR_TX_OVER_IF_Pos)        /*!< UART_T::FSR: TX_OVER_IF Mask            */
N
N#define UART_FSR_TX_FULL_Pos        23                                      /*!< UART_T::FSR: TX_FULL Position           */
N#define UART_FSR_TX_FULL_Msk        (1ul << UART_FSR_TX_FULL_Pos)           /*!< UART_T::FSR: TX_FULL Mask               */
N
N#define UART_FSR_TX_EMPTY_Pos       22                                      /*!< UART_T::FSR: TX_EMPTY Position          */
N#define UART_FSR_TX_EMPTY_Msk       (1ul << UART_FSR_TX_EMPTY_Pos)          /*!< UART_T::FSR: TX_EMPTY Mask              */
N
N#define UART_FSR_TX_POINTER_Pos     16                                      /*!< UART_T::FSR: TX_POINTER Position        */
N#define UART_FSR_TX_POINTER_Msk     (0x3Ful << UART_FSR_TX_POINTER_Pos)     /*!< UART_T::FSR: TX_POINTER Mask            */
N
N#define UART_FSR_RX_FULL_Pos        15                                      /*!< UART_T::FSR: RX_FULL Position           */
N#define UART_FSR_RX_FULL_Msk        (1ul << UART_FSR_RX_FULL_Pos)           /*!< UART_T::FSR: RX_FULL Mask               */
N
N#define UART_FSR_RX_EMPTY_Pos       14                                      /*!< UART_T::FSR: RX_EMPTY Position          */
N#define UART_FSR_RX_EMPTY_Msk       (1ul << UART_FSR_RX_EMPTY_Pos)          /*!< UART_T::FSR: RX_EMPTY Mask              */
N
N#define UART_FSR_RX_POINTER_Pos     8                                       /*!< UART_T::FSR: RX_POINTERS Position       */
N#define UART_FSR_RX_POINTER_Msk     (0x3Ful << UART_FSR_RX_POINTER_Pos)     /*!< UART_T::FSR: RX_POINTER Mask            */
N
N#define UART_FSR_BIF_Pos            6                                       /*!< UART_T::FSR: BIF Position               */
N#define UART_FSR_BIF_Msk            (1ul << UART_FSR_BIF_Pos)               /*!< UART_T::FSR: BIF Mask                   */
N
N#define UART_FSR_FEF_Pos            5                                       /*!< UART_T::FSR: FEF Position               */
N#define UART_FSR_FEF_Msk            (1ul << UART_FSR_FEF_Pos)               /*!< UART_T::FSR: FEF Mask                   */
N
N#define UART_FSR_PEF_Pos            4                                       /*!< UART_T::FSR: PEF Position               */
N#define UART_FSR_PEF_Msk            (1ul << UART_FSR_PEF_Pos)               /*!< UART_T::FSR: PEF Mask                   */
N
N#define UART_FSR_RS485_ADD_DETF_Pos 3                                       /*!< UART_T::FSR: RS485_ADD_DETF Position    */
N#define UART_FSR_RS485_ADD_DETF_Msk (1ul << UART_FSR_RS485_ADD_DETF_Pos)    /*!< UART_T::FSR: RS485_ADD_DETF Mask        */
N
N#define UART_FSR_RX_OVER_IF_Pos     0                                       /*!< UART_T::FSR: RX_OVER_IF Position        */
N#define UART_FSR_RX_OVER_IF_Msk     (1ul << UART_FSR_RX_OVER_IF_Pos)        /*!< UART_T::FSR: RX_OVER_IF Mask            */
N
N/* UART ISR Bit Field Definitions */
N#define UART_ISR_HW_BUF_ERR_INT_Pos 29                                      /*!< UART_T::ISR: HW BUF_ERR_INT Position    */
N#define UART_ISR_HW_BUF_ERR_INT_Msk (1ul << UART_ISR_HW_BUF_ERR_INT_Pos)    /*!< UART_T::ISR: HW BUF_ERR_INT Mask        */
N
N#define UART_ISR_HW_TOUT_INT_Pos    28                                      /*!< UART_T::ISR: HW TOUT_INT Position       */
N#define UART_ISR_HW_TOUT_INT_Msk    (1ul << UART_ISR_HW_TOUT_INT_Pos)       /*!< UART_T::ISR: HW TOUT_INT Mask           */
N
N#define UART_ISR_HW_MODEM_INT_Pos   27                                      /*!< UART_T::ISR: HW MODEM_INT Position      */
N#define UART_ISR_HW_MODEM_INT_Msk   (1ul << UART_ISR_HW_MODEM_INT_Pos)      /*!< UART_T::ISR: HW MODEM_INT Mask          */
N
N#define UART_ISR_HW_RLS_INT_Pos     26                                      /*!< UART_T::ISR: HW RLS_INT Position        */
N#define UART_ISR_HW_RLS_INT_Msk     (1ul << UART_ISR_HW_RLS_INT_Pos)        /*!< UART_T::ISR: HW RLS_INT Position        */
N
N#define UART_ISR_HW_BUF_ERR_IF_Pos  21                                      /*!< UART_T::ISR: HW BUF_ERR_IF Position     */
N#define UART_ISR_HW_BUF_ERR_IF_Msk  (1ul << UART_ISR_HW_BUF_ERR_IF_Pos)     /*!< UART_T::ISR: HW BUF_ERR_IF Mask         */
N
N#define UART_ISR_HW_TOUT_IF_Pos     20                                      /*!< UART_T::ISR: HW TOUT_IF Position        */
N#define UART_ISR_HW_TOUT_IF_Msk     (1ul << UART_ISR_HW_TOUT_IFF_Pos)       /*!< UART_T::ISR: HW TOUT_IF Mask            */
N
N#define UART_ISR_HW_MODEM_IF_Pos    19                                      /*!< UART_T::ISR: HW MODEM_IF Position       */
N#define UART_ISR_HW_MODEM_IF_Msk    (1ul << UART_ISR_HW_MODEM_IF_Pos)       /*!< UART_T::ISR: HW MODEM_IF Mask           */
N
N#define UART_ISR_HW_RLS_IF_Pos      18                                      /*!< UART_T::ISR: HW RLS_IF Position         */
N#define UART_ISR_HW_RLS_IF_Msk      (1ul << UART_ISR_HW_RLS_IF_Pos)         /*!< UART_T::ISR: HW RLS_IF Mark             */
N
N#define UART_ISR_LIN_INT_Pos        15                                      /*!< UART_T::ISR: LIN_INT Position           */
N#define UART_ISR_LIN_INT_Msk        (1ul << UART_ISR_LIN_INT_Pos)           /*!< UART_T::ISR: LIN_INT Mask               */
N
N#define UART_ISR_BUF_ERR_INT_Pos    13                                      /*!< UART_T::ISR: BUF_ERR_INT Position       */
N#define UART_ISR_BUF_ERR_INT_Msk    (1ul << UART_ISR_BUF_ERR_INT_Pos)       /*!< UART_T::ISR: BUF_ERR_INT Mask           */
N
N#define UART_ISR_TOUT_INT_Pos       12                                      /*!< UART_T::ISR: TOUT_INT Position          */
N#define UART_ISR_TOUT_INT_Msk       (1ul << UART_ISR_TOUT_INT_Pos)          /*!< UART_T::ISR: TOUT_INT Mask              */
N
N#define UART_ISR_MODEM_INT_Pos      11                                      /*!< UART_T::ISR: MODEM_INT Position         */
N#define UART_ISR_MODEM_INT_Msk      (1ul << UART_ISR_MODEM_INT_Pos)         /*!< UART_T::ISR: MODEM_INT Mask             */
N
N#define UART_ISR_RLS_INT_Pos        10                                      /*!< UART_T::ISR: RLS_INT Position           */
N#define UART_ISR_RLS_INT_Msk        (1ul << UART_ISR_RLS_INT_Pos)           /*!< UART_T::ISR: RLS_INT Mask               */
N
N#define UART_ISR_THRE_INT_Pos       9                                       /*!< UART_T::ISR: THRE_INT Position          */
N#define UART_ISR_THRE_INT_Msk       (1ul << UART_ISR_THRE_INT_Pos)          /*!< UART_T::ISR: THRE_INT Mask              */
N
N#define UART_ISR_RDA_INT_Pos        8                                       /*!< UART_T::ISR: RDA_INT Position           */
N#define UART_ISR_RDA_INT_Msk        (1ul << UART_ISR_RDA_INT_Pos)           /*!< UART_T::ISR: RDA_INT Mask               */
N
N#define UART_ISR_LIN_IF_Pos         7                                       /*!< UART_T::ISR: LIN RX_IF Position         */
N#define UART_ISR_LIN_IF_Msk         (1ul << UART_ISR_LIN_IF_Pos)            /*!< UART_T::ISR: LIN RX_IF Mask             */
N
N#define UART_ISR_BUF_ERR_IF_Pos     5                                       /*!< UART_T::ISR: BUF_ERR_IF Position        */
N#define UART_ISR_BUF_ERR_IF_Msk     (1ul << UART_ISR_BUF_ERR_IF_Pos)        /*!< UART_T::ISR: BUF_ERR_IF Mask            */
N
N#define UART_ISR_TOUT_IF_Pos        4                                       /*!< UART_T::ISR: TOUT_IF Position           */
N#define UART_ISR_TOUT_IF_Msk        (1ul << UART_ISR_TOUT_IF_Pos)           /*!< UART_T::ISR: TOUT_IF Mask               */
N
N#define UART_ISR_MODEM_IF_Pos       3                                       /*!< UART_T::ISR: MODEM_IF Position          */
N#define UART_ISR_MODEM_IF_Msk       (1ul << UART_ISR_MODEM_IF_Pos)          /*!< UART_T::ISR: MODEM_IF Mask              */
N
N#define UART_ISR_RLS_IF_Pos         2                                       /*!< UART_T::ISR: RLS_IF Position            */
N#define UART_ISR_RLS_IF_Msk         (1ul << UART_ISR_RLS_IF_Pos)            /*!< UART_T::ISR: RLS_IF Mask                */
N
N#define UART_ISR_THRE_IF_Pos        1                                       /*!< UART_T::ISR: THRE_IF Position           */
N#define UART_ISR_THRE_IF_Msk        (1ul << UART_ISR_THRE_IF_Pos)           /*!< UART_T::ISR: THRE_IF Mask               */
N
N#define UART_ISR_RDA_IF_Pos         0                                       /*!< UART_T::ISR: RDA_IF Position            */
N#define UART_ISR_RDA_IF_Msk         (1ul << UART_ISR_RDA_IF_Pos)            /*!< UART_T::ISR: RDA_IF Mask                */
N
N
N/* UART TOR Bit Field Definitions */
N#define UART_TOR_DLY_Pos           8                                        /*!< UART_T::TOR: DLY Position               */
N#define UART_TOR_DLY_Msk           (0xFFul << UART_TOR_DLY_Pos)             /*!< UART_T::TOR: DLY Mask                   */
N
N#define UART_TOR_TOIC_Pos          0                                        /*!< UART_T::TOR: TOIC Position              */
N#define UART_TOR_TOIC_Msk          (0xFFul << UART_TOR_TOIC_Pos)
N
N/* UART BAUD Bit Field Definitions */
N#define UART_BAUD_DIV_X_EN_Pos    29                                        /*!< UART_T::BAUD: DIV_X_EN Position         */
N#define UART_BAUD_DIV_X_EN_Msk    (1ul << UART_BAUD_DIV_X_EN_Pos)           /*!< UART_T::BAUD: DIV_X_EN Mask             */
N
N#define UART_BAUD_DIV_X_ONE_Pos   28                                        /*!< UART_T::BAUD: DIV_X_ONE Position        */
N#define UART_BAUD_DIV_X_ONE_Msk   (1ul << UART_BAUD_DIV_X_ONE_Pos)          /*!< UART_T::BAUD: DIV_X_ONE Mask            */
N
N#define UART_BAUD_DIVIDER_X_Pos   24                                        /*!< UART_T::BAUD: DIVIDER_X Position        */
N#define UART_BAUD_DIVIDER_X_Msk   (0xFul << UART_BAUD_DIVIDER_X_Pos)        /*!< UART_T::BAUD: DIVIDER_X Mask            */
N
N#define UART_BAUD_BRD_Pos         0                                         /*!< UART_T::BAUD: BRD Position              */
N#define UART_BAUD_BRD_Msk         (0xFFFFul << UART_BAUD_BRD_Pos)           /*!< UART_T::BAUD: BRD Mask                  */
N
N/* UART IRCR Bit Field Definitions */
N#define UART_IRCR_INV_RX_Pos      6                                         /*!< UART_T::IRCR: INV_RX Position           */
N#define UART_IRCR_INV_RX_Msk     (1ul << UART_IRCR_INV_RX_Pos)              /*!< UART_T::IRCR: INV_RX Mask               */
N
N#define UART_IRCR_INV_TX_Pos      5                                         /*!< UART_T::IRCR: INV_TX Position           */
N#define UART_IRCR_INV_TX_Msk     (1ul << UART_IRCR_INV_TX_Pos)              /*!< UART_T::IRCR: INV_TX Mask               */
N
N#define UART_IRCR_TX_SELECT_Pos   1                                         /*!< UART_T::IRCR: TX_SELECT Position        */
N#define UART_IRCR_TX_SELECT_Msk   (1ul << UART_IRCR_TX_SELECT_Pos)          /*!< UART_T::IRCR: TX_SELECT Mask            */
N
N/* UART ALT_CSR Bit Field Definitions */
N#define UART_ALT_CSR_ADDR_MATCH_Pos      24                                      /*!< UART_T::ALT_CSR: ADDR_MATCH Position    */
N#define UART_ALT_CSR_ADDR_MATCH_Msk     (0xFFul << UART_ALT_CSR_ADDR_MATCH_Pos)  /*!< UART_T::ALT_CSR: ADDR_MATCH Mask        */
N
N#define UART_ALT_CSR_RS485_ADD_EN_Pos   15                                       /*!< UART_T::ALT_CSR: RS485_ADD_EN Position  */
N#define UART_ALT_CSR_RS485_ADD_EN_Msk   (1ul << UART_ALT_CSR_RS485_ADD_EN_Pos)   /*!< UART_T::ALT_CSR: RS485_ADD_EN Mask      */
N
N#define UART_ALT_CSR_RS485_AUD_Pos      10                                       /*!< UART_T::ALT_CSR: RS485_AUD Position     */
N#define UART_ALT_CSR_RS485_AUD_Msk      (1ul << UART_ALT_CSR_RS485_AUD_Pos)      /*!< UART_T::ALT_CSR: RS485_AUD Mask         */
N
N#define UART_ALT_CSR_RS485_AAD_Pos      9                                        /*!< UART_T::ALT_CSR: RS485_AAD Position     */
N#define UART_ALT_CSR_RS485_AAD_Msk      (1ul << UART_ALT_CSR_RS485_AAD_Pos)      /*!< UART_T::ALT_CSR: RS485_AAD Mask         */
N
N#define UART_ALT_CSR_RS485_NMM_Pos      8                                        /*!< UART_T::ALT_CSR: RS485_NMM Position     */
N#define UART_ALT_CSR_RS485_NMM_Msk      (1ul << UART_ALT_CSR_RS485_NMM_Pos)      /*!< UART_T::ALT_CSR: RS485_NMM Mask         */
N
N#define UART_ALT_CSR_LIN_TX_EN_Pos      7                                        /*!< UART_T::ALT_CSR: LIN TX Break Mode Enable Position     */
N#define UART_ALT_CSR_LIN_TX_EN_Msk      (1ul << UART_ALT_CSR_LIN_TX_EN_Pos)      /*!< UART_T::ALT_CSR: LIN TX Break Mode Enable Mask         */
N
N#define UART_ALT_CSR_LIN_RX_EN_Pos      6                                        /*!< UART_T::ALT_CSR: LIN RX Enable Position     */
N#define UART_ALT_CSR_LIN_RX_EN_Msk      (1ul << UART_ALT_CSR_LIN_RX_EN_Pos)      /*!< UART_T::ALT_CSR: LIN RX Enable Mask         */
N
N#define UART_ALT_CSR_UA_LIN_BKFL_Pos    0                                        /*!< UART_T::ALT_CSR: UART LIN Break Field Length Position     */
N#define UART_ALT_CSR_UA_LIN_BKFL_Msk    (0xFul << UART_ALT_CSR_UA_LIN_BKFL_Pos)  /*!< UART_T::ALT_CSR: UART LIN Break Field Length Mask         */
N
N/* UART FUN_SEL Bit Field Definitions */
N#define UART_FUN_SEL_FUN_SEL_Pos        0                                        /*!< UART_T::FUN_SEL: FUN_SEL Position       */
N#define UART_FUN_SEL_FUN_SEL_Msk       (0x3ul << UART_FUN_SEL_FUN_SEL_Pos)       /*!< UART_T::FUN_SEL: FUN_SEL Mask           */
N
N/* UART LIN_CTL Bit Field Definitions */
N#define UART_LIN_CTL_LIN_PID_Pos        24                                        /*!< UART_T::LIN_CTL: LIN_PID Position       */
N#define UART_LIN_CTL_LIN_PID_Msk        (0xFFul << UART_LIN_CTL_LIN_PID_Pos)      /*!< UART_T::LIN_CTL: LIN_PID Mask           */
N
N#define UART_LIN_CTL_LIN_HEAD_SEL_Pos   22                                        /*!< UART_T::LIN_CTL: LIN_HEAD_SEL Position       */
N#define UART_LIN_CTL_LIN_HEAD_SEL_Msk   (0x3ul << UART_LIN_CTL_LIN_HEAD_SEL_Pos)  /*!< UART_T::LIN_CTL: LIN_HEAD_SEL Mask           */
N
N#define UART_LIN_CTL_LIN_BS_LEN_Pos     20                                        /*!< UART_T::LIN_CTL: LIN_BS_LEN Position       */
N#define UART_LIN_CTL_LIN_BS_LEN_Msk     (0x3ul << UART_LIN_CTL_LIN_BS_LEN_Pos)    /*!< UART_T::LIN_CTL: LIN_BS_LEN Mask           */
N
N#define UART_LIN_CTL_LIN_BKFL_Pos       16                                        /*!< UART_T::LIN_CTL: LIN_BKFL Position       */
N#define UART_LIN_CTL_LIN_BKFL_Msk       (0xFul << UART_LIN_CTL_LIN_BKFL_Pos)      /*!< UART_T::LIN_CTL: LIN_BKFL Mask           */
N
N#define UART_LIN_CTL_BIT_ERR_EN_Pos     12                                        /*!< UART_T::LIN_CTL: BIT_ERR_EN Position       */
N#define UART_LIN_CTL_BIT_ERR_EN_Msk     (1ul << UART_LIN_CTL_BIT_ERR_EN_Pos)      /*!< UART_T::LIN_CTL: BIT_ERR_EN Mask           */
N
N#define UART_LIN_CTL_LIN_RX_DIS_Pos     11                                        /*!< UART_T::LIN_CTL: LIN_RX_DIS Position       */
N#define UART_LIN_CTL_LIN_RX_DIS_Msk     (1ul << UART_LIN_CTL_LIN_RX_DIS_Pos)      /*!< UART_T::LIN_CTL: LIN_RX_DIS Mask           */
N
N#define UART_LIN_CTL_LIN_BKDET_EN_Pos   10                                        /*!< UART_T::LIN_CTL: LIN_BKDET_EN Position       */
N#define UART_LIN_CTL_LIN_BKDET_EN_Msk   (1ul << UART_LIN_CTL_LIN_BKDET_EN_Pos)    /*!< UART_T::LIN_CTL: LIN_BKDET_EN Mask           */
N
N#define UART_LIN_CTL_LIN_IDPEN_Pos      9                                         /*!< UART_T::LIN_CTL: LIN_IDPEN Position       */
N#define UART_LIN_CTL_LIN_IDPEN_Msk      (1ul << UART_LIN_CTL_LIN_IDPEN_Pos)       /*!< UART_T::LIN_CTL: LIN_IDPEN Mask           */
N
N#define UART_LIN_CTL_LIN_SHD_Pos        8                                         /*!< UART_T::LIN_CTL: LIN_SHD Position       */
N#define UART_LIN_CTL_LIN_SHD_Msk        (1ul << UART_LIN_CTL_LIN_SHD_Pos)         /*!< UART_T::LIN_CTL: LIN_SHD Mask           */
N
N#define UART_LIN_CTL_LIN_MUTE_EN_Pos    4                                          /*!< UART_T::LIN_CTL: LIN_MUTE_EN Position       */
N#define UART_LIN_CTL_LIN_MUTE_EN_Msk    (1ul << UART_LIN_CTL_LIN_MUTE_EN_Pos)      /*!< UART_T::LIN_CTL: LIN_MUTE_EN Mask           */
N
N#define UART_LIN_CTL_LINS_DUM_EN_Pos    3                                          /*!< UART_T::LIN_CTL: LINS_DUM_EN Position       */
N#define UART_LIN_CTL_LINS_DUM_EN_Msk    (1ul << UART_LIN_CTL_LINS_DUM_EN_Pos)      /*!< UART_T::LIN_CTL: LINS_DUM_EN Mask           */
N
N#define UART_LIN_CTL_LINS_ARS_EN_Pos    2                                          /*!< UART_T::LIN_CTL: LINS_ARS_EN Position       */
N#define UART_LIN_CTL_LINS_ARS_EN_Msk    (1ul << UART_LIN_CTL_LINS_ARS_EN_Pos)      /*!< UART_T::LIN_CTL: LINS_ARS_EN Mask           */
N
N#define UART_LIN_CTL_LINS_HDET_EN_Pos   1                                          /*!< UART_T::LIN_CTL: LINS_HDET_EN Position       */
N#define UART_LIN_CTL_LINS_HDET_EN_Msk   (1ul << UART_LIN_CTL_LINS_HDET_EN_Pos)     /*!< UART_T::LIN_CTL: LINS_HDET_EN Mask           */
N
N#define UART_LIN_CTL_LINS_EN_Pos        0                                          /*!< UART_T::LIN_CTL: LINS_EN Position       */
N#define UART_LIN_CTL_LINS_EN_Msk        (1ul << UART_LIN_CTL_LINS_EN_Pos)          /*!< UART_T::LIN_CTL: LINS_EN Mask           */
N
N/* UART LIN_SR Bit Field Definitions */
N#define UART_LIN_SR_BIT_ERR_F_Pos       9                                           /*!< UART_T::LIN_SR: BIT_ERR_F Position         */
N#define UART_LIN_SR_BIT_ERR_F_Msk       (1ul << UART_LIN_SR_BIT_ERR_F_Pos)          /*!< UART_T::LIN_SR: BIT_ERR_F Mask             */
N
N#define UART_LIN_SR_LINS_BKDET_F_Pos    8                                           /*!< UART_T::LIN_SR: LINS_BKDET_F Position      */
N#define UART_LIN_SR_LINS_BKDET_F_Msk    (1ul << UART_LIN_SR_LINS_BKDET_F_Pos)       /*!< UART_T::LIN_SR: LINS_BKDET_F Mask          */
N
N#define UART_LIN_SR_LINS_SYNC_F_Pos     3                                           /*!< UART_T::LIN_SR: LINS_SYNC_F Position       */
N#define UART_LIN_SR_LINS_SYNC_F_Msk     (1ul << UART_LIN_SR_LINS_SYNC_F_Pos)        /*!< UART_T::LIN_SR: LINS_SYNC_F Mask           */
N
N#define UART_LIN_SR_LINS_IDPERR_F_Pos   2                                           /*!< UART_T::LIN_SR: LINS_IDPERR_F Position     */
N#define UART_LIN_SR_LINS_IDPERR_F_Msk   (1ul << UART_LIN_SR_LINS_IDPERR_F_Pos)      /*!< UART_T::LIN_SR: LINS_IDPERR_F Mask         */
N
N#define UART_LIN_SR_LINS_HERR_F_Pos     1                                           /*!< UART_T::LIN_SR: LINS_HERR_F Position       */
N#define UART_LIN_SR_LINS_HERR_F_Msk     (1ul << UART_LIN_SR_LINS_HERR_F_Pos)        /*!< UART_T::LIN_SR: LINS_HERR_F Mask           */
N
N#define UART_LIN_SR_LINS_HDET_F_Pos     0                                           /*!< UART_T::LIN_SR: LINS_HDET_F Position       */
N#define UART_LIN_SR_LINS_HDET_F_Msk     (1ul << UART_LIN_SR_LINS_HDET_F_Pos)        /*!< UART_T::LIN_SR: LINS_HDET_F Mask           */
N
N/*@}*/ /* end of group UART_CONST */
N/*@}*/ /* end of group UART */
N
N
N/*---------------------- Universal Serial Bus Device Controller -------------------------*/
N/**
N    @addtogroup USBD Universal Serial Bus Device Controller (USBD)
N    Memory Mapped Structure for USBD Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N/**
N * @var USBD_EP_T::BUFSEG
N * Offset: 0x500/0x510/0x520/0x530/0x540/0x550/0x560/0x570  Endpoint 0~7 Buffer Segmentation Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[8:3]   |BUFSEG    |Endpoint Buffer Segmentation
N * |        |          |It is used to indicate the offset address for each endpoint with the USB SRAM starting address
N * |        |          |The effective starting address of the endpoint is
N * |        |          |USB_SRAM address + { BUFSEG[8:3], 3'b000}
N * |        |          |Where the USB_SRAM address = USBD_BA+0x100h.
N * |        |          |Refer to the section 5.4.4.7 for the endpoint SRAM structure and its description.
N * @var USBD_EP_T::MXPLD
N * Offset: 0x504/0x514/0x524/0x534/0x544/0x554/0x564/0x574  Endpoint 0~7 Maximal Payload Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[8:0]   |MXPLD     |Maximal Payload
N * |        |          |Define the data length which is transmitted to host (IN token) or the actual data length which
N * |        |          |is received from the host (OUT token).
N * |        |          |It also used to indicate that the endpoint is ready to be transmitted in IN token or received in
N * |        |          |OUT token.
N * |        |          |(1) When the register is written by CPU,
N * |        |          |For IN token, the value of MXPLD is used to define the data length to be transmitted and
N * |        |          |indicate the data buffer is ready.
N * |        |          |For OUT token, it means that the controller is ready to receive data from the host and the value
N * |        |          |of MXPLD is the maximal data length comes from host.
N * |        |          |(2) When the register is read by CPU,
N * |        |          |For IN token, the value of MXPLD is indicated by the data length be transmitted to host
N * |        |          |For OUT token, the value of MXPLD is indicated the actual data length receiving from host.
N * |        |          |Note: Once MXPLD is written, the data packets will be transmitted/received immediately after
N * |        |          |IN/OUT token arrived.
N * @var USBD_EP_T::CFG
N * Offset: 0x508/0x518/0x528/0x538/0x548/0x558/0x568/0x578  Endpoint 0~7 Configuration Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[3:0]   |EP_NUM    |Endpoint Number
N * |        |          |These bits are used to define the endpoint number of the current endpoint.
N * |[4]     |ISOCH     |Isochronous Endpoint
N * |        |          |This bit is used to set the endpoint as Isochronous endpoint, no handshake.
N * |        |          |0 = No Isochronous endpoint.
N * |        |          |1 = Isochronous endpoint.
N * |[6:5]   |STATE     |Endpoint STATE
N * |        |          |00 = Endpoint is Disabled.
N * |        |          |01 = Out endpoint.
N * |        |          |10 = IN endpoint.
N * |        |          |11 = Undefined.
N * |[7]     |DSQ_SYNC  |Data Sequence Synchronization
N * |        |          |0 = DATA0 PID.
N * |        |          |1 = DATA1 PID.
N * |        |          |Note: It is used to specify the DATA0 or DATA1 PID in the following IN token transaction.
N * |        |          |Hardware will toggle automatically in IN token base on the bit.
N * |[9]     |CSTALL    |Clear STALL Response
N * |        |          |0 = Disable the device to clear the STALL handshake in setup stage.
N * |        |          |1 = Clear the device to response STALL handshake in setup stage.
N * @var USBD_EP_T::CFGP
N * Offset: 0x50C/0x51C/0x52C/0x53C/0x54C/0x55C/0x56C/0x57C  Endpoint 0~7 Set Stall and Clear In/Out Ready Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |CLRRDY    |Clear Ready
N * |        |          |When the USB_MXPLD register is set by user, it means that the endpoint is ready to transmit or
N * |        |          |receive data.
N * |        |          |If the user wants to turn off this transaction before the transaction start, users can set this
N * |        |          |bit to 1 to turn it off and it will be cleared to 0 automatically.
N * |        |          |For IN token, write '1' to clear the IN token had ready to transmit the data to USB.
N * |        |          |For OUT token, write '1' to clear the OUT token had ready to receive the data from USB.
N * |        |          |This bit is write 1 only and is always 0 when it is read back.
N * |[1]     |SSTALL    |Set STALL
N * |        |          |0 = Disable the device to response STALL.
N * |        |          |1 = Set the device to respond STALL automatically.
N */
N
N    __IO uint32_t BUFSEG;        /* Offset: 0x500/0x510/0x520/0x530/0x540/0x550/0x560/0x570  Endpoint 0~7 Buffer Segmentation Register */
X    volatile uint32_t BUFSEG;         
N    __IO uint32_t MXPLD;         /* Offset: 0x504/0x514/0x524/0x534/0x544/0x554/0x564/0x574  Endpoint 0~7 Maximal Payload Register */
X    volatile uint32_t MXPLD;          
N    __IO uint32_t CFG;           /* Offset: 0x508/0x518/0x528/0x538/0x548/0x558/0x568/0x578  Endpoint 0~7 Configuration Register */
X    volatile uint32_t CFG;            
N    __IO uint32_t CFGP;          /* Offset: 0x50C/0x51C/0x52C/0x53C/0x54C/0x55C/0x56C/0x57C  Endpoint 0~7 Set Stall and Clear In/Out Ready Control Register */
X    volatile uint32_t CFGP;           
N
N} USBD_EP_T;
N
N
N
N
N
N
Ntypedef struct
N{
N
N
N/**
N * @var USBD_T::INTEN
N * Offset: 0x00  USB Interrupt Enable Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |BUS_IE    |Bus Event Interrupt Enable
N * |        |          |0 = BUS event interrupt Disabled.
N * |        |          |1 = BUS event interrupt Enabled.
N * |[1]     |USB_IE    |USB Event Interrupt Enable
N * |        |          |0 = USB event interrupt Disabled.
N * |        |          |1 = USB event interrupt Enabled.
N * |[2]     |FLDET_IE  |Floating Detection Interrupt Enable
N * |        |          |0 = Floating detection Interrupt Disabled.
N * |        |          |1 = Floating detection Interrupt Enabled.
N * |[3]     |WAKEUP_IE |USB Wake-Up Interrupt Enable
N * |        |          |0 = Wake-up Interrupt Disabled.
N * |        |          |1 = Wake-up Interrupt Enabled.
N * |[8]     |WAKEUP_EN |Wake-Up Function Enable
N * |        |          |0 = USB wake-up function Disabled.
N * |        |          |1 = USB wake-up function Enabled.
N * |[15]    |INNAK_EN  |Active NAK Function And Its Status In IN Token
N * |        |          |0 = When device responds NAK after receiving IN token, IN NAK status will not be
N * |        |          |    updated to USBD_EPSTS register, so that the USB interrupt event will not be asserted.
N * |        |          |1 = IN NAK status will be updated to USBD_EPSTS register and the USB interrupt event
N * |        |          |    will be asserted, when the device responds NAK after receiving IN token.
N * @var USBD_T::INTSTS
N * Offset: 0x04  USB Interrupt Event Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |BUS_STS   |BUS Interrupt Status
N * |        |          |The BUS event means that there is one of the suspense or the resume function in the bus.
N * |        |          |0 = No BUS event occurred.
N * |        |          |1 = Bus event occurred; check USB_ATTR[3:0] to know which kind of bus event was occurred,
N * |        |          |cleared by write 1 to USB_INTSTS[0].
N * |[1]     |USB_STS   |USB Event Interrupt Status
N * |        |          |The USB event includes the SETUP Token, IN Token, OUT ACK, ISO IN, or ISO OUT events in the bus.
N * |        |          |0 = No USB event occurred.
N * |        |          |1 = USB event occurred, check EPSTS0~7 to know which kind of USB event occurred.
N * |        |          |Cleared by write 1 to USB_INTSTS[1] or EPEVT0~7 and SETUP (USB_INTSTS[31]).
N * |[2]     |FLDET_STS |Floating Detection Interrupt Status
N * |        |          |0 = There is not attached/detached event in the USB.
N * |        |          |1 = There is attached/detached event in the USB bus and it is cleared by write 1 to
N * |        |          |USB_INTSTS[2].
N * |[3]     |WAKEUP_STS|Wake-Up Interrupt Status
N * |        |          |0 = No Wake-up event occurred.
N * |        |          |1 = Wake-up event occurred, cleared by write 1 to USB_INTSTS[3].
N * |[16]    |EPEVT0    |Endpoint 0's USB Event Status
N * |        |          |0 = No event occurred on endpoint 0.
N * |        |          |1 = USB event occurred on Endpoint 0, check USB_EPSTS[10:8] to know which kind of USB event was
N * |        |          |occurred, cleared by write 1 to USB_INTSTS[16] or USB_INTSTS[1].
N * |[17]    |EPEVT1    |Endpoint 1's USB Event Status
N * |        |          |0 = No event occurred on endpoint 1.
N * |        |          |1 = USB event occurred on Endpoint 1, check USB_EPSTS[13:11] to know which kind of USB event was
N * |        |          |occurred, cleared by write 1 to USB_INTSTS[17] or USB_INTSTS[1].
N * |[18]    |EPEVT2    |Endpoint 2's USB Event Status
N * |        |          |0 = No event occurred on endpoint 2.
N * |        |          |1 = USB event occurred on Endpoint 2, check USB_EPSTS[16:14] to know which kind of USB event was
N * |        |          |occurred, cleared by write 1 to USB_INTSTS[18] or USB_INTSTS[1].
N * |[19]    |EPEVT3    |Endpoint 3's USB Event Status
N * |        |          |0 = No event occurred on endpoint 3.
N * |        |          |1 = USB event occurred on Endpoint 3, check USB_EPSTS[19:17] to know which kind of USB event was
N * |        |          |occurred, cleared by write 1 to USB_INTSTS[19] or USB_INTSTS[1].
N * |[20]    |EPEVT4    |Endpoint 4's USB Event Status
N * |        |          |0 = No event occurred on endpoint 4.
N * |        |          |1 = USB event occurred on Endpoint 4, check USB_EPSTS[22:20] to know which kind of USB event was
N * |        |          |occurred, cleared by write 1 to USB_INTSTS[20] or USB_INTSTS[1].
N * |[21]    |EPEVT5    |Endpoint 5's USB Event Status
N * |        |          |0 = No event occurred on endpoint 5.
N * |        |          |1 = USB event occurred on Endpoint 5, check USB_EPSTS[25:23] to know which kind of USB event was
N * |        |          |occurred, cleared by write 1 to USB_INTSTS[21] or USB_INTSTS[1].
N * |[22]    |EPEVT6    |Endpoint 6's USB Event Status
N * |        |          |0 = No event occurred on endpoint 6.
N * |        |          |1 = USB event occurred on Endpoint 6, check USB_EPSTS[28:26] to know which kind of USB event was
N * |        |          |occurred, cleared by write 1 to USB_INTSTS[22] or USB_INTSTS[1].
N * |[23]    |EPEVT7    |Endpoint 7's USB Event Status
N * |        |          |0 = No event occurred on endpoint 7.
N * |        |          |1 = USB event occurred on Endpoint 7, check USB_EPSTS[31:29] to know which kind of USB event was
N * |        |          |occurred, cleared by write 1 to USB_INTSTS[23] or USB_INTSTS[1].
N * |[31]    |SETUP     |Setup Event Status
N * |        |          |0 = No Setup event.
N * |        |          |1 = SETUP event occurred, cleared by write 1 to USB_INTSTS[31].
N * @var USBD_T::FADDR
N * Offset: 0x08  USB Device Function Address Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[6:0]   |FADDR     |USB Device Function Address
N * @var USBD_T::EPSTS
N * Offset: 0x0C  USB Endpoint Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[7]     |OVERRUN   |Overrun
N * |        |          |It indicates that the received data is over the maximum payload number or not.
N * |        |          |0 = No overrun.
N * |        |          |1 = Out Data is more than the Max Payload in MXPLD register or the Setup Data is more than 8
N * |        |          |Bytes.
N * |[10:8]  |EPSTS0    |Endpoint 0 Bus Status
N * |        |          |These bits are used to indicate the current status of this endpoint
N * |        |          |000 = In ACK.
N * |        |          |001 = In NAK.
N * |        |          |010 = Out Packet Data0 ACK.
N * |        |          |110 = Out Packet Data1 ACK.
N * |        |          |011 = Setup ACK.
N * |        |          |111 = Isochronous transfer end.
N * |[13:11] |EPSTS1    |Endpoint 1 Bus Status
N * |        |          |These bits are used to indicate the current status of this endpoint
N * |        |          |000 = In ACK.
N * |        |          |001 = In NAK.
N * |        |          |010 = Out Packet Data0 ACK.
N * |        |          |110 = Out Packet Data1 ACK.
N * |        |          |011 = Setup ACK.
N * |        |          |111 = Isochronous transfer end.
N * |[16:14] |EPSTS2    |Endpoint 2 Bus Status
N * |        |          |These bits are used to indicate the current status of this endpoint
N * |        |          |000 = In ACK.
N * |        |          |001 = In NAK.
N * |        |          |010 = Out Packet Data0 ACK.
N * |        |          |110 = Out Packet Data1 ACK.
N * |        |          |011 = Setup ACK.
N * |        |          |111 = Isochronous transfer end.
N * |[19:17] |EPSTS3    |Endpoint 3 Bus Status
N * |        |          |These bits are used to indicate the current status of this endpoint
N * |        |          |000 = In ACK.
N * |        |          |001 = In NAK.
N * |        |          |010 = Out Packet Data0 ACK.
N * |        |          |110 = Out Packet Data1 ACK.
N * |        |          |011 = Setup ACK.
N * |        |          |111 = Isochronous transfer end.
N * |[22:20] |EPSTS4    |Endpoint 4 Bus Status
N * |        |          |These bits are used to indicate the current status of this endpoint
N * |        |          |000 = In ACK.
N * |        |          |001 = In NAK.
N * |        |          |010 = Out Packet Data0 ACK.
N * |        |          |110 = Out Packet Data1 ACK.
N * |        |          |011 = Setup ACK.
N * |        |          |111 = Isochronous transfer end.
N * |[25:23] |EPSTS5    |Endpoint 5 Bus Status
N * |        |          |These bits are used to indicate the current status of this endpoint
N * |        |          |000 = In ACK.
N * |        |          |001 = In NAK.
N * |        |          |010 = Out Packet Data0 ACK.
N * |        |          |110 = Out Packet Data1 ACK.
N * |        |          |011 = Setup ACK.
N * |        |          |111 = Isochronous transfer end.
N * |[28:26] |EPSTS6    |Endpoint 6 Bus Status
N * |        |          |These bits are used to indicate the current status of this endpoint
N * |        |          |000 = In ACK.
N * |        |          |001 = In NAK.
N * |        |          |010 = Out Packet Data0 ACK.
N * |        |          |110 = Out Packet Data1 ACK.
N * |        |          |011 = Setup ACK.
N * |        |          |111 = Isochronous transfer end.
N * |[31:29] |EPSTS7    |Endpoint 7 Bus Status
N * |        |          |These bits are used to indicate the current status of this endpoint
N * |        |          |000 = In ACK.
N * |        |          |001 = In NAK.
N * |        |          |010 = Out Packet Data0 ACK.
N * |        |          |110 = Out Packet Data1 ACK.
N * |        |          |011 = Setup ACK.
N * |        |          |111 = Isochronous transfer end.
N * @var USBD_T::ATTR
N * Offset: 0x10  USB Bus Status and Attribution Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |USBRST    |USB Reset Status
N * |        |          |0 = Bus no reset.
N * |        |          |1 = Bus reset when SE0 (single-ended 0) is presented more than 2.5us.
N * |        |          |Note: This bit is read only.
N * |[1]     |SUSPEND   |Suspend Status
N * |        |          |0 = Bus no suspend.
N * |        |          |1 = Bus idle more than 3ms, either cable is plugged off or host is sleeping.
N * |        |          |Note: This bit is read only.
N * |[2]     |RESUME    |Resume Status
N * |        |          |0 = No bus resume.
N * |        |          |1 = Resume from suspend.
N * |        |          |Note: This bit is read only.
N * |[3]     |TIMEOUT   |Time-Out Status
N * |        |          |0 = No time-out.
N * |        |          |1 = No Bus response more than 18 bits time.
N * |        |          |Note: This bit is read only.
N * |[4]     |PHY_EN    |PHY Transceiver Function Enable
N * |        |          |0 = PHY transceiver function Disabled.
N * |        |          |1 = PHY transceiver function Enabled.
N * |[5]     |RWAKEUP   |Remote Wake-Up
N * |        |          |0 = Release the USB bus from K state.
N * |        |          |1 = Force USB bus to K (USB_D+ low, USB_D- high) state, used for remote wake-up.
N * |[7]     |USB_EN    |USB Controller Enable
N * |        |          |0 = USB Controller Disabled.
N * |        |          |1 = USB Controller Enabled.
N * |[8]     |DPPU_EN   |Pull-Up Resistor On USB_D+ Enable
N * |        |          |0 = Pull-up resistor in USB_D+ pin Disabled.
N * |        |          |1 = Pull-up resistor in USB_D+ pin Enabled.
N * |[9]     |PWRDN     |Power-Down PHY Transceiver, Low Active
N * |        |          |0 = Power-down related circuit of PHY transceiver.
N * |        |          |1 = Turn-on related circuit of PHY transceiver.
N * |[10]    |BYTEM     |CPU Access USB SRAM Size Mode Selection
N * |        |          |0 = Word mode: The size of the transfer from CPU to USB SRAM can be Word only.
N * |        |          |1 = Byte mode: The size of the transfer from CPU to USB SRAM can be Byte only.
N * @var USBD_T::FLDET
N * Offset: 0x14  USB Floating Detection Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |FLDET     |Device Floating Detected
N * |        |          |0 = Controller is not attached into the USB host.
N * |        |          |1 =Controller is attached into the BUS.
N * @var USBD_T::STBUFSEG
N * Offset: 0x18  Setup Token Buffer Segmentation Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[8:3]   |STBUFSEG  |Setup Token Buffer Segmentation
N * |        |          |It is used to indicate the offset address for the SETUP token with the USB Device SRAM starting
N * |        |          |address The effective starting address is
N * |        |          |USB_SRAM address + {STBUFSEG[8:3], 3'b000}
N * |        |          |Where the USB_SRAM address = USBD_BA+0x100h.
N * |        |          |Note: It is used for SETUP token only.
N * @var USBD_T::DRVSE0
N * Offset: 0x90  USB Drive SE0 Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |DRVSE0    |Drive Single Ended Zero In USB Bus
N * |        |          |The Single Ended Zero (SE0) is when both lines (USB_D+ and USB_D-) are being pulled low.
N * |        |          |0 = None.
N * |        |          |1 = Force USB PHY transceiver to drive SE0.
N */
N
N    __IO uint32_t INTEN;         /* Offset: 0x00  USB Interrupt Enable Register                                      */
X    volatile uint32_t INTEN;          
N    __IO uint32_t INTSTS;        /* Offset: 0x04  USB Interrupt Event Status Register                                */
X    volatile uint32_t INTSTS;         
N    __IO uint32_t FADDR;         /* Offset: 0x08  USB Device Function Address Register                               */
X    volatile uint32_t FADDR;          
N    __I  uint32_t EPSTS;         /* Offset: 0x0C  USB Endpoint Status Register                                       */
X    volatile const  uint32_t EPSTS;          
N    __IO uint32_t ATTR;          /* Offset: 0x10  USB Bus Status and Attribution Register                            */
X    volatile uint32_t ATTR;           
N    __I  uint32_t FLDET;         /* Offset: 0x14  USB Floating Detection Register                                    */
X    volatile const  uint32_t FLDET;          
N    __IO uint32_t STBUFSEG;      /* Offset: 0x18  Setup Token Buffer Segmentation Register                           */
X    volatile uint32_t STBUFSEG;       
N    __I  uint32_t RESERVE1[29];  
X    volatile const  uint32_t RESERVE1[29];  
N    __IO uint32_t DRVSE0;        /* Offset: 0x90  USB Drive SE0 Control Register                                     */
X    volatile uint32_t DRVSE0;         
N    __I  uint32_t RESERVE2[283];
X    volatile const  uint32_t RESERVE2[283];
N        USBD_EP_T EP[8];         /* Offset: 0x500 Endpoint 0~7 Control Registers                                     */
N
N} USBD_T;
N
N
N/**
N    @addtogroup USBD_CONST USBD Bit Field Definition
N    Constant Definitions for USBD Controller
N@{ */
N
N
N/* USBD INTEN Bit Field Definitions */
N#define USBD_INTEN_INNAK_EN_Pos    15                                    /*!< USBD_T::INTEN: INNAK_EN Position */
N#define USBD_INTEN_INNAK_EN_Msk    (1ul << USBD_INTEN_INNAK_EN_Pos)      /*!< USBD_T::INTEN: INNAK_EN Mask */
N
N#define USBD_INTEN_WAKEUP_EN_Pos   8                                     /*!< USBD_T::INTEN: RWAKEUP Position */
N#define USBD_INTEN_WAKEUP_EN_Msk   (1ul << USBD_INTEN_WAKEUP_EN_Pos)     /*!< USBD_T::INTEN: RWAKEUP Mask */
N
N#define USBD_INTEN_WAKEUP_IE_Pos   3                                     /*!< USBD_T::INTEN: WAKEUP_IE Position */
N#define USBD_INTEN_WAKEUP_IE_Msk   (1ul << USBD_INTEN_WAKEUP_IE_Pos)     /*!< USBD_T::INTEN: WAKEUP_IE Mask */
N
N#define USBD_INTEN_FLDET_IE_Pos    2                                     /*!< USBD_T::INTEN: FLDET_IE Position */
N#define USBD_INTEN_FLDET_IE_Msk    (1ul << USBD_INTEN_FLDET_IE_Pos)      /*!< USBD_T::INTEN: FLDET_IE Mask */
N
N#define USBD_INTEN_USB_IE_Pos      1                                     /*!< USBD_T::INTEN: USB_IE Position */
N#define USBD_INTEN_USB_IE_Msk      (1ul << USBD_INTEN_USB_IE_Pos)        /*!< USBD_T::INTEN: USB_IE Mask */
N
N#define USBD_INTEN_BUS_IE_Pos      0                                     /*!< USBD_T::INTEN: BUS_IE Position */
N#define USBD_INTEN_BUS_IE_Msk      (1ul << USBD_INTEN_BUS_IE_Pos)        /*!< USBD_T::INTEN: BUS_IE Mask */
N
N/* USBD INTSTS Bit Field Definitions */
N#define USBD_INTSTS_SETUP_Pos        31                                  /*!< USBD_T::INTSTS: SETUP Position */
N#define USBD_INTSTS_SETUP_Msk        (1ul << USBD_INTSTS_SETUP_Pos)      /*!< USBD_T::INTSTS: SETUP Mask */
N
N#define USBD_INTSTS_EPEVT7_Pos       23                                  /*!< USBD_T::INTSTS: EPEVT7 Position */
N#define USBD_INTSTS_EPEVT7_Msk       (0x1ul << USBD_INTSTS_EPEVT7_Pos)   /*!< USBD_T::INTSTS: EPEVT7 Mask     */
N
N#define USBD_INTSTS_EPEVT6_Pos       22                                  /*!< USBD_T::INTSTS: EPEVT6 Position */
N#define USBD_INTSTS_EPEVT6_Msk       (0x1ul << USBD_INTSTS_EPEVT6_Pos)   /*!< USBD_T::INTSTS: EPEVT6 Mask     */
N
N#define USBD_INTSTS_EPEVT5_Pos       21                                  /*!< USBD_T::INTSTS: EPEVT5 Position */
N#define USBD_INTSTS_EPEVT5_Msk       (0x1ul << USBD_INTSTS_EPEVT5_Pos)   /*!< USBD_T::INTSTS: EPEVT5 Mask     */
N
N#define USBD_INTSTS_EPEVT4_Pos       20                                  /*!< USBD_T::INTSTS: EPEVT4 Position */
N#define USBD_INTSTS_EPEVT4_Msk       (0x1ul << USBD_INTSTS_EPEVT4_Pos)   /*!< USBD_T::INTSTS: EPEVT4 Mask     */
N
N#define USBD_INTSTS_EPEVT3_Pos       19                                  /*!< USBD_T::INTSTS: EPEVT3 Position */
N#define USBD_INTSTS_EPEVT3_Msk       (0x1ul << USBD_INTSTS_EPEVT3_Pos)   /*!< USBD_T::INTSTS: EPEVT3 Mask     */
N
N#define USBD_INTSTS_EPEVT2_Pos       18                                  /*!< USBD_T::INTSTS: EPEVT2 Position */
N#define USBD_INTSTS_EPEVT2_Msk       (0x1ul << USBD_INTSTS_EPEVT2_Pos)   /*!< USBD_T::INTSTS: EPEVT2 Mask     */
N
N#define USBD_INTSTS_EPEVT1_Pos       17                                  /*!< USBD_T::INTSTS: EPEVT1 Position */
N#define USBD_INTSTS_EPEVT1_Msk       (0x1ul << USBD_INTSTS_EPEVT1_Pos)   /*!< USBD_T::INTSTS: EPEVT1 Mask     */
N
N#define USBD_INTSTS_EPEVT0_Pos       16                                  /*!< USBD_T::INTSTS: EPEVT0 Position */
N#define USBD_INTSTS_EPEVT0_Msk       (0x1ul << USBD_INTSTS_EPEVT0_Pos)   /*!< USBD_T::INTSTS: EPEVT0 Mask     */
N
N#define USBD_INTSTS_WAKEUP_STS_Pos   3                                   /*!< USBD_T::INTSTS: WAKEUP_STS Position */
N#define USBD_INTSTS_WAKEUP_STS_Msk   (1ul << USBD_INTSTS_WAKEUP_STS_Pos) /*!< USBD_T::INTSTS: WAKEUP_STS Mask */
N
N#define USBD_INTSTS_FLDET_STS_Pos    2                                   /*!< USBD_T::INTSTS: FLDET_STS Position */
N#define USBD_INTSTS_FLDET_STS_Msk    (1ul << USBD_INTSTS_FLDET_STS_Pos)  /*!< USBD_T::INTSTS: FLDET_STS Mask */
N
N#define USBD_INTSTS_USB_STS_Pos      1                                   /*!< USBD_T::INTSTS: USB_STS Position */
N#define USBD_INTSTS_USB_STS_Msk      (1ul << USBD_INTSTS_USB_STS_Pos)    /*!< USBD_T::INTSTS: USB_STS Mask */
N
N#define USBD_INTSTS_BUS_STS_Pos      0                                   /*!< USBD_T::INTSTS: BUS_STS Position */
N#define USBD_INTSTS_BUS_STS_Msk      (1ul << USBD_INTSTS_BUS_STS_Pos)    /*!< USBD_T::INTSTS: BUS_STS Mask */
N
N/* USBD FADDR Bit Field Definitions */
N#define USBD_FADDR_FADDR_Pos     0                                       /*!< USBD_T::FADDR: FADDR Position */
N#define USBD_FADDR_FADDR_Msk     (0x7Ful << USBD_FADDR_FADDR_Pos)        /*!< USBD_T::FADDR: FADDR Mask */
N
N/* USBD EPSTS Bit Field Definitions */
N#define USBD_EPSTS_EPSTS5_Pos    23                                      /*!< USBD_T::EPSTS: EPSTS5 Position */
N#define USBD_EPSTS_EPSTS5_Msk    (7ul << USBD_EPSTS_EPSTS5_Pos)          /*!< USBD_T::EPSTS: EPSTS5 Mask */
N
N#define USBD_EPSTS_EPSTS4_Pos    20                                      /*!< USBD_T::EPSTS: EPSTS4 Position */
N#define USBD_EPSTS_EPSTS4_Msk    (7ul << USBD_EPSTS_EPSTS4_Pos)          /*!< USBD_T::EPSTS: EPSTS5 Mask */
N
N#define USBD_EPSTS_EPSTS3_Pos    17                                      /*!< USBD_T::EPSTS: EPSTS3 Position */
N#define USBD_EPSTS_EPSTS3_Msk    (7ul << USBD_EPSTS_EPSTS3_Pos)          /*!< USBD_T::EPSTS: EPSTS3 Mask */
N
N#define USBD_EPSTS_EPSTS2_Pos    14                                      /*!< USBD_T::EPSTS: EPSTS2 Position */
N#define USBD_EPSTS_EPSTS2_Msk    (7ul << USBD_EPSTS_EPSTS2_Pos)          /*!< USBD_T::EPSTS: EPSTS2 Mask */
N
N#define USBD_EPSTS_EPSTS1_Pos    11                                      /*!< USBD_T::EPSTS: EPSTS1 Position */
N#define USBD_EPSTS_EPSTS1_Msk    (7ul << USBD_EPSTS_EPSTS1_Pos)          /*!< USBD_T::EPSTS: EPSTS1 Mask */
N
N#define USBD_EPSTS_EPSTS0_Pos    8                                       /*!< USBD_T::EPSTS: EPSTS0 Position */
N#define USBD_EPSTS_EPSTS0_Msk    (7ul << USBD_EPSTS_EPSTS0_Pos)          /*!< USBD_T::EPSTS: EPSTS0 Mask */
N
N#define USBD_EPSTS_OVERRUN_Pos   7                                       /*!< USBD_T::EPSTS: OVERRUN Position */
N#define USBD_EPSTS_OVERRUN_Msk   (1ul << USBD_EPSTS_OVERRUN_Pos)         /*!< USBD_T::EPSTS: OVERRUN Mask */
N
N/* USBD ATTR Bit Field Definitions */
N#define USBD_ATTR_BYTEM_Pos      10                                      /*!< USBD_T::ATTR: BYTEM Position */
N#define USBD_ATTR_BYTEM_Msk      (1ul << USBD_ATTR_BYTEM_Pos)            /*!< USBD_T::ATTR: BYTEM Mask */
N
N#define USBD_ATTR_PWRDN_Pos      9                                       /*!< USBD_T::ATTR: PWRDN Position */
N#define USBD_ATTR_PWRDN_Msk      (1ul << USBD_ATTR_PWRDN_Pos)            /*!< USBD_T::ATTR: PWRDN Mask */
N
N#define USBD_ATTR_DPPU_EN_Pos    8                                       /*!< USBD_T::ATTR: DPPU_EN Position */
N#define USBD_ATTR_DPPU_EN_Msk    (1ul << USBD_ATTR_DPPU_EN_Pos)          /*!< USBD_T::ATTR: DPPU_EN Mask */
N
N#define USBD_ATTR_USB_EN_Pos     7                                       /*!< USBD_T::ATTR: USB_EN Position */
N#define USBD_ATTR_USB_EN_Msk     (1ul << USBD_ATTR_USB_EN_Pos)           /*!< USBD_T::ATTR: USB_EN Mask */
N
N#define USBD_ATTR_RWAKEUP_Pos    5                                       /*!< USBD_T::ATTR: RWAKEUP Position */
N#define USBD_ATTR_RWAKEUP_Msk    (1ul << USBD_ATTR_RWAKEUP_Pos)          /*!< USBD_T::ATTR: RWAKEUP Mask */
N
N#define USBD_ATTR_PHY_EN_Pos     4                                       /*!< USBD_T::ATTR: PHY_EN Position */
N#define USBD_ATTR_PHY_EN_Msk     (1ul << USBD_ATTR_PHY_EN_Pos)           /*!< USBD_T::ATTR: PHY_EN Mask */
N
N#define USBD_ATTR_TIMEOUT_Pos    3                                       /*!< USBD_T::ATTR: TIMEOUT Position */
N#define USBD_ATTR_TIMEOUT_Msk    (1ul << USBD_ATTR_TIMEOUT_Pos)          /*!< USBD_T::ATTR: TIMEOUT Mask */
N
N#define USBD_ATTR_RESUME_Pos     2                                       /*!< USBD_T::ATTR: RESUME Position */
N#define USBD_ATTR_RESUME_Msk     (1ul << USBD_ATTR_RESUME_Pos)           /*!< USBD_T::ATTR: RESUME Mask */
N
N#define USBD_ATTR_SUSPEND_Pos    1                                       /*!< USBD_T::ATTR: SUSPEND Position */
N#define USBD_ATTR_SUSPEND_Msk    (1ul << USBD_ATTR_SUSPEND_Pos)          /*!< USBD_T::ATTR: SUSPEND Mask */
N
N#define USBD_ATTR_USBRST_Pos     0                                       /*!< USBD_T::ATTR: USBRST Position */
N#define USBD_ATTR_USBRST_Msk     (1ul << USBD_ATTR_USBRST_Pos)           /*!< USBD_T::ATTR: USBRST Mask */
N
N/* USBD FLDET Bit Field Definitions */
N#define USBD_FLDET_FLDET_Pos     0                                       /*!< USBD_T::FLDET: FLDET Position */
N#define USBD_FLDET_FLDET_Msk     (1ul << USBD_FLDET_FLDET_Pos)           /*!< USBD_T::FLDET: FLDET Mask */
N
N/* USBD STBUFSEG Bit Field Definitions */
N#define USBD_STBUFSEG_STBUFSEG_Pos   3                                        /*!< USBD_T::STBUFSEG: STBUFSEG Position */
N#define USBD_STBUFSEG_STBUFSEG_Msk   (0x3Ful << USBD_STBUFSEG_STBUFSEG_Pos)   /*!< USBD_T::STBUFSEG: STBUFSEG Mask */
N
N/* USBD BUFSEG Bit Field Definitions */
N#define USBD_BUFSEG_BUFSEG_Pos   3                                       /*!< USBD_EP_T::BUFSEG: BUFSEG Position */
N#define USBD_BUFSEG_BUFSEG_Msk   (0x3Ful << USBD_BUFSEG_BUFSEG_Pos)      /*!< USBD_EP_T::BUFSEG: BUFSEG Mask */
N
N/* USBD MXPLD Bit Field Definitions */
N#define USBD_MXPLD_MXPLD_Pos    0                                        /*!< USBD_EP_T::MXPLD: MXPLD Position */
N#define USBD_MXPLD_MXPLD_Msk    (0x1FFul << USBD_MXPLD_MXPLD_Pos)        /*!< USBD_EP_T::MXPLD: MXPLD Mask */
N
N/* USBD CFG Bit Field Definitions */
N#define USBD_CFG_CSTALL_Pos     9                                        /*!< USBD_EP_T::CFG: CSTALL Position */
N#define USBD_CFG_CSTALL_Msk     (1ul << USBD_CFG_CSTALL_Pos)             /*!< USBD_EP_T::CFG: CSTALL Mask */
N
N#define USBD_CFG_DSQ_SYNC_Pos   7                                        /*!< USBD_EP_T::CFG: DSQ_SYNC Position */
N#define USBD_CFG_DSQ_SYNC_Msk   (1ul << USBD_CFG_DSQ_SYNC_Pos)           /*!< USBD_EP_T::CFG: DSQ_SYNC Mask */
N
N#define USBD_CFG_STATE_Pos      5                                        /*!< USBD_EP_T::CFG: STATE Position */
N#define USBD_CFG_STATE_Msk      (3ul << USBD_CFG_STATE_Pos)              /*!< USBD_EP_T::CFG: STATE Mask */
N
N#define USBD_CFG_ISOCH_Pos      4                                        /*!< USBD_EP_T::CFG: ISOCH Position */
N#define USBD_CFG_ISOCH_Msk      (1ul << USBD_CFG_ISOCH_Pos)              /*!< USBD_EP_T::CFG: ISOCH Mask */
N
N#define USBD_CFG_EP_NUM_Pos     0                                        /*!< USBD_EP_T::CFG: EP_NUM Position */
N#define USBD_CFG_EP_NUM_Msk     (0xFul << USBD_CFG_EP_NUM_Pos)           /*!< USBD_EP_T::CFG: EP_NUM Mask */
N
N/* USBD CFGP Bit Field Definitions */
N#define USBD_CFGP_SSTALL_Pos    1                                        /*!< USBD_EP_T::CFGP: SSTALL Position */
N#define USBD_CFGP_SSTALL_Msk    (1ul << USBD_CFGP_SSTALL_Pos)            /*!< USBD_EP_T::CFGP: SSTALL Mask */
N
N#define USBD_CFGP_CLRRDY_Pos    0                                        /*!< USBD_EP_T::CFGP: CLRRDY Position */
N#define USBD_CFGP_CLRRDY_Msk    (1ul << USBD_CFGP_CLRRDY_Pos)            /*!< USBD_EP_T::CFGP: CLRRDY Mask */
N
N/* USBD DRVSE0 Bit Field Definitions */
N#define USBD_DRVSE0_DRVSE0_Pos   0                                       /*!< USBD_T::DRVSE0: DRVSE0 Position */
N#define USBD_DRVSE0_DRVSE0_Msk   (1ul << USBD_DRVSE0_DRVSE0_Pos)         /*!< USBD_T::DRVSE0: DRVSE0 Mask */
N/*@}*/ /* end of group USBD_CONST */
N/*@}*/ /* end of group USBD */
N
N
N/*---------------------- Watch Dog Timer Controller -------------------------*/
N/**
N    @addtogroup WDT Watch Dog Timer Controller (WDT)
N    Memory Mapped Structure for WDT Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N/**
N * @var WDT_T::WTCR
N * Offset: 0x00  Watchdog Timer Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |WTR       |Reset Watchdog Timer Up Counter (Write Protect)
N * |        |          |0 = No effect.
N * |        |          |1 = Reset the internal 18-bit WDT up counter value.
N * |        |          |Note: This bit will be automatically cleared by hardware.
N * |[1]     |WTRE      |Watchdog Timer Reset Enable (Write Protect)
N * |        |          |Setting this bit will enable the WDT time-out reset function if the WDT up counter value has not
N * |        |          |been cleared after the specific WDT reset delay period expires.
N * |        |          |0 = WDT time-out reset function Disabled.
N * |        |          |1 = WDT time-out reset function Enabled.
N * |[2]     |WTRF      |Watchdog Timer Time-out Reset Flag
N * |        |          |This bit indicates the system has been reset by WDT time-out reset or not.
N * |        |          |0 = WDT time-out reset did not occur.
N * |        |          |1 = WDT time-out reset occurred.
N * |        |          |Note: This bit is cleared by writing 1 to it.
N * |[3]     |WTIF      |Watchdog Timer Time-out Interrupt Flag
N * |        |          |This bit will set to 1 while WDT up counter value reaches the selected WDT time-out interval.
N * |        |          |0 = WDT time-out interrupt did not occur.
N * |        |          |1 = WDT time-out interrupt occurred.
N * |        |          |Note: This bit is cleared by writing 1 to it.
N * |[4]     |WTWKE     |Watchdog Timer Time-out Wake-Up Function Control
N * |        |          |(Write Protect)
N * |        |          |If this bit is set to 1, while WTIF is generated to 1 and WTIE enabled, the WDT time-out
N * |        |          |interrupt signal will generate a wake-up trigger event to chip.
N * |        |          |0 = Wake-up trigger event Disabled if WDT time-out interrupt signal generated.
N * |        |          |1 = Wake-up trigger event Enabled if WDT time-out interrupt signal generated.
N * |        |          |Note: Chip can be woken-up by WDT time-out interrupt signal generated only if WDT clock source
N * |        |          |is selected to 10 kHz oscillator.
N * |[5]     |WTWKF     |Watchdog Timer Time-out Wake-Up Flag
N * |        |          |This bit indicates the interrupt wake-up flag status of WDT.
N * |        |          |0 = WDT does not cause chip wake-up.
N * |        |          |1 = Chip wake-up from Idle or Power-down mode if WDT time-out interrupt signal generated.
N * |        |          |Note: This bit is cleared by writing 1 to it.
N * |[6]     |WTIE      |Watchdog Timer Time-out Interrupt Enable Control (Write Protect)
N * |        |          |If this bit is enabled, the WDT time-out interrupt signal is generated and inform to CPU.
N * |        |          |0 = WDT time-out interrupt Disabled.
N * |        |          |1 = WDT time-out interrupt Enabled.
N * |[7]     |WTE       |Watchdog Timer Enable Control (Write Protect)
N * |        |          |0 = WDT Disabled. (This action will reset the internal up counter value.)
N * |        |          |1 = WDT Enabled.
N * |        |          |Note: If CWDTEN (CONFIG0[31] Watchdog Enable) bit is set to 0, this bit is forced as 1 and
N * |        |          | user cannot change this bit to 0.
N * |[10:8]  |WTIS      |Watchdog Timer Time-out Interval Selection (Write Protect)
N * |        |          |These three bits select the time-out interval period for the WDT.
N * |        |          |000 = 24 *TWDT.
N * |        |          |001 = 26 * TWDT.
N * |        |          |010 = 28 * TWDT.
N * |        |          |011 = 210 * TWDT.
N * |        |          |100 = 212 * TWDT.
N * |        |          |101 = 214 * TWDT.
N * |        |          |110 = 216 * TWDT.
N * |        |          |111 = 218 * TWDT.
N * |[31]    |DBGACK_WDT|ICE Debug Mode Acknowledge Disable Control (Write Protect)
N * |        |          |0 = ICE debug mode acknowledgement effects WDT counting.
N * |        |          |WDT up counter will be held while CPU is held by ICE.
N * |        |          |1 = ICE debug mode acknowledgement Disabled.
N * |        |          |WDT up counter will keep going no matter CPU is held by ICE or not.
N * @var WDT_T::WTCRALT
N * Offset: 0x04  Watchdog Timer Alternative Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[1:0]   |WTRDSEL   |Watchdog Timer Reset Delay Selection (Write Protect)
N * |        |          |When WDT time-out happened, user has a time named WDT Reset Delay Period to clear WDT counter to
N * |        |          |prevent WDT time-out reset happened.
N * |        |          |User can select a suitable value of WDT Reset Delay Period for different WDT time-out period.
N * |        |          |These bits are protected bit.
N * |        |          |It means programming this bit needs to write "59h", "16h", "88h" to address 0x5000_0100 to
N * |        |          |disable register protection.
N * |        |          |Reference the register REGWRPROT at address GCR_BA+0x100.
N * |        |          |00 = Watchdog Timer Reset Delay Period is 1026 * WDT_CLK.
N * |        |          |01 = Watchdog Timer Reset Delay Period is 130 * WDT_CLK.
N * |        |          |10 = Watchdog Timer Reset Delay Period is 18 * WDT_CLK.
N * |        |          |11 = Watchdog Timer Reset Delay Period is 3 * WDT_CLK.
N * |        |          |Note: This register will be reset to 0 if WDT time-out reset happened.
N */
N
N    __IO uint32_t WTCR;          /* Offset: 0x00  Watchdog Timer Control Register                                    */
X    volatile uint32_t WTCR;           
N    __IO uint32_t WTCRALT;       /* Offset: 0x04  Watchdog Timer Alternative Control Register                        */
X    volatile uint32_t WTCRALT;        
N
N} WDT_T;
N
N
N
N/**
N    @addtogroup WDT_CONST WDT Bit Field Definition
N    Constant Definitions for WDT Controller
N@{ */
N
N
N
N/* WDT WTCR Bit Field Definitions */
N#define WDT_WTCR_DBGACK_WDT_Pos 31                                              /*!< WDT_T::WTCR: DBGACK_WDT Position */
N#define WDT_WTCR_DBGACK_WDT_Msk (1ul << WDT_WTCR_DBGACK_WDT_Pos)                /*!< WDT_T::WTCR: DBGACK_WDT Mask */
N
N#define WDT_WTCR_WTIS_Pos       8                                               /*!< WDT_T::WTCR: WTIS Position */
N#define WDT_WTCR_WTIS_Msk       (0x7ul << WDT_WTCR_WTIS_Pos)                    /*!< WDT_T::WTCR: WTIS Mask */
N
N#define WDT_WTCR_WTE_Pos        7                                               /*!< WDT_T::WTCR: WTE Position */
N#define WDT_WTCR_WTE_Msk        (1ul << WDT_WTCR_WTE_Pos)                       /*!< WDT_T::WTCR: WTE Mask */
N
N#define WDT_WTCR_WTIE_Pos       6                                               /*!< WDT_T::WTCR: WTIE Position */
N#define WDT_WTCR_WTIE_Msk       (1ul << WDT_WTCR_WTIE_Pos)                      /*!< WDT_T::WTCR: WTIE Mask */
N
N#define WDT_WTCR_WTWKF_Pos      5                                               /*!< WDT_T::WTCR: WTWKF Position */
N#define WDT_WTCR_WTWKF_Msk      (1ul << WDT_WTCR_WTWKF_Pos)                     /*!< WDT_T::WTCR: WTWKF Mask */
N
N#define WDT_WTCR_WTWKE_Pos      4                                               /*!< WDT_T::WTCR: WTWKE Position */
N#define WDT_WTCR_WTWKE_Msk      (1ul << WDT_WTCR_WTWKE_Pos)                     /*!< WDT_T::WTCR: WTWKE Mask */
N
N#define WDT_WTCR_WTIF_Pos       3                                               /*!< WDT_T::WTCR: WTIF Position */
N#define WDT_WTCR_WTIF_Msk       (1ul << WDT_WTCR_WTIF_Pos)                      /*!< WDT_T::WTCR: WTIF Mask */
N
N#define WDT_WTCR_WTRF_Pos       2                                               /*!< WDT_T::WTCR: WTRF Position */
N#define WDT_WTCR_WTRF_Msk       (1ul << WDT_WTCR_WTRF_Pos)                      /*!< WDT_T::WTCR: WTRF Mask */
N
N#define WDT_WTCR_WTRE_Pos       1                                               /*!< WDT_T::WTCR: WTRE Position */
N#define WDT_WTCR_WTRE_Msk       (1ul << WDT_WTCR_WTRE_Pos)                      /*!< WDT_T::WTCR: WTRE Mask */
N
N#define WDT_WTCR_WTR_Pos        0                                               /*!< WDT_T::WTCR: WTR Position */
N#define WDT_WTCR_WTR_Msk        (1ul << WDT_WTCR_WTR_Pos)                       /*!< WDT_T::WTCR: WTR Mask */
N
N/* WDT WTCRALT Bit Field Definitions */
N#define WDT_WTCRALT_WTRDSEL_Pos 0                                               /*!< WDT_T::WTCRALT: WTRDSEL Position */
N#define WDT_WTCRALT_WTRDSEL_Msk (0x3ul << WDT_WTCRALT_WTRDSEL_Pos)              /*!< WDT_T::WTCRALT: WTRDSEL Mask */
N/*@}*/ /* end of group WDT_CONST */
N/*@}*/ /* end of group WDT */
N
N
N/*---------------------- Window Watchdog Timer -------------------------*/
N/**
N    @addtogroup WWDT Window Watchdog Timer (WWDT)
N    Memory Mapped Structure for WWDT Controller
N@{ */
N
N
Ntypedef struct
N{
N
N
N/**
N * @var WWDT_T::WWDTRLD
N * Offset: 0x00  Window Watchdog Timer Reload Counter Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[31:0]  |WWDTRLD   |WWDT Reload Counter Register
N * |        |          |Writing 0x00005AA5 to this register will reload the WWDT counter value to 0x3F.
N * |        |          |Note: User can only write WWDTRLD to reload WWDT counter value when current WWDT
N * |        |          | counter value between 0 and WINCMP. If user writes WWDTRLD when current WWDT
N * |        |          | counter value is larger than WINCMP, WWDT reset signal will generate immediately.
N * @var WWDT_T::WWDTCR
N * Offset: 0x04  Window Watchdog Timer Control Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |WWDTEN    |WWDT Enable Control
N * |        |          |0 = WWDT counter is stopped.
N * |        |          |1 = WWDT counter is starting counting.
N * |[1]     |WWDTIE    |WWDT Interrupt Enable Control
N * |        |          |If this bit is enabled, the WWDT counter compare match interrupt signal is generated and inform
N * |        |          |to CPU.
N * |        |          |0 = WWDT counter compare match interrupt Disabled.
N * |        |          |1 = WWDT counter compare match interrupt Enabled.
N * |[11:8]  |PERIODSEL |WWDT Counter Prescale Period Selection
N * |        |          |0000 = Pre-scale is 1; Max time-out period is 1 * 64 * TWWDT.
N * |        |          |0001 = Pre-scale is 2; Max time-out period is 2 * 64 * TWWDT.
N * |        |          |0010 = Pre-scale is 4; Max time-out period is 4 * 64 * TWWDT.
N * |        |          |0011 = Pre-scale is 8; Max time-out period is 8 * 64 * TWWDT.
N * |        |          |0100 = Pre-scale is 16; Max time-out period is 16 * 64 * TWWDT.
N * |        |          |0101 = Pre-scale is 32; Max time-out period is 32 * 64 * TWWDT.
N * |        |          |0110 = Pre-scale is 64; Max time-out period is 64 * 64 * TWWDT.
N * |        |          |0111 = Pre-scale is 128; Max time-out period is 128 * 64 * TWWDT.
N * |        |          |1000 = Pre-scale is 192; Max time-out period is 192 * 64 * TWWDT.
N * |        |          |1001 = Pre-scale is 256; Max time-out period is 256 * 64 * TWWDT.
N * |        |          |1010 = Pre-scale is 384; Max time-out period is 384 * 64 * TWWDT.
N * |        |          |1011 = Pre-scale is 512; Max time-out period is 512 * 64 * TWWDT.
N * |        |          |1100 = Pre-scale is 768; Max time-out period is 768 * 64 * TWWDT.
N * |        |          |1101 = Pre-scale is 1024; Max time-out period is 1024 * 64 * TWWDT.
N * |        |          |1110 = Pre-scale is 1536; Max time-out period is 1536 * 64 * TWWDT.
N * |        |          |1111 = Pre-scale is 2048; Max time-out period is 2048 * 64 * TWWDT.
N * |[21:16] |WINCMP    |WWDT Window Compare Register
N * |        |          |Set this register to adjust the valid reload window.
N * |        |          |Note: User can only write WWDTRLD to reload WWDT counter value when current WWDT counter value
N * |        |          |between 0 and WINCMP.
N * |        |          |If user writes WWDTRLD when current WWDT counter value larger than WINCMP, WWDT reset signal
N * |        |          |will generate immediately.
N * |[31]    |DBGACK_WWDT|ICE Debug Mode Acknowledge Disable Control
N * |        |          |0 = ICE debug mode acknowledgement effects WWDT counting.
N * |        |          |WWDT down counter will be held while CPU is held by ICE.
N * |        |          |1 = ICE debug mode acknowledgement Disabled.
N * |        |          |WWDT down counter will keep going no matter CPU is held by ICE or not.
N * @var WWDT_T::WWDTSR
N * Offset: 0x08  Window Watchdog Timer Status Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[0]     |WWDTIF    |WWDT Compare Match Interrupt Flag
N * |        |          |This bit indicates the interrupt flag status of WWDT while WWDT counter value matches WINCMP
N * |        |          |value.
N * |        |          |0 = No effect.
N * |        |          |1 = WWDT counter value matches WINCMP value.
N * |        |          |Note: This bit is cleared by writing 1 to it.
N * |[1]     |WWDTRF    |WWDT Time-out Reset Flag
N * |        |          |This bit indicates the system has been reset by WWDT time-out reset or not.
N * |        |          |0 = WWDT time-out reset did not occur.
N * |        |          |1 = WWDT time-out reset occurred.
N * |        |          |Note: This bit is cleared by writing 1 to it.
N * @var WWDT_T::WWDTCVR
N * Offset: 0x0C  Window Watchdog Timer Counter Value Register
N * ---------------------------------------------------------------------------------------------------
N * |Bits    |Field     |Descriptions
N * | :----: | :----:   | :---- |
N * |[5:0]   |WWDTCVAL  |WWDT Counter Value
N * |        |          |WWDTCVAL will be updated continuously to monitor 6-bit down counter value.
N */
N
N    __IO uint32_t WWDTRLD;       /* Offset: 0x00  Window Watchdog Timer Reload Counter Register                      */
X    volatile uint32_t WWDTRLD;        
N    __IO uint32_t WWDTCR;        /* Offset: 0x04  Window Watchdog Timer Control Register                             */
X    volatile uint32_t WWDTCR;         
N    __IO uint32_t WWDTSR;        /* Offset: 0x08  Window Watchdog Timer Status Register                              */
X    volatile uint32_t WWDTSR;         
N    __I  uint32_t WWDTCVR;       /* Offset: 0x0C  Window Watchdog Timer Counter Value Register                       */
X    volatile const  uint32_t WWDTCVR;        
N
N} WWDT_T;
N
N
N/**
N    @addtogroup WWDT_CONST WWDT Bit Field Definition
N    Constant Definitions for WWDT Controller
N@{ */
N
N
N
N/* WWDT WWDTRLD Bit Field Definitions */
N#define WWDT_WWDTRLD_WWDTRLD_Pos    0                                           /*!< WWDT_T::WWDTRLD: WWDTRLD Position */
N#define WWDT_WWDTRLD_WWDTRLD_Msk    (0xFFFFFFFFul << WWDT_WWDTRLD_WWDTRLD_Pos)  /*!< WWDT_T::WWDTRLD: WWDTRLD Mask */
N
N/* WWDT WWDTCR Bit Field Definitions */
N#define WWDT_WWDTCR_DBGACK_WWDT_Pos 31                                          /*!< WWDT_T::WWDTCR: DBGACK_WWDT Position */
N#define WWDT_WWDTCR_DBGACK_WWDT_Msk (1ul << WWDT_WWDTCR_DBGACK_WWDT_Pos)        /*!< WWDT_T::WWDTCR: DBGACK_WWDT Mask */
N
N#define WWDT_WWDTCR_WINCMP_Pos      16                                          /*!< WWDT_T::WWDTCR: WINCMP Position */
N#define WWDT_WWDTCR_WINCMP_Msk      (0x3Ful << WWDT_WWDTCR_WINCMP_Pos)          /*!< WWDT_T::WWDTCR: WINCMP Mask */
N
N#define WWDT_WWDTCR_PERIODSEL_Pos   8                                           /*!< WWDT_T::WWDTCR: PERIODSEL Position */
N#define WWDT_WWDTCR_PERIODSEL_Msk   (0xFul << WWDT_WWDTCR_PERIODSEL_Pos)        /*!< WWDT_T::WWDTCR: PERIODSEL Mask */
N
N#define WWDT_WWDTCR_WWDTIE_Pos      1                                           /*!< WWDT_T::WWDTCR: WWDTIE Position */
N#define WWDT_WWDTCR_WWDTIE_Msk      (1ul << WWDT_WWDTCR_WWDTIE_Pos)             /*!< WWDT_T::WWDTCR: WWDTIE Mask */
N
N#define WWDT_WWDTCR_WWDTEN_Pos      0                                           /*!< WWDT_T::WWDTCR: WWDTEN Position */
N#define WWDT_WWDTCR_WWDTEN_Msk      (1ul << WWDT_WWDTCR_WWDTEN_Pos)             /*!< WWDT_T::WWDTCR: WWDTEN Mask */
N
N/* WWDT WWDTSR Bit Field Definitions */
N#define WWDT_WWDTSR_WWDTRF_Pos      1                                           /*!< WWDT_T::WWDTSR: WWDTRF Position */
N#define WWDT_WWDTSR_WWDTRF_Msk      (1ul << WWDT_WWDTSR_WWDTRF_Pos)             /*!< WWDT_T::WWDTSR: WWDTRF Mask */
N
N#define WWDT_WWDTSR_WWDTIF_Pos      0                                           /*!< WWDT_T::WWDTSR: WWDTIF Position */
N#define WWDT_WWDTSR_WWDTIF_Msk      (1ul << WWDT_WWDTSR_WWDTIF_Pos)             /*!< WWDT_T::WWDTSR: WWDTIF Mask */
N
N/* WWDT WWDTCVR Bit Field Definitions */
N#define WWDT_WWDTCVR_WWDTCVAL_Pos   0                                           /*!< WWDT_T::WWDTCVR: WWDTCVAL Position */
N#define WWDT_WWDTCVR_WWDTCVAL_Msk   (0x3Ful << WWDT_WWDTCVR_WWDTCVAL_Pos)       /*!< WWDT_T::WWDTCVR: WWDTCVAL Mask */
N/*@}*/ /* end of group WWDT_CONST */
N/*@}*/ /* end of group WWDT */
N/*@}*/ /* end of group */
N
N
N/******************************************************************************/
N/*                         Peripheral memory map                              */
N/******************************************************************************/
N/** @addtogroup PERIPHERAL_MEM_MAP Peripheral Memory Map
N  Memory Mapped Structure for Peripheral
N  @{
N */
N/* Peripheral and SRAM base address */
N#define FLASH_BASE          ((     uint32_t)0x00000000)
N#define SRAM_BASE           ((     uint32_t)0x20000000)
N#define AHB_BASE            ((     uint32_t)0x50000000)
N#define APB1_BASE           ((     uint32_t)0x40000000)
N#define APB2_BASE           ((     uint32_t)0x40100000)
N
N/* Peripheral memory map */
N#define GPIO_BASE           (AHB_BASE        + 0x4000)                   /*!< GPIO Base Address                                   */
N#define PA_BASE             (GPIO_BASE               )                   /*!< GPIO PORTA Base Address                             */
N#define PB_BASE             (GPIO_BASE       + 0x0040)                   /*!< GPIO PORTB Base Address                             */
N#define PC_BASE             (GPIO_BASE       + 0x0080)                   /*!< GPIO PORTC Base Address                             */
N#define PD_BASE             (GPIO_BASE       + 0x00C0)                   /*!< GPIO PORTD Base Address                             */
N#define PE_BASE             (GPIO_BASE       + 0x0100)                   /*!< GPIO PORTE Base Address                             */
N#define PF_BASE             (GPIO_BASE       + 0x0140)                   /*!< GPIO PORTF Base Address                             */
N#define GPIO_DBNCECON_BASE  (GPIO_BASE       + 0x0180)                   /*!< GPIO De-bounce Cycle Control Base Address           */
N#define GPIO_PIN_DATA_BASE  (GPIO_BASE       + 0x0200)                   /*!< GPIO Pin Data Input/Output Control Base Address     */
N
N
N#define UART0_BASE           (APB1_BASE      + 0x50000)
N#define UART1_BASE           (APB2_BASE      + 0x50000)
N#define UART2_BASE           (APB2_BASE      + 0x54000)
N
N
N#define TIMER0_BASE          (APB1_BASE      + 0x10000)                 /*!< Timer0 Base Address                              */
N#define TIMER1_BASE          (APB1_BASE      + 0x10020)                 /*!< Timer1 Base Address                              */
N#define TIMER2_BASE          (APB2_BASE      + 0x10000)                 /*!< Timer2 Base Address                              */
N#define TIMER3_BASE          (APB2_BASE      + 0x10020)                 /*!< Timer3 Base Address                              */
N
N#define WDT_BASE             (APB1_BASE      + 0x4000)                  /*!< Watchdog Timer Base Address                      */
N
N#define WWDT_BASE            (APB1_BASE      + 0x4100)                  /*!< Window Watchdog Timer Base Address               */
N
N#define SPI0_BASE            (APB1_BASE      + 0x30000)                 /*!< SPI0 Base Address                                */
N#define SPI1_BASE            (APB1_BASE      + 0x34000)                 /*!< SPI1 Base Address                                */
N#define SPI2_BASE            (APB2_BASE      + 0x30000)                 /*!< SPI2 Base Address                                */
N#define SPI3_BASE            (APB2_BASE      + 0x34000)                 /*!< SPI3 Base Address                                */
N
N#define I2C0_BASE            (APB1_BASE      + 0x20000)                 /*!< I2C0 Base Address                                */
N#define I2C1_BASE            (APB2_BASE      + 0x20000)                 /*!< I2C1 Base Address                                */
N
N#define RTC_BASE             (APB1_BASE      + 0x08000)                 /*!< RTC Base Address                                 */
N
N#define ADC_BASE             (APB1_BASE      + 0xE0000)                 /*!< ADC Base Address                                 */
N
N#define ACMP_BASE            (APB1_BASE      + 0xD0000)                 /*!< ACMP Base Address                                */
N
N#define CLK_BASE             (AHB_BASE       + 0x00200)                 /*!< System Clock Controller Base Address             */
N
N#define GCR_BASE             (AHB_BASE       + 0x00000)                 /*!< System Global Controller Base Address            */
N
N#define INT_BASE             (AHB_BASE       + 0x00300)                 /*!< Interrupt Source Controller Base Address         */
N
N#define FMC_BASE             (AHB_BASE       + 0x0C000)
N
N#define PS2_BASE             (APB2_BASE      + 0x00000)                 /*!< PS/2 Base Address                                */
N
N#define CAN0_BASE            (APB2_BASE      + 0x80000)                 /*!< CAN0 Base Address                                */
N#define CAN1_BASE            (APB2_BASE      + 0x84000)                 /*!< CAN1 Base Address                                */
N
N#define USBD_BASE            (APB1_BASE      + 0x60000)                 /*!< USBD Base Address                                */
N
N#define PDMA0_BASE           (AHB_BASE       + 0x08000)                 /*!< PDMA0 Base Address                               */
N#define PDMA1_BASE           (AHB_BASE       + 0x08100)                 /*!< PDMA1 Base Address                               */
N#define PDMA2_BASE           (AHB_BASE       + 0x08200)                 /*!< PDMA2 Base Address                               */
N#define PDMA3_BASE           (AHB_BASE       + 0x08300)                 /*!< PDMA3 Base Address                               */
N#define PDMA4_BASE           (AHB_BASE       + 0x08400)                 /*!< PDMA4 Base Address                               */
N#define PDMA5_BASE           (AHB_BASE       + 0x08500)                 /*!< PDMA5 Base Address                               */
N#define PDMA6_BASE           (AHB_BASE       + 0x08600)                 /*!< PDMA6 Base Address                               */
N#define PDMA7_BASE           (AHB_BASE       + 0x08700)                 /*!< PDMA7 Base Address                               */
N#define PDMA8_BASE           (AHB_BASE       + 0x08800)                 /*!< PDMA8 Base Address                               */
N
N#define PDMA_GCR_BASE        (AHB_BASE       + 0x08F00)                 /*!< PDMA Grobal Base Address                         */
N
N#define CRC_BASE             (AHB_BASE       + 0x08E00)                 /*!< CRC Base Address                                 */
N
N#define PWMA_BASE            (APB1_BASE      + 0x40000)                 /*!< PWMA Base Address                                */
N#define PWMB_BASE            (APB2_BASE      + 0x40000)                 /*!< PWMB Base Address                                */
N
N#define SC0_BASE             (APB2_BASE      + 0x90000)                 /*!< SC0 Base Address                                 */
N#define SC1_BASE             (APB2_BASE      + 0x94000)                 /*!< SC1 Base Address                                 */
N#define SC2_BASE             (APB2_BASE      + 0x98000)                 /*!< SC2 Base Address                                 */
N
N#define I2S_BASE             (APB2_BASE      + 0xA0000)                 /*!< I2S Base Address                                 */
N
N#define EBI_BASE             (AHB_BASE       + 0x10000)                 /*!< EBI Base Address                                 */
N/*@}*/ /* end of group PERIPHERAL_MEM_MAP */
N
N/******************************************************************************/
N/*                         Peripheral Definitions                             */
N/******************************************************************************/
N
N/** @addtogroup PERIPHERAL Peripheral Definitions
N  The Definitions of Peripheral
N  @{
N */
N#define PA                  ((GPIO_T *) PA_BASE)                        /*!< GPIO PORTA Configuration Struct                        */
N#define PB                  ((GPIO_T *) PB_BASE)                        /*!< GPIO PORTB Configuration Struct                        */
N#define PC                  ((GPIO_T *) PC_BASE)                        /*!< GPIO PORTC Configuration Struct                        */
N#define PD                  ((GPIO_T *) PD_BASE)                        /*!< GPIO PORTD Configuration Struct                        */
N#define PE                  ((GPIO_T *) PE_BASE)                        /*!< GPIO PORTE Configuration Struct                        */
N#define PF                  ((GPIO_T *) PF_BASE)                        /*!< GPIO PORTF Configuration Struct                        */
N#define GPIO                ((GPIO_DBNCECON_T *) GPIO_DBNCECON_BASE)    /*!< Interrupt De-bounce Cycle Control Configuration Struct */
N
N#define UART0               ((UART_T *) UART0_BASE)
N#define UART1               ((UART_T *) UART1_BASE)
N#define UART2               ((UART_T *) UART2_BASE)
N
N#define TIMER0              ((TIMER_T *) TIMER0_BASE)                   /*!< Timer0 Configuration Struct                      */
N#define TIMER1              ((TIMER_T *) TIMER1_BASE)                   /*!< Timer1 Configuration Struct                      */
N#define TIMER2              ((TIMER_T *) TIMER2_BASE)                   /*!< Timer2 Configuration Struct                      */
N#define TIMER3              ((TIMER_T *) TIMER3_BASE)                   /*!< Timer3 Configuration Struct                      */
N
N#define WDT                 ((WDT_T *) WDT_BASE)                        /*!< Watchdog Timer Configuration Struct              */
N
N#define WWDT                ((WWDT_T *) WWDT_BASE)                      /*!< Window Watchdog Timer Configuration Struct       */
N
N#define SPI0                ((SPI_T *) SPI0_BASE)                       /*!< SPI0 Configuration Struct                        */
N#define SPI1                ((SPI_T *) SPI1_BASE)                       /*!< SPI1 Configuration Struct                        */
N#define SPI2                ((SPI_T *) SPI2_BASE)                       /*!< SPI2 Configuration Struct                        */
N#define SPI3                ((SPI_T *) SPI3_BASE)                       /*!< SPI3 Configuration Struct                        */
N
N#define I2C0                ((I2C_T *) I2C0_BASE)                       /*!< I2C0 Configuration Struct                        */
N#define I2C1                ((I2C_T *) I2C1_BASE)                       /*!< I2C1 Configuration Struct                        */
N
N#define I2S                 ((I2S_T *) I2S_BASE)                        /*!< I2S Configuration Struct                         */
N
N#define RTC                 ((RTC_T *) RTC_BASE)                        /*!< RTC Configuration Struct                         */
N
N#define ADC                 ((ADC_T *) ADC_BASE)                        /*!< ADC Configuration Struct                         */
N
N#define ACMP                ((ACMP_T *) ACMP_BASE)                      /*!< ACMP Configuration Struct                        */
N
N#define CLK                 ((CLK_T *) CLK_BASE)                        /*!< System Clock Controller Configuration Struct     */
N
N#define SYS                 ((GCR_T *) GCR_BASE)                        /*!< System Global Controller Configuration Struct    */
N
N#define SYSINT              ((GCR_INT_T *) INT_BASE)                    /*!< Interrupt Source Controller Configuration Struct */
N
N#define FMC                 ((FMC_T *) FMC_BASE)
N
N#define PS2                 ((PS2_T *) PS2_BASE)                        /*!< PS/2 Configuration Struct                        */
N
N#define CAN                 ((CAN_T *) CAN0_BASE)
N#define CAN0                ((CAN_T *) CAN0_BASE)                                               /*!< CAN0 Configuration Struct                        */
N#define CAN1                ((CAN_T *) CAN1_BASE)                                               /*!< CAN1 Configuration Struct                        */
N
N#define USBD                ((USBD_T *) USBD_BASE)                      /*!< USBD Configuration Struct                        */
N
N#define PDMA0               ((PDMA_T *) PDMA0_BASE)                     /*!< PDMA0 Configuration Struct                       */
N#define PDMA1               ((PDMA_T *) PDMA1_BASE)                     /*!< PDMA1 Configuration Struct                       */
N#define PDMA2               ((PDMA_T *) PDMA2_BASE)                     /*!< PDMA2 Configuration Struct                       */
N#define PDMA3               ((PDMA_T *) PDMA3_BASE)                     /*!< PDMA3 Configuration Struct                       */
N#define PDMA4               ((PDMA_T *) PDMA4_BASE)                     /*!< PDMA4 Configuration Struct                       */
N#define PDMA5               ((PDMA_T *) PDMA5_BASE)                     /*!< PDMA5 Configuration Struct                       */
N#define PDMA6               ((PDMA_T *) PDMA6_BASE)                     /*!< PDMA6 Configuration Struct                       */
N#define PDMA7               ((PDMA_T *) PDMA7_BASE)                     /*!< PDMA7 Configuration Struct                       */
N#define PDMA8               ((PDMA_T *) PDMA8_BASE)                     /*!< PDMA8 Configuration Struct                       */
N
N#define PDMA_GCR            ((PDMA_GCR_T *) PDMA_GCR_BASE)              /*!< PDMA Global Configuration Struct                 */
N
N#define CRC                 ((CRC_T *) CRC_BASE)                        /*!< CRC Configuration Struct                         */
N
N#define PWMA                ((PWM_T *) PWMA_BASE)                       /*!< PWMA Configuration Struct                        */
N#define PWMB                ((PWM_T *) PWMB_BASE)                       /*!< PWMB Configuration Struct                        */
N
N#define SC0                 ((SC_T *) SC0_BASE)                         /*!< SC0 Configuration Struct                        */
N#define SC1                 ((SC_T *) SC1_BASE)                         /*!< SC1 Configuration Struct                        */
N#define SC2                 ((SC_T *) SC2_BASE)                         /*!< SC2 Configuration Struct                        */
N
N#define EBI                 ((EBI_T *) EBI_BASE)                        /*!< EBI Configuration Struct                         */
N
N/*@}*/ /* end of group PERIPHERAL */
N
N#define UNLOCKREG(x)        do{*((__IO uint32_t *)(GCR_BASE + 0x100)) = 0x59;*((__IO uint32_t *)(GCR_BASE + 0x100)) = 0x16;*((__IO uint32_t *)(GCR_BASE + 0x100)) = 0x88;}while(*((__IO uint32_t *)(GCR_BASE + 0x100))==0)
N#define LOCKREG(x)          *((__IO uint32_t *)(GCR_BASE + 0x100)) = 0x00
N
N#define REGCOPY(dest, src)  *((uint32_t *)&(dest)) = *((uint32_t *)&(src))
N#define CLEAR(dest)         *((uint32_t *)&(dest)) = 0
N
N//=============================================================================
N/** @addtogroup IO_ROUTINE I/O routines
N  The Declaration of I/O routines
N  @{
N */
N
Ntypedef volatile unsigned char  vu8;        ///< Define 8-bit unsigned volatile data type
Ntypedef volatile unsigned short vu16;       ///< Define 16-bit unsigned volatile data type
Ntypedef volatile unsigned long  vu32;       ///< Define 32-bit unsigned volatile data type
N
N/**
N  * @brief Get a 8-bit unsigned value from specified address
N  * @param[in] addr Address to get 8-bit data from
N  * @return  8-bit unsigned value stored in specified address
N  */
N#define M8(addr)  (*((vu8  *) (addr)))
N
N/**
N  * @brief Get a 16-bit unsigned value from specified address
N  * @param[in] addr Address to get 16-bit data from
N  * @return  16-bit unsigned value stored in specified address
N  * @note The input address must be 16-bit aligned
N  */
N#define M16(addr) (*((vu16 *) (addr)))
N
N/**
N  * @brief Get a 32-bit unsigned value from specified address
N  * @param[in] addr Address to get 32-bit data from
N  * @return  32-bit unsigned value stored in specified address
N  * @note The input address must be 32-bit aligned
N  */
N#define M32(addr) (*((vu32 *) (addr)))
N
N/**
N  * @brief Set a 32-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 32-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 32-bit aligned
N  */
N#define outpw(port,value)     *((volatile unsigned int *)(port)) = value
N
N/**
N  * @brief Get a 32-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 32-bit data from
N  * @return  32-bit unsigned value stored in specified I/O port
N  * @note The input port must be 32-bit aligned
N  */
N#define inpw(port)            (*((volatile unsigned int *)(port)))
N
N/**
N  * @brief Set a 16-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 16-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 16-bit aligned
N  */
N#define outps(port,value)     *((volatile unsigned short *)(port)) = value
N
N/**
N  * @brief Get a 16-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 16-bit data from
N  * @return  16-bit unsigned value stored in specified I/O port
N  * @note The input port must be 16-bit aligned
N  */
N#define inps(port)            (*((volatile unsigned short *)(port)))
N
N/**
N  * @brief Set a 8-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 8-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  */
N#define outpb(port,value)     *((volatile unsigned char *)(port)) = value
N
N/**
N  * @brief Get a 8-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 8-bit data from
N  * @return  8-bit unsigned value stored in specified I/O port
N  */
N#define inpb(port)            (*((volatile unsigned char *)(port)))
N
N/**
N  * @brief Set a 32-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 32-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 32-bit aligned
N  */
N#define outp32(port,value)    *((volatile unsigned int *)(port)) = value
N
N/**
N  * @brief Get a 32-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 32-bit data from
N  * @return  32-bit unsigned value stored in specified I/O port
N  * @note The input port must be 32-bit aligned
N  */
N#define inp32(port)           (*((volatile unsigned int *)(port)))
N
N/**
N  * @brief Set a 16-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 16-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  * @note The output port must be 16-bit aligned
N  */
N#define outp16(port,value)    *((volatile unsigned short *)(port)) = value
N
N/**
N  * @brief Get a 16-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 16-bit data from
N  * @return  16-bit unsigned value stored in specified I/O port
N  * @note The input port must be 16-bit aligned
N  */
N#define inp16(port)           (*((volatile unsigned short *)(port)))
N
N/**
N  * @brief Set a 8-bit unsigned value to specified I/O port
N  * @param[in] port Port address to set 8-bit data
N  * @param[in] value Value to write to I/O port
N  * @return  None
N  */
N#define outp8(port,value)     *((volatile unsigned char *)(port)) = value
N
N/**
N  * @brief Get a 8-bit unsigned value from specified I/O port
N  * @param[in] port Port address to get 8-bit data from
N  * @return  8-bit unsigned value stored in specified I/O port
N  */
N#define inp8(port)            (*((volatile unsigned char *)(port)))
N
N/*@}*/ /* end of group IO_ROUTINE */
N
N
N
N
N/** @addtogroup legacy_Constants Legacy Constants
N  Legacy Constants
N  @{
N*/
N
N
N#define E_SUCCESS   0
N#ifndef NULL
S#define NULL        0
N#endif
N
N#define TRUE        1
N#define FALSE       0
N
N#define ENABLE     1
N#define DISABLE    0
N
N/* Define one bit mask */
N#define BIT0    0x00000001
N#define BIT1    0x00000002
N#define BIT2    0x00000004
N#define BIT3    0x00000008
N#define BIT4    0x00000010
N#define BIT5    0x00000020
N#define BIT6    0x00000040
N#define BIT7    0x00000080
N#define BIT8    0x00000100
N#define BIT9    0x00000200
N#define BIT10   0x00000400
N#define BIT11   0x00000800
N#define BIT12   0x00001000
N#define BIT13   0x00002000
N#define BIT14   0x00004000
N#define BIT15   0x00008000
N#define BIT16   0x00010000
N#define BIT17   0x00020000
N#define BIT18   0x00040000
N#define BIT19   0x00080000
N#define BIT20   0x00100000
N#define BIT21   0x00200000
N#define BIT22   0x00400000
N#define BIT23   0x00800000
N#define BIT24   0x01000000
N#define BIT25   0x02000000
N#define BIT26   0x04000000
N#define BIT27   0x08000000
N#define BIT28   0x10000000
N#define BIT29   0x20000000
N#define BIT30   0x40000000
N#define BIT31   0x80000000
N
N/* Byte Mask Definitions */
N#define BYTE0_Msk               (0x000000FF)
N#define BYTE1_Msk               (0x0000FF00)
N#define BYTE2_Msk               (0x00FF0000)
N#define BYTE3_Msk               (0xFF000000)
N
N#define _GET_BYTE0(u32Param)    (((u32Param) & BYTE0_Msk)      )  /*!< Extract Byte 0 (Bit  0~ 7) from parameter u32Param */
N#define _GET_BYTE1(u32Param)    (((u32Param) & BYTE1_Msk) >>  8)  /*!< Extract Byte 1 (Bit  8~15) from parameter u32Param */
N#define _GET_BYTE2(u32Param)    (((u32Param) & BYTE2_Msk) >> 16)  /*!< Extract Byte 2 (Bit 16~23) from parameter u32Param */
N#define _GET_BYTE3(u32Param)    (((u32Param) & BYTE3_Msk) >> 24)  /*!< Extract Byte 3 (Bit 24~31) from parameter u32Param */
N
N/*@}*/ /* end of group legacy_Constants */
N
N/*@}*/ /* end of group Definitions */
N
N
N/******************************************************************************/
N/*                         Peripheral header files                            */
N/******************************************************************************/
N#include "SYS.h"
L 1 ".\Libraries\StdDriver\inc\SYS.h" 1
N/**************************************************************************//**
N * @file     sys.h
N * @version  V3.00
N * $Revision: 16 $
N * $Date: 15/07/21 2:45p $
N * @brief    NUC230_240 Series SYS Driver Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __SYS_H__
N#define __SYS_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup SYS_Driver SYS Driver
N  @{
N*/
N
N/** @addtogroup SYS_EXPORTED_CONSTANTS SYS Exported Constants
N  @{
N*/
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Module Reset Control Resister constant definitions.                                                    */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PDMA_RST    ((0x0<<24) | SYS_IPRSTC1_PDMA_RST_Pos  ) /*!< PDMA reset is one of the SYS_ResetModule parameter */
N#define EBI_RST     ((0x0<<24) | SYS_IPRSTC1_EBI_RST_Pos   ) /*!< EBI reset is one of the SYS_ResetModule parameter */
N#define GPIO_RST    ((0x4<<24) | SYS_IPRSTC2_GPIO_RST_Pos  ) /*!< GPIO reset is one of the SYS_ResetModule parameter */
N#define TMR0_RST    ((0x4<<24) | SYS_IPRSTC2_TMR0_RST_Pos  ) /*!< TMR0 reset is one of the SYS_ResetModule parameter */
N#define TMR1_RST    ((0x4<<24) | SYS_IPRSTC2_TMR1_RST_Pos  ) /*!< TMR1 reset is one of the SYS_ResetModule parameter */
N#define TMR2_RST    ((0x4<<24) | SYS_IPRSTC2_TMR2_RST_Pos  ) /*!< TMR2 reset is one of the SYS_ResetModule parameter */
N#define TMR3_RST    ((0x4<<24) | SYS_IPRSTC2_TMR3_RST_Pos  ) /*!< TMR3 reset is one of the SYS_ResetModule parameter */
N#define I2C0_RST    ((0x4<<24) | SYS_IPRSTC2_I2C0_RST_Pos  ) /*!< I2C0 reset is one of the SYS_ResetModule parameter */
N#define I2C1_RST    ((0x4<<24) | SYS_IPRSTC2_I2C1_RST_Pos  ) /*!< I2C1 reset is one of the SYS_ResetModule parameter */
N#define SPI0_RST    ((0x4<<24) | SYS_IPRSTC2_SPI0_RST_Pos  ) /*!< SPI0 reset is one of the SYS_ResetModule parameter */
N#define SPI1_RST    ((0x4<<24) | SYS_IPRSTC2_SPI1_RST_Pos  ) /*!< SPI1 reset is one of the SYS_ResetModule parameter */
N#define SPI2_RST    ((0x4<<24) | SYS_IPRSTC2_SPI2_RST_Pos  ) /*!< SPI2 reset is one of the SYS_ResetModule parameter */
N#define SPI3_RST    ((0x4<<24) | SYS_IPRSTC2_SPI3_RST_Pos  ) /*!< SPI3 reset is one of the SYS_ResetModule parameter */
N#define UART0_RST   ((0x4<<24) | SYS_IPRSTC2_UART0_RST_Pos ) /*!< UART0 reset is one of the SYS_ResetModule parameter */
N#define UART1_RST   ((0x4<<24) | SYS_IPRSTC2_UART1_RST_Pos ) /*!< UART1 reset is one of the SYS_ResetModule parameter */
N#define UART2_RST   ((0x4<<24) | SYS_IPRSTC2_UART2_RST_Pos ) /*!< UART1 reset is one of the SYS_ResetModule parameter */
N#define PWM03_RST   ((0x4<<24) | SYS_IPRSTC2_PWM03_RST_Pos ) /*!< PWM03 reset is one of the SYS_ResetModule parameter */
N#define PWM47_RST   ((0x4<<24) | SYS_IPRSTC2_PWM47_RST_Pos ) /*!< PWM47 reset is one of the SYS_ResetModule parameter */
N#define ACMP_RST    ((0x4<<24) | SYS_IPRSTC2_ACMP_RST_Pos  ) /*!< ACMP reset is one of the SYS_ResetModule parameter */
N#define PS2_RST     ((0x4<<24) | SYS_IPRSTC2_PS2_RST_Pos   ) /*!< PS2 reset is one of the SYS_ResetModule parameter */
N#define CAN0_RST    ((0x4<<24) | SYS_IPRSTC2_CAN0_RST_Pos  ) /*!< CAN0 reset is one of the SYS_ResetModule parameter */
N#define CAN1_RST    ((0x4<<24) | SYS_IPRSTC2_CAN1_RST_Pos  ) /*!< CAN1 reset is one of the SYS_ResetModule parameter */
N#define USBD_RST    ((0x4<<24) | SYS_IPRSTC2_USBD_RST_Pos  ) /*!< USBD reset is one of the SYS_ResetModule parameter */
N#define ADC_RST     ((0x4<<24) | SYS_IPRSTC2_ADC_RST_Pos   ) /*!< ADC reset is one of the SYS_ResetModule parameter */
N#define I2S_RST     ((0x4<<24) | SYS_IPRSTC2_I2S_RST_Pos   ) /*!< I2S reset is one of the SYS_ResetModule parameter */
N#define SC0_RST     ((0x8<<24) | SYS_IPRSTC3_SC0_RST_Pos   ) /*!< SC0 reset is one of the SYS_ResetModule parameter */
N#define SC1_RST     ((0x8<<24) | SYS_IPRSTC3_SC1_RST_Pos   ) /*!< SC1 reset is one of the SYS_ResetModule parameter */
N#define SC2_RST     ((0x8<<24) | SYS_IPRSTC3_SC2_RST_Pos   ) /*!< SC2 reset is one of the SYS_ResetModule parameter */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Brown Out Detector Threshold Voltage Selection constant definitions.                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N#define SYS_BODCR_BOD_RST_EN            (1UL<<SYS_BODCR_BOD_RSTEN_Pos)    /*!< Brown-out Reset Enable */
N#define SYS_BODCR_BOD_INTERRUPT_EN      (0UL<<SYS_BODCR_BOD_RSTEN_Pos)    /*!< Brown-out Interrupt Enable */
N#define SYS_BODCR_BOD_VL_4_4V           (3UL<<SYS_BODCR_BOD_VL_Pos)       /*!< Setting Brown Out Detector Threshold Voltage as 4.4V */
N#define SYS_BODCR_BOD_VL_3_7V           (2UL<<SYS_BODCR_BOD_VL_Pos)       /*!< Setting Brown Out Detector Threshold Voltage as 3.7V */
N#define SYS_BODCR_BOD_VL_2_7V           (1UL<<SYS_BODCR_BOD_VL_Pos)       /*!< Setting Brown Out Detector Threshold Voltage as 2.7V */
N#define SYS_BODCR_BOD_VL_2_2V           (0UL<<SYS_BODCR_BOD_VL_Pos)       /*!< Setting Brown Out Detector Threshold Voltage as 2.2V */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Multi-Function constant definitions.                                                                   */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/* How to use below #define?
NExample: If user want to set PA.0 as ADC0 and PA1 as ADC1 in initial function,
N         user can issue following command to achieve it.
N
N         SYS->GPA_MFP  = SYS_GPA_MFP_PA0_ADC0 | SYS_GPA_MFP_PA1_ADC1;
N         SYS->ALT_MFP1 = SYS_ALT_MFP1_PA0_ADC0| SYS_ALT_MFP1_PA1_ADC1;
N*/
N
N//PA.0
N#define SYS_GPA_MFP_PA0_GPIO        0x00000000UL        /*!< GPA_MFP PA.0 setting for GPIO */
N#define SYS_ALT_MFP_PA0_GPIO        NULL                /*!< No ALT_MFP setting for PA.0 */
N#define SYS_ALT_MFP1_PA0_GPIO       0x00000000UL        /*!< ALT_MFP1 PA.0 setting for GPIO */
N#define SYS_ALT_MFP2_PA0_GPIO       NULL                /*!< No ALT_MFP2 setting for PA.0 */
N
N#define SYS_GPA_MFP_PA0_ADC0        (1UL<<0)            /*!< GPA_MFP PA.0 setting for ADC0 */
N#define SYS_ALT_MFP_PA0_ADC0        NULL                /*!< No ALT_MFP setting for PA.0 */
N#define SYS_ALT_MFP1_PA0_ADC0       0x00000000UL        /*!< ALT_MFP1 PA.0 setting for ADC0 */
N#define SYS_ALT_MFP2_PA0_ADC0       NULL                /*!< No ALT_MFP2 setting for PA.0 */
N
N#define SYS_GPA_MFP_PA0_SC0_PWR     (1UL<<0)            /*!< GPA_MFP PA.0 setting for SC0_PWR */
N#define SYS_ALT_MFP_PA0_SC0_PWR     NULL                /*!< No ALT_MFP setting for PA.0 */
N#define SYS_ALT_MFP1_PA0_SC0_PWR    (1UL<<2)            /*!< ALT_MFP1 PA.0 setting for SC0_PWR */
N#define SYS_ALT_MFP2_PA0_SC0_PWR    NULL                /*!< No ALT_MFP2 setting for PA.0 */
N
N#define SYS_GPA_MFP_PA0_Msk         (1UL<<0)            /*!< GPA_MFP PA.0 mask */
N#define SYS_ALT_MFP1_PA0_Msk        (1UL<<2)            /*!< ALT_MFP1 PA.0 mask */
N
N//PA.1
N#define SYS_GPA_MFP_PA1_GPIO        0x00000000UL        /*!< GPA_MFP PA.1 setting for GPIO */
N#define SYS_ALT_MFP_PA1_GPIO        0x00000000UL        /*!< ALT_MFP PA.1 setting for GPIO */
N#define SYS_ALT_MFP1_PA1_GPIO       0x00000000UL        /*!< ALT_MFP1 PA.1 setting for GPIO */
N#define SYS_ALT_MFP2_PA1_GPIO       NULL                /*!< No ALT_MFP2 setting for PA.1 */
N
N#define SYS_GPA_MFP_PA1_ADC1        (1UL<<1)            /*!< GPA_MFP PA.1 setting for ADC1 */
N#define SYS_ALT_MFP_PA1_ADC1        0x00000000UL        /*!< ALT_MFP PA.1 setting for ADC1  */
N#define SYS_ALT_MFP1_PA1_ADC1       0x00000000UL        /*!< ALT_MFP1 PA.1 setting for ADC1 */
N#define SYS_ALT_MFP2_PA1_ADC1       NULL                /*!< No ALT_MFP2 setting for PA.1 */
N
N#define SYS_GPA_MFP_PA1_SC0_RST     (1UL<<1)            /*!< GPA_MFP PA.1 setting for SC0_RST */
N#define SYS_ALT_MFP_PA1_SC0_RST     0x00000000UL        /*!< ALT_MFP PA.1 setting for SC0_RST */
N#define SYS_ALT_MFP1_PA1_SC0_RST    (1UL<<3)            /*!< ALT_MFP1 PA.1 setting for SC0_RST */
N#define SYS_ALT_MFP2_PA1_SC0_RST    NULL                /*!< No ALT_MFP2 setting for PA.1 */
N
N#define SYS_GPA_MFP_PA1_AD12        (1UL<<1)                /*!< GPA_MFP PA.1 setting for AD12  */
N#define SYS_ALT_MFP_PA1_AD12        ((1UL<<11) | (1UL<<20)) /*!< GPA_MFP PA.1 setting for AD12  */
N#define SYS_ALT_MFP1_PA1_AD12       0x00000000UL            /*!< ALT_MFP1 PA.1 setting for AD12 */
N#define SYS_ALT_MFP2_PA1_AD12       NULL                    /*!< No ALT_MFP2 setting for PA.1   */
N
N#define SYS_GPA_MFP_PA1_Msk         (1UL<<1)                /*!< GPA_MFP PA.1 mask */
N#define SYS_ALT_MFP_PA1_Msk         ((1UL<<11) | (1UL<<20)) /*!< ALT_MFP PA.1 mask */
N#define SYS_ALT_MFP1_PA1_Msk        (1UL<<3)                /*!< ALT_MFP1 PA.1 mask */
N
N//PA.2
N#define SYS_GPA_MFP_PA2_GPIO        0x00000000UL        /*!< GPA_MFP PA.2 setting for GPIO */
N#define SYS_ALT_MFP_PA2_GPIO        0x00000000UL        /*!< ALT_MFP PA.2 setting for GPIO */
N#define SYS_ALT_MFP1_PA2_GPIO       0x00000000UL        /*!< ALT_MFP1 PA.2 setting for GPIO */
N#define SYS_ALT_MFP2_PA2_GPIO       NULL                /*!< No ALT_MFP2 setting for PA.2 */
N
N#define SYS_GPA_MFP_PA2_ADC2        (1UL<<2)            /*!< GPA_MFP PA.2 setting for ADC2 */
N#define SYS_ALT_MFP_PA2_ADC2        0x00000000UL        /*!< ALT_MFP PA.2 setting for ADC2 */
N#define SYS_ALT_MFP1_PA2_ADC2       0x00000000UL        /*!< ALT_MFP1 PA.2 setting for ADC2 */
N#define SYS_ALT_MFP2_PA2_ADC2       NULL                /*!< No ALT_MFP2 setting for PA.2 */
N
N#define SYS_GPA_MFP_PA2_SC0_CLK     (1UL<<2)            /*!< GPA_MFP PA.2 setting for SC0_CLK */
N#define SYS_ALT_MFP_PA2_SC0_CLK     0x00000000UL        /*!< ALT_MFP1 PA.2 setting for SC0_CLK */
N#define SYS_ALT_MFP1_PA2_SC0_CLK    (1UL<<0)            /*!< ALT_MFP1 PA.2 setting for SC0_CLK */
N#define SYS_ALT_MFP2_PA2_SC0_CLK    NULL                /*!< No ALT_MFP2 setting for PA.2 */
N
N#define SYS_GPA_MFP_PA2_UART3_TXD   (1UL<<2)            /*!< GPA_MFP PA.2 setting for UART3_TXD */
N#define SYS_ALT_MFP_PA2_UART3_TXD   0x00000000UL        /*!< ALT_MFP PA.2 setting for UART3_TXD */
N#define SYS_ALT_MFP1_PA2_UART3_TXD  (1UL<<0)            /*!< ALT_MFP1 PA.2 setting for UART3_TXD */
N#define SYS_ALT_MFP2_PA2_UART3_TXD  NULL                /*!< No ALT_MFP2 setting for PA.2 */
N
N#define SYS_GPA_MFP_PA2_AD11        (1UL<<2)                /*!< GPA_MFP PA.2 setting for AD11  */
N#define SYS_ALT_MFP_PA2_AD11        ((1UL<<11) | (1UL<<19)) /*!< ALT_MFP PA.2 setting for AD11  */
N#define SYS_ALT_MFP1_PA2_AD11       0x00000000UL            /*!< ALT_MFP1 PA.2 setting for AD11 */
N#define SYS_ALT_MFP2_PA2_AD11       NULL                    /*!< No ALT_MFP2 setting for PA.2   */
N
N#define SYS_GPA_MFP_PA2_Msk         (1UL<<2)                /*!< GPA_MFP PA.2 mask             */
N#define SYS_ALT_MFP_PA2_Msk         ((1UL<<11) | (1UL<<19)) /*!< ALT_MFP PA.2 mask             */
N#define SYS_ALT_MFP1_PA2_Msk        (1UL<<0)                /*!< ALT_MFP1 PA.2 mask            */
N
N//PA.3
N#define SYS_GPA_MFP_PA3_GPIO        0x00000000UL        /*!< GPA_MFP PA.3 setting for GPIO */
N#define SYS_ALT_MFP_PA3_GPIO        0x00000000UL        /*!< ALT_MFP PA.3 setting for GPIO */
N#define SYS_ALT_MFP1_PA3_GPIO       0x00000000UL        /*!< ALT_MFP1 PA.3 setting for GPIO */
N#define SYS_ALT_MFP2_PA3_GPIO       NULL                /*!< No ALT_MFP2 setting for PA.3 */
N
N#define SYS_GPA_MFP_PA3_ADC3        (1UL<<3)            /*!< GPA_MFP PA.3 setting for ADC3 */
N#define SYS_ALT_MFP_PA3_ADC3        0x00000000UL        /*!< ALT_MFP PA.3 setting for ADC3 */
N#define SYS_ALT_MFP1_PA3_ADC3       0x00000000UL        /*!< ALT_MFP1 PA.3 setting for ADC3 */
N#define SYS_ALT_MFP2_PA3_ADC3       NULL                /*!< No ALT_MFP2 setting for PA.3 */
N
N#define SYS_GPA_MFP_PA3_SC0_DAT     (1UL<<3)            /*!< GPA_MFP PA.3 setting for SC0_DAT */
N#define SYS_ALT_MFP_PA3_SC0_DAT     0x00000000UL        /*!< ALT_MFP PA.3 setting for SC0_DAT */
N#define SYS_ALT_MFP1_PA3_SC0_DAT    (1UL<<1)            /*!< ALT_MFP1 PA.3 setting for SC0_DAT */
N#define SYS_ALT_MFP2_PA3_SC0_DAT    NULL                /*!< No ALT_MFP2 setting for PA.3 */
N
N#define SYS_GPA_MFP_PA3_UART3_RXD   (1UL<<3)            /*!< GPA_MFP PA.3 setting for UART3_RXD */
N#define SYS_ALT_MFP_PA3_UART3_RXD   0x00000000UL        /*!< ALT_MFP PA.3 setting for UART3_RXD */
N#define SYS_ALT_MFP1_PA3_UART3_RXD  (1UL<<1)            /*!< ALT_MFP1 PA.3 setting for UART3_RXD */
N#define SYS_ALT_MFP2_PA3_UART3_RXD  NULL                /*!< No ALT_MFP2 setting for PA.3 */
N
N#define SYS_GPA_MFP_PA3_AD10        (1UL<<3)                /*!< GPA_MFP PA.3 setting for AD10  */
N#define SYS_ALT_MFP_PA3_AD10        ((1UL<<11) | (1UL<<18)) /*!< ALT_MFP PA.3 setting for AD10  */
N#define SYS_ALT_MFP1_PA3_AD10       0x00000000UL            /*!< ALT_MFP1 PA.3 setting for AD10 */
N#define SYS_ALT_MFP2_PA3_AD10       NULL                    /*!< No ALT_MFP2 setting for PA.3   */
N
N#define SYS_GPA_MFP_PA3_Msk         (1UL<<3)                /*!< GPA_MFP PA.3 mask              */
N#define SYS_ALT_MFP_PA3_Msk         ((1UL<<11) | (1UL<<18)) /*!< ALT_MFP PA.3 mask              */
N#define SYS_ALT_MFP1_PA3_Msk        (1UL<<1)                /*!< ALT_MFP1 PA.3 mask             */
N
N//PA.4
N#define SYS_GPA_MFP_PA4_GPIO        0x00000000UL        /*!< GPA_MFP PA.4 setting for GPIO */
N#define SYS_ALT_MFP_PA4_GPIO        0x00000000UL        /*!< ALT_MFP PA.4 setting for GPIO */
N#define SYS_ALT_MFP1_PA4_GPIO       0x00000000UL        /*!< ALT_MFP1 PA.4 setting for GPIO */
N#define SYS_ALT_MFP2_PA4_GPIO       NULL                /*!< No ALT_MFP2 setting for PA.4 */
N
N#define SYS_GPA_MFP_PA4_ADC4        (1UL<<4)            /*!< GPA_MFP PA.4 setting for ADC4 */
N#define SYS_ALT_MFP_PA4_ADC4        0x00000000UL        /*!< ALT_MFP PA.4 setting for ADC4 */
N#define SYS_ALT_MFP1_PA4_ADC4       0x00000000UL        /*!< ALT_MFP1 PA.4 setting for ADC4 */
N#define SYS_ALT_MFP2_PA4_ADC4       NULL                /*!< No ALT_MFP2 setting for PA.4 */
N
N#define SYS_GPA_MFP_PA4_SC1_PWR     (1UL<<4)            /*!< GPA_MFP PA.4 setting for SC1_PWR */
N#define SYS_ALT_MFP_PA4_SC1_PWR     0x00000000UL        /*!< ALT_MFP PA.4 setting for SC1_PWR */
N#define SYS_ALT_MFP1_PA4_SC1_PWR    (1UL<<7)            /*!< ALT_MFP1 PA.4 setting for SC1_PWR */
N#define SYS_ALT_MFP2_PA4_SC1_PWR    NULL                /*!< No ALT_MFP2 setting for PA.4 */
N
N#define SYS_GPA_MFP_PA4_AD9         (1UL<<4)                /*!< GPA_MFP PA.4 setting for AD9   */
N#define SYS_ALT_MFP_PA4_AD9         ((1UL<<11) | (1UL<<17)) /*!< ALT_MFP PA.4 setting for AD9   */
N#define SYS_ALT_MFP1_PA4_AD9        0x00000000UL            /*!< ALT_MFP1 PA.4 setting for AD9  */
N#define SYS_ALT_MFP2_PA4_AD9        NULL                    /*!< No ALT_MFP2 setting for PA.4   */
N
N#define SYS_GPA_MFP_PA4_Msk         (1UL<<4)                /*!< GPA_MFP PA.4 mask              */
N#define SYS_ALT_MFP_PA4_Msk         ((1UL<<11) | (1UL<<17)) /*!< ALT_MFP PA.4 mask              */
N#define SYS_ALT_MFP1_PA4_Msk        (1UL<<7)                /*!< ALT_MFP1 PA.4 mask             */
N
N//PA.5
N#define SYS_GPA_MFP_PA5_GPIO        0x00000000UL        /*!< GPA_MFP PA.5 setting for GPIO */
N#define SYS_ALT_MFP_PA5_GPIO        0x00000000UL        /*!< ALT_MFP PA.5 setting for GPIO */
N#define SYS_ALT_MFP1_PA5_GPIO       0x00000000UL        /*!< ALT_MFP1 PA.5 setting for GPIO */
N#define SYS_ALT_MFP2_PA5_GPIO       NULL                /*!< No ALT_MFP2 setting for PA.5 */
N
N#define SYS_GPA_MFP_PA5_ADC5        (1UL<<5)            /*!< GPA_MFP PA.5 setting for ADC5 */
N#define SYS_ALT_MFP_PA5_ADC5        0x00000000UL        /*!< ALT_MFP PA.5 setting for ADC5 */
N#define SYS_ALT_MFP1_PA5_ADC5       0x00000000UL        /*!< ALT_MFP1 PA.5 setting for ADC5 */
N#define SYS_ALT_MFP2_PA5_ADC5       NULL                /*!< No ALT_MFP2 setting for PA.5 */
N
N#define SYS_GPA_MFP_PA5_SC1_RST     (1UL<<5)            /*!< GPA_MFP PA.5 setting for SC1_RST */
N#define SYS_ALT_MFP_PA5_SC1_RST     0x00000000UL        /*!< ALT_MFP PA.5 setting for SC1_RST */
N#define SYS_ALT_MFP1_PA5_SC1_RST    (1UL<<8)            /*!< ALT_MFP1 PA.5 setting for SC1_RST */
N#define SYS_ALT_MFP2_PA5_SC1_RST    NULL                /*!< No ALT_MFP2 setting for PA.5 */
N
N#define SYS_GPA_MFP_PA5_AD8         (1UL<<5)                /*!< GPA_MFP PA.5 setting for AD8   */
N#define SYS_ALT_MFP_PA5_AD8         ((1UL<<11) | (1UL<<16)) /*!< ALT_MFP PA.5 setting for AD8   */
N#define SYS_ALT_MFP1_PA5_AD8        0x00000000UL            /*!< ALT_MFP1 PA.5 setting for AD8  */
N#define SYS_ALT_MFP2_PA5_AD8        NULL                    /*!< No ALT_MFP2 setting for PA.5   */
N
N#define SYS_GPA_MFP_PA5_Msk         (1UL<<5)                /*!< GPA_MFP PA.5 mask  */
N#define SYS_ALT_MFP_PA5_Msk         ((1UL<<11) | (1UL<<16)) /*!< ALT_MFP PA.5 mask  */
N#define SYS_ALT_MFP1_PA5_Msk        (1UL<<8)                /*!< ALT_MFP1 PA.5 mask */
N
N//PA.6
N#define SYS_GPA_MFP_PA6_GPIO        0x00000000UL        /*!< GPA_MFP PA.6 setting for GPIO */
N#define SYS_ALT_MFP_PA6_GPIO        0x00000000UL        /*!< ALT_MFP PA.6 setting for GPIO */
N#define SYS_ALT_MFP1_PA6_GPIO       0x00000000UL        /*!< ALT_MFP1 PA.6 setting for GPIO */
N#define SYS_ALT_MFP2_PA6_GPIO       NULL                /*!< No ALT_MFP2 setting for PA.6 */
N
N#define SYS_GPA_MFP_PA6_ADC6        (1UL<<6)            /*!< GPA_MFP PA.6 setting for ADC6 */
N#define SYS_ALT_MFP_PA6_ADC6        0x00000000UL        /*!< ALT_MFP PA.6 setting for ADC6 */
N#define SYS_ALT_MFP1_PA6_ADC6       0x00000000UL        /*!< ALT_MFP1 PA.6 setting for ADC6 */
N#define SYS_ALT_MFP2_PA6_ADC6       NULL                /*!< No ALT_MFP2 setting for PA.6 */
N
N#define SYS_GPA_MFP_PA6_SC1_CLK     (1UL<<6)            /*!< GPA_MFP PA.6 setting for SC1_CLK */
N#define SYS_ALT_MFP_PA6_SC1_CLK     0x00000000UL        /*!< ALT_MFP PA.6 setting for SC1_CLK */
N#define SYS_ALT_MFP1_PA6_SC1_CLK    (1UL<<5)            /*!< ALT_MFP1 PA.6 setting for SC1_CLK */
N#define SYS_ALT_MFP2_PA6_SC1_CLK    NULL                /*!< No ALT_MFP2 setting for PA.6 */
N
N#define SYS_GPA_MFP_PA6_UART4_TXD   (1UL<<6)            /*!< GPA_MFP PA.6 setting for UART4_TXD */
N#define SYS_ALT_MFP_PA6_UART4_TXD   0x00000000UL        /*!< ALT_MFP PA.6 setting for UART4_TXD */
N#define SYS_ALT_MFP1_PA6_UART4_TXD  (1UL<<5)            /*!< ALT_MFP1 PA.6 setting for UART4_TXD */
N#define SYS_ALT_MFP2_PA6_UART4_TXD  NULL                /*!< No ALT_MFP2 setting for PA.6 */
N
N#define SYS_GPA_MFP_PA6_AD7         (1UL<<6)            /*!< GPA_MFP PA.6 setting for AD7   */
N#define SYS_ALT_MFP_PA6_AD7         (1UL<<11)           /*!< ALT_MFP PA.6 setting for AD7   */
N#define SYS_ALT_MFP1_PA6_AD7        0x00000000UL        /*!< ALT_MFP1 PA.6 setting for AD7  */
N#define SYS_ALT_MFP2_PA6_AD7        NULL                /*!< No ALT_MFP2 setting for PA.6   */
N
N#define SYS_GPA_MFP_PA6_Msk         (1UL<<6)            /*!< GPA_MFP PA.6 mask  */
N#define SYS_ALT_MFP_PA6_Msk         (1UL<<11)           /*!< ALT_MFP PA.6 mask  */
N#define SYS_ALT_MFP1_PA6_Msk        (1UL<<5)            /*!< ALT_MFP1 PA.6 mask */
N
N//PA.7
N#define SYS_GPA_MFP_PA7_GPIO        0x00000000UL        /*!< GPA_MFP PA.7 setting for GPIO */
N#define SYS_ALT_MFP_PA7_GPIO        0x00000000UL        /*!< ALT_MFP PA.7 setting for GPIO */
N#define SYS_ALT_MFP1_PA7_GPIO       0x00000000UL        /*!< ALT_MFP1 PA.7 setting for GPIO */
N#define SYS_ALT_MFP2_PA7_GPIO       NULL                /*!< No ALT_MFP2 setting for PA.7 */
N
N#define SYS_GPA_MFP_PA7_ADC7        (1UL<<7)            /*!< GPA_MFP PA.7 setting for ADC7 */
N#define SYS_ALT_MFP_PA7_ADC7        0x00000000UL        /*!< ALT_MFP PA.7 setting for ADC7 */
N#define SYS_ALT_MFP1_PA7_ADC7       0x00000000UL        /*!< ALT_MFP1 PA.7 setting for ADC7 */
N#define SYS_ALT_MFP2_PA7_ADC7       NULL                /*!< No ALT_MFP2 setting for PA.7 */
N
N#define SYS_GPA_MFP_PA7_SPI2_SS1    (1UL<<7)            /*!< GPA_MFP PA.7 setting for SPI2_SS1 */
N#define SYS_ALT_MFP_PA7_SPI2_SS1    (1UL<<2)            /*!< ALT_MFP PA.7 setting for SPI2_SS1 */
N#define SYS_ALT_MFP1_PA7_SPI2_SS1   0x00000000UL        /*!< ALT_MFP1 PA.7 setting for SPI2_SS1n*/
N#define SYS_ALT_MFP2_PA7_SPI2_SS1   NULL                /*!< No ALT_MFP2 setting for PA.7    */
N
N#define SYS_GPA_MFP_PA7_SC1_DAT     (1UL<<7)            /*!< GPA_MFP PA.7 setting for SC1_DAT */
N#define SYS_ALT_MFP_PA7_SC1_DAT     0x00000000UL        /*!< ALT_MFP PA.7 setting for SC1_DAT */
N#define SYS_ALT_MFP1_PA7_SC1_DAT    (1UL<<6)            /*!< ALT_MFP1 PA.7 setting for SC1_DAT */
N#define SYS_ALT_MFP2_PA7_SC1_DAT    NULL                /*!< No ALT_MFP2 setting for PA.7    */
N
N#define SYS_GPA_MFP_PA7_UART4_RXD   (1UL<<7)            /*!< GPA_MFP PA.7 setting for UART4_RXD */
N#define SYS_ALT_MFP_PA7_UART4_RXD   0x00000000UL        /*!< ALT_MFP PA.7 setting for UART4_RXD */
N#define SYS_ALT_MFP1_PA7_UART4_RXD  (1UL<<6)            /*!< ALT_MFP1 PA.7 setting for UART4_RXD */
N#define SYS_ALT_MFP2_PA7_UART4_RXD  NULL                /*!< No ALT_MFP2 setting for PA.7 */
N
N#define SYS_GPA_MFP_PA7_AD6         (1UL<<7)            /*!< GPA_MFP PA.7 setting for AD6   */
N#define SYS_ALT_MFP_PA7_AD6         (1UL<<11)           /*!< ALT_MFP PA.7 setting for AD6   */
N#define SYS_ALT_MFP1_PA7_AD6        0x00000000UL        /*!< ALT_MFP1 PA.7 setting for AD6  */
N#define SYS_ALT_MFP2_PA7_AD6        NULL                /*!< No ALT_MFP2 setting for PA.7   */
N
N#define SYS_GPA_MFP_PA7_Msk         (1UL<<7)                /*!< GPA_MFP PA.7 mask             */
N#define SYS_ALT_MFP_PA7_Msk         ((1UL<<2) | (1UL<<11))  /*!< ALT_MFP PA.7 mask             */
N#define SYS_ALT_MFP1_PA7_Msk        (1UL<<6)                /*!< ALT_MFP1 PA.7 mask            */
N
N//PA.8
N#define SYS_GPA_MFP_PA8_GPIO        0x00000000UL        /*!< GPA_MFP PA.8 setting for GPIO */
N#define SYS_ALT_MFP_PA8_GPIO        NULL                /*!< No ALT_MFP setting for PA.8 */
N#define SYS_ALT_MFP1_PA8_GPIO       NULL                /*!< No ALT_MFP1 setting for PA.8 */
N#define SYS_ALT_MFP2_PA8_GPIO       NULL                /*!< No ALT_MFP2 setting for PA.8 */
N
N#define SYS_GPA_MFP_PA8_I2C0_SDA    (1UL<<8)            /*!< GPA_MFP PA.8 setting for I2C0_SDA */
N#define SYS_ALT_MFP_PA8_I2C0_SDA    NULL                /*!< No ALT_MFP setting for PA.8 */
N#define SYS_ALT_MFP1_PA8_I2C0_SDA   NULL                /*!< No ALT_MFP1 setting for PA.8 */
N#define SYS_ALT_MFP2_PA8_I2C0_SDA   NULL                /*!< No ALT_MFP2 setting for PA.8 */
N
N#define SYS_GPA_MFP_PA8_Msk         (1UL<<8)            /*!< GPA_MFP PA.8 mask             */
N
N//PA.9
N#define SYS_GPA_MFP_PA9_GPIO        0x00000000UL        /*!< GPA_MFP PA.9 setting for GPIO */
N#define SYS_ALT_MFP_PA9_GPIO        NULL                /*!< No ALT_MFP setting for PA.9   */
N#define SYS_ALT_MFP1_PA9_GPIO       NULL                /*!< No ALT_MFP1 setting for PA.9  */
N#define SYS_ALT_MFP2_PA9_GPIO       NULL                /*!< No ALT_MFP2 setting for PA.9  */
N
N#define SYS_GPA_MFP_PA9_I2C0_SCL    (1UL<<9)            /*!< GPA_MFP PA.9 setting for I2C0_SCL */
N#define SYS_ALT_MFP_PA9_I2C0_SCL    NULL                /*!< No ALT_MFP setting for PA.9   */
N#define SYS_ALT_MFP1_PA9_I2C0_SCL   NULL                /*!< No ALT_MFP1 setting for PA.9  */
N#define SYS_ALT_MFP2_PA9_I2C0_SCL   NULL                /*!< No ALT_MFP2 setting for PA.9  */
N
N#define SYS_GPA_MFP_PA9_Msk         (1UL<<9)            /*!< GPA_MFP PA.9 mask             */
N
N//PA.10
N#define SYS_GPA_MFP_PA10_GPIO       0x00000000UL        /*!< GPA_MFP PA.10 setting for GPIO */
N#define SYS_ALT_MFP_PA10_GPIO       0x00000000UL        /*!< ALT_MFP PA.10 setting for GPIO */
N#define SYS_ALT_MFP1_PA10_GPIO      NULL                /*!< No ALT_MFP1 setting for PA.10  */
N#define SYS_ALT_MFP2_PA10_GPIO      NULL                /*!< No ALT_MFP2 setting for PA.10  */
N
N#define SYS_GPA_MFP_PA10_I2C1_SDA   (1UL<<10)           /*!< GPA_MFP PA.10 setting for I2C1_SDA */
N#define SYS_ALT_MFP_PA10_I2C1_SDA   0x00000000UL        /*!< ALT_MFP PA.10 setting for I2C1_SDA */
N#define SYS_ALT_MFP1_PA10_I2C1_SDA  NULL                /*!< No ALT_MFP1 setting for PA.10  */
N#define SYS_ALT_MFP2_PA10_I2C1_SDA  NULL                /*!< No ALT_MFP2 setting for PA.10  */
N
N#define SYS_GPA_MFP_PA10_CAN1_TXD   (1UL<<10)           /*!< GPA_MFP PA.10 setting for CAN1_TXD */
N#define SYS_ALT_MFP_PA10_CAN1_TXD   (1UL<<28)           /*!< ALT_MFP PA.10 setting for CAN1_TXD */
N#define SYS_ALT_MFP1_PA10_CAN1_TXD  NULL                /*!< No ALT_MFP1 setting for PA.10    */
N#define SYS_ALT_MFP2_PA10_CAN1_TXD  NULL                /*!< No ALT_MFP2 setting for PA.10    */
N
N#define SYS_GPA_MFP_PA10_nWR        (1UL<<10)           /*!< GPA_MFP PA.10 setting for nWR */
N#define SYS_ALT_MFP_PA10_nWR        (1UL<<11)           /*!< ALT_MFP PA.10 setting for nWR */
N#define SYS_ALT_MFP1_PA10_nWR       NULL                /*!< No ALT_MFP1 setting for PA.10 */
N#define SYS_ALT_MFP2_PA10_nWR       NULL                /*!< No ALT_MFP2 setting for PA.10 */
N
N#define SYS_GPA_MFP_PA10_Msk        (1UL<<10)               /*!< GPA_MFP PA.10 mask         */
N#define SYS_ALT_MFP_PA10_Msk        ((1UL<<11) | (1UL<<28)) /*!< ALT_MFP PA.10 mask         */
N
N//PA.11
N#define SYS_GPA_MFP_PA11_GPIO       0x00000000UL        /*!< GPA_MFP PA.11 setting for GPIO */
N#define SYS_ALT_MFP_PA11_GPIO       0x00000000UL        /*!< ALT_MFP PA.11 setting for GPIO */
N#define SYS_ALT_MFP1_PA11_GPIO      NULL                /*!< No ALT_MFP1 setting for PA.11  */
N#define SYS_ALT_MFP2_PA11_GPIO      NULL                /*!< No ALT_MFP2 setting for PA.11    */
N
N#define SYS_GPA_MFP_PA11_I2C1_SCL   (1UL<<11)           /*!< GPA_MFP PA.11 setting for I2C1_SCL */
N#define SYS_ALT_MFP_PA11_I2C1_SCL   0x00000000UL        /*!< ALT_MFP PA.11 setting for I2C1_SCL */
N#define SYS_ALT_MFP1_PA11_I2C1_SCL  NULL                /*!< No ALT_MFP1 setting for PA.11  */
N#define SYS_ALT_MFP2_PA11_I2C1_SCL  NULL                /*!< No ALT_MFP2 setting for PA.11  */
N
N#define SYS_GPA_MFP_PA11_CAN1_RXD   (1UL<<11)           /*!< GPA_MFP PA.11 setting for CAN1_RXD */
N#define SYS_ALT_MFP_PA11_CAN1_RXD   (1UL<<28)           /*!< ALT_MFP PA.11 setting for CAN1_RXD */
N#define SYS_ALT_MFP1_PA11_CAN1_RXD  NULL                /*!< No ALT_MFP1 setting for PA.11    */
N#define SYS_ALT_MFP2_PA11_CAN1_RXD  NULL                /*!< No ALT_MFP2 setting for PA.11    */
N
N#define SYS_GPA_MFP_PA11_nRD        (1UL<<11)           /*!< GPA_MFP PA.11 setting for nRD  */
N#define SYS_ALT_MFP_PA11_nRD        (1UL<<11)           /*!< ALT_MFP PA.11 setting for nRD  */
N#define SYS_ALT_MFP1_PA11_nRD       NULL                /*!< No ALT_MFP1 setting for PA.11  */
N#define SYS_ALT_MFP2_PA11_nRD       NULL                /*!< No ALT_MFP2 setting for PA.11  */
N
N#define SYS_GPA_MFP_PA11_Msk    (1UL<<11)               /*!< GPA_MFP PA.11 mask             */
N#define SYS_ALT_MFP_PA11_Msk    ((1UL<<11) | (1UL<<28)) /*!< ALT_MFP PA.11 mask             */
N
N//PA.12
N#define SYS_GPA_MFP_PA12_GPIO       0x00000000UL        /*!< GPA_MFP PA.12 setting for GPIO */
N#define SYS_ALT_MFP_PA12_GPIO       0x00000000UL        /*!< ALT_MFP PA.12 setting for GPIO */
N#define SYS_ALT_MFP1_PA12_GPIO      0x00000000UL        /*!< ALT_MFP1 PA.12 setting for GPIO */
N#define SYS_ALT_MFP2_PA12_GPIO      NULL                /*!< No ALT_MFP2 setting for PA.12 */
N
N#define SYS_GPA_MFP_PA12_PWM0       (1UL<<12)           /*!< GPA_MFP PA.12 setting for PWM0 */
N#define SYS_ALT_MFP_PA12_PWM0       0x00000000UL        /*!< ALT_MFP PA.12 setting for PWM0 */
N#define SYS_ALT_MFP1_PA12_PWM0      0x00000000UL        /*!< ALT_MFP1 PA.12 setting for PWM0 */
N#define SYS_ALT_MFP2_PA12_PWM0      NULL                /*!< No ALT_MFP2 setting for PA.12 */
N
N#define SYS_GPA_MFP_PA12_SC2_DAT    (1UL<<12)           /*!< GPA_MFP PA.12 setting for SC2_DAT  */
N#define SYS_ALT_MFP_PA12_SC2_DAT    0x00000000UL        /*!< ALT_MFP PA.12 setting for SC2_DAT */
N#define SYS_ALT_MFP1_PA12_SC2_DAT   (1UL<<11)           /*!< ALT_MFP1 PA.12 setting for SC2_DAT */
N#define SYS_ALT_MFP2_PA12_SC2_DAT   NULL                /*!< No ALT_MFP2 setting for PA.12 */
N
N#define SYS_GPA_MFP_PA12_UART5_RXD      (1UL<<12)           /*!< GPA_MFP PA.12 setting for UART5_RXD */
N#define SYS_ALT_MFP_PA12_UART5_RXD      0x00000000UL        /*!< ALT_MFP PA.12 setting for UART5_RXD */
N#define SYS_ALT_MFP1_PA12_UART5_RXD     (1UL<<11)           /*!< ALT_MFP1 PA.12 setting for UART5_RXD */
N#define SYS_ALT_MFP2_PA12_UART5_RXD     NULL                /*!< No ALT_MFP2 setting for PA.12 */
N
N#define SYS_GPA_MFP_PA12_AD13       (1UL<<12)               /*!< GPA_MFP PA.12 setting for AD13  */
N#define SYS_ALT_MFP_PA12_AD13       ((1UL<<21) | (1UL<<11)) /*!< ALT_MFP PA.12 setting for AD13  */
N#define SYS_ALT_MFP1_PA12_AD13      0x00000000UL            /*!< ALT_MFP1 PA.12 setting for AD13 */
N#define SYS_ALT_MFP2_PA12_AD13      NULL                    /*!< No ALT_MFP2 setting for PA.12   */
N
N#define SYS_GPA_MFP_PA12_Msk        (1UL<<12)               /*!< GPA_MFP PA.12 mask             */
N#define SYS_ALT_MFP_PA12_Msk        ((1UL<<21) | (1UL<<11)) /*!< ALT_MFP PA.12 mask             */
N#define SYS_ALT_MFP1_PA12_Msk       (1UL<<11)               /*!< ALT_MFP1 PA.12 mask            */
N
N//PA.13
N#define SYS_GPA_MFP_PA13_GPIO       0x00000000UL        /*!< GPA_MFP PA.13 setting for GPIO */
N#define SYS_ALT_MFP_PA13_GPIO       0x00000000UL        /*!< ALT_MFP PA.13 setting for GPIO */
N#define SYS_ALT_MFP1_PA13_GPIO      0x00000000UL        /*!< ALT_MFP1 PA.13 setting for GPIO */
N#define SYS_ALT_MFP2_PA13_GPIO      NULL                /*!< No ALT_MFP2 setting for PA.13 */
N
N#define SYS_GPA_MFP_PA13_PWM1       (1UL<<13)           /*!< GPA_MFP PA.13 setting for PWM1 */
N#define SYS_ALT_MFP_PA13_PWM1       0x00000000UL        /*!< ALT_MFP PA.13 setting for PWM1 */
N#define SYS_ALT_MFP1_PA13_PWM1      0x00000000UL        /*!< ALT_MFP1 PA.13 setting for PWM1 */
N#define SYS_ALT_MFP2_PA13_PWM1      NULL                /*!< No ALT_MFP2 setting for PA.13 */
N
N#define SYS_GPA_MFP_PA13_SC2_CLK    (1UL<<13)           /*!< GPA_MFP PA.13 setting for SC2_CLK */
N#define SYS_ALT_MFP_PA13_SC2_CLK    0x00000000UL        /*!< ALT_MFP PA.13 setting for SC2_CLK */
N#define SYS_ALT_MFP1_PA13_SC2_CLK   (1UL<<10)           /*!< ALT_MFP1 PA.13 setting for SC2_CLK */
N#define SYS_ALT_MFP2_PA13_SC2_CLK   NULL                /*!< No ALT_MFP2 setting for PA.13 */
N
N#define SYS_GPA_MFP_PA13_UART5_TXD      (1UL<<13)           /*!< GPA_MFP PA.13 setting for UART5_TXD */
N#define SYS_ALT_MFP_PA13_UART5_TXD      0x00000000UL        /*!< ALT_MFP PA.13 setting for UART5_TXD */
N#define SYS_ALT_MFP1_PA13_UART5_TXD     (1UL<<10)           /*!< ALT_MFP1 PA.13 setting for UART5_TXD */
N#define SYS_ALT_MFP2_PA13_UART5_TXD     NULL                /*!< No ALT_MFP2 setting for PA.13 */
N
N#define SYS_GPA_MFP_PA13_AD14       (1UL<<13)               /*!< GPA_MFP PA.13 setting for AD14  */
N#define SYS_ALT_MFP_PA13_AD14       ((1UL<<22) | (1UL<<11)) /*!< ALT_MFP PA.13 setting for AD14  */
N#define SYS_ALT_MFP1_PA13_AD14      0x00000000UL            /*!< ALT_MFP1 PA.13 setting for AD14 */
N#define SYS_ALT_MFP2_PA13_AD14      NULL                    /*!< No ALT_MFP2 setting for PA.13   */
N
N#define SYS_GPA_MFP_PA13_Msk        (1UL<<13)               /*!< GPA_MFP PA.13 mask             */
N#define SYS_ALT_MFP_PA13_Msk        ((1UL<<22) | (1UL<<11)) /*!< ALT_MFP PA.13 mask             */
N#define SYS_ALT_MFP1_PA13_Msk       (1UL<<10)               /*!< ALT_MFP1 PA.13 mask            */
N
N//PA.14
N#define SYS_GPA_MFP_PA14_GPIO       0x00000000UL        /*!< GPA_MFP PA.14 setting for GPIO */
N#define SYS_ALT_MFP_PA14_GPIO       0x00000000UL        /*!< ALT_MFP PA.14 setting for GPIO */
N#define SYS_ALT_MFP1_PA14_GPIO      0x00000000UL        /*!< ALT_MFP1 PA.14 setting for GPIO */
N#define SYS_ALT_MFP2_PA14_GPIO      NULL                /*!< No ALT_MFP2 setting for PA.14 */
N
N#define SYS_GPA_MFP_PA14_PWM2       (1UL<<14)           /*!< GPA_MFP PA.14 setting for PWM2 */
N#define SYS_ALT_MFP_PA14_PWM2       0x00000000UL        /*!< ALT_MFP PA.14 setting for PWM2 */
N#define SYS_ALT_MFP1_PA14_PWM2      0x00000000UL        /*!< ALT_MFP1 PA.14 setting for PWM2 */
N#define SYS_ALT_MFP2_PA14_PWM2      NULL                /*!< No ALT_MFP2 setting for PA.14 */
N
N#define SYS_GPA_MFP_PA14_SC2_RST    (1UL<<14)           /*!< GPA_MFP PA.14 setting for SC2_RST */
N#define SYS_ALT_MFP_PA14_SC2_RST    0x00000000UL        /*!< ALT_MFP PA.14 setting for SC2_RST */
N#define SYS_ALT_MFP1_PA14_SC2_RST   (1UL<<13)           /*!< ALT_MFP1 PA.14 setting for SC2_RST */
N#define SYS_ALT_MFP2_PA14_SC2_RST   NULL                /*!< No ALT_MFP2 setting for PA.14 */
N
N#define SYS_GPA_MFP_PA14_AD15       (1UL<<14)               /*!< GPA_MFP PA.14 setting for AD15  */
N#define SYS_ALT_MFP_PA14_AD15       ((1UL<<23) | (1UL<<11)) /*!< ALT_MFP PA.14 setting for AD15  */
N#define SYS_ALT_MFP1_PA14_AD15      0x00000000UL            /*!< ALT_MFP1 PA.14 setting for AD15 */
N#define SYS_ALT_MFP2_PA14_AD15      NULL                    /*!< No ALT_MFP2 setting for PA.14   */
N
N#define SYS_GPA_MFP_PA14_Msk        (1UL<<14)               /*!< GPA_MFP PA.14 mask             */
N#define SYS_ALT_MFP_PA14_Msk        ((1UL<<23) | (1UL<<11)) /*!< ALT_MFP PA.14 mask             */
N#define SYS_ALT_MFP1_PA14_Msk       (1UL<<13)               /*!< ALT_MFP1 PA.14 mask            */
N
N//PA.15
N#define SYS_GPA_MFP_PA15_GPIO       0x00000000UL        /*!< GPA_MFP PA.15 setting for GPIO */
N#define SYS_ALT_MFP_PA15_GPIO       0x00000000UL        /*!< ALT_MFP PA.15 setting for GPIO */
N#define SYS_ALT_MFP1_PA15_GPIO      0x00000000UL        /*!< ALT_MFP1 PA.15 setting for GPIO */
N#define SYS_ALT_MFP2_PA15_GPIO      NULL                /*!< No ALT_MFP2 setting for PA.15 */
N
N#define SYS_GPA_MFP_PA15_PWM3       (1UL<<15)           /*!< GPA_MFP PA.15 setting for PWM3 */
N#define SYS_ALT_MFP_PA15_PWM3       0x00000000UL        /*!< ALT_MFP PA.15 setting for PWM3 */
N#define SYS_ALT_MFP1_PA15_PWM3      0x00000000UL        /*!< ALT_MFP1 PA.15 setting for PWM3 */
N#define SYS_ALT_MFP2_PA15_PWM3      NULL                /*!< No ALT_MFP2 setting for PA.15 */
N
N#define SYS_GPA_MFP_PA15_I2S_MCLK   (1UL<<15)           /*!< GPA_MFP PA.15 setting for I2S_MCLK */
N#define SYS_ALT_MFP_PA15_I2S_MCLK   (1UL<<9)            /*!< ALT_MFP PA.15 setting for I2S_MCLK */
N#define SYS_ALT_MFP1_PA15_I2S_MCLK  0x00000000UL        /*!< ALT_MFP1 PA.15 setting for I2S_MCLK */
N#define SYS_ALT_MFP2_PA15_I2S_MCLK  NULL                /*!< No ALT_MFP2 setting for PA.15 */
N
N#define SYS_GPA_MFP_PA15_SC2_PWR    (1UL<<15)           /*!< GPA_MFP PA.15 setting for SC2_PWR */
N#define SYS_ALT_MFP_PA15_SC2_PWR    0x00000000UL        /*!< ALT_MFP PA.15 setting for SC2_PWR */
N#define SYS_ALT_MFP1_PA15_SC2_PWR   (1UL<<12)           /*!< ALT_MFP1 PA.15 setting for SC2_PWR */
N#define SYS_ALT_MFP2_PA15_SC2_PWR   NULL                /*!< No ALT_MFP2 setting for PA.15 */
N
N#define SYS_GPA_MFP_PA15_Msk        (1UL<<15)           /*!< GPA_MFP PA.15 mask             */
N#define SYS_ALT_MFP_PA15_Msk        (1UL<<9)            /*!< ALT_MFP PA.15 mask             */
N#define SYS_ALT_MFP1_PA15_Msk       (1UL<<12)           /*!< ALT_MFP1 PA.15 mask            */
N
N//PB.0
N#define SYS_GPB_MFP_PB0_GPIO        0x00000000UL        /*!< GPB_MFP PB.0 setting for GPIO */
N#define SYS_ALT_MFP_PB0_GPIO        NULL                /*!< No ALT_MFP setting for PB.0   */
N#define SYS_ALT_MFP1_PB0_GPIO       NULL                /*!< No ALT_MFP1 setting for PB.0  */
N#define SYS_ALT_MFP2_PB0_GPIO       NULL                /*!< No ALT_MFP2 setting for PB.0  */
N
N#define SYS_GPB_MFP_PB0_UART0_RXD   (1UL<<0)            /*!< GPB_MFP PB.0 setting for UART0_RXD */
N#define SYS_ALT_MFP_PB0_UART0_RXD   NULL                /*!< No ALT_MFP setting for PB.0   */
N#define SYS_ALT_MFP1_PB0_UART0_RXD  NULL                /*!< No ALT_MFP1 setting for PB.0  */
N#define SYS_ALT_MFP2_PB0_UART0_RXD  NULL                /*!< No ALT_MFP2 setting for PB.0  */
N
N#define SYS_GPB_MFP_PB0_Msk         (1UL<<0)            /*!< GPB_MFP PB.0 mask             */
N
N//PB.1
N#define SYS_GPB_MFP_PB1_GPIO        0x00000000UL        /*!< GPB_MFP PB.1 setting for GPIO */
N#define SYS_ALT_MFP_PB1_GPIO        NULL                /*!< No ALT_MFP setting for PB.1   */
N#define SYS_ALT_MFP1_PB1_GPIO       NULL                /*!< No ALT_MFP1 setting for PB.1  */
N#define SYS_ALT_MFP2_PB1_GPIO       NULL                /*!< No ALT_MFP2 setting for PB.1  */
N
N#define SYS_GPB_MFP_PB1_UART0_TXD   (1UL<<1)            /*!< GPB_MFP PB.1 setting for UART0_TXD */
N#define SYS_ALT_MFP_PB1_UART0_TXD   NULL                /*!< No ALT_MFP setting for PB.1   */
N#define SYS_ALT_MFP1_PB1_UART0_TXD  NULL                /*!< No ALT_MFP1 setting for PB.1  */
N#define SYS_ALT_MFP2_PB1_UART0_TXD  NULL                /*!< No ALT_MFP2 setting for PB.1  */
N
N#define SYS_GPB_MFP_PB1_Msk         (1UL<<1)            /*!< GPB_MFP PB.1 mask             */
N
N//PB.2
N#define SYS_GPB_MFP_PB2_GPIO        0x00000000UL        /*!< GPB_MFP PB.2 setting for GPIO */
N#define SYS_ALT_MFP_PB2_GPIO        0x00000000UL        /*!< ALT_MFP PB.2 setting for GPIO */
N#define SYS_ALT_MFP1_PB2_GPIO       NULL                /*!< No ALT_MFP1 setting for PB.2  */
N#define SYS_ALT_MFP2_PB2_GPIO       0x00000000UL        /*!< ALT_MFP2 PB.2 setting for GPIO */
N
N#define SYS_GPB_MFP_PB2_UART0_nRTS      (1UL<<2)        /*!< GPB_MFP PB.2 setting for UART0_nRTS */
N#define SYS_ALT_MFP_PB2_UART0_nRTS      0x00000000UL    /*!< ALT_MFP PB.2 setting for UART0_nRTS */
N#define SYS_ALT_MFP1_PB2_UART0_nRTS     NULL            /*!< No ALT_MFP1 setting for PB.2 */
N#define SYS_ALT_MFP2_PB2_UART0_nRTS     0x00000000UL    /*!< ALT_MFP2 PB.2 setting for UART0_nRTS */
N
N#define SYS_GPB_MFP_PB2_TM2_EXT     (1UL<<2)            /*!< GPB_MFP PB.2 setting for TM2_EXT */
N#define SYS_ALT_MFP_PB2_TM2_EXT     (1UL<<26)           /*!< ALT_MFP PB.2 setting for TM2_EXT */
N#define SYS_ALT_MFP1_PB2_TM2_EXT    NULL                /*!< No ALT_MFP1 setting for PB.2  */
N#define SYS_ALT_MFP2_PB2_TM2_EXT    0x00000000UL        /*!< ALT_MFP2 PB.2 setting for TM2_EXT */
N
N#define SYS_GPB_MFP_PB2_ACMP0_O     (1UL<<2)            /*!< GPB_MFP PB.2 setting for ACMP0_O */
N#define SYS_ALT_MFP_PB2_ACMP0_O     (1UL<<30)           /*!< ALT_MFP PB.2 setting for ACMP0_O */
N#define SYS_ALT_MFP1_PB2_ACMP0_O    NULL                /*!< No ALT_MFP1 setting for PB.2  */
N#define SYS_ALT_MFP2_PB2_ACMP0_O    0x00000000UL        /*!< ALT_MFP2 PB.2 setting for ACMP0_O */
N
N#define SYS_GPB_MFP_PB2_TM2         (1UL<<2)            /*!< GPB_MFP PB.2 setting for TM2 */
N#define SYS_ALT_MFP_PB2_TM2         0x00000000UL        /*!< ALT_MFP PB.2 setting for TM2 */
N#define SYS_ALT_MFP1_PB2_TM2        NULL                /*!< No ALT_MFP1 setting for PB.2 */
N#define SYS_ALT_MFP2_PB2_TM2        (1UL<<4)            /*!< ALT_MFP2 PB.2 setting for TM2 */
N
N#define SYS_GPB_MFP_PB2_nWRL        (1UL<<2)                /*!< GPB_MFP PB.2 setting for nWRL */
N#define SYS_ALT_MFP_PB2_nWRL        ((1UL<<13)|(1UL<<11))   /*!< ALT_MFP PB.2 setting for nWRL */
N#define SYS_ALT_MFP1_PB2_nWRL       NULL                    /*!< No ALT_MFP1 setting for PB.2  */
N#define SYS_ALT_MFP2_PB2_nWRL       0x00000000UL            /*!< ALT_MFP2 PB.2 setting for nWRL */
N
N#define SYS_GPB_MFP_PB2_Msk     (1UL<<2)                                    /*!< GPB_MFP PB.2 mask */
N#define SYS_ALT_MFP_PB2_Msk     ((1UL<<30)|(1UL<<26)|(1UL<<13)|(1UL<<11))   /*!< ALT_MFP PB.2 mask */
N#define SYS_ALT_MFP2_PB2_Msk    (1UL<<4)                                    /*!< ALT_MFP2 PB.2 mask */
N
N//PB.3
N#define SYS_GPB_MFP_PB3_GPIO        0x00000000UL        /*!< GPB_MFP PB.3 setting for GPIO */
N#define SYS_ALT_MFP_PB3_GPIO        0x00000000UL        /*!< ALT_MFP PB.3 setting for GPIO */
N#define SYS_ALT_MFP1_PB3_GPIO       0x00000000UL        /*!< ALT_MFP1 PB.3 setting for GPIO */
N#define SYS_ALT_MFP2_PB3_GPIO       0x00000000UL        /*!< ALT_MFP2 PB.3 setting for GPIO */
N
N#define SYS_GPB_MFP_PB3_UART0_nCTS    (1UL<<3)          /*!< GPB_MFP PB.3 setting for UART0_nCTS */
N#define SYS_ALT_MFP_PB3_UART0_nCTS    0x00000000UL      /*!< ALT_MFP PB.3 setting for UART0_nCTS */
N#define SYS_ALT_MFP1_PB3_UART0_nCTS   0x00000000UL      /*!< ALT_MFP1 PB.3 setting for UART0_nCTS */
N#define SYS_ALT_MFP2_PB3_UART0_nCTS   0x00000000UL      /*!< ALT_MFP2 PB.3 setting for UART0_nCTS */
N
N#define SYS_GPB_MFP_PB3_TM3_EXT     (1UL<<3)            /*!< GPB_MFP PB.3 setting for TM3_EXT */
N#define SYS_ALT_MFP_PB3_TM3_EXT     (1UL<<27)           /*!< ALT_MFP PB.3 setting for TM3_EXT */
N#define SYS_ALT_MFP1_PB3_TM3_EXT    0x00000000UL        /*!< ALT_MFP1 PB.3 setting for TM3_EXT */
N#define SYS_ALT_MFP2_PB3_TM3_EXT    0x00000000UL        /*!< ALT_MFP2 PB.3 setting for TM3_EXT */
N
N#define SYS_GPB_MFP_PB3_SC2_CD      (1UL<<3)            /*!< GPB_MFP PB.3 setting for SC2_CD */
N#define SYS_ALT_MFP_PB3_SC2_CD      0x00000000UL        /*!< ALT_MFP PB.3 setting for SC2_CD */
N#define SYS_ALT_MFP1_PB3_SC2_CD     (1UL<<14)           /*!< ALT_MFP1 PB.3 setting for SC2_CD */
N#define SYS_ALT_MFP2_PB3_SC2_CD     0x00000000UL        /*!< ALT_MFP2 PB.3 setting for SC2_CD */
N
N#define SYS_GPB_MFP_PB3_TM3         (1UL<<3)            /*!< GPB_MFP PB.3 setting for TM3 */
N#define SYS_ALT_MFP_PB3_TM3         0x00000000UL        /*!< ALT_MFP PB.3 setting for TM3 */
N#define SYS_ALT_MFP1_PB3_TM3        0x00000000UL        /*!< ALT_MFP1 PB.3 setting for TM3 */
N#define SYS_ALT_MFP2_PB3_TM3        (1UL<<5)            /*!< ALT_MFP2 PB.3 setting for TM3 */
N
N#define SYS_GPB_MFP_PB3_nWRH        (1UL<<3)                /*!< GPB_MFP PB.3 setting for nWRH */
N#define SYS_ALT_MFP_PB3_nWRH        ((1UL<<14) | (1UL<<11)) /*!< ALT_MFP PB.3 setting for nWRH */
N#define SYS_ALT_MFP1_PB3_nWRH       0x00000000UL            /*!< ALT_MFP1 PB.3 setting for nWRH */
N#define SYS_ALT_MFP2_PB3_nWRH       0x00000000UL            /*!< ALT_MFP2 PB.3 setting for nWRH */
N
N#define SYS_GPB_MFP_PB3_Msk         (1UL<<3)                            /*!< GPB_MFP PB.3 mask */
N#define SYS_ALT_MFP_PB3_Msk         ((1UL<<27) | (1UL<<14) | (1UL<<11)) /*!< ALT_MFP PB.3 mask */
N#define SYS_ALT_MFP1_PB3_Msk        (1UL<<14)                           /*!< ALT_MFP1 PB.3 mask */
N#define SYS_ALT_MFP2_PB3_Msk        (1UL<<5)                            /*!< ALT_MFP2 PB.3 mask */
N
N//PB.4
N#define SYS_GPB_MFP_PB4_GPIO        0x00000000UL        /*!< GPA_MFP PB.4 setting for GPIO */
N#define SYS_ALT_MFP_PB4_GPIO        NULL                /*!< No ALT_MFP setting for PB.4   */
N#define SYS_ALT_MFP1_PB4_GPIO       NULL                /*!< No ALT_MFP1 setting for PB.4  */
N#define SYS_ALT_MFP2_PB4_GPIO       NULL                /*!< No ALT_MFP2 setting for PB.4  */
N
N#define SYS_GPB_MFP_PB4_UART1_RXD       (1UL<<4)        /*!< GPA_MFP PB.4 setting for UART1_RXD */
N#define SYS_ALT_MFP_PB4_UART1_RXD       NULL            /*!< No ALT_MFP setting for PB.4   */
N#define SYS_ALT_MFP1_PB4_UART1_RXD      NULL            /*!< No ALT_MFP1 setting for PB.4  */
N#define SYS_ALT_MFP2_PB4_UART1_RXD      NULL            /*!< No ALT_MFP2 setting for PB.4  */
N
N#define SYS_GPB_MFP_PB4_Msk         (1UL<<4)            /*!< GPA_MFP PB.4 mask */
N
N//PB.5
N#define SYS_GPB_MFP_PB5_GPIO        0x00000000UL        /*!< GPA_MFP PB.5 setting for GPIO */
N#define SYS_ALT_MFP_PB5_GPIO        NULL                /*!< No ALT_MFP setting for PB.5   */
N#define SYS_ALT_MFP1_PB5_GPIO       NULL                /*!< No ALT_MFP1 setting for PB.5  */
N#define SYS_ALT_MFP2_PB5_GPIO       NULL                /*!< No ALT_MFP2 setting for PB.5  */
N
N#define SYS_GPB_MFP_PB5_UART1_TXD       (1UL<<5)        /*!< GPA_MFP PB.5 setting for UART1_TXD */
N#define SYS_ALT_MFP_PB5_UART1_TXD       NULL            /*!< No ALT_MFP setting for PB.5   */
N#define SYS_ALT_MFP1_PB5_UART1_TXD      NULL            /*!< No ALT_MFP1 setting for PB.5  */
N#define SYS_ALT_MFP2_PB5_UART1_TXD      NULL            /*!< No ALT_MFP2 setting for PB.5  */
N
N#define SYS_GPB_MFP_PB5_Msk         (1UL<<5)            /*!< GPA_MFP PB.5 mask */
N
N//PB.6
N#define SYS_GPB_MFP_PB6_GPIO        0x00000000UL        /*!< GPB_MFP PB.6 setting for GPIO */
N#define SYS_ALT_MFP_PB6_GPIO        0x00000000UL        /*!< ALT_MFP PB.6 setting for GPIO */
N#define SYS_ALT_MFP1_PB6_GPIO       NULL                /*!< No ALT_MFP1 setting for PB.6 */
N#define SYS_ALT_MFP2_PB6_GPIO       NULL                /*!< No ALT_MFP2 setting for PB.6 */
N
N#define SYS_GPB_MFP_PB6_UART1_nRTS      (1UL<<6)        /*!< GPB_MFP PB.6 setting for UART1_nRTS */
N#define SYS_ALT_MFP_PB6_UART1_nRTS      0x00000000UL    /*!< ALT__MFP PB.6 setting for UART1_nRTS */
N#define SYS_ALT_MFP1_PB6_UART1_nRTS     NULL            /*!< No ALT_MFP1 setting for PB.6  */
N#define SYS_ALT_MFP2_PB6_UART1_nRTS     NULL            /*!< No ALT_MFP2 setting for PB.6  */
N
N#define SYS_GPB_MFP_PB6_ALE         (1UL<<6)            /*!< GPB_MFP PB.6 setting for ALE */
N#define SYS_ALT_MFP_PB6_ALE         (1UL<<11)           /*!< ALT_MFP PB.6 setting for ALE */
N#define SYS_ALT_MFP1_PB6_ALE        NULL                /*!< No ALT_MFP1 setting for PB.6 */
N#define SYS_ALT_MFP2_PB6_ALE        NULL                /*!< No ALT_MFP2 setting for PB.6 */
N
N#define SYS_GPB_MFP_PB6_Msk         (1UL<<6)            /*!< GPB_MFP PB.6 mask */
N#define SYS_ALT_MFP_PB6_Msk         (1UL<<11)           /*!< ALT_MFP PB.6 mask */
N
N//PB.7
N#define SYS_GPB_MFP_PB7_GPIO        0x00000000UL        /*!< GPB_MFP PB.7 setting for GPIO */
N#define SYS_ALT_MFP_PB7_GPIO        0x00000000UL        /*!< ALT_MFP PB.7 setting for GPIO */
N#define SYS_ALT_MFP1_PB7_GPIO       NULL                /*!< No ALT_MFP1 setting for PB.7 */
N#define SYS_ALT_MFP2_PB7_GPIO       NULL                /*!< No ALT_MFP2 setting for PB.7 */
N
N#define SYS_GPB_MFP_PB7_UART1_nCTS    (1UL<<7)          /*!< GPB_MFP PB.7 setting for UART1_nCTS */
N#define SYS_ALT_MFP_PB7_UART1_nCTS    0x00000000UL      /*!< ALT_MFP PB.7 setting for UART1_nCTS */
N#define SYS_ALT_MFP1_PB7_UART1_nCTS   NULL              /*!< No ALT_MFP1 setting for PB.7  */
N#define SYS_ALT_MFP2_PB7_UART1_nCTS   NULL              /*!< No ALT_MFP2 setting for PB.7  */
N
N#define SYS_GPB_MFP_PB7_nCS         (1UL<<7)            /*!< GPB_MFP PB.7 setting for nCS */
N#define SYS_ALT_MFP_PB7_nCS         (1UL<<11)           /*!< ALT_MFP PB.7 setting for nCS */
N#define SYS_ALT_MFP1_PB7_nCS        NULL                /*!< No ALT_MFP1 setting for PB.7 */
N#define SYS_ALT_MFP2_PB7_nCS        NULL                /*!< No ALT_MFP2 setting for PB.7 */
N
N#define SYS_GPB_MFP_PB7_Msk         (1UL<<7)            /*!< GPB_MFP PB.7 mask */
N#define SYS_ALT_MFP_PB7_Msk         (1UL<<11)           /*!< ALT_MFP PB.7 mask */
N
N//PB.8
N#define SYS_GPB_MFP_PB8_GPIO        0x00000000UL        /*!< GPA_MFP PB.8 setting for GPIO */
N#define SYS_ALT_MFP_PB8_GPIO        0x00000000UL        /*!< ALT_MFP PB.8 setting for GPIO */
N#define SYS_ALT_MFP1_PB8_GPIO       NULL                /*!< No ALT_MFP1 setting for PB.8  */
N#define SYS_ALT_MFP2_PB8_GPIO       NULL                /*!< No ALT_MFP2 setting for PB.8  */
N
N#define SYS_GPB_MFP_PB8_TM0         (1UL<<8)            /*!< GPA_MFP PB.8 setting for TM0 */
N#define SYS_ALT_MFP_PB8_TM0         0x00000000UL        /*!< ALT_MFP PB.8 setting for TM0 */
N#define SYS_ALT_MFP1_PB8_TM0        NULL                /*!< No ALT_MFP1 setting for PB.8 */
N#define SYS_ALT_MFP2_PB8_TM0        NULL                /*!< No ALT_MFP2 setting for PB.8 */
N
N#define SYS_GPB_MFP_PB8_CLKO        (1UL<<8)            /*!< GPA_MFP PB.8 setting for CLKO */
N#define SYS_ALT_MFP_PB8_CLKO        (1UL<<29)           /*!< ALT_MFP PB.8 setting for CLKO */
N#define SYS_ALT_MFP1_PB8_CLKO       NULL                /*!< No ALT_MFP1 setting for PB.8  */
N#define SYS_ALT_MFP2_PB8_CLKO       NULL                /*!< No ALT_MFP2 setting for PB.8  */
N
N#define SYS_GPB_MFP_PB8_Msk         (1UL<<8)            /*!< GPA_MFP PB.8 mask */
N#define SYS_ALT_MFP_PB8_Msk         (1UL<<29)           /*!< ALT_MFP PB.8 mask */
N
N//PB.9
N#define SYS_GPB_MFP_PB9_GPIO        0x00000000UL        /*!< GPB_MFP PB.9 setting for GPIO */
N#define SYS_ALT_MFP_PB9_GPIO        0x00000000UL        /*!< ALT_MFP PB.9 setting for GPIO */
N#define SYS_ALT_MFP1_PB9_GPIO       NULL                /*!< No ALT_MFP1 setting for PB.9  */
N#define SYS_ALT_MFP2_PB9_GPIO       NULL                /*!< No ALT_MFP2 setting for PB.9  */
N
N#define SYS_GPB_MFP_PB9_TM1         (1UL<<9)            /*!< GPB_MFP PB.9 setting for TM1 */
N#define SYS_ALT_MFP_PB9_TM1         0x00000000UL        /*!< ALT_MFP PB.9 setting for TM1 */
N#define SYS_ALT_MFP1_PB9_TM1        NULL                /*!< No ALT_MFP1 setting for PB.9 */
N#define SYS_ALT_MFP2_PB9_TM1        NULL                /*!< No ALT_MFP2 setting for PB.9 */
N
N#define SYS_GPB_MFP_PB9_SPI1_SS1        (1UL<<9)        /*!< GPB_MFP PB.9 setting for SPI1_SS1 */
N#define SYS_ALT_MFP_PB9_SPI1_SS1        (1UL<<1)        /*!< ALT_MFP PB.9 setting for SPI1_SS1 */
N#define SYS_ALT_MFP1_PB9_SPI1_SS1       NULL            /*!< No ALT_MFP1 setting for PB.9  */
N#define SYS_ALT_MFP2_PB9_SPI1_SS1       NULL            /*!< No ALT_MFP2 setting for PB.9  */
N
N#define SYS_GPB_MFP_PB9_Msk         (1UL<<9)            /*!< GPB_MFP PB.9 mask */
N#define SYS_ALT_MFP_PB9_Msk         (1UL<<1)            /*!< ALT_MFP PB.9 mask */
N
N//PB.10
N#define SYS_GPB_MFP_PB10_GPIO       0x00000000UL        /*!< GPB_MFP PB.10 setting for GPIO */
N#define SYS_ALT_MFP_PB10_GPIO       0x00000000UL        /*!< ALT_MFP PB.10 setting for GPIO */
N#define SYS_ALT_MFP1_PB10_GPIO      NULL                /*!< No ALT_MFP1 setting for PB.10  */
N#define SYS_ALT_MFP2_PB10_GPIO      NULL                /*!< No ALT_MFP2 setting for PB.10  */
N
N#define SYS_GPB_MFP_PB10_TM2        (1UL<<10)           /*!< GPB_MFP PB.10 setting for TM2 */
N#define SYS_ALT_MFP_PB10_TM2        0x00000000UL        /*!< ALT_MFP PB.10 setting for TM2 */
N#define SYS_ALT_MFP1_PB10_TM2       NULL                /*!< No ALT_MFP1 setting for PB.10 */
N#define SYS_ALT_MFP2_PB10_TM2       NULL                /*!< No ALT_MFP2 setting for PB.10 */
N
N#define SYS_GPB_MFP_PB10_SPI0_SS1       (1UL<<10)       /*!< GPB_MFP PB.10 setting for SPI0_SS1 */
N#define SYS_ALT_MFP_PB10_SPI0_SS1       (1UL<<0)        /*!< ALT_MFP PB.10 setting for SPI0_SS1 */
N#define SYS_ALT_MFP1_PB10_SPI0_SS1      NULL            /*!< No ALT_MFP1 setting for PB.10 */
N#define SYS_ALT_MFP2_PB10_SPI0_SS1      NULL            /*!< No ALT_MFP2 setting for PB.10 */
N
N#define SYS_GPB_MFP_PB10_Msk        (1UL<<10)           /*!< GPB_MFP PB.10 mask */
N#define SYS_ALT_MFP_PB10_Msk        (1UL<<0)            /*!< ALT_MFP PB.10 mask */
N
N//PB.11
N#define SYS_GPB_MFP_PB11_GPIO       0x00000000UL        /*!< GPB_MFP PB.11 setting for GPIO */
N#define SYS_ALT_MFP_PB11_GPIO       0x00000000UL        /*!< ALT_MFP PB.11 setting for GPIO */
N#define SYS_ALT_MFP1_PB11_GPIO      NULL                /*!< No ALT_MFP1 setting for PB.11  */
N#define SYS_ALT_MFP2_PB11_GPIO      NULL                /*!< No ALT_MFP2 setting for PB.11  */
N
N#define SYS_GPB_MFP_PB11_TM3        (1UL<<11)           /*!< GPB_MFP PB.11 setting for TM3 */
N#define SYS_ALT_MFP_PB11_TM3        0x00000000UL        /*!< ALT_MFP PB.11 setting for TM3 */
N#define SYS_ALT_MFP1_PB11_TM3       NULL                /*!< No ALT_MFP1 setting for PB.11  */
N#define SYS_ALT_MFP2_PB11_TM3       NULL                /*!< No ALT_MFP2 setting for PB.11  */
N
N#define SYS_GPB_MFP_PB11_PWM4       (1UL<<11)           /*!< GPB_MFP PB.11 setting for PWM4  */
N#define SYS_ALT_MFP_PB11_PWM4       (1UL<<4)            /*!< ALT_MFP PB.11 setting for PWM4  */
N#define SYS_ALT_MFP1_PB11_PWM4      NULL                /*!< No ALT_MFP1 setting for PB.11  */
N#define SYS_ALT_MFP2_PB11_PWM4      NULL                /*!< No ALT_MFP2 setting for PB.11  */
N
N#define SYS_GPB_MFP_PB11_Msk        (1UL<<11)           /*!< GPB_MFP PB.11 mask */
N#define SYS_ALT_MFP_PB11_Msk        (1UL<<4)            /*!< ALT_MFP PB.11 mask */
N
N//PB.12 is reserved
N
N//PB.13
N#define SYS_GPB_MFP_PB13_GPIO       0x00000000UL        /*!< GPB_MFP PB.13 setting for GPIO */
N#define SYS_ALT_MFP_PB13_GPIO       0x00000000UL        /*!< ALT_MFP PB.13 setting for GPIO */
N#define SYS_ALT_MFP1_PB13_GPIO      NULL                /*!< No ALT_MFP1 setting for PB.13  */
N#define SYS_ALT_MFP2_PB13_GPIO      NULL                /*!< No ALT_MFP2 setting for PB.13  */
N
N#define SYS_GPB_MFP_PB13_ACMP1_O    (1UL<<13)           /*!< GPB_MFP PB.13 setting for ACMP1_O */
N#define SYS_ALT_MFP_PB13_ACMP1_O    0x00000000UL        /*!< ALT_MFP PB.13 setting for ACMP1_O */
N#define SYS_ALT_MFP1_PB13_ACMP1_O   NULL                /*!< No ALT_MFP1 setting for PB.13 */
N#define SYS_ALT_MFP2_PB13_ACMP1_O   NULL                /*!< No ALT_MFP2 setting for PB.13 */
N
N#define SYS_GPB_MFP_PB13_AD1        (1UL<<13)           /*!< GPB_MFP PB.13 setting for AD1 */
N#define SYS_ALT_MFP_PB13_AD1        (1UL<<11)           /*!< ALT_MFP PB.13 setting for AD1 */
N#define SYS_ALT_MFP1_PB13_AD1       NULL                /*!< No ALT_MFP1 setting for PB.13 */
N#define SYS_ALT_MFP2_PB13_AD1       NULL                /*!< No ALT_MFP2 setting for PB.13 */
N
N#define SYS_GPB_MFP_PB13_Msk        (1UL<<13)           /*!< GPB_MFP PB.13 mask */
N#define SYS_ALT_MFP_PB13_Msk        (1UL<<11)           /*!< ALT_MFP PB.13 mask */
N
N//PB.14
N#define SYS_GPB_MFP_PB14_GPIO       0x00000000UL        /*!< GPB_MFP PB.14 setting for GPIO */
N#define SYS_ALT_MFP_PB14_GPIO       0x00000000UL        /*!< ALT_MFP PB.14 setting for GPIO */
N#define SYS_ALT_MFP1_PB14_GPIO      NULL                /*!< No ALT_MFP1 setting for PB.14 */
N#define SYS_ALT_MFP2_PB14_GPIO      NULL                /*!< No ALT_MFP2 setting for PB.14 */
N
N#define SYS_GPB_MFP_PB14_INT0       (1UL<<14)           /*!< GPB_MFP PB.14 setting for INT0 */
N#define SYS_ALT_MFP_PB14_INT0       0x00000000UL        /*!< ALT_MFP PB.14 setting for INT0 */
N#define SYS_ALT_MFP1_PB14_INT0      NULL                /*!< No ALT_MFP1 setting for PB.14 */
N#define SYS_ALT_MFP2_PB14_INT0      0x00000000UL        /*!< ALT_MFP2 PB.14 setting for INT0 */
N
N#define SYS_GPB_MFP_PB14_SPI3_SS1    (1UL<<14)          /*!< GPB_MFP PB.14 setting for SPI3_SS1 */
N#define SYS_ALT_MFP_PB14_SPI3_SS1    (1UL<<3)           /*!< ALT_MFP PB.14 setting for SPI3_SS1 */
N#define SYS_ALT_MFP1_PB14_SPI3_SS1   NULL               /*!< No ALT_MFP1 setting for PB.14 */
N#define SYS_ALT_MFP2_PB14_SPI3_SS1   0x00000000UL       /*!< ALT_MFP2 PB.14 setting for SPI3_SS1 */
N
N#define SYS_GPB_MFP_PB14_AD0        (1UL<<14)           /*!< GPB_MFP PB.14 setting for AD0 */
N#define SYS_ALT_MFP_PB14_AD0        0x00000000UL        /*!< ALT_MFP PB.14 setting for AD0 */
N#define SYS_ALT_MFP1_PB14_AD0       NULL                /*!< No ALT_MFP1 setting for PB.14  */
N#define SYS_ALT_MFP2_PB14_AD0       (1UL<<1)            /*!< ALT_MFP2 PB.14 setting for AD0 */
N
N#define SYS_GPB_MFP_PB14_Msk        (1UL<<14)           /*!< GPB_MFP PB.14 mask */
N#define SYS_ALT_MFP_PB14_Msk        (1UL<<3)            /*!< ALT_MFP PB.14 mask */
N#define SYS_ALT_MFP2_PB14_Msk       (1UL<<1)            /*!< ALT_MFP2 PB.14 mask */
N
N//PB.15
N#define SYS_GPB_MFP_PB15_GPIO       0x00000000UL        /*!< GPB_MFP PB.15 setting for GPIO */
N#define SYS_ALT_MFP_PB15_GPIO       0x00000000UL        /*!< ALT_MFP PB.15 setting for GPIO */
N#define SYS_ALT_MFP1_PB15_GPIO      NULL                /*!< No ALT_MFP1 setting for PB.15 */
N#define SYS_ALT_MFP2_PB15_GPIO      0x00000000UL        /*!< ALT_MFP2 PB.15 setting for GPIO */
N
N#define SYS_GPB_MFP_PB15_INT1       (1UL<<15)           /*!< GPB_MFP PB.15 setting for INT1 */
N#define SYS_ALT_MFP_PB15_INT1       0x00000000UL        /*!< ALT_MFP PB.15 setting for INT1 */
N#define SYS_ALT_MFP1_PB15_INT1      NULL                /*!< No ALT_MFP1 setting for PB.15 */
N#define SYS_ALT_MFP2_PB15_INT1      0x00000000UL        /*!< ALT_MFP2 PB.15 setting for INT1 */
N
N#define SYS_GPB_MFP_PB15_TM0_EXT    (1UL<<15)           /*!< GPB_MFP PB.15 setting for TM0_EXT */
N#define SYS_ALT_MFP_PB15_TM0_EXT    (1UL<<24)           /*!< ALT_MFP PB.15 setting for TM0_EXT */
N#define SYS_ALT_MFP1_PB15_TM0_EXT   NULL                /*!< No ALT_MFP1 setting for PB.15 */
N#define SYS_ALT_MFP2_PB15_TM0_EXT   0x00000000UL        /*!< ALT_MFP2 PB.15 setting for TM0_EXT */
N
N#define SYS_GPB_MFP_PB15_TM0        (1UL<<15)           /*!< GPB_MFP PB.15 setting for TM0 */
N#define SYS_ALT_MFP_PB15_TM0        0x00000000UL        /*!< ALT_MFP PB.15 setting for TM0 */
N#define SYS_ALT_MFP1_PB15_TM0       NULL                /*!< No ALT_MFP1 setting for PB.15 */
N#define SYS_ALT_MFP2_PB15_TM0       (1UL<<2)            /*!< ALT_MFP2 PB.15 setting for TM0 */
N
N#define SYS_GPB_MFP_PB15_AD6        (1UL<<15)           /*!< GPB_MFP PB.15 setting for AD6 */
N#define SYS_ALT_MFP_PB15_AD6        0x00000000UL        /*!< ALT_MFP PB.15 setting for AD6 */
N#define SYS_ALT_MFP1_PB15_AD6       NULL                /*!< No ALT_MFP1 setting for PB.15 */
N#define SYS_ALT_MFP2_PB15_AD6       (1UL<<1)            /*!< ALT_MFP2 PB.15 setting for AD6 */
N
N#define SYS_GPB_MFP_PB15_Msk        (1UL<<15)           /*!< GPB_MFP PB.15 mask */
N#define SYS_ALT_MFP_PB15_Msk        (1UL<<24)           /*!< ALT_MFP PB.15 mask */
N#define SYS_ALT_MFP2_PB15_Msk       ((1UL<<1)|(1UL<<2)) /*!< ALT_MFP2 PB.15 mask */
N
N//PC.0
N#define SYS_GPC_MFP_PC0_GPIO        0x00000000UL        /*!< GPC_MFP PC.0 setting for GPIO */
N#define SYS_ALT_MFP_PC0_GPIO        0x00000000UL        /*!< ALT_MFP PC.0 setting for GPIO */
N#define SYS_ALT_MFP1_PC0_GPIO       NULL                /*!< No ALT_MFP1 setting for PC.0 */
N#define SYS_ALT_MFP2_PC0_GPIO       NULL                /*!< No ALT_MFP2 setting for PC.0 */
N
N#define SYS_GPC_MFP_PC0_SPI0_SS0        (1UL<<0)        /*!< GPC_MFP PC.0 setting for SPI0_SS0 */
N#define SYS_ALT_MFP_PC0_SPI0_SS0        0x00000000UL    /*!< ALT_MFP PC.0 setting for SPI0_SS0 */
N#define SYS_ALT_MFP1_PC0_SPI0_SS0       NULL            /*!< No ALT_MFP1 setting for PC.0 */
N#define SYS_ALT_MFP2_PC0_SPI0_SS0       NULL            /*!< No ALT_MFP2 setting for PC.0 */
N
N#define SYS_GPC_MFP_PC0_I2S_LRCLK       (1UL<<0)        /*!< GPC_MFP PC.0 setting for I2S_LRCLK */
N#define SYS_ALT_MFP_PC0_I2S_LRCLK       (1UL<<5)        /*!< ALT_MFP PC.0 setting for I2S_LRCLK */
N#define SYS_ALT_MFP1_PC0_I2S_LRCLK      NULL            /*!< No ALT_MFP1 setting for PC.0 */
N#define SYS_ALT_MFP2_PC0_I2S_LRCLK      NULL            /*!< No ALT_MFP2 setting for PC.0 */
N
N#define SYS_GPC_MFP_PC0_I2S_LRCK        (1UL<<0)        /*!< GPC_MFP PC.0 setting for I2S_LRCK */
N#define SYS_ALT_MFP_PC0_I2S_LRCK        (1UL<<5)        /*!< ALT_MFP PC.0 setting for I2S_LRCK */
N#define SYS_ALT_MFP1_PC0_I2S_LRCK       NULL            /*!< No ALT_MFP1 setting for PC.0 */
N#define SYS_ALT_MFP2_PC0_I2S_LRCK       NULL            /*!< No ALT_MFP2 setting for PC.0 */
N
N#define SYS_GPC_MFP_PC0_Msk         (1UL<<0)            /*!< GPC_MFP PC.0 mask */
N#define SYS_ALT_MFP_PC0_Msk         (1UL<<5)            /*!< ALT_MFP PC.0 mask */
N
N//PC.1
N#define SYS_GPC_MFP_PC1_GPIO        0x00000000UL        /*!< GPC_MFP PC.1 setting for GPIO */
N#define SYS_ALT_MFP_PC1_GPIO        0x00000000UL        /*!< ALT_MFP PC.1 setting for GPIO */
N#define SYS_ALT_MFP1_PC1_GPIO       NULL                /*!< No ALT_MFP1 setting for PC.1 */
N#define SYS_ALT_MFP2_PC1_GPIO       NULL                /*!< No ALT_MFP2 setting for PC.1 */
N
N#define SYS_GPC_MFP_PC1_SPI0_CLK     (1UL<<1)           /*!< GPC_MFP PC.1 setting for SPI0_CLK */
N#define SYS_ALT_MFP_PC1_SPI0_CLK     0x00000000UL       /*!< ALT_MFP PC.1 setting for SPI0_CLK */
N#define SYS_ALT_MFP1_PC1_SPI0_CLK    NULL               /*!< No ALT_MFP1 setting for PC.1 */
N#define SYS_ALT_MFP2_PC1_SPI0_CLK    NULL               /*!< No ALT_MFP2 setting for PC.1 */
N
N#define SYS_GPC_MFP_PC1_I2S_BCLK     (1UL<<1)           /*!< GPC_MFP PC.1 setting for I2S_BCLK  */
N#define SYS_ALT_MFP_PC1_I2S_BCLK     (1UL<<6)           /*!< ALT_MFP PC.1 setting for I2S_BCLK  */
N#define SYS_ALT_MFP1_PC1_I2S_BCLK    NULL               /*!< No ALT_MFP1 setting for PC.1 */
N#define SYS_ALT_MFP2_PC1_I2S_BCLK    NULL               /*!< No ALT_MFP2 setting for PC.1 */
N
N#define SYS_GPC_MFP_PC1_Msk         (1UL<<1)            /*!< GPC_MFP PC.1 mask */
N#define SYS_ALT_MFP_PC1_Msk         (1UL<<6)            /*!< ALT_MFP PC.1 mask */
N
N//PC.2
N#define SYS_GPC_MFP_PC2_GPIO        0x00000000UL        /*!< GPC_MFP PC.2 setting for GPIO */
N#define SYS_ALT_MFP_PC2_GPIO        0x00000000UL        /*!< ALT_MFP PC.2 setting for GPIO */
N#define SYS_ALT_MFP1_PC2_GPIO       NULL                /*!< No ALT_MFP1 setting for PC.2 */
N#define SYS_ALT_MFP2_PC2_GPIO       NULL                /*!< No ALT_MFP2 setting for PC.2 */
N
N#define SYS_GPC_MFP_PC2_SPI0_MISO0      (1UL<<2)        /*!< GPC_MFP PC.2 setting for SPI0_MISO0 */
N#define SYS_ALT_MFP_PC2_SPI0_MISO0      0x00000000UL    /*!< ALT_MFP PC.2 setting for SPI0_MISO0 */
N#define SYS_ALT_MFP1_PC2_SPI0_MISO0     NULL            /*!< No ALT_MFP1 setting for PC.2 */
N#define SYS_ALT_MFP2_PC2_SPI0_MISO0     NULL            /*!< No ALT_MFP2 setting for PC.2 */
N
N#define SYS_GPC_MFP_PC2_I2S_DI       (1UL<<2)           /*!< GPC_MFP PC.2 setting for I2S_DI */
N#define SYS_ALT_MFP_PC2_I2S_DI       (1UL<<7)           /*!< ALT_MFP PC.2 setting for I2S_DI */
N#define SYS_ALT_MFP1_PC2_I2S_DI      NULL               /*!< No ALT_MFP1 setting for PC.2 */
N#define SYS_ALT_MFP2_PC2_I2S_DI      NULL               /*!< No ALT_MFP2 setting for PC.2 */
N
N#define SYS_GPC_MFP_PC2_Msk         (1UL<<2)            /*!< GPC_MFP PC.2 mask */
N#define SYS_ALT_MFP_PC2_Msk         (1UL<<7)            /*!< ALT_MFP PC.2 mask */
N
N//PC.3
N#define SYS_GPC_MFP_PC3_GPIO        0x00000000UL        /*!< GPC_MFP PC.3 setting for GPIO */
N#define SYS_ALT_MFP_PC3_GPIO        0x00000000UL        /*!< ALT_MFP PC.3 setting for GPIO */
N#define SYS_ALT_MFP1_PC3_GPIO       NULL                /*!< No ALT_MFP1 setting for PC.3 */
N#define SYS_ALT_MFP2_PC3_GPIO       NULL                /*!< No ALT_MFP2 setting for PC.3 */
N
N#define SYS_GPC_MFP_PC3_SPI0_MOSI0      (1UL<<3)        /*!< GPC_MFP PC.3 setting for SPI0_MOSI0 */
N#define SYS_ALT_MFP_PC3_SPI0_MOSI0      0x00000000UL    /*!< ALT_MFP PC.3 setting for SPI0_MOSI0 */
N#define SYS_ALT_MFP1_PC3_SPI0_MOSI0     NULL            /*!< No ALT_MFP1 setting for PC.3 */
N#define SYS_ALT_MFP2_PC3_SPI0_MOSI0    NULL             /*!< No ALT_MFP2 setting for PC.3 */
N
N#define SYS_GPC_MFP_PC3_I2S_DO       (1UL<<3)           /*!< GPC_MFP PC.3 setting for I2S_DO  */
N#define SYS_ALT_MFP_PC3_I2S_DO       (1UL<<8)           /*!< ALT_MFP PC.3 setting for I2S_DO  */
N#define SYS_ALT_MFP1_PC3_I2S_DO      NULL               /*!< No ALT_MFP1 setting for PC.3 */
N#define SYS_ALT_MFP2_PC3_I2S_DO      NULL               /*!< No ALT_MFP2 setting for PC.3 */
N
N#define SYS_GPC_MFP_PC3_Msk         (1UL<<3)            /*!< GPC_MFP PC.3 mask */
N#define SYS_ALT_MFP_PC3_Msk         (1UL<<8)            /*!< ALT_MFP PC.3 mask */
N
N//PC.4
N#define SYS_GPC_MFP_PC4_GPIO        0x00000000UL        /*!< GPC_MFP PC.4 setting for GPIO */
N#define SYS_ALT_MFP_PC4_GPIO        NULL                /*!< No ALT_MFP setting for PC.4 */
N#define SYS_ALT_MFP1_PC4_GPIO       NULL                /*!< No ALT_MFP1 setting for PC.4 */
N#define SYS_ALT_MFP2_PC4_GPIO       NULL                /*!< No ALT_MFP2 setting for PC.4 */
N
N#define SYS_GPC_MFP_PC4_SPI0_MISO1       (1UL<<4)       /*!< GPC_MFP PC.4 setting for SPI0_MISO1 */
N#define SYS_ALT_MFP_PC4_SPI0_MISO1       NULL           /*!< No ALT_MFP setting for PC.4 */
N#define SYS_ALT_MFP1_PC4_SPI0_MISO1      NULL           /*!< No ALT_MFP1 setting for PC.4 */
N#define SYS_ALT_MFP2_PC4_SPI0_MISO1      NULL           /*!< No ALT_MFP2 setting for PC.4 */
N
N#define SYS_GPC_MFP_PC4_Msk         (1UL<<4)            /*!< GPC_MFP PC.4 mask */
N
N//PC.5
N#define SYS_GPC_MFP_PC5_GPIO        0x00000000UL        /*!< GPC_MFP PC.5 setting for GPIO */
N#define SYS_ALT_MFP_PC5_GPIO        NULL                /*!< No ALT_MFP setting for PC.5 */
N#define SYS_ALT_MFP1_PC5_GPIO       NULL                /*!< No ALT_MFP1 setting for PC.5 */
N#define SYS_ALT_MFP2_PC5_GPIO       NULL                /*!< No ALT_MFP2 setting for PC.5 */
N
N#define SYS_GPC_MFP_PC5_SPI0_MOSI1      (1UL<<5)        /*!< GPC_MFP PC.5 setting for SPI0_MOSI1 */
N#define SYS_ALT_MFP_PC5_SPI0_MOSI1      NULL            /*!< No ALT_MFP setting for PC.5 */
N#define SYS_ALT_MFP1_PC5_SPI0_MOSI1     NULL            /*!< No ALT_MFP1 setting for PC.5 */
N#define SYS_ALT_MFP2_PC5_SPI0_MOSI1     NULL            /*!< No ALT_MFP2 setting for PC.5 */
N
N#define SYS_GPC_MFP_PC5_Msk         (1UL<<5)            /*!< GPC_MFP PC.5 mask */
N
N//PC.6
N#define SYS_GPC_MFP_PC6_GPIO        0x00000000UL        /*!< GPC_MFP PC.6 setting for GPIO */
N#define SYS_ALT_MFP_PC6_GPIO        0x00000000UL        /*!< ALT_MFP PC.6 setting for GPIO */
N#define SYS_ALT_MFP1_PC6_GPIO       0x00000000UL        /*!< ALT_MFP1 PC.6 setting for GPIO */
N#define SYS_ALT_MFP2_PC6_GPIO       NULL                /*!< No ALT_MFP2 setting for PC.6 */
N
N#define SYS_GPC_MFP_PC6_ACMP0_P     (1UL<<6)            /*!< GPC_MFP PC.6 setting for ACMP0_P */
N#define SYS_ALT_MFP_PC6_ACMP0_P     0x00000000UL        /*!< ALT_MFP PC.6 setting for ACMP0_P */
N#define SYS_ALT_MFP1_PC6_ACMP0_P    0x00000000UL        /*!< ALT_MFP1 PC.6 setting for ACMP0_P */
N#define SYS_ALT_MFP2_PC6_ACMP0_P    NULL                /*!< No ALT_MFP2 setting for PC.6 */
N
N#define SYS_GPC_MFP_PC6_SC0_CD      (1UL<<6)            /*!< GPC_MFP PC.6 setting for SC0_CD */
N#define SYS_ALT_MFP_PC6_SC0_CD      0x00000000UL        /*!< ALT_MFP PC.6 setting for SC0_CD */
N#define SYS_ALT_MFP1_PC6_SC0_CD     (1UL<<4)            /*!< ALT_MFP1 PC.6 setting for SC0_CD */
N#define SYS_ALT_MFP2_PC6_SC0_CD     NULL                /*!< No ALT_MFP2 setting for PC.6 */
N
N#define SYS_GPC_MFP_PC6_AD4         (1UL<<6)            /*!< GPC_MFP PC.6 setting for AD4  */
N#define SYS_ALT_MFP_PC6_AD4         (1UL<<11)           /*!< ALT_MFP PC.6 setting for AD4  */
N#define SYS_ALT_MFP1_PC6_AD4        0x00000000UL        /*!< ALT_MFP1 PC.6 setting for AD4 */
N#define SYS_ALT_MFP2_PC6_AD4        NULL                /*!< No ALT_MFP2 setting for PC.6 */
N
N#define SYS_GPC_MFP_PC6_Msk         (1UL<<6)            /*!< GPC_MFP PC.6 mask */
N#define SYS_ALT_MFP_PC6_Msk         (1UL<<11)           /*!< ALT_MFP PC.6 mask */
N#define SYS_ALT_MFP1_PC6_Msk        (1UL<<4)            /*!< ALT_MFP1 PC.6 mask */
N
N//PC.7
N#define SYS_GPC_MFP_PC7_GPIO        0x00000000UL        /*!< GPC_MFP PC.7 setting for GPIO */
N#define SYS_ALT_MFP_PC7_GPIO        0x00000000UL        /*!< ALT_MFP PC.7 setting for GPIO */
N#define SYS_ALT_MFP1_PC7_GPIO       0x00000000UL        /*!< ALT_MFP1 PC.7 setting for GPIO */
N#define SYS_ALT_MFP2_PC7_GPIO       NULL                /*!< No ALT_MFP2 setting for PC.7 */
N
N#define SYS_GPC_MFP_PC7_ACMP0_N     (1UL<<7)            /*!< GPC_MFP PC.7 setting for ACMP0_N */
N#define SYS_ALT_MFP_PC7_ACMP0_N     0x00000000UL        /*!< ALT_MFP PC.7 setting for ACMP0_N */
N#define SYS_ALT_MFP1_PC7_ACMP0_N    0x00000000UL        /*!< ALT_MFP1 PC.7 setting for ACMP0_N */
N#define SYS_ALT_MFP2_PC7_ACMP0_N    NULL                /*!< No ALT_MFP2 setting for PC.7 */
N
N#define SYS_GPC_MFP_PC7_SC1_CD      (1UL<<7)            /*!< GPC_MFP PC.7 setting for SC1_CD */
N#define SYS_ALT_MFP_PC7_SC1_CD      0x00000000UL        /*!< ALT_MFP PC.7 setting for SC1_CD */
N#define SYS_ALT_MFP1_PC7_SC1_CD     (1UL<<9)            /*!< ALT_MFP1 PC.7 setting for SC1_CD */
N#define SYS_ALT_MFP2_PC7_SC1_CD     NULL                /*!< No ALT_MFP2 setting for PC.7 */
N
N#define SYS_GPC_MFP_PC7_AD5         (1UL<<7)            /*!< GPC_MFP PC.7 setting for AD5 */
N#define SYS_ALT_MFP_PC7_AD5         (1UL<<11)           /*!< ALT_MFP PC.7 setting for AD5  */
N#define SYS_ALT_MFP1_PC7_AD5        0x00000000UL        /*!< ALT_MFP1 PC.7 setting for AD5 */
N#define SYS_ALT_MFP2_PC7_AD5        NULL                /*!< No ALT_MFP2 setting for PC.7 */
N
N#define SYS_GPC_MFP_PC7_Msk         (1UL<<7)            /*!< GPC_MFP PC.7 mask */
N#define SYS_ALT_MFP_PC7_Msk         (1UL<<11)           /*!< ALT_MFP PC.7 mask */
N#define SYS_ALT_MFP1_PC7_Msk        (1UL<<9)            /*!< ALT_MFP1 PC.7 mask */
N
N//PC.8
N#define SYS_GPC_MFP_PC8_GPIO        0x00000000UL        /*!< GPC_MFP PC.8 setting for GPIO */
N#define SYS_ALT_MFP_PC8_GPIO        0x00000000UL        /*!< ALT_MFP PC.8 setting for GPIO */
N#define SYS_ALT_MFP1_PC8_GPIO       NULL                /*!< No ALT_MFP1 setting for PC.8 */
N#define SYS_ALT_MFP2_PC8_GPIO       NULL                /*!< No ALT_MFP2 setting for PC.8 */
N
N#define SYS_GPC_MFP_PC8_SPI1_SS0    (1UL<<8)            /*!< GPC_MFP PC.8 setting for SPI1_SS0 */
N#define SYS_ALT_MFP_PC8_SPI1_SS0    0x00000000UL        /*!< ALT_MFP PC.8 setting for SPI1_SS0 */
N#define SYS_ALT_MFP1_PC8_SPI1_SS0   NULL                /*!< No ALT_MFP1 setting for PC.8 */
N#define SYS_ALT_MFP2_PC8_SPI1_SS0   NULL                /*!< No ALT_MFP2 setting for PC.8 */
N
N#define SYS_GPC_MFP_PC8_MCLK        (1UL<<8)                /*!< GPC_MFP PC.8 setting for MCLK  */
N#define SYS_ALT_MFP_PC8_MCLK        ((1UL<<11) | (1UL<<12)) /*!< ALT_MFP PC.8 setting for MCLK  */
N#define SYS_ALT_MFP1_PC8_MCLK       NULL                    /*!< No ALT_MFP1 setting for PC.8 */
N#define SYS_ALT_MFP2_PC8_MCLK       NULL                    /*!< No ALT_MFP2 setting for PC.8 */
N
N#define SYS_GPC_MFP_PC8_Msk         (1UL<<8)                /*!< GPC_MFP PC.8 mask */
N#define SYS_ALT_MFP_PC8_Msk         ((1UL<<11) | (1UL<<12)) /*!< ALT_MFP PC.8 mask */
N
N//PC.9
N#define SYS_GPC_MFP_PC9_GPIO        0x00000000UL        /*!< GPC_MFP PC.9 setting for GPIO */
N#define SYS_ALT_MFP_PC9_GPIO        NULL                /*!< No ALT_MFP setting for PC.9 */
N#define SYS_ALT_MFP1_PC9_GPIO       NULL                /*!< No ALT_MFP1 setting for PC.9 */
N#define SYS_ALT_MFP2_PC9_GPIO       NULL                /*!< No ALT_MFP2 setting for PC.9 */
N
N#define SYS_GPC_MFP_PC9_SPI1_CLK        (1UL<<9)        /*!< GPC_MFP PC.9 setting for SPI1_CLK */
N#define SYS_ALT_MFP_PC9_SPI1_CLK        NULL            /*!< No ALT_MFP setting for PC.9 */
N#define SYS_ALT_MFP1_PC9_SPI1_CLK       NULL            /*!< No ALT_MFP1 setting for PC.9 */
N#define SYS_ALT_MFP2_PC9_SPI1_CLK       NULL            /*!< No ALT_MFP2 setting for PC.9 */
N
N#define SYS_GPC_MFP_PC9_Msk         (1UL<<9)            /*!< GPC_MFP PC.9 mask */
N
N//PC.10
N#define SYS_GPC_MFP_PC10_GPIO       0x00000000UL        /*!< GPC_MFP PC.10 setting for GPIO */
N#define SYS_ALT_MFP_PC10_GPIO       NULL                /*!< No ALT_MFP setting for PC.10 */
N#define SYS_ALT_MFP1_PC10_GPIO      NULL                /*!< No ALT_MFP1 setting for PC.10 */
N#define SYS_ALT_MFP2_PC10_GPIO      NULL                /*!< No ALT_MFP2 setting for PC.10 */
N
N#define SYS_GPC_MFP_PC10_SPI1_MISO0     (1UL<<10)       /*!< GPC_MFP PC.10 setting for SPI1_MISO0 */
N#define SYS_ALT_MFP_PC10_SPI1_MISO0     NULL            /*!< No ALT_MFP setting for PC.10 */
N#define SYS_ALT_MFP1_PC10_SPI1_MISO0    NULL            /*!< No ALT_MFP1 setting for PC.10 */
N#define SYS_ALT_MFP2_PC10_SPI1_MISO0    NULL            /*!< No ALT_MFP2 setting for PC.10 */
N
N#define SYS_GPC_MFP_PC10_Msk        (1UL<<10)            /*!< GPC_MFP PC.10 mask */
N
N//PC.11
N#define SYS_GPC_MFP_PC11_GPIO       0x00000000UL        /*!< GPC_MFP PC.11 setting for GPIO */
N#define SYS_ALT_MFP_PC11_GPIO       NULL                /*!< No ALT_MFP setting for PC.11 */
N#define SYS_ALT_MFP1_PC11_GPIO      NULL                /*!< No ALT_MFP1 setting for PC.11 */
N#define SYS_ALT_MFP2_PC11_GPIO      NULL                /*!< No ALT_MFP2 setting for PC.11 */
N
N#define SYS_GPC_MFP_PC11_SPI1_MOSI0     (1UL<<11)       /*!< GPC_MFP PC.11 setting for SPI1_MOSI0 */
N#define SYS_ALT_MFP_PC11_SPI1_MOSI0     NULL            /*!< No ALT_MFP setting for PC.11 */
N#define SYS_ALT_MFP1_PC11_SPI1_MOSI0    NULL            /*!< No ALT_MFP1 setting for PC.11 */
N#define SYS_ALT_MFP2_PC11_SPI1_MOSI0    NULL            /*!< No ALT_MFP2 setting for PC.11 */
N
N#define SYS_GPC_MFP_PC11_Msk         (1UL<<11)          /*!< GPC_MFP PC.11 mask */
N
N//PC.12
N#define SYS_GPC_MFP_PC12_GPIO        0x00000000UL       /*!< GPC_MFP PC.12 setting for GPIO */
N#define SYS_ALT_MFP_PC12_GPIO        NULL               /*!< No ALT_MFP setting for PC.12 */
N#define SYS_ALT_MFP1_PC12_GPIO       NULL               /*!< No ALT_MFP1 setting for PC.12 */
N#define SYS_ALT_MFP2_PC12_GPIO       NULL               /*!< No ALT_MFP2 setting for PC.12 */
N
N#define SYS_GPC_MFP_PC12_SPI1_MISO1      (1UL<<12)      /*!< GPC_MFP PC.12 setting for SPI1_MISO1 */
N#define SYS_ALT_MFP_PC12_SPI1_MISO1      NULL           /*!< No ALT_MFP setting for PC.12 */
N#define SYS_ALT_MFP1_PC12_SPI1_MISO1     NULL           /*!< No ALT_MFP1 setting for PC.12 */
N#define SYS_ALT_MFP2_PC12_SPI1_MISO1     NULL           /*!< No ALT_MFP2 setting for PC.12 */
N
N#define SYS_GPC_MFP_PC12_Msk         (1UL<<12)          /*!< GPC_MFP PC.12 mask */
N
N//PC.13
N#define SYS_GPC_MFP_PC13_GPIO        0x00000000UL       /*!< GPC_MFP PC.13 setting for GPIO */
N#define SYS_ALT_MFP_PC13_GPIO        NULL               /*!< No ALT_MFP setting for PC.13 */
N#define SYS_ALT_MFP1_PC13_GPIO       NULL               /*!< No ALT_MFP1 setting for PC.13 */
N#define SYS_ALT_MFP2_PC13_GPIO       NULL               /*!< No ALT_MFP2 setting for PC.13 */
N
N#define SYS_GPC_MFP_PC13_SPI1_MOSI1     (1UL<<13)       /*!< GPC_MFP PC.13 setting for SPI1_MOSI1 */
N#define SYS_ALT_MFP_PC13_SPI1_MOSI1     NULL            /*!< No ALT_MFP setting for PC.13 */
N#define SYS_ALT_MFP1_PC13_SPI1_MOSI1    NULL            /*!< No ALT_MFP1 setting for PC.13 */
N#define SYS_ALT_MFP2_PC13_SPI1_MOSI1    NULL            /*!< No ALT_MFP2 setting for PC.13 */
N
N#define SYS_GPC_MFP_PC13_Msk         (1UL<<13)          /*!< GPC_MFP PC.13 mask */
N
N//PC.14
N#define SYS_GPC_MFP_PC14_GPIO        0x00000000UL       /*!< GPC_MFP PC.14 setting for GPIO */
N#define SYS_ALT_MFP_PC14_GPIO        0x00000000UL       /*!< ALT_MFP PC.14 setting for GPIO */
N#define SYS_ALT_MFP1_PC14_GPIO       NULL               /*!< No ALT_MFP1 setting for PC.14 */
N#define SYS_ALT_MFP2_PC14_GPIO       NULL               /*!< No ALT_MFP2 setting for PC.14 */
N
N#define SYS_GPC_MFP_PC14_ACMP1_P     (1UL<<14)          /*!< GPC_MFP PC.14 setting for ACMP1_P */
N#define SYS_ALT_MFP_PC14_ACMP1_P     0x00000000UL       /*!< ALT_MFP PC.14 setting for ACMP1_P */
N#define SYS_ALT_MFP1_PC14_ACMP1_P    NULL               /*!< No ALT_MFP1 setting for PC.14 */
N#define SYS_ALT_MFP2_PC14_ACMP1_P    NULL               /*!< No ALT_MFP2 setting for PC.14 */
N
N#define SYS_GPC_MFP_PC14_AD2        (1UL<<14)           /*!< GPC_MFP PC.14 setting for AD2 */
N#define SYS_ALT_MFP_PC14_AD2        (1UL<<11)           /*!< ALT_MFP PC.14 setting for AD2 */
N#define SYS_ALT_MFP1_PC14_AD2       NULL                /*!< No ALT_MFP1 setting for PC.14 */
N#define SYS_ALT_MFP2_PC14_AD2       NULL                /*!< No ALT_MFP2 setting for PC.14 */
N
N#define SYS_GPC_MFP_PC14_Msk        (1UL<<14)           /*!< GPC_MFP PC.14 mask */
N#define SYS_ALT_MFP_PC14_Msk        (1UL<<11)           /*!< ALT_MFP PC.14 mask */
N
N//PC.15
N#define SYS_GPC_MFP_PC15_GPIO       0x00000000UL        /*!< GPC_MFP PC.15 setting for GPIO */
N#define SYS_ALT_MFP_PC15_GPIO       0x00000000UL        /*!< ALT_MFP PC.15 setting for GPIO */
N#define SYS_ALT_MFP1_PC15_GPIO      NULL                /*!< No ALT_MFP1 setting for PC.15 */
N#define SYS_ALT_MFP2_PC15_GPIO      NULL                /*!< No ALT_MFP2 setting for PC.15 */
N
N#define SYS_GPC_MFP_PC15_ACMP1_N    (1UL<<15)           /*!< GPC_MFP PC.15 setting for ACMP1_N */
N#define SYS_ALT_MFP_PC15_ACMP1_N    0x00000000UL        /*!< ALT_MFP PC.15 setting for ACMP1_N */
N#define SYS_ALT_MFP1_PC15_ACMP1_N   NULL                /*!< No ALT_MFP1 setting for PC.15 */
N#define SYS_ALT_MFP2_PC15_ACMP1_N   NULL                /*!< No ALT_MFP2 setting for PC.15 */
N
N#define SYS_GPC_MFP_PC15_AD3        (1UL<<15)           /*!< GPB_MFP PC.15 setting for AD3 */
N#define SYS_ALT_MFP_PC15_AD3        (1UL<<11)           /*!< ALT_MFP PC.15 setting for AD3 */
N#define SYS_ALT_MFP1_PC15_AD3       NULL                /*!< No ALT_MFP1 setting for PC.15 */
N#define SYS_ALT_MFP2_PC15_AD3       NULL                /*!< No ALT_MFP2 setting for PC.15 */
N
N#define SYS_GPC_MFP_PC15_Msk        (1UL<<15)           /*!< GPC_MFP PC.15 mask */
N#define SYS_ALT_MFP_PC15_Msk        (1UL<<11)           /*!< ALT_MFP PC.15 mask */
N
N//PD.0
N#define SYS_GPD_MFP_PD0_GPIO        0x00000000UL        /*!< GPD_MFP PD.0 setting for GPIO */
N#define SYS_ALT_MFP_PD0_GPIO        NULL                /*!< No ALT_MFP setting for PD.0 */
N#define SYS_ALT_MFP1_PD0_GPIO       NULL                /*!< No ALT_MFP1 setting for PD.0 */
N#define SYS_ALT_MFP2_PD0_GPIO       NULL                /*!< No ALT_MFP2 setting for PD.0 */
N
N#define SYS_GPD_MFP_PD0_SPI2_SS0     (1UL<<0)           /*!< GPD_MFP PD.0 setting for SPI2_SS0 */
N#define SYS_ALT_MFP_PD0_SPI2_SS0     NULL               /*!< No ALT_MFP setting for PD.0 */
N#define SYS_ALT_MFP1_PD0_SPI2_SS0    NULL               /*!< No ALT_MFP1 setting for PD.0 */
N#define SYS_ALT_MFP2_PD0_SPI2_SS0    NULL               /*!< No ALT_MFP2 setting for PD.0 */
N
N#define SYS_GPD_MFP_PD0_Msk         (1UL<<0)            /*!< GPD_MFP PD.0 mask */
N
N//PD.1
N#define SYS_GPD_MFP_PD1_GPIO        0x00000000UL        /*!< GPD_MFP PD.1 setting for GPIO */
N#define SYS_ALT_MFP_PD1_GPIO        NULL                /*!< No ALT_MFP setting for PD.1 */
N#define SYS_ALT_MFP1_PD1_GPIO       NULL                /*!< No ALT_MFP1 setting for PD.1 */
N#define SYS_ALT_MFP2_PD1_GPIO       NULL                /*!< No ALT_MFP2 setting for PD.1 */
N
N#define SYS_GPD_MFP_PD1_SPI2_CLK     (1UL<<1)           /*!< GPD_MFP PD.1 setting for SPI2_CLK */
N#define SYS_ALT_MFP_PD1_SPI2_CLK     NULL               /*!< No ALT_MFP setting for PD.1 */
N#define SYS_ALT_MFP1_PD1_SPI2_CLK    NULL               /*!< No ALT_MFP1 setting for PD.1 */
N#define SYS_ALT_MFP2_PD1_SPI2_CLK    NULL               /*!< No ALT_MFP2 setting for PD.1 */
N
N#define SYS_GPD_MFP_PD1_Msk         (1UL<<1)            /*!< GPD_MFP PD.1 mask */
N
N//PD.2
N#define SYS_GPD_MFP_PD2_GPIO        0x00000000UL        /*!< GPD_MFP PD.2 setting for GPIO */
N#define SYS_ALT_MFP_PD2_GPIO        NULL                /*!< No ALT_MFP setting for PD.2 */
N#define SYS_ALT_MFP1_PD2_GPIO       NULL                /*!< No ALT_MFP1 setting for PD.2 */
N#define SYS_ALT_MFP2_PD2_GPIO       NULL                /*!< No ALT_MFP2 setting for PD.2 */
N
N#define SYS_GPD_MFP_PD2_SPI2_MISO0      (1UL<<2)        /*!< GPD_MFP PD.2 setting for SPI2_MISO0 */
N#define SYS_ALT_MFP_PD2_SPI2_MISO0      NULL            /*!< No ALT_MFP setting for PD.2 */
N#define SYS_ALT_MFP1_PD2_SPI2_MISO0     NULL            /*!< No ALT_MFP1 setting for PD.2 */
N#define SYS_ALT_MFP2_PD2_SPI2_MISO0     NULL            /*!< No ALT_MFP2 setting for PD.2 */
N
N#define SYS_GPD_MFP_PD2_Msk         (1UL<<2)            /*!< GPD_MFP PD.2 mask */
N
N//PD.3
N#define SYS_GPD_MFP_PD3_GPIO        0x00000000UL        /*!< GPD_MFP PD.3 setting for GPIO */
N#define SYS_ALT_MFP_PD3_GPIO        NULL                /*!< No ALT_MFP setting for PD.3 */
N#define SYS_ALT_MFP1_PD3_GPIO       NULL                /*!< No ALT_MFP1 setting for PD.3 */
N#define SYS_ALT_MFP2_PD3_GPIO       NULL                /*!< No ALT_MFP2 setting for PD.3 */
N
N#define SYS_GPD_MFP_PD3_SPI2_MOSI0      (1UL<<3)        /*!< GPD_MFP PD.3 setting for SPI2_MOSI0 */
N#define SYS_ALT_MFP_PD3_SPI2_MOSI0      NULL            /*!< No ALT_MFP setting for PD.3 */
N#define SYS_ALT_MFP1_PD3_SPI2_MOSI0     NULL            /*!< No ALT_MFP1 setting for PD.3 */
N#define SYS_ALT_MFP2_PD3_SPI2_MOSI0     NULL            /*!< No ALT_MFP2 setting for PD.3 */
N
N#define SYS_GPD_MFP_PD3_Msk         (1UL<<3)            /*!< GPD_MFP PD.3 mask */
N
N//PD.4
N#define SYS_GPD_MFP_PD4_GPIO        0x00000000UL        /*!< GPD_MFP PD.4 setting for GPIO */
N#define SYS_ALT_MFP_PD4_GPIO        NULL                /*!< No ALT_MFP setting for PD.4 */
N#define SYS_ALT_MFP1_PD4_GPIO       NULL                /*!< No ALT_MFP1 setting for PD.4 */
N#define SYS_ALT_MFP2_PD4_GPIO       NULL                /*!< No ALT_MFP2 setting for PD.4 */
N
N#define SYS_GPD_MFP_PD4_SPI2_MISO1      (1UL<<4)        /*!< GPD_MFP PD.4 setting for SPI2_MISO1 */
N#define SYS_ALT_MFP_PD4_SPI2_MISO1      NULL            /*!< No ALT_MFP setting for PD.4 */
N#define SYS_ALT_MFP1_PD4_SPI2_MISO1     NULL            /*!< No ALT_MFP1 setting for PD.4 */
N#define SYS_ALT_MFP2_PD4_SPI2_MISO1     NULL            /*!< No ALT_MFP2 setting for PD.4 */
N
N#define SYS_GPD_MFP_PD4_Msk         (1UL<<4)            /*!< GPD_MFP PD.4 mask */
N
N//PD.5
N#define SYS_GPD_MFP_PD5_GPIO        0x00000000UL        /*!< GPD_MFP PD.5 setting for GPIO */
N#define SYS_ALT_MFP_PD5_GPIO        NULL                /*!< No ALT_MFP setting for PD.5 */
N#define SYS_ALT_MFP1_PD5_GPIO       NULL                /*!< No ALT_MFP1 setting for PD.5 */
N#define SYS_ALT_MFP2_PD5_GPIO       NULL                /*!< No ALT_MFP2 setting for PD.5 */
N
N#define SYS_GPD_MFP_PD5_SPI2_MOSI1      (1UL<<5)        /*!< GPD_MFP PD.5 setting for SPI2_MOSI1 */
N#define SYS_ALT_MFP_PD5_SPI2_MOSI1      NULL            /*!< No ALT_MFP setting for PD.5 */
N#define SYS_ALT_MFP1_PD5_SPI2_MOSI1     NULL            /*!< No ALT_MFP1 setting for PD.5 */
N#define SYS_ALT_MFP2_PD5_SPI2_MOSI1     NULL            /*!< No ALT_MFP2 setting for PD.5 */
N
N#define SYS_GPD_MFP_PD5_Msk         (1UL<<5)            /*!< GPD_MFP PD.5 mask */
N
N//PD.6
N#define SYS_GPD_MFP_PD6_GPIO        0x00000000UL        /*!< GPD_MFP PD.6 setting for GPIO */
N#define SYS_ALT_MFP_PD6_GPIO        NULL                /*!< No ALT_MFP setting for PD.6 */
N#define SYS_ALT_MFP1_PD6_GPIO       NULL                /*!< No ALT_MFP1 setting for PD.6 */
N#define SYS_ALT_MFP2_PD6_GPIO       NULL                /*!< No ALT_MFP2 setting for PD.6 */
N
N#define SYS_GPD_MFP_PD6_CAN0_RXD      (1UL<<6)          /*!< GPD_MFP PD.6 setting for CAN0_RXD */
N#define SYS_ALT_MFP_PD6_CAN0_RXD      NULL              /*!< No ALT_MFP setting for PD.6 */
N#define SYS_ALT_MFP1_PD6_CAN0_RXD     NULL              /*!< No ALT_MFP1 setting for PD.6 */
N#define SYS_ALT_MFP2_PD6_CAN0_RXD     NULL              /*!< No ALT_MFP2 setting for PD.6 */
N
N#define SYS_GPD_MFP_PD6_Msk         (1UL<<6)            /*!< GPD_MFP PD.6 mask */
N
N//PD.7
N#define SYS_GPD_MFP_PD7_GPIO        0x00000000UL        /*!< GPD_MFP PD.7 setting for GPIO */
N#define SYS_ALT_MFP_PD7_GPIO        NULL                /*!< No ALT_MFP setting for PD.7 */
N#define SYS_ALT_MFP1_PD7_GPIO       NULL                /*!< No ALT_MFP1 setting for PD.7 */
N#define SYS_ALT_MFP2_PD7_GPIO       NULL                /*!< No ALT_MFP2 setting for PD.7 */
N
N#define SYS_GPD_MFP_PD7_CAN0_TXD      (1UL<<7)          /*!< GPD_MFP PD.7 setting for CAN0_TXD */
N#define SYS_ALT_MFP_PD7_CAN0_TXD      NULL              /*!< No ALT_MFP setting for PD.7 */
N#define SYS_ALT_MFP1_PD7_CAN0_TXD     NULL              /*!< No ALT_MFP1 setting for PD.7 */
N#define SYS_ALT_MFP2_PD7_CAN0_TXD     NULL              /*!< No ALT_MFP2 setting for PD.7 */
N
N#define SYS_GPD_MFP_PD7_Msk         (1UL<<7)            /*!< GPD_MFP PD.7 mask */
N
N//PD.8
N#define SYS_GPD_MFP_PD8_GPIO        0x00000000UL        /*!< GPD_MFP PD.8 setting for GPIO */
N#define SYS_ALT_MFP_PD8_GPIO        NULL                /*!< No ALT_MFP setting for PD.8 */
N#define SYS_ALT_MFP1_PD8_GPIO       NULL                /*!< No ALT_MFP1 setting for PD.8 */
N#define SYS_ALT_MFP2_PD8_GPIO       NULL                /*!< No ALT_MFP2 setting for PD.8 */
N
N#define SYS_GPD_MFP_PD8_SPI3_SS0        (1UL<<8)        /*!< GPD_MFP PD.8 setting for SPI3 SPI3_SS0 */
N#define SYS_ALT_MFP_PD8_SPI3_SS0        NULL            /*!< No ALT_MFP setting for PD.8 */
N#define SYS_ALT_MFP1_PD8_SPI3_SS0       NULL            /*!< No ALT_MFP1 setting for PD.8 */
N#define SYS_ALT_MFP2_PD8_SPI3_SS0       NULL            /*!< No ALT_MFP2 setting for PD.8 */
N
N#define SYS_GPD_MFP_PD8_Msk         (1UL<<8)            /*!< GPD_MFP PD.8 mask */
N
N//PD.9
N#define SYS_GPD_MFP_PD9_GPIO        0x00000000UL        /*!< GPD_MFP PD.9 setting for GPIO */
N#define SYS_ALT_MFP_PD9_GPIO        NULL                /*!< No ALT_MFP setting for PD.9 */
N#define SYS_ALT_MFP1_PD9_GPIO       NULL                /*!< No ALT_MFP1 setting for PD.9 */
N#define SYS_ALT_MFP2_PD9_GPIO       NULL                /*!< No ALT_MFP2 setting for PD.9 */
N
N#define SYS_GPD_MFP_PD9_SPI3_CLK    (1UL<<9)            /*!< GPD_MFP PD.9 setting for SPI3_CLK */
N#define SYS_ALT_MFP_PD9_SPI3_CLK    NULL                /*!< No ALT_MFP setting for PD.9 */
N#define SYS_ALT_MFP1_PD9_SPI3_CLK   NULL                /*!< No ALT_MFP1 setting for PD.9 */
N#define SYS_ALT_MFP2_PD9_SPI3_CLK   NULL                /*!< No ALT_MFP2 setting for PD.9 */
N
N#define SYS_GPD_MFP_PD9_Msk         (1UL<<9)            /*!< GPD_MFP PD.9 mask */
N
N//PD.10
N#define SYS_GPD_MFP_PD10_GPIO       0x00000000UL        /*!< GPD_MFP PD.10 setting for GPIO */
N#define SYS_ALT_MFP_PD10_GPIO       NULL                /*!< No ALT_MFP setting for PD.10 */
N#define SYS_ALT_MFP1_PD10_GPIO      NULL                /*!< No ALT_MFP1 setting for PD.10 */
N#define SYS_ALT_MFP2_PD10_GPIO      NULL                /*!< No ALT_MFP2 setting for PD.10 */
N
N#define SYS_GPD_MFP_PD10_SPI3_MISO0     (1UL<<10)       /*!< GPD_MFP PD.10 setting for SPI3_MISO0 */
N#define SYS_ALT_MFP_PD10_SPI3_MISO0     NULL            /*!< No ALT_MFP setting for PD.10 */
N#define SYS_ALT_MFP1_PD10_SPI3_MISO0    NULL            /*!< No ALT_MFP1 setting for PD.10 */
N#define SYS_ALT_MFP2_PD10_SPI3_MISO0    NULL            /*!< No ALT_MFP2 setting for PD.10 */
N
N#define SYS_GPD_MFP_PD10_Msk        (1UL<<10)           /*!< GPD_MFP PD.10 mask */
N
N//PD.11
N#define SYS_GPD_MFP_PD11_GPIO       0x00000000UL        /*!< GPD_MFP PD.11 setting for GPIO */
N#define SYS_ALT_MFP_PD11_GPIO       NULL                /*!< No ALT_MFP setting for PD.11 */
N#define SYS_ALT_MFP1_PD11_GPIO      NULL                /*!< No ALT_MFP1 setting for PD.11 */
N#define SYS_ALT_MFP2_PD11_GPIO      NULL                /*!< No ALT_MFP2 setting for PD.11 */
N
N#define SYS_GPD_MFP_PD11_SPI3_MOSI0     (1UL<<11)       /*!< GPD_MFP PD.11 setting for SPI3_MOSI0 */
N#define SYS_ALT_MFP_PD11_SPI3_MOSI0     NULL            /*!< No ALT_MFP setting for PD.11 */
N#define SYS_ALT_MFP1_PD11_SPI3_MOSI0    NULL            /*!< No ALT_MFP1 setting for PD.11 */
N#define SYS_ALT_MFP2_PD11_SPI3_MOSI0    NULL            /*!< No ALT_MFP2 setting for PD.11 */
N
N#define SYS_GPD_MFP_PD11_Msk        (1UL<<11)           /*!< GPD_MFP PD.11 mask */
N
N//PD.12
N#define SYS_GPD_MFP_PD12_GPIO       0x00000000UL        /*!< GPD_MFP PD.12 setting for GPIO */
N#define SYS_ALT_MFP_PD12_GPIO       NULL                /*!< No ALT_MFP setting for PD.12 */
N#define SYS_ALT_MFP1_PD12_GPIO      NULL                /*!< No ALT_MFP1 setting for PD.12 */
N#define SYS_ALT_MFP2_PD12_GPIO      NULL                /*!< No ALT_MFP2 setting for PD.12 */
N
N#define SYS_GPD_MFP_PD12_SPI3_MISO1     (1UL<<12)       /*!< GPD_MFP PD.12 setting for SPI3_MISO1 */
N#define SYS_ALT_MFP_PD12_SPI3_MISO1     NULL            /*!< No ALT_MFP setting for PD.12 */
N#define SYS_ALT_MFP1_PD12_SPI3_MISO1    NULL            /*!< No ALT_MFP1 setting for PD.12 */
N#define SYS_ALT_MFP2_PD12_SPI3_MISO1    NULL            /*!< No ALT_MFP2 setting for PD.12 */
N
N#define SYS_GPD_MFP_PD12_Msk        (1UL<<12)           /*!< GPD_MFP PD.12 mask */
N
N//PD.13
N#define SYS_GPD_MFP_PD13_GPIO       0x00000000UL        /*!< GPD_MFP PD.13 setting for GPIO */
N#define SYS_ALT_MFP_PD13_GPIO       NULL                /*!< No ALT_MFP setting for PD.13 */
N#define SYS_ALT_MFP1_PD13_GPIO      NULL                /*!< No ALT_MFP1 setting for PD.13 */
N#define SYS_ALT_MFP2_PD13_GPIO      NULL                /*!< No ALT_MFP2 setting for PD.13 */
N
N#define SYS_GPD_MFP_PD13_SPI3_MOSI1     (1UL<<13)       /*!< GPD_MFP PD.13 setting for SPI3_MOSI1 */
N#define SYS_ALT_MFP_PD13_SPI3_MOSI1     NULL            /*!< No ALT_MFP setting for PD.13 */
N#define SYS_ALT_MFP1_PD13_SPI3_MOSI1    NULL            /*!< No ALT_MFP1 setting for PD.13 */
N#define SYS_ALT_MFP2_PD13_SPI3_MOSI1    NULL            /*!< No ALT_MFP2 setting for PD.13 */
N
N#define SYS_GPD_MFP_PD13_Msk        (1UL<<13)           /*!< GPD_MFP PD.13 mask */
N
N//PD.14
N#define SYS_GPD_MFP_PD14_GPIO       0x00000000UL        /*!< GPD_MFP PD.14 setting for GPIO */
N#define SYS_ALT_MFP_PD14_GPIO       NULL                /*!< No ALT_MFP setting for PD.14 */
N#define SYS_ALT_MFP1_PD14_GPIO      NULL                /*!< No ALT_MFP1 setting for PD.14 */
N#define SYS_ALT_MFP2_PD14_GPIO      0x00000000UL        /*!< ALT_MFP2 PD.14 setting for GPIO */
N
N#define SYS_GPD_MFP_PD14_UART2_RXD      (1UL<<14)       /*!< GPD_MFP PD.14 setting for UART2_RXD */
N#define SYS_ALT_MFP_PD14_UART2_RXD      NULL            /*!< No ALT_MFP setting for PD.14 */
N#define SYS_ALT_MFP1_PD14_UART2_RXD     NULL            /*!< No ALT_MFP1 setting for PD.14 */
N#define SYS_ALT_MFP2_PD14_UART2_RXD     0x00000000UL    /*!< ALT_MFP2 PD.14 setting for UART2_RXD */
N
N#define SYS_GPD_MFP_PD14_CAN1_RXD       (1UL<<14)       /*!< GPD_MFP PD.14 setting for CAN1_RXD */
N#define SYS_ALT_MFP_PD14_CAN1_RXD       NULL            /*!< No ALT_MFP setting for PD.14 */
N#define SYS_ALT_MFP1_PD14_CAN1_RXD      NULL            /*!< No ALT_MFP1 setting for PD.14 */
N#define SYS_ALT_MFP2_PD14_CAN1_RXD      (1UL<<0)        /*!< ALT_MFP2 PD.14 setting for CAN1_RXD */
N
N#define SYS_GPD_MFP_PD14_Msk        (1UL<<14)           /*!< GPD_MFP PD.14 mask */
N#define SYS_ALT_MFP2_PD14_Msk       (1UL<<0)            /*!< ALT_MFP2 PD.14 mask */
N
N//PD.15
N#define SYS_GPD_MFP_PD15_GPIO       0x00000000UL        /*!< GPD_MFP PD.15 setting for GPIO */
N#define SYS_ALT_MFP_PD15_GPIO       NULL                /*!< No ALT_MFP setting for PD.15 */
N#define SYS_ALT_MFP1_PD15_GPIO      NULL                /*!< No ALT_MFP1 setting for PD.15 */
N#define SYS_ALT_MFP2_PD15_GPIO      0x00000000UL        /*!< ALT_MFP2 PD.15 setting for GPIO */
N
N#define SYS_GPD_MFP_PD15_UART2_TXD       (1UL<<15)      /*!< GPD_MFP PD.15 setting for UART2_TXD */
N#define SYS_ALT_MFP_PD15_UART2_TXD       NULL           /*!< No ALT_MFP setting for PD.15 */
N#define SYS_ALT_MFP1_PD15_UART2_TXD      NULL           /*!< No ALT_MFP1 setting for PD.15 */
N#define SYS_ALT_MFP2_PD15_UART2_TXD      0x00000000UL   /*!< ALT_MFP2 PD.15 setting for UART2_TXD */
N
N#define SYS_GPD_MFP_PD15_CAN1_TXD       (1UL<<15)       /*!< GPD_MFP PD.15 setting for CAN1_TXD */
N#define SYS_ALT_MFP_PD15_CAN1_TXD       NULL            /*!< No ALT_MFP setting for PD.15 */
N#define SYS_ALT_MFP1_PD15_CAN1_TXD      NULL            /*!< No ALT_MFP1 setting for PD.15 */
N#define SYS_ALT_MFP2_PD15_CAN1_TXD      (1UL<<0)        /*!< ALT_MFP2 PD.15 setting for CAN1_TXD */
N
N#define SYS_GPD_MFP_PD15_Msk        (1UL<<15)           /*!< GPD_MFP PD.15 mask */
N#define SYS_ALT_MFP2_PD15_Msk       (1UL<<0)            /*!< ALT_MFP2 PD.15 mask */
N
N//PE.0
N#define SYS_GPE_MFP_PE0_GPIO        0x00000000UL        /*!< GPE_MFP PE.0 setting for GPIO */
N#define SYS_ALT_MFP_PE0_GPIO        NULL                /*!< No ALT_MFP setting for PE.0 */
N#define SYS_ALT_MFP1_PE0_GPIO       NULL                /*!< No ALT_MFP1 setting for PE.0 */
N#define SYS_ALT_MFP2_PE0_GPIO       NULL                /*!< No ALT_MFP2 setting for PE.0 */
N
N#define SYS_GPE_MFP_PE0_PWM6        (1UL<<0)            /*!< GPE_MFP PE.0 setting for PWM6 */
N#define SYS_ALT_MFP_PE0_PWM6        NULL                /*!< No ALT_MFP setting for PE.0 */
N#define SYS_ALT_MFP1_PE0_PWM6       NULL                /*!< No ALT_MFP1 setting for PE.0 */
N#define SYS_ALT_MFP2_PE0_PWM6       NULL                /*!< No ALT_MFP2 setting for PE.0 */
N
N#define SYS_GPE_MFP_PE0_Msk         (1UL<<0)            /*!< GPE_MFP PE.0 mask */
N
N//PE.1
N#define SYS_GPE_MFP_PE1_GPIO        0x00000000UL        /*!< GPE_MFP PE.1 setting for GPIO */
N#define SYS_ALT_MFP_PE1_GPIO        NULL                /*!< No ALT_MFP setting for PE.1 */
N#define SYS_ALT_MFP1_PE1_GPIO       NULL                /*!< No ALT_MFP1 setting for PE.1 */
N#define SYS_ALT_MFP2_PE1_GPIO       NULL                /*!< No ALT_MFP2 setting for PE.1 */
N
N#define SYS_GPE_MFP_PE1_PWM7        (1UL<<1)            /*!< GPE_MFP PE.1 setting for PWM7 */
N#define SYS_ALT_MFP_PE1_PWM7        NULL                /*!< No ALT_MFP setting for PE.1 */
N#define SYS_ALT_MFP1_PE1_PWM7       NULL                /*!< No ALT_MFP1 setting for PE.1 */
N#define SYS_ALT_MFP2_PE1_PWM7       NULL                /*!< No ALT_MFP2 setting for PE.1 */
N
N#define SYS_GPE_MFP_PE1_Msk         (1UL<<1)            /*!< GPE_MFP PE.1 mask */
N
N//PE.5
N#define SYS_GPE_MFP_PE5_GPIO        0x00000000UL        /*!< GPE_MFP PE.5 setting for GPIO */
N#define SYS_ALT_MFP_PE5_GPIO        0x00000000UL        /*!< ALT_MFP PE.5 setting for GPIO */
N#define SYS_ALT_MFP1_PE5_GPIO       NULL                /*!< No ALT_MFP1 setting for PE.5 */
N#define SYS_ALT_MFP2_PE5_GPIO       0x00000000UL        /*!< ALT_MFP2 PE.5 setting for GPIO */
N
N#define SYS_GPE_MFP_PE5_PWM5        (1UL<<5)            /*!< GPE_MFP PE.5 setting for PWM5 */
N#define SYS_ALT_MFP_PE5_PWM5        0x00000000UL        /*!< ALT_MFP PE.5 setting for PWM5 */
N#define SYS_ALT_MFP1_PE5_PWM5       NULL                /*!< No ALT_MFP1 setting for PE.5 */
N#define SYS_ALT_MFP2_PE5_PWM5       0x00000000UL        /*!< ALT_MFP2 PE.5 setting for PWM5 */
N
N#define SYS_GPE_MFP_PE5_TM1_EXT     (1UL<<5)            /*!< GPE_MFP PE.5 setting for TM1_EXT */
N#define SYS_ALT_MFP_PE5_TM1_EXT     (1UL<<25)           /*!< ALT_MFP PE.5 setting for TM1_EXT */
N#define SYS_ALT_MFP1_PE5_TM1_EXT    NULL                /*!< No ALT_MFP1 setting for PE.5 */
N#define SYS_ALT_MFP2_PE5_TM1_EXT    0x00000000UL        /*!< ALT_MFP2 PE.5 setting for TM1_EXT */
N
N#define SYS_GPE_MFP_PE5_TM1         (1UL<<5)            /*!< GPE_MFP PE.5 setting for TM1 */
N#define SYS_ALT_MFP_PE5_TM1         0x00000000UL        /*!< ALT_MFP PE.5 setting for TM1 */
N#define SYS_ALT_MFP1_PE5_TM1        NULL                /*!< No ALT_MFP1 setting for PE.5 */
N#define SYS_ALT_MFP2_PE5_TM1        (1UL<<3)            /*!< ALT_MFP2 PE.5 setting for TM1 */
N
N#define SYS_GPE_MFP_PE5_Msk         (1UL<<5)            /*!< GPE_MFP PE.5 mask */
N#define SYS_ALT_MFP_PE5_Msk         (1UL<<25)           /*!< ALT_MFP PE.5 mask */
N#define SYS_ALT_MFP2_PE5_Msk        (1UL<<3)            /*!< ALT_MFP2 PE.5 mask */
N
N//PF.0
N#define SYS_GPF_MFP_PF0_GPIO        0x00000000UL        /*!< GPF_MFP PF.0 setting for GPIO */
N#define SYS_ALT_MFP_PF0_GPIO        NULL                /*!< No ALT_MFP setting for PF.0 */
N#define SYS_ALT_MFP1_PF0_GPIO       NULL                /*!< No ALT_MFP1 setting for PF.0 */
N#define SYS_ALT_MFP2_PF0_GPIO       NULL                /*!< No ALT_MFP2 setting for PF.0 */
N
N#define SYS_GPF_MFP_PF0_XT1_OUT     (1UL<<0)            /*!< GPF_MFP PF.0 setting for XT1_OUT */
N#define SYS_ALT_MFP_PF0_XT1_OUT     NULL                /*!< No ALT_MFP setting for PF.0 */
N#define SYS_ALT_MFP1_PF0_XT1_OUT    NULL                /*!< No ALT_MFP1 setting for PF.0 */
N#define SYS_ALT_MFP2_PF0_XT1_OUT    NULL                /*!< No ALT_MFP2 setting for PF.0 */
N
N#define SYS_GPF_MFP_PF0_Msk         (1UL<<0)            /*!< GPF_MFP PF.0 mask */
N
N//PF.1
N#define SYS_GPF_MFP_PF1_GPIO        0x00000000UL        /*!< GPF_MFP PF.1 setting for GPIO */
N#define SYS_ALT_MFP_PF1_GPIO        NULL                /*!< No ALT_MFP setting for PF.1 */
N#define SYS_ALT_MFP1_PF1_GPIO       NULL                /*!< No ALT_MFP1 setting for PF.1 */
N#define SYS_ALT_MFP2_PF1_GPIO       NULL                /*!< No ALT_MFP2 setting for PF.1 */
N
N#define SYS_GPF_MFP_PF1_XT1_IN      (1UL<<1)            /*!< GPF_MFP PF.1 setting for XT1_IN */
N#define SYS_ALT_MFP_PF1_XT1_IN      NULL                /*!< No ALT_MFP setting for PF.1 */
N#define SYS_ALT_MFP1_PF1_XT1_IN     NULL                /*!< No ALT_MFP1 setting for PF.1 */
N#define SYS_ALT_MFP2_PF1_XT1_IN     NULL                /*!< No ALT_MFP2 setting for PF.1 */
N
N#define SYS_GPF_MFP_PF1_Msk         (1UL<<1)            /*!< GPF_MFP PF.1 mask */
N
N//PF.2
N#define SYS_GPF_MFP_PF2_GPIO        0x00000000UL        /*!< GPF_MFP PF.2 setting for GPIO */
N#define SYS_ALT_MFP_PF2_GPIO        NULL                /*!< No ALT_MFP setting for PF.2 */
N#define SYS_ALT_MFP1_PF2_GPIO       NULL                /*!< No ALT_MFP1 setting for PF.2 */
N#define SYS_ALT_MFP2_PF2_GPIO       NULL                /*!< No ALT_MFP2 setting for PF.2 */
N
N#define SYS_GPF_MFP_PF2_PS2_DAT     (1UL<<2)            /*!< GPF_MFP PF.2 setting for PS2_DAT */
N#define SYS_ALT_MFP_PF2_PS2_DAT     NULL                /*!< No ALT_MFP setting for PF.2 */
N#define SYS_ALT_MFP1_PF2_PS2_DAT    NULL                /*!< No ALT_MFP1 setting for PF.2 */
N#define SYS_ALT_MFP2_PF2_PS2_DAT    NULL                /*!< No ALT_MFP2 setting for PF.2 */
N
N#define SYS_GPF_MFP_PF2_Msk         (1UL<<2)            /*!< GPF_MFP PF.2 mask */
N
N//PF.3
N#define SYS_GPF_MFP_PF3_GPIO        0x00000000UL        /*!< GPF_MFP PF.3 setting for GPIO */
N#define SYS_ALT_MFP_PF3_GPIO        NULL                /*!< No ALT_MFP setting for PF.3 */
N#define SYS_ALT_MFP1_PF3_GPIO       NULL                /*!< No ALT_MFP1 setting for PF.3 */
N#define SYS_ALT_MFP2_PF3_GPIO       NULL                /*!< No ALT_MFP2 setting for PF.3 */
N
N#define SYS_GPF_MFP_PF3_PS2_CLK     (1UL<<3)            /*!< GPF_MFP PF.3 setting for PS2_CLK */
N#define SYS_ALT_MFP_PF3_PS2_CLK     NULL                /*!< No ALT_MFP setting for PF.3 */
N#define SYS_ALT_MFP1_PF3_PS2_CLK    NULL                /*!< No ALT_MFP1 setting for PF.3 */
N#define SYS_ALT_MFP2_PF3_PS2_CLK    NULL                /*!< No ALT_MFP2 setting for PF.3 */
N
N#define SYS_GPF_MFP_PF3_Msk         (1UL<<3)            /*!< GPF_MFP PF.3 mask */
N
N
N/*@}*/ /* end of group SYS_EXPORTED_CONSTANTS */
N
N/** @addtogroup SYS_EXPORTED_FUNCTIONS SYS Exported Functions
N  @{
N*/
N
N
N/**
N  * @brief      Clear Brown-out detector interrupt flag
N  * @param      None
N  * @return     None
N  * @details    This macro clear Brown-out detector interrupt flag.
N  */
N#define SYS_CLEAR_BOD_INT_FLAG()        (SYS->BODCR |= SYS_BODCR_BOD_INTF_Msk)
N
N/**
N  * @brief      Set Brown-out detector function to normal mode
N  * @param      None
N  * @return     None
N  * @details    This macro set Brown-out detector to normal mode.
N  */
N#define SYS_CLEAR_BOD_LPM()             (SYS->BODCR &= ~SYS_BODCR_BOD_LPM_Msk)
N
N/**
N  * @brief      Disable Brown-out detector function
N  * @param      None
N  * @return     None
N  * @details    This macro disable Brown-out detector function.
N  */
N#define SYS_DISABLE_BOD()               (SYS->BODCR &= ~SYS_BODCR_BOD_EN_Msk)
N
N/**
N  * @brief      Enable Brown-out detector function
N  * @param      None
N  * @return     None
N  * @details    This macro enable Brown-out detector function.
N  */
N#define SYS_ENABLE_BOD()                (SYS->BODCR |= SYS_BODCR_BOD_EN_Msk)
N
N/**
N  * @brief      Get Brown-out detector interrupt flag
N  * @param      None
N  * @retval     0   Brown-out detect interrupt flag is not set.
N  * @retval     >=1 Brown-out detect interrupt flag is set.
N  * @details    This macro get Brown-out detector interrupt flag.
N  */
N#define SYS_GET_BOD_INT_FLAG()          (SYS->BODCR & SYS_BODCR_BOD_INTF_Msk)
N
N/**
N  * @brief      Get Brown-out detector status
N  * @param      None
N  * @retval     0   System voltage is higher than BOD_VL setting or BOD_EN is 0.
N  * @retval     >=1 System voltage is lower than BOD_VL setting.
N  * @details    This macro get Brown-out detector output status.
N  *             If the BOD_EN is 0, this function always return 0.
N  */
N#define SYS_GET_BOD_OUTPUT()            (SYS->BODCR & SYS_BODCR_BOD_OUT_Msk)
N
N/**
N  * @brief      Enable Brown-out detector interrupt function
N  * @param      None
N  * @return     None
N  * @details    This macro enable Brown-out detector interrupt function.
N  */
N#define SYS_DISABLE_BOD_RST()           (SYS->BODCR &= ~SYS_BODCR_BOD_RSTEN_Msk)
N
N/**
N  * @brief      Enable Brown-out detector reset function
N  * @param      None
N  * @return     None
N  * @details    This macro enable Brown-out detect reset function.
N  */
N#define SYS_ENABLE_BOD_RST()            (SYS->BODCR |= SYS_BODCR_BOD_RSTEN_Msk)
N
N/**
N  * @brief      Set Brown-out detector function low power mode
N  * @param      None
N  * @return     None
N  * @details    This macro set Brown-out detector to low power mode.
N  */
N#define SYS_SET_BOD_LPM()               (SYS->BODCR |= SYS_BODCR_BOD_LPM_Msk)
N
N/**
N  * @brief      Set Brown-out detector voltage level
N  * @param[in]  u32Level is Brown-out voltage level. Including :
N  *             - \ref SYS_BODCR_BOD_VL_4_4V
N  *             - \ref SYS_BODCR_BOD_VL_3_7V
N  *             - \ref SYS_BODCR_BOD_VL_2_7V
N  *             - \ref SYS_BODCR_BOD_VL_2_2V
N  * @return     None
N  * @details    This macro set Brown-out detector voltage level.
N  */
N#define SYS_SET_BOD_LEVEL(u32Level)     (SYS->BODCR = (SYS->BODCR & ~SYS_BODCR_BOD_VL_Msk) | u32Level)
N
N/**
N  * @brief      Get reset source is from Brown-out detector reset
N  * @param      None
N  * @retval     0   Previous reset source is not from Brown-out detector reset
N  * @retval     >=1 Previous reset source is from Brown-out detector reset
N  * @details    This macro get previous reset source is from Brown-out detect reset or not.
N  */
N#define SYS_IS_BOD_RST()                (SYS->RSTSRC & SYS_RSTSRC_RSTS_BOD_Msk)
N
N/**
N  * @brief      Get reset source is from CPU reset
N  * @param      None
N  * @retval     0   Previous reset source is not from CPU reset
N  * @retval     >=1 Previous reset source is from CPU reset
N  * @details    This macro get previous reset source is from CPU reset.
N  */
N#define SYS_IS_CPU_RST()                (SYS->RSTSRC & SYS_RSTSRC_RSTS_CPU_Msk)
N
N/**
N  * @brief      Get reset source is from Low-Voltage-Reset
N  * @param      None
N  * @retval     0   Previous reset source is not from Low-Voltage-Reset
N  * @retval     >=1 Previous reset source is from Low-Voltage-Reset
N  * @details    This macro get previous reset source is from Low-Voltage-Reset.
N  */
N#define SYS_IS_LVR_RST()                (SYS->RSTSRC & SYS_RSTSRC_RSTS_LVR_Msk)
N
N/**
N  * @brief      Get reset source is from Power-on Reset
N  * @param      None
N  * @retval     0   Previous reset source is not from Power-on Reset
N  * @retval     >=1 Previous reset source is from Power-on Reset
N  * @details    This macro get previous reset source is from Power-on Reset.
N  */
N#define SYS_IS_POR_RST()                (SYS->RSTSRC & SYS_RSTSRC_RSTS_POR_Msk)
N
N/**
N  * @brief      Get reset source is from reset pin reset
N  * @param      None
N  * @retval     0   Previous reset source is not from reset pin reset
N  * @retval     >=1 Previous reset source is from reset pin reset
N  * @details    This macro get previous reset source is from reset pin reset.
N  */
N#define SYS_IS_RSTPIN_RST()             (SYS->RSTSRC & SYS_RSTSRC_RSTS_RESET_Msk)
N
N/**
N  * @brief      Get reset source is from system reset
N  * @param      None
N  * @retval     0   Previous reset source is not from system reset
N  * @retval     >=1 Previous reset source is from system reset
N  * @details    This macro get previous reset source is from system reset.
N  */
N#define SYS_IS_SYSTEM_RST()             (SYS->RSTSRC & SYS_RSTSRC_RSTS_SYS_Msk)
N
N/**
N  * @brief      Get reset source is from window watch dog reset
N  * @param      None
N  * @retval     0   Previous reset source is not from window watch dog reset
N  * @retval     >=1 Previous reset source is from window watch dog reset
N  * @details    This macro get previous reset source is from window watch dog reset.
N  */
N#define SYS_IS_WDT_RST()                (SYS->RSTSRC & SYS_RSTSRC_RSTS_WDT_Msk)
N
N/**
N  * @brief      Disable Low-Voltage-Reset function
N  * @param      None
N  * @return     None
N  * @details    This macro disable Low-Voltage-Reset function.
N  */
N#define SYS_DISABLE_LVR()               (SYS->BODCR &= ~SYS_BODCR_LVR_EN_Msk)
N
N/**
N  * @brief      Enable Low-Voltage-Reset function
N  * @param      None
N  * @return     None
N  * @details    This macro ensable Low-Voltage-Reset function.
N  */
N#define SYS_ENABLE_LVR()                (SYS->BODCR |= SYS_BODCR_LVR_EN_Msk)
N
N/**
N  * @brief      Disable Power-on Reset function
N  * @param      None
N  * @return     None
N  * @details    This macro disable Power-on Reset function.
N  */
N#define SYS_DISABLE_POR()               (SYS->PORCR = 0x5AA5)
N
N/**
N  * @brief      Ensable Power-on Reset function
N  * @param      None
N  * @return     None
N  * @details    This macro enable Power-on Reset function.
N  */
N#define SYS_ENABLE_POR()                (SYS->PORCR = 0)
N
N/**
N  * @brief      Clear reset source flag
N  * @param[in]  u32RstSrc is reset source. Including:
N  *             - \ref SYS_RSTSRC_RSTS_CPU_Msk
N  *             - \ref SYS_RSTSRC_RSTS_SYS_Msk
N  *             - \ref SYS_RSTSRC_RSTS_BOD_Msk
N  *             - \ref SYS_RSTSRC_RSTS_LVR_Msk
N  *             - \ref SYS_RSTSRC_RSTS_WDT_Msk
N  *             - \ref SYS_RSTSRC_RSTS_RESET_Msk
N  *             - \ref SYS_RSTSRC_RSTS_POR_Msk
N  * @return     None
N  * @details    This macro clear reset source flag.
N  */
N#define SYS_CLEAR_RST_SOURCE(u32RstSrc) (SYS->RSTSRC = (u32RstSrc))
N
N
N/**
N  * @brief      Enable register write-protection function
N  * @param      None
N  * @return     None
N  * @details    This function enable register write-protection function.
N  *             To lock the protected register to forbid write access.
N  */
Nstatic __INLINE void SYS_LockReg(void)
Xstatic __inline void SYS_LockReg(void)
N{
N    SYS->REGWRPROT = 0;
X    ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->REGWRPROT = 0;
N}
N
N/**
N  * @brief      Disable register write-protection function
N  * @param      None
N  * @return     None
N  * @details    This function disable register write-protection function.
N  *             To unlock the protected register to allow write access.
N  *
N  */
Nstatic __INLINE void SYS_UnlockReg(void)
Xstatic __inline void SYS_UnlockReg(void)
N{
N    while(SYS->REGWRPROT != SYS_REGWRPROT_REGPROTDIS_Msk)
X    while(((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->REGWRPROT != (1ul << 0))
N    {
N        SYS->REGWRPROT = 0x59;
X        ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->REGWRPROT = 0x59;
N        SYS->REGWRPROT = 0x16;
X        ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->REGWRPROT = 0x16;
N        SYS->REGWRPROT = 0x88;
X        ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->REGWRPROT = 0x88;
N    }
N}
N
N
Nvoid SYS_ClearResetSrc(uint32_t u32Src);
Nuint32_t SYS_GetBODStatus(void);
Nuint32_t SYS_GetResetSrc(void);
Nuint32_t SYS_IsRegLocked(void);
Nuint32_t  SYS_ReadPDID(void);
Nvoid SYS_ResetChip(void);
Nvoid SYS_ResetCPU(void);
Nvoid SYS_ResetModule(uint32_t u32ModuleIndex);
Nvoid SYS_EnableBOD(int32_t i32Mode, uint32_t u32BODLevel);
Nvoid SYS_DisableBOD(void);
N
N
N/*@}*/ /* end of group SYS_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group SYS_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__SYS_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 12443 ".\Libraries\Device\Nuvoton\NUC230_240\Include\NUC230_240.h" 2
N#include "ADC.h"
L 1 ".\Libraries\StdDriver\inc\ADC.h" 1
N/**************************************************************************//**
N * @file     adc.h
N * @version  V3.00
N * $Revision: 4 $
N * $Date: 15/05/06 4:49p $
N * @brief    NUC230_240 Series ADC Driver Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __ADC_H__
N#define __ADC_H__
N
N#include "NUC230_240.h"
L 1 ".\Libraries\Device\Nuvoton\NUC230_240\Include\NUC230_240.h" 1
N/**************************************************************************//**
N * @file     NUC230_240.h
N * @version  V3.0
N * $Revision: 39 $
N * $Date: 15/09/04 3:38p $
N * @brief    NUC230_240 Series Peripheral Access Layer Header File
N *
N * @note
N * Copyright (C) 2015 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N
N
N/**
N  \mainpage Introduction
N  *
N  *
N  * This user manual describes the usage of NUC230_240 Series MCU device driver
N  *
N  * <b>Disclaimer</b>
N  *
N  * The Software is furnished "AS IS", without warranty as to performance or results, and
N  * the entire risk as to performance or results is assumed by YOU. Nuvoton disclaims all
N  * warranties, express, implied or otherwise, with regard to the Software, its use, or
N  * operation, including without limitation any and all warranties of merchantability, fitness
N  * for a particular purpose, and non-infringement of intellectual property rights.
N  *
N  * <b>Copyright Notice</b>
N  *
N  * Copyright (C) 2015 Nuvoton Technology Corp. All rights reserved.
N  */
N
N/**
N  * \page PG_REV Revision History
N  *
N  * <b>Revision 3.01.001</b>
N  * \li Fixed the clock selection bug in SCUART_TxRx() sample code.
N  * \li Fixed the reset handler from __iar_program_start to Reset_Handler.
N  * \li Fixed the bug of clearing wrong enable bit in UART_SelectLINMode() of UART driver.
N  * \li Fixed CAN_STATUS_LEC_Msk from 0x03 to 0x07.
N  * \li Fixed SC_UACTL_UA_MODE_EN_Msk define error from (3ul << SC_UACTL_UA_MODE_EN_Pos) to (1ul << SC_UACTL_UA_MODE_EN_Pos).
N  * \li Fixed the wrong SC1 and SC2 clock source select shift position in MODULE constant definitions.
N  * \li Fixed the wrong definition bug of PS2_DISABLE_OVERRIDE() and PS2_ENABLE_OVERRIDE().
N  * \li Fixed the bug of PS2_Write() in PS2 driver.
N  * \li Removed ReadDID() function from FMC driver as It is no longer supported.
N  * \li Updated USB driver to improve reliability and compatibility.
N  * \li Added NuEdu sample code.
N  * \li Added INT 'MCUIRQ' and 'MCUIRQCR' bit field definitions.
N  * \li Added CLK_EnableSysTick() and CLK_DisableSysTick() to control SysTick and select SysTick clock source.
N  * \li Added SPI_FIFO_SIZE constant definition.
N  * \li Added USB device sample code.
N  * \li Improved USBD driver for adding more USB sample code.
N  *
N  * <b>Revision 3.00.002</b>
N  * \li Fixed the wrong baud rate returned by SCUART_SetLineConfig() in SCUART driver.
N  * \li Fixed SCUART_Open() of SCUART driver for wrong clock calculation and return value.
N  * \li Fixed SC_SET_STOP_BIT_LEN define error.
N  * \li Fixed the bug of ADC_IS_DATA_OVERRUN() that the input parameter is channel number but channel bit mask.
N  * \li Updated CAN clock setting in CAN_Open() of CAN driver to comply with different system clocks.
N  * \li Fixed the wrong return value bug of CLK_SetCoreClock() in CLK driver.
N  * \li Fixed CLK_SetModuleClock() error for PWM clock selection in CLK driver.
N  * \li Fixed the bug of CLK_SysTickDelay() that COUNTFLAG may not be cleared in CLK driver.
N  * \li Fixed the GPIO_ENABLE_DOUT_MASK() and GPIO_DISABLE_DOUT_MASK() implement inverse error in GPIO driver.
N  * \li Fixed the close wrong I2C bug of I2C_Close() in I2C driver.
N  * \li Fixed API declare name from I2C_SetClockBusFreq() to I2C_SetBusClockFreq() in I2C driver.
N  * \li Fixed the clear RS-485 address byte detection flag bug to clear one flag at one time in RS485_HANDLE() of UART driver.
N  * \li Added one more zero packet when BULK IN transfer is end by max packet size packet at last packet in VCOM sample code.
N  * \li Fixed UA_LIN_CTL[4] bit field name as 'MUTE_EN' not 'WAKE_EN' in UART LIN_CTL bit field definitions of header file.
N  * \li Fixed the wrong mask definition of SC_TRSR_TX_POINT_F_Msk and SC_TRSR_RX_POINT_F_Msk in header file.
N  * \li Fixed the wrong bit definition of WAKEUP_EN in USB_INTEN register of header file.
N  * \li Fixed the channel 0 trigger disabled bug when channel 1~3 trigger enabled in PWM_EnableADCTrigger() of PWM driver.
N  * \li Fixed the bug that channel 0 trigger will be disabled when channel 1~3 trigger are enabled in PWM_EnableADCTrigger() of PWM driver.
N  * \li Fixed SCUART_PARITY_NONE/SCUART_PARITY_EVEN/SCUART_PARITY_ODD definition bug in SCUART driver.
N  * \li Fixed four macro definitions of SPI driver to avoid affecting non-target SPI_SS pin including SPI_SET_SS0_HIGH() SPI_SET_SS1_HIGH() SPI_SET_SS0_LOW() SPI_SET_SS1_LOW().
N  * \li Fixed the clear flag bug to clear one flag at one time in UART_ClearIntFlag(). It should be '(uart)->FSR = UART_FSR_RS485_ADD_DETF_Msk' but '(uart)->FSR |= UART_FSR_RS485_ADD_DETF_Msk'.
N  * \li Fixed the clear wrong flag bug in UART_RS485_CLEAR_ADDR_FLAG().
N  * \li Fixed UA_LIN_CTL[4] bit field name as 'MUTE_EN' not 'WAKE_EN' in UA_LIN_CTL constants definitions in UART driver.
N  * \li Added SPI_SET_SS_LEVEL() macro definition in SPI driver to allow user to set both SPI_SS pins.
N  * \li Added a lack macro SYS_IS_LVR_RST() to SYS driver.
N  * 
N  * <b>Revision 3.00.001</b>
N  * \li Updated to support new API
N*/
N
N#ifndef __NUC230_240_H__
S#define __NUC230_240_H__
S
S/*
S * ==========================================================================
S * ---------- Interrupt Number Definition -----------------------------------
S * ==========================================================================
S*/
S
S/** @addtogroup CMSIS Device Definitions for CMSIS
S  Interrupt Number Definition and Configurations for CMSIS
S  @{
S*/
S
S/**
S * @details  Interrupt Number Definition. The maximum of 32 Specific Interrupts are possible.
S */
S
Stypedef enum IRQn {
S    /******  Cortex-M0 Processor Exceptions Numbers ***************************************************/
S    NonMaskableInt_IRQn         = -14,    /*!< 2 Non Maskable Interrupt                             */
S    HardFault_IRQn              = -13,    /*!< 3 Cortex-M0 Hard Fault Interrupt                     */
S    SVCall_IRQn                 = -5,     /*!< 11 Cortex-M0 SV Call Interrupt                       */
S    PendSV_IRQn                 = -2,     /*!< 14 Cortex-M0 Pend SV Interrupt                       */
S    SysTick_IRQn                = -1,     /*!< 15 Cortex-M0 System Tick Interrupt                   */
S
S    /******  ARMIKMCU Swift specific Interrupt Numbers ************************************************/
S    BOD_IRQn                  = 0,        /*!< Brown-Out Low Voltage Detected Interrupt             */
S    WDT_IRQn                  = 1,        /*!< Watch Dog Timer Interrupt                            */
S    EINT0_IRQn                = 2,        /*!< EINT0 Interrupt                                      */
S    EINT1_IRQn                = 3,        /*!< EINT1 Interrupt                                      */
S    GPAB_IRQn                 = 4,        /*!< GPIO_PA/PB Interrupt                                 */
S    GPCDEF_IRQn               = 5,        /*!< GPIO_PC/PD/PE/PF Interrupt                           */
S    PWMA_IRQn                 = 6,        /*!< PWMA Interrupt                                       */
S    PWMB_IRQn                 = 7,        /*!< PWMB Interrupt                                       */
S    TMR0_IRQn                 = 8,        /*!< TIMER0 Interrupt                                     */
S    TMR1_IRQn                 = 9,        /*!< TIMER1 Interrupt                                     */
S    TMR2_IRQn                 = 10,       /*!< TIMER2 Interrupt                                     */
S    TMR3_IRQn                 = 11,       /*!< TIMER3 Interrupt                                     */
S    UART02_IRQn               = 12,       /*!< UART0/UART2 Interrupt                                */
S    UART1_IRQn                = 13,       /*!< UART1 Interrupt                                      */
S    SPI0_IRQn                 = 14,       /*!< SPI0 Interrupt                                       */
S    SPI1_IRQn                 = 15,       /*!< SPI1 Interrupt                                       */
S    SPI2_IRQn                 = 16,       /*!< SPI2 Interrupt                                       */
S    SPI3_IRQn                 = 17,       /*!< SPI3 Interrupt                                       */
S    I2C0_IRQn                 = 18,       /*!< I2C0 Interrupt                                       */
S    I2C1_IRQn                 = 19,       /*!< I2C1 Interrupt                                       */
S    CAN0_IRQn                 = 20,       /*!< CAN0 Interrupt                                       */
S    CAN1_IRQn                 = 21,       /*!< CAN1 Interrupt                                       */
S    SC012_IRQn                = 22,       /*!< SC0/SC1/SC2 Interrupt                                */
S    USBD_IRQn                 = 23,       /*!< USB device Interrupt                                 */
S    PS2_IRQn                  = 24,       /*!< PS/2 device Interrupt                                */
S    ACMP_IRQn                 = 25,       /*!< ACMP0 Interrupt                                      */
S    PDMA_IRQn                 = 26,       /*!< PDMA Interrupt                                       */
S    I2S_IRQn                  = 27,       /*!< I2S Interrupt                                        */
S    PWRWU_IRQn                = 28,       /*!< Power Down Wake Up Interrupt                         */
S    ADC_IRQn                  = 29,       /*!< ADC Interrupt                                        */
S    IRC_IRQn                  = 30,       /*!< IRC TRIM Interrupt                                   */
S    RTC_IRQn                  = 31        /*!< RTC Interrupt                                        */
S} IRQn_Type;
S
S
S/*
S * ==========================================================================
S * ----------- Processor and Core Peripheral Section ------------------------
S * ==========================================================================
S */
S
S/* Configuration of the Cortex-M0 Processor and Core Peripherals */
S#define __MPU_PRESENT           0       /*!< armikcmu does not provide a MPU present or not       */
S#define __NVIC_PRIO_BITS        2       /*!< armikcmu Supports 2 Bits for the Priority Levels     */
S#define __Vendor_SysTickConfig  0       /*!< Set to 1 if different SysTick Config is used         */
S
S
S/*@}*/ /* end of group CMSIS */
S
S
S#include "core_cm0.h"                   /* Cortex-M0 processor and core peripherals               */
S#include "system_NUC230_240.h"          /* System                                                 */
S
S#if defined ( __CC_ARM   )
S#pragma anon_unions
S#endif
S
S
S/*-------------------------------- Device Specific Peripheral registers structures ---------------------*/
S/** @addtogroup REGISTER Control Register
S  Peripheral Control Registers
S  @{
S */
S
S
S
S
S/*---------------------- Analog Comparator Controller -------------------------*/
S/**
S    @addtogroup ACMP Analog Comparator Controller (ACMP)
S    Memory Mapped Structure for ACMP Controller
S@{ */
S
S
Stypedef struct
S{
S
S
S/**
S * @var ACMP_T::CMPCR
S * Offset: 0x00~0x04  Analog Comparator Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |CMPEN     |Comparator Enable
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |[1]     |CMPIE     |Comparator Interrupt Enable
S * |        |          |0 = Interrupt function
S * |        |          |Disabled.
S * |        |          |1 = Interrupt function
S * |        |          |Enabled.
S * |[2]     |CMP_HYSEN |Comparator Hysteresis Enable
S * |        |          |0 = Hysteresis function Disabled (Default).
S * |        |          |1 = Hysteresis function
S * |        |          |Enabled.
S * |[4]     |CMPCN     |Comparator Negative Input Selection
S * |        |          |0 = The source of the negative comparator input is from ACMPn_N pin (n = 0, 1).
S * |        |          |1 = Internal band-gap reference voltage is selected as the source
S * |        |          |    of negative comparator input.
S * |[6]     |CMPINV    |Comparator Output Inverse Enable
S * |        |          |0 = Comparator analog output inverse is Disabled.
S * |        |          |1 = Comparator analog output inverse is Enabled.
S * @var ACMP_T::CMPSR
S * Offset: 0x08  Analog Comparator Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |CMPF0     |Comparator 0 Interrupt Flag
S * |        |          |This bit is set by hardware whenever the comparator 0 output changes state.
S * |        |          |This will cause an interrupt if CMPCR0[1] is set to 1.
S * |        |          |Write 1 to clear this bit to 0.
S * |[1]     |CMPF1     |Comparator 1 Interrupt Flag
S * |        |          |This bit is set by hardware whenever the comparator 1 output changes state.
S * |        |          |This will cause an interrupt if CMPCR1[1] is set to 1.
S * |        |          |Write 1 to clear this bit to 0.
S * |[2]     |CO0       |Comparator 0 Output
S * |        |          |Synchronized to the APB clock to allow reading by software.
S * |        |          |Cleared when the comparator 0 is disabled (CMPCR0[0] = 0).
S * |[3]     |CO1       |Comparator 1 Output
S * |        |          |Synchronized to the APB clock to allow reading by software.
S * |        |          |Cleared when the comparator 1 is disabled (CMPCR1[0] = 0).
S */
S
S    __IO uint32_t CMPCR[2];      /* Offset: 0x00  Analog Comparator 0 Control Register                               */
S    __IO uint32_t CMPSR;         /* Offset: 0x04  Analog Comparator 1 Control Register                               */
S
S} ACMP_T;
S
S
S/**
S    @addtogroup ACMP_CONST ACMP Bit Field Definition
S    Constant Definitions for ACMP Controller
S@{ */
S
S
S
S/* CMPCR Bit Field Definitions */
S#define ACMP_CMPCR_CMPINV_Pos      6                                   /*!< ACMP_T::CMPCR: CMPINV Position */
S#define ACMP_CMPCR_CMPINV_Msk      (1ul << ACMP_CMPCR_CMPINV_Pos)      /*!< ACMP_T::CMPCR: CMPINV Mask */
S
S#define ACMP_CMPCR_CMPCN_Pos       4                                   /*!< ACMP_T::CMPCR: CMPCN Position */
S#define ACMP_CMPCR_CMPCN_Msk       (1ul << ACMP_CMPCR_CMPCN_Pos)       /*!< ACMP_T::CMPCR: CMPCN Mask */
S
S#define ACMP_CMPCR_CMP_HYSEN_Pos   2                                   /*!< ACMP_T::CMPCR: CMP_HYSEN Position */
S#define ACMP_CMPCR_CMP_HYSEN_Msk   (1ul << ACMP_CMPCR_CMP_HYSEN_Pos)   /*!< ACMP_T::CMPCR: CMP_HYSEN Mask */
S
S#define ACMP_CMPCR_CMPIE_Pos       1                                   /*!< ACMP_T::CMPCR: CMPIE Position */
S#define ACMP_CMPCR_CMPIE_Msk       (1ul << ACMP_CMPCR_CMPIE_Pos)       /*!< ACMP_T::CMPCR: CMPIE Mask */
S
S#define ACMP_CMPCR_CMPEN_Pos       0                                   /*!< ACMP_T::CMPCR: CMPEN Position */
S#define ACMP_CMPCR_CMPEN_Msk       (1ul << ACMP_CMPCR_CMPEN_Pos)       /*!< ACMP_T::CMPCR: CMPEN Mask */
S
S/* CMPSR Bit Field Definitions */
S#define ACMP_CMPSR_CO1_Pos     3                                 /*!< ACMP_T::CMPSR: CO1 Position */
S#define ACMP_CMPSR_CO1_Msk     (1ul << ACMP_CMPSR_CO1_Pos)       /*!< ACMP_T::CMPSR: CO1 Mask */
S
S#define ACMP_CMPSR_CO0_Pos     2                                 /*!< ACMP_T::CMPSR: CO0 Position */
S#define ACMP_CMPSR_CO0_Msk     (1ul << ACMP_CMPSR_CO0_Pos)       /*!< ACMP_T::CMPSR: CO0 Mask */
S
S#define ACMP_CMPSR_CMPF1_Pos   1                                 /*!< ACMP_T::CMPSR: CMPF1 Position */
S#define ACMP_CMPSR_CMPF1_Msk   (1ul << ACMP_CMPSR_CMPF1_Pos)     /*!< ACMP_T::CMPSR: CMPF1 Mask */
S
S#define ACMP_CMPSR_CMPF0_Pos   0                                 /*!< ACMP_T::CMPSR: CMPF0 Position */
S#define ACMP_CMPSR_CMPF0_Msk   (1ul << ACMP_CMPSR_CMPF0_Pos)     /*!< ACMP_T::CMPSR: CMPF0 Mask */
S/*@}*/ /* end of group ACMP_CONST */
S/*@}*/ /* end of group ACMP */
S
S
S
S/*----------------------------- ADC Controller -------------------------------*/
S/** @addtogroup ADC Analog to Digital Converter (ADC)
S  Memory Mapped Structure for ADC Controller
S  @{
S */
S
S
Stypedef struct
S{
S
S/**
S * @var ADC_T::ADDR
S * Offset: 0x00-0x1C  ADC Data Register  
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |RSLT      |A/D Conversion Result
S * |        |          |This field contains conversion result of ADC.
S * |        |          |When DMOF bit (ADCR[31]) set to 0, 12-bit ADC conversion result with unsigned format will be
S * |        |          |filled in RSLT (ADDRx[11:0], x=0~7) and zero will be filled in RSLT (ADDRx[15:12], x=0~7).
S * |        |          |When DMOF bit (ADCR[31]) set to 1, 12-bit ADC conversion result with 2'complement format will be
S * |        |          |filled in RSLT(ADDRx[11:0], x=0~7) and signed bits to will be filled in RSLT (ADDRx[15:12],
S * |        |          |x=0~7).
S * |[16]    |OVERRUN   |Overrun Flag
S * |        |          |0 = Data in RSLT (ADDRx[15:0], x=0~7) is recent conversion result.
S * |        |          |1 = Data in RSLT (ADDRx[15:0], x=0~7) is overwritten.
S * |        |          |If converted data in RSLT has not been read before new conversion result is loaded to this
S * |        |          |register, OVERRUN is set to 1 and previous conversion result is gone.
S * |        |          |It is cleared by hardware after ADDR register is read.
S * |        |          |This is a read only bit.
S * |[17]    |VALID     |Valid Flag
S * |        |          |0 = Data in RSLT bits (ADDRx[15:0], x=0~7) is not valid.
S * |        |          |1 = Data in RSLT bits (ADDRx[15:0], x=0~7) is valid.
S * |        |          |This bit is set to 1 when corresponding channel analog input conversion is completed and cleared
S * |        |          |by hardware after ADDR register is read.
S * |        |          |This is a read only bit
S * @var ADC_T::ADCR
S * Offset: 0x20  ADC Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |ADEN      |A/D Converter Enable
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |        |          |Before starting A/D conversion function, this bit should be set to 1.
S * |        |          |Clear it to 0 to disable A/D converter analog circuit for saving power consumption.
S * |[1]     |ADIE      |A/D Interrupt Enable
S * |        |          |0 = A/D interrupt function Disabled.
S * |        |          |1 = A/D interrupt function Enabled.
S * |        |          |A/D conversion end interrupt request is generated if ADIE bit (ADCR[1]) is set to 1.
S * |[3:2]   |ADMD      |A/D Converter Operation Mode
S * |        |          |00 = Single conversion.
S * |        |          |01 = Reserved.
S * |        |          |10 = Single-cycle scan.
S * |        |          |11 = Continuous scan.
S * |        |          |When changing the operation mode, software should disable ADST bit (ADCR[11]) firstly.
S * |[5:4]   |TRGS      |Hardware Trigger Source
S * |        |          |00 = A/D conversion is started by external STADC pin.
S * |        |          |11 = A/D conversion is started by PWM Center-aligned trigger.
S * |        |          |Others = Reserved.
S * |        |          |Software should disable TRGEN (ADCR[8]) and ADST (ADCR[11]) before change TRGS.
S * |[7:6]   |TRGCOND   |External Trigger Condition
S * |        |          |These two bits decide external pin STADC trigger event is level or edge.
S * |        |          |The signal must be kept at stable state at least 8 PCLKs for level trigger and 4 PCLKs at high
S * |        |          |and low state for edge trigger.
S * |        |          |00 = Low level.
S * |        |          |01 = High level.
S * |        |          |10 = Falling edge.
S * |        |          |11 = Rising edge.
S * |[8]     |TRGEN     |Hardware Trigger Enable
S * |        |          |Enable or disable triggering of A/D conversion by hardware (external STADC pin or PWM
S * |        |          |Center-aligned trigger).
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |        |          |ADC hardware trigger function is only supported in single-cycle scan mode.
S * |        |          |If hardware trigger mode, the ADST bit (ADCR[11]) can be set to 1 by the selected hardware
S * |        |          |trigger source.
S * |[9]     |PTEN      |PDMA Transfer Enable
S * |        |          |0 = PDMA data transfer Disabled.
S * |        |          |1 = PDMA data transfer in ADDR 0~7 Enabled.
S * |        |          |When A/D conversion is completed, the converted data is loaded into ADDR 0~7, software can
S * |        |          |enable this bit to generate a PDMA data transfer request.
S * |        |          |When PTEN=1, software must set ADIE=0 (ADCR[1]) to disable interrupt.
S * |[10]    |DIFFEN    |Differential Input Mode Enable
S * |        |          |0 = Single-end analog input mode.
S * |        |          |1 = Differential analog input mode.
S * |        |          |Differential   input Paired Channel
S * |        |          |Differential input voltage (Vdiff) = Vplus - Vminus, where Vplus
S * |        |          |is the analog input; Vminus is the inverted analog input.
S * |        |          |In differential input mode, only the even number of the two corresponding channels needs to be
S * |        |          |enabled in ADCHER.
S * |        |          |The conversion result will be placed to the corresponding data register of the enabled channel.
S * |[11]    |ADST      |A/D Conversion Start
S * |        |          |0 = Conversion stops and A/D converter enter idle state.
S * |        |          |1 = Conversion starts.
S * |        |          |ADST bit can be set to 1 from three sources: software, PWM Center-aligned trigger and external
S * |        |          |pin STADC.
S * |        |          |ADST will be cleared to 0 by hardware automatically at the ends of single mode and single-cycle
S * |        |          |scan mode.
S * |        |          |In continuous scan mode, A/D conversion is continuously performed until software writes 0 to
S * |        |          |this bit or chip reset.
S * |[31]    |DMOF      |A/D Differential Input Mode Output Format
S * |        |          |0 = A/D Conversion result will be filled in RSLT at ADDRx registers with unsigned format.
S * |        |          |1 = A/D Conversion result will be filled in RSLT at ADDRx registers with 2'complement format.
S * @var ADC_T::ADCHER
S * Offset: 0x24  ADC Channel Enable Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |CHEN      |Analog Input Channel Enable
S * |        |          |Set CHEN[7:0] to enable the corresponding analog input channel 7 ~ 0.
S * |        |          |If DIFFEN bit (ADCR[10]) is set to 1, only the even number channels need to be enabled.
S * |        |          |0 = ADC input channel Disabled.
S * |        |          |1 = ADC input channel Enabled.
S * |[9:8]   |PRESEL    |Analog Input Channel 7 Select
S * |        |          |00 = External analog input.
S * |        |          |01 = Internal band-gap voltage.
S * |        |          |10 = Internal temperature sensor.
S * |        |          |11 = Reserved.
S * |        |          |Note:
S * |        |          |When software select the band-gap voltage as the analog input source of ADC channel 7, ADC clock
S * |        |          |rate needs to be limited to slower than 300 kHz.
S * @var ADC_T::ADCMPR
S * Offset: 0x28  ADC Compare Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |CMPEN     |Compare Enable
S * |        |          |0 = Compare function Disabled.
S * |        |          |1 = Compare function Enabled.
S * |        |          |Set this bit to 1 to enable ADC controller to compare CMPD (ADCMPR0/1[27:16]) with specified
S * |        |          |channel conversion result when converted data is loaded into ADDR register.
S * |[1]     |CMPIE     |Compare Interrupt Enable
S * |        |          |0 = Compare function interrupt Disabled.
S * |        |          |1 = Compare function interrupt Enabled.
S * |        |          |If the compare function is enabled and the compare condition matches the setting of CMPCOND
S * |        |          |(ADCMPR0/1[2]) and CMPMATCNT (ADCMPR0/1[11:8]), CMPF0/1 bit (ADSR[1]/[2]) will be asserted, in
S * |        |          |the meanwhile, if CMPIE (ADCMPR0/1[1]) is set to 1, a compare interrupt request is generated.
S * |[2]     |CMPCOND   |Compare Condition
S * |        |          |0 = Set the compare condition as that when a 12-bit A/D conversion result is less than the
S * |        |          |12-bit CMPD (ADCMPR0/1[27:16]), the internal match counter will increase one.
S * |        |          |1 = Set the compare condition as that when a 12-bit A/D conversion result is greater or equal to
S * |        |          |the 12-bit CMPD (ADCMPR0/1[27:16]), the internal match counter will increase one.
S * |        |          |Note: When the internal counter reaches the value to (CMPMATCNT (ADCMPR0/1[11:8])+1), the
S * |        |          |CMPF0/1 bit (ADSR[1]/[2]) will be set.
S * |[5:3]   |CMPCH     |Compare Channel Selection
S * |        |          |000 = Channel 0 conversion result is selected to be compared.
S * |        |          |001 = Channel 1 conversion result is selected to be compared.
S * |        |          |010 = Channel 2 conversion result is selected to be compared.
S * |        |          |011 = Channel 3 conversion result is selected to be compared.
S * |        |          |100 = Channel 4 conversion result is selected to be compared.
S * |        |          |101 = Channel 5 conversion result is selected to be compared.
S * |        |          |110 = Channel 6 conversion result is selected to be compared.
S * |        |          |111 = Channel 7 conversion result is selected to be compared.
S * |[11:8]  |CMPMATCNT |Compare Match Count
S * |        |          |When the specified A/D channel analog conversion result matches the compare condition defined by
S * |        |          |CMPCOND (ADCMPR0/1[2]), the internal match counter will increase 1.
S * |        |          |When the internal counter reaches the value to (CMPMATCNT (ADCMPR0/1[11:8]) +1), the CMPF0/1 bit
S * |        |          |(ADSR[1]/[2]) will be set.
S * |[27:16] |CMPD      |Comparison Data
S * |        |          |The 12-bit data is used to compare with conversion result of specified channel.
S * |        |          |When DMOF bit (ADCR[31]) is set to 0, ADC comparator compares CMPD with conversion result with
S * |        |          |unsigned format.
S * |        |          |CMPD should be filled in unsigned format.
S * |        |          |When DMOF bit (ADCR[31]) is set to 1, ADC comparator compares CMPD with conversion result with
S * |        |          |2'complement format.
S * |        |          |CMPD should be filled in 2'complement format.
S * @var ADC_T::ADSR
S * Offset: 0x30  ADC Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |ADF       |A/D Conversion End Flag
S * |        |          |A status flag that indicates the end of A/D conversion.
S * |        |          |ADF is set to 1 at these two conditions:
S * |        |          |1. When A/D conversion ends in Single mode.
S * |        |          |2. When A/D conversion ends on all specified channels in Scan mode.
S * |        |          |This flag can be cleared by writing 1 to itself.
S * |[1]     |CMPF0     |Compare Flag
S * |        |          |When the selected channel A/D conversion result meets setting condition in ADCMPR0 then this bit
S * |        |          |is set to 1.
S * |        |          |And it is cleared by writing 1 to self.
S * |        |          |0 = Conversion result in ADDR does not meet ADCMPR0 setting.
S * |        |          |1 = Conversion result in ADDR meets ADCMPR0 setting.
S * |[2]     |CMPF1     |Compare Flag
S * |        |          |When the selected channel A/D conversion result meets setting condition in ADCMPR1 then this bit
S * |        |          |is set to 1.
S * |        |          |And it is cleared by writing 1 to self.
S * |        |          |0 = Conversion result in ADDR does not meet ADCMPR1 setting.
S * |        |          |1 = Conversion result in ADDR meets ADCMPR1 setting.
S * |[3]     |BUSY      |BUSY/IDLE
S * |        |          |0 = A/D converter is in idle state.
S * |        |          |1 = A/D converter is busy at conversion.
S * |        |          |This bit is mirror of as ADST bit (ADCR[11]).
S * |        |          |It is read only.
S * |[6:4]   |CHANNEL   |Current Conversion Channel
S * |        |          |This field reflects the current conversion channel when BUSY = 1 (ADSR[3]).
S * |        |          |When BUSY = 0, it shows the number of the next converted channel.
S * |        |          |It is read only.
S * |[15:8]  |VALID     |Data Valid Flag
S * |        |          |It is a mirror of VALID bit (ADDR0~7[17]).
S * |        |          |It is read only.
S * |[23:16] |OVERRUN   |Overrun Flag
S * |        |          |It is a mirror to OVERRUN bit (ADDR0~7[16]).
S * |        |          |It is read only.
S * @var ADC_T::ADPDMA
S * Offset: 0x40  ADC PDMA Current Transfer Data Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[17:0]  |AD_PDMA   |ADC PDMA Current Transfer Data Register
S * |        |          |When PDMA transferring, read this register can monitor current PDMA transfer data.
S * |        |          |Current PDMA transfer data is the content of ADDR0 ~ ADDR7.
S * |        |          |This is a read only register.
S */
S
S    __I  uint32_t ADDR[8];       /* Offset: 0x00-0x1C  ADC Data Register                                             */
S    __IO uint32_t ADCR;          /* Offset: 0x20  ADC Control Register                                               */
S    __IO uint32_t ADCHER;        /* Offset: 0x24  ADC Channel Enable Register                                        */
S    __IO uint32_t ADCMPR[2];     /* Offset: 0x28  ADC Compare Register                                               */
S    __IO uint32_t ADSR;          /* Offset: 0x30  ADC Status Register                                                */
S    __I  uint32_t RESERVE0[3];  
S    __I  uint32_t ADPDMA;        /* Offset: 0x40  ADC PDMA Current Transfer Data Register                            */
S
S} ADC_T;
S
S
S/**
S    @addtogroup ADC_CONST ADC Bit Field Definition
S    Constant Definitions for ADC Controller
S@{ */
S
S
S
S/* ADDR Bit Field Definitions */
S#define ADC_ADDR_VALID_Pos      17                                /*!< ADC_T::ADDR: VALID Position */
S#define ADC_ADDR_VALID_Msk      (1ul << ADC_ADDR_VALID_Pos)       /*!< ADC_T::ADDR: VALID Mask */
S
S#define ADC_ADDR_OVERRUN_Pos    16                                /*!< ADC_T::ADDR: OVERRUN Position */
S#define ADC_ADDR_OVERRUN_Msk    (1ul << ADC_ADDR_OVERRUN_Pos)     /*!< ADC_T::ADDR: OVERRUN Mask */
S
S#define ADC_ADDR_RSLT_Pos       0                                 /*!< ADC_T::ADDR: RSLT Position */
S#define ADC_ADDR_RSLT_Msk       (0xFFFFul << ADC_ADDR_RSLT_Pos)   /*!< ADC_T::ADDR: RSLT Mask */
S
S/* ADCR Bit Field Definitions */
S#define ADC_ADCR_DMOF_Pos       31                                /*!< ADC_T::ADCR: DMOF Position */
S#define ADC_ADCR_DMOF_Msk       (1ul << ADC_ADCR_DMOF_Pos)        /*!< ADC_T::ADCR: DMOF Mask */
S
S#define ADC_ADCR_ADST_Pos       11                                /*!< ADC_T::ADCR: ADST Position */
S#define ADC_ADCR_ADST_Msk       (1ul << ADC_ADCR_ADST_Pos)        /*!< ADC_T::ADCR: ADST Mask */
S
S#define ADC_ADCR_DIFFEN_Pos     10                                /*!< ADC_T::ADCR: DIFFEN Position */
S#define ADC_ADCR_DIFFEN_Msk     (1ul << ADC_ADCR_DIFFEN_Pos)      /*!< ADC_T::ADCR: DIFFEN Mask */
S
S#define ADC_ADCR_PTEN_Pos       9                                 /*!< ADC_T::ADCR: PTEN Position */
S#define ADC_ADCR_PTEN_Msk       (1ul << ADC_ADCR_PTEN_Pos)        /*!< ADC_T::ADCR: PTEN Mask */
S
S#define ADC_ADCR_TRGEN_Pos      8                                 /*!< ADC_T::ADCR: TRGEN Position */
S#define ADC_ADCR_TRGEN_Msk      (1ul << ADC_ADCR_TRGEN_Pos)       /*!< ADC_T::ADCR: TRGEN Mask */
S
S#define ADC_ADCR_TRGCOND_Pos    6                                 /*!< ADC_T::ADCR: TRGCOND Position */
S#define ADC_ADCR_TRGCOND_Msk    (3ul << ADC_ADCR_TRGCOND_Pos)     /*!< ADC_T::ADCR: TRGCOND Mask */
S
S#define ADC_ADCR_TRGS_Pos       4                                 /*!< ADC_T::ADCR: TRGS Position */
S#define ADC_ADCR_TRGS_Msk       (3ul << ADC_ADCR_TRGS_Pos)        /*!< ADC_T::ADCR: TRGS Mask */
S
S#define ADC_ADCR_ADMD_Pos       2                                 /*!< ADC_T::ADCR: ADMD Position */
S#define ADC_ADCR_ADMD_Msk       (3ul << ADC_ADCR_ADMD_Pos)        /*!< ADC_T::ADCR: ADMD Mask */
S
S#define ADC_ADCR_ADIE_Pos       1                                 /*!< ADC_T::ADCR: ADIE Position */
S#define ADC_ADCR_ADIE_Msk       (1ul << ADC_ADCR_ADIE_Pos)        /*!< ADC_T::ADCR: ADIE Mask */
S
S#define ADC_ADCR_ADEN_Pos       0                                 /*!< ADC_T::ADCR: ADEN Position */
S#define ADC_ADCR_ADEN_Msk       (1ul << ADC_ADCR_ADEN_Pos)        /*!< ADC_T::ADCR: ADEN Mask */
S
S/* ADCHER Bit Field Definitions */
S#define ADC_ADCHER_PRESEL_Pos   8                                 /*!< ADC_T::ADCHER: PRESEL Position */
S#define ADC_ADCHER_PRESEL_Msk   (3ul << ADC_ADCHER_PRESEL_Pos)    /*!< ADC_T::ADCHER: PRESEL Mask */
S
S#define ADC_ADCHER_CHEN_Pos     0                                 /*!< ADC_T::ADCHER: CHEN Position */
S#define ADC_ADCHER_CHEN_Msk     (0xFFul << ADC_ADCHER_CHEN_Pos)   /*!< ADC_T::ADCHER: CHEN Mask */
S
S/* ADCMPR Bit Field Definitions */
S#define ADC_ADCMPR_CMPD_Pos        16                                    /*!< ADC_T::ADCMPR: CMPD Position */
S#define ADC_ADCMPR_CMPD_Msk        (0xFFFul << ADC_ADCMPR_CMPD_Pos)      /*!< ADC_T::ADCMPR: CMPD Mask */
S
S#define ADC_ADCMPR_CMPMATCNT_Pos   8                                     /*!< ADC_T::ADCMPR: CMPMATCNT Position */
S#define ADC_ADCMPR_CMPMATCNT_Msk   (0xFul << ADC_ADCMPR_CMPMATCNT_Pos)   /*!< ADC_T::ADCMPR: CMPMATCNT Mask */
S
S#define ADC_ADCMPR_CMPCH_Pos       3                                     /*!< ADC_T::ADCMPR: CMPCH Position */
S#define ADC_ADCMPR_CMPCH_Msk       (7ul << ADC_ADCMPR_CMPCH_Pos)         /*!< ADC_T::ADCMPR: CMPCH Mask */
S
S#define ADC_ADCMPR_CMPCOND_Pos     2                                     /*!< ADC_T::ADCMPR: CMPCOND Position */
S#define ADC_ADCMPR_CMPCOND_Msk     (1ul << ADC_ADCMPR_CMPCOND_Pos)       /*!< ADC_T::ADCMPR: CMPCOND Mask */
S
S#define ADC_ADCMPR_CMPIE_Pos       1                                     /*!< ADC_T::ADCMPR: CMPIE Position */
S#define ADC_ADCMPR_CMPIE_Msk       (1ul << ADC_ADCMPR_CMPIE_Pos)         /*!< ADC_T::ADCMPR: CMPIE Mask */
S
S#define ADC_ADCMPR_CMPEN_Pos       0                                     /*!< ADC_T::ADCMPR: CMPEN Position */
S#define ADC_ADCMPR_CMPEN_Msk       (1ul << ADC_ADCMPR_CMPEN_Pos)         /*!< ADC_T::ADCMPR: CMPEN Mask */
S
S/* ADSR Bit Field Definitions */
S#define ADC_ADSR_OVERRUN_Pos       16                                    /*!< ADC_T::ADSR: OVERRUN Position */
S#define ADC_ADSR_OVERRUN_Msk       (0xFFul << ADC_ADSR_OVERRUN_Pos)      /*!< ADC_T::ADSR: OVERRUN Mask */
S
S#define ADC_ADSR_VALID_Pos         8                                     /*!< ADC_T::ADSR: VALID Position */
S#define ADC_ADSR_VALID_Msk         (0xFFul << ADC_ADSR_VALID_Pos)        /*!< ADC_T::ADSR: VALID Mask */
S
S#define ADC_ADSR_CHANNEL_Pos       4                                     /*!< ADC_T::ADSR: CHANNEL Position */
S#define ADC_ADSR_CHANNEL_Msk       (7ul << ADC_ADSR_CHANNEL_Pos)         /*!< ADC_T::ADSR: CHANNEL Mask */
S
S#define ADC_ADSR_BUSY_Pos          3                                     /*!< ADC_T::ADSR: BUSY Position */
S#define ADC_ADSR_BUSY_Msk          (1ul << ADC_ADSR_BUSY_Pos)            /*!< ADC_T::ADSR: BUSY Mask */
S
S#define ADC_ADSR_CMPF1_Pos         2                                     /*!< ADC_T::ADSR: CMPF1 Position */
S#define ADC_ADSR_CMPF1_Msk         (1ul << ADC_ADSR_CMPF1_Pos)           /*!< ADC_T::ADSR: CMPF1 Mask */
S
S#define ADC_ADSR_CMPF0_Pos         1                                     /*!< ADC_T::ADSR: CMPF0 Position */
S#define ADC_ADSR_CMPF0_Msk         (1ul << ADC_ADSR_CMPF0_Pos)           /*!< ADC_T::ADSR: CMPF0 Mask */
S
S#define ADC_ADSR_ADF_Pos           0                                     /*!< ADC_T::ADSR: ADF Position */
S#define ADC_ADSR_ADF_Msk           (1ul << ADC_ADSR_ADF_Pos)             /*!< ADC_T::ADSR: ADF Mask */
S
S/* ADPDMA Bit Field Definitions */
S#define ADC_ADPDMA_AD_PDMA_Pos     0                                     /*!< ADC_T::ADPDMA: AD_PDMA Position */
S#define ADC_ADPDMA_AD_PDMA_Msk     (0x3FFFFul << ADC_ADPDMA_AD_PDMA_Pos) /*!< ADC_T::ADPDMA: AD_PDMA Mask */
S/*@}*/ /* end of group ADC_CONST */
S/*@}*/ /* end of group ADC */
S
S
S
S/*----------------------------- CAN Controller ------------------------------*/
S/** @addtogroup CAN Controller Area Network (CAN)
S  Register Structure for CAN Device Controller
S  @{
S */
S
S
S
Stypedef struct
S{
S
S
S
S/**
S * @var CAN_IF_T::CREQ
S * Offset: 0x20, 0x80  IFn (Register Map Note 2) Command Request Registers
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[5:0]   |MessageNumber|Message Number
S * |        |          |0x01-0x20: Valid Message Number, the Message Object in the Message
S * |        |          |RAM is selected for data transfer.
S * |        |          |0x00: Not a valid Message Number, interpreted as 0x20.
S * |        |          |0x21-0x3F: Not a valid Message Number, interpreted as 0x01-0x1F.
S * |[15]    |Busy      |Busy Flag
S * |        |          |0 = Read/write action has finished.
S * |        |          |1 = Writing to the IFn Command Request Register is in progress.
S * |        |          |This bit can only be read by the software.
S * @var CAN_IF_T::CMASK
S * Offset: 0x24, 0x84  IFn Command Mask Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |DAT_B     |Access Data Bytes [7:4]
S * |        |          |Write Operation:
S * |        |          |0 = Data Bytes [7:4] unchanged.
S * |        |          |1 = Transfer Data Bytes [7:4] to Message Object.
S * |        |          |Read Operation:
S * |        |          |0 = Data Bytes [7:4] unchanged.
S * |        |          |1 = Transfer Data Bytes [7:4] to IFn Message Buffer Register.
S * |[1]     |DAT_A     |Access Data Bytes [3:0]
S * |        |          |Write Operation:
S * |        |          |0 = Data Bytes [3:0] unchanged.
S * |        |          |1 = Transfer Data Bytes [3:0] to Message Object.
S * |        |          |Read Operation:
S * |        |          |0 = Data Bytes [3:0] unchanged.
S * |        |          |1 = Transfer Data Bytes [3:0] to IFn Message Buffer Register.
S * |[2]     |TxRqst_NewDat|Access Transmission Request Bit When Write Operation
S * |        |          |0 = TxRqst bit unchanged.
S * |        |          |1 = Set TxRqst bit.
S * |        |          |Note: If a transmission is requested by programming bit TxRqst/NewDat in the IFn Command Mask
S * |        |          |Register, bit TxRqst in the IFn Message Control Register will be ignored.
S * |        |          |Access New Data Bit when Read Operation.
S * |        |          |0 = NewDat bit remains unchanged.
S * |        |          |1 = Clear NewDat bit in the Message Object.
S * |        |          |Note: A read access to a Message Object can be combined with the reset of the control bits
S * |        |          |IntPnd and NewDat.
S * |        |          |The values of these bits transferred to the IFn Message Control Register always reflect the
S * |        |          |status before resetting these bits.
S * |[3]     |ClrIntPnd |Clear Interrupt Pending Bit
S * |        |          |Write Operation:
S * |        |          |When writing to a Message Object, this bit is ignored.
S * |        |          |Read Operation:
S * |        |          |0 = IntPnd bit (CAN_IFn_MCON[13]) remains unchanged.
S * |        |          |1 = Clear IntPnd bit in the Message Object.
S * |[4]     |Control   |Control Access Control Bits
S * |        |          |Write Operation:
S * |        |          |0 = Control Bits unchanged.
S * |        |          |1 = Transfer Control Bits to Message Object.
S * |        |          |Read Operation:
S * |        |          |0 = Control Bits unchanged.
S * |        |          |1 = Transfer Control Bits to IFn Message Buffer Register.
S * |[5]     |Arb       |Access Arbitration Bits
S * |        |          |Write Operation:
S * |        |          |0 = Arbitration bits unchanged.
S * |        |          |1 = Transfer Identifier + Dir (CAN_IFn_ARB2[13]) + Xtd (CAN_IFn_ARB2[14]) + MsgVal
S * |        |          |(CAN_IFn_APB2[15]) to Message Object.
S * |        |          |Read Operation:
S * |        |          |0 = Arbitration bits unchanged.
S * |        |          |1 = Transfer Identifier + Dir + Xtd + MsgVal to IFn Message Buffer Register.
S * |[6]     |Mask      |Access Mask Bits
S * |        |          |Write Operation:
S * |        |          |0 = Mask bits unchanged.
S * |        |          |1 = Transfer Identifier Mask + MDir + MXtd to Message Object.
S * |        |          |Read Operation:
S * |        |          |0 = Mask bits unchanged.
S * |        |          |1 = Transfer Identifier Mask + MDir + MXtd to IFn Message Buffer Register.
S * |[7]     |WR_RD     |Write / Read Mode
S * |        |          |0 = Read: Transfer data from the Message Object addressed by the Command Request Register into
S * |        |          |the selected Message Buffer Registers.
S * |        |          |1 = Write: Transfer data from the selected Message Buffer Registers to the Message Object
S * |        |          |addressed by the Command Request Register.
S * @var CAN_IF_T::MASK1
S * Offset: 0x28, 0x88  IFn Mask 1 Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |Msk[15:0] |Identifier Mask 15-0
S * |        |          |0 = The corresponding bit in the identifier of the message object cannot inhibit the match in
S * |        |          |the acceptance filtering.
S * |        |          |1 = The corresponding identifier bit is used for acceptance filtering.
S * @var CAN_IF_T::MASK2
S * Offset: 0x2C, 0x8C  IFn Mask 2 Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[12:0]  |Msk[28:16]|Identifier Mask 28-16
S * |        |          |0 = The corresponding bit in the identifier of the message object cannot inhibit the match in
S * |        |          |the acceptance filtering.
S * |        |          |1 = The corresponding identifier bit is used for acceptance filtering.
S * |[14]    |MDir      |Mask Message Direction
S * |        |          |0 = The message direction bit (Dir (CAN_IFn_ARB2[13])) has no effect on the acceptance
S * |        |          |filtering.
S * |        |          |1 = The message direction bit (Dir) is used for acceptance filtering.
S * |[15]    |MXtd      |Mask Extended Identifier
S * |        |          |0 = The extended identifier bit (IDE) has no effect on the acceptance filtering.
S * |        |          |1 = The extended identifier bit (IDE) is used for acceptance filtering.
S * |        |          |Note: When 11-bit ("standard") Identifiers are used for a Message Object, the identifiers of
S * |        |          |received Data Frames are written into bits ID28 to ID18 (CAN_IFn_ARB2[12:2]).
S * |        |          |For acceptance filtering, only these bits together with mask bits Msk28 to Msk18
S * |        |          |(CAN_IFn_MASK2[12:2]) are considered.
S * @var CAN_IF_T::ARB1
S * Offset: 0x30, 0x90  IFn Arbitration 1 Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |ID[15:0]  |Message Identifier 15-0
S * |        |          |ID28 - ID0, 29-bit Identifier ("Extended Frame").
S * |        |          |ID28 - ID18, 11-bit Identifier ("Standard Frame")
S * @var CAN_IF_T::ARB2
S * Offset: 0x34, 0x94  IFn Arbitration 2 Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[12:0]  |ID[28:16] |Message Identifier 28-16
S * |        |          |ID28 - ID0, 29-bit Identifier ("Extended Frame").
S * |        |          |ID28 - ID18, 11-bit Identifier ("Standard Frame")
S * |[13]    |Dir       |Message Direction
S * |        |          |0 = Direction is receive.
S * |        |          |On TxRqst, a Remote Frame with the identifier of this Message Object is transmitted.
S * |        |          |On reception of a Data Frame with matching identifier, that message is stored in this Message
S * |        |          |Object.
S * |        |          |1 = Direction is transmit.
S * |        |          |On TxRqst, the respective Message Object is transmitted as a Data Frame.
S * |        |          |On reception of a Remote Frame with matching identifier, the TxRqst bit (CAN_IFn_CMASK[2]) of
S * |        |          |this Message Object is set (if RmtEn (CAN_IFn_MCON[9]) = one).
S * |[14]    |Xtd       |Extended Identifier
S * |        |          |0 = The 11-bit ("standard") Identifier will be used for this Message Object.
S * |        |          |1 = The 29-bit ("extended") Identifier will be used for this Message Object.
S * |[15]    |MsgVal    |Message Valid
S * |        |          |0 = The Message Object is ignored by the Message Handler.
S * |        |          |1 = The Message Object is configured and should be considered by the Message Handler.
S * |        |          |Note: The application software must reset the MsgVal bit of all unused Messages Objects during
S * |        |          |the initialization before it resets bit Init (CAN_CON[0]).
S * |        |          |This bit must also be reset before the identifier Id28-0 (CAN_IFn_ARB1/2), the control bits Xtd
S * |        |          |(CAN_IFn_ARB2[14]), Dir (CAN_IFn_APB2[13]), or the Data Length Code DLC3-0 (CAN_IFn_MCON[3:0])
S * |        |          |are modified, or if the Messages Object is no longer required.
S * @var CAN_IF_T::MCON
S * Offset: 0x38, 0x98  IFn Message Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |DLC       |Data Length Code
S * |        |          |0-8: Data Frame has 0-8 data bytes.
S * |        |          |9-15: Data Frame has 8 data bytes
S * |        |          |Note: The Data Length Code of a Message Object must be defined the same as in all the
S * |        |          |corresponding objects with the same identifier at other nodes.
S * |        |          |When the Message Handler stores a data frame, it will write the DLC to the value given by the
S * |        |          |received message.
S * |        |          |Data 0: 1st data byte of a CAN Data Frame
S * |        |          |Data 1: 2nd data byte of a CAN Data Frame
S * |        |          |Data 2: 3rd data byte of a CAN Data Frame
S * |        |          |Data 3: 4th data byte of a CAN Data Frame
S * |        |          |Data 4: 5th data byte of a CAN Data Frame
S * |        |          |Data 5: 6th data byte of a CAN Data Frame
S * |        |          |Data 6: 7th data byte of a CAN Data Frame
S * |        |          |Data 7 : 8th data byte of a CAN Data Frame
S * |        |          |Note: The Data 0 Byte is the first data byte shifted into the shift register of the CAN Core
S * |        |          |during a reception while the Data 7 byte is the last.
S * |        |          |When the Message Handler stores a Data Frame, it will write all the eight data bytes into a
S * |        |          |Message Object.
S * |        |          |If the Data Length Code is less than 8, the remaining bytes of the Message Object will be
S * |        |          |overwritten by unspecified values.
S * |[7]     |EoB       |End Of Buffer
S * |        |          |0 = Message Object belongs to a FIFO Buffer and is not the last Message Object of that FIFO
S * |        |          |Buffer.
S * |        |          |1 = Single Message Object or last Message Object of a FIFO Buffer.
S * |        |          |Note: This bit is used to concatenate two or more Message Objects (up to 32) to build a FIFO
S * |        |          |Buffer.
S * |        |          |For single Message Objects (not belonging to a FIFO Buffer), this bit must always be set to one.
S * |[8]     |TxRqst    |Transmit Request
S * |        |          |0 = This Message Object is not waiting for transmission.
S * |        |          |1 = The transmission of this Message Object is requested and is not yet done.
S * |[9]     |RmtEn     |Remote Enable Control
S * |        |          |0 = At the reception of a Remote Frame, TxRqst (CAN_IFn_MCON[8]) is left unchanged.
S * |        |          |1 = At the reception of a Remote Frame, TxRqst is set.
S * |[10]    |RxIE      |Receive Interrupt Enable Control
S * |        |          |0 = IntPnd (CAN_IFn_MCON[13]) will be left unchanged after a successful reception of a frame.
S * |        |          |1 = IntPnd will be set after a successful reception of a frame.
S * |[11]    |TxIE      |Transmit Interrupt Enable Control
S * |        |          |0 = IntPnd (CAN_IFn_MCON[13]) will be left unchanged after the successful transmission of a
S * |        |          |frame.
S * |        |          |1 = IntPnd will be set after a successful transmission of a frame.
S * |[12]    |UMask     |Use Acceptance Mask
S * |        |          |0 = Mask ignored.
S * |        |          |1 = Use Mask (Msk28-0, MXtd, and MDir) for acceptance filtering.
S * |        |          |Note: If the UMask bit is set to one, the Message Object's mask bits have to be programmed
S * |        |          |during initialization of the Message Object before MsgVal bit (CAN_IFn_APB2[15]) is set to one.
S * |[13]    |IntPnd    |Interrupt Pending
S * |        |          |0 = This message object is not the source of an interrupt.
S * |        |          |1 = This message object is the source of an interrupt.
S * |        |          |The Interrupt Identifier in the Interrupt Register will point to this message object if there is
S * |        |          |no other interrupt source with higher priority.
S * |[14]    |MsgLst    |Message Lost (only valid for Message Objects with direction = receive).
S * |        |          |0 = No message lost since last time this bit was reset by the CPU.
S * |        |          |1 = The Message Handler stored a new message into this object when NewDat was still set, the CPU
S * |        |          |has lost a message.
S * |[15]    |NewDat    |New Data
S * |        |          |0 = No new data has been written into the data portion of this Message Object by the Message
S * |        |          |Handler since last time this flag was cleared by the application software.
S * |        |          |1 = The Message Handler or the application software has written new data into the data portion
S * |        |          |of this Message Object.
S * @var CAN_IF_T::DAT_A1
S * Offset: 0x3C, 0x9C  IFn Data A1 Register (Register Map Note 3)
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |Data0     |Data Byte 0
S * |        |          |1st data byte of a CAN Data Frame
S * |[15:8]  |Data1     |Data Byte 1
S * |        |          |2nd data byte of a CAN Data Frame
S * @var CAN_IF_T::DAT_A2
S * Offset: 0x40, 0xA0  IFn Data A2 Register (Register Map Note 3)
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |Data2     |Data Byte 2
S * |        |          |3rd data byte of CAN Data Frame
S * |[15:8]  |Data3     |Data Byte 3
S * |        |          |4th data byte of CAN Data Frame
S * @var CAN_IF_T::DAT_B1
S * Offset: 0x44, 0xA4  IFn Data B1 Register (Register Map Note 3)
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |Data4     |Data Byte 4
S * |        |          |5th data byte of CAN Data Frame
S * |[15:8]  |Data5     |Data Byte 5
S * |        |          |6th data byte of CAN Data Frame
S * @var CAN_IF_T::DAT_B2
S * Offset: 0x48, 0xA8  IFn Data B2 Register (Register Map Note 3)
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |Data6     |Data Byte 6
S * |        |          |7th data byte of CAN Data Frame.
S * |[15:8]  |Data7     |Data Byte 7
S * |        |          |8th data byte of CAN Data Frame.
S */
S
S    __IO uint32_t CREQ;          /* Offset: 0x20, 0x80  IFn (Register Map Note 2) Command Request Registers          */
S    __IO uint32_t CMASK;         /* Offset: 0x24, 0x84  IFn Command Mask Register                                    */
S    __IO uint32_t MASK1;         /* Offset: 0x28, 0x88  IFn Mask 1 Register                                          */
S    __IO uint32_t MASK2;         /* Offset: 0x2C, 0x8C  IFn Mask 2 Register                                          */
S    __IO uint32_t ARB1;          /* Offset: 0x30, 0x90  IFn Arbitration 1 Register                                   */
S    __IO uint32_t ARB2;          /* Offset: 0x34, 0x94  IFn Arbitration 2 Register                                   */
S    __IO uint32_t MCON;          /* Offset: 0x38, 0x98  IFn Message Control Register                                 */
S    __IO uint32_t DAT_A1;        /* Offset: 0x3C, 0x9C  IFn Data A1 Register (Register Map Note 3)                   */
S    __IO uint32_t DAT_A2;        /* Offset: 0x40, 0xA0  IFn Data A2 Register (Register Map Note 3)                   */
S    __IO uint32_t DAT_B1;        /* Offset: 0x44, 0xA4  IFn Data B1 Register (Register Map Note 3)                   */
S    __IO uint32_t DAT_B2;        /* Offset: 0x48, 0xA8  IFn Data B2 Register (Register Map Note 3)                   */
S    __I  uint32_t RESERVE[13];   
S
S} CAN_IF_T;
S
S
S
S
S
Stypedef struct
S{
S
S
S
S/**
S * @var CAN_T::CON
S * Offset: 0x00  Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |Init      |Init Initialization
S * |        |          |0 = Normal Operation.
S * |        |          |1 = Initialization is started.
S * |[1]     |IE        |Module Interrupt Enable Control
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |[2]     |SIE       |Status Change Interrupt Enable Control
S * |        |          |0 = Disabled - No Status Change Interrupt will be generated.
S * |        |          |1 = Enabled - An interrupt will be generated when a message transfer is successfully completed
S * |        |          |or a CAN bus error is detected.
S * |[3]     |EIE       |Error Interrupt Enable Control
S * |        |          |0 = Disabled - No Error Status Interrupt will be generated.
S * |        |          |1 = Enabled - A change in the bits BOff (CAN_STATUS[7]) or EWarn (CAN_STATUS[6]) in the Status
S * |        |          |Register will generate an interrupt.
S * |[5]     |DAR       |Automatic Re-Transmission Disable Control
S * |        |          |0 = Automatic Retransmission of disturbed messages enabled.
S * |        |          |1 = Automatic Retransmission disabled.
S * |[6]     |CCE       |Configuration Change Enable Control
S * |        |          |0 = No write access to the Bit Timing Register.
S * |        |          |1 = Write access to the Bit Timing Register (CAN_BTIME) allowed. (while Init bit (CAN_CON[0]) = 1).
S * |[7]     |Test      |Test Mode Enable Control
S * |        |          |0 = Normal Operation.
S * |        |          |1 = Test Mode.
S * @var CAN_T::STATUS
S * Offset: 0x04  Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[2:0]   |LEC       |Last Error Code (Type Of The Last Error To Occur On The CAN Bus)
S * |        |          |The LEC field holds a code, which indicates the type of the last error to occur on the CAN bus.
S * |        |          |This field will be cleared to '0' when a message has been transferred (reception or
S * |        |          |transmission) without error.
S * |        |          |The unused code '7' may be written by the CPU to check for updates.
S * |        |          |The following table describes the error code.
S * |[3]     |TxOK      |Transmitted A Message Successfully
S * |        |          |0 = Since this bit was reset by the CPU, no message has been successfully transmitted.
S * |        |          |This bit is never reset by the CAN Core.
S * |        |          |1 = Since this bit was last reset by the CPU, a message has been successfully (error free and
S * |        |          |acknowledged by at least one other node) transmitted.
S * |[4]     |RxOK      |Received A Message Successfully
S * |        |          |0 = No message has been successfully received since this bit was last reset by the CPU.
S * |        |          |This bit is never reset by the CAN Core.
S * |        |          |1 = A message has been successfully received since this bit was last reset by the CPU
S * |        |          |(independent of the result of acceptance filtering).
S * |[5]     |EPass     |Error Passive (Read Only)
S * |        |          |0 = The CAN Core is error active.
S * |        |          |1 = The CAN Core is in the error passive state as defined in the CAN Specification.
S * |[6]     |EWarn     |Error Warning Status (Read Only)
S * |        |          |0 = Both error counters are below the error warning limit of 96.
S * |        |          |1 = At least one of the error counters in the EML has reached the error warning limit of 96.
S * |[7]     |BOff      |Bus-Off Status (Read Only)
S * |        |          |0 = The CAN module is not in bus-off state.
S * |        |          |1 = The CAN module is in bus-off state.
S * @var CAN_T::ERR
S * Offset: 0x08  Error Counter Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |TEC       |Transmit Error Counter
S * |        |          |Actual state of the Transmit Error Counter. Values between 0 and 255.
S * |[14:8]  |REC       |Receive Error Counter
S * |        |          |Actual state of the Receive Error Counter. Values between 0 and 127.
S * |[15]    |RP        |Receive Error Passive
S * |        |          |0 = The Receive Error Counter is below the error passive level.
S * |        |          |1 = The Receive Error Counter has reached the error passive level as defined in the CAN
S * |        |          |Specification.
S * @var CAN_T::BTIME
S * Offset: 0x0C  Bit Timing Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[5:0]   |BRP       |Baud Rate Prescaler
S * |        |          |0x01-0x3F: The value by which the oscillator frequency is divided for generating the bit time
S * |        |          |quanta.
S * |        |          |The bit time is built up from a multiple of this quanta.
S * |        |          |Valid values for the Baud Rate Prescaler are [ 0 ... 63 ].
S * |        |          |The actual interpretation by the hardware of this value is such that one more than the value
S * |        |          |programmed here is used.
S * |[7:6]   |SJW       |(Re)Synchronization Jump Width
S * |        |          |0x0-0x3: Valid programmed values are [0 ... 3].
S * |        |          |The actual interpretation by the hardware of this value is such that one more than the value
S * |        |          |programmed here is used.
S * |[11:8]  |TSeg1     |Time Segment Before The Sample Point Minus Sync_Seg
S * |        |          |0x01-0x0F: valid values for TSeg1 are [1 ... 15].
S * |        |          |The actual interpretation by the hardware of this value is such that one more than the value
S * |        |          |programmed is used.
S * |[14:12] |TSeg2     |Time Segment After Sample Point
S * |        |          |0x0-0x7: Valid values for TSeg2 are [0 ... 7].
S * |        |          |The actual interpretation by the hardware of this value is such that one more than the value
S * |        |          |programmed here is used.
S * @var CAN_T::IIDR
S * Offset: 0x10  Interrupt Identifier Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |IntId     |Interrupt Identifier (Indicates The Source Of The Interrupt)
S * |        |          |If several interrupts are pending, the CAN Interrupt Register will point to the pending
S * |        |          |interrupt with the highest priority, disregarding their chronological order.
S * |        |          |An interrupt remains pending until the application software has cleared it.
S * |        |          |If IntId is different from 0x0000 and IE (CAN_IFn_MCON[1]) is set, the IRQ interrupt signal to
S * |        |          |the EIC is active.
S * |        |          |The interrupt remains active until IntId is back to value 0x0000 (the cause of the interrupt is
S * |        |          |reset) or until IE is reset.
S * |        |          |The Status Interrupt has the highest priority.
S * |        |          |Among the message interrupts, the Message Object' s interrupt priority decreases with increasing
S * |        |          |message number.
S * |        |          |A message interrupt is cleared by clearing the Message Object's IntPnd bit (CAN_IFn_MCON[13]).
S * |        |          |The Status Interrupt is cleared by reading the Status Register.
S * @var CAN_T::TEST
S * Offset: 0x14  Test Register (Register Map Note 1)
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[1:0]   |Res       |Reserved
S * |        |          |There are reserved bits.
S * |        |          |These bits are always read as '0' and must always be written with '0'.
S * |[2]     |Basic     |Basic Mode
S * |        |          |0 = Basic Mode disabled.
S * |        |          |1= IF1 Registers used as Tx Buffer, IF2 Registers used as Rx Buffer.
S * |[3]     |Silent    |Silent Mode
S * |        |          |0 = Normal operation.
S * |        |          |1 = The module is in Silent Mode.
S * |[4]     |LBack     |Loop Back Mode Enable Control
S * |        |          |0 = Loop Back Mode is disabled.
S * |        |          |1 = Loop Back Mode is enabled.
S * |[6:5]   |Tx10      |Tx[1:0]: Control Of CAN_TX Pin
S * |        |          |00 = Reset value, CAN_TX pin is controlled by the CAN Core.
S * |        |          |01 = Sample Point can be monitored at CAN_TX pin.
S * |        |          |10 = CAN_TX pin drives a dominant ('0') value.
S * |        |          |11 = CAN_TX pin drives a recessive ('1') value.
S * |[7]     |Rx        |Monitors The Actual Value Of CAN_RX Pin (Read Only)
S * |        |          |0 = The CAN bus is dominant (CAN_RX = '0').
S * |        |          |1 = The CAN bus is recessive (CAN_RX = '1').
S * @var CAN_T::BRPE
S * Offset: 0x18  Baud Rate Prescaler Extension Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |BRPE      |BRPE: Baud Rate Prescaler Extension
S * |        |          |0x00-0x0F: By programming BRPE, the Baud Rate Prescaler can be extended to values up to 1023.
S * |        |          |The actual interpretation by the hardware is that one more than the value programmed by BRPE
S * |        |          |(MSBs) and BTIME (LSBs) is used.
S * @var CAN_T::TXREQ1
S * Offset: 0x100  Transmission Request Register 1
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |TxRqst[16:1]|Transmission Request Bits 16-1 (Of All Message Objects)
S * |        |          |0 = This Message Object is not waiting for transmission.
S * |        |          |1 = The transmission of this Message Object is requested and is not yet done.
S * |        |          |These bits are read only.
S * @var CAN_T::TXREQ2
S * Offset: 0x104  Transmission Request Register 2
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |TxRqst[32:17]|Transmission Request Bits 32-17 (Of All Message Objects)
S * |        |          |0 = This Message Object is not waiting for transmission.
S * |        |          |1 = The transmission of this Message Object is requested and is not yet done.
S * |        |          |These bits are read only.
S * @var CAN_T::NDAT1
S * Offset: 0x120  New Data Register 1
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |NewData[16:1]|New Data Bits 16-1 (Of All Message Objects)
S * |        |          |0 = No new data has been written into the data portion of this Message Object by the Message
S * |        |          |Handler since the last time this flag was cleared by the application software.
S * |        |          |1 = The Message Handler or the application software has written new data into the data portion
S * |        |          |of this Message Object.
S * @var CAN_T::NDAT2
S * Offset: 0x124  New Data Register 2
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |NewData[32:17]|New Data Bits 32-17 (Of All Message Objects)
S * |        |          |0 = No new data has been written into the data portion of this Message Object by the Message
S * |        |          |Handler since the last time this flag was cleared by the application software.
S * |        |          |1 = The Message Handler or the application software has written new data into the data portion
S * |        |          |of this Message Object.
S * @var CAN_T::IPND1
S * Offset: 0x140  Interrupt Pending Register 1
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |IntPnd[16:1]|Interrupt Pending Bits 16-1 (Of All Message Objects)
S * |        |          |0 = This message object is not the source of an interrupt.
S * |        |          |1 = This message object is the source of an interrupt.
S * @var CAN_T::IPND2
S * Offset: 0x144  Interrupt Pending Register 2
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |IntPnd[32:17]|Interrupt Pending Bits 32-17(Of All Message Objects)
S * |        |          |0 = This message object is not the source of an interrupt.
S * |        |          |1 = This message object is the source of an interrupt.
S * @var CAN_T::MVLD1
S * Offset: 0x160  Message Valid Register 1
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |MsgVal[16:1]|Message Valid Bits 16-1 (Of All Message Objects) (Read Only)
S * |        |          |0 = This Message Object is ignored by the Message Handler.
S * |        |          |1 = This Message Object is configured and should be considered by the Message Handler.
S * |        |          |Ex.
S * |        |          |CAN_MVLD1[0] means Message object No.1 is valid or not.
S * |        |          |If CAN_MVLD1[0] is set, message object No.1 is configured.
S * @var CAN_T::MVLD2
S * Offset: 0x164  Message Valid Register 2
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |MsgVal[32:17]|Message Valid Bits 32-17 (Of All Message Objects) (Read Only)
S * |        |          |0 = This Message Object is ignored by the Message Handler.
S * |        |          |1 = This Message Object is configured and should be considered by the Message Handler.
S * |        |          |Ex.CAN_MVLD2[15] means Message object No.32 is valid or not.
S * |        |          |If CAN_MVLD2[15] is set, message object No.32 is configured.
S * @var CAN_T::WU_EN
S * Offset: 0x168  Wake-up Enable Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |WAKUP_EN  |Wake-Up Enable Control
S * |        |          |0 = The wake-up function Disabled.
S * |        |          |1 = The wake-up function Enabled.
S * |        |          |Note: User can wake-up system when there is a falling edge in the CAN_Rx pin.
S * @var CAN_T::WU_STATUS
S * Offset: 0x16C  Wake-up Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |WAKUP_STS |Wake-Up Status
S * |        |          |0 = No wake-up event occurred.
S * |        |          |1 = Wake-up event occurred.
S * |        |          |Note: This bit can be cleared by writing '0'.
S */
S
S    __IO uint32_t CON;           /* Offset: 0x00  Control Register                                                   */
S    __IO uint32_t STATUS;        /* Offset: 0x04  Status Register                                                    */
S    __IO uint32_t ERR;           /* Offset: 0x08  Error Counter Register                                             */
S    __IO uint32_t BTIME;         /* Offset: 0x0C  Bit Timing Register                                                */
S    __IO uint32_t IIDR;          /* Offset: 0x10  Interrupt Identifier Register                                      */
S    __IO uint32_t TEST;          /* Offset: 0x14  Test Register (Register Map Note 1)                                */
S    __IO uint32_t BRPE;          /* Offset: 0x18  Baud Rate Prescaler Extension Register                             */
S    __I  uint32_t RESERVE0[1];  
S    __IO CAN_IF_T IF[2];         /* Offset: 0x20  CAN Interface Control Registers                                    */
S    __I  uint32_t RESERVE1[8];  
S    __IO uint32_t TXREQ1;        /* Offset: 0x100  Transmission Request Register 1                                   */
S    __IO uint32_t TXREQ2;        /* Offset: 0x104  Transmission Request Register 2                                   */
S    __I  uint32_t RESERVE2[6];  
S    __IO uint32_t NDAT1;         /* Offset: 0x120  New Data Register 1                                               */
S    __IO uint32_t NDAT2;         /* Offset: 0x124  New Data Register 2                                               */
S    __I  uint32_t RESERVE3[6];  
S    __IO uint32_t IPND1;         /* Offset: 0x140  Interrupt Pending Register 1                                      */
S    __IO uint32_t IPND2;         /* Offset: 0x144  Interrupt Pending Register 2                                      */
S    __I  uint32_t RESERVE4[6];  
S    __IO uint32_t MVLD1;         /* Offset: 0x160  Message Valid Register 1                                          */
S    __IO uint32_t MVLD2;         /* Offset: 0x164  Message Valid Register 2                                          */
S    __IO uint32_t WU_EN;         /* Offset: 0x168  Wake-up Enable Register                                           */
S    __IO uint32_t WU_STATUS;     /* Offset: 0x16C  Wake-up Status Register                                           */
S
S} CAN_T;
S
S
S
S/**
S    @addtogroup CAN_CONST CAN Bit Field Definition
S    Constant Definitions for CAN Controller
S@{ */
S
S
S/* CAN CON Bit Field Definitions */
S#define CAN_CON_TEST_Pos           7                                    /*!< CAN_T::CON: TEST Position */
S#define CAN_CON_TEST_Msk           (1ul << CAN_CON_TEST_Pos)            /*!< CAN_T::CON: TEST Mask     */
S
S#define CAN_CON_CCE_Pos            6                                    /*!< CAN_T::CON: CCE Position  */
S#define CAN_CON_CCE_Msk            (1ul << CAN_CON_CCE_Pos)             /*!< CAN_T::CON: CCE Mask      */
S
S#define CAN_CON_DAR_Pos            5                                    /*!< CAN_T::CON: DAR Position  */
S#define CAN_CON_DAR_Msk            (1ul << CAN_CON_DAR_Pos)             /*!< CAN_T::CON: DAR Mask      */
S
S#define CAN_CON_EIE_Pos            3                                    /*!< CAN_T::CON: EIE Position  */
S#define CAN_CON_EIE_Msk            (1ul << CAN_CON_EIE_Pos)             /*!< CAN_T::CON: EIE Mask      */
S
S#define CAN_CON_SIE_Pos            2                                    /*!< CAN_T::CON: SIE Position  */
S#define CAN_CON_SIE_Msk            (1ul << CAN_CON_SIE_Pos)             /*!< CAN_T::CON: SIE Mask      */
S
S#define CAN_CON_IE_Pos             1                                    /*!< CAN_T::CON: IE Position   */
S#define CAN_CON_IE_Msk             (1ul << CAN_CON_IE_Pos)              /*!< CAN_T::CON: IE Mask       */
S
S#define CAN_CON_INIT_Pos           0                                    /*!< CAN_T::CON: INIT Position */
S#define CAN_CON_INIT_Msk           (1ul << CAN_CON_INIT_Pos)            /*!< CAN_T::CON: INIT Mask     */
S
S/* CAN STATUS Bit Field Definitions */
S#define CAN_STATUS_BOFF_Pos        7                                    /*!< CAN_T::STATUS: BOFF Position  */
S#define CAN_STATUS_BOFF_Msk        (1ul << CAN_STATUS_BOFF_Pos)         /*!< CAN_T::STATUS: BOFF Mask      */
S
S#define CAN_STATUS_EWARN_Pos       6                                    /*!< CAN_T::STATUS: EWARN Position */
S#define CAN_STATUS_EWARN_Msk       (1ul << CAN_STATUS_EWARN_Pos)        /*!< CAN_T::STATUS: EWARN Mask     */
S
S#define CAN_STATUS_EPASS_Pos       5                                    /*!< CAN_T::STATUS: EPASS Position */
S#define CAN_STATUS_EPASS_Msk       (1ul << CAN_STATUS_EPASS_Pos)        /*!< CAN_T::STATUS: EPASS Mask     */
S
S#define CAN_STATUS_RXOK_Pos        4                                    /*!< CAN_T::STATUS: RXOK Position  */
S#define CAN_STATUS_RXOK_Msk        (1ul << CAN_STATUS_RXOK_Pos)         /*!< CAN_T::STATUS: RXOK Mask      */
S
S#define CAN_STATUS_TXOK_Pos        3                                    /*!< CAN_T::STATUS: TXOK Position  */
S#define CAN_STATUS_TXOK_Msk        (1ul << CAN_STATUS_TXOK_Pos)         /*!< CAN_T::STATUS: TXOK Mask      */
S
S#define CAN_STATUS_LEC_Pos         0                                    /*!< CAN_T::STATUS: LEC Position   */
S#define CAN_STATUS_LEC_Msk         (0x7ul << CAN_STATUS_LEC_Pos)        /*!< CAN_T::STATUS: LEC Mask       */
S
S/* CAN ERR Bit Field Definitions */
S#define CAN_ERR_RP_Pos             15                                   /*!< CAN_T::ERR: RP Position       */
S#define CAN_ERR_RP_Msk             (1ul << CAN_ERR_RP_Pos)              /*!< CAN_T::ERR: RP Mask           */
S
S#define CAN_ERR_REC_Pos            8                                    /*!< CAN_T::ERR: REC Position      */
S#define CAN_ERR_REC_Msk            (0x7Ful << CAN_ERR_REC_Pos)          /*!< CAN_T::ERR: REC Mask          */
S
S#define CAN_ERR_TEC_Pos            0                                    /*!< CAN_T::ERR: TEC Position      */
S#define CAN_ERR_TEC_Msk            (0xFFul << CAN_ERR_TEC_Pos)          /*!< CAN_T::ERR: TEC Mask          */
S
S/* CAN BTIME Bit Field Definitions */
S#define CAN_BTIME_TSEG2_Pos        12                                   /*!< CAN_T::BTIME: TSEG2 Position  */
S#define CAN_BTIME_TSEG2_Msk        (0x7ul << CAN_BTIME_TSEG2_Pos)       /*!< CAN_T::BTIME: TSEG2 Mask      */
S
S#define CAN_BTIME_TSEG1_Pos        8                                    /*!< CAN_T::BTIME: TSEG1 Position  */
S#define CAN_BTIME_TSEG1_Msk        (0xFul << CAN_BTIME_TSEG1_Pos)       /*!< CAN_T::BTIME: TSEG1 Mask      */
S
S#define CAN_BTIME_SJW_Pos          6                                    /*!< CAN_T::BTIME: SJW Position    */
S#define CAN_BTIME_SJW_Msk          (0x3ul << CAN_BTIME_SJW_Pos)         /*!< CAN_T::BTIME: SJW Mask        */
S
S#define CAN_BTIME_BRP_Pos          0                                    /*!< CAN_T::BTIME: BRP Position    */
S#define CAN_BTIME_BRP_Msk          (0x3Ful << CAN_BTIME_BRP_Pos)        /*!< CAN_T::BTIME: BRP Mask        */
S
S/* CAN IIDR Bit Field Definitions */
S#define CAN_IIDR_INTID_Pos         0                                    /*!< CAN_T::IIDR: INTID Position   */
S#define CAN_IIDR_INTID_Msk         (0xFFFFul << CAN_IIDR_INTID_Pos)     /*!< CAN_T::IIDR: INTID Mask       */
S
S/* CAN TEST Bit Field Definitions */
S#define CAN_TEST_RX_Pos            7                                    /*!< CAN_T::TEST: RX Position      */
S#define CAN_TEST_RX_Msk            (1ul << CAN_TEST_RX_Pos)             /*!< CAN_T::TEST: RX Mask          */
S
S#define CAN_TEST_TX_Pos            5                                    /*!< CAN_T::TEST: TX Position      */
S#define CAN_TEST_TX_Msk            (0x3ul << CAN_TEST_TX_Pos)           /*!< CAN_T::TEST: TX Mask          */
S
S#define CAN_TEST_LBACK_Pos         4                                    /*!< CAN_T::TEST: LBACK Position   */
S#define CAN_TEST_LBACK_Msk         (1ul << CAN_TEST_LBACK_Pos)          /*!< CAN_T::TEST: LBACK Mask       */
S
S#define CAN_TEST_SILENT_Pos        3                                    /*!< CAN_T::TEST: Silent Position  */
S#define CAN_TEST_SILENT_Msk        (1ul << CAN_TEST_SILENT_Pos)         /*!< CAN_T::TEST: Silent Mask      */
S
S#define CAN_TEST_BASIC_Pos         2                                    /*!< CAN_T::TEST: Basic Position   */
S#define CAN_TEST_BASIC_Msk         (1ul << CAN_TEST_BASIC_Pos)          /*!< CAN_T::TEST: Basic Mask       */
S
S/* CAN BPRE Bit Field Definitions */
S#define CAN_BRPE_BRPE_Pos          0                                    /*!< CAN_T::BRPE: BRPE Position    */
S#define CAN_BRPE_BRPE_Msk          (0xFul << CAN_BRPE_BRPE_Pos)         /*!< CAN_T::BRPE: BRPE Mask        */
S
S/* CAN IFn_CREQ Bit Field Definitions */
S#define CAN_IF_CREQ_BUSY_Pos       15                                   /*!< CAN_IF_T::CREQ: BUSY Position */
S#define CAN_IF_CREQ_BUSY_Msk       (1ul << CAN_IF_CREQ_BUSY_Pos)        /*!< CAN_IF_T::CREQ: BUSY Mask     */
S
S#define CAN_IF_CREQ_MSGNUM_Pos     0                                    /*!< CAN_IF_T::CREQ: MSGNUM Position */
S#define CAN_IF_CREQ_MSGNUM_Msk     (0x3Ful << CAN_IF_CREQ_MSGNUM_Pos)   /*!< CAN_IF_T::CREQ: MSGNUM Mask     */
S
S/* CAN IFn_CMASK Bit Field Definitions */
S#define CAN_IF_CMASK_WRRD_Pos      7                                    /*!< CAN_IF_T::CMASK: WRRD Position */
S#define CAN_IF_CMASK_WRRD_Msk      (1ul << CAN_IF_CMASK_WRRD_Pos)       /*!< CAN_IF_T::CMASK: WRRD Mask     */
S
S#define CAN_IF_CMASK_MASK_Pos      6                                    /*!< CAN_IF_T::CMASK: MASK Position */
S#define CAN_IF_CMASK_MASK_Msk      (1ul << CAN_IF_CMASK_MASK_Pos)       /*!< CAN_IF_T::CMASK: MASK Mask     */
S
S#define CAN_IF_CMASK_ARB_Pos       5                                    /*!< CAN_IF_T::CMASK: ARB Position  */
S#define CAN_IF_CMASK_ARB_Msk       (1ul << CAN_IF_CMASK_ARB_Pos)        /*!< CAN_IF_T::CMASK: ARB Mask      */
S
S#define CAN_IF_CMASK_CONTROL_Pos   4                                    /*!< CAN_IF_T::CMASK: CONTROL Position */
S#define CAN_IF_CMASK_CONTROL_Msk   (1ul << CAN_IF_CMASK_CONTROL_Pos)    /*!< CAN_IF_T::CMASK: CONTROL Mask */
S
S#define CAN_IF_CMASK_CLRINTPND_Pos 3                                    /*!< CAN_IF_T::CMASK: CLRINTPND Position */
S#define CAN_IF_CMASK_CLRINTPND_Msk (1ul << CAN_IF_CMASK_CLRINTPND_Pos)  /*!< CAN_IF_T::CMASK: CLRINTPND Mask */
S
S#define CAN_IF_CMASK_TXRQSTNEWDAT_Pos 2                                         /*!< CAN_IF_T::CMASK: TXRQSTNEWDAT Position */
S#define CAN_IF_CMASK_TXRQSTNEWDAT_Msk (1ul << CAN_IF_CMASK_TXRQSTNEWDAT_Pos)    /*!< CAN_IF_T::CMASK: TXRQSTNEWDAT Mask     */
S
S#define CAN_IF_CMASK_DATAA_Pos     1                                    /*!< CAN_IF_T::CMASK: DATAA Position */
S#define CAN_IF_CMASK_DATAA_Msk     (1ul << CAN_IF_CMASK_DATAA_Pos)      /*!< CAN_IF_T::CMASK: DATAA Mask     */
S
S#define CAN_IF_CMASK_DATAB_Pos     0                                    /*!< CAN_IF_T::CMASK: DATAB Position */
S#define CAN_IF_CMASK_DATAB_Msk     (1ul << CAN_IF_CMASK_DATAB_Pos)      /*!< CAN_IF_T::CMASK: DATAB Mask     */
S
S/* CAN IFn_MASK1 Bit Field Definitions */
S#define CAN_IF_MASK1_MSK_Pos       0                                    /*!< CAN_IF_T::MASK1: MSK Position   */
S#define CAN_IF_MASK1_MSK_Msk       (0xFFul << CAN_IF_MASK1_MSK_Pos)     /*!< CAN_IF_T::MASK1: MSK Mask       */
S
S/* CAN IFn_MASK2 Bit Field Definitions */
S#define CAN_IF_MASK2_MXTD_Pos      15                                   /*!< CAN_IF_T::MASK2: MXTD Position */
S#define CAN_IF_MASK2_MXTD_Msk      (1ul << CAN_IF_MASK2_MXTD_Pos)       /*!< CAN_IF_T::MASK2: MXTD Mask     */
S
S#define CAN_IF_MASK2_MDIR_Pos      14                                   /*!< CAN_IF_T::MASK2: MDIR Position */
S#define CAN_IF_MASK2_MDIR_Msk      (1ul << CAN_IF_MASK2_MDIR_Pos)       /*!< CAN_IF_T::MASK2: MDIR Mask     */
S
S#define CAN_IF_MASK2_MSK_Pos       0                                    /*!< CAN_IF_T::MASK2: MSK Position */
S#define CAN_IF_MASK2_MSK_Msk       (0x1FFul << CAN_IF_MASK2_MSK_Pos)    /*!< CAN_IF_T::MASK2: MSK Mask     */
S
S/* CAN IFn_ARB1 Bit Field Definitions */
S#define CAN_IF_ARB1_ID_Pos         0                                    /*!< CAN_IF_T::ARB1: ID Position   */
S#define CAN_IF_ARB1_ID_Msk         (0xFFFFul << CAN_IF_ARB1_ID_Pos)     /*!< CAN_IF_T::ARB1: ID Mask       */
S
S/* CAN IFn_ARB2 Bit Field Definitions */
S#define CAN_IF_ARB2_MSGVAL_Pos     15                                   /*!< CAN_IF_T::ARB2: MSGVAL Position */
S#define CAN_IF_ARB2_MSGVAL_Msk     (1ul << CAN_IF_ARB2_MSGVAL_Pos)      /*!< CAN_IF_T::ARB2: MSGVAL Mask     */
S
S#define CAN_IF_ARB2_XTD_Pos        14                                   /*!< CAN_IF_T::ARB2: XTD Position    */
S#define CAN_IF_ARB2_XTD_Msk        (1ul << CAN_IF_ARB2_XTD_Pos)         /*!< CAN_IF_T::ARB2: XTD Mask        */
S
S#define CAN_IF_ARB2_DIR_Pos        13                                   /*!< CAN_IF_T::ARB2: DIR Position    */
S#define CAN_IF_ARB2_DIR_Msk        (1ul << CAN_IF_ARB2_DIR_Pos)         /*!< CAN_IF_T::ARB2: DIR Mask        */
S
S#define CAN_IF_ARB2_ID_Pos         0                                    /*!< CAN_IF_T::ARB2: ID Position     */
S#define CAN_IF_ARB2_ID_Msk         (0x1FFFul << CAN_IF_ARB2_ID_Pos)     /*!< CAN_IF_T::ARB2: ID Mask         */
S
S/* CAN IFn_MCON Bit Field Definitions */
S#define CAN_IF_MCON_NEWDAT_Pos     15                                   /*!< CAN_IF_T::MCON: NEWDAT Position */
S#define CAN_IF_MCON_NEWDAT_Msk     (1ul << CAN_IF_MCON_NEWDAT_Pos)      /*!< CAN_IF_T::MCON: NEWDAT Mask     */
S
S#define CAN_IF_MCON_MSGLST_Pos     14                                   /*!< CAN_IF_T::MCON: MSGLST Position */
S#define CAN_IF_MCON_MSGLST_Msk     (1ul << CAN_IF_MCON_MSGLST_Pos)      /*!< CAN_IF_T::MCON: MSGLST Mask     */
S
S#define CAN_IF_MCON_INTPND_Pos     13                                   /*!< CAN_IF_T::MCON: INTPND Position */
S#define CAN_IF_MCON_INTPND_Msk     (1ul << CAN_IF_MCON_INTPND_Pos)      /*!< CAN_IF_T::MCON: INTPND Mask     */
S
S#define CAN_IF_MCON_UMASK_Pos      12                                   /*!< CAN_IF_T::MCON: UMASK Position  */
S#define CAN_IF_MCON_UMASK_Msk      (1ul << CAN_IF_MCON_UMASK_Pos)       /*!< CAN_IF_T::MCON: UMASK Mask      */
S
S#define CAN_IF_MCON_TXIE_Pos       11                                   /*!< CAN_IF_T::MCON: TXIE Position   */
S#define CAN_IF_MCON_TXIE_Msk       (1ul << CAN_IF_MCON_TXIE_Pos)        /*!< CAN_IF_T::MCON: TXIE Mask       */
S
S#define CAN_IF_MCON_RXIE_Pos       10                                   /*!< CAN_IF_T::MCON: RXIE Position   */
S#define CAN_IF_MCON_RXIE_Msk       (1ul << CAN_IF_MCON_RXIE_Pos)        /*!< CAN_IF_T::MCON: RXIE Mask       */
S
S#define CAN_IF_MCON_RMTEN_Pos      9                                    /*!< CAN_IF_T::MCON: RMTEN Position  */
S#define CAN_IF_MCON_RMTEN_Msk      (1ul << CAN_IF_MCON_RMTEN_Pos)       /*!< CAN_IF_T::MCON: RMTEN Mask      */
S
S#define CAN_IF_MCON_TXRQST_Pos     8                                    /*!< CAN_IF_T::MCON: TXRQST Position */
S#define CAN_IF_MCON_TXRQST_Msk     (1ul << CAN_IF_MCON_TXRQST_Pos)      /*!< CAN_IF_T::MCON: TXRQST Mask     */
S
S#define CAN_IF_MCON_EOB_Pos        7                                    /*!< CAN_IF_T::MCON: EOB Position    */
S#define CAN_IF_MCON_EOB_Msk        (1ul << CAN_IF_MCON_EOB_Pos)         /*!< CAN_IF_T::MCON: EOB Mask        */
S
S#define CAN_IF_MCON_DLC_Pos        0                                    /*!< CAN_IF_T::MCON: DLC Position    */
S#define CAN_IF_MCON_DLC_Msk        (0xFul << CAN_IF_MCON_DLC_Pos)       /*!< CAN_IF_T::MCON: DLC Mask        */
S
S/* CAN IFn_DATA_A1 Bit Field Definitions */
S#define CAN_IF_DAT_A1_DATA1_Pos    8                                    /*!< CAN_IF_T::DAT_A1: DATA1 Position */
S#define CAN_IF_DAT_A1_DATA1_Msk    (0xFFul << CAN_IF_DAT_A1_DATA1_Pos)  /*!< CAN_IF_T::DAT_A1: DATA1 Mask     */
S
S#define CAN_IF_DAT_A1_DATA0_Pos    0                                    /*!< CAN_IF_T::DAT_A1: DATA0 Position */
S#define CAN_IF_DAT_A1_DATA0_Msk    (0xFFul << CAN_IF_DAT_A1_DATA0_Pos)  /*!< CAN_IF_T::DAT_A1: DATA0 Mask     */
S
S/* CAN IFn_DATA_A2 Bit Field Definitions */
S#define CAN_IF_DAT_A2_DATA3_Pos    8                                    /*!< CAN_IF_T::DAT_A1: DATA3 Position */
S#define CAN_IF_DAT_A2_DATA3_Msk    (0xFFul << CAN_IF_DAT_A2_DATA3_Pos)  /*!< CAN_IF_T::DAT_A1: DATA3 Mask     */
S
S#define CAN_IF_DAT_A2_DATA2_Pos    0                                    /*!< CAN_IF_T::DAT_A1: DATA2 Position */
S#define CAN_IF_DAT_A2_DATA2_Msk    (0xFFul << CAN_IF_DAT_A2_DATA2_Pos)  /*!< CAN_IF_T::DAT_A1: DATA2 Mask     */
S
S/* CAN IFn_DATA_B1 Bit Field Definitions */
S#define CAN_IF_DAT_B1_DATA5_Pos    8                                    /*!< CAN_IF_T::DAT_B1: DATA5 Position */
S#define CAN_IF_DAT_B1_DATA5_Msk    (0xFFul << CAN_IF_DAT_B1_DATA5_Pos)  /*!< CAN_IF_T::DAT_B1: DATA5 Mask */
S
S#define CAN_IF_DAT_B1_DATA4_Pos    0                                    /*!< CAN_IF_T::DAT_B1: DATA4 Position */
S#define CAN_IF_DAT_B1_DATA4_Msk    (0xFFul << CAN_IF_DAT_B1_DATA4_Pos)  /*!< CAN_IF_T::DAT_B1: DATA4 Mask */
S
S/* CAN IFn_DATA_B2 Bit Field Definitions */
S#define CAN_IF_DAT_B2_DATA7_Pos    8                                    /*!< CAN_IF_T::DAT_B2: DATA7 Position */
S#define CAN_IF_DAT_B2_DATA7_Msk    (0xFFul << CAN_IF_DAT_B2_DATA7_Pos)  /*!< CAN_IF_T::DAT_B2: DATA7 Mask     */
S
S#define CAN_IF_DAT_B2_DATA6_Pos    0                                    /*!< CAN_IF_T::DAT_B2: DATA6 Position */
S#define CAN_IF_DAT_B2_DATA6_Msk    (0xFFul << CAN_IF_DAT_B2_DATA6_Pos)  /*!< CAN_IF_T::DAT_B2: DATA6 Mask     */
S
S/* CAN IFn_TXRQST1 Bit Field Definitions */
S#define CAN_IF_TXRQST1_TXRQST_Pos  0                                        /*!< CAN_T::TXRQST1: TXRQST Position */
S#define CAN_IF_TXRQST1_TXRQST_Msk  (0xFFFFul << CAN_IF_TXRQST1_TXRQST_Pos)  /*!< CAN_T::TXRQST1: TXRQST Mask     */
S
S/* CAN IFn_TXRQST2 Bit Field Definitions */
S#define CAN_IF_TXRQST2_TXRQST_Pos  0                                        /*!< CAN_T::TXRQST2: TXRQST Position  */
S#define CAN_IF_TXRQST2_TXRQST_Msk  (0xFFFFul << CAN_IF_TXRQST2_TXRQST_Pos)  /*!< CAN_T::TXRQST2: TXRQST Mask      */
S
S/* CAN IFn_NDAT1 Bit Field Definitions */
S#define CAN_IF_NDAT1_NEWDATA_Pos   0                                        /*!< CAN_T::NDAT1: NEWDATA Position */
S#define CAN_IF_NDAT1_NEWDATA_Msk   (0xFFFFul << CAN_IF_NDAT1_NEWDATA_Pos)   /*!< CAN_T::NDAT1: NEWDATA Mask     */
S
S/* CAN IFn_NDAT2 Bit Field Definitions */
S#define CAN_IF_NDAT2_NEWDATA_Pos   0                                        /*!< CAN_T::NDAT2: NEWDATA Position */
S#define CAN_IF_NDAT2_NEWDATA_Msk   (0xFFFFul << CAN_IF_NDAT2_NEWDATA_Pos)   /*!< CAN_T::NDAT2: NEWDATA Mask     */
S
S/* CAN IFn_IPND1 Bit Field Definitions */
S#define CAN_IF_IPND1_INTPND_Pos   0                                         /*!< CAN_T::IPND1: INTPND Position */
S#define CAN_IF_IPND1_INTPND_Msk   (0xFFFFul << CAN_IF_IPND1_INTPND_Pos)     /*!< CAN_T::IPND1: INTPND Mask     */
S
S/* CAN IFn_IPND2 Bit Field Definitions */
S#define CAN_IF_IPND2_INTPND_Pos   0                                         /*!< CAN_T::IPND2: INTPND Position */
S#define CAN_IF_IPND2_INTPND_Msk   (0xFFFFul << CAN_IF_IPND2_INTPND_Pos)     /*!< CAN_T::IPND2: INTPND Mask     */
S
S/* CAN IFn_MVLD1 Bit Field Definitions */
S#define CAN_IF_MVLD1_MSGVAL_Pos   0                                         /*!< CAN_T::MVLD1: MSGVAL Position */
S#define CAN_IF_MVLD1_MSGVAL_Msk   (0xFFFFul << CAN_IF_MVLD1_MSGVAL_Pos)     /*!< CAN_T::MVLD1: MSGVAL Mask     */
S
S/* CAN IFn_MVLD2 Bit Field Definitions */
S#define CAN_IF_MVLD2_MSGVAL_Pos   0                                         /*!< CAN_T::MVLD2: MSGVAL Position */
S#define CAN_IF_MVLD2_MSGVAL_Msk   (0xFFFFul << CAN_IF_MVLD2_MSGVAL_Pos)     /*!< CAN_T::MVLD2: MSGVAL Mask     */
S
S/* CAN WUEN Bit Field Definitions */
S#define CAN_WUEN_WAKUP_EN_Pos     0                                         /*!< CAN_T::WU_EN: WAKUP_EN Position */
S#define CAN_WUEN_WAKUP_EN_Msk    (1ul << CAN_WUEN_WAKUP_EN_Pos)             /*!< CAN_T::WU_EN: WAKUP_EN Mask     */
S
S/* CAN WUSTATUS Bit Field Definitions */
S#define CAN_WUSTATUS_WAKUP_STS_Pos     0                                    /*!< CAN_T::WU_STATUS: WAKUP_STS Position */
S#define CAN_WUSTATUS_WAKUP_STS_Msk    (1ul << CAN_WUSTATUS_WAKUP_STS_Pos)   /*!< CAN_T::WU_STATUS: WAKUP_STS Mask     */
S/*@}*/ /* end of group CAN_CONST */
S/*@}*/ /* end of group CAN */
S
S
S/*---------------------------- Clock Controller ------------------------------*/
S/** @addtogroup CLK System Clock Controller (CLK)
S  Memory Mapped Structure for System Clock Controller
S  @{
S */
S
S
S
Stypedef struct
S{
S
S
S
S/**
S * @var CLK_T::PWRCON
S * Offset: 0x00  System Power-down Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |XTL12M_EN |External 4~24 MHz High Speed Crystal Enable (HXT) Control (Write Protect)
S * |        |          |The bit default value is set by flash controller user configuration register CFOSC
S * |        |          |(Config0[26:24]).
S * |        |          |When the default clock source is from external 4~24 MHz high speed crystal, this bit is set to 1
S * |        |          |automatically.
S * |        |          |0 = External 4~24 MHz high speed crystal oscillator (HXT) Disabled.
S * |        |          |1 = External 4~24 MHz high speed crystal oscillator (HXT) Enabled.
S * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register.    
S * |[1]     |XTL32K_EN |External 32.768 KHz Low Speed Crystal Enable (LXT) Control (Write Protect)
S * |        |          |0 = External 32.768 kHz low speed crystal oscillator (LXT) Disabled.
S * |        |          |1 = External 32.768 kHz low speed crystal oscillator (LXT) Enabled (Normal operation).
S * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register. 
S * |[2]     |OSC22M_EN |Internal 22.1184 MHz High Speed Oscillator (HIRC) Enable Control (Write Protect)
S * |        |          |0 = Internal 22.1184 MHz high speed oscillator (HIRC) Disabled.
S * |        |          |1 = Internal 22.1184 MHz high speed oscillator (HIRC) Enabled.
S * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register. 
S * |[3]     |OSC10K_EN |Internal 10 KHz Low Speed Oscillator (LIRC) Enable Control (Write Protect)
S * |        |          |0 = Internal 10 kHz low speed oscillator (LIRC) Disabled.
S * |        |          |1 = Internal 10 kHz low speed oscillator (LIRC) Enabled.
S * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register.
S * |[4]     |PD_WU_DLY |Wake-up Delay Counter Enable Control (Write Protect)
S * |        |          |When the chip wakes up from Power-down mode, the clock control will delay certain clock cycles
S * |        |          |to wait system clock stable.
S * |        |          |The delayed clock cycle is 4096 clock cycles when chip work at external 4~24 MHz high speed
S * |        |          |crystal, and 256 clock cycles when chip work at internal 22.1184 MHz high speed oscillator.
S * |        |          |0 = Clock cycles delay Disabled.
S * |        |          |1 = Clock cycles delay Enabled.
S * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register.
S * |[5]     |PD_WU_INT_EN|Power-Down Mode Wake-Up Interrupt Enable Control (Write Protect)
S * |        |          |0 = Power-down mode wake-up interrupt Disabled.
S * |        |          |1 = Power-down mode wake-up interrupt Enabled.
S * |        |          |Note1: The interrupt will occur when both PD_WU_STS and PD_WU_INT_EN are high.
S * |        |          |Note2: This bit is write protected bit. Refer to the REGWRPROT register.
S * |[6]     |PD_WU_STS |Power-Down Mode Wake-Up Interrupt Status
S * |        |          |Set by "Power-down wake-up event", it indicates that resume from Power-down mode.
S * |        |          |The flag is set if the GPIO, USB, UART, WDT, I2C, TIMER, ACMP, BOD or RTC wake-up occurred.
S * |        |          |Write 1 to clear the bit to 0.
S * |        |          |Note: This bit is working only if PD_WU_INT_EN (PWRCON[5]) set to 1.
S * |[7]     |PWR_DOWN_EN|System Power-Down Enable Bit (Write Protect)
S * |        |          |When this bit is set to 1, Power-down mode is enabled and chip Power-down behavior willdepends
S * |        |          |on the PD_WAIT_CPU bit.
S * |        |          |(a) If the PD_WAIT_CPU is 0, then the chip enters Power-down mode immediately after the
S * |        |          |PWR_DOWN_EN bit set.
S * |        |          |(b) if the PD_WAIT_CPU is 1, then the chip keeps active till the CPU sleep mode is also active
S * |        |          |and then the chip enters Power-down mode. (recommend)
S * |        |          |When chip wakes up from Power-down mode, this bit is cleared by hardware.
S * |        |          |User needs to set this bit again for next Power-down.
S * |        |          |In Power-down mode, external 4~24 MHz high speed crystal oscillator and the internal 22.1184 MHz
S * |        |          |high speed oscillator will be disabled in this mode, 
S * |        |          |but the external 32.768 kHz low speed crystal and internal 10 kHz low speed oscillator are not
S * |        |          |controlled by Power-down mode.
S * |        |          |In Power- down mode, the PLL and system clock are disabled, and ignored the clock source
S * |        |          |selection.
S * |        |          |The clocks of peripheral are not controlled by Power-down mode, if the peripheral clock source
S * |        |          |is from external 32.768 kHz low speed crystal oscillator or the internal 10 kHz low speed
S * |        |          |oscillator.
S * |        |          |0 = Chip operating normally or chip in Idle mode because of WFI command.
S * |        |          |1 = Chip enters Power-down mode instantly or waits CPU sleep command WFI.
S * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register.
S * |[8]     |PD_WAIT_CPU|This Bit Control The Power-Down Entry Condition (Write Protect)
S * |        |          |0 = Chip enters Power-down mode when the PWR_DOWN_EN bit is set to 1.
S * |        |          |1 = Chip enters Power- down mode when the both PD_WAIT_CPU and PWR_DOWN_EN bits are set to 1 and
S * |        |          |CPU run WFI instruction.
S * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register.
S * @var CLK_T::AHBCLK
S * Offset: 0x04  AHB Devices Clock Enable Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[1]     |PDMA_EN   |PDMA Controller Clock Enable Control
S * |        |          |0 = PDMA peripherial clock Disabled.
S * |        |          |1 = PDMA peripherial clock Enabled.
S * |[2]     |ISP_EN    |Flash ISP Controller Clock Enable Control
S * |        |          |0 = Flash ISP peripheral clock Disabled.
S * |        |          |1 = Flash ISP peripheral clock Enabled.    
S * |[3]     |EBI_EN    |EBI Controller Clock Enable Control
S * |        |          |0 = EBI peripherial clock Disabled.
S * |        |          |1 = EBI peripherial clock Enabled.
S * @var CLK_T::APBCLK
S * Offset: 0x08  APB Devices Clock Enable Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |WDT_EN    |Watchdog Timer Clock Enable Control (Write Protect)
S * |        |          |0 = Watchdog Timer clock Disabled.
S * |        |          |1 = Watchdog Timer clock Enabled.
S * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register.
S * |[1]     |RTC_EN    |Real-Time-Clock APB Interface Clock Enable Control
S * |        |          |This bit is used to control the RTC APB clock only, The RTC peripheral clock source is selected
S * |        |          |from RTC_SEL_10K(CLKSEL2[18]).
S * |        |          |It can be selected to the external 32.768 kHz low speed crystal or Internal 10 kHz low speed
S * |        |          |oscillator.
S * |        |          |0 = RTC clock Disabled.
S * |        |          |1 = RTC clock Enabled.
S * |[2]     |TMR0_EN   |Timer0 Clock Enable Control
S * |        |          |0 = Timer0 clock Disabled.
S * |        |          |1 = Timer0 clock Enabled.
S * |[3]     |TMR1_EN   |Timer1 Clock Enable Control
S * |        |          |0 = Timer1 clock Disabled.
S * |        |          |1 = Timer1 clock Enabled.
S * |[4]     |TMR2_EN   |Timer2 Clock Enable Control
S * |        |          |0 = Timer2 clock Disabled.
S * |        |          |1 = Timer2 clock Enabled.
S * |[5]     |TMR3_EN   |Timer3 Clock Enable Control
S * |        |          |0 = Timer3 clock Disabled.
S * |        |          |1 = Timer3 clock Enabled.
S * |[6]     |FDIV_EN   |Frequency Divider Output Clock Enable Control
S * |        |          |0 = FDIV clock Disabled.
S * |        |          |1 = FDIV clock Enabled.
S * |[8]     |I2C0_EN   |I2C0 Clock Enable Control
S * |        |          |0 = I2C0 clock Disabled.
S * |        |          |1 = I2C0 clock Enabled.
S * |[9]     |I2C1_EN   |I2C1 Clock Enable Control
S * |        |          |0 = I2C1 clock Disabled.
S * |        |          |1 = I2C1 clock Enabled.
S * |[12]    |SPI0_EN   |SPI0 Clock Enable Control
S * |        |          |0 = SPI0 clock Disabled.
S * |        |          |1 = SPI0 clock Enabled.
S * |[13]    |SPI1_EN   |SPI1 Clock Enable Control
S * |        |          |0 = SPI1 clock Disabled.
S * |        |          |1 = SPI1 clock Enabled.
S * |[14]    |SPI2_EN   |SPI2 Clock Enable Control
S * |        |          |0 = SPI2 clock Disabled.
S * |        |          |1 = SPI2 clock Enabled.
S * |[15]    |SPI3_EN   |SPI3 Clock Enable Control
S * |        |          |0 = SPI3 clock Disabled.
S * |        |          |1 = SPI3 clock Enabled.
S * |[16]    |UART0_EN  |UART0 Clock Enable Control
S * |        |          |0 = UART0 clock Disabled.
S * |        |          |1 = UART0 clock Enabled.
S * |[17]    |UART1_EN  |UART1 Clock Enable Control
S * |        |          |0 = UART1 clock Disabled.
S * |        |          |1 = UART1 clock Enabled.
S * |[18]    |UART2_EN  |UART2 Clock Enable Control
S * |        |          |0 = UART2 clock Disabled.
S * |        |          |1 = UART2 clock Enabled.
S * |[20]    |PWM01_EN  |PWM_01 Clock Enable Control
S * |        |          |0 = PWM01 clock Disabled.
S * |        |          |1 = PWM01 clock Enabled.
S * |[21]    |PWM23_EN  |PWM_23 Clock Enable Control
S * |        |          |0 = PWM23 clock Disabled.
S * |        |          |1 = PWM23 clock Enabled.
S * |[22]    |PWM45_EN  |PWM_45 Clock Enable Control
S * |        |          |0 = PWM45 clock Disabled.
S * |        |          |1 = PWM45 clock Enabled.
S * |[23]    |PWM67_EN  |PWM_67 Clock Enable Control
S * |        |          |0 = PWM67 clock Disabled.
S * |        |          |1 = PWM67 clock Enabled.
S * |[24]    |CAN0_EN   |CAN Bus Controller-0 Clock Enable Control
S * |        |          |0 = CAN0 clock Disabled.
S * |        |          |1 = CAN0 clock Enable.
S * |[25]    |CAN1_EN   |CAN Bus Controller-1 Clock Enable Control
S * |        |          |0 = CAN1 clock Disable.
S * |        |          |1 = CAN1 clock Enabled.
S * |[27]    |USBD_EN   |USB 2.0 FS Device Controller Clock Enable Control
S * |        |          |0 = USB clock Disabled.
S * |        |          |1 = USB clock Enabled.
S * |[28]    |ADC_EN    |Analog-Digital-Converter (ADC) Clock Enable Control
S * |        |          |0 = ADC clock Disabled.
S * |        |          |1 = ADC clock Enabled.
S * |[29]    |I2S_EN    |I2S Clock Enable Control
S * |        |          |0 = I2S clock Disabled.
S * |        |          |1 = I2S clock Enabled.
S * |[30]    |ACMP_EN   |Analog Comparator Clock Enable Control
S * |        |          |0 = Analog Comparator clock Disabled.
S * |        |          |1 = Analog Comparator clock Enabled.
S * |[31]    |PS2_EN    |PS/2 Clock Enable Control
S * |        |          |0 = PS/2 clock Disabled.
S * |        |          |1 = PS/2 clock Enabled.
S * @var CLK_T::CLKSTATUS
S * Offset: 0x0C  Clock status monitor Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |XTL12M_STB|External 4~24 MHz High Speed Crystal (HXT) Clock Source Stable Flag (Read Only)
S * |        |          |0 = External 4~24 MHz high speed crystal clock (HXT) is not stable or disabled.
S * |        |          |1 = External 4~24 MHz high speed crystal clock (HXT) is stable and enabled.
S * |[1]     |XTL32K_STB|External 32.768 KHz Low Speed Crystal (LXT) Clock Source Stable Flag(Read Only)
S * |        |          |0 = External 32.768 kHz low speed crystal (LXT) clock is not stable or disabled.
S * |        |          |1 = External 32.768 kHz low speed crystal (LXT) clock is stable and enabled.
S * |[2]     |PLL_STB   |Internal PLL Clock Source Stable Flag (Read Only)
S * |        |          |0 = Internal PLL clock is not stable or disabled.
S * |        |          |1 = Internal PLL clock is stable in normal mode.
S * |[3]     |OSC10K_STB|Internal 10 KHz Low Speed Oscillator (LIRC) Clock Source Stable Flag (Read Only)
S * |        |          |0 = Internal 10 kHz low speed oscillator clock (LIRC) is not stable or disabled.
S * |        |          |1 = Internal 10 kHz low speed oscillator clock (LIRC) is stable and enabled.
S * |[4]     |OSC22M_STB|Internal 22.1184 MHz High Speed Oscillator (HIRC) Clock Source Stable Flag (Read Only)
S * |        |          |0 = Internal 22.1184 MHz high speed oscillator (HIRC) clock is not stable or disabled.
S * |        |          |1 = Internal 22.1184 MHz high speed oscillator (HIRC) clock is stable and enabled.
S * |[7]     |CLK_SW_FAIL|Clock Switching Fail Flag (Read Only)
S * |        |          |0 = Clock switching success.
S * |        |          |1 = Clock switching failure.
S * |        |          |This bit is an index that if current system clock source is match as user defined at HCLK_S
S * |        |          |(CLKSEL[2:0]).
S * |        |          |When user switch system clock, the system clock source will keep old clock until the new clock
S * |        |          |is stable.
S * |        |          |During the period that waiting new clock stable, this bit will be an index shows system clock
S * |        |          |source is not match as user wanted.
S * @var CLK_T::CLKSEL0
S * Offset: 0x10  Clock Source Select Control Register 0
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[2:0]   |HCLK_S    |HCLK Clock Source Selection (Write Protect)
S * |        |          |1. Before clock switching, the related clock sources (both pre-select and new-select) must be
S * |        |          |turn on.
S * |        |          |2. The 3-bit default value is reloaded from the value of CFOSC (Config0[26:24]) in user
S * |        |          |configuration register of Flash controller by any reset. Therefore the default value is either
S * |        |          |000b or 111b.
S * |        |          |000 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
S * |        |          |001 = Clock source from external 32.768 kHz low speed crystal oscillator clock.
S * |        |          |010 = Clock source from PLL clock.
S * |        |          |011 = Clock source from internal 10 kHz low speed oscillator clock.
S * |        |          |111 = Clock source from internal 22.1184 MHz high speed oscillator clock.
S * |        |          |Note: These bits are write protected bit. Refer to the REGWRPROT register.
S * |[5:3]   |STCLK_S   |Cortex-M0 SysTick Clock Source Selection (Write Protect)
S * |        |          |If SYST_CSR[2] = 1, SysTick clock source is from HCLK.
S * |        |          |If SYST_CSR[2] = 0, SysTick clock source is defined by STCLK_S(CLKSEL0[5:3]).
S * |        |          |000 = Clock source from external 4~24 MHz high speed crystal clock.
S * |        |          |001 = Clock source from external 32.768 kHz low speed crystal clock.
S * |        |          |010 = Clock source from external 4~24 MHz high speed crystal clock/2.
S * |        |          |011 = Clock source from HCLK/2.
S * |        |          |111 = Clock source from internal 22.1184 MHz high speed oscillator clock/2.
S * |        |          |Note1: These bits are write protected bit. Refer to the REGWRPROT register.
S * |        |          |Note2: if SysTick clock source is not from HCLK (i.e. SYST_CSR[2] = 0), SysTick clock source
S * |        |          |must less than or equal to HCLK/2.
S * @var CLK_T::CLKSEL1
S * Offset: 0x14  Clock Source Select Control Register 1
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[1:0]   |WDT_S     |Watchdog Timer Clock Source Select (Write Protect)
S * |        |          |00 = Reserved.
S * |        |          |01 = Clock source from external 32.768 kHz low speed crystal oscillator clock.
S * |        |          |10 = Clock source from HCLK/2048 clock.
S * |        |          |11 = Clock source from internal 10 kHz low speed oscillator clock.
S * |        |          |Note: These bits are write protected bit. Refer to the REGWRPROT register.
S * |[3:2]   |ADC_S     |ADC Clock Source Select
S * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
S * |        |          |01 = Clock source from PLL clock.
S * |        |          |10 = Clock source from HCLK.
S * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
S * |[4]     |SPI0_S    |SPI0 Clock Source Selection
S * |        |          |0 = Clock source from PLL clock.
S * |        |          |1 = Clock source from HCLK.
S * |[5]     |SPI1_S    |SPI1 Clock Source Selection
S * |        |          |0 = Clock source from PLL clock.
S * |        |          |1 = Clock source from HCLK.
S * |[6]     |SPI2_S    |SPI2 Clock Source Selection
S * |        |          |0 = Clock source from PLL clock.
S * |        |          |1 = Clock source from HCLK.
S * |[7]     |SPI3_S    |SPI3 Clock Source Selection
S * |        |          |0 = Clock source from PLL clock.
S * |        |          |1 = Clock source from HCLK.
S * |[10:8]  |TMR0_S    |TIMER0 Clock Source Selection
S * |        |          |000 = Clock source from external 4~24 MHz high speed crystal clock.
S * |        |          |001 = Clock source from external 32.768 kHz low speed crystal clock.
S * |        |          |010 = Clock source from HCLK.
S * |        |          |011 = Clock source from external trigger.
S * |        |          |101 = Clock source from internal 10 kHz low speed oscillator clock.
S * |        |          |111 = Clock source from internal 22.1184 MHz high speed oscillator clock.
S * |        |          |Others = Reserved.
S * |[14:12] |TMR1_S    |TIMER1 Clock Source Selection
S * |        |          |000 = Clock source from external 4~24 MHz high speed crystal clock.
S * |        |          |001 = Clock source from external 32.768 kHz low speed crystal clock.
S * |        |          |010 = Clock source from HCLK.
S * |        |          |011 = Clock source from external trigger.
S * |        |          |101 = Clock source from internal 10 kHz low speed oscillator clock.
S * |        |          |111 = Clock source from internal 22.1184 MHz high speed oscillator clock.
S * |        |          |Others = Reserved.
S * |[18:16] |TMR2_S    |TIMER2 Clock Source Selection
S * |        |          |000 = Clock source from external 4~24 MHz high speed crystal clock.
S * |        |          |001 = Clock source from external 32.768 kHz low speed crystal clock.
S * |        |          |010 = Clock source from HCLK.
S * |        |          |011 = Clock source from external trigger.
S * |        |          |101 = Clock source from internal 10 kHz low speed oscillator clock.
S * |        |          |111 = Clock source from internal 22.1184 MHz high speed oscillator clock.
S * |        |          |Others = Reserved.
S * |[22:20] |TMR3_S    |TIMER3 Clock Source Selection
S * |        |          |000 = Clock source from external 4~24 MHz high speed crystal clock.
S * |        |          |001 = Clock source from external 32.768 kHz low speed crystal clock.
S * |        |          |010 = Clock source from HCLK.
S * |        |          |011 = Clock source from external trigger.
S * |        |          |101 = Clock source from internal 10 kHz low speed oscillator clock.
S * |        |          |111 = Clock source from internal 22.1184 MHz high speed oscillator clock.
S * |        |          |Others = Reserved.
S * |[25:24] |UART_S    |UART Clock Source Selection
S * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
S * |        |          |01 = Clock source from PLL clock.
S * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
S * |[29:28] |PWM01_S   |PWM0 And PWM1 Clock Source Selection
S * |        |          |PWM0 and PWM1 used the same clock source; both of them used the same prescaler.
S * |        |          |The clock source of PWM0 and PWM1 is defined by PWM01_S (CLKSEL1[29:28]) and PWM01_S_E
S * |        |          |(CLKSEL2[8]).
S * |        |          |If PWM01_S_E = 0, the clock source of PWM0 and PWM1 defined by PWM01_S list below:
S * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
S * |        |          |01 = Clock source from external 32.768 kHz low speed crystal oscillator clock.
S * |        |          |10 = Clock source from HCLK.
S * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
S * |        |          |If PWM01_S_E = 1, the clock source of PWM0 and PWM1 defined by PWM01_S list below:
S * |        |          |00 = Reserved.
S * |        |          |01 = Reserved.
S * |        |          |10 = Reserved.
S * |        |          |11 = Clock source from internal 10 kHz low speed oscillator clock.
S * |[31:30] |PWM23_S   |PWM2 And PWM3 Clock Source Selection
S * |        |          |PWM2 and PWM3 used the same clock source; both of them used the same prescaler.
S * |        |          |The clock source of PWM2 and PWM3 is defined by PWM23_S (CLKSEL1[31:30]) and PWM23_S_E
S * |        |          |(CLKSEL2[9]).
S * |        |          |If PWM23_S_E = 0, the clock source of PWM2 and PWM3 defined by PWM23_S list below:
S * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
S * |        |          |01 = Clock source from external 32.768 kHz low speed crystal oscillator clock.
S * |        |          |10 = Clock source from HCLK.
S * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
S * |        |          |If PWM23_S_E = 1, the clock source of PWM2 and PWM3 defined by PWM23_S list below:
S * |        |          |00 = Reserved.
S * |        |          |01 = Reserved.
S * |        |          |10 = Reserved.
S * |        |          |11 = Clock source from internal 10 kHz low speed oscillator clock.
S * @var CLK_T::CLKDIV
S * Offset: 0x18  Clock Divider Number Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |HCLK_N    |HCLK Clock Divide Number From HCLK Clock Source
S * |        |          |HCLK clock frequency = (HCLK clock source frequency) / (HCLK_N + 1).
S * |[7:4]   |USB_N     |USB Clock Divide Number From PLL Clock
S * |        |          |USB clock frequency = (PLL frequency) / (USB_N + 1).
S * |[11:8]  |UART_N    |UART Clock Divide Number From UART Clock Source
S * |        |          |UART clock frequency = (UART clock source frequency) / (UART_N + 1).
S * |[23:16] |ADC_N     |ADC Clock Divide Number From ADC Clock Source
S * |        |          |ADC clock frequency = (ADC clock source frequency) / (ADC_N + 1).
S * @var CLK_T::CLKSEL2
S * Offset: 0x1C  Clock Source Select Control Register 2
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[1:0]   |I2S_S     |I2S Clock Source Selection
S * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
S * |        |          |01 = Clock source from PLL clock.
S * |        |          |10 = Clock source from HCLK.
S * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
S * |[3:2]   |FRQDIV_S  |Clock Divider Clock Source Selection
S * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
S * |        |          |01 = Clock source from external 32.768 kHz low speed crystal oscillator clock.
S * |        |          |10 = Clock source from HCLK.
S * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
S * |[5:4]   |PWM45_S   |PWM4 And PWM5 Clock Source Selection
S * |        |          |PWM4 and PWM5 used the same clock source; both of them used the same prescaler.
S * |        |          |The clock source of PWM4 and PWM5 is defined by PWM45_S (CLKSEL2[5:4]) and PWM45_S_E
S * |        |          |(CLKSEL2[10]).
S * |        |          |If PWM45_S_E = 0, the clock source of PWM4 and PWM5 defined by PWM45_S list below:
S * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
S * |        |          |01 = Clock source from external 32.768 kHz low speed crystal oscillator clock.
S * |        |          |10 = Clock source from HCLK.
S * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
S * |        |          |If PWM45_S_E = 1, the clock source of PWM4 and PWM5 defined by PWM45_S list below:
S * |        |          |00 = Reserved.
S * |        |          |01 = Reserved.
S * |        |          |10 = Reserved.
S * |        |          |11 = Clock source from internal 10 kHz low speed oscillator clock.
S * |[7:6]   |PWM67_S   |PWM6 And PWM7 Clock Source Selection
S * |        |          |PWM6 and PWM7 used the sameclock source; both of them used the same prescaler.
S * |        |          |The clock source of PWM6 and PWM7 is defined by PWM67_S (CLKSEL2[7:6]) and PWM67_S_E
S * |        |          |(CLKSEL2[11]).
S * |        |          |If PWM67_S_E = 0, the clock source of PWM6 and PWM7 defined by PWM67_S list below:
S * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
S * |        |          |01 = Clock source from external 32.768 kHz low speed crystal oscillator clock.
S * |        |          |10 = Clock source from HCLK.
S * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
S * |        |          |If PWM67_S_E = 1, the clock source of PWM6 and PWM7 defined by PWM67_S list below:
S * |        |          |00 = Reserved.
S * |        |          |01 = Reserved.
S * |        |          |10 = Reserved.
S * |        |          |11 = Clock source from internal 10 kHz low speed oscillator clock.
S * |[8]     |PWM01_S_E |PWM0 And PWM1 Clock Source Selection Extend
S * |        |          |PWM0 and PWM1 used the same clock source; both of them used the same prescaler.
S * |        |          |The clock source of PWM0 and PWM1 is defined by PWM01_S (CLKSEL1[29:28]) and PWM01_S_E
S * |        |          |(CLKSEL2[8]).
S * |        |          |If PWM01_S_E = 0, the clock source of PWM0 and PWM1 defined by PWM01_S list below:
S * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
S * |        |          |01 = Clock source from external 32.768 kHz low speed crystal oscillator clock.
S * |        |          |10 = Clock source from HCLK.
S * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
S * |        |          |If PWM01_S_E = 1, the clock source of PWM0 and PWM1 defined by PWM01_S list below:
S * |        |          |00 = Reserved.
S * |        |          |01 = Reserved.
S * |        |          |10 = Reserved.
S * |        |          |11 = Clock source from internal 10 kHz low speed oscillator clock.
S * |[9]     |PWM23_S_E |PWM2 And PWM3 Clock Source Selection Extend
S * |        |          |PWM2 and PWM3 used the same clock source; both of them used the same prescaler.
S * |        |          |The clock source of PWM2 and PWM3 is defined by PWM23_S (CLKSEL1[31:30]) and PWM23_S_E
S * |        |          |(CLKSEL2[9]).
S * |        |          |If PWM23_S_E = 0, the clock source of PWM2 and PWM3 defined by PWM23_S list below:
S * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
S * |        |          |01 = Clock source from external 32.768 kHz low speed crystal oscillator clock.
S * |        |          |10 = Clock source from HCLK.
S * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
S * |        |          |If PWM23_S_E = 1, the clock source of PWM2 and PWM3 defined by PWM23_S listbelow:
S * |        |          |00 = Reserved.
S * |        |          |01 = Reserved.
S * |        |          |10 = Reserved.
S * |        |          |11 = Clock source from internal 10 kHz low speed oscillator clock.
S * |[10]    |PWM45_S_E |PWM4 And PWM5 Clock Source Selection Extend
S * |        |          |PWM4 and PWM5 used the same clock source; both of them used the same prescaler.
S * |        |          |The clock source of PWM4 and PWM5 is defined by PWM45_S (CLKSEL2[5:4]) and PWM45_S_E
S * |        |          |(CLKSEL2[10]).
S * |        |          |If PWM45_S_E = 0, the clock source of PWM4 and PWM5 defined by PWM45_S list below:
S * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
S * |        |          |01 = Clock source from external 32.768 kHz low speed crystal oscillator clock.
S * |        |          |10 = Clock source from HCLK.
S * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
S * |        |          |If PWM45_S_E = 1, the clock source of PWM4 and PWM5 defined by PWM45_S list below:
S * |        |          |00 = Reserved.
S * |        |          |01 = Reserved.
S * |        |          |10 = Reserved.
S * |        |          |11 = Clock source from internal 10 kHz low speed oscillator clock.
S * |[11]    |PWM67_S_E |PWM6 And PWM7 Clock Source Selection Extend
S * |        |          |PWM6 and PWM7 used the same clock source; both of them used the same prescaler.
S * |        |          |The clock source of PWM6 and PWM7 is defined by PWM67_S (CLKSEL2[7:6]) and PWM67_S_E
S * |        |          |(CLKSEL2[11]).
S * |        |          |If PWM67_S_E = 0, the peripheral clock source of PWM6 and PWM7 defined by PWM67_S list below:
S * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
S * |        |          |01 = Clock source from external 32.768 kHz low speed crystal oscillator clock.
S * |        |          |10 = Clock source from HCLK.
S * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
S * |        |          |If PWM67_S_E = 1, the clock source of PWM6 and PWM7 defined by PWM67_S list below:
S * |        |          |00 = Reserved.
S * |        |          |01 = Reserved.
S * |        |          |10 = Reserved.
S * |        |          |11 = Clock source from internal 10 kHz low speed oscillator clock.
S * |[17:16] |WWDT_S    |Window Watchdog Timer Clock Source Selection
S * |        |          |10 = Clock source from HCLK/2048 clock.
S * |        |          |11 = Clock source from internal 10 kHz low speed oscillator clock.
S * |[18]    |RTC_SEL_10K|RTC Clock Source Selection
S * |        |          |0 = External XTL32K.
S * |        |          |1 = Internal IRC 10K.
S * @var CLK_T::PLLCON
S * Offset: 0x20  PLL Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[8:0]   |FB_DV     |PLL Feedback Divider Control Bits
S * |        |          |Refer to the PLL formulas.
S * |[13:9]  |IN_DV     |PLL Input Divider Control Bits
S * |        |          |Refer to the PLL formulas.
S * |[15:14] |OUT_DV    |PLL Output Divider Control Bits
S * |        |          |Refer to the PLL formulas.
S * |[16]    |PD        |Power-Down Mode
S * |        |          |If the PWR_DOWN_EN bit is set to 1 in PWRCON register, the PLL will enter Power-down mode too. 
S * |        |          |0 = PLL is in Normal mode.
S * |        |          |1 = PLL is in Power-down mode (default).
S * |[17]    |BP        |PLL Bypass Control
S * |        |          |0 = PLL is in Normal mode (default).
S * |        |          |1 = PLL clock output is same as PLL source clock input.
S * |[18]    |OE        |PLL OE (FOUT Enable) Control
S * |        |          |0 = PLL FOUT Enabled.
S * |        |          |1 = PLL FOUT is fixed low.
S * |[19]    |PLL_SRC   |PLL Source Clock Selection
S * |        |          |0 = PLL source clock from external 4~24 MHz high speed crystal.
S * |        |          |1 = PLL source clock from internal 22.1184 MHz high speed oscillator.
S * @var CLK_T::FRQDIV
S * Offset: 0x24  Frequency Divider Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |FSEL      |Divider Output Frequency Selection Bits
S * |        |          |The formula of output frequency is Fout = Fin/2(N+1).
S * |        |          |Fin is the input clock frequency.
S * |        |          |Fout is the frequency of divider output clock.
S * |        |          |N is the 4-bit value of FSEL[3:0].
S * |[4]     |DIVIDER_EN|Frequency Divider Enable Bit
S * |        |          |0 = Frequency Divider function Disabled.
S * |        |          |1 = Frequency Divider function Enabled.
S * |[5]     |DIVIDER1  |Frequency Divider One Enable Bit
S * |        |          |0 = Frequency divider will output clock with source frequency divided by FSEL.
S * |        |          |1 = Frequency divider will output clock with source frequency.
S * |[6]     |CLKO_1HZ_EN|Clock Output 1Hz Enable Bit
S * |        |          |0 = 1 Hz clock output for 32K frequency compensation Disabled.
S * |        |          |1 = 1 Hz clock output for 32K frequency compensation Enabled.
S * @var CLK_T::APBCLK1
S * Offset: 0x30  APB Devices Clock Enable Control Register 1
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |SC0_EN    |SC0 Clock Enable Control
S * |        |          |0 = SC0 Clock Disabled.
S * |        |          |1 = SC0 Clock Enabled.
S * |[1]     |SC1_EN    |SC1 Clock Enable Control
S * |        |          |0 = SC1 clock Disabled.
S * |        |          |1 = SC1 clock Enabled.
S * |[2]     |SC2_EN    |SC2 Clock Enable Control
S * |        |          |0 = SC2 clock Disabled.
S * |        |          |1 = SC2 clock Enabled.
S * @var CLK_T::CLKSEL3
S * Offset: 0x34  Clock Source Select Control Register 3
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[1:0]   |SC0_S     |SC0 Clock Source Selection
S * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
S * |        |          |01 = Clock source from PLL clock.
S * |        |          |10 = HCLK.
S * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
S * |[3:2]   |SC1_S     |SC1 Clock Source Selection
S * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
S * |        |          |01 = Clock source from PLL clock.
S * |        |          |10 = HCLK.
S * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
S * |[5:4]   |SC2_S     |SC2 Clock Source Selection
S * |        |          |00 = Clock source from external 4~24 MHz high speed crystal oscillator clock.
S * |        |          |01 = Clock source from PLL clock.
S * |        |          |10 = HCLK.
S * |        |          |11 = Clock source from internal 22.1184 MHz high speed oscillator clock.
S * @var CLK_T::CLKDIV1
S * Offset: 0x38  Clock Divider Number Register 1
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |SC0_N     |SC0 Clock Divide Number From SC0 Clock Source
S * |        |          |The SC0 clock frequency = (SC0 clock source frequency) / (SC0_N + 1).
S * |[15:8]  |SC1_N     |SC1 Clock Divide Number From SC1 Clock Source
S * |        |          |The SC1 clock frequency = (SC1 clock source frequency) / (SC1_N + 1).
S * |[23:16] |SC2_N     |SC2 Clock Divide Number From SC2 Clock Source
S * |        |          |The SC2 clock frequency = (SC2 clock source frequency) / (SC2_N + 1).
S */
S
S    __IO uint32_t PWRCON;        /* Offset: 0x00  System Power-down Control Register                                 */
S    __IO uint32_t AHBCLK;        /* Offset: 0x04  AHB Devices Clock Enable Control Register                          */
S    __IO uint32_t APBCLK;        /* Offset: 0x08  APB Devices Clock Enable Control Register                          */
S    __IO uint32_t CLKSTATUS;     /* Offset: 0x0C  Clock status monitor Register                                      */
S    __IO uint32_t CLKSEL0;       /* Offset: 0x10  Clock Source Select Control Register 0                             */
S    __IO uint32_t CLKSEL1;       /* Offset: 0x14  Clock Source Select Control Register 1                             */
S    __IO uint32_t CLKDIV;        /* Offset: 0x18  Clock Divider Number Register                                      */
S    __IO uint32_t CLKSEL2;       /* Offset: 0x1C  Clock Source Select Control Register 2                             */
S    __IO uint32_t PLLCON;        /* Offset: 0x20  PLL Control Register                                               */
S    __IO uint32_t FRQDIV;        /* Offset: 0x24  Frequency Divider Control Register                                 */
S    __IO uint32_t RESERVE[2];   
S    __IO uint32_t APBCLK1;       /* Offset: 0x30  APB Devices Clock Enable Control Register 1                        */
S    __IO uint32_t CLKSEL3;       /* Offset: 0x34  Clock Source Select Control Register 3                             */
S    __IO uint32_t CLKDIV1;       /* Offset: 0x38  Clock Divider Number Register 1                                    */
S
S} CLK_T;
S
S
S/**
S    @addtogroup CLK_CONST CLK Bit Field Definition
S    Constant Definitions for CLK Controller
S@{ */
S
S
S/* CLK PWRCON Bit Field Definitions */
S#define CLK_PWRCON_PD_WAIT_CPU_Pos           8                                    /*!< CLK_T::PWRCON: PD_WAIT_CPU Position */
S#define CLK_PWRCON_PD_WAIT_CPU_Msk           (1ul << CLK_PWRCON_PD_WAIT_CPU_Pos)  /*!< CLK_T::PWRCON: PD_WAIT_CPU Mask */
S
S#define CLK_PWRCON_PWR_DOWN_EN_Pos           7                                    /*!< CLK_T::PWRCON: PWR_DOWN_EN Position */
S#define CLK_PWRCON_PWR_DOWN_EN_Msk           (1ul << CLK_PWRCON_PWR_DOWN_EN_Pos)  /*!< CLK_T::PWRCON: PWR_DOWN_EN Mask */
S
S#define CLK_PWRCON_PD_WU_STS_Pos             6                                    /*!< CLK_T::PWRCON: PD_WU_STS Position */
S#define CLK_PWRCON_PD_WU_STS_Msk             (1ul << CLK_PWRCON_PD_WU_STS_Pos)    /*!< CLK_T::PWRCON: PD_WU_STS Mask */
S
S#define CLK_PWRCON_PD_WU_INT_EN_Pos          5                                    /*!< CLK_T::PWRCON: PD_WU_INT_EN Position */
S#define CLK_PWRCON_PD_WU_INT_EN_Msk          (1ul << CLK_PWRCON_PD_WU_INT_EN_Pos) /*!< CLK_T::PWRCON: PD_WU_INT_EN Mask */
S
S#define CLK_PWRCON_PD_WU_DLY_Pos             4                                    /*!< CLK_T::PWRCON: PD_WU_DLY Position */
S#define CLK_PWRCON_PD_WU_DLY_Msk             (1ul << CLK_PWRCON_PD_WU_DLY_Pos)    /*!< CLK_T::PWRCON: PD_WU_DLY Mask */
S
S#define CLK_PWRCON_OSC10K_EN_Pos             3                                    /*!< CLK_T::PWRCON: OSC10K_EN Position */
S#define CLK_PWRCON_OSC10K_EN_Msk             (1ul << CLK_PWRCON_OSC10K_EN_Pos)    /*!< CLK_T::PWRCON: OSC10K_EN Mask */
S#define CLK_PWRCON_IRC10K_EN_Pos             3                                    /*!< CLK_T::PWRCON: IRC10K_EN Position */
S#define CLK_PWRCON_IRC10K_EN_Msk             (1ul << CLK_PWRCON_IRC10K_EN_Pos)    /*!< CLK_T::PWRCON: IRC10K_EN Mask */
S
S#define CLK_PWRCON_OSC22M_EN_Pos             2                                    /*!< CLK_T::PWRCON: OSC22M_EN Position */
S#define CLK_PWRCON_OSC22M_EN_Msk             (1ul << CLK_PWRCON_OSC22M_EN_Pos)    /*!< CLK_T::PWRCON: OSC22M_EN Mask */
S#define CLK_PWRCON_IRC22M_EN_Pos             2                                    /*!< CLK_T::PWRCON: IRC22M_EN Position */
S#define CLK_PWRCON_IRC22M_EN_Msk             (1ul << CLK_PWRCON_IRC22M_EN_Pos)    /*!< CLK_T::PWRCON: IRC22M_EN Mask */
S
S#define CLK_PWRCON_XTL32K_EN_Pos             1                                    /*!< CLK_T::PWRCON: XTL32K_EN Position */
S#define CLK_PWRCON_XTL32K_EN_Msk             (1ul << CLK_PWRCON_XTL32K_EN_Pos)    /*!< CLK_T::PWRCON: XTL32K_EN Mask */
S
S#define CLK_PWRCON_XTL12M_EN_Pos             0                                    /*!< CLK_T::PWRCON: XTL12M_EN Position */
S#define CLK_PWRCON_XTL12M_EN_Msk             (1ul << CLK_PWRCON_XTL12M_EN_Pos)    /*!< CLK_T::PWRCON: XTL12M_EN Mask */
S
S/* CLK AHBCLK Bit Field Definitions */
S#define CLK_AHBCLK_EBI_EN_Pos                3                                    /*!< CLK_T::AHBCLK: EBI_EN Position */
S#define CLK_AHBCLK_EBI_EN_Msk                (1ul << CLK_AHBCLK_EBI_EN_Pos)       /*!< CLK_T::AHBCLK: EBI_EN Mask */
S
S#define CLK_AHBCLK_ISP_EN_Pos                2                                    /*!< CLK_T::AHBCLK: ISP_EN Position */
S#define CLK_AHBCLK_ISP_EN_Msk                (1ul << CLK_AHBCLK_ISP_EN_Pos)       /*!< CLK_T::AHBCLK: ISP_EN Mask */
S
S#define CLK_AHBCLK_PDMA_EN_Pos               1                                    /*!< CLK_T::AHBCLK: PDMA_EN Position */
S#define CLK_AHBCLK_PDMA_EN_Msk               (1ul << CLK_AHBCLK_PDMA_EN_Pos)      /*!< CLK_T::AHBCLK: PDMA_EN Mask */
S
S/* CLK APBCLK Bit Field Definitions */
S#define CLK_APBCLK_PS2_EN_Pos                31                                   /*!< CLK_T::APBCLK: PS2_EN Position */
S#define CLK_APBCLK_PS2_EN_Msk                (1ul << CLK_APBCLK_PS2_EN_Pos)       /*!< CLK_T::APBCLK: PS2_EN Mask */
S
S#define CLK_APBCLK_ACMP_EN_Pos               30                                   /*!< CLK_T::APBCLK: ACMP_EN Position */
S#define CLK_APBCLK_ACMP_EN_Msk               (1ul << CLK_APBCLK_ACMP_EN_Pos)      /*!< CLK_T::APBCLK: ACMP_EN Mask */
S
S#define CLK_APBCLK_I2S_EN_Pos                29                                   /*!< CLK_T::APBCLK: I2S_EN Position */
S#define CLK_APBCLK_I2S_EN_Msk                (1ul << CLK_APBCLK_I2S_EN_Pos)       /*!< CLK_T::APBCLK: I2S_EN Mask */
S
S#define CLK_APBCLK_ADC_EN_Pos                28                                   /*!< CLK_T::APBCLK: ADC_EN Position */
S#define CLK_APBCLK_ADC_EN_Msk                (1ul << CLK_APBCLK_ADC_EN_Pos)       /*!< CLK_T::APBCLK: ADC_EN Mask */
S
S#define CLK_APBCLK_USBD_EN_Pos               27                                   /*!< CLK_T::APBCLK: USBD_EN Position */
S#define CLK_APBCLK_USBD_EN_Msk               (1ul << CLK_APBCLK_USBD_EN_Pos)      /*!< CLK_T::APBCLK: USBD_EN Mask */
S
S#define CLK_APBCLK_CAN1_EN_Pos               25                                   /*!< CLK_T::APBCLK: CAN1_EN Position */
S#define CLK_APBCLK_CAN1_EN_Msk               (1ul << CLK_APBCLK_CAN1_EN_Pos)      /*!< CLK_T::APBCLK: CAN1_EN Mask */
S
S#define CLK_APBCLK_CAN0_EN_Pos               24                                   /*!< CLK_T::APBCLK: CAN0_EN Position */
S#define CLK_APBCLK_CAN0_EN_Msk               (1ul << CLK_APBCLK_CAN0_EN_Pos)      /*!< CLK_T::APBCLK: CAN0_EN Mask */
S
S#define CLK_APBCLK_PWM67_EN_Pos              23                                   /*!< CLK_T::APBCLK: PWM67_EN Position */
S#define CLK_APBCLK_PWM67_EN_Msk              (1ul << CLK_APBCLK_PWM67_EN_Pos)     /*!< CLK_T::APBCLK: PWM67_EN Mask */
S
S#define CLK_APBCLK_PWM45_EN_Pos              22                                   /*!< CLK_T::APBCLK: PWM45_EN Position */
S#define CLK_APBCLK_PWM45_EN_Msk              (1ul << CLK_APBCLK_PWM45_EN_Pos)     /*!< CLK_T::APBCLK: PWM45_EN Mask */
S
S#define CLK_APBCLK_PWM23_EN_Pos              21                                   /*!< CLK_T::APBCLK: PWM23_EN Position */
S#define CLK_APBCLK_PWM23_EN_Msk              (1ul << CLK_APBCLK_PWM23_EN_Pos)     /*!< CLK_T::APBCLK: PWM23_EN Mask */
S
S#define CLK_APBCLK_PWM01_EN_Pos              20                                   /*!< CLK_T::APBCLK: PWM01_EN Position */
S#define CLK_APBCLK_PWM01_EN_Msk              (1ul << CLK_APBCLK_PWM01_EN_Pos)     /*!< CLK_T::APBCLK: PWM01_EN Mask */
S
S#define CLK_APBCLK_UART2_EN_Pos              18                                   /*!< CLK_T::APBCLK: UART2_EN Position */
S#define CLK_APBCLK_UART2_EN_Msk              (1ul << CLK_APBCLK_UART2_EN_Pos)     /*!< CLK_T::APBCLK: UART2_EN Mask */
S
S#define CLK_APBCLK_UART1_EN_Pos              17                                   /*!< CLK_T::APBCLK: UART1_EN Position */
S#define CLK_APBCLK_UART1_EN_Msk              (1ul << CLK_APBCLK_UART1_EN_Pos)     /*!< CLK_T::APBCLK: UART1_EN Mask */
S
S#define CLK_APBCLK_UART0_EN_Pos              16                                   /*!< CLK_T::APBCLK: UART0_EN Position */
S#define CLK_APBCLK_UART0_EN_Msk              (1ul << CLK_APBCLK_UART0_EN_Pos)     /*!< CLK_T::APBCLK: UART0_EN Mask */
S
S#define CLK_APBCLK_SPI3_EN_Pos               15                                   /*!< CLK_T::APBCLK: SPI3_EN Position */
S#define CLK_APBCLK_SPI3_EN_Msk               (1ul << CLK_APBCLK_SPI3_EN_Pos)      /*!< CLK_T::APBCLK: SPI3_EN Mask */
S
S#define CLK_APBCLK_SPI2_EN_Pos               14                                   /*!< CLK_T::APBCLK: SPI2_EN Position */
S#define CLK_APBCLK_SPI2_EN_Msk               (1ul << CLK_APBCLK_SPI2_EN_Pos)      /*!< CLK_T::APBCLK: SPI2_EN Mask */
S
S#define CLK_APBCLK_SPI1_EN_Pos               13                                   /*!< CLK_T::APBCLK: SPI1_EN Position */
S#define CLK_APBCLK_SPI1_EN_Msk               (1ul << CLK_APBCLK_SPI1_EN_Pos)      /*!< CLK_T::APBCLK: SPI1_EN Mask */
S
S#define CLK_APBCLK_SPI0_EN_Pos               12                                   /*!< CLK_T::APBCLK: SPI0_EN Position */
S#define CLK_APBCLK_SPI0_EN_Msk               (1ul << CLK_APBCLK_SPI0_EN_Pos)      /*!< CLK_T::APBCLK: SPI0_EN Mask */
S
S#define CLK_APBCLK_I2C1_EN_Pos               9                                    /*!< CLK_T::APBCLK: I2C1_EN Position */
S#define CLK_APBCLK_I2C1_EN_Msk               (1ul << CLK_APBCLK_I2C1_EN_Pos)      /*!< CLK_T::APBCLK: I2C1_EN Mask */
S
S#define CLK_APBCLK_I2C0_EN_Pos               8                                    /*!< CLK_T::APBCLK: I2C0_EN_ Position */
S#define CLK_APBCLK_I2C0_EN_Msk               (1ul << CLK_APBCLK_I2C0_EN_Pos)      /*!< CLK_T::APBCLK: I2C0_EN_ Mask */
S
S#define CLK_APBCLK_FDIV_EN_Pos               6                                    /*!< CLK_T::APBCLK: FDIV_EN Position */
S#define CLK_APBCLK_FDIV_EN_Msk               (1ul << CLK_APBCLK_FDIV_EN_Pos)      /*!< CLK_T::APBCLK: FDIV_EN Mask */
S
S#define CLK_APBCLK_TMR3_EN_Pos               5                                    /*!< CLK_T::APBCLK: TMR3_EN Position */
S#define CLK_APBCLK_TMR3_EN_Msk               (1ul << CLK_APBCLK_TMR3_EN_Pos)      /*!< CLK_T::APBCLK: TMR3_EN Mask */
S
S#define CLK_APBCLK_TMR2_EN_Pos               4                                    /*!< CLK_T::APBCLK: TMR2_EN Position */
S#define CLK_APBCLK_TMR2_EN_Msk               (1ul << CLK_APBCLK_TMR2_EN_Pos)      /*!< CLK_T::APBCLK: TMR2_EN Mask */
S
S#define CLK_APBCLK_TMR1_EN_Pos               3                                    /*!< CLK_T::APBCLK: TMR1_EN Position */
S#define CLK_APBCLK_TMR1_EN_Msk               (1ul << CLK_APBCLK_TMR1_EN_Pos)      /*!< CLK_T::APBCLK: TMR1_EN Mask */
S
S#define CLK_APBCLK_TMR0_EN_Pos               2                                    /*!< CLK_T::APBCLK: TMR0_EN Position */
S#define CLK_APBCLK_TMR0_EN_Msk               (1ul << CLK_APBCLK_TMR0_EN_Pos)      /*!< CLK_T::APBCLK: TMR0_EN Mask */
S
S#define CLK_APBCLK_RTC_EN_Pos                1                                    /*!< CLK_T::APBCLK: RTC_EN Position */
S#define CLK_APBCLK_RTC_EN_Msk                (1ul << CLK_APBCLK_RTC_EN_Pos)       /*!< CLK_T::APBCLK: RTC_EN Mask */
S
S#define CLK_APBCLK_WDT_EN_Pos                0                                    /*!< CLK_T::APBCLK: WDT_EN Position */
S#define CLK_APBCLK_WDT_EN_Msk                (1ul << CLK_APBCLK_WDT_EN_Pos)       /*!< CLK_T::APBCLK: WDT_EN Mask */
S
S/* CLK APBCLK1 Bit Field Definitions */
S#define CLK_APBCLK1_SC2_EN_Pos                2                                   /*!< CLK_T::APBCLK1: SC2_EN Position */
S#define CLK_APBCLK1_SC2_EN_Msk                (1ul << CLK_APBCLK1_SC2_EN_Pos)     /*!< CLK_T::APBCLK1: SC2_EN Mask */
S
S#define CLK_APBCLK1_SC1_EN_Pos                1                                   /*!< CLK_T::APBCLK1: SC1_EN Position */
S#define CLK_APBCLK1_SC1_EN_Msk                (1ul << CLK_APBCLK1_SC1_EN_Pos)     /*!< CLK_T::APBCLK1: SC1_EN Mask */
S
S#define CLK_APBCLK1_SC0_EN_Pos                0                                   /*!< CLK_T::APBCLK1: SC0_EN Position */
S#define CLK_APBCLK1_SC0_EN_Msk                (1ul << CLK_APBCLK1_SC0_EN_Pos)     /*!< CLK_T::APBCLK1: SC0_EN Mask */
S
S/* CLK CLKSTATUS Bit Field Definitions */
S#define CLK_CLKSTATUS_CLK_SW_FAIL_Pos        7                                        /*!< CLK_T::CLKSTATUS: CLK_SW_FAIL Position */
S#define CLK_CLKSTATUS_CLK_SW_FAIL_Msk        (1ul << CLK_CLKSTATUS_CLK_SW_FAIL_Pos)   /*!< CLK_T::CLKSTATUS: CLK_SW_FAIL Mask */
S
S#define CLK_CLKSTATUS_OSC22M_STB_Pos         4                                        /*!< CLK_T::CLKSTATUS: OSC22M_STB Position */
S#define CLK_CLKSTATUS_OSC22M_STB_Msk         (1ul << CLK_CLKSTATUS_OSC22M_STB_Pos)    /*!< CLK_T::CLKSTATUS: OSC22M_STB Mask */
S#define CLK_CLKSTATUS_IRC22M_STB_Pos         4                                        /*!< CLK_T::CLKSTATUS: IRC22M_STB Position */
S#define CLK_CLKSTATUS_IRC22M_STB_Msk         (1ul << CLK_CLKSTATUS_IRC22M_STB_Pos)    /*!< CLK_T::CLKSTATUS: IRC22M_STB Mask */
S
S#define CLK_CLKSTATUS_OSC10K_STB_Pos         3                                        /*!< CLK_T::CLKSTATUS: OSC10K_STB Position */
S#define CLK_CLKSTATUS_OSC10K_STB_Msk         (1ul << CLK_CLKSTATUS_OSC10K_STB_Pos)    /*!< CLK_T::CLKSTATUS: OSC10K_STB Mask */
S#define CLK_CLKSTATUS_IRC10K_STB_Pos         3                                        /*!< CLK_T::CLKSTATUS: IRC10K_STB Position */
S#define CLK_CLKSTATUS_IRC10K_STB_Msk         (1ul << CLK_CLKSTATUS_IRC10K_STB_Pos)    /*!< CLK_T::CLKSTATUS: IRC10K_STB Mask */
S
S#define CLK_CLKSTATUS_PLL_STB_Pos            2                                        /*!< CLK_T::CLKSTATUS: PLL_STB Position */
S#define CLK_CLKSTATUS_PLL_STB_Msk            (1ul << CLK_CLKSTATUS_PLL_STB_Pos)       /*!< CLK_T::CLKSTATUS: PLL_STB Mask */
S
S#define CLK_CLKSTATUS_XTL32K_STB_Pos         1                                        /*!< CLK_T::CLKSTATUS: XTL32K_STB Position */
S#define CLK_CLKSTATUS_XTL32K_STB_Msk         (1ul << CLK_CLKSTATUS_XTL32K_STB_Pos)    /*!< CLK_T::CLKSTATUS: XTL32K_STB Mask */
S
S#define CLK_CLKSTATUS_XTL12M_STB_Pos         0                                        /*!< CLK_T::CLKSTATUS: XTL12M_STB Position */
S#define CLK_CLKSTATUS_XTL12M_STB_Msk         (1ul << CLK_CLKSTATUS_XTL12M_STB_Pos)    /*!< CLK_T::CLKSTATUS: XTL12M_STB Mask */
S
S/* CLK CLKSEL0 Bit Field Definitions */
S#define CLK_CLKSEL0_STCLK_S_Pos              3                                        /*!< CLK_T::CLKSEL0: STCLK_S Position */
S#define CLK_CLKSEL0_STCLK_S_Msk              (7ul << CLK_CLKSEL0_STCLK_S_Pos)         /*!< CLK_T::CLKSEL0: STCLK_S Mask */
S
S#define CLK_CLKSEL0_HCLK_S_Pos               0                                        /*!< CLK_T::CLKSEL0: HCLK_S Position */
S#define CLK_CLKSEL0_HCLK_S_Msk               (7ul << CLK_CLKSEL0_HCLK_S_Pos)          /*!< CLK_T::CLKSEL0: HCLK_S Mask */
S
S/* CLK CLKSEL1 Bit Field Definitions */
S#define CLK_CLKSEL1_PWM23_S_Pos              30                                       /*!< CLK_T::CLKSEL1: PWM23_S Position */
S#define CLK_CLKSEL1_PWM23_S_Msk              (3ul << CLK_CLKSEL1_PWM23_S_Pos)         /*!< CLK_T::CLKSEL1: PWM23_S Mask */
S
S#define CLK_CLKSEL1_PWM01_S_Pos              28                                       /*!< CLK_T::CLKSEL1: PWM01_S Position */
S#define CLK_CLKSEL1_PWM01_S_Msk              (3ul << CLK_CLKSEL1_PWM01_S_Pos)         /*!< CLK_T::CLKSEL1: PWM01_S Mask */
S
S#define CLK_CLKSEL1_UART_S_Pos               24                                       /*!< CLK_T::CLKSEL1: UART_S Position */
S#define CLK_CLKSEL1_UART_S_Msk               (3ul << CLK_CLKSEL1_UART_S_Pos)          /*!< CLK_T::CLKSEL1: UART_S Mask */
S
S#define CLK_CLKSEL1_TMR3_S_Pos               20                                       /*!< CLK_T::CLKSEL1: TMR3_S Position */
S#define CLK_CLKSEL1_TMR3_S_Msk               (7ul << CLK_CLKSEL1_TMR3_S_Pos)          /*!< CLK_T::CLKSEL1: TMR3_S Mask */
S
S#define CLK_CLKSEL1_TMR2_S_Pos               16                                       /*!< CLK_T::CLKSEL1: TMR2_S Position */
S#define CLK_CLKSEL1_TMR2_S_Msk               (7ul << CLK_CLKSEL1_TMR2_S_Pos)          /*!< CLK_T::CLKSEL1: TMR2_S Mask */
S
S#define CLK_CLKSEL1_TMR1_S_Pos               12                                       /*!< CLK_T::CLKSEL1: TMR1_S Position */
S#define CLK_CLKSEL1_TMR1_S_Msk               (7ul << CLK_CLKSEL1_TMR1_S_Pos)          /*!< CLK_T::CLKSEL1: TMR1_S Mask */
S
S#define CLK_CLKSEL1_TMR0_S_Pos               8                                        /*!< CLK_T::CLKSEL1: TMR0_S Position */
S#define CLK_CLKSEL1_TMR0_S_Msk               (7ul << CLK_CLKSEL1_TMR0_S_Pos)          /*!< CLK_T::CLKSEL1: TMR0_S Mask */
S
S#define CLK_CLKSEL1_SPI3_S_Pos               7                                        /*!< CLK_T::CLKSEL1: SPI3_S Position */
S#define CLK_CLKSEL1_SPI3_S_Msk               (1ul << CLK_CLKSEL1_SPI3_S_Pos)          /*!< CLK_T::CLKSEL1: SPI3_S Mask */
S
S#define CLK_CLKSEL1_SPI2_S_Pos               6                                        /*!< CLK_T::CLKSEL1: SPI2_S Position */
S#define CLK_CLKSEL1_SPI2_S_Msk               (1ul << CLK_CLKSEL1_SPI2_S_Pos)          /*!< CLK_T::CLKSEL1: SPI2_S Mask */
S
S#define CLK_CLKSEL1_SPI1_S_Pos               5                                        /*!< CLK_T::CLKSEL1: SPI1_S Position */
S#define CLK_CLKSEL1_SPI1_S_Msk               (1ul << CLK_CLKSEL1_SPI1_S_Pos)          /*!< CLK_T::CLKSEL1: SPI1_S Mask */
S
S#define CLK_CLKSEL1_SPI0_S_Pos               4                                        /*!< CLK_T::CLKSEL1: SPI0_S Position */
S#define CLK_CLKSEL1_SPI0_S_Msk               (1ul << CLK_CLKSEL1_SPI0_S_Pos)          /*!< CLK_T::CLKSEL1: SPI0_S Mask */
S
S#define CLK_CLKSEL1_ADC_S_Pos                2                                        /*!< CLK_T::CLKSEL1: ADC_S Position */
S#define CLK_CLKSEL1_ADC_S_Msk                (3ul << CLK_CLKSEL1_ADC_S_Pos)           /*!< CLK_T::CLKSEL1: ADC_S Mask */
S
S#define CLK_CLKSEL1_WDT_S_Pos                0                                        /*!< CLK_T::CLKSEL1: WDT_S Position */
S#define CLK_CLKSEL1_WDT_S_Msk                (3ul << CLK_CLKSEL1_WDT_S_Pos)           /*!< CLK_T::CLKSEL1: WDT_S Mask */
S
S/* CLK CLKSEL2 Bit Field Definitions */
S#define CLK_CLKSEL2_RTC_SEL_10K_Pos          18                                       /*!< CLK_T::CLKSEL2: RTC_SEL_10K Position */
S#define CLK_CLKSEL2_RTC_SEL_10K_Msk          (1ul << CLK_CLKSEL2_RTC_SEL_10K_Pos)     /*!< CLK_T::CLKSEL2: RTC_SEL_10K Mask */
S
S#define CLK_CLKSEL2_WWDT_S_Pos               16                                       /*!< CLK_T::CLKSEL2: WWDT_S Position */
S#define CLK_CLKSEL2_WWDT_S_Msk               (3ul << CLK_CLKSEL2_WWDT_S_Pos)          /*!< CLK_T::CLKSEL2: WWDT_S Mask */
S
S#define CLK_CLKSEL2_PWM67_S_E_Pos            11                                       /*!< CLK_T::CLKSEL2: PWM67_S_E Position */
S#define CLK_CLKSEL2_PWM67_S_E_Msk            (1ul << CLK_CLKSEL2_PWM67_S_E_Pos)       /*!< CLK_T::CLKSEL2: PWM67_S_E Mask */
S#define CLK_CLKSEL2_PWM67_S_EXT_Pos          11                                       /*!< CLK_T::CLKSEL2: PWM67_S_E Position */
S#define CLK_CLKSEL2_PWM67_S_EXT_Msk          (1ul << CLK_CLKSEL2_PWM67_S_EXT_Pos)     /*!< CLK_T::CLKSEL2: PWM67_S_E Mask */
S
S#define CLK_CLKSEL2_PWM45_S_E_Pos            10                                       /*!< CLK_T::CLKSEL2: PWM45_S_E Position */
S#define CLK_CLKSEL2_PWM45_S_E_Msk            (1ul << CLK_CLKSEL2_PWM45_S_E_Pos)       /*!< CLK_T::CLKSEL2: PWM45_S_E Mask */
S#define CLK_CLKSEL2_PWM45_S_EXT_Pos          10                                       /*!< CLK_T::CLKSEL2: PWM45_S_EXT Position */
S#define CLK_CLKSEL2_PWM45_S_EXT_Msk          (1ul << CLK_CLKSEL2_PWM45_S_EXT_Pos)     /*!< CLK_T::CLKSEL2: PWM45_S_EXT Mask */
S
S#define CLK_CLKSEL2_PWM23_S_E_Pos            9                                        /*!< CLK_T::CLKSEL2: PWM23_S_E Position */
S#define CLK_CLKSEL2_PWM23_S_E_Msk            (1ul << CLK_CLKSEL2_PWM23_S_E_Pos)       /*!< CLK_T::CLKSEL2: PWM23_S_E Mask */
S#define CLK_CLKSEL2_PWM23_S_EXT_Pos          9                                        /*!< CLK_T::CLKSEL2: PWM23_S_EXT Position */
S#define CLK_CLKSEL2_PWM23_S_EXT_Msk          (1ul << CLK_CLKSEL2_PWM23_S_EXT_Pos)     /*!< CLK_T::CLKSEL2: PWM23_S_EXT Mask */
S
S#define CLK_CLKSEL2_PWM01_S_E_Pos            8                                        /*!< CLK_T::CLKSEL2: PWM01_S_E Position */
S#define CLK_CLKSEL2_PWM01_S_E_Msk            (1ul << CLK_CLKSEL2_PWM01_S_E_Pos)       /*!< CLK_T::CLKSEL2: PWM01_S_E Mask */
S#define CLK_CLKSEL2_PWM01_S_EXT_Pos          8                                        /*!< CLK_T::CLKSEL2: PWM01_S_EXT Position */
S#define CLK_CLKSEL2_PWM01_S_EXT_Msk          (1ul << CLK_CLKSEL2_PWM01_S_EXT_Pos)     /*!< CLK_T::CLKSEL2: PWM01_S_EXT Mask */
S
S#define CLK_CLKSEL2_PWM67_S_Pos              6                                        /*!< CLK_T::CLKSEL2: PWM67_S_ Position */
S#define CLK_CLKSEL2_PWM67_S_Msk              (3ul << CLK_CLKSEL2_PWM67_S_Pos)         /*!< CLK_T::CLKSEL2: PWM67_S_ Mask */
S
S#define CLK_CLKSEL2_PWM45_S_Pos              4                                        /*!< CLK_T::CLKSEL2: PWM45_S Position */
S#define CLK_CLKSEL2_PWM45_S_Msk              (3ul << CLK_CLKSEL2_PWM45_S_Pos)         /*!< CLK_T::CLKSEL2: PWM45_S Mask */
S
S#define CLK_CLKSEL2_FRQDIV_S_Pos             2                                        /*!< CLK_T::CLKSEL2: FRQDIV_S Position */
S#define CLK_CLKSEL2_FRQDIV_S_Msk             (3ul << CLK_CLKSEL2_FRQDIV_S_Pos)        /*!< CLK_T::CLKSEL2: FRQDIV_S Mask */
S
S#define CLK_CLKSEL2_I2S_S_Pos                0                                        /*!< CLK_T::CLKSEL2: I2S_S Position */
S#define CLK_CLKSEL2_I2S_S_Msk                (3ul << CLK_CLKSEL2_I2S_S_Pos)           /*!< CLK_T::CLKSEL2: I2S_S Mask */
S
S/* CLK CLKSEL3 Bit Field Definitions */
S#define CLK_CLKSEL3_SC2_S_Pos                4                                        /*!< CLK_T::CLKSEL3: SC2_S Position */
S#define CLK_CLKSEL3_SC2_S_Msk                (3ul << CLK_CLKSEL3_SC2_S_Pos)           /*!< CLK_T::CLKSEL3: SC2_S Mask */
S
S#define CLK_CLKSEL3_SC1_S_Pos                2                                        /*!< CLK_T::CLKSEL3: SC1_S Position */
S#define CLK_CLKSEL3_SC1_S_Msk                (3ul << CLK_CLKSEL3_SC1_S_Pos)           /*!< CLK_T::CLKSEL3: SC1_S Mask */
S
S#define CLK_CLKSEL3_SC0_S_Pos                0                                        /*!< CLK_T::CLKSEL3: SC0_S Position */
S#define CLK_CLKSEL3_SC0_S_Msk                (3ul << CLK_CLKSEL3_SC0_S_Pos)           /*!< CLK_T::CLKSEL3: SC0_S Mask */
S
S/* CLK CLKDIV Bit Field Definitions */
S#define CLK_CLKDIV_ADC_N_Pos                 16                                       /*!< CLK_T::CLKDIV: ADC_N Position */
S#define CLK_CLKDIV_ADC_N_Msk                 (0xFFul << CLK_CLKDIV_ADC_N_Pos)         /*!< CLK_T::CLKDIV: ADC_N Mask */
S
S#define CLK_CLKDIV_UART_N_Pos                8                                        /*!< CLK_T::CLKDIV: UART_N Position */
S#define CLK_CLKDIV_UART_N_Msk                (0xFul << CLK_CLKDIV_UART_N_Pos)         /*!< CLK_T::CLKDIV: UART_N Mask */
S
S#define CLK_CLKDIV_USB_N_Pos                 4                                        /*!< CLK_T::CLKDIV: USB_N Position */
S#define CLK_CLKDIV_USB_N_Msk                 (0xFul << CLK_CLKDIV_USB_N_Pos)          /*!< CLK_T::CLKDIV: USB_N Mask */
S
S#define CLK_CLKDIV_HCLK_N_Pos                0                                        /*!< CLK_T::CLKDIV: HCLK_N Position */
S#define CLK_CLKDIV_HCLK_N_Msk                (0xFul << CLK_CLKDIV_HCLK_N_Pos)         /*!< CLK_T::CLKDIV: HCLK_N Mask */
S
S/* CLK CLKDIV1 Bit Field Definitions */
S#define CLK_CLKDIV1_SC2_N_Pos                16                                       /*!< CLK_T::CLKDIV: SC2_N Position */
S#define CLK_CLKDIV1_SC2_N_Msk                (0xFFul << CLK_CLKDIV1_SC2_N_Pos)        /*!< CLK_T::CLKDIV: SC2_N Mask */
S
S#define CLK_CLKDIV1_SC1_N_Pos                8                                        /*!< CLK_T::CLKDIV: SC1_N Position */
S#define CLK_CLKDIV1_SC1_N_Msk                (0xFFul << CLK_CLKDIV1_SC1_N_Pos)        /*!< CLK_T::CLKDIV: SC1_N Mask */
S
S#define CLK_CLKDIV1_SC0_N_Pos                0                                        /*!< CLK_T::CLKDIV: SC0_N Position */
S#define CLK_CLKDIV1_SC0_N_Msk                (0xFFul << CLK_CLKDIV1_SC0_N_Pos)        /*!< CLK_T::CLKDIV: SC0_N Mask */
S
S/* CLK PLLCON Bit Field Definitions */
S#define CLK_PLLCON_PLL_SRC_Pos               19                                       /*!< CLK_T::PLLCON: PLL_SRC Position */
S#define CLK_PLLCON_PLL_SRC_Msk               (1ul << CLK_PLLCON_PLL_SRC_Pos)          /*!< CLK_T::PLLCON: PLL_SRC Mask */
S
S#define CLK_PLLCON_OE_Pos                    18                                       /*!< CLK_T::PLLCON: PLL_SRC Position */
S#define CLK_PLLCON_OE_Msk                    (1ul << CLK_PLLCON_OE_Pos)               /*!< CLK_T::PLLCON: PLL_SRC Mask */
S
S#define CLK_PLLCON_BP_Pos                    17                                       /*!< CLK_T::PLLCON: OE Position */
S#define CLK_PLLCON_BP_Msk                    (1ul << CLK_PLLCON_BP_Pos)               /*!< CLK_T::PLLCON: OE Mask */
S
S#define CLK_PLLCON_PD_Pos                    16                                       /*!< CLK_T::PLLCON: PD Position */
S#define CLK_PLLCON_PD_Msk                    (1ul << CLK_PLLCON_PD_Pos)               /*!< CLK_T::PLLCON: PD Mask */
S
S#define CLK_PLLCON_OUT_DV_Pos                14                                       /*!< CLK_T::PLLCON: OUT_DV Position */
S#define CLK_PLLCON_OUT_DV_Msk                (3ul << CLK_PLLCON_OUT_DV_Pos)           /*!< CLK_T::PLLCON: OUT_DV Mask */
S
S#define CLK_PLLCON_IN_DV_Pos                 9                                        /*!< CLK_T::PLLCON: IN_DV Position */
S#define CLK_PLLCON_IN_DV_Msk                 (0x1Ful << CLK_PLLCON_IN_DV_Pos)         /*!< CLK_T::PLLCON: IN_DV Mask */
S
S#define CLK_PLLCON_FB_DV_Pos                 0                                        /*!< CLK_T::PLLCON: FB_DV Position */
S#define CLK_PLLCON_FB_DV_Msk                 (0x1FFul << CLK_PLLCON_FB_DV_Pos)        /*!< CLK_T::PLLCON: FB_DV Mask */
S
S/* CLK FRQDIV Bit Field Definitions */
S#define CLK_FRQDIV_CLKO_1HZ_EN_Pos           6                                        /*!< CLK_T::FRQDIV: CLKO_1HZ_EN Position */
S#define CLK_FRQDIV_CLKO_1HZ_EN_Msk           (1ul << CLK_FRQDIV_CLKO_1HZ_EN_Pos)      /*!< CLK_T::FRQDIV: CLKO_1HZ_EN Mask */
S
S#define CLK_FRQDIV_DIVIDER1_Pos              5                                        /*!< CLK_T::FRQDIV: DIVIDER1 Position */
S#define CLK_FRQDIV_DIVIDER1_Msk              (1ul << CLK_FRQDIV_DIVIDER1_Pos)         /*!< CLK_T::FRQDIV: DIVIDER1 Mask */
S
S#define CLK_FRQDIV_DIVIDER_EN_Pos            4                                        /*!< CLK_T::FRQDIV: DIVIDER_EN Position */
S#define CLK_FRQDIV_DIVIDER_EN_Msk            (1ul << CLK_FRQDIV_DIVIDER_EN_Pos)       /*!< CLK_T::FRQDIV: DIVIDER_EN Mask */
S
S#define CLK_FRQDIV_FSEL_Pos                  0                                        /*!< CLK_T::FRQDIV: FRQDIV_FSEL Position */
S#define CLK_FRQDIV_FSEL_Msk                  (0xFul << CLK_FRQDIV_FSEL_Pos)           /*!< CLK_T::FRQDIV: FRQDIV_FSEL Mask */
S/*@}*/ /* end of group CLK_CONST */
S/*@}*/ /* end of group CLK */
S
S
S
S/*----------------------------- Cyclic Redundancy Check (CRC) Controller -----------------------------*/
S/** @addtogroup CRC Cyclic Redundancy Check Controller (CRC)
S  Memory Mapped Structure for Cyclic Redundancy Check
S  @{
S */
S
S
Stypedef struct
S{
S
S
S/**
S * @var CRC_T::CTL
S * Offset: 0x00  CRC Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |CRCCEN    |CRC Channel Enable
S * |        |          |0 = No effect.
S * |        |          |1 = CRC operation Enabled.
S * |        |          |Note1: When operating in CRC DMA mode (TRIG_EN (CRC_CTL[23]) = 1), if user clears this bit, the
S * |        |          |DMA operation will be continuous until all CRC DMA operation is done, and the TRIG_EN
S * |        |          |(CRC_CTL[23]) bit will keep 1until all CRC DMA operation done.
S * |        |          |But in this case, the CRC_BLKD_IF (CRC_DMAISR[1])flag will inactive, user can read CRC checksum
S * |        |          |result only if TRIG_EN (CRC_CTL[23]) clears to 0.
S * |        |          |Note2: When operating in CRC DMA mode (TRIG_EN (CRC_CTL[23]) = 1), if user wants to stop the
S * |        |          |transfer immediately, user can write 1 to CRC_RST (CRC_CTL [1]) bit to stop the transmission.
S * |[1]     |CRC_RST   |CRC Engine Reset
S * |        |          |0 = No effect.
S * |        |          |1 = Reset the internal CRC state machine and internal buffer.
S * |        |          |The others contents of CRC_CTL register will not be cleared.
S * |        |          |This bit will be cleared automatically.
S * |        |          |Note: When operated in CPU PIO mode, setting this bit will reload the initial seed value
S * |        |          |(CRC_SEED register).
S * |[23]    |TRIG_EN   |Trigger Enable
S * |        |          |This bit is used to trigger the CRC DMA transfer.
S * |        |          |0 = No effect.
S * |        |          |1 = CRC DMA data read or write transfer Enabled.
S * |        |          |Note1: If this bit asserts which indicates the CRC engine operation in CRC DMA mode, do not fill
S * |        |          |in any data in CRC_WDATA register.
S * |        |          |Note2: When CRC DMA transfer completed, this bit will be cleared automatically.
S * |        |          |Note3: If the bus error occurs when CRC DMA transfer data, all CRC DMA transfer will be stopped.
S * |        |          |Software must reset all DMA channel before trigger DMA again.
S * |[24]    |WDATA_RVS |Write Data Order Reverse
S * |        |          |This bit is used to enable the bit order reverse function for write data value in CRC_WDATA
S * |        |          |register.
S * |        |          |0 = Bit order reverse for CRC write data in Disabled.
S * |        |          |1 = Bit order reverse for CRC write data in Enabled (per byre).
S * |        |          |Note: If the write data is 0xAABBCCDD, the bit order reverse for CRC write data in is 0x55DD33BB
S * |[25]    |CHECKSUM_RVS|Checksum Reverse
S * |        |          |This bit is used to enable the bit order reverse function for write data value in CRC_CHECKSUM
S * |        |          |register.
S * |        |          |0 = Bit order reverse for CRC checksum Disabled.
S * |        |          |1 = Bit order reverse for CRC checksum Enabled.
S * |        |          |Note: If the checksum result is 0XDD7B0F2E, the bit order reverse for CRC checksum is 0x74F0DEBB
S * |[26]    |WDATA_COM |Write Data 1's Complement
S * |        |          |This bit is used to enable the 1's complement function for write data value in CRC_WDATA
S * |        |          |register.
S * |        |          |0 = 1's complement for CRC write data in Disabled.
S * |        |          |1 = 1's complement for CRC write data in Enabled.
S * |[27]    |CHECKSUM_COM|Checksum 1's Complement
S * |        |          |This bit is used to enable the 1's complement function for checksum result in CRC_CHECKSUM
S * |        |          |register.
S * |        |          |0 = 1's complement for CRC checksum Disabled.
S * |        |          |1 = 1's complement for CRC checksum Enabled.
S * |[29:28] |CPU_WDLEN |CPU Write Data Length
S * |        |          |This field indicates the CPU write data length only when operating in CPU PIO mode.
S * |        |          |00 = The write data length is 8-bit mode.
S * |        |          |01 = The write data length is 16-bit mode.
S * |        |          |10 = The write data length is 32-bit mode.
S * |        |          |11 = Reserved.
S * |        |          |Note1: This field is only valid when operating in CPU PIO mode.
S * |        |          |Note2: When the write data length is 8-bit mode, the valid data in CRC_WDATA register is only
S * |        |          |CRC_WDATA [7:0] bits; if the write data length is 16-bit mode, the valid data in CRC_WDATA
S * |        |          |register is only CRC_WDATA [15:0].
S * |[31:30] |CRC_MODE  |CRC Polynomial Mode
S * |        |          |This field indicates the CRC operation polynomial mode.
S * |        |          |00 = CRC-CCITT Polynomial Mode.
S * |        |          |01 = CRC-8 Polynomial Mode.
S * |        |          |10 = CRC-16 Polynomial Mode.
S * |        |          |11 = CRC-32 Polynomial Mode.
S * @var CRC_T::DMASAR
S * Offset: 0x04  CRC DMA Source Address Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |CRC_DMASAR|CRC DMA Transfer Source Address Register
S * |        |          |This field indicates a 32-bit source address of CRC DMA.
S * |        |          |(CRC_DMASAR + CRC_DMABCR) = (CRC_DMACSAR + CRC_DMACBCR).
S * |        |          |Note: The source address must be word alignment
S * @var CRC_T::DMABCR
S * Offset: 0x0C  CRC DMA Transfer Byte Count Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |CRC_DMABCR|CRC DMA Transfer Byte Count Register
S * |        |          |This field indicates a 16-bit total transfer byte count number of CRC DMA
S * |        |          |(CRC_DMASAR + CRC_DMABCR) = (CRC_DMACSAR + CRC_DMACBCR).
S * @var CRC_T::DMACSAR
S * Offset: 0x14  CRC DMA Current Source Address Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |CRC_DMACSAR|CRC DMA Current Source Address Register (Read Only)
S * |        |          |This field indicates the current source address where the CRC DMA transfer just occurs.
S * |        |          |(CRC_DMASAR + CRC_DMABCR) = (CRC_DMACSAR + CRC_DMACBCR).
S * @var CRC_T::DMACBCR
S * Offset: 0x1C  CRC DMA Current Transfer Byte Count Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |CRC_DMACBCR|CRC DMA Current Remained Byte Count Register (Read Only)
S * |        |          |This field indicates the current remained byte count of CRC DMA.
S * |        |          |(CRC_DMASAR + CRC_DMABCR) = (CRC_DMACSAR + CRC_DMACBCR).
S * |        |          |Note: Setting CRC_RST (CRC_CTL[1]) bit to 1 will clear this register value.
S * @var CRC_T::DMAIER
S * Offset: 0x20  CRC DMA Interrupt Enable Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |CRC_TABORT_IE|CRC DMA Read/Write Target Abort Interrupt Enable
S * |        |          |Enable this bit will generate the CRC DMA Target Abort interrupt signal while CRC_TARBOT_IF
S * |        |          |(CRC_DMAISR[0]) bit is set to 1.
S * |        |          |0 = Target abort interrupt generation Disabled during CRC DMA transfer.
S * |        |          |1 = Target abort interrupt generation Enabled during CRC DMA transfer.
S * |[1]     |CRC_BLKD_IE|CRC DMA Block Transfer Done Interrupt Enable
S * |        |          |Enable this bit will generate the CRC DMA Transfer Done interrupt signal while CRC_BLKD_IF
S * |        |          |(CRC_DMAISR[1]) bit is set to 1.
S * |        |          |0 = Interrupt generator Disabled when CRC DMA transfer done.
S * |        |          |1 = Interrupt generator Enabled when CRC DMA transfer done.
S * @var CRC_T::DMAISR
S * Offset: 0x24  CRC DMA Interrupt Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |CRC_TABORT_IF|CRC DMA Read/Write Target Abort Interrupt Flag
S * |        |          |This bit indicates that CRC bus has error or not during CRC DMA transfer.
S * |        |          |0 = No bus error response received during CRC DMA transfer.
S * |        |          |1 = Bus error response received during CRC DMA transfer.
S * |        |          |It is cleared by writing 1 to it through software.
S * |        |          |Note: The bit filed indicate bus master received error response or not.
S * |        |          |If bus master received error response, it means that CRC transfer target abort is happened.
S * |        |          |DMA will stop transfer and respond this event to software then CRC state machine goes to IDLE
S * |        |          |state.
S * |        |          |When target abort occurred, software must reset DMA before transfer those data again.
S * |[1]     |CRC_BLKD_IF|CRC DMA Block Transfer Done Interrupt Flag
S * |        |          |This bit indicates that CRC DMA transfer has finished or not.
S * |        |          |0 = Not finished if TRIG_EN (CRC_CTL[23]) bit has enabled.
S * |        |          |1 = CRC transfer done if TRIG_EN (CRC_CTL[23]) bit has enabled.
S * |        |          |It is cleared by writing 1 to it through software.
S * |        |          |(When CRC DMA transfer done, TRIG_EN (CRC_CTL[23]) bit will be cleared automatically)
S * @var CRC_T::WDATA
S * Offset: 0x80  CRC Write Data Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |CRC_WDATA |CRC Write Data Register
S * |        |          |When operating in CPU PIO mode, software can write data to this field to perform CRC operation.
S * |        |          |When operating in DMA mode, this field indicates the DMA read data from memory and cannot be
S * |        |          |written.
S * |        |          |Note: When the write data length is 8-bit mode, the valid data in CRC_WDATA register is only
S * |        |          |CRC_WDATA [7:0] bits; if the write data length is 16-bit mode, the valid data in CRC_WDATA
S * |        |          |register is only CRC_WDATA [15:0].
S * @var CRC_T::SEED
S * Offset: 0x84  CRC Seed Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |CRC_SEED  |CRC Seed Register
S * |        |          |This field indicates the CRC seed value.
S * @var CRC_T::CHECKSUM
S * Offset: 0x88  CRC Checksum Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |CRC_CHECKSUM|CRC Checksum Register
S * |        |          |This fields indicates the CRC checksum result
S */
S
S    __IO uint32_t CTL;           /* Offset: 0x00  CRC Control Register                                               */
S    __IO uint32_t DMASAR;        /* Offset: 0x04  CRC DMA Source Address Register                                    */
S    __I  uint32_t RESERVED0;    
S    __IO uint32_t DMABCR ;       /* Offset: 0x0C  CRC DMA Transfer Byte Count Register                               */
S    __I  uint32_t RESERVED1;    
S    __I  uint32_t DMACSAR;       /* Offset: 0x14  CRC DMA Current Source Address Register                            */
S    __I  uint32_t RESERVED2;    
S    __I  uint32_t DMACBCR;       /* Offset: 0x1C  CRC DMA Current Transfer Byte Count Register                       */
S    __IO uint32_t DMAIER ;       /* Offset: 0x20  CRC DMA Interrupt Enable Register                                  */
S    __IO uint32_t DMAISR;        /* Offset: 0x24  CRC DMA Interrupt Status Register                                  */
S    __I  uint32_t RESERVED3[22];
S    __IO uint32_t WDATA;         /* Offset: 0x80  CRC Write Data Register                                            */
S    __IO uint32_t SEED;          /* Offset: 0x84  CRC Seed Register                                                  */
S    __I  uint32_t CHECKSUM;      /* Offset: 0x88  CRC Checksum Register                                              */
S
S} CRC_T;
S
S
S/**
S    @addtogroup CRC_CONST CRC Bit Field Definition
S    Constant Definitions for CRC Controller
S@{ */
S
S
S/* CRC CTL Bit Field Definitions */
S#define CRC_CTL_CRC_MODE_Pos            30                                      /*!< CRC_T::CTL: CRC_MODE Position */
S#define CRC_CTL_CRC_MODE_Msk            (0x3ul << CRC_CTL_CRC_MODE_Pos)         /*!< CRC_T::CTL: CRC_MODE Mask */
S
S#define CRC_CTL_CPU_WDLEN_Pos           28                                      /*!< CRC_T::CTL: CPU_WDLEN Position */
S#define CRC_CTL_CPU_WDLEN_Msk           (0x3ul << CRC_CTL_CPU_WDLEN_Pos)        /*!< CRC_T::CTL: CPU_WDLEN Mask */
S
S#define CRC_CTL_CHECKSUM_COM_Pos        27                                      /*!< CRC_T::CTL: CHECKSUM_COM Position */
S#define CRC_CTL_CHECKSUM_COM_Msk        (1ul << CRC_CTL_CHECKSUM_COM_Pos)       /*!< CRC_T::CTL: CHECKSUM_COM Mask */
S
S#define CRC_CTL_WDATA_COM_Pos           26                                      /*!< CRC_T::CTL: WDATA_COM Position */
S#define CRC_CTL_WDATA_COM_Msk           (1ul << CRC_CTL_WDATA_COM_Pos)          /*!< CRC_T::CTL: WDATA_COM Mask */
S
S#define CRC_CTL_CHECKSUM_RVS_Pos        25                                      /*!< CRC_T::CTL: CHECKSUM_RVS Position */
S#define CRC_CTL_CHECKSUM_RVS_Msk        (1ul << CRC_CTL_CHECKSUM_RVS_Pos)       /*!< CRC_T::CTL: CHECKSUM_RVS Mask */
S
S#define CRC_CTL_WDATA_RVS_Pos           24                                      /*!< CRC_T::CTL: WDATA_RVS Position */
S#define CRC_CTL_WDATA_RVS_Msk           (1ul << CRC_CTL_WDATA_RVS_Pos)          /*!< CRC_T::CTL: WDATA_RVS Mask */
S
S#define CRC_CTL_TRIG_EN_Pos             23                                      /*!< CRC_T::CTL: TRIG_EN Position */
S#define CRC_CTL_TRIG_EN_Msk             (1ul << CRC_CTL_TRIG_EN_Pos)            /*!< CRC_T::CTL: TRIG_EN Mask */
S
S#define CRC_CTL_CRC_RST_Pos             1                                       /*!< CRC_T::CTL: CRC_RST Position */
S#define CRC_CTL_CRC_RST_Msk             (1ul << CRC_CTL_CRC_RST_Pos)            /*!< CRC_T::CTL: CRC_RST Mask */
S
S#define CRC_CTL_CRCCEN_Pos              0                                       /*!< CRC_T::CTL: CRCCEN Position */
S#define CRC_CTL_CRCCEN_Msk              (1ul << CRC_CTL_CRCCEN_Pos)             /*!< CRC_T::CTL: CRCCEN Mask */
S
S/* CRC DMASAR Bit Field Definitions */
S#define CRC_DMASAR_CRC_DMASAR_Pos       0                                               /*!< CRC_T::DMASAR: CRC_DMASAR Position */
S#define CRC_DMASAR_CRC_DMASAR_Msk       (0xFFFFFFFFul << CRC_DMASAR_CRC_DMASAR_Pos)     /*!< CRC_T::DMASAR: CRC_DMASAR Mask */
S
S/* CRC DMABCR Bit Field Definitions */
S#define CRC_DMABCR_CRC_DMABCR_Pos       0                                               /*!< CRC_T::DMABCR: CRC_DMABCR Position */
S#define CRC_DMABCR_CRC_DMABCR_Msk       (0xFFFFul << CRC_DMABCR_CRC_DMABCR_Pos)         /*!< CRC_T::DMABCR: CRC_DMABCR Mask */
S
S/* CRC DMACSAR Bit Field Definitions */
S#define CRC_DMACSAR_CRC_DMACSAR_Pos     0                                               /*!< CRC_T::DMACSAR: CRC_DMACSAR Position */
S#define CRC_DMACSAR_CRC_DMACSAR_Msk     (0xFFFFFFFFul << CRC_DMACSAR_CRC_DMACSAR_Pos)   /*!< CRC_T::DMACSAR: CRC_DMACSAR Mask */
S
S/* CRC DMACBCR Bit Field Definitions */
S#define CRC_DMACBCR_CRC_DMACBCR_Pos     0                                               /*!< CRC_T::DMACBCR: DMACBCR Position */
S#define CRC_DMACBCR_CRC_DMACBCR_Msk     (0xFFFFul << CRC_DMACBCR_CRC_DMACBCR_Pos)       /*!< CRC_T::DMACBCR: DMACBCR Mask */
S
S/* CRC DMAIER Bit Field Definitions */
S#define CRC_DMAIER_CRC_BLKD_IE_Pos      1                                               /*!< CRC_T::DMAIER: CRC_BLKD_IE Position */
S#define CRC_DMAIER_CRC_BLKD_IE_Msk      (1ul << CRC_DMAIER_CRC_BLKD_IE_Pos)             /*!< CRC_T::DMAIER: CRC_BLKD_IE Mask */
S
S#define CRC_DMAIER_CRC_TABORT_IE_Pos    0                                               /*!< CRC_T::DMAIER: CRC_TABORT_IE Position */
S#define CRC_DMAIER_CRC_TABORT_IE_Msk    (1ul << CRC_DMAIER_CRC_TABORT_IE_Pos)           /*!< CRC_T::DMAIER: CRC_TABORT_IE Mask */
S
S/* CRC DMAISR Bit Field Definitions */
S#define CRC_DMAISR_CRC_BLKD_IF_Pos      1                                               /*!< CRC_T::DMAISR: CRC_BLKD_IF Position */
S#define CRC_DMAISR_CRC_BLKD_IF_Msk      (1ul << CRC_DMAISR_CRC_BLKD_IF_Pos)             /*!< CRC_T::DMAISR: CRC_BLKD_IF Mask */
S
S#define CRC_DMAISR_CRC_TABORT_IF_Pos    0                                               /*!< CRC_T::DMAISR: CRC_TABORT_IF Position */
S#define CRC_DMAISR_CRC_TABORT_IF_Msk    (1ul << CRC_DMAISR_CRC_TABORT_IF_Pos)           /*!< CRC_T::DMAISR: CRC_TABORT_IF Mask */
S
S/* CRC WDATA Bit Field Definitions */
S#define CRC_WDATA_CRC_WDATA_Pos         0                                               /*!< CRC_T::WDATA: CRC_WDATA Position */
S#define CRC_WDATA_CRC_WDATA_Msk         (0xFFFFFFFFul << CRC_WDATA_CRC_WDATA_Pos)       /*!< CRC_T::WDATA: CRC_WDATA Mask */
S
S/* CRC SEED Bit Field Definitions */
S#define CRC_SEED_CRC_SEED_Pos           0                                               /*!< CRC_T::SEED: CRC_SEED Position */
S#define CRC_SEED_CRC_SEED_Msk           (0xFFFFFFFFul << CRC_SEED_CRC_SEED_Pos)         /*!< CRC_T::SEED: CRC_SEED Mask */
S
S/* CRC CHECKSUM Bit Field Definitions */
S#define CRC_CHECKSUM_CRC_CHECKSUM_Pos   0                                               /*!< CRC_T::CHECKSUM: CRC_CHECKSUM Position */
S#define CRC_CHECKSUM_CRC_CHECKSUM_Msk   (0xFFFFFFFFul << CRC_CHECKSUM_CRC_CHECKSUM_Pos) /*!< CRC_T::CHECKSUM: CRC_CHECKSUM Mask */
S/*@}*/ /* end of group CRC_CONST */
S/*@}*/ /* end of group CRC */
S
S
S/*---------------------- External Bus Interface Controller -------------------------*/
S/**
S    @addtogroup EBI External Bus Interface Controller (EBI)
S    Memory Mapped Structure for EBI Controller
S@{ */
S
S
Stypedef struct
S{
S
S
S/**
S * @var EBI_T::EBICON
S * Offset: 0x00  EBI Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |ExtEN     |EBI Enable
S * |        |          |This bit is the functional enable bit for EBI.
S * |        |          |0 = EBI function is disabled
S * |        |          |1 = EBI function is enabled
S * |[1]     |ExtBW16   |EBI data width 16 bit
S * |        |          |This bit defines if the data bus is 8-bit or 16-bit.
S * |        |          |0 = EBI data width is 8 bit
S * |        |          |1 = EBI data width is 16 bit
S * |[10:8]  |MCLKDIV   |External Output Clock Divider
S * |        |          |The frequency of EBI output clock is controlled by MCLKDIV.
S * |        |          |000 = HCLK/1
S * |        |          |001 = HCLK/2
S * |        |          |010 = HCLK/4
S * |        |          |011 = HCLK/8
S * |        |          |100 = HCLK/16
S * |        |          |101 = HCKL/32
S * |        |          |11X = default
S * |        |          |Notice: Default value of output clock is HCLK/1
S * |[18:16] |ExttALE   |Expand Time of ALE
S * |        |          |The ALE width (tALE) to latch the address can be controlled by ExttALE.
S * |        |          |tALE = (ExttALE + 1) * MCLK
S * @var EBI_T::EXTIME
S * Offset: 0x04  EBI Timing Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:3]   |ExttACC   |EBI Data Accesss Time
S * |        |          |ExttACC define data access time (tACC).
S * |        |          |tACC = (ExttACC + 1) * MCLK
S * |[10:8]  |ExttAHD   |EBI Data Access Hold Time
S * |        |          |ExttAHD define data access hold time (tAHD).
S * |        |          |tAHD = (ExttAHD + 1) * MCLK
S * |[15:12] |ExtIW2X   |Idle State Cycle After Write
S * |        |          |When write action is finish, idle state is inserted and nCS return to high if ExtIW2X is not
S * |        |          |zero.
S * |        |          |Idle state cycle = (ExtIW2X * MCLK)
S * |[27:24] |ExtIR2R   |Idle State Cycle Between Read-Read
S * |        |          |When read action is finish and next action is going to read, idle state is inserted and nCS
S * |        |          |return
S * |        |          |to high if ExtIR2R is not zero.
S * |        |          |Idle state cycle = (ExtIR2R * MCLK)
S * @var EBI_T::EBICON2
S * Offset: 0x08   External Bus Interface General Control Register 2
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |WBUFF_EN  |EBI Write Buffer Enable Control
S * |        |          |0 = EBI write buffer Disabled.
S * |        |          |1 = EBI write buffer Enabled.c
S * |[1]     |RAHD_OFF  |Access Hold Time Disable Control When Read
S * |        |          |0 = tAHD is controlled by ExttAHD[2:0] when read through EBI.
S * |        |          |1 = Zero tAHD when read through EBI.
S * |[2]     |WAHD_OFF  |Access Hold Time Disable Control When Write 
S * |        |          |0 = tAHD is controlled by ExttAHD[2:0] when write through EBI.
S * |        |          |1 = Zero tAHD when write through EBI.
S */
S
S    __IO uint32_t EBICON;        /* Offset: 0x00  EBI Control Register                                               */
S    __IO uint32_t EXTIME;        /* Offset: 0x04  EBI Timing Control Register                                        */
S    __IO uint32_t EBICON2;       /* Offset: 0x08   External Bus Interface General Control Register 2                 */
S
S} EBI_T;
S
S
S
S/**
S    @addtogroup EBI_CONST EBI Bit Field Definition
S    Constant Definitions for EBI Controller
S@{ */
S
S/* EBI EBICON Bit Field Definitions */
S#define EBI_EBICON_ExttALE_Pos      16                                          /*!< EBI_T::EBICON: ExttALE Position */
S#define EBI_EBICON_ExttALE_Msk      (0x7ul << EBI_EBICON_ExttALE_Pos)           /*!< EBI_T::EBICON: ExttALE Mask */
S
S#define EBI_EBICON_MCLKDIV_Pos      8                                           /*!< EBI_T::EBICON: MCLKDIV Position */
S#define EBI_EBICON_MCLKDIV_Msk      (0x7ul << EBI_EBICON_MCLKDIV_Pos)           /*!< EBI_T::EBICON: MCLKDIV Mask */
S
S#define EBI_EBICON_ExtBW16_Pos      1                                           /*!< EBI_T::EBICON: ExtBW16 Position */
S#define EBI_EBICON_ExtBW16_Msk      (1ul << EBI_EBICON_ExtBW16_Pos)             /*!< EBI_T::EBICON: ExtBW16 Mask */
S
S#define EBI_EBICON_ExtEN_Pos        0                                           /*!< EBI_T::EBICON: ExtEN Position */
S#define EBI_EBICON_ExtEN_Msk        (1ul << EBI_EBICON_ExtEN_Pos)               /*!< EBI_T::EBICON: ExtEN Mask */
S
S/* EBI EXTIME Bit Field Definitions */
S#define EBI_EXTIME_ExtIR2R_Pos      24                                          /*!< EBI_T::EXTIME: ExtIR2R Position */
S#define EBI_EXTIME_ExtIR2R_Msk      (0xFul << EBI_EXTIME_ExtIR2R_Pos)           /*!< EBI_T::EXTIME: ExtIR2R Mask */
S
S#define EBI_EXTIME_ExtIW2X_Pos      12                                          /*!< EBI_T::EXTIME: ExtIW2X Position */
S#define EBI_EXTIME_ExtIW2X_Msk      (0xFul << EBI_EXTIME_ExtIW2X_Pos)           /*!< EBI_T::EXTIME: ExtIW2X Mask */
S
S#define EBI_EXTIME_ExttAHD_Pos      8                                           /*!< EBI_T::EXTIME: ExttAHD Position */
S#define EBI_EXTIME_ExttAHD_Msk      (0x7ul << EBI_EXTIME_ExttAHD_Pos)           /*!< EBI_T::EXTIME: ExttAHD Mask */
S
S#define EBI_EXTIME_ExttACC_Pos      3                                           /*!< EBI_T::EXTIME: ExttACC Position */
S#define EBI_EXTIME_ExttACC_Msk      (0x1Ful << EBI_EXTIME_ExttACC_Pos)          /*!< EBI_T::EXTIME: ExttACC Mask */
S
S/* EBI EBICON2 Bit Field Definitions */
S#define EBI_EBICON2_WAHD_OFF_Pos    2                                           /*!< EBI_T::EBICON2: WAHD_OFF Position */
S#define EBI_EBICON2_WAHD_OFF_Msk    (1ul << EBI_EBICON2_WAHD_OFF_Pos)           /*!< EBI_T::EBICON2: WAHD_OFF Mask */
S
S#define EBI_EBICON2_RAHD_OFF_Pos    1                                           /*!< EBI_T::EBICON2: RAHD_OFF Position */
S#define EBI_EBICON2_RAHD_OFF_Msk    (1ul << EBI_EBICON2_RAHD_OFF_Pos)           /*!< EBI_T::EBICON2: RAHD_OFF Mask */
S
S#define EBI_EBICON2_WBUFF_EN_Pos    0                                           /*!< EBI_T::EBICON2: WBUFF_EN Position */
S#define EBI_EBICON2_WBUFF_EN_Msk    (1ul << EBI_EBICON2_WBUFF_EN_Pos)           /*!< EBI_T::EBICON2: WBUFF_EN Mask */
S/*@}*/ /* end of group EBI_CONST */
S/*@}*/ /* end of group EBI */
S
S/*---------------------- Flash Memory Controller -------------------------*/
S/**
S    @addtogroup FMC Flash Memory Controller (FMC)
S    Memory Mapped Structure for FMC Controller
S@{ */
S
S
S
Stypedef struct
S{
S
S
S/**
S * @var FMC_T::ISPCON
S * Offset: 0x00  ISP Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |ISPEN     |ISP Enable
S * |        |          |This bit is protected bit. ISP function enable bit. Set this bit to enable ISP function.
S * |        |          |1 = Enable ISP function
S * |        |          |0 = Disable ISP function
S * |[1]     |BS        |Boot Select
S * |        |          |This bit is protected bit. Set/clear this bit to select next booting from LDROM/APROM,
S * |        |          |respectively. This bit also functions as MCU booting status flag, which can be used to check
S * |        |          |where
S * |        |          |MCU booted from. This bit is initiated with the inversed value of CBS in Config0 after power-
S * |        |          |on reset; It keeps the same value at other reset.
S * |        |          |1 = boot from LDROM
S * |        |          |0 = boot from APROM
S * |[4]     |CFGUEN    |Config Update Enable
S * |        |          |Writing this bit to 1 enables s/w to update Config value by ISP procedure regardless of program
S * |        |          |code is running in APROM or LDROM.
S * |        |          |1 = Config update enable
S * |        |          |0 = Config update disable
S * |[5]     |LDUEN     |LDROM Update Enable
S * |        |          |LDROM update enable bit.
S * |        |          |1 = LDROM can be updated when the MCU runs in APROM.
S * |        |          |0 = LDROM cannot be updated
S * |[6]     |ISPFF     |ISP Fail Flag
S * |        |          |This bit is set by hardware when a triggered ISP meets any of the following conditions:
S * |        |          |(1) APROM writes to itself.
S * |        |          |(2) LDROM writes to itself.
S * |        |          |(3) Destination address is illegal, such as over an available range.
S * |        |          |Write 1 to clear.
S * |[7]     |SWRST     |Software Reset
S * |        |          |Writing 1 to this bit to start software reset.
S * |        |          |It is cleared by hardware after reset is finished.
S * |[10:8]  |PT        |Flash Program Time
S * |        |          |000 = 40 us
S * |        |          |001 = 45 us
S * |        |          |010 = 50 us
S * |        |          |011 = 55 us
S * |        |          |100 = 20 us
S * |        |          |101 = 25 us
S * |        |          |110 = 30 us
S * |        |          |111 = 35 us
S * |[14:12] |ET        |Flash Erase Time
S * |        |          |000 = 20 ms (default)
S * |        |          |001 = 25 ms
S * |        |          |010 = 30 ms
S * |        |          |011 = 35 ms
S * |        |          |100 = 3  ms
S * |        |          |101 = 5  ms
S * |        |          |110 = 10 ms
S * |        |          |111 = 15 ms
S * @var FMC_T::ISPADR
S * Offset: 0x04  ISP Address Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |ISPADR    |ISP Address
S * |        |          |NuMicro NUC230/240 series has a maximum of 32Kx32 (128 KB) embedded Flash,
S * |        |          |which supports word program only. ISPADR[1:0] must be kept 00b for ISP operation.
S * @var FMC_T::ISPDAT
S * Offset: 0x08  ISP Data Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |ISPDAT    |ISP Data
S * |        |          |Write data to this register before ISP program operation
S * |        |          |Read data from this register after ISP read operation
S * @var FMC_T::ISPCMD
S * Offset: 0x0C  ISP Command Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[5:0]   |FOEN_FCEN_FCTRL|ISP Command
S * |        |          |ISP command table is shown below:
S * |        |          |Operation Mode, FOEN, FCEN, FCTRL[3:0]
S * |        |          |Read          ,    0,    0, 0000
S * |        |          |Program       ,    1,    0, 0001
S * |        |          |Page Erase    ,    1,    0, 0010
S * @var FMC_T::ISPTRG
S * Offset: 0x10  IISP Trigger Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |ISPGO     |ISP start trigger
S * |        |          |Write 1 to start ISP operation and this bit will be cleared to 0 by hardware automatically when
S * |        |          |ISP
S * |        |          |operation is finish.
S * |        |          |1 = ISP is on going
S * |        |          |0 = ISP done
S * @var FMC_T::DFBADR
S * Offset: 0x14  Data Flash Base Address Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |DFBA      |Data Flash Base Address
S * |        |          |This register indicates data flash start address.
S * |        |          |It is a read only register.
S * |        |          |For 8/16/32/64kB flash memory device, the data flash size is 4kB and it start address is fixed
S * |        |          |at
S * |        |          |0x01F000 by hardware internally.
S * @var FMC_T::FATCON
S * Offset: 0x18  Flash Access Time Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |FPSEN     |Flash Power Save Enable
S * |        |          |If CPU clock is slower than 24 MHz, then s/w can enable flash power saving function.
S * |        |          |1 = Enable flash power saving
S * |        |          |0 = Disable flash power saving
S * |[3:1]   |FATS      |Flash Access Time Window Select
S * |        |          |These bits are used to decide flash sense amplifier active duration.
S * |        |          |000 = 40 ns
S * |        |          |001 = 50 ns
S * |        |          |010 = 60 ns
S * |        |          |011 = 70 ns
S * |        |          |100 = 80 ns
S * |        |          |101 = 90 ns
S * |        |          |110 = 100 ns
S * |        |          |111 = Reserved
S * |[4]     |L_SPEED   |Flash Low Speed Mode Enable
S * |        |          |1 = Flash access always no wait state (zero wait state)
S * |        |          |0 = Insert wait state while Flash access discontinued address.
S * |        |          |Note: Set this bit only when HCLK <= 25MHz. If HCLK > 25MHz, CPU will fetch wrong
S * |        |          |code and cause fail result.
S * @var FMC_T::ISPSTA
S * Offset: 0x40  ISP Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |ISPGO     |ISP Start Trigger (Read Only)
S * |        |          |Write 1 to start ISP operation and this bit will be cleared to 0 by hardware
S * |        |          |automatically when ISP operation is finished.
S * |        |          |0 = ISP operation finished.
S * |        |          |1 = ISP operation progressed.
S * |        |          |Note: This bit is the same as ISPTRG bit0
S * |[2:1]   |CBS       |Chip Boot Selection (Read Only)
S * |        |          |This is a mirror of CBS in Config0.
S * |[6]     |ISPFF     |ISP Fail Flag (Write-protection Bit)
S * |        |          |This bit is set by hardware when a triggered ISP meets any of the following conditions:
S * |        |          |(1) APROM writes to itself.
S * |        |          |(2) LDROM writes to itself.
S * |        |          |(3) CONFIG is erased/programmed when CFGUEN is set to 0
S * |        |          |(4) Destination address is illegal, such as over an available range.
S * |[20:9]  |VECMAP    |Vector Page Mapping Address (Read Only)
S * |        |          |The current flash address space 0x0000_0000~0x0000_01FF is mapping to the address
S * |        |          |{VECMAP[11:0], 9'h000} ~ {VECMAP[11:0], 9'h1FF}
S */
S
S    __IO uint32_t ISPCON;        /* Offset: 0x00  ISP Control Register                                               */
S    __IO uint32_t ISPADR;        /* Offset: 0x04  ISP Address Register                                               */
S    __IO uint32_t ISPDAT;        /* Offset: 0x08  ISP Data Register                                                  */
S    __IO uint32_t ISPCMD;        /* Offset: 0x0C  ISP Command Register                                               */
S    __IO uint32_t ISPTRG;        /* Offset: 0x10  IISP Trigger Control Register                                      */
S    __I  uint32_t DFBADR;        /* Offset: 0x14  Data Flash Base Address Register                                   */
S    __IO uint32_t FATCON;        /* Offset: 0x18  Flash Access Time Control Register                                 */
S    __I  uint32_t RESERVED[9];  
S    __IO uint32_t ISPSTA;        /* Offset: 0x40  ISP Status Register                                                */
S
S} FMC_T;
S
S
S/**
S    @addtogroup FMC_CONST FMC Bit Field Definition
S    Constant Definitions for FMC Controller
S@{ */
S
S
S/* FMC ISPCON Bit Field Definitions */
S#define FMC_ISPCON_ET_Pos                       12                                      /*!< FMC_T::ISPCON: ET Position */
S#define FMC_ISPCON_ET_Msk                       (7ul << FMC_ISPCON_ET_Pos)              /*!< FMC_T::ISPCON: ET Mask     */
S
S#define FMC_ISPCON_PT_Pos                       8                                       /*!< FMC_T::ISPCON: PT Position */
S#define FMC_ISPCON_PT_Msk                       (7ul << FMC_ISPCON_PT_Pos)              /*!< FMC_T::ISPCON: PT Mask     */
S
S#define FMC_ISPCON_ISPFF_Pos                    6                                       /*!< FMC_T::ISPCON: ISPFF Position */
S#define FMC_ISPCON_ISPFF_Msk                    (1ul << FMC_ISPCON_ISPFF_Pos)           /*!< FMC_T::ISPCON: ISPFF Mask */
S
S#define FMC_ISPCON_LDUEN_Pos                    5                                       /*!< FMC_T::ISPCON: LDUEN Position */
S#define FMC_ISPCON_LDUEN_Msk                    (1ul << FMC_ISPCON_LDUEN_Pos)           /*!< FMC_T::ISPCON: LDUEN Mask */
S
S#define FMC_ISPCON_CFGUEN_Pos                   4                                       /*!< FMC_T::ISPCON: CFGUEN Position */
S#define FMC_ISPCON_CFGUEN_Msk                   (1ul << FMC_ISPCON_CFGUEN_Pos)          /*!< FMC_T::ISPCON: CFGUEN Mask */
S
S#define FMC_ISPCON_APUEN_Pos                    3                                       /*!< FMC_T::ISPCON: APUEN Position */
S#define FMC_ISPCON_APUEN_Msk                    (1ul << FMC_ISPCON_APUEN_Pos)           /*!< FMC_T::ISPCON: APUEN Mask */
S
S#define FMC_ISPCON_BS_Pos                       1                                       /*!< FMC_T::ISPCON: BS Position */
S#define FMC_ISPCON_BS_Msk                       (0x1ul << FMC_ISPCON_BS_Pos)            /*!< FMC_T::ISPCON: BS Mask */
S
S#define FMC_ISPCON_ISPEN_Pos                    0                                       /*!< FMC_T::ISPCON: ISPEN Position */
S#define FMC_ISPCON_ISPEN_Msk                    (1ul << FMC_ISPCON_ISPEN_Pos)           /*!< FMC_T::ISPCON: ISPEN Mask */
S
S/* FMC ISPADR Bit Field Definitions */
S#define FMC_ISPADR_ISPADR_Pos                   0                                       /*!< FMC_T::ISPADR: ISPADR Position */
S#define FMC_ISPADR_ISPADR_Msk                   (0xFFFFFFFFul << FMC_ISPADR_ISPADR_Pos) /*!< FMC_T::ISPADR: ISPADR Mask     */
S
S/* FMC ISPADR Bit Field Definitions */
S#define FMC_ISPDAT_ISPDAT_Pos                   0                                       /*!< FMC_T::ISPDAT: ISPDAT Position */
S#define FMC_ISPDAT_ISPDAT_Msk                   (0xFFFFFFFFul << FMC_ISPDAT_ISPDAT_Pos) /*!< FMC_T::ISPDAT: ISPDAT Mask     */
S
S/* FMC ISPCMD Bit Field Definitions */
S#define FMC_ISPCMD_FOEN_Pos                     5                                       /*!< FMC_T::ISPCMD: FOEN Position */
S#define FMC_ISPCMD_FOEN_Msk                     (1ul << FMC_ISPCMD_FOEN_Pos)            /*!< FMC_T::ISPCMD: FOEN Mask */
S
S#define FMC_ISPCMD_FCEN_Pos                     4                                       /*!< FMC_T::ISPCMD: FCEN Position */
S#define FMC_ISPCMD_FCEN_Msk                     (1ul << FMC_ISPCMD_FCEN_Pos)            /*!< FMC_T::ISPCMD: FCEN Mask */
S
S#define FMC_ISPCMD_FCTRL_Pos                    0                                       /*!< FMC_T::ISPCMD: FCTRL Position */
S#define FMC_ISPCMD_FCTRL_Msk                    (0xFul << FMC_ISPCMD_FCTRL_Pos)         /*!< FMC_T::ISPCMD: FCTRL Mask */
S
S/* FMC ISPTRG Bit Field Definitions */
S#define FMC_ISPTRG_ISPGO_Pos                    0                                       /*!< FMC_T::ISPTRG: ISPGO Position */
S#define FMC_ISPTRG_ISPGO_Msk                    (1ul << FMC_ISPTRG_ISPGO_Pos)           /*!< FMC_T::ISPTRG: ISPGO Mask */
S
S/* FMC DFBADR Bit Field Definitions */
S#define FMC_DFBADR_DFBA_Pos                     0                                       /*!< FMC_T::DFBADR: DFBA Position */
S#define FMC_DFBADR_DFBA_Msk                     (0xFFFFFFFFul << FMC_DFBADR_DFBA_Pos)   /*!< FMC_T::DFBADR: DFBA Mask     */
S
S/* FMC FATCON Bit Field Definitions */
S#define FMC_FATCON_FOMSEL1_Pos                  6                                       /*!< FMC_T::FATCON: FOMSEL1 Position */
S#define FMC_FATCON_FOMSEL1_Msk                  (1ul << FMC_FATCON_FOMSEL1_Pos)         /*!< FMC_T::FATCON: FOMSEL1 Mask */
S
S#define FMC_FATCON_FOMSEL0_Pos                  4                                       /*!< FMC_T::FATCON: FOMSEL0 Position */
S#define FMC_FATCON_FOMSEL0_Msk                  (1ul << FMC_FATCON_FOMSEL0_Pos)         /*!< FMC_T::FATCON: FOMSEL0 Mask */
S
S#define FMC_FATCON_FATS_Pos                     1                                       /*!< FMC_T::FATCON: FATS Position */
S#define FMC_FATCON_FATS_Msk                     (7ul << FMC_FATCON_FATS_Pos)            /*!< FMC_T::FATCON: FATS Mask */
S
S#define FMC_FATCON_FPSEN_Pos                    0                                       /*!< FMC_T::FATCON: FPSEN Position */
S#define FMC_FATCON_FPSEN_Msk                    (1ul << FMC_FATCON_FPSEN_Pos)           /*!< FMC_T::FATCON: FPSEN Mask */
S
S
S#define FMC_ISPSTA_ISPGO_Pos                    0                                       /*!< FMC_T::ISPSTA: ISPGO Position */
S#define FMC_ISPSTA_ISPGO_Msk                    (1ul << FMC_ISPSTA_ISPGO_Pos)           /*!< FMC_T::ISPSTA: ISPGO Mask */
S
S#define FMC_ISPSTA_CBS_Pos                      1                                       /*!< FMC_T::ISPSTA: CBS Position */
S#define FMC_ISPSTA_CBS_Msk                      (0x3ul << FMC_ISPSTA_CBS_Pos)           /*!< FMC_T::ISPSTA: CBS Mask */
S
S#define FMC_ISPSTA_ISPFF_Pos                    6                                       /*!< FMC_T::ISPSTA: ISPFF Position */
S#define FMC_ISPSTA_ISPFF_Msk                    (0x3ul << FMC_ISPSTA_ISPFF_Pos)         /*!< FMC_T::ISPSTA: ISPFF Mask */
S
S#define FMC_ISPSTA_VECMAP_Pos                   9                                       /*!< FMC_T::ISPSTA: VECMAP Position */
S#define FMC_ISPSTA_VECMAP_Msk                   (0xFFFul << FMC_ISPSTA_VECMAP_Pos)      /*!< FMC_T::ISPSTA: VECMAP Mask */
S/*@}*/ /* end of group FMC_CONST */
S/*@}*/ /* end of group FMC */
S
S
S/*---------------------- General Purpose Input/Output Controller -------------------------*/
S/**
S    @addtogroup GPIO General Purpose Input/Output Controller (GPIO)
S    Memory Mapped Structure for GPIO Controller
S@{ */
S
S
S
Stypedef struct
S{
S
S
S/**
S * @var GPIO_T::PMD
S * Offset: 0x00  GPIO Port [A/B/C/D/E/F] Pin I/O Mode Control
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[2n+1:2n]|PMDn     |GPIOx I/O Pin[n] Mode Control
S * |        |          |Determine each I/O mode of GPIOx pins.
S * |        |          |00 = GPIO port [n] pin is in Input mode.
S * |        |          |01 = GPIO port [n] pin is in Push-pull Output mode.
S * |        |          |10 = GPIO port [n] pin is in Open-drain Output mode.
S * |        |          |11 = GPIO port [n] pin is in Quasi-bidirectional mode.
S * |        |          |Note1: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
S * |        |          |Note2:
S * |        |          |The initial value of this field is defined by CIOINI (Config0[10]).
S * |        |          |If CIOINI is set to 1, the default value is 0xFFFF_FFFF and all pins will be Quasi-bidirectional
S * |        |          |mode after chip is powered on.
S * |        |          |If CIOINI is cleared to 0, the default value is 0x0000_0000 and all pins will be input only mode
S * |        |          |after chip is powered on.
S * @var GPIO_T::OFFD
S * Offset: 0x04  GPIO Port [A/B/C/D/E/F] Pin Digital Input Path Disable Control
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:16] |OFFD      |GPIOx Pin[n] Digital Input Path Disable Control
S * |        |          |Each of these bits is used to control if the digital input path of corresponding GPIO pin is
S * |        |          |disabled.
S * |        |          |If input is analog signal, users can disable GPIO digital input path to avoid current leakage.
S * |        |          |0 = I/O digital input path Enabled.
S * |        |          |1 = I/O digital input path Disabled (digital input tied to low). 
S * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
S * @var GPIO_T::DOUT
S * Offset: 0x08  GPIO Port [A/B/C/D/E/F] Data Output Value
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[n]     |DOUTn     |GPIOx Pin[n] Output Value
S * |        |          |Each of these bits controls the status of a GPIO pin when the GPIO pin is configured as
S * |        |          |Push-pull output, open-drain output or quasi-bidirectional mode.
S * |        |          |0 = GPIO port [A/B/C/D/E/F] Pin[n] will drive Low if the GPIO pin is configured as Push-pull
S * |        |          |output, Open-drain output or Quasi-bidirectional mode.
S * |        |          |1 = GPIO port [A/B/C/D/E/F] Pin[n] will drive High if the GPIO pin is configured as Push-pull
S * |        |          |output or Quasi-bidirectional mode.
S * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE. 
S * @var GPIO_T::DMASK
S * Offset: 0x0C  GPIO Port [A/B/C/D/E/F] Data Output Write Mask
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[n]     |DMASKn    |Port [A/B/C/D/E/F] Data Output Write Mask
S * |        |          |These bits are used to protect the corresponding register of GPIOx_DOUT bit[n].
S * |        |          |When the DMASK bit[n] is set to 1, the corresponding GPIOx_DOUT[n] bit is protected.
S * |        |          |If the write signal is masked, write data to the protect bit is ignored.
S * |        |          |0 = Corresponding GPIOx_DOUT[n] bit can be updated.
S * |        |          |1 = Corresponding GPIOx_DOUT[n] bit protected.
S * |        |          |Note1: This function only protects the corresponding GPIOx_DOUT[n] bit, and will not protect the
S * |        |          |corresponding bit control register (PAn_PDIO, PBn_PDIO, PCn_PDIO, PDn_PDIO, PEn_PDIO and
S * |        |          |PFn_PDIO). 
S * |        |          |Note2: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
S * @var GPIO_T::PIN
S * Offset: 0x10  GPIO Port [A/B/C/D/E/F] Pin Value
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[n]     |PINn      |Port [A/B/C/D/E/F] Pin Values
S * |        |          |Each bit of the register reflects the actual status of the respective GPIO pin.
S * |        |          |If the bit is 1, it indicates the corresponding pin status is high, else the pin status is low.
S * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE. 
S * @var GPIO_T::DBEN
S * Offset: 0x14  GPIO Port [A/B/C/D/E/F] De-bounce Enable
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[n]     |DBENn     |Port [A/B/C/D/E/F] Input Signal De-Bounce Enable
S * |        |          |DBEN[n] is used to enable the de-bounce function for each corresponding bit.
S * |        |          |If the input signal pulse width cannot be sampled by continuous two de-bounce sample cycle, the
S * |        |          |input signal transition is seen as the signal bounce and will not trigger the interrupt.
S * |        |          |The de-bounce clock source is controlled by DBNCECON[4], one de-bounce sample cycle period is
S * |        |          |controlled by DBNCECON[3:0].
S * |        |          |0 = Bit[n] de-bounce function Disabled.
S * |        |          |1 = Bit[n] de-bounce function Enabled.
S * |        |          |The de-bounce function is valid only for edge triggered interrupt.
S * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
S * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
S * @var GPIO_T::IMD
S * Offset: 0x18  GPIO Port [A/B/C/D/E/F] Interrupt Mode Control
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[n]     |IMDn      |Port [A/B/C/D/E/F] Edge Or Level Detection Interrupt Control
S * |        |          |IMD[n] is used to control the interrupt is by level trigger or by edge trigger.
S * |        |          |If the interrupt is by edge trigger, the trigger source can be controlled by de-bounce.
S * |        |          |If the interrupt is by level trigger, the input source is sampled by one HCLK.
S * |        |          |clock and generates the interrupt.
S * |        |          |0 = Edge trigger interrupt.
S * |        |          |1 = Level trigger interrupt.
S * |        |          |If the pin is set as the level trigger interrupt, only one level can be set on the registers
S * |        |          |GPIOx_IEN.
S * |        |          |If both levels to trigger interrupt are set, the setting is ignored and no interrupt will occur.
S * |        |          |The de-bounce function is valid only for edge triggered interrupt.
S * |        |          |If the interrupt mode is level triggered, the de-bounce enable bit is ignored.
S * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE. 
S * @var GPIO_T::IEN
S * Offset: 0x1C  GPIO Port [A/B/C/D/E/F] Interrupt Enable
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[n]     |IF_ENn    |Port [A/B/C/D/E/F] Interrupt Enable By Input Falling Edge Or Input Level Low
S * |        |          |IF_EN[n] is used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
S * |        |          |Set bit to 1 also enable the pin wake-up function.
S * |        |          |When setting the IF_EN[n] bit to 1:
S * |        |          |If the interrupt is level trigger, the input PIN[n] state at level "low" will generate the
S * |        |          |interrupt.
S * |        |          |If the interrupt is edge trigger, the input PIN[n] state change from "high-to-low" will generate
S * |        |          |the interrupt.
S * |        |          |0 = PIN[n] state low-level or high-to-low change interrupt Disabled.
S * |        |          |1 = PIN[n] state low-level or high-to-low change interrupt Enabled.
S * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
S * |[n+16]  |IR_ENn    |Port [A/B/C/D/E/F] Interrupt Enable By Input Rising Edge Or Input Level High
S * |        |          |IR_EN[n] used to enable the interrupt for each of the corresponding input GPIO_PIN[n].
S * |        |          |Set bit to 1 also enable the pin wake-up function.
S * |        |          |When setting the IR_EN[n] bit to 1:
S * |        |          |If the interrupt is level trigger, the input PIN[n] state at level "high" will generate the
S * |        |          |interrupt.
S * |        |          |If the interrupt is edge trigger, the input PIN[n] state change from "low-to-high" will generate
S * |        |          |the interrupt.
S * |        |          |0 = PIN[n] level-high or low-to-high interrupt Disabled.
S * |        |          |1 = PIN[n] level-high or low-to-high interrupt Enabled.
S * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE.
S * @var GPIO_T::ISRC
S * Offset: 0x20  GPIO Port [A/B/C/D/E/F] Interrupt Source Flag
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[n]     |ISRCn     |Port [A/B/C/D/E/F] Interrupt Source Flag
S * |        |          |Read :
S * |        |          |0 = No interrupt at GPIOx[n].
S * |        |          |1 = GPIOx[n] generates an interrupt.
S * |        |          |Write :
S * |        |          |0= No action.
S * |        |          |1= Clear the corresponding pending interrupt. 
S * |        |          |Note: Max. n = 3 for GPIOF; Max. n = 15 for GPIOA/GPIOB/GPIOC/GPIOD/GPIOE. 
S */
S
S    __IO uint32_t PMD;           /* Offset: 0x00  GPIO Port [A/B/C/D/E/F] Pin I/O Mode Control                       */
S    __IO uint32_t OFFD;          /* Offset: 0x04  GPIO Port [A/B/C/D/E/F] Pin Digital Input Path Disable Control     */
S    __IO uint32_t DOUT;          /* Offset: 0x08  GPIO Port [A/B/C/D/E/F] Data Output Value                          */
S    __IO uint32_t DMASK;         /* Offset: 0x0C  GPIO Port [A/B/C/D/E/F] Data Output Write Mask                     */
S    __I  uint32_t PIN;           /* Offset: 0x10  GPIO Port [A/B/C/D/E/F] Pin Value                                  */
S    __IO uint32_t DBEN;          /* Offset: 0x14  GPIO Port [A/B/C/D/E/F] De-bounce Enable                           */
S    __IO uint32_t IMD;           /* Offset: 0x18  GPIO Port [A/B/C/D/E/F] Interrupt Mode Control                     */
S    __IO uint32_t IEN;           /* Offset: 0x1C  GPIO Port [A/B/C/D/E/F] Interrupt Enable                           */
S    __IO uint32_t ISRC;          /* Offset: 0x20  GPIO Port [A/B/C/D/E/F] Interrupt Source Flag                      */
S
S} GPIO_T;
S
S
S
S
S
Stypedef struct
S{
S
S
S/**
S * @var GPIO_DBNCECON_T::DBNCECON
S * Offset: 0x180  External Interrupt De-bounce Control
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |DBCLKSEL  |De-Bounce Sampling Cycle Selection
S * |        |          |0000 = Sample interrupt input once per 1 clocks
S * |        |          |0001 = Sample interrupt input once per 2 clocks
S * |        |          |0010 = Sample interrupt input once per 4 clocks
S * |        |          |0011 = Sample interrupt input once per 8 clocks
S * |        |          |0100 = Sample interrupt input once per 16 clocks
S * |        |          |0101 = Sample interrupt input once per 32 clocks
S * |        |          |0110 = Sample interrupt input once per 64 clocks
S * |        |          |0111 = Sample interrupt input once per 128 clocks
S * |        |          |1000 = Sample interrupt input once per 256 clocks
S * |        |          |1001 = Sample interrupt input once per 2*256 clocks
S * |        |          |1010 = Sample interrupt input once per 4*256clocks
S * |        |          |1011 = Sample interrupt input once per 8*256 clocks
S * |        |          |1100 = Sample interrupt input once per 16*256 clocks
S * |        |          |1101 = Sample interrupt input once per 32*256 clocks
S * |        |          |1110 = Sample interrupt input once per 64*256 clocks
S * |        |          |1111 = Sample interrupt input once per 128*256 clocks
S * |        |          |Sample   interrupt input once per 128*256 clocks
S * |[4]     |DBCLKSRC  |De-Bounce Counter Clock Source Selection
S * |        |          |0 = De-bounce counter clock source is the HCLK.
S * |        |          |1 = De-bounce counter clock source is the internal 10 kHz low speed oscillator.
S * |[5]     |ICLK_ON   |Interrupt Clock On Mode
S * |        |          |0 = Edge detection circuit is active only if I/O pin corresponding GPIOx_IEN bit is set to 1.
S * |        |          |1 = All I/O pins edge detection circuit is always active after reset.
S * |        |          |It is recommended to turn off this bit to save system power if no special application concern.
S */
S
S    __IO uint32_t DBNCECON;      /* Offset: 0x180  External Interrupt De-bounce Control                              */
S
S} GPIO_DBNCECON_T;
S
S
S/**
S    @addtogroup GPIO_CONST GPIO Bit Field Definition
S    Constant Definitions for GPIO Controller
S@{ */
S
S
S/* GPIO PMD Bit Field Definitions */
S#define GPIO_PMD_PMD15_Pos          30                                          /*!< GPIO_T::PMD: PMD15 Position */
S#define GPIO_PMD_PMD15_Msk          (0x3ul << GPIO_PMD_PMD15_Pos)               /*!< GPIO_T::PMD: PMD15 Mask */
S
S#define GPIO_PMD_PMD14_Pos          28                                          /*!< GPIO_T::PMD: PMD14 Position */
S#define GPIO_PMD_PMD14_Msk          (0x3ul << GPIO_PMD_PMD14_Pos)               /*!< GPIO_T::PMD: PMD14 Mask */
S
S#define GPIO_PMD_PMD13_Pos          26                                          /*!< GPIO_T::PMD: PMD13 Position */
S#define GPIO_PMD_PMD13_Msk          (0x3ul << GPIO_PMD_PMD13_Pos)               /*!< GPIO_T::PMD: PMD13 Mask */
S
S#define GPIO_PMD_PMD12_Pos          24                                          /*!< GPIO_T::PMD: PMD12 Position */
S#define GPIO_PMD_PMD12_Msk          (0x3ul << GPIO_PMD_PMD12_Pos)               /*!< GPIO_T::PMD: PMD12 Mask */
S
S#define GPIO_PMD_PMD11_Pos          22                                          /*!< GPIO_T::PMD: PMD11 Position */
S#define GPIO_PMD_PMD11_Msk          (0x3ul << GPIO_PMD_PMD11_Pos)               /*!< GPIO_T::PMD: PMD11 Mask */
S
S#define GPIO_PMD_PMD10_Pos          20                                          /*!< GPIO_T::PMD: PMD10 Position */
S#define GPIO_PMD_PMD10_Msk          (0x3ul << GPIO_PMD_PMD10_Pos)               /*!< GPIO_T::PMD: PMD10 Mask */
S
S#define GPIO_PMD_PMD9_Pos           18                                          /*!< GPIO_T::PMD: PMD9 Position */
S#define GPIO_PMD_PMD9_Msk           (0x3ul << GPIO_PMD_PMD9_Pos)                /*!< GPIO_T::PMD: PMD9 Mask */
S
S#define GPIO_PMD_PMD8_Pos           16                                          /*!< GPIO_T::PMD: PMD8 Position */
S#define GPIO_PMD_PMD8_Msk           (0x3ul << GPIO_PMD_PMD8_Pos)                /*!< GPIO_T::PMD: PMD8 Mask */
S
S#define GPIO_PMD_PMD7_Pos           14                                          /*!< GPIO_T::PMD: PMD7 Position */
S#define GPIO_PMD_PMD7_Msk           (0x3ul << GPIO_PMD_PMD7_Pos)                /*!< GPIO_T::PMD: PMD7 Mask */
S
S#define GPIO_PMD_PMD6_Pos           12                                          /*!< GPIO_T::PMD: PMD6 Position */
S#define GPIO_PMD_PMD6_Msk           (0x3ul << GPIO_PMD_PMD6_Pos)                /*!< GPIO_T::PMD: PMD6 Mask */
S
S#define GPIO_PMD_PMD5_Pos           10                                          /*!< GPIO_T::PMD: PMD5 Position */
S#define GPIO_PMD_PMD5_Msk           (0x3ul << GPIO_PMD_PMD5_Pos)                /*!< GPIO_T::PMD: PMD5 Mask */
S
S#define GPIO_PMD_PMD4_Pos           8                                           /*!< GPIO_T::PMD: PMD4 Position */
S#define GPIO_PMD_PMD4_Msk           (0x3ul << GPIO_PMD_PMD4_Pos)                /*!< GPIO_T::PMD: PMD4 Mask */
S
S#define GPIO_PMD_PMD3_Pos           6                                           /*!< GPIO_T::PMD: PMD3 Position */
S#define GPIO_PMD_PMD3_Msk           (0x3ul << GPIO_PMD_PMD3_Pos)                /*!< GPIO_T::PMD: PMD3 Mask */
S
S#define GPIO_PMD_PMD2_Pos           4                                           /*!< GPIO_T::PMD: PMD2 Position */
S#define GPIO_PMD_PMD2_Msk           (0x3ul << GPIO_PMD_PMD2_Pos)                /*!< GPIO_T::PMD: PMD2 Mask */
S
S#define GPIO_PMD_PMD1_Pos           2                                           /*!< GPIO_T::PMD: PMD1 Position */
S#define GPIO_PMD_PMD1_Msk           (0x3ul << GPIO_PMD_PMD1_Pos)                /*!< GPIO_T::PMD: PMD1 Mask */
S
S#define GPIO_PMD_PMD0_Pos           0                                           /*!< GPIO_T::PMD: PMD0 Position */
S#define GPIO_PMD_PMD0_Msk           (0x3ul << GPIO_PMD_PMD0_Pos)                /*!< GPIO_T::PMD: PMD0 Mask */
S
S/* GPIO OFFD Bit Field Definitions */
S#define GPIO_OFFD_OFFD_Pos          16                                          /*!< GPIO_T::OFFD: OFFD Position */
S#define GPIO_OFFD_OFFD_Msk          (0xFFFFul << GPIO_OFFD_OFFD_Pos)            /*!< GPIO_T::OFFD: OFFD Mask */
S
S/* GPIO DOUT Bit Field Definitions */
S#define GPIO_DOUT_DOUT_Pos          0                                           /*!< GPIO_T::DOUT: DOUT Position */
S#define GPIO_DOUT_DOUT_Msk          (0xFFFFul << GPIO_DOUT_DOUT_Pos)            /*!< GPIO_T::DOUT: DOUT Mask */
S
S/* GPIO DMASK Bit Field Definitions */
S#define GPIO_DMASK_DMASK_Pos        0                                           /*!< GPIO_T::DMASK: DMASK Position */
S#define GPIO_DMASK_DMASK_Msk        (0xFFFFul << GPIO_DMASK_DMASK_Pos)          /*!< GPIO_T::DMASK: DMASK Mask */
S
S/* GPIO PIN Bit Field Definitions */
S#define GPIO_PIN_PIN_Pos            0                                           /*!< GPIO_T::PIN: PIN Position */
S#define GPIO_PIN_PIN_Msk            (0xFFFFul << GPIO_PIN_PIN_Pos)              /*!< GPIO_T::PIN: PIN Mask */
S
S/* GPIO DBEN Bit Field Definitions */
S#define GPIO_DBEN_DBEN_Pos          0                                           /*!< GPIO_T::DBEN: DBEN Position */
S#define GPIO_DBEN_DBEN_Msk          (0xFFFFul << GPIO_DBEN_DBEN_Pos)            /*!< GPIO_T::DBEN: DBEN Mask */
S
S/* GPIO IMD Bit Field Definitions */
S#define GPIO_IMD_IMD_Pos            0                                           /*!< GPIO_T::IMD: IMD Position */
S#define GPIO_IMD_IMD_Msk            (0xFFFFul << GPIO_IMD_IMD_Pos)              /*!< GPIO_T::IMD: IMD Mask */
S
S/* GPIO IEN Bit Field Definitions */
S#define GPIO_IEN_IR_EN_Pos          16                                          /*!< GPIO_T::IEN: IR_EN Position */
S#define GPIO_IEN_IR_EN_Msk          (0xFFFFul << GPIO_IEN_IR_EN_Pos)            /*!< GPIO_T::IEN: IR_EN Mask */
S
S#define GPIO_IEN_IF_EN_Pos          0                                           /*!< GPIO_T::IEN: IF_EN Position */
S#define GPIO_IEN_IF_EN_Msk          (0xFFFFul << GPIO_IEN_IF_EN_Pos)            /*!< GPIO_T::IEN: IF_EN Mask */
S
S/* GPIO ISRC Bit Field Definitions */
S#define GPIO_ISRC_ISRC_Pos          0                                           /*!< GPIO_T::ISRC: ISRC Position */
S#define GPIO_ISRC_ISRC_Msk          (0xFFFFul << GPIO_ISRC_ISRC_Pos)            /*!< GPIO_T::ISRC: ISRC Mask */
S
S/* GPIO DBNCECON Bit Field Definitions */
S#define GPIO_DBNCECON_ICLK_ON_Pos   5                                           /*!< GPIO_DBNCECON_T::DBNCECON: ICLK_ON  Position */
S#define GPIO_DBNCECON_ICLK_ON_Msk   (1ul << GPIO_DBNCECON_ICLK_ON_Pos)          /*!< GPIO_DBNCECON_T::DBNCECON: ICLK_ON  Mask */
S
S#define GPIO_DBNCECON_DBCLKSRC_Pos  4                                           /*!< GPIO_DBNCECON_T::DBNCECON: DBCLKSRC Position */
S#define GPIO_DBNCECON_DBCLKSRC_Msk  (1ul << GPIO_DBNCECON_DBCLKSRC_Pos)         /*!< GPIO_DBNCECON_T::DBNCECON: DBCLKSRC Mask */
S
S#define GPIO_DBNCECON_DBCLKSEL_Pos  0                                           /*!< GPIO_DBNCECON_T::DBNCECON: DBCLKSEL Position */
S#define GPIO_DBNCECON_DBCLKSEL_Msk  (0xFul << GPIO_DBNCECON_DBCLKSEL_Pos)       /*!< GPIO_DBNCECON_T::DBNCECON: DBCLKSEL Mask */
S/*@}*/ /* end of group GPIO_CONST */
S/*@}*/ /* end of group GPIO */
S
S
S
S/*---------------------- Inter-IC Bus Controller -------------------------*/
S/**
S    @addtogroup I2C Inter-IC Bus Controller (I2C)
S    Memory Mapped Structure for I2C Controller
S@{ */
S
S
Stypedef struct
S{
S
S
S/**
S * @var I2C_T::I2CON
S * Offset: 0x00  I2C Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[2]     |AA        |Assert Acknowledge Control
S * |        |          |When AA =1 prior to address or data received, an acknowledged (low level to I2Cn_SDA) will be
S * |        |          |returned during the acknowledge clock pulse on the I2Cn_SCL line when 
S * |        |          |1. A slave is acknowledging the address sent from master, 
S * |        |          |2. The receiver devices are acknowledging the data sent by transmitter.
S * |        |          |When AA=0 prior to address or data received, a Not acknowledged (high level to I2Cn_SDA) will be
S * |        |          |returned during the acknowledge clock pulse on the I2Cn_SCL line.
S * |[3]     |SI        |I2C Interrupt Flag
S * |        |          |When a new I2C state is present in the I2CSTATUS register, the SI flag is set by hardware, and
S * |        |          |if bit EI (I2CON [7]) is set, the I2C interrupt is requested.
S * |        |          |SI must be cleared by software.
S * |        |          |Clear SI by writing 1 to this bit.
S * |[4]     |STO       |I2C STOP Control
S * |        |          |In Master mode, setting STO to transmit a STOP condition to bus then I2C hardware will check the
S * |        |          |bus condition if a STOP condition is detected this bit will be cleared by hardware
S * |        |          |automatically.
S * |        |          |In a slave mode, setting STO resets I2C hardware to the defined "not addressed" slave mode.
S * |        |          |This means it is NO LONGER in the slave receiver mode to receive data from the master transmit
S * |        |          |device.
S * |[5]     |STA       |I2C START Control
S * |        |          |Setting STA to logic 1 to enter Master mode, the I2C hardware sends a START or repeat START
S * |        |          |condition to bus when the bus is free.
S * |[6]     |ENS1      |I2C Controller Enable
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |        |          |Set to enable I2C serial function controller.
S * |        |          |When ENS1=1 the I2C serial function enables.
S * |        |          |The multi-function pin function of I2Cn_SDA and I2Cn_SCL must set to I2C function first.
S * |[7]     |EI        |Enable Interrupt
S * |        |          |0 = I2C interrupt Disabled.
S * |        |          |1 = I2C interrupt Enabled.
S * @var I2C_T::I2CADDR0
S * Offset: 0x04  I2C Slave Address Register0
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |GC        |General Call Function
S * |        |          |0 = General Call Function Disabled.
S * |        |          |1 = General Call Function Enabled.
S * |[7:1]   |I2CADDR   |I2C Address Register
S * |        |          |The content of this register is irrelevant when I2C is in Master mode.
S * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own address.
S * |        |          |The I2C hardware will react if either of the address is matched.
S * @var I2C_T::I2CDAT
S * Offset: 0x08  I2C Data Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |I2CDAT    |I2C Data Register
S * |        |          |Bit [7:0] is located with the 8-bit transferred data of I2C serial port.
S * @var I2C_T::I2CSTATUS
S * Offset: 0x0C  I2C Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |I2CSTATUS |I2C Status Register
S * |        |          |The status register of I2C:
S * |        |          |The three least significant bits are always 0.
S * |        |          |The five most significant bits contain the status code.
S * |        |          |There are 26 possible status codes.
S * |        |          |When I2CSTATUS contains F8H, no serial interrupt is requested.
S * |        |          |All other I2CSTATUS values correspond to defined I2C states.
S * |        |          |When each of these states is entered, a status interrupt is requested (SI = 1).
S * |        |          |A valid status code is present in I2CSTATUS one cycle after SI is set by hardware and is still
S * |        |          |present one cycle after SI has been reset by software.
S * |        |          |In addition, states 00H stands for a Bus Error.
S * |        |          |A Bus Error occurs when a START or STOP condition is present at an illegal position in the
S * |        |          |formation frame.
S * |        |          |Example of illegal position are during the serial transfer of an address byte, a data byte or an
S * |        |          |acknowledge bit.
S * @var I2C_T::I2CLK
S * Offset: 0x10  I2C Clock Divided Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |I2CLK     |I2C clock divided Register
S * |        |          |The I2C clock rate bits: Data Baud Rate of I2C = (system clock) / (4x (I2CLK+1)).
S * |        |          |Note: The minimum value of I2CLK is 4.
S * @var I2C_T::I2CTOC
S * Offset: 0x14  I2C Time-out Counter Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |TIF       |Time-out Flag
S * |        |          |This bit is set by H/W when I2C time-out happened and it can interrupt CPU if I2C interrupt
S * |        |          |enable bit (EI) is set to 1.
S * |        |          |Note: Write 1 to clear this bit.
S * |[1]     |DIV4      |Time-out Counter Input Clock Divided by 4
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |        |          |When Enabled, The time-out period is extend 4 times.
S * |[2]     |ENTI      |Time-out Counter Enable/Disable
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |        |          |When Enabled, the 14-bit time-out counter will start counting when SI is clear.
S * |        |          |Setting flag SI to high will reset counter and re-start up counting after SI is cleared.
S * @var I2C_T::I2CADDR1
S * Offset: 0x18  I2C Slave Address Register1
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |GC        |General Call Function
S * |        |          |0 = General Call Function Disabled.
S * |        |          |1 = General Call Function Enabled.
S * |[7:1]   |I2CADDR   |I2C Address Register
S * |        |          |The content of this register is irrelevant when I2C is in Master mode.
S * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own address.
S * |        |          |The I2C hardware will react if either of the address is matched.
S * @var I2C_T::I2CADDR2
S * Offset: 0x1C  I2C Slave Address Register2
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |GC        |General Call Function
S * |        |          |0 = General Call Function Disabled.
S * |        |          |1 = General Call Function Enabled.
S * |[7:1]   |I2CADDR   |I2C Address Register
S * |        |          |The content of this register is irrelevant when I2C is in Master mode.
S * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own address.
S * |        |          |The I2C hardware will react if either of the address is matched.
S * @var I2C_T::I2CADDR3
S * Offset: 0x20  I2C Slave Address Register3
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |GC        |General Call Function
S * |        |          |0 = General Call Function Disabled.
S * |        |          |1 = General Call Function Enabled.
S * |[7:1]   |I2CADDR   |I2C Address Register
S * |        |          |The content of this register is irrelevant when I2C is in Master mode.
S * |        |          |In the slave mode, the seven most significant bits must be loaded with the chip's own address.
S * |        |          |The I2C hardware will react if either of the address is matched.
S * @var I2C_T::I2CADM0
S * Offset: 0x24  I2C Slave Address Mask Register0
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:1]   |I2CADM    |I2C Address Mask Register
S * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address
S * |        |          |register.).
S * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
S * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
S * |        |          |When the bit in the address mask register is set to one, it means the received corresponding
S * |        |          |address bit is don't-care.
S * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact
S * |        |          |the same as address register.
S * @var I2C_T::I2CADM1
S * Offset: 0x28  I2C Slave Address Mask Register1
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:1]   |I2CADM    |I2C Address Mask Register
S * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address
S * |        |          |register.).
S * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
S * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
S * |        |          |When the bit in the address mask register is set to one, it means the received corresponding
S * |        |          |address bit is don't-care.
S * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact
S * |        |          |the same as address register.
S * @var I2C_T::I2CADM2
S * Offset: 0x2C  I2C Slave Address Mask Register2
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:1]   |I2CADM    |I2C Address Mask Register
S * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address
S * |        |          |register.).
S * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
S * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
S * |        |          |When the bit in the address mask register is set to one, it means the received corresponding
S * |        |          |address bit is don't-care.
S * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact
S * |        |          |the same as address register.
S * @var I2C_T::I2CADM3
S * Offset: 0x30  I2C Slave Address Mask Register3
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:1]   |I2CADM    |I2C Address Mask Register
S * |        |          |0 = Mask Disabled (the received corresponding register bit should be exact the same as address
S * |        |          |register.).
S * |        |          |1 = Mask Enabled (the received corresponding address bit is don't care.).
S * |        |          |I2C bus controllers support multiple address recognition with four address mask register.
S * |        |          |When the bit in the address mask register is set to one, it means the received corresponding
S * |        |          |address bit is don't-care.
S * |        |          |If the bit is set to zero, that means the received corresponding register bit should be exact
S * |        |          |the same as address register.
S * @var I2C_T::I2CWKUPCON
S * Offset: 0x3C  I2C Wake-up Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |WKUPEN    |I2C Wake-up Enable
S * |        |          |0 = I2C wake-up function Disabled.
S * |        |          |1= I2C wake-up function Enabled.
S * @var I2C_T::I2CWKUPSTS
S * Offset: 0x40  I2C Wake-up Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |WKUPIF    |I2C Wake-up Flag
S * |        |          |When chip is woken up from Power-down mode by I2C, this bit is set to 1.
S * |        |          |Software can write 1 to clear this bit.
S */
S
S    __IO uint32_t I2CON;         /* Offset: 0x00  I2C Control Register                                               */
S    __IO uint32_t I2CADDR0;      /* Offset: 0x04  I2C Slave Address Register0                                        */
S    __IO uint32_t I2CDAT;        /* Offset: 0x08  I2C Data Register                                                  */
S    __I  uint32_t I2CSTATUS;     /* Offset: 0x0C  I2C Status Register                                                */
S    __IO uint32_t I2CLK;         /* Offset: 0x10  I2C Clock Divided Register                                         */
S    __IO uint32_t I2CTOC;        /* Offset: 0x14  I2C Time-out Counter Register                                      */
S    __IO uint32_t I2CADDR1;      /* Offset: 0x18  I2C Slave Address Register1                                        */
S    __IO uint32_t I2CADDR2;      /* Offset: 0x1C  I2C Slave Address Register2                                        */
S    __IO uint32_t I2CADDR3;      /* Offset: 0x20  I2C Slave Address Register3                                        */
S    __IO uint32_t I2CADM0;       /* Offset: 0x24  I2C Slave Address Mask Register0                                   */
S    __IO uint32_t I2CADM1;       /* Offset: 0x28  I2C Slave Address Mask Register1                                   */
S    __IO uint32_t I2CADM2;       /* Offset: 0x2C  I2C Slave Address Mask Register2                                   */
S    __IO uint32_t I2CADM3;       /* Offset: 0x30  I2C Slave Address Mask Register3                                   */
S    __I  uint32_t RESERVED0[2]; 
S    __IO uint32_t I2CWKUPCON;    /* Offset: 0x3C  I2C Wake-up Control Register                                       */
S    __IO uint32_t I2CWKUPSTS;    /* Offset: 0x40  I2C Wake-up Status Register                                        */
S
S} I2C_T;
S
S
S/**
S    @addtogroup I2C_CONST I2C Bit Field Definition
S    Constant Definitions for I2C Controller
S@{ */
S
S
S
S/* I2C I2CON Bit Field Definitions */
S#define I2C_I2CON_EI_Pos                        7                                       /*!< I2C_T::I2CON: EI Position */
S#define I2C_I2CON_EI_Msk                        (1ul << I2C_I2CON_EI_Pos)               /*!< I2C_T::I2CON: EI Mask */
S
S#define I2C_I2CON_ENS1_Pos                      6                                       /*!< I2C_T::I2CON: ENS1 Position */
S#define I2C_I2CON_ENS1_Msk                      (1ul << I2C_I2CON_ENS1_Pos)             /*!< I2C_T::I2CON: ENS1 Mask */
S
S#define I2C_I2CON_STA_Pos                       5                                       /*!< I2C_T::I2CON: STA Position */
S#define I2C_I2CON_STA_Msk                       (1ul << I2C_I2CON_STA_Pos)              /*!< I2C_T::I2CON: STA Mask */
S
S#define I2C_I2CON_STO_Pos                       4                                       /*!< I2C_T::I2CON: STO Position */
S#define I2C_I2CON_STO_Msk                       (1ul << I2C_I2CON_STO_Pos)              /*!< I2C_T::I2CON: STO Mask */
S
S#define I2C_I2CON_SI_Pos                        3                                       /*!< I2C_T::I2CON: SI Position */
S#define I2C_I2CON_SI_Msk                        (1ul << I2C_I2CON_SI_Pos)               /*!< I2C_T::I2CON: SI Mask */
S
S#define I2C_I2CON_AA_Pos                        2                                       /*!< I2C_T::I2CON: AA Position */
S#define I2C_I2CON_AA_Msk                        (1ul << I2C_I2CON_AA_Pos)               /*!< I2C_T::I2CON: AA Mask */
S
S/* I2C I2CADDR Bit Field Definitions */
S#define I2C_I2CADDR_I2CADDR_Pos                 1                                       /*!< I2C_T::I2CADDR1: I2CADDR Position */
S#define I2C_I2CADDR_I2CADDR_Msk                 (0x7Ful << I2C_I2CADDR_I2CADDR_Pos)     /*!< I2C_T::I2CADDR1: I2CADDR Mask */
S
S#define I2C_I2CADDR_GC_Pos                      0                                       /*!< I2C_T::I2CADDR1: GC Position */
S#define I2C_I2CADDR_GC_Msk                      (1ul << I2C_I2CADDR_GC_Pos)             /*!< I2C_T::I2CADDR1: GC Mask */
S
S/* I2C I2CDAT Bit Field Definitions */
S#define I2C_I2CDAT_I2CDAT_Pos                   0                                       /*!< I2C_T::I2CDAT: I2CDAT Position */
S#define I2C_I2CDAT_I2CDAT_Msk                   (0xFFul << I2C_I2CDAT_I2CDAT_Pos)       /*!< I2C_T::I2CDAT: I2CDAT Mask */
S
S/* I2C I2CSTATUS Bit Field Definitions */
S#define I2C_I2CSTATUS_I2CSTATUS_Pos             0                                       /*!< I2C_T::I2CSTATUS: I2CSTATUS Position */
S#define I2C_I2CSTATUS_I2CSTATUS_Msk             (0xFFul << I2C_I2CSTATUS_I2CSTATUS_Pos) /*!< I2C_T::I2CSTATUS: I2CSTATUS Mask */
S
S/* I2C I2CLK Bit Field Definitions */
S#define I2C_I2CLK_I2CLK_Pos                     0                                       /*!< I2C_T::I2CLK: I2CLK Position */
S#define I2C_I2CLK_I2CLK_Msk                     (0xFFul << I2C_I2CLK_I2CLK_Pos)         /*!< I2C_T::I2CLK: I2CLK Mask */
S
S/* I2C I2CTOC Bit Field Definitions */
S#define I2C_I2CTOC_ENTI_Pos                     2                                       /*!< I2C_T::I2CTOC: ENTI Position */
S#define I2C_I2CTOC_ENTI_Msk                     (1ul << I2C_I2CTOC_ENTI_Pos)            /*!< I2C_T::I2CTOC: ENTI Mask */
S
S#define I2C_I2CTOC_DIV4_Pos                     1                                       /*!< I2C_T::I2CTOC: DIV4 Position */
S#define I2C_I2CTOC_DIV4_Msk                     (1ul << I2C_I2CTOC_DIV4_Pos)            /*!< I2C_T::I2CTOC: DIV4 Mask */
S
S#define I2C_I2CTOC_TIF_Pos                      0                                       /*!< I2C_T::I2CTOC: TIF Position */
S#define I2C_I2CTOC_TIF_Msk                      (1ul << I2C_I2CTOC_TIF_Pos)             /*!< I2C_T::I2CTOC: TIF Mask */
S
S/* I2C I2CADM Bit Field Definitions */
S#define I2C_I2CADM_I2CADM_Pos                   1                                       /*!< I2C_T::I2CADM0: I2CADM Position */
S#define I2C_I2CADM_I2CADM_Msk                   (0x7Ful << I2C_I2CADM_I2CADM_Pos)       /*!< I2C_T::I2CADM0: I2CADM Mask */
S
S/* I2C I2CWKUPCON Bit Field Definitions */
S#define I2C_I2CWKUPCON_WKUPEN_Pos               0                                       /*!< I2C_T::I2CWKUPCON: WKUPEN Position */
S#define I2C_I2CWKUPCON_WKUPEN_Msk               (1ul << I2C_I2CWKUPCON_WKUPEN_Pos)      /*!< I2C_T::I2CWKUPCON: WKUPEN Mask */
S
S/* I2C I2CWKUPSTS Bit Field Definitions */
S#define I2C_I2CWKUPSTS_WKUPIF_Pos               0                                       /*!< I2C_T::I2CWKUPSTS: WKUPIF Position */
S#define I2C_I2CWKUPSTS_WKUPIF_Msk               (1ul << I2C_I2CWKUPSTS_WKUPIF_Pos)      /*!< I2C_T::I2CWKUPSTS: WKUPIF Mask */
S/*@}*/ /* end of group I2C_CONST */
S/*@}*/ /* end of group I2C */
S
S
S
S/*----------------------------- I2S Controller -------------------------------*/
S/** @addtogroup I2S Integrated Interchip Sound(I2S)
S  Memory Mapped Structure for I2S Interface Controller
S  @{
S */
S
S
Stypedef struct
S{
S
S
S/**
S * @var I2S_T::CON
S * Offset: 0x00  I2S Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |I2SEN     |I2S Controller Enable
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |[1]     |TXEN      |Transmit Enable
S * |        |          |0 = Data transmit Disabled.
S * |        |          |1 = Data transmit Enabled.
S * |[2]     |RXEN      |Receive Enable
S * |        |          |0 = Data receiving Disabled.
S * |        |          |1 = Data receiving Enabled.
S * |[3]     |MUTE      |Transmit Mute Enable
S * |        |          |0 = Transmit data is shifted from buffer.
S * |        |          |1 = Send zero on transmit channel.
S * |[5:4]   |WORDWIDTH |Word Width
S * |        |          |00 = data is 8-bit word.
S * |        |          |01 = data is 16-bit word.
S * |        |          |10 = data is 24-bit word.
S * |        |          |11 = data is 32-bit word.
S * |[6]     |MONO      |Monaural Data
S * |        |          |0 = Data is stereo format.
S * |        |          |1 = Data is monaural format.
S * |[7]     |FORMAT    |Data Format
S * |        |          |0 = I2S data format.
S * |        |          |1 = MSB justified data format.
S * |[8]     |SLAVE     |Slave Mode
S * |        |          |I2S can operate as master or slave.
S * |        |          |For Master mode, I2S_BCLK and I2S_LRCLK pins are output mode and send bit clock from NuMicro
S * |        |          |NUC230_240 series to Audio CODEC chip.
S * |        |          |In Slave mode, I2S_BCLK and I2S_LRCLK pins are input mode and I2S_BCLK and I2S_LRCLK signals are
S * |        |          |received from outer Audio CODEC chip.
S * |        |          |0 = Master mode.
S * |        |          |1 = Slave mode.
S * |[11:9]  |TXTH      |Transmit FIFO Threshold Level
S * |        |          |If the count of remaining data word (32 bits) in transmit FIFO is equal to or less than
S * |        |          |threshold level then TXTHF (I2SSTATUS[18]) is set.
S * |        |          |000 = 0 word data in transmit FIFO.
S * |        |          |001 = 1 word data in transmit FIFO.
S * |        |          |010 = 2 words data in transmit FIFO.
S * |        |          |011 = 3 words data in transmit FIFO.
S * |        |          |100 = 4 words data in transmit FIFO.
S * |        |          |101 = 5 words data in transmit FIFO.
S * |        |          |110 = 6 words data in transmit FIFO.
S * |        |          |111 = 7 words data in transmit FIFO.
S * |[14:12] |RXTH      |Receive FIFO Threshold Level
S * |        |          |When the count of received data word(s) in buffer is equal to or higher than threshold level,
S * |        |          |RXTHF (I2SSTATUS[10]) will be set.
S * |        |          |000 = 1 word data in receive FIFO.
S * |        |          |001 = 2 word data in receive FIFO.
S * |        |          |010 = 3 word data in receive FIFO.
S * |        |          |011 = 4 word data in receive FIFO.
S * |        |          |100 = 5 word data in receive FIFO.
S * |        |          |101 = 6 word data in receive FIFO.
S * |        |          |110 = 7 word data in receive FIFO.
S * |        |          |111 = 8 word data in receive FIFO.
S * |[15]    |MCLKEN    |Master Clock Enable
S * |        |          |If MCLKEN is set to 1, I2S controller will generate master clock on I2S_MCLK pin for external
S * |        |          |audio devices.
S * |        |          |0 = Master clock Disabled.
S * |        |          |1 = Master clock Enabled.
S * |[16]    |RCHZCEN   |Right Channel Zero Cross Detection Enable
S * |        |          |If this bit is set to 1, when right channel data sign bit change or next shift data bits are all
S * |        |          |0 then RZCF flag in I2SSTATUS register is set to 1.
S * |        |          |This function is only available in transmit operation.
S * |        |          |0 = Right channel zero cross detection Disabled.
S * |        |          |1 = Right channel zero cross detection Enabled.
S * |[17]    |LCHZCEN   |Left Channel Zero Cross Detection Enable
S * |        |          |If this bit is set to 1, when left channel data sign bit changes or next shift data bits are all
S * |        |          |0 then LZCF flag in I2SSTATUS register is set to 1.
S * |        |          |This function is only available in transmit operation.
S * |        |          |0 = Left channel zero cross detection Disabled.
S * |        |          |1 = Left channel zero cross detection Enabled.
S * |[18]    |CLR_TXFIFO|Clear Transmit FIFO
S * |        |          |Write 1 to clear transmit FIFO, internal pointer is reset to FIFO start point, and TX_LEVEL[3:0]
S * |        |          |returns to 0 and
S * |        |          |transmit FIFO becomes empty but data in transmit FIFO is not changed.
S * |        |          |This bit is cleared by hardware automatically. Returns 0 on read.
S * |[19]    |CLR_RXFIFO|Clear Receive FIFO
S * |        |          |Write 1 to clear receive FIFO, internal pointer is reset to FIFO start point, and RX_LEVEL[3:0]
S * |        |          |returns 0 and receive FIFO becomes empty.
S * |        |          |This bit is cleared by hardware automatically. Returns 0 on read.
S * |[20]    |TXDMA     |Enable Transmit DMA
S * |        |          |When TX DMA is enabled, I2S request DMA to transfer data from SRAM to transmit FIFO if FIFO is
S * |        |          |not full.
S * |        |          |0 = TX DMA Disabled.
S * |        |          |1 = TX DMA Enabled.
S * |[21]    |RXDMA     |Enable Receive DMA
S * |        |          |When RX DMA is enabled, I2S requests DMA to transfer data from receive FIFO to SRAM if FIFO is
S * |        |          |not empty.
S * |        |          |0 = RX DMA Disabled.
S * |        |          |1 = RX DMA Enabled.
S * |[23]    |RXLCH     |Receive Left Channel Enable
S * |        |          |When monaural format is selected (MONO = 1), I2S controller will receive right channel data if
S * |        |          |RXLCH is set to 0,
S * |        |          |and receive left channel data if RXLCH is set to 1.
S * |        |          |0 = Receive right channel data in Mono mode.
S * |        |          |1 = Receive left channel data in Mono mode.
S * @var I2S_T::CLKDIV
S * Offset: 0x04  I2S Clock Divider Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[2:0]   |MCLK_DIV  |Master Clock Divider
S * |        |          |If MCLKEN is set to 1, I2S controller will generate master clock for external audio devices.
S * |        |          |The master clock rate, F_MCLK, is determined by the following expressions.
S * |        |          |If MCLK_DIV >= 1, F_MCLK = F_I2SCLK/(2x(MCLK_DIV)).
S * |        |          |If MCLK_DIV = 0, F_MCLK = F_I2SCLK.
S * |        |          |F_I2SCLK is the frequency of I2S peripheral clock.
S * |        |          |In general, the master clock rate is 256 times sampling clock rate.
S * |[15:8]  |BCLK_DIV  |Bit Clock Divider
S * |        |          |The I2S controller will generate bit clock in Master mode.
S * |        |          |The bit clock rate, F_BCLK, is determined by the following expression.
S * |        |          |F_BCLK = F_I2SCLK /(2x(BCLK_DIV + 1)) , where F_I2SCLK is the frequency of I2S peripheral clock.
S * @var I2S_T::IE
S * Offset: 0x08  I2S Interrupt Enable Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |RXUDFIE   |Receive FIFO Underflow Interrupt Enable
S * |        |          |0 = Interrupt Disabled.
S * |        |          |1 = Interrupt Enabled.
S * |[1]     |RXOVFIE   |Receive FIFO Overflow Interrupt Enable
S * |        |          |0 = Interrupt Disabled.
S * |        |          |1 = Interrupt Enabled.
S * |[2]     |RXTHIE    |Receive FIFO Threshold Level Interrupt Enable
S * |        |          |When the count of data words in receive FIFO is equal to or higher than RXTH (I2SCON[14:12]) and
S * |        |          |this bit is set to 1, receive FIFO threshold level interrupt will be asserted.
S * |        |          |0 = Interrupt Disabled.
S * |        |          |1 = Interrupt Enabled.
S * |[8]     |TXUDFIE   |Transmit FIFO Underflow Interrupt Enable
S * |        |          |Interrupt occurs if this bit is set to 1 and the transmit FIFO underflow flag is set to 1.
S * |        |          |0 = Interrupt Disabled.
S * |        |          |1 = Interrupt Enabled.
S * |[9]     |TXOVFIE   |Transmit FIFO Overflow Interrupt Enable
S * |        |          |Interrupt occurs if this bit is set to 1 and the transmit FIFO overflow flag is set to 1
S * |        |          |0 = Interrupt Disabled.
S * |        |          |1 = Interrupt Enabled.
S * |[10]    |TXTHIE    |Transmit FIFO Threshold Level Interrupt Enable
S * |        |          |Interrupt occurs if this bit is set to 1 and the count of data words in transmit FIFO is less
S * |        |          |than TXTH (I2SCON[11:9]).
S * |        |          |0 = Interrupt Disabled.
S * |        |          |1 = Interrupt Enabled.
S * |[11]    |RZCIE     |Right Channel Zero-Cross Interrupt Enable
S * |        |          |Interrupt occurs if this bit is set to 1 and right channel zero-cross event is detected.
S * |        |          |0 = Interrupt Disabled.
S * |        |          |1 = Interrupt Enabled.
S * |[12]    |LZCIE     |Left Channel Zero-Cross Interrupt Enable
S * |        |          |Interrupt occurs if this bit is set to 1 and left channel zero-cross event is detected.
S * |        |          |0 = Interrupt Disabled.
S * |        |          |1 = Interrupt Enabled.
S * @var I2S_T::STATUS
S * Offset: 0x0C  I2S Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |I2SINT    |I2S Interrupt Flag
S * |        |          |This bit is wire-OR of I2STXINT and I2SRXINT bits.
S * |        |          |0 = No I2S interrupt.
S * |        |          |1 = I2S interrupt.
S * |        |          |Note: This bit is read only.
S * |[1]     |I2SRXINT  |I2S Receive Interrupt
S * |        |          |0 = No receive interrupt.
S * |        |          |1 = Receive interrupt.
S * |        |          |Note: This bit is read only.
S * |[2]     |I2STXINT  |I2S Transmit Interrupt
S * |        |          |0 = No transmit interrupt.
S * |        |          |1 = Transmit interrupt.
S * |        |          |Note: This bit is read only.
S * |[3]     |RIGHT     |Right Channel
S * |        |          |This bit indicates current transmit data is belong to which channel
S * |        |          |0 = Left channel.
S * |        |          |1 = Right channel.
S * |        |          |Note: This bit is read only.
S * |[8]     |RXUDF     |Receive FIFO Underflow Flag
S * |        |          |Underflow event will occur if read the empty receive FIFO.
S * |        |          |0 = No underflow event occurred.
S * |        |          |1 = Underflow.
S * |        |          |Note: Write 1 to clear this bit to 0.
S * |[9]     |RXOVF     |Receive FIFO Overflow Flag
S * |        |          |When receive FIFO is full and hardware attempt to write data to receive FIFO, this bit will be
S * |        |          |set to 1, data in 1st buffer will be overwrote.
S * |        |          |0 = No overflow.
S * |        |          |1 = Overflow.
S * |        |          |Note: Write 1 to clear this bit to 0.
S * |[10]    |RXTHF     |Receive FIFO Threshold Flag
S * |        |          |When data word(s) in receive FIFO is equal to or larger than threshold value set in RXTH
S * |        |          |(I2SCON[14:12]).
S * |        |          |The RXTHF bit becomes to 1.
S * |        |          |It keeps at 1 till RX_LEVEL (I2SSTATUS[27:24]) is less than RXTH.
S * |        |          |0 = Data word(s) in FIFO is less than threshold level.
S * |        |          |1 = Data word(s) in FIFO is equal to or larger than threshold level.
S * |        |          |Note: This bit is read only.
S * |[11]    |RXFULL    |Receive FIFO Full
S * |        |          |This bit reflects the count of data in receive FIFO is 8
S * |        |          |0 = Not full.
S * |        |          |1 = Full.
S * |        |          |Note: This bit is read only.
S * |[12]    |RXEMPTY   |Receive FIFO Empty
S * |        |          |This bit reflects the count of data in receive FIFO is 0
S * |        |          |0 = Not empty.
S * |        |          |1 = Empty.
S * |        |          |Note: This bit is read only.
S * |[16]    |TXUDF     |Transmit FIFO Underflow Flag
S * |        |          |If transmit FIFO is empty and hardware reads data from transmit FIFO. This bit will be set to 1.
S * |        |          |0 = No underflow.
S * |        |          |1 = Underflow.
S * |        |          |Note: Software can write 1 to clear this bit to 0.
S * |[17]    |TXOVF     |Transmit FIFO Overflow Flag
S * |        |          |This bit will be set to 1 if writes data to transmit FIFO when transmit FIFO is full.
S * |        |          |0 = No overflow.
S * |        |          |1 = Overflow.
S * |        |          |Note: Write 1 to clear this bit to 0.
S * |[18]    |TXTHF     |Transmit FIFO Threshold Flag
S * |        |          |When the count of data stored in transmit-FIFO is equal to or less than threshold value set in
S * |        |          |TXTH (I2SCON[11:9]).
S * |        |          |The TXTHF bit becomes to 1.
S * |        |          |It keeps at 1 till TX_LEVEL (I2SSTATUS[31:28]) is larger than TXTH.
S * |        |          |0 = Data word(s) in FIFO is larger than threshold level.
S * |        |          |1 = Data word(s) in FIFO is equal to or less than threshold level.
S * |        |          |Note: This bit is read only.
S * |[19]    |TXFULL    |Transmit FIFO Full
S * |        |          |This bit reflects data word number in transmit FIFO is 8
S * |        |          |0 = Not full.
S * |        |          |1 = Full.
S * |        |          |Note: This bit is read only.
S * |[20]    |TXEMPTY   |Transmit FIFO Empty
S * |        |          |This bit reflects data word number in transmit FIFO is 0
S * |        |          |0 = Not empty.
S * |        |          |1 = Empty.
S * |        |          |Note: This bit is read only.
S * |[21]    |TXBUSY    |Transmit Busy
S * |        |          |This bit is cleared to 0 when all data in transmit FIFO and shift buffer is shifted out.
S * |        |          |And set to 1 when 1st data is load to shift buffer.
S * |        |          |0 = Transmit shift buffer is empty.
S * |        |          |1 = Transmit shift buffer is not empty.
S * |        |          |Note: This bit is read only.
S * |[22]    |RZCF      |Right Channel Zero-Cross Flag
S * |        |          |It indicates the sign bit of right channel sample data is changed or all data bits are 0.
S * |        |          |0 = No zero-cross.
S * |        |          |1 = Right channel zero-cross event is detected.
S * |        |          |Note: Write 1 to clear this bit to 0.
S * |[23]    |LZCF      |Left Channel Zero-Cross Flag
S * |        |          |It indicates the sign bit of left channel sample data is changed or all data bits are 0.
S * |        |          |0 = No zero-cross.
S * |        |          |1 = Left channel zero-cross event is detected.
S * |        |          |Note: Write 1 to clear this bit to 0.
S * |[27:24] |RX_LEVEL  |Receive FIFO Level
S * |        |          |These bits indicate word number in receive FIFO
S * |        |          |0000 = No data.
S * |        |          |0001 = 1 word in receive FIFO.
S * |        |          |....
S * |        |          |1000 = 8 words in receive FIFO.
S * |[31:28] |TX_LEVEL  |Transmit FIFO Level
S * |        |          |These bits indicate word number in transmit FIFO
S * |        |          |0000 = No data.
S * |        |          |0001 = 1 word in transmit FIFO.
S * |        |          |....
S * |        |          |1000 = 8 words in transmit FIFO.
S * @var I2S_T::TXFIFO
S * Offset: 0x10  I2S Transmit FIFO Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |TXFIFO    |Transmit FIFO Register
S * |        |          |I2S contains 8 words (8x32 bits) data buffer for data transmit.
S * |        |          |Write data to this register to prepare data for transmission.
S * |        |          |The remaining word number is indicated by TX_LEVEL (I2SSTATUS[31:28]).
S * @var I2S_T::RXFIFO
S * Offset: 0x14  I2S Receive FIFO Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |RXFIFO    |Receive FIFO Register
S * |        |          |I2S contains 8 words (8x32 bits) data buffer for data receive.
S * |        |          |Read this register to get data of receive FIFO.
S * |        |          |The remaining data word number is indicated by RX_LEVEL (I2SSTATUS[27:24]).
S */
S
S    __IO uint32_t CON;           /* Offset: 0x00  I2S Control Register                                               */
S    __IO uint32_t CLKDIV;        /* Offset: 0x04  I2S Clock Divider Control Register                                 */
S    __IO uint32_t IE;            /* Offset: 0x08  I2S Interrupt Enable Register                                      */
S    __IO uint32_t STATUS;        /* Offset: 0x0C  I2S Status Register                                                */
S    __O  uint32_t TXFIFO;        /* Offset: 0x10  I2S Transmit FIFO Register                                         */
S    __I  uint32_t RXFIFO;        /* Offset: 0x14  I2S Receive FIFO Register                                          */
S
S} I2S_T;
S
S
S
S/**
S    @addtogroup I2S_CONST I2S Bit Field Definition
S    Constant Definitions for I2S Controller
S@{ */
S
S
S/* I2S I2SCON Bit Field Definitions */
S#define I2S_CON_RXLCH_Pos                    23                                   /*!< I2S_T::CON: RXLCH Position         */
S#define I2S_CON_RXLCH_Msk                    (1ul << I2S_CON_RXLCH_Pos)           /*!< I2S_T::CON: RXLCH Mask             */
S
S#define I2S_CON_RXDMA_Pos                    21                                   /*!< I2S_T::CON: RXDMA Position         */
S#define I2S_CON_RXDMA_Msk                    (1ul << I2S_CON_RXDMA_Pos)           /*!< I2S_T::CON: RXDMA Mask             */
S
S#define I2S_CON_TXDMA_Pos                    20                                   /*!< I2S_T::CON: TXDMA Position         */
S#define I2S_CON_TXDMA_Msk                    (1ul << I2S_CON_TXDMA_Pos)           /*!< I2S_T::CON: TXDMA Mask             */
S
S#define I2S_CON_CLR_RXFIFO_Pos               19                                   /*!< I2S_T::CON: CLR_RXFIFO Position    */
S#define I2S_CON_CLR_RXFIFO_Msk               (1ul << I2S_CON_CLR_RXFIFO_Pos)      /*!< I2S_T::CON: CLR_RXFIFO Mask        */
S
S#define I2S_CON_CLR_TXFIFO_Pos               18                                   /*!< I2S_T::CON: CLR_TXFIFO Position    */
S#define I2S_CON_CLR_TXFIFO_Msk               (1ul << I2S_CON_CLR_TXFIFO_Pos)      /*!< I2S_T::CON: CLR_TXFIFO Mask        */
S
S#define I2S_CON_LCHZCEN_Pos                  17                                   /*!< I2S_T::CON: LCHZCEN Position       */
S#define I2S_CON_LCHZCEN_Msk                  (1ul << I2S_CON_LCHZCEN_Pos)         /*!< I2S_T::CON: LCHZCEN Mask           */
S
S#define I2S_CON_RCHZCEN_Pos                  16                                   /*!< I2S_T::CON: RCHZCEN Position       */
S#define I2S_CON_RCHZCEN_Msk                  (1ul << I2S_CON_RCHZCEN_Pos)         /*!< I2S_T::CON: RCHZCEN Mask           */
S
S#define I2S_CON_MCLKEN_Pos                   15                                   /*!< I2S_T::CON: MCLKEN Position        */
S#define I2S_CON_MCLKEN_Msk                   (1ul << I2S_CON_MCLKEN_Pos)          /*!< I2S_T::CON: MCLKEN Mask            */
S
S#define I2S_CON_RXTH_Pos                     12                                   /*!< I2S_T::CON: RXTH Position          */
S#define I2S_CON_RXTH_Msk                     (7ul << I2S_CON_RXTH_Pos)            /*!< I2S_T::CON: RXTH Mask              */
S
S#define I2S_CON_TXTH_Pos                     9                                    /*!< I2S_T::CON: TXTH Position          */
S#define I2S_CON_TXTH_Msk                     (7ul << I2S_CON_TXTH_Pos)            /*!< I2S_T::CON: TXTH Mask              */
S
S#define I2S_CON_SLAVE_Pos                    8                                    /*!< I2S_T::CON: SLAVE Position         */
S#define I2S_CON_SLAVE_Msk                    (1ul << I2S_CON_SLAVE_Pos)           /*!< I2S_T::CON: SLAVE Mask             */
S
S#define I2S_CON_FORMAT_Pos                   7                                    /*!< I2S_T::CON: FORMAT Position        */
S#define I2S_CON_FORMAT_Msk                   (1ul << I2S_CON_FORMAT_Pos)          /*!< I2S_T::CON: FORMAT Mask            */
S
S#define I2S_CON_MONO_Pos                     6                                    /*!< I2S_T::CON: MONO Position          */
S#define I2S_CON_MONO_Msk                     (1ul << I2S_CON_MONO_Pos)            /*!< I2S_T::CON: MONO Mask              */
S
S#define I2S_CON_WORDWIDTH_Pos                4                                    /*!< I2S_T::CON: WORDWIDTH Position     */
S#define I2S_CON_WORDWIDTH_Msk                (3ul << I2S_CON_WORDWIDTH_Pos)       /*!< I2S_T::CON: WORDWIDTH Mask         */
S
S#define I2S_CON_MUTE_Pos                     3                                    /*!< I2S_T::CON: MUTE Position          */
S#define I2S_CON_MUTE_Msk                     (1ul << I2S_CON_MUTE_Pos)            /*!< I2S_T::CON: MUTE Mask              */
S
S#define I2S_CON_RXEN_Pos                     2                                    /*!< I2S_T::CON: RXEN Position          */
S#define I2S_CON_RXEN_Msk                     (1ul << I2S_CON_RXEN_Pos)            /*!< I2S_T::CON: RXEN Mask              */
S
S#define I2S_CON_TXEN_Pos                     1                                    /*!< I2S_T::CON: TXEN Position          */
S#define I2S_CON_TXEN_Msk                     (1ul << I2S_CON_TXEN_Pos)            /*!< I2S_T::CON: TXEN Mask              */
S
S#define I2S_CON_I2SEN_Pos                    0                                    /*!< I2S_T::CON: I2SEN Position         */
S#define I2S_CON_I2SEN_Msk                    (1ul << I2S_CON_I2SEN_Pos)           /*!< I2S_T::CON: I2SEN Mask             */
S
S/* I2S I2SCLKDIV Bit Field Definitions */
S#define I2S_CLKDIV_BCLK_DIV_Pos              8                                    /*!< I2S_T::CLKDIV: BCLK_DIV Position   */
S#define I2S_CLKDIV_BCLK_DIV_Msk              (0xFFul << I2S_CLKDIV_BCLK_DIV_Pos)  /*!< I2S_T::CLKDIV: BCLK_DIV Mask       */
S
S#define I2S_CLKDIV_MCLK_DIV_Pos              0                                    /*!< I2S_T::CLKDIV: MCLK_DIV Position   */
S#define I2S_CLKDIV_MCLK_DIV_Msk              (7ul << I2S_CLKDIV_MCLK_DIV_Pos)     /*!< I2S_T::CLKDIV: MCLK_DIV Mask       */
S
S/* I2S I2SIE Bit Field Definitions */
S#define I2S_IE_LZCIE_Pos                     12                                   /*!< I2S_T::IE: LZCIE Position          */
S#define I2S_IE_LZCIE_Msk                     (1ul << I2S_IE_LZCIE_Pos)            /*!< I2S_T::IE: LZCIE Mask              */
S
S#define I2S_IE_RZCIE_Pos                     11                                   /*!< I2S_T::IE: RZCIE Position          */
S#define I2S_IE_RZCIE_Msk                     (1ul << I2S_IE_RZCIE_Pos)            /*!< I2S_T::IE: RZCIE Mask              */
S
S#define I2S_IE_TXTHIE_Pos                    10                                   /*!< I2S_T::IE: TXTHIE Position         */
S#define I2S_IE_TXTHIE_Msk                    (1ul << I2S_IE_TXTHIE_Pos)           /*!< I2S_T::IE: TXTHIE Mask             */
S
S#define I2S_IE_TXOVFIE_Pos                   9                                    /*!< I2S_T::IE: TXOVFIE Position        */
S#define I2S_IE_TXOVFIE_Msk                   (1ul << I2S_IE_TXOVFIE_Pos)          /*!< I2S_T::IE: TXOVFIE Mask            */
S
S#define I2S_IE_TXUDFIE_Pos                   8                                    /*!< I2S_T::IE: TXUDFIE Position        */
S#define I2S_IE_TXUDFIE_Msk                   (1ul << I2S_IE_TXUDFIE_Pos)          /*!< I2S_T::IE: TXUDFIE Mask            */
S
S#define I2S_IE_RXTHIE_Pos                    2                                    /*!< I2S_T::IE: RXTHIE Position         */
S#define I2S_IE_RXTHIE_Msk                    (1ul << I2S_IE_RXTHIE_Pos)           /*!< I2S_T::IE: RXTHIE Mask             */
S
S#define I2S_IE_RXOVFIE_Pos                   1                                    /*!< I2S_T::IE: RXOVFIE Position        */
S#define I2S_IE_RXOVFIE_Msk                   (1ul << I2S_IE_RXOVFIE_Pos)          /*!< I2S_T::IE: RXOVFIE Mask            */
S
S#define I2S_IE_RXUDFIE_Pos                   0                                    /*!< I2S_T::IE: RXUDFIE Position        */
S#define I2S_IE_RXUDFIE_Msk                   (1ul << I2S_IE_RXUDFIE_Pos)          /*!< I2S_T::IE: RXUDFIE Mask            */
S
S
S/* I2S I2SSTATUS Bit Field Definitions */
S#define I2S_STATUS_TX_LEVEL_Pos              28                                      /*!< I2S_T::STATUS: TX_LEVEL Position   */
S#define I2S_STATUS_TX_LEVEL_Msk              (0xFul << I2S_STATUS_TX_LEVEL_Pos)   /*!< I2S_T::STATUS: TX_LEVEL Mask       */
S
S#define I2S_STATUS_RX_LEVEL_Pos              24                                   /*!< I2S_T::STATUS: RX_LEVEL Position   */
S#define I2S_STATUS_RX_LEVEL_Msk              (0xFul << I2S_STATUS_RX_LEVEL_Pos)   /*!< I2S_T::STATUS: RX_LEVEL Mask       */
S
S#define I2S_STATUS_LZCF_Pos                  23                                      /*!< I2S_T::STATUS: LZCF Position       */
S#define I2S_STATUS_LZCF_Msk                  (1ul << I2S_STATUS_LZCF_Pos)         /*!< I2S_T::STATUS: LZCF Mask           */
S
S#define I2S_STATUS_RZCF_Pos                  22                                   /*!< I2S_T::STATUS: RZCF Position       */
S#define I2S_STATUS_RZCF_Msk                  (1ul << I2S_STATUS_RZCF_Pos)         /*!< I2S_T::STATUS: RZCF Mask           */
S
S#define I2S_STATUS_TXBUSY_Pos                21                                   /*!< I2S_T::STATUS: TXBUSY Position     */
S#define I2S_STATUS_TXBUSY_Msk                (1ul << I2S_STATUS_TXBUSY_Pos)       /*!< I2S_T::STATUS: TXBUSY Mask         */
S
S#define I2S_STATUS_TXEMPTY_Pos               20                                   /*!< I2S_T::STATUS: TXEMPTY Position    */
S#define I2S_STATUS_TXEMPTY_Msk               (1ul << I2S_STATUS_TXEMPTY_Pos)      /*!< I2S_T::STATUS: TXEMPTY Mask        */
S
S#define I2S_STATUS_TXFULL_Pos                19                                   /*!< I2S_T::STATUS: TXFULL Position     */
S#define I2S_STATUS_TXFULL_Msk                (1ul << I2S_STATUS_TXFULL_Pos)       /*!< I2S_T::STATUS: TXFULL Mask         */
S
S#define I2S_STATUS_TXTHF_Pos                 18                                   /*!< I2S_T::STATUS: TXTHF Position      */
S#define I2S_STATUS_TXTHF_Msk                 (1ul << I2S_STATUS_TXTHF_Pos)        /*!< I2S_T::STATUS: TXTHF Mask          */
S
S#define I2S_STATUS_TXOVF_Pos                 17                                   /*!< I2S_T::STATUS: TXOVF Position      */
S#define I2S_STATUS_TXOVF_Msk                 (1ul << I2S_STATUS_TXOVF_Pos)        /*!< I2S_T::STATUS: TXOVF Mask          */
S
S#define I2S_STATUS_TXUDF_Pos                 16                                   /*!< I2S_T::STATUS: TXUDF Position      */
S#define I2S_STATUS_TXUDF_Msk                 (1ul << I2S_STATUS_TXUDF_Pos)        /*!< I2S_T::STATUS: TXUDF Mask          */
S
S#define I2S_STATUS_RXEMPTY_Pos               12                                   /*!< I2S_T::STATUS: RXEMPTY Position    */
S#define I2S_STATUS_RXEMPTY_Msk               (1ul << I2S_STATUS_RXEMPTY_Pos)      /*!< I2S_T::STATUS: RXEMPTY Mask        */
S
S#define I2S_STATUS_RXFULL_Pos                11                                   /*!< I2S_T::STATUS: RXFULL Position     */
S#define I2S_STATUS_RXFULL_Msk                (1ul << I2S_STATUS_RXFULL_Pos)       /*!< I2S_T::STATUS: RXFULL Mask         */
S
S#define I2S_STATUS_RXTHF_Pos                 10                                   /*!< I2S_T::STATUS: RXTHF Position      */
S#define I2S_STATUS_RXTHF_Msk                 (1ul << I2S_STATUS_RXTHF_Pos)        /*!< I2S_T::STATUS: RXTHF Mask          */
S
S#define I2S_STATUS_RXOVF_Pos                 9                                    /*!< I2S_T::STATUS: RXOVF Position      */
S#define I2S_STATUS_RXOVF_Msk                 (1ul << I2S_STATUS_RXOVF_Pos)        /*!< I2S_T::STATUS: RXOVF Mask          */
S
S#define I2S_STATUS_RXUDF_Pos                 8                                    /*!< I2S_T::STATUS: RXUDF Position      */
S#define I2S_STATUS_RXUDF_Msk                 (1ul << I2S_STATUS_RXUDF_Pos)        /*!< I2S_T::STATUS: RXUDF Mask          */
S
S#define I2S_STATUS_RIGHT_Pos                 3                                    /*!< I2S_T::STATUS: RIGHT Position      */
S#define I2S_STATUS_RIGHT_Msk                 (1ul << I2S_STATUS_RIGHT_Pos)        /*!< I2S_T::STATUS: RIGHT Mask          */
S
S#define I2S_STATUS_I2STXINT_Pos              2                                    /*!< I2S_T::STATUS: I2STXINT Position   */
S#define I2S_STATUS_I2STXINT_Msk              (1ul << I2S_STATUS_I2STXINT_Pos)     /*!< I2S_T::STATUS: I2STXINT Mask       */
S
S#define I2S_STATUS_I2SRXINT_Pos              1                                    /*!< I2S_T::STATUS: I2SRXINT Position   */
S#define I2S_STATUS_I2SRXINT_Msk              (1ul << I2S_STATUS_I2SRXINT_Pos)     /*!< I2S_T::STATUS: I2SRXINT Mask       */
S
S#define I2S_STATUS_I2SINT_Pos                0                                    /*!< I2S_T::STATUS: I2SINT Position     */
S#define I2S_STATUS_I2SINT_Msk                (1ul << I2S_STATUS_I2SINT_Pos)       /*!< I2S_T::STATUS: I2SINT Mask         */
S/*@}*/ /* end of group I2S_CONST */
S/*@}*/ /* end of group I2S */
S
S
S
S/*---------------------- Peripheral Direct Memory Access Controller -------------------------*/
S/**
S    @addtogroup PDMA Peripheral Direct Memory Access Controller (PDMA)
S    Memory Mapped Structure for PDMA Controller
S@{ */
S
S
Stypedef struct
S{
S
S
S/**
S * @var PDMA_T::CSR
S * Offset: 0x00  PDMA Channel x Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |PDMACEN   |PDMA Channel Enable
S * |        |          |Setting this bit to 1 enables PDMA operation.
S * |        |          |If this bit is cleared, PDMA will ignore all PDMA request and force Bus Master into IDLE state.
S * |        |          |Note: SW_RST(PDMA_CSRx[1], x= 0~8) will clear this bit.
S * |[1]     |SW_RST    |Software Engine Reset
S * |        |          |0 = No effect.
S * |        |          |1 = Reset the internal state machine, pointers and internal buffer.
S * |        |          |The contents of control register will not be cleared.
S * |        |          |This bit will be automatically cleared after few clock cycles.
S * |[3:2]   |MODE_SEL  |PDMA Mode Selection
S * |        |          |00 = Memory to Memory mode (Memory-to-Memory).
S * |        |          |01 = Peripheral to Memory mode (Peripheral-to-Memory).
S * |        |          |10 = Memory to Peripheral mode (Memory-to-Peripheral).
S * |[5:4]   |SAD_SEL   |Transfer Source Address Direction Selection
S * |        |          |00 = Transfer source address is increasing successively.
S * |        |          |01 = Reserved.
S * |        |          |10 = Transfer source address is fixed (This feature can be used when data where transferred from
S * |        |          |a single source to multiple destinations).
S * |        |          |11 = Reserved.
S * |[7:6]   |DAD_SEL   |Transfer Destination Address Direction Selection
S * |        |          |00 = Transfer destination address is increasing successively.
S * |        |          |01 = Reserved.
S * |        |          |10 = Transfer destination address is fixed.
S * |        |          |(This feature can be used when data where transferred from multiple sources to a single
S * |        |          |destination).
S * |        |          |11 = Reserved.
S * |[20:19] |APB_TWS   |Peripheral Transfer Width Selection
S * |        |          |00 = One word (32-bit) is transferred for every PDMA operation.
S * |        |          |01 = One byte (8-bit) is transferred for every PDMA operation.
S * |        |          |10 = One half-word (16-bit) is transferred for every PDMA operation.
S * |        |          |11 = Reserved.
S * |        |          |Note: This field is meaningful only when MODE_SEL (PDMA_CSRx[3:2]) is Peripheral to Memory mode
S * |        |          |(Peripheral-to-Memory) or Memory to Peripheral mode (Memory-to-Peripheral).
S * |[23]    |TRIG_EN   |Trigger Enable
S * |        |          |0 = No effect.
S * |        |          |1 = PDMA data read or write transfer Enabled.
S * |        |          |Note: When PDMA transfer completed, this bit will be cleared automatically.
S * |        |          |If the bus error occurs, all PDMA transfer will be stopped.
S * |        |          |Software must reset all PDMA channel, and then trigger again.
S * @var PDMA_T::SAR
S * Offset: 0x04  PDMA Channel x Source Address Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |PDMA_SAR  |PDMA Transfer Source Address Register
S * |        |          |This field indicates a 32-bit source address of PDMA.
S * |        |          |Note: The source address must be word alignment.
S * @var PDMA_T::DAR
S * Offset: 0x08  PDMA Channel x Destination Address Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |PDMA_DAR  |PDMA Transfer Destination Address Register
S * |        |          |This field indicates a 32-bit destination address of PDMA.
S * |        |          |Note: The destination address must be word alignment
S * @var PDMA_T::BCR
S * Offset: 0x0C  PDMA Channel x Transfer Byte Count Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |PDMA_BCR  |PDMA Transfer Byte Count Register
S * |        |          |This field indicates a 16-bit transfer byte count number of PDMA; it must be word alignment.
S * @var PDMA_T::POINT
S * Offset: 0x10  PDMA Channel x Internal buffer pointer Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |PDMA_POINT|PDMA Internal Buffer Pointer Register (Read Only)
S * |        |          |This field indicates the internal buffer pointer.
S * @var PDMA_T::CSAR
S * Offset: 0x14  PDMA Channel x Current Source Address Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |PDMA_CSAR |PDMA Current Source Address Register (Read Only)
S * |        |          |This field indicates the source address where the PDMA transfer just occurred.
S * @var PDMA_T::CDAR
S * Offset: 0x18  PDMA Channel x Current Destination Address Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |PDMA_CDAR |PDMA Current Destination Address Register (Read Only)
S * |        |          |This field indicates the destination address where the PDMA transfer just occurred.
S * @var PDMA_T::CBCR
S * Offset: 0x1C  PDMA Channel x Current Transfer Byte Count Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |PDMA_CBCR |PDMA Current Byte Count Register (Read Only)
S * |        |          |This field indicates the current remained byte count of PDMA.
S * |        |          |Note: This field value will be cleared to 0, when software set SW_RST (PDMA_CSRx[1]) to "1".
S * @var PDMA_T::IER
S * Offset: 0x20  PDMA Channel x Interrupt Enable Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |TABORT_IE |PDMA Read/Write Target Abort Interrupt Enable
S * |        |          |0 = Target abort interrupt generation Disabled during PDMA transfer.
S * |        |          |1 = Target abort interrupt generation Enabled during PDMA transfer.
S * |[1]     |BLKD_IE   |PDMA Block Transfer Done Interrupt Enable
S * |        |          |0 = Interrupt generator Disabled when PDMA transfer is done.
S * |        |          |1 = Interrupt generator Enabled when PDMA transfer is done.
S * @var PDMA_T::ISR
S * Offset: 0x24  PDMA Channel x Interrupt Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |TABORT_IF |PDMA Read/Write Target Abort Interrupt Flag
S * |        |          |Write 1 to clear this bit to 0.
S * |        |          |0 = No bus ERROR response received.
S * |        |          |1 = Bus ERROR response received.
S * |        |          |Note: This bit filed indicates bus master received ERROR response or not.
S * |        |          |If bus master received ERROR response, it means that target abort is happened.
S * |        |          |PDMA controller will stop transfer and respond this event to software then goes to IDLE state.
S * |        |          |When target abort occurred, software must reset PDMA, and then transfer those data again.
S * |[1]     |BLKD_IF   |PDMA Block Transfer Done Interrupt Flag
S * |        |          |This bit indicates that PDMA has finished all transfers.
S * |        |          |0 = Not finished.
S * |        |          |1 = Done.
S * |        |          |Write 1 to clear this bit to 0.
S * @var PDMA_T::SBUF
S * Offset: 0x80  PDMA Channel x Shared Buffer FIFO x Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |PDMA_SBUF0|PDMA Shared Buffer FIFO 0 (Read Only)
S * |        |          |Each channel has its own 1 word internal buffer.
S */
S
S    __IO uint32_t CSR;           /* Offset: 0x00  PDMA Channel x Control Register                                    */
S    __IO uint32_t SAR;           /* Offset: 0x04  PDMA Channel x Source Address Register                             */
S    __IO uint32_t DAR;           /* Offset: 0x08  PDMA Channel x Destination Address Register                        */
S    __IO uint32_t BCR;           /* Offset: 0x0C  PDMA Channel x Transfer Byte Count Register                        */
S    __I  uint32_t POINT;         /* Offset: 0x10  PDMA Channel x Internal buffer pointer Register                    */
S    __I  uint32_t CSAR;          /* Offset: 0x14  PDMA Channel x Current Source Address Register                     */
S    __I  uint32_t CDAR;          /* Offset: 0x18  PDMA Channel x Current Destination Address Register                */
S    __I  uint32_t CBCR;          /* Offset: 0x1C  PDMA Channel x Current Transfer Byte Count Register                */
S    __IO uint32_t IER;           /* Offset: 0x20  PDMA Channel x Interrupt Enable Register                           */
S    __IO uint32_t ISR;           /* Offset: 0x24  PDMA Channel x Interrupt Status Register                           */
S    __I  uint32_t RESERVE[22];  
S    __I  uint32_t SBUF;          /* Offset: 0x80  PDMA Channel x Shared Buffer FIFO x Register                       */
S
S} PDMA_T;
S
S
S
S
S
Stypedef struct
S{
S
S
S/**
S * @var PDMA_GCR_T::GCRCSR
S * Offset: 0x00  PDMA Global Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[8]     |CLK0_EN   |PDMA Controller Channel 0 Clock Enable Control
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |[9]     |CLK1_EN   |PDMA Controller Channel 1 Clock Enable Control
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |[10]    |CLK2_EN   |PDMA Controller Channel 2 Clock Enable Control
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |[11]    |CLK3_EN   |PDMA Controller Channel 3 Clock Enable Control
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |[12]    |CLK4_EN   |PDMA Controller Channel 4 Clock Enable Control
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |[13]    |CLK5_EN   |PDMA Controller Channel 5 Clock Enable Control
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |[14]    |CLK6_EN   |PDMA Controller Channel 6 Clock Enable Control
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |[15]    |CLK7_EN   |PDMA Controller Channel 7 Clock Enable Control
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |[16]    |CLK8_EN   |PDMA Controller Channel 8 Clock Enable Control
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |[24]    |CRC_CLK_EN|CRC Controller Clock Enable Control
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * @var PDMA_GCR_T::PDSSR0
S * Offset: 0x04  PDMA Service Selection Control Register 0
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |SPI0_RXSEL|PDMA SPI0 RX Selection
S * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral SPI0 RX.
S * |        |          |Software can change the channel RX setting by this field.
S * |        |          |For example, SPI0_RXSEL (PDMA_PDSSR0[3:0]) = 0110, that means SPI0_RX is connected to PDMA_CH6.
S * |        |          |0000: CH0
S * |        |          |0001: CH1
S * |        |          |0010: CH2
S * |        |          |0011: CH3
S * |        |          |0100: CH4
S * |        |          |0101: CH5
S * |        |          |0110: CH6
S * |        |          |0111: CH7
S * |        |          |1000: CH8
S * |        |          |Others : Reserved
S * |[7:4]   |SPI0_TXSEL|PDMA SPI0 TX Selection
S * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral SPI0 TX.
S * |        |          |Software can configure the TX channel setting by this field.
S * |        |          |The channel configuration is the same as SPI0_RXSEL (PDMA_PDSSR0[3:0]) field.
S * |        |          |Please refer to the explanation of SPI0_RXSEL (PDMA_PDSSR0[3:0]).
S * |[11:8]  |SPI1_RXSEL|PDMA SPI1 RX Selection
S * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral SPI1 RX.
S * |        |          |Software can configure the RX channel setting by this field.
S * |        |          |The channel configuration is the same as SPI0_RXSEL (PDMA_PDSSR0[3:0]) field.
S * |        |          |Please refer to the explanation of SPI0_RXSEL (PDMA_PDSSR0[3:0]).
S * |[15:12] |SPI1_TXSEL|PDMA SPI1 TX Selection
S * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral SPI1 TX.
S * |        |          |Software can configure the TX channel setting by this field.
S * |        |          |The channel configuration is the same as SPI0_RXSEL (PDMA_PDSSR0[3:0]) field.
S * |        |          |Please refer to the explanation of SPI0_RXSEL (PDMA_PDSSR0[3:0]).
S * |[19:16] |SPI2_RXSEL|PDMA SPI2 RX Selection
S * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral SPI2 RX.
S * |        |          |Software can configure the RX channel setting by this field.
S * |        |          |The channel configuration is the same as SPI0_RXSEL (PDMA_PDSSR0[3:0]) field.
S * |        |          |Please refer to the explanation of SPI0_RXSEL (PDMA_PDSSR0[3:0]).
S * |[23:20] |SPI2_TXSEL|PDMA SPI2 TX Selection
S * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral SPI2 TX.
S * |        |          |Software can configure the TX channel setting by this field.
S * |        |          |The channel configuration is the same as SPI0_RXSEL (PDMA_PDSSR0[3:0]) field.
S * |        |          |Please refer to the explanation of SPI0_RXSEL (PDMA_PDSSR0[3:0]).
S * |[27:24] |SPI3_RXSEL|PDMA SPI3 RX Selection
S * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral SPI3 RX.
S * |        |          |Software can configure the RX channel setting by this field.
S * |        |          |The channel configuration is the same as SPI0_RXSEL (PDMA_PDSSR0[3:0]) field.
S * |        |          |Please refer to the explanation of SPI0_RXSEL (PDMA_PDSSR0[3:0]).
S * |[31:28] |SPI3_TXSEL|PDMA SPI3 TX Selection
S * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral SPI3 TX.
S * |        |          |Software can configure the TX channel setting by this field.
S * |        |          |The channel configuration is the same as SPI0_RXSEL (PDMA_PDSSR0[3:0]) field.
S * |        |          |Please refer to the explanation of SPI0_RXSEL (PDMA_PDSSR0[3:0]).
S * @var PDMA_GCR_T::PDSSR1
S * Offset: 0x08  PDMA Service Selection Control Register 1
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |UART0_RXSEL|PDMA UART0 RX Selection
S * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral UART0 RX.
S * |        |          |Software can change the channel RX setting by this field.
S * |        |          |For example, UART0_RXSEL (PDMA_PDSSR1[3:0]) = 0110, which means UART0_RX is connected to
S * |        |          |PDMA_CH6.
S * |        |          |0000: CH0
S * |        |          |0001: CH1
S * |        |          |0010: CH2
S * |        |          |0011: CH3
S * |        |          |0100: CH4
S * |        |          |0101: CH5
S * |        |          |0110: CH6
S * |        |          |0111: CH7
S * |        |          |1000: CH8
S * |        |          |Others : Reserved
S * |[7:4]   |UART0_TXSEL|PDMA UART0 TX Selection
S * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral UART0 TX.
S * |        |          |Software can configure the TX channel setting by this field.
S * |        |          |The channel configuration is the same as UART0_RXSEL (PDMA_PDSSR1[3:0]) field.
S * |        |          |Please refer to the explanation of UART0_RXSEL (PDMA_PDSSR1[3:0]).
S * |[11:8]  |UART1_RXSEL|PDMA UART1 RX Selection
S * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral UART1 RX.
S * |        |          |Software can configure the RX channel setting by this field.
S * |        |          |The channel configuration is the same as UART0_RXSEL (PDMA_PDSSR1[3:0]) field.
S * |        |          |Please refer to the explanation of UART0_RXSEL (PDMA_PDSSR1[3:0]).
S * |[15:12] |UART1_TXSEL|PDMA UART1 TX Selection
S * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral UART1 TX.
S * |        |          |Software can configure the TX channel setting by this field.
S * |        |          |The channel configuration is the same as UART0_RXSEL (PDMA_PDSSR1[3:0]) field.
S * |        |          |Please refer to the explanation of UART0_RXSEL (PDMA_PDSSR1[3:0]).
S * |[27:24] |ADC_RXSEL |PDMA ADC RX Selection
S * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral ADC RX.
S * |        |          |Software can configure the RX channel setting by this field.
S * |        |          |The channel configuration is the same as UART0_RXSEL (PDMA_PDSSR1[3:0]) field.
S * |        |          |Please refer to the explanation of UART0_RXSEL (PDMA_PDSSR1[3:0]).
S * @var PDMA_GCR_T::GCRISR
S * Offset: 0x0C  PDMA Global Interrupt Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |INTR0     |Interrupt Status Of Channel 0
S * |        |          |This bit is the interrupt status of PDMA channel0.
S * |        |          |Note: This bit is read only
S * |[1]     |INTR1     |Interrupt Status Of Channel 1
S * |        |          |This bit is the interrupt status of PDMA channel1.
S * |        |          |Note: This bit is read only
S * |[2]     |INTR2     |Interrupt Status Of Channel 2
S * |        |          |This bit is the interrupt status of PDMA channel2.
S * |        |          |Note: This bit is read only
S * |[3]     |INTR3     |Interrupt Status Of Channel 3
S * |        |          |This bit is the interrupt status of PDMA channel3.
S * |        |          |Note: This bit is read only
S * |[4]     |INTR4     |Interrupt Status Of Channel 4
S * |        |          |This bit is the interrupt status of PDMA channel4.
S * |        |          |Note: This bit is read only
S * |[5]     |INTR5     |Interrupt Status Of Channel 5
S * |        |          |This bit is the interrupt status of PDMA channel5.
S * |        |          |Note: This bit is read only
S * |[6]     |INTR6     |Interrupt Status Of Channel 6
S * |        |          |This bit is the interrupt status of PDMA channel6.
S * |        |          |Note: This bit is read only
S * |[7]     |INTR7     |Interrupt Status Of Channel 7
S * |        |          |This bit is the interrupt status of PDMA channel7.
S * |        |          |Note: This bit is read only
S * |[8]     |INTR8     |Interrupt Status Of Channel 8
S * |        |          |This bit is the interrupt status of PDMA channel8.
S * |        |          |Note: This bit is read only
S * |[16]    |INTRCRC   |Interrupt Status Of CRC Controller
S * |        |          |This bit is the interrupt status of CRC controller
S * |        |          |Note: This bit is read only
S * |[31]    |INTR      |Interrupt Status
S * |        |          |This bit is the interrupt status of PDMA controller.
S * |        |          |Note: This bit is read only
S * @var PDMA_GCR_T::PDSSR2
S * Offset: 0x10  PDMA Service Selection Control Register 2
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |I2S_RXSEL |PDMA I2S RX Selection
S * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral I2S RX.
S * |        |          |Software can change the channel RX setting by this field.
S * |        |          |For example: I2S_RXSEL (PDMA_PDSSR2[3:0]) = 0110, that means I2S_RX is connected to PDMA_CH6.
S * |        |          |0000: CH0
S * |        |          |0001: CH1
S * |        |          |0010: CH2
S * |        |          |0011: CH3
S * |        |          |0100: CH4
S * |        |          |0101: CH5
S * |        |          |0110: CH6
S * |        |          |0111: CH7
S * |        |          |1000: CH8
S * |        |          |Others : Reserved
S * |[7:4]   |I2S_TXSEL |PDMA I2S TX Selection
S * |        |          |This field defines which PDMA channel is connected to the on-chip peripheral I2S TX.
S * |        |          |Software can configure the TX channel setting by this field.
S * |        |          |The channel configuration is the same as I2S_RXSEL (PDMA_PDSSR2[3:0]) field.
S * |        |          |Please refer to the explanation of I2S_RXSEL (PDMA_PDSSR2[3:0]).
S */
S
S    __IO uint32_t GCRCSR;        /* Offset: 0x00  PDMA Global Control Register                                       */
S    __IO uint32_t PDSSR0;        /* Offset: 0x04  PDMA Service Selection Control Register 0                          */
S    __IO uint32_t PDSSR1;        /* Offset: 0x08  PDMA Service Selection Control Register 1                          */
S    __IO uint32_t GCRISR;        /* Offset: 0x0C  PDMA Global Interrupt Status Register                              */
S    __IO uint32_t PDSSR2;        /* Offset: 0x10  PDMA Service Selection Control Register 2                          */
S
S} PDMA_GCR_T;
S
S
S
S/**
S    @addtogroup PDMA_CONST PDMA Bit Field Definition
S    Constant Definitions for GPIO Controller
S@{ */
S
S
S/* PDMA CSR Bit Field Definitions */
S#define PDMA_CSR_TRIG_EN_Pos                        23                              /*!< PDMA_T::CSR: TRIG_EN Position */
S#define PDMA_CSR_TRIG_EN_Msk                        (1ul << PDMA_CSR_TRIG_EN_Pos)   /*!< PDMA_T::CSR: TRIG_EN Mask */
S
S#define PDMA_CSR_APB_TWS_Pos                        19                              /*!< PDMA_T::CSR: APB_TWS Position */
S#define PDMA_CSR_APB_TWS_Msk                        (3ul << PDMA_CSR_APB_TWS_Pos)   /*!< PDMA_T::CSR: APB_TWS Mask */
S
S#define PDMA_CSR_DAD_SEL_Pos                        6                               /*!< PDMA_T::CSR: DAD_SEL Position */
S#define PDMA_CSR_DAD_SEL_Msk                        (3ul << PDMA_CSR_DAD_SEL_Pos)   /*!< PDMA_T::CSR: DAD_SEL Mask */
S
S#define PDMA_CSR_SAD_SEL_Pos                        4                               /*!< PDMA_T::CSR: SAD_SEL Position */
S#define PDMA_CSR_SAD_SEL_Msk                        (3ul << PDMA_CSR_SAD_SEL_Pos)   /*!< PDMA_T::CSR: SAD_SEL Mask */
S
S#define PDMA_CSR_MODE_SEL_Pos                       2                               /*!< PDMA_T::CSR: MODE_SEL Position */
S#define PDMA_CSR_MODE_SEL_Msk                       (3ul << PDMA_CSR_MODE_SEL_Pos)  /*!< PDMA_T::CSR: MODE_SEL Mask */
S
S#define PDMA_CSR_SW_RST_Pos                         1                               /*!< PDMA_T::CSR: SW_RST Position */
S#define PDMA_CSR_SW_RST_Msk                         (1ul << PDMA_CSR_SW_RST_Pos)    /*!< PDMA_T::CSR: SW_RST Mask */
S
S#define PDMA_CSR_PDMACEN_Pos                        0                               /*!< PDMA_T::CSR: PDMACEN Position */
S#define PDMA_CSR_PDMACEN_Msk                        (1ul << PDMA_CSR_PDMACEN_Pos)   /*!< PDMA_T::CSR: PDMACEN Mask */
S
S/* PDMA BCR Bit Field Definitions */
S#define PDMA_BCR_BCR_Pos                            0                               /*!< PDMA_T::BCR: BCR Position */
S#define PDMA_BCR_BCR_Msk                            (0xFFFFul << PDMA_BCR_BCR_Pos)  /*!< PDMA_T::BCR: BCR Mask */
S
S/* PDMA POINT Bit Field Definitions */
S#define PDMA_POINT_POINT_Pos                        0                               /*!< PDMA_T::POINT: POINT Position */
S#define PDMA_POINT_POINT_Msk                        (0xFul << PDMA_POINT_POINT_Pos) /*!< PDMA_T::POINT: POINT Mask */
S
S/* PDMA CBCR Bit Field Definitions */
S#define PDMA_CBCR_CBCR_Pos                          0                                   /*!< PDMA_T::CBCR: CBCR Position */
S#define PDMA_CBCR_CBCR_Msk                          (0xFFFFul << PDMA_CBCR_CBCR_Pos)    /*!< PDMA_T::CBCR: CBCR Mask */
S
S
S/* PDMA IER Bit Field Definitions */
S#define PDMA_IER_BLKD_IE_Pos                        1                               /*!< PDMA_T::IER: BLKD_IE Position */
S#define PDMA_IER_BLKD_IE_Msk                        (1ul << PDMA_IER_BLKD_IE_Pos)   /*!< PDMA_T::IER: BLKD_IE Mask */
S
S#define PDMA_IER_TABORT_IE_Pos                      0                               /*!< PDMA_T::IER: TABORT_IE Position */
S#define PDMA_IER_TABORT_IE_Msk                      (1ul << PDMA_IER_TABORT_IE_Pos) /*!< PDMA_T::IER: TABORT_IE Mask */
S
S/* PDMA ISR Bit Field Definitions */
S#define PDMA_ISR_BLKD_IF_Pos                        1                               /*!< PDMA_T::ISR: BLKD_IF Position */
S#define PDMA_ISR_BLKD_IF_Msk                        (1ul << PDMA_ISR_BLKD_IF_Pos)   /*!< PDMA_T::ISR: BLKD_IF Mask */
S
S#define PDMA_ISR_TABORT_IF_Pos                      0                               /*!< PDMA_T::ISR: TABORT_IF Position */
S#define PDMA_ISR_TABORT_IF_Msk                      (1ul << PDMA_ISR_TABORT_IF_Pos) /*!< PDMA_T::ISR: TABORT_IF Mask */
S
S/* PDMA GCRCSR Bit Field Definitions */
S#define PDMA_GCRCSR_CRC_CLK_EN_Pos                  24                                  /*!< PDMA_GCR_T::GCRCSR: CRC_CLK_EN Position */
S#define PDMA_GCRCSR_CRC_CLK_EN_Msk                  (1ul << PDMA_GCRCSR_CRC_CLK_EN_Pos) /*!< PDMA_GCR_T::GCRCSR: CRC_CLK_EN Mask */
S
S#define PDMA_GCRCSR_CLK8_EN_Pos                     16                                  /*!< PDMA_GCR_T::GCRCSR: CLK8_EN Position */
S#define PDMA_GCRCSR_CLK8_EN_Msk                     (1ul << PDMA_GCRCSR_CLK8_EN_Pos)    /*!< PDMA_GCR_T::GCRCSR: CLK8_EN Mask */
S
S#define PDMA_GCRCSR_CLK7_EN_Pos                     15                                  /*!< PDMA_GCR_T::GCRCSR: CLK7_EN Position */
S#define PDMA_GCRCSR_CLK7_EN_Msk                     (1ul << PDMA_GCRCSR_CLK7_EN_Pos)    /*!< PDMA_GCR_T::GCRCSR: CLK7_EN Mask */
S
S#define PDMA_GCRCSR_CLK6_EN_Pos                     14                                  /*!< PDMA_GCR_T::GCRCSR: CLK6_EN Position */
S#define PDMA_GCRCSR_CLK6_EN_Msk                     (1ul << PDMA_GCRCSR_CLK6_EN_Pos)    /*!< PDMA_GCR_T::GCRCSR: CLK6_EN Mask */
S
S#define PDMA_GCRCSR_CLK5_EN_Pos                     13                                  /*!< PDMA_GCR_T::GCRCSR: CLK5_EN Position */
S#define PDMA_GCRCSR_CLK5_EN_Msk                     (1ul << PDMA_GCRCSR_CLK5_EN_Pos)    /*!< PDMA_GCR_T::GCRCSR: CLK5_EN Mask */
S
S#define PDMA_GCRCSR_CLK4_EN_Pos                     12                                  /*!< PDMA_GCR_T::GCRCSR: CLK4_EN Position */
S#define PDMA_GCRCSR_CLK4_EN_Msk                     (1ul << PDMA_GCRCSR_CLK4_EN_Pos)    /*!< PDMA_GCR_T::GCRCSR: CLK4_EN Mask */
S
S#define PDMA_GCRCSR_CLK3_EN_Pos                     11                                  /*!< PDMA_GCR_T::GCRCSR: CLK3_EN Position */
S#define PDMA_GCRCSR_CLK3_EN_Msk                     (1ul << PDMA_GCRCSR_CLK3_EN_Pos)    /*!< PDMA_GCR_T::GCRCSR: CLK3_EN Mask */
S
S#define PDMA_GCRCSR_CLK2_EN_Pos                     10                                  /*!< PDMA_GCR_T::GCRCSR: CLK2_EN Position */
S#define PDMA_GCRCSR_CLK2_EN_Msk                     (1ul << PDMA_GCRCSR_CLK2_EN_Pos)    /*!< PDMA_GCR_T::GCRCSR: CLK2_EN Mask */
S
S#define PDMA_GCRCSR_CLK1_EN_Pos                     9                                   /*!< PDMA_GCR_T::GCRCSR: CLK1_EN Position */
S#define PDMA_GCRCSR_CLK1_EN_Msk                     (1ul << PDMA_GCRCSR_CLK1_EN_Pos)    /*!< PDMA_GCR_T::GCRCSR: CLK1_EN Mask */
S
S#define PDMA_GCRCSR_CLK0_EN_Pos                     8                                   /*!< PDMA_GCR_T::GCRCSR: CLK0_EN Position */
S#define PDMA_GCRCSR_CLK0_EN_Msk                     (1ul << PDMA_GCRCSR_CLK0_EN_Pos)    /*!< PDMA_GCR_T::GCRCSR: CLK0_EN Mask */
S
S/* PDMA PDSSR0 Bit Field Definitions */
S#define PDMA_PDSSR0_SPI3_TXSEL_Pos                  28                                      /*!< PDMA_GCR_T::PDSSR0: SPI3_TXSEL Position */
S#define PDMA_PDSSR0_SPI3_TXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI3_TXSEL_Pos)   /*!< PDMA_GCR_T::PDSSR0: SPI3_TXSEL Mask */
S
S#define PDMA_PDSSR0_SPI3_RXSEL_Pos                  24                                      /*!< PDMA_GCR_T::PDSSR0: SPI3_RXSEL Position */
S#define PDMA_PDSSR0_SPI3_RXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI3_RXSEL_Pos)   /*!< PDMA_GCR_T::PDSSR0: SPI3_RXSEL Mask */
S
S#define PDMA_PDSSR0_SPI2_TXSEL_Pos                  20                                      /*!< PDMA_GCR_T::PDSSR0: SPI2_TXSEL Position */
S#define PDMA_PDSSR0_SPI2_TXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI2_TXSEL_Pos)   /*!< PDMA_GCR_T::PDSSR0: SPI2_TXSEL Mask */
S
S#define PDMA_PDSSR0_SPI2_RXSEL_Pos                  16                                      /*!< PDMA_GCR_T::PDSSR0: SPI2_RXSEL Position */
S#define PDMA_PDSSR0_SPI2_RXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI2_RXSEL_Pos)   /*!< PDMA_GCR_T::PDSSR0: SPI2_RXSEL Mask */
S
S#define PDMA_PDSSR0_SPI1_TXSEL_Pos                  12                                      /*!< PDMA_GCR_T::PDSSR0: SPI1_TXSEL Position */
S#define PDMA_PDSSR0_SPI1_TXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI1_TXSEL_Pos)   /*!< PDMA_GCR_T::PDSSR0: SPI1_TXSEL Mask */
S
S#define PDMA_PDSSR0_SPI1_RXSEL_Pos                  8                                       /*!< PDMA_GCR_T::PDSSR0: SPI1_RXSEL Position */
S#define PDMA_PDSSR0_SPI1_RXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI1_RXSEL_Pos)   /*!< PDMA_GCR_T::PDSSR0: SPI1_RXSEL Mask */
S
S#define PDMA_PDSSR0_SPI0_TXSEL_Pos                  4                                       /*!< PDMA_GCR_T::PDSSR0: SPI0_TXSEL Position */
S#define PDMA_PDSSR0_SPI0_TXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI0_TXSEL_Pos)   /*!< PDMA_GCR_T::PDSSR0: SPI0_TXSEL Mask */
S
S#define PDMA_PDSSR0_SPI0_RXSEL_Pos                  0                                       /*!< PDMA_GCR_T::PDSSR0: SPI0_RXSEL Position */
S#define PDMA_PDSSR0_SPI0_RXSEL_Msk                  (0xFul << PDMA_PDSSR0_SPI0_RXSEL_Pos)   /*!< PDMA_GCR_T::PDSSR0: SPI0_RXSEL Mask */
S
S/* PDMA PDSSR1 Bit Field Definitions */
S#define PDMA_PDSSR1_ADC_RXSEL_Pos                   24                                      /*!< PDMA_GCR_T::PDSSR1: ADC_RXSEL Position */
S#define PDMA_PDSSR1_ADC_RXSEL_Msk                   (0xFul << PDMA_PDSSR1_ADC_RXSEL_Pos)    /*!< PDMA_GCR_T::PDSSR1: ADC_RXSEL Mask */
S
S#define PDMA_PDSSR1_UART1_TXSEL_Pos                 12                                      /*!< PDMA_GCR_T::PDSSR1: UART1_TXSEL Position */
S#define PDMA_PDSSR1_UART1_TXSEL_Msk                 (0xFul << PDMA_PDSSR1_UART1_TXSEL_Pos)  /*!< PDMA_GCR_T::PDSSR1: UART1_TXSEL Mask */
S
S#define PDMA_PDSSR1_UART1_RXSEL_Pos                 8                                       /*!< PDMA_GCR_T::PDSSR1: UART1_RXSEL Position */
S#define PDMA_PDSSR1_UART1_RXSEL_Msk                 (0xFul << PDMA_PDSSR1_UART1_RXSEL_Pos)  /*!< PDMA_GCR_T::PDSSR1: UART1_RXSEL Mask */
S
S#define PDMA_PDSSR1_UART0_TXSEL_Pos                 4                                       /*!< PDMA_GCR_T::PDSSR1: UART0_TXSEL Position */
S#define PDMA_PDSSR1_UART0_TXSEL_Msk                 (0xFul << PDMA_PDSSR1_UART0_TXSEL_Pos)  /*!< PDMA_GCR_T::PDSSR1: UART0_TXSEL Mask */
S
S#define PDMA_PDSSR1_UART0_RXSEL_Pos                 0                                       /*!< PDMA_GCR_T::PDSSR1: UART0_RXSEL Position */
S#define PDMA_PDSSR1_UART0_RXSEL_Msk                 (0xFul << PDMA_PDSSR1_UART0_RXSEL_Pos)  /*!< PDMA_GCR_T::PDSSR1: UART0_RXSEL Mask */
S
S/* PDMA GCRISR Bit Field Definitions */
S#define PDMA_GCRISR_INTR_Pos                        31                              /*!< PDMA_GCR_T::GCRISR: INTR Position */
S#define PDMA_GCRISR_INTR_Msk                        (1ul << PDMA_GCRISR_INTR_Pos)   /*!< PDMA_GCR_T::GCRISR: INTR Mask */
S
S#define PDMA_GCRISR_INTRCRC_Pos                     16                               /*!< PDMA_GCR_T::GCRISR: INTRCRC Position */
S#define PDMA_GCRISR_INTRCRC_Msk                     (1ul << PDMA_GCRISR_INTRCRC_Pos) /*!< PDMA_GCR_T::GCRISR: INTRCRC Mask */
S
S#define PDMA_GCRISR_INTR8_Pos                       8                               /*!< PDMA_GCR_T::GCRISR: INTR8 Position */
S#define PDMA_GCRISR_INTR8_Msk                       (1ul << PDMA_GCRISR_INTR8_Pos)  /*!< PDMA_GCR_T::GCRISR: INTR8 Mask */
S
S#define PDMA_GCRISR_INTR7_Pos                       7                               /*!< PDMA_GCR_T::GCRISR: INTR7 Position */
S#define PDMA_GCRISR_INTR7_Msk                       (1ul << PDMA_GCRISR_INTR7_Pos)  /*!< PDMA_GCR_T::GCRISR: INTR7 Mask */
S
S#define PDMA_GCRISR_INTR6_Pos                       6                               /*!< PDMA_GCR_T::GCRISR: INTR6 Position */
S#define PDMA_GCRISR_INTR6_Msk                       (1ul << PDMA_GCRISR_INTR6_Pos)  /*!< PDMA_GCR_T::GCRISR: INTR6 Mask */
S
S#define PDMA_GCRISR_INTR5_Pos                       5                               /*!< PDMA_GCR_T::GCRISR: INTR5 Position */
S#define PDMA_GCRISR_INTR5_Msk                       (1ul << PDMA_GCRISR_INTR5_Pos)  /*!< PDMA_GCR_T::GCRISR: INTR5 Mask */
S
S#define PDMA_GCRISR_INTR4_Pos                       4                               /*!< PDMA_GCR_T::GCRISR: INTR4 Position */
S#define PDMA_GCRISR_INTR4_Msk                       (1ul << PDMA_GCRISR_INTR4_Pos)  /*!< PDMA_GCR_T::GCRISR: INTR4 Mask */
S
S#define PDMA_GCRISR_INTR3_Pos                       3                               /*!< PDMA_GCR_T::GCRISR: INTR3 Position */
S#define PDMA_GCRISR_INTR3_Msk                       (1ul << PDMA_GCRISR_INTR3_Pos)  /*!< PDMA_GCR_T::GCRISR: INTR3 Mask */
S
S#define PDMA_GCRISR_INTR2_Pos                       2                               /*!< PDMA_GCR_T::GCRISR: INTR2 Position */
S#define PDMA_GCRISR_INTR2_Msk                       (1ul << PDMA_GCRISR_INTR2_Pos)  /*!< PDMA_GCR_T::GCRISR: INTR2 Mask */
S
S#define PDMA_GCRISR_INTR1_Pos                       1                               /*!< PDMA_GCR_T::GCRISR: INTR1 Position */
S#define PDMA_GCRISR_INTR1_Msk                       (1ul << PDMA_GCRISR_INTR1_Pos)  /*!< PDMA_GCR_T::GCRISR: INTR1 Mask */
S
S#define PDMA_GCRISR_INTR0_Pos                       0                               /*!< PDMA_GCR_T::GCRISR: INTR0 Position */
S#define PDMA_GCRISR_INTR0_Msk                       (1ul << PDMA_GCRISR_INTR0_Pos)  /*!< PDMA_GCR_T::GCRISR: INTR0 Mask */
S
S/* PDMA PDSSR2 Bit Field Definitions */
S#define PDMA_PDSSR2_I2S_TXSEL_Pos                   4                                       /*!< PDMA_GCR_T::PDSSR2: I2S_TXSEL Position */
S#define PDMA_PDSSR2_I2S_TXSEL_Msk                   (0xFul << PDMA_PDSSR2_I2S_TXSEL_Pos)    /*!< PDMA_GCR_T::PDSSR2: I2S_TXSEL Mask */
S
S#define PDMA_PDSSR2_I2S_RXSEL_Pos                   0                                       /*!< PDMA_GCR_T::PDSSR2: I2S_RXSEL Position */
S#define PDMA_PDSSR2_I2S_RXSEL_Msk                   (0xFul << PDMA_PDSSR2_I2S_RXSEL_Pos)    /*!< PDMA_GCR_T::PDSSR2: I2S_RXSEL Mask */
S/*@}*/ /* end of group PDMA_CONST */
S/*@}*/ /* end of group DMA */
S
S
S/*------------------------------ PS2 Controller ------------------------------*/
S/** @addtogroup PS2 PS2 Serial Interface(PS2)
S  Memory Mapped Structure for PS2 Serial Interface Controller
S  @{
S */
S
S
Stypedef struct
S{
S
S
S/**
S * @var PS2_T::PS2CON
S * Offset: 0x00  PS/2 Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |PS2EN     |Enable PS/2 Device
S * |        |          |Enable PS/2 device controller
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |[1]     |TXINTEN   |Enable Transmit Interrupt
S * |        |          |0 = Data transmit complete interrupt Disabled.
S * |        |          |1 = Data transmit complete interrupt Enabled.
S * |[2]     |RXINTEN   |Enable Receive Interrupt
S * |        |          |0 = Data receive complete interrupt Disabled.
S * |        |          |1 = Data receive complete interrupt Enabled.
S * |[6:3]   |TXFIFO_DEPTH|Transmit Data FIFO Depth
S * |        |          |There are 16 bytes buffer for data transmit.
S * |        |          |Software can define the FIFO depth from 1 to 16 bytes depends on application needs.
S * |        |          |0 = 1 byte.
S * |        |          |1 = 2 bytes.
S * |        |          |...
S * |        |          |14 = 15 bytes.
S * |        |          |15 = 16 bytes.
S * |[7]     |ACK       |Acknowledge Enable
S * |        |          |0 = Always send acknowledge to host at 12th clock for host to device communication.
S * |        |          |1 = If parity bit error or stop bit is not received correctly, acknowledge bit will not be sent
S * |        |          |to host at 12th clock.
S * |[8]     |CLRFIFO   |Clear TX FIFO
S * |        |          |Write 1 to this bit to terminate device to host transmission.
S * |        |          |The TXEMPTY(PS2STATUS[7]) bit will be set to 1 and pointer BYTEIDEX(PS2STATUS[11:8]) is reset to
S * |        |          |0 regardless there is residue data in buffer or not.
S * |        |          |The buffer content is not been cleared.
S * |        |          |0 = Not active.
S * |        |          |1 = Clear FIFO.
S * |[9]     |OVERRIDE  |Software Override PS/2 CLK/DATA Pin State
S * |        |          |0 = PS2_CLK and PS2_DATA pins are controlled by internal state machine.
S * |        |          |1 = PS2_CLK and PS2_DATA pins are controlled by software.
S * |[10]    |FPS2CLK   |Force PS2CLK Line
S * |        |          |It forces PS2_CLK line high or low regardless of the internal state of the device controller if
S * |        |          |OVERRIDE(PS2CON[9]) is set to 1.
S * |        |          |0 = Force PS2_CLK line low.
S * |        |          |1 = Force PS2_CLK line high.
S * |[11]    |FPS2DAT   |Force PS2DATA Line
S * |        |          |It forces PS2_DATA high or low regardless of the internal state of the device controller if
S * |        |          |OVERRIDE (PS2CON[9]) is set to 1.
S * |        |          |0 = Force PS2_DATA low.
S * |        |          |1 = Force PS2_DATA high.
S * @var PS2_T::PS2TXDATA0
S * Offset: 0x04  PS/2 Transmit Data Register 0
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |PS2TXDATAx|Transmit Data
S * |        |          |Writing data to this register starts in device to host communication if bus is in IDLE state.
S * |        |          |Software must enable PS2EN(PS2CON[0]) before writing data to TX buffer.
S * @var PS2_T::PS2TXDATA1
S * Offset: 0x08  PS/2 Transmit Data Register 1
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |PS2TXDATAx|Transmit Data
S * |        |          |Writing data to this register starts in device to host communication if bus is in IDLE state.
S * |        |          |Software must enable PS2EN(PS2CON[0]) before writing data to TX buffer.
S * @var PS2_T::PS2TXDATA2
S * Offset: 0x0C  PS/2 Transmit Data Register 2
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |PS2TXDATAx|Transmit Data
S * |        |          |Writing data to this register starts in device to host communication if bus is in IDLE state.
S * |        |          |Software must enable PS2EN(PS2CON[0]) before writing data to TX buffer.
S * @var PS2_T::PS2TXDATA3
S * Offset: 0x10  PS/2 Transmit Data Register 3
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |PS2TXDATAx|Transmit Data
S * |        |          |Writing data to this register starts in device to host communication if bus is in IDLE state.
S * |        |          |Software must enable PS2EN(PS2CON[0]) before writing data to TX buffer.
S * @var PS2_T::PS2RXDATA
S * Offset: 0x14  PS/2 Receive Data Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |RXDATA    |Received Data
S * |        |          |For host to device communication, after acknowledge bit is sent, the received data is copied
S * |        |          |from receive shift register to PS2RXDATA register.
S * |        |          |CPU must read this register before next byte reception complete, otherwise the data will be
S * |        |          |overwritten and RXOVF(PS2STATUS[6]) bit will be set to 1.
S * @var PS2_T::PS2STATUS
S * Offset: 0x18  PS/2 Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |PS2CLK    |CLK Pin State
S * |        |          |This bit reflects the status of the PS2_CLK line after synchronizing.
S * |[1]     |PS2DATA   |DATA Pin State
S * |        |          |This bit reflects the status of the PS2_DATA line after synchronizing and sampling.
S * |[2]     |FRAMERR   |Frame Error
S * |        |          |For host to device communication, this bit sets to 1 if STOP bit (logic 1) is not received.
S * |        |          |If frame error occurs, the PS/2_DATA line may keep at low state after 12th clock.
S * |        |          |At this moment, software overrides PS2_CLK to send clock till PS2_DATA release to high state.
S * |        |          |After that, device sends a "Resend" command to host.
S * |        |          |0 = No frame error.
S * |        |          |1 = Frame error occur.
S * |        |          |Write 1 to clear this bit.
S * |[3]     |RXPARITY  |Received Parity
S * |        |          |This bit reflects the parity bit for the last received data byte (odd parity).
S * |        |          |This bit is read only.
S * |[4]     |RXBUSY    |Receive Busy
S * |        |          |This bit indicates that the PS/2 device is currently receiving data.
S * |        |          |0 = Idle.
S * |        |          |1 = Currently receiving data.
S * |        |          |This bit is read only.
S * |[5]     |TXBUSY    |Transmit Busy
S * |        |          |This bit indicates that the PS/2 device is currently sending data.
S * |        |          |0 = Idle.
S * |        |          |1 = Currently sending data.
S * |        |          |This bit is read only.
S * |[6]     |RXOVF     |RX Buffer Overwrite
S * |        |          |0 = No overwrite.
S * |        |          |1 = Data in PS2RXDATA register is overwritten by new received data.
S * |        |          |Write 1 to clear this bit.
S * |[7]     |TXEMPTY   |TX FIFO Empty
S * |        |          |When software writes data to PS2TXDATA0-3, the TXEMPTY bit is cleared to 0 immediately if
S * |        |          |PS2EN(PS2CON[0]) is enabled.
S * |        |          |When transmitted data byte number is equal to FIFODEPTH(PS2CON[6:3]) then TXEMPTY bit is set to
S * |        |          |1.
S * |        |          |0 = There is data to be transmitted.
S * |        |          |1 = FIFO is empty.
S * |        |          |This bit is read only.
S * |[11:8]  |BYTEIDX   |Byte Index
S * |        |          |It indicates which data byte in transmit data shift register.
S * |        |          |When all data in FIFO is transmitted and it will be cleared to 0.
S * |        |          |This bit is read only.
S * |        |          |BYTEIDX,    DATA Transmit , BYTEIDX,    DATA Transmit
S * |        |          |0000   , PS2TXDATA0[ 7: 0], 1000   , PS2TXDATA2[ 7: 0],
S * |        |          |0001   , PS2TXDATA0[15: 8], 1001   , PS2TXDATA2[15: 8],
S * |        |          |0010   , PS2TXDATA0[23:16], 1010   , PS2TXDATA2[23:16],
S * |        |          |0011   , PS2TXDATA0[31:24], 1011   , PS2TXDATA2[31:24],
S * |        |          |0100   , PS2TXDATA1[ 7: 0], 1100   , PS2TXDATA3[ 7: 0],
S * |        |          |0101   , PS2TXDATA1[15: 8], 1101   , PS2TXDATA3[15: 8],
S * |        |          |0110   , PS2TXDATA1[23:16], 1110   , PS2TXDATA3[23:16],
S * |        |          |0111   , PS2TXDATA1[31:24], 1111   , PS2TXDATA3[31:24],
S * @var PS2_T::PS2INTID
S * Offset: 0x1C  PS/2 Interrupt Identification Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |RXINT     |Receive Interrupt
S * |        |          |This bit is set to 1 when acknowledge bit is sent for Host to device communication.
S * |        |          |Interrupt occurs if RXINTEN(PS2CON[2]) bit is set to 1.
S * |        |          |0 = No interrupt.
S * |        |          |1 = Receive interrupt occurs.
S * |        |          |Write 1 to clear this bit to 0.
S * |[1]     |TXINT     |Transmit Interrupt
S * |        |          |This bit is set to 1 after STOP bit is transmitted.
S * |        |          |Interrupt occur if TXINTEN(PS2CON[1]) bit is set to 1.
S * |        |          |0 = No interrupt.
S * |        |          |1 = Transmit interrupt occurs.
S * |        |          |Write 1 to clear this bit to 0.
S */
S
S    __IO uint32_t PS2CON;        /* Offset: 0x00  PS/2 Control Register                                              */
S    __IO uint32_t PS2TXDATA0;    /* Offset: 0x04  PS/2 Transmit Data Register 0                                      */
S    __IO uint32_t PS2TXDATA1;    /* Offset: 0x08  PS/2 Transmit Data Register 1                                      */
S    __IO uint32_t PS2TXDATA2;    /* Offset: 0x0C  PS/2 Transmit Data Register 2                                      */
S    __IO uint32_t PS2TXDATA3;    /* Offset: 0x10  PS/2 Transmit Data Register 3                                      */
S    __IO uint32_t PS2RXDATA;     /* Offset: 0x14  PS/2 Receive Data Register                                         */
S    __IO uint32_t PS2STATUS;     /* Offset: 0x18  PS/2 Status Register                                               */
S    __IO uint32_t PS2INTID;      /* Offset: 0x1C  PS/2 Interrupt Identification Register                             */
S
S} PS2_T;
S
S
S
S/**
S    @addtogroup PS2_CONST PS2 Bit Field Definition
S    Constant Definitions for PS2 Controller
S@{ */
S
S
S/* PS2 PS2CON Bit Field Definitions */
S#define PS2_PS2CON_PS2EN_Pos                       0                                        /*!< PS2_T::PS2CON: PS2EN Position */
S#define PS2_PS2CON_PS2EN_Msk                       (1ul << PS2_PS2CON_PS2EN_Pos)            /*!< PS2_T::PS2CON: PS2EN Mask */
S
S#define PS2_PS2CON_TXINTEN_Pos                     1                                        /*!< PS2_T::PS2CON: TXINTEN Position */
S#define PS2_PS2CON_TXINTEN_Msk                     (1ul << PS2_PS2CON_TXINTEN_Pos)          /*!< PS2_T::PS2CON: TXINTEN Mask */
S
S#define PS2_PS2CON_RXINTEN_Pos                     2                                        /*!< PS2_T::PS2CON: RXINTEN Position */
S#define PS2_PS2CON_RXINTEN_Msk                     (1ul << PS2_PS2CON_RXINTEN_Pos)          /*!< PS2_T::PS2CON: RXINTEN Mask */
S
S#define PS2_PS2CON_TXFIFO_DEPTH_Pos                3                                        /*!< PS2_T::PS2CON: TXFIFO_DEPTH Position */
S#define PS2_PS2CON_TXFIFO_DEPTH_Msk                (0xFul << PS2_PS2CON_TXFIFO_DEPTH_Pos)   /*!< PS2_T::PS2CON: TXFIFO_DEPTH Mask */
S
S#define PS2_PS2CON_ACK_Pos                         7                                        /*!< PS2_T::PS2CON: ACK Position */
S#define PS2_PS2CON_ACK_Msk                         (1ul << PS2_PS2CON_ACK_Pos)              /*!< PS2_T::PS2CON: ACK Mask */
S
S#define PS2_PS2CON_CLRFIFO_Pos                     8                                        /*!< PS2_T::PS2CON: CLRFIFO Position */
S#define PS2_PS2CON_CLRFIFO_Msk                     (1ul << PS2_PS2CON_CLRFIFO_Pos)          /*!< PS2_T::PS2CON: CLRFIFO Mask */
S
S#define PS2_PS2CON_OVERRIDE_Pos                    9                                        /*!< PS2_T::PS2CON: OVERRIDE Position */
S#define PS2_PS2CON_OVERRIDE_Msk                    (1ul << PS2_PS2CON_OVERRIDE_Pos)         /*!< PS2_T::PS2CON: OVERRIDE Mask */
S
S#define PS2_PS2CON_FPS2CLK_Pos                     10                                       /*!< PS2_T::PS2CON: FPS2CLK Position */
S#define PS2_PS2CON_FPS2CLK_Msk                     (1ul << PS2_PS2CON_FPS2CLK_Pos)          /*!< PS2_T::PS2CON: FPS2CLK Mask */
S
S#define PS2_PS2CON_FPS2DAT_Pos                     11                                       /*!< PS2_T::PS2CON: FPS2DAT Position */
S#define PS2_PS2CON_FPS2DAT_Msk                     (1ul << PS2_PS2CON_FPS2DAT_Pos)          /*!< PS2_T::PS2CON: FPS2DAT Mask */
S
S/* PS/2 PS2RXDATA Bit Field Definitions */
S#define PS2_PS2RXDATA_RXDATA_Pos                   0                                        /*!< PS2_T::PS2RXDATA: RXDATA Position */
S#define PS2_PS2RXDATA_RXDATA_Msk                   (0xFFul << PS2_PS2RXDATA_RXDATA_Pos)     /*!< PS2_T::PS2RXDATA: RXDATA Mask */
S
S/* PS/2 PS2STATUS Bit Field Definitions */
S#define PS2_PS2STATUS_PS2CLK_Pos                   0                                        /*!< PS2_T::PS2STATUS: PS2CLK Position */
S#define PS2_PS2STATUS_PS2CLK_Msk                   (1ul << PS2_PS2STATUS_PS2CLK_Pos)        /*!< PS2_T::PS2STATUS: PS2CLK Mask */
S
S#define PS2_PS2STATUS_PS2DATA_Pos                  1                                        /*!< PS2_T::PS2STATUS: PS2DATA Position */
S#define PS2_PS2STATUS_PS2DATA_Msk                  (1ul << PS2_PS2STATUS_PS2DATA_Pos)       /*!< PS2_T::PS2STATUS: PS2DATA Mask */
S
S#define PS2_PS2STATUS_FRAMERR_Pos                  2                                        /*!< PS2_T::PS2STATUS: FRAMERR Position */
S#define PS2_PS2STATUS_FRAMERR_Msk                  (1ul << PS2_PS2STATUS_FRAMERR_Pos)       /*!< PS2_T::PS2STATUS: FRAMERR Mask */
S
S#define PS2_PS2STATUS_RXPARITY_Pos                 3                                        /*!< PS2_T::PS2STATUS: RXPARITY Position */
S#define PS2_PS2STATUS_RXPARITY_Msk                 (1ul << PS2_PS2STATUS_RXPARITY_Pos)      /*!< PS2_T::PS2STATUS: RXPARITY Mask */
S
S#define PS2_PS2STATUS_RXBUSY_Pos                   4                                        /*!< PS2_T::PS2STATUS: RXBUSY Position */
S#define PS2_PS2STATUS_RXBUSY_Msk                   (1ul << PS2_PS2STATUS_RXBUSY_Pos)        /*!< PS2_T::PS2STATUS: RXBUSY Mask */
S
S#define PS2_PS2STATUS_TXBUSY_Pos                   5                                        /*!< PS2_T::PS2STATUS: TXBUSY Position */
S#define PS2_PS2STATUS_TXBUSY_Msk                   (1ul << PS2_PS2STATUS_TXBUSY_Pos)        /*!< PS2_T::PS2STATUS: TXBUSY Mask */
S
S#define PS2_PS2STATUS_RXOVF_Pos                    6                                        /*!< PS2_T::PS2STATUS: RXOVF Position */
S#define PS2_PS2STATUS_RXOVF_Msk                    (1ul << PS2_PS2STATUS_RXOVF_Pos)         /*!< PS2_T::PS2STATUS: RXOVF Mask */
S
S#define PS2_PS2STATUS_TXEMPTY_Pos                  7                                        /*!< PS2_T::PS2STATUS: TXEMPTY Position */
S#define PS2_PS2STATUS_TXEMPTY_Msk                  (1ul << PS2_PS2STATUS_TXEMPTY_Pos)       /*!< PS2_T::PS2STATUS: TXEMPTY Mask */
S
S#define PS2_PS2STATUS_BYTEIDX_Pos                  8                                        /*!< PS2_T::PS2STATUS: BYTEIDX Position */
S#define PS2_PS2STATUS_BYTEIDX_Msk                  (0xFul << PS2_PS2STATUS_BYTEIDX_Pos)     /*!< PS2_T::PS2STATUS: BYTEIDX Mask */
S
S/* PS/2 PS2INTID Bit Field Definitions */
S#define PS2_PS2INTID_RXINT_Pos                     0                                        /*!< PS2_T::PS2INTID: RXINT Position */
S#define PS2_PS2INTID_RXINT_Msk                     (1ul << PS2_PS2INTID_RXINT_Pos)          /*!< PS2_T::PS2INTID: RXINT Mask */
S
S#define PS2_PS2INTID_TXINT_Pos                     1                                        /*!< PS2_T::PS2INTID: TXINT Position */
S#define PS2_PS2INTID_TXINT_Msk                     (1ul << PS2_PS2INTID_TXINT_Pos)          /*!< PS2_T::PS2INTID: TXINT Mask */
S/*@}*/ /* end of group PS2_CONST */
S/*@}*/ /* end of group PS2 */
S
S
S/*---------------------- Pulse Width Modulation Controller -------------------------*/
S/**
S    @addtogroup PWM Pulse Width Modulation Controller (PWM)
S    Memory Mapped Structure for PWM Controller
S@{ */
S
S
S
Stypedef struct
S{
S
S
S/**
S * @var PWM_T::PPR
S * Offset: 0x00  PWM Prescaler Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits     |Field     |Descriptions
S * | :----:  | :----:   | :---- |
S * |[7:0]    |CP01      |Clock Prescaler 0 (PWM-Timer 0 / 1 For Group A And PWM-Timer 4 / 5 For Group B)
S * |         |          |Clock input is divided by (CP01 + 1) before it is fed to the corresponding PWM-timer
S * |         |          |If CP01=0, then the clock prescaler 0 output clock will be stopped.
S * |         |          |So corresponding PWM-timer will also be stopped.
S * |[15:8]   |CP23      |Clock Prescaler 2 (PWM-Timer2 / 3 For Group A And PWM-Timer 6 / 7 For Group B)
S * |         |          |Clock input is divided by (CP23 + 1) before it is fed to the corresponding PWM-timer
S * |         |          |If CP23=0, then the clock prescaler 2 output clock will be stopped.
S * |         |          |So corresponding PWM-timer will also be stopped.
S * |[23:16]  |DZI01     |Dead-Zone Interval For Pair Of Channel 0 And Channel 1 (PWM0 And PWM1 Pair For PWM Group A, PWM4 And PWM5 Pair For PWM Group B)
S * |         |          |These 8-bit determine the Dead-zone length.
S * |        |          |The unit time of Dead-zone length = [(prescale+1)*(clock source divider)]/ PWMxy_CLK (where xy
S * |        |          |could be 01 or 45, depends on selected PWM channel.).
S * |[31:24]  |DZI23     |Dead-Zone Interval For Pair Of Channel2 And Channel3 (PWM2 And PWM3 Pair For PWM Group A, PWM6 And PWM7 Pair For PWM Group B)
S * |         |          |These 8-bit determine the Dead-zone length.
S * |        |          |The unit time of Dead-zone length = [(prescale+1)*(clock source divider)]/ PWMxy_CLK (where xy
S * |        |          |could be 23 or 67, depends on selected PWM channel.).
S * @var PWM_T::CSR
S * Offset: 0x04  PWM Clock Source Divider Select Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits      |Field     |Descriptions
S * | :----:   | :----:   | :---- |
S * |[2:0]     |CSR0      |Timer 0 Clock Source Selection(PWM timer 0 for group A and PWM timer 4 for group B)
S * |          |          |Select clock input for timer.
S * |          |          |(Table is the same as CSR3)
S * |[6:4]     |CSR1      |Timer 1 Clock Source Selection(PWM timer 1 for group A and PWM timer 5 for group B)
S * |          |          |Select clock input for timer.
S * |          |          |(Table is the same as CSR3)
S * |[10:8]    |CSR2      |Timer 2 Clock Source Selection(PWM timer 2 for group A and PWM timer 6 for group B)
S * |          |          |Select clock input for timer.
S * |          |          |(Table is the same as CSR3)
S * |[14:12]   |CSR3      |Timer 3 Clock Source Selection (PWM timer 3 for group A and PWM timer 7 for group B)
S * |          |          |Select clock input for timer.
S * |          |          |CSRx[2:0] = Input clock divider
S * |          |          |100 = 1
S * |          |          |011 = 16
S * |          |          |010 = 8
S * |          |          |001 = 4
S * |          |          |000 = 2
S * @var PWM_T::PCR
S * Offset: 0x08  PWM Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits     |Field         |Descriptions
S * | :----:  | :----:       | :---- |
S * |[0]      |CH0EN         |PWM-Timer 0 Enable (PWM Timer 0 For Group A And PWM Timer 4 For Group B)
S * |         |              |0 = The corresponding PWM-Timer stops running.
S * |         |              |1 = The corresponding PWM-Timer starts running.
S * |[1]      |CH0PINV       |PWM-Timer 0 Output Polar Inverse Enable (PWM Timer 0 For Group A And PWM Timer 4 For Group B)
S * |         |              |0 = PWM0 output polar inverse Disabled.
S * |         |              |1 = PWM0 output polar inverse Enabled.
S * |[2]      |CH0INV        |PWM-Timer 0 Output Inverter Enable (PWM Timer 0 For Group A And PWM Timer 4 For Group B)
S * |         |              |0 = Inverter Disabled.
S * |         |              |1 = Inverter Enabled.
S * |[3]      |CH0MOD        |PWM-Timer 0 Auto-Reload/One-Shot Mode (PWM Timer 0 For Group A And PWM Timer 4 For Group B)
S * |         |              |0 = One-shot mode.
S * |         |              |1 = Auto-reload mode.
S * |         |              |Note: If there is a transition at this bit, it will cause CNR0 and CMR0 be cleared.
S * |[4]      |DZEN01        |Dead-Zone 0 Generator Enable (PWM0 And PWM1 Pair For PWM Group A, PWM4 And PWM5 Pair For PWM Group B)
S * |         |              |0 = Disabled.
S * |         |              |1 = Enabled.
S * |        |          |Note: When Dead-zone generator is enabled, the pair of PWM0 and PWM1 becomes a complementary
S * |        |          |pair for PWM group A and the pair of PWM4 and PWM5 becomes a complementary pair for PWM group B.
S * |[5]      |DZEN23        |Dead-Zone 2 Generator Enable (PWM2 And PWM3 Pair For PWM Group A, PWM6 And PWM7 Pair For PWM Group B)
S * |         |              |0 = Disabled.
S * |         |              |1 = Enabled.
S * |        |          |Note: When Dead-zone generator is enabled, the pair of PWM2 and PWM3 becomes a complementary
S * |        |          |pair for PWM group A and the pair of PWM6 and PWM7 becomes a complementary pair for PWM group B.
S * |[8]      |CH1EN         |PWM-Timer 1 Enable (PWM Timer 1 For Group A And PWM Timer 5 For Group B)
S * |         |              |0 = Corresponding PWM-Timer Stopped.
S * |         |              |1 = Corresponding PWM-Timer Start Running.
S * |[9]      |CH1PINV       |PWM-Timer 1 Output Polar Inverse Enable (PWM Timer 1 For Group A And PWM Timer 5 For Group B)
S * |         |              |0 = PWM1 output polar inverse Disabled.
S * |         |              |1 = PWM1 output polar inverse Enabled.
S * |[10]     |CH1INV        |PWM-Timer 1 Output Inverter Enable (PWM Timer 1 For Group A And PWM Timer 5 For Group B)
S * |         |              |0 = Inverter Disable.
S * |         |              |1 = Inverter Enable.
S * |[11]     |CH1MOD        |PWM-Timer 1 Auto-Reload/One-Shot Mode (PWM Timer 1 For Group A And PWM Timer 5 For Group B)
S * |         |              |0 = One-shot mode.
S * |         |              |1 = Auto-reload mode.
S * |         |              |Note: If there is a transition at this bit, it will cause CNR1 and CMR1 be cleared.
S * |[16]     |CH2EN         |PWM-Timer 2 Enable (PWM Timer 2 For Group A And PWM Timer 6 For Group B)
S * |         |              |0 = Corresponding PWM-Timer Stopped.
S * |         |              |1 = Corresponding PWM-Timer Start Running.
S * |[17]     |CH2PINV       |PWM-Timer 2 Output Polar Inverse Enable (PWM Timer 2 For Group A And PWM Timer 6 For Group B)
S * |         |              |0 = PWM2 output polar inverse Disabled.
S * |         |              |1 = PWM2 output polar inverse Enabled.
S * |[18]     |CH2INV        |PWM-Timer 2 Output Inverter Enable (PWM Timer 2 For Group A And PWM Timer 6 For Group B)
S * |         |              |0 = Inverter Disabled.
S * |         |              |1 = Inverter Enabled.
S * |[19]     |CH2MOD        |PWM-Timer 2 Auto-Reload/One-Shot Mode (PWM Timer 2 For Group A And PWM Timer 6 For Group B)
S * |         |              |0 = One-shot mode.
S * |         |              |1 = Auto-reload mode.
S * |         |              |Note: If there is a transition at this bit, it will cause CNR2 and CMR2 be cleared.
S * |[24]     |CH3EN         |PWM-Timer 3 Enable (PWM Timer 3 For Group A And PWM Timer 7 For Group B)
S * |         |              |0 = Corresponding PWM-Timer Stopped.
S * |         |              |1 = Corresponding PWM-Timer Start Running.
S * |[25]     |CH3PINV       |PWM-Timer 3 Output Polar Inverse Enable (PWM Timer 3 For Group A And PWM Timer 7 For Group B)
S * |         |              |0 = PWM3 output polar inverse Disable.
S * |         |              |1 = PWM3 output polar inverse Enable.
S * |[26]     |CH3INV        |PWM-Timer 3 Output Inverter Enable (PWM Timer 3 For Group A And PWM Timer 7 For Group B)
S * |         |              |0 = Inverter Disabled.
S * |         |              |1 = Inverter Enabled.
S * |[27]     |CH3MOD        |PWM-Timer 3 Auto-Reload/One-Shot Mode (PWM Timer 3 For Group A And PWM Timer 7 For Group B)
S * |         |              |0 = One-shot mode.
S * |         |              |1 = Auto-reload mode.
S * |         |              |Note: If there is a transition at this bit, it will cause CNR3 and CMR3 be cleared.
S * |[30]     |PWM01TYPE     |PWM01 Aligned Type Selection Bit (PWM0 And PWM1 Pair For PWM Group A, PWM4 And PWM5 Pair For PWM Group B)
S * |         |              |0 = Edge-aligned type.
S * |         |              |1 = Center-aligned type.
S * |[31]     |PWM23TYPE     |PWM23 Aligned Type Selection Bit (PWM2 And PWM3 Pair For PWM Group A, PWM6 And PWM7 Pair For PWM Group B)
S * |         |              |0 = Edge-aligned type.
S * |         |              |1 = Center-aligned type.
S * @var PWM_T::CNR0
S * Offset: 0x0C  PWM Counter Register 0
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |CNRx      |PWM Timer Loaded Value
S * |        |          |CNR determines the PWM period.
S * |        |          |PWM frequency = PWMxy_CLK/[(prescale+1)*(clock divider)*(CNR+1)]; where xy, could be 01, 23, 45
S * |        |          |or 67, depends on selected PWM channel.
S * |        |          |For Edge-aligned type:
S * |        |          | Duty ratio = (CMR+1)/(CNR+1).
S * |        |          | CMR >= CNR: PWM output is always high.
S * |        |          | CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
S * |        |          | CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit.
S * |        |          |For Center-aligned type:
S * |        |          | Duty ratio = [(2 x CMR) + 1]/[2 x (CNR+1)].
S * |        |          | CMR > CNR: PWM output is always high.
S * |        |          | CMR <= CNR: PWM low width = 2 x (CNR-CMR) + 1 unit; PWM high width = (2 x CMR) + 1 unit.
S * |        |          | CMR = 0: PWM low width = 2 x CNR + 1 unit; PWM high width = 1 unit.
S * |        |          |(Unit = one PWM clock cycle).
S * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
S * |        |          |Note: When PWM operating at Center-aligned type, CNR value should be set between 0x0000 to
S * |        |          |0xFFFE.
S * |        |          |If CNR equal to 0xFFFF, the PWM will work unpredictable.
S * |        |          |Note: When CNR value is set to 0, PWM output is always high.
S * @var PWM_T::CMR0
S * Offset: 0x0C  PWM Counter Register 0
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |CNRx      |PWM Timer Loaded Value
S * |        |          |CNR determines the PWM period.
S * |        |          |PWM frequency = PWMxy_CLK/[(prescale+1)*(clock divider)*(CNR+1)]; where xy, could be 01, 23, 45
S * |        |          |or 67, depends on selected PWM channel.
S * |        |          |For Edge-aligned type:
S * |        |          | Duty ratio = (CMR+1)/(CNR+1).
S * |        |          | CMR >= CNR: PWM output is always high.
S * |        |          | CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
S * |        |          | CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit.
S * |        |          |For Center-aligned type:
S * |        |          | Duty ratio = [(2 x CMR) + 1]/[2 x (CNR+1)].
S * |        |          | CMR > CNR: PWM output is always high.
S * |        |          | CMR <= CNR: PWM low width = 2 x (CNR-CMR) + 1 unit; PWM high width = (2 x CMR) + 1 unit.
S * |        |          | CMR = 0: PWM low width = 2 x CNR + 1 unit; PWM high width = 1 unit.
S * |        |          |(Unit = one PWM clock cycle).
S * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
S * |        |          |Note: When PWM operating at Center-aligned type, CNR value should be set between 0x0000 to
S * |        |          |0xFFFE.
S * |        |          |If CNR equal to 0xFFFF, the PWM will work unpredictable.
S * |        |          |Note: When CNR value is set to 0, PWM output is always high.
S * @var PWM_T::PDR0
S * Offset: 0x14  PWM Data Register 0
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |PDRx      |PWM Data Register
S * |        |          |User can monitor PDR to know the current value in 16-bit counter.
S * @var PWM_T::CNR1
S * Offset: 0x18  PWM Counter Register 1
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |CNRx      |PWM Timer Loaded Value
S * |        |          |CNR determines the PWM period.
S * |        |          |PWM frequency = PWMxy_CLK/[(prescale+1)*(clock divider)*(CNR+1)]; where xy, could be 01, 23, 45
S * |        |          |or 67, depends on selected PWM channel.
S * |        |          |For Edge-aligned type:
S * |        |          | Duty ratio = (CMR+1)/(CNR+1).
S * |        |          | CMR >= CNR: PWM output is always high.
S * |        |          | CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
S * |        |          | CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit.
S * |        |          |For Center-aligned type:
S * |        |          | Duty ratio = [(2 x CMR) + 1]/[2 x (CNR+1)].
S * |        |          | CMR > CNR: PWM output is always high.
S * |        |          | CMR <= CNR: PWM low width = 2 x (CNR-CMR) + 1 unit; PWM high width = (2 x CMR) + 1 unit.
S * |        |          | CMR = 0: PWM low width = 2 x CNR + 1 unit; PWM high width = 1 unit.
S * |        |          |(Unit = one PWM clock cycle).
S * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
S * |        |          |Note: When PWM operating at Center-aligned type, CNR value should be set between 0x0000 to
S * |        |          |0xFFFE.
S * |        |          |If CNR equal to 0xFFFF, the PWM will work unpredictable.
S * |        |          |Note: When CNR value is set to 0, PWM output is always high.
S * @var PWM_T::CMR1
S * Offset: 0x1C  PWM Comparator Register 1
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |CMRx      |PWM Comparator Register
S * |        |          |CMR determines the PWM duty.
S * |        |          |PWM frequency = PWMxy_CLK/[(prescale+1)*(clock divider)*(CNR+1)]; where xy, could be 01, 23, 45
S * |        |          |or 67, depends on selected PWM channel.
S * |        |          |For Edge-aligned type:
S * |        |          | Duty ratio = (CMR+1)/(CNR+1).
S * |        |          | CMR >= CNR: PWM output is always high.
S * |        |          | CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
S * |        |          | CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit.
S * |        |          |For Center-aligned type:
S * |        |          | Duty ratio = [(2 x CMR) + 1]/[2 x (CNR+1)].
S * |        |          | CMR > CNR: PWM output is always high.
S * |        |          | CMR <= CNR: PWM low width = 2 x (CNR-CMR) + 1 unit; PWM high width = (2 x CMR) + 1 unit.
S * |        |          | CMR = 0: PWM low width = 2 x CNR + 1 unit; PWM high width = 1 unit.
S * |        |          |(Unit = one PWM clock cycle).
S * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
S * @var PWM_T::PDR1
S * Offset: 0x20  PWM Data Register 1
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |PDRx      |PWM Data Register
S * |        |          |User can monitor PDR to know the current value in 16-bit counter.
S * @var PWM_T::CNR2
S * Offset: 0x24  PWM Counter Register 2
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |CNRx      |PWM Timer Loaded Value
S * |        |          |CNR determines the PWM period.
S * |        |          |PWM frequency = PWMxy_CLK/[(prescale+1)*(clock divider)*(CNR+1)]; where xy, could be 01, 23, 45
S * |        |          |or 67, depends on selected PWM channel.
S * |        |          |For Edge-aligned type:
S * |        |          | Duty ratio = (CMR+1)/(CNR+1).
S * |        |          | CMR >= CNR: PWM output is always high.
S * |        |          | CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
S * |        |          | CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit.
S * |        |          |For Center-aligned type:
S * |        |          | Duty ratio = [(2 x CMR) + 1]/[2 x (CNR+1)].
S * |        |          | CMR > CNR: PWM output is always high.
S * |        |          | CMR <= CNR: PWM low width = 2 x (CNR-CMR) + 1 unit; PWM high width = (2 x CMR) + 1 unit.
S * |        |          | CMR = 0: PWM low width = 2 x CNR + 1 unit; PWM high width = 1 unit.
S * |        |          |(Unit = one PWM clock cycle).
S * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
S * |        |          |Note: When PWM operating at Center-aligned type, CNR value should be set between 0x0000 to
S * |        |          |0xFFFE.
S * |        |          |If CNR equal to 0xFFFF, the PWM will work unpredictable.
S * |        |          |Note: When CNR value is set to 0, PWM output is always high.
S * @var PWM_T::CMR2
S * Offset: 0x28  PWM Comparator Register 2
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |CMRx      |PWM Comparator Register
S * |        |          |CMR determines the PWM duty.
S * |        |          |PWM frequency = PWMxy_CLK/[(prescale+1)*(clock divider)*(CNR+1)]; where xy, could be 01, 23, 45
S * |        |          |or 67, depends on selected PWM channel.
S * |        |          |For Edge-aligned type:
S * |        |          | Duty ratio = (CMR+1)/(CNR+1).
S * |        |          | CMR >= CNR: PWM output is always high.
S * |        |          | CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
S * |        |          | CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit.
S * |        |          |For Center-aligned type:
S * |        |          | Duty ratio = [(2 x CMR) + 1]/[2 x (CNR+1)].
S * |        |          | CMR > CNR: PWM output is always high.
S * |        |          | CMR <= CNR: PWM low width = 2 x (CNR-CMR) + 1 unit; PWM high width = (2 x CMR) + 1 unit.
S * |        |          | CMR = 0: PWM low width = 2 x CNR + 1 unit; PWM high width = 1 unit.
S * |        |          |(Unit = one PWM clock cycle).
S * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
S * @var PWM_T::PDR2
S * Offset: 0x2C  PWM Data Register 2
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |PDRx      |PWM Data Register
S * |        |          |User can monitor PDR to know the current value in 16-bit counter.
S * @var PWM_T::CNR3
S * Offset: 0x30  PWM Counter Register 3
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |CNRx      |PWM Timer Loaded Value
S * |        |          |CNR determines the PWM period.
S * |        |          |PWM frequency = PWMxy_CLK/[(prescale+1)*(clock divider)*(CNR+1)]; where xy, could be 01, 23, 45
S * |        |          |or 67, depends on selected PWM channel.
S * |        |          |For Edge-aligned type:
S * |        |          | Duty ratio = (CMR+1)/(CNR+1).
S * |        |          | CMR >= CNR: PWM output is always high.
S * |        |          | CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
S * |        |          | CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit.
S * |        |          |For Center-aligned type:
S * |        |          | Duty ratio = [(2 x CMR) + 1]/[2 x (CNR+1)].
S * |        |          | CMR > CNR: PWM output is always high.
S * |        |          | CMR <= CNR: PWM low width = 2 x (CNR-CMR) + 1 unit; PWM high width = (2 x CMR) + 1 unit.
S * |        |          | CMR = 0: PWM low width = 2 x CNR + 1 unit; PWM high width = 1 unit.
S * |        |          |(Unit = one PWM clock cycle).
S * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
S * |        |          |Note: When PWM operating at Center-aligned type, CNR value should be set between 0x0000 to
S * |        |          |0xFFFE.
S * |        |          |If CNR equal to 0xFFFF, the PWM will work unpredictable.
S * |        |          |Note: When CNR value is set to 0, PWM output is always high.
S * @var PWM_T::CMR3
S * Offset: 0x34  PWM Comparator Register 3
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |CMRx      |PWM Comparator Register
S * |        |          |CMR determines the PWM duty.
S * |        |          |PWM frequency = PWMxy_CLK/[(prescale+1)*(clock divider)*(CNR+1)]; where xy, could be 01, 23, 45
S * |        |          |or 67, depends on selected PWM channel.
S * |        |          |For Edge-aligned type:
S * |        |          | Duty ratio = (CMR+1)/(CNR+1).
S * |        |          | CMR >= CNR: PWM output is always high.
S * |        |          | CMR < CNR: PWM low width = (CNR-CMR) unit; PWM high width = (CMR+1) unit.
S * |        |          | CMR = 0: PWM low width = (CNR) unit; PWM high width = 1 unit.
S * |        |          |For Center-aligned type:
S * |        |          | Duty ratio = [(2 x CMR) + 1]/[2 x (CNR+1)].
S * |        |          | CMR > CNR: PWM output is always high.
S * |        |          | CMR <= CNR: PWM low width = 2 x (CNR-CMR) + 1 unit; PWM high width = (2 x CMR) + 1 unit.
S * |        |          | CMR = 0: PWM low width = 2 x CNR + 1 unit; PWM high width = 1 unit.
S * |        |          |(Unit = one PWM clock cycle).
S * |        |          |Note: Any write to CNR will take effect in next PWM cycle.
S * @var PWM_T::PDR3
S * Offset: 0x38  PWM Data Register 3
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |PDRx      |PWM Data Register
S * |        |          |User can monitor PDR to know the current value in 16-bit counter.
S * @var PWM_T::PBCR
S * Offset: 0x3C  PWM Backward Compatible Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |BCn       |PWM Backward Compatible Register
S * |        |          |0 = Configure write 0 to clear CFLRI0~3 and CRLRI0~3.
S * |        |          |1 = Configure write 1 to clear CFLRI0~3 and CRLRI0~3.
S * |        |          |Refer to the CCR0/CCR2 register bit 6, 7, 22, 23 description
S * |        |          |Note: It is recommended that this bit be set to 1 to prevent CFLRIx and CRLRIx from being
S * |        |          |cleared when writing CCR0/CCR2.
S * @var PWM_T::PIER
S * Offset: 0x40  PWM Interrupt Enable Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |PWMIE0    |PWM Channel 0 Period Interrupt Enable
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |[1]     |PWMIE1    |PWM Channel 1 Period Interrupt Enable
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |[2]     |PWMIE2    |PWM Channel 2 Period Interrupt Enable
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |[3]     |PWMIE3    |PWM Channel 3 Period Interrupt Enable
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |[8]     |PWMDIE0   |PWM Channel 0 Duty Interrupt Enable
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |[9]     |PWMDIE1   |PWM Channel 1 Duty Interrupt Enable
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |[10]    |PWMDIE2   |PWM Channel 2 Duty Interrupt Enable
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |[11]    |PWMDIE3   |PWM Channel 3 Duty Interrupt Enable
S * |        |          |0 = Disabled.
S * |        |          |1 = Enabled.
S * |[16]    |INT01TYPE |PWM01 Interrupt Period Type Selection Bit (PWM0 And PWM1 Pair For PWM Group A, PWM4 And PWM5 Pair For PWM Group B)
S * |        |          |0 = PWMIFn will be set if PWM counter underflow.
S * |        |          |1 = PWMIFn will be set if PWM counter matches CNRn register.
S * |        |          |Note: This bit is effective when PWM in Center-aligned type only.
S * |[17]    |INT23TYPE |PWM23 Interrupt Period Type Selection Bit (PWM2 And PWM3 Pair For PWM Group A, PWM6 And PWM7 Pair For PWM Group B)
S * |        |          |0 = PWMIFn will be set if PWM counter underflow.
S * |        |          |1 = PWMIFn will be set if PWM counter matches CNRn register.
S * |        |          |Note: This bit is effective when PWM in Center-aligned type only.
S * @var PWM_T::PIIR
S * Offset: 0x44  PWM Interrupt Indication Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |PWMIF0    |PWM Channel 0 Period Interrupt Status
S * |        |          |This bit is set by hardware when PWM0 counter reaches the requirement of interrupt (depend on
S * |        |          |INT01TYPE bit of PIER register), software can write 1 to clear this bit to 0.
S * |[1]     |PWMIF1    |PWM Channel 1 Period Interrupt Status
S * |        |          |This bit is set by hardware when PWM1 counter reaches the requirement of interrupt (depend on
S * |        |          |INT01TYPE bit of PIER register), software can write 1 to clear this bit to 0.
S * |[2]     |PWMIF2    |PWM Channel 2 Period Interrupt Status
S * |        |          |This bit is set by hardware when PWM2 counter reaches the requirement of interrupt (depend on
S * |        |          |INT23TYPE bit of PIER register), software can write 1 to clear this bit to 0.
S * |[3]     |PWMIF3    |PWM Channel 3 Period Interrupt Status
S * |        |          |This bit is set by hardware when PWM3 counter reaches the requirement of interrupt (depend on
S * |        |          |INT23TYPE bit of PIER register), software can write 1 to clear this bit to 0.
S * |[8]     |PWMDIF0   |PWM Channel 0 Duty Interrupt Flag
S * |        |          |Flag is set by hardware when channel 0 PWM counter down count and reaches CMR0, software can
S * |        |          |clear this bit by writing a one to it.
S * |        |          |Note: If CMR equal to CNR, this flag is not working in Edge-aligned type selection
S * |[9]     |PWMDIF1   |PWM Channel 1 Duty Interrupt Flag
S * |        |          |Flag is set by hardware when channel 1 PWM counter down count and reaches CMR1, software can
S * |        |          |clear this bit by writing a one to it.
S * |        |          |Note: If CMR equal to CNR, this flag is not working in Edge-aligned type selection
S * |[10]    |PWMDIF2   |PWM Channel 2 Duty Interrupt Flag
S * |        |          |Flag is set by hardware when channel 2 PWM counter down count and reaches CMR2, software can
S * |        |          |clear this bit by writing a one to it.
S * |        |          |Note: If CMR equal to CNR, this flag is not working in Edge-aligned type selection
S * |[11]    |PWMDIF3   |PWM Channel 3 Duty Interrupt Flag
S * |        |          |Flag is set by hardware when channel 3 PWM counter down count and reaches CMR3, software can
S * |        |          |clear this bit by writing a one to it.
S * |        |          |Note: If CMR equal to CNR, this flag is not working in Edge-aligned type selection
S * @var PWM_T::CCR0
S * Offset: 0x50  PWM Capture Control Register 0
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |INV0      |Channel 0 Inverter Enable
S * |        |          |0 = Inverter Disabled.
S * |        |          |1 = Inverter Enabled. Reverse the input signal from GPIO before fed to Capture timer
S * |[1]     |CRL_IE0   |Channel 0 Rising Latch Interrupt Enable
S * |        |          |0 = Rising latch interrupt Disabled.
S * |        |          |1 = Rising latch interrupt Enabled.
S * |        |          |When Enabled, if Capture detects PWM group channel 0 has rising transition, Capture will issue
S * |        |          |an Interrupt.
S * |[2]     |CFL_IE0   |Channel 0 Falling Latch Interrupt Enable
S * |        |          |0 = Falling latch interrupt Disabled.
S * |        |          |1 = Falling latch interrupt Enabled.
S * |        |          |When Enabled, if Capture detects PWM group channel 0 has falling transition, Capture will issue
S * |        |          |an Interrupt.
S * |[3]     |CAPCH0EN  |Channel 0 Capture Function Enable
S * |        |          |0 = Capture function on PWM group channel 0 Disabled.
S * |        |          |1 = Capture function on PWM group channel 0 Enabled.
S * |        |          |When Enabled, Capture latched the PWM-counter value and saved to CRLR (Rising latch) and CFLR
S * |        |          |(Falling latch).
S * |        |          |When Disabled, Capture does not update CRLR and CFLR, and disable PWM group channel 0 Interrupt.
S * |[4]     |CAPIF0    |Channel 0 Capture Interrupt Indication Flag
S * |        |          |If PWM group channel 0 rising latch interrupt is enabled (CRL_IE0 = 1), a rising transition
S * |        |          |occurs at PWM group channel 0 will result in CAPIF0 to high; Similarly, a falling transition
S * |        |          |will cause CAPIF0 to be set high if PWM group channel 0 falling latch interrupt is enabled
S * |        |          |(CFL_IE0 = 1).
S * |        |          |Write 1 to clear this bit to 0.
S * |[6]     |CRLRI0    |CRLR0 Latched Indicator Bit
S * |        |          |When PWM group input channel 0 has a rising transition, CRLR0 was latched with the value of PWM
S * |        |          |down-counter and this bit is set by hardware.
S * |        |          |Software can write 0 to clear this bit to 0 if the BCn bit is 0, and can write 1 to clear this
S * |        |          |bit to 0 if the BCn bit is 1.
S * |[7]     |CFLRI0    |CFLR0 Latched Indicator Bit
S * |        |          |When PWM group input channel 0 has a falling transition, CFLR0 was latched with the value of PWM
S * |        |          |down-counter and this bit is set by hardware.
S * |        |          |Software can write 0 to clear this bit to 0 if the BCn bit is 0, and can write 1 to clear this
S * |        |          |bit to0 if BCn bit is 1.
S * |[16]    |INV1      |Channel 1 Inverter Enable
S * |        |          |0 = Inverter Disabled.
S * |        |          |1 = Inverter Enabled. Reverse the input signal from GPIO before fed to Capture timer
S * |[17]    |CRL_IE1   |Channel 1 Rising Latch Interrupt Enable
S * |        |          |0 = Rising latch interrupt Disabled.
S * |        |          |1 = Rising latch interrupt Enabled.
S * |        |          |When Enabled, if Capture detects PWM group channel 1 has rising transition, Capture will issue
S * |        |          |an Interrupt.
S * |[18]    |CFL_IE1   |Channel 1 Falling Latch Interrupt Enable
S * |        |          |0 = Falling latch interrupt Disabled.
S * |        |          |1 = Falling latch interrupt Enabled.
S * |        |          |When Enabled, if Capture detects PWM group channel 1 has falling transition, Capture will issue
S * |        |          |an Interrupt.
S * |[19]    |CAPCH1EN  |Channel 1 Capture Function Enable
S * |        |          |0 = Capture function on PWM group channel 1 Disabled.
S * |        |          |1 = Capture function on PWM group channel 1 Enabled.
S * |        |          |When Enabled, Capture latched the PWM-counter and saved to CRLR (Rising latch) and CFLR (Falling
S * |        |          |latch).
S * |        |          |When Disabled, Capture does not update CRLR and CFLR, and disable PWM group channel 1 Interrupt.
S * |[20]    |CAPIF1    |Channel 1 Capture Interrupt Indication Flag
S * |        |          |If PWM group channel 1 rising latch interrupt is enabled (CRL_IE1 = 1), a rising transition
S * |        |          |occurs at PWM group channel 1 will result in CAPIF1 to high; Similarly, a falling transition
S * |        |          |will cause CAPIF1 to be set high if PWM group channel 1 falling latch interrupt is enabled
S * |        |          |(CFL_IE1 = 1).
S * |        |          |Write 1 to clear this bit to 0.
S * |[22]    |CRLRI1    |CRLR1 Latched Indicator Bit
S * |        |          |When PWM group input channel 1 has a rising transition, CRLR1 was latched with the value of PWM
S * |        |          |down-counter and this bit is set by hardware.
S * |        |          |Software can write 0 to clear this bit to 0 if BCn bit is 0, and can write 1 to clear this bit
S * |        |          |to0 if BCn bit is 1.
S * |[23]    |CFLRI1    |CFLR1 Latched Indicator Bit
S * |        |          |When PWM group input channel 1 has a falling transition, CFLR1 was latched with the value of PWM
S * |        |          |down-counter and this bit is set by hardware.
S * |        |          |Software can write 0 to clear this bit to 0 if BCn bit is 0, and can write 1 to clear this bit
S * |        |          |to 0 if BCn bit is 1.
S * @var PWM_T::CCR2
S * Offset: 0x54  PWM Capture Control Register 2
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |INV2      |Channel 2 Inverter Enable
S * |        |          |0 = Inverter Disabled.
S * |        |          |1 = Inverter Enabled. Reverse the input signal from GPIO before fed to Capture timer
S * |[1]     |CRL_IE2   |Channel 2 Rising Latch Interrupt Enable
S * |        |          |0 = Rising latch interrupt Disabled.
S * |        |          |1 = Rising latch interrupt Enabled.
S * |        |          |When Enabled, if Capture detects PWM group channel 2 has rising transition, Capture will issue
S * |        |          |an Interrupt.
S * |[2]     |CFL_IE2   |Channel 2 Falling Latch Interrupt Enable
S * |        |          |0 = Falling latch interrupt Disabled.
S * |        |          |1 = Falling latch interrupt Enabled.
S * |        |          |When Enabled, if Capture detects PWM group channel 2 has falling transition, Capture will issue
S * |        |          |an Interrupt.
S * |[3]     |CAPCH2EN  |Channel 2 Capture Function Enable
S * |        |          |0 = Capture function on PWM group channel 2 Disabled.
S * |        |          |1 = Capture function on PWM group channel 2 Enabled.
S * |        |          |When Enabled, Capture latched the PWM-counter value and saved to CRLR (Rising latch) and CFLR
S * |        |          |(Falling latch).
S * |        |          |When Disabled, Capture does not update CRLR and CFLR, and disable PWM group channel 2 Interrupt.
S * |[4]     |CAPIF2    |Channel 2 Capture Interrupt Indication Flag
S * |        |          |If PWM group channel 2 rising latch interrupt is enabled (CRL_IE2=1), a rising transition occurs
S * |        |          |at PWM group channel 2 will result in CAPIF2 to high; Similarly, a falling transition will cause
S * |        |          |CAPIF2 to be set high if PWM group channel 2 falling latch interrupt is enabled (CFL_IE2=1).
S * |        |          |Write 1 to clear this bit to 0
S * |[6]     |CRLRI2    |CRLR2 Latched Indicator Bit
S * |        |          |When PWM group input channel 2 has a rising transition, CRLR2 was latched with the value of PWM
S * |        |          |down-counter and this bit is set by hardware.
S * |        |          |Software can write 0 to clear this bit to 0 if the BCn bit is 0, and can write 1 to clear this
S * |        |          |bit to 0 if the BCn bit is 1.
S * |[7]     |CFLRI2    |CFLR2 Latched Indicator Bit
S * |        |          |When PWM group input channel 2 has a falling transition, CFLR2 was latched with the value of PWM
S * |        |          |down-counter and this bit is set by hardware.
S * |        |          |Software can write 0 to clear this bit to 0 if BCn bit is 0, and can write 1 to clear this bit
S * |        |          |to 0 if the BCn bit is 1.
S * |[16]    |INV3      |Channel 3 Inverter Enable
S * |        |          |0 = Inverter Disabled.
S * |        |          |1 = Inverter Enabled. Reverse the input signal from GPIO before fed to Capture timer
S * |[17]    |CRL_IE3   |Channel 3 Rising Latch Interrupt Enable
S * |        |          |0 = Rising latch interrupt Disabled.
S * |        |          |1 = Rising latch interrupt Enabled.
S * |        |          |When Enabled, if Capture detects PWM group channel 3 has rising transition, Capture will issue
S * |        |          |an Interrupt.
S * |[18]    |CFL_IE3   |Channel 3 Falling Latch Interrupt Enable
S * |        |          |0 = Falling latch interrupt Disabled.
S * |        |          |1 = Falling latch interrupt Enabled.
S * |        |          |When Enabled, if Capture detects PWM group channel 3 has falling transition, Capture will issue
S * |        |          |an Interrupt.
S * |[19]    |CAPCH3EN  |Channel 3 Capture Function Enable
S * |        |          |0 = Capture function on PWM group channel 3 Disabled.
S * |        |          |1 = Capture function on PWM group channel 3 Enabled.
S * |        |          |When Enabled, Capture latched the PWM-counter and saved to CRLR (Rising latch) and CFLR (Falling
S * |        |          |latch).
S * |        |          |When Disabled, Capture does not update CRLR and CFLR, and disable PWM group channel 3 Interrupt.
S * |[20]    |CAPIF3    |Channel 3 Capture Interrupt Indication Flag
S * |        |          |If PWM group channel 3 rising latch interrupt is enabled (CRL_IE3=1), a rising transition occurs
S * |        |          |at PWM group channel 3 will result in CAPIF3 to high; Similarly, a falling transition will cause
S * |        |          |CAPIF3 to be set high if PWM group channel 3 falling latch interrupt is enabled (CFL_IE3=1).
S * |        |          |Write 1 to clear this bit to 0
S * |[22]    |CRLRI3    |CRLR3 Latched Indicator Bit
S * |        |          |When PWM group input channel 3 has a rising transition, CRLR3 was latched with the value of PWM
S * |        |          |down-counter and this bit is set by hardware.
S * |        |          |Software can write 0 to clear this bit to 0 if the BCn bit is 0, and can write 1 to clear this
S * |        |          |bit to 0 if the BCn bit is 1.
S * |[23]    |CFLRI3    |CFLR3 Latched Indicator Bit
S * |        |          |When PWM group input channel 3 has a falling transition, CFLR3 was latched with the value of PWM
S * |        |          |down-counter and this bit is set by hardware.
S * |        |          |Software can write 0 to clear this bit to 0 if the BCn bit is 0, and can write 1 to clear this
S * |        |          |bit to 0 if the BCn bit is 1.
S * @var PWM_T::CRLR0
S * Offset: 0x58  PWM Capture Rising Latch Register (Channel 0)
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |CRLRx     |Capture Rising Latch Register
S * |        |          |Latch the PWM counter when Channel 0/1/2/3 has rising transition.
S * @var PWM_T::CFLR0
S * Offset: 0x5C  PWM Capture Falling Latch Register (Channel 0)
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |CFLRx     |Capture Falling Latch Register
S * |        |          |Latch the PWM counter when Channel 0/1/2/3 has Falling transition.
S * @var PWM_T::CRLR1
S * Offset: 0x60  PWM Capture Rising Latch Register (Channel 1)
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |CRLRx     |Capture Rising Latch Register
S * |        |          |Latch the PWM counter when Channel 0/1/2/3 has rising transition.
S * @var PWM_T::CFLR1
S * Offset: 0x64  PWM Capture Falling Latch Register (Channel 1)
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |CFLRx     |Capture Falling Latch Register
S * |        |          |Latch the PWM counter when Channel 0/1/2/3 has Falling transition.
S * @var PWM_T::CRLR2
S * Offset: 0x68  PWM Capture Rising Latch Register (Channel 2)
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |CRLRx     |Capture Rising Latch Register
S * |        |          |Latch the PWM counter when Channel 0/1/2/3 has rising transition.
S * @var PWM_T::CFLR2
S * Offset: 0x6C  PWM Capture Falling Latch Register (Channel 2)
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |CFLRx     |Capture Falling Latch Register
S * |        |          |Latch the PWM counter when Channel 0/1/2/3 has Falling transition.
S * @var PWM_T::CRLR3
S * Offset: 0x70  PWM Capture Rising Latch Register (Channel 3)
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |CRLRx     |Capture Rising Latch Register
S * |        |          |Latch the PWM counter when Channel 0/1/2/3 has rising transition.
S * @var PWM_T::CFLR3
S * Offset: 0x74  PWM Capture Falling Latch Register (Channel 3)
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |CFLRx     |Capture Falling Latch Register
S * |        |          |Latch the PWM counter when Channel 0/1/2/3 has Falling transition.
S * @var PWM_T::CAPENR
S * Offset: 0x78  PWM Capture Input 0~3 Enable Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |CINEN0    |Channel 0 Capture Input Enable
S * |        |          |0 = PWM Channel 0 capture input path Disabled.
S * |        |          |The input of PWM channel 0 capture function is always regarded as 0.
S * |        |          |1 = PWM Channel 0 capture input path Enabled.
S * |        |          |The input of PWM channel 0 capture function comes from correlative multifunction pin if GPIO
S * |        |          |multi-function is set as PWM0.
S * |[1]     |CINEN1    |Channel 1 Capture Input Enable
S * |        |          |0 = PWM Channel 1 capture input path Disabled.
S * |        |          |The input of PWM channel 1 capture function is always regarded as 0.
S * |        |          |1 = PWM Channel 1 capture input path Enabled.
S * |        |          |The input of PWM channel 1 capture function comes from correlative multifunction pin if GPIO
S * |        |          |multi-function is set as PWM1.
S * |[2]     |CINEN2    |Channel 2 Capture Input Enable
S * |        |          |0 = PWM Channel 2 capture input path Disabled.
S * |        |          |The input of PWM channel 2 capture function is always regarded as 0.
S * |        |          |1 = PWM Channel 2 capture input path Enabled.
S * |        |          |The input of PWM channel 2 capture function comes from correlative multifunction pin if GPIO
S * |        |          |multi-function is set as PWM2.
S * |[3]     |CINEN3    |Channel 3 Capture Input Enable
S * |        |          |0 = PWM Channel 3 capture input path Disabled.
S * |        |          |The input of PWM channel 3 capture function is always regarded as 0.
S * |        |          |1 = PWM Channel 3 capture input path Enabled.
S * |        |          |The input of PWM channel 3 capture function comes from correlative multifunction pin if GPIO
S * |        |          |multi-function is set as PWM3.
S * @var PWM_T::POE
S * Offset: 0x7C  PWM Output Enable for Channel 0~3
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |POE0      |Channel 0 Output Enable Register
S * |        |          |0 = PWM channel 0 output to pin Disabled.
S * |        |          |1 = PWM channel 0 output to pin Enabled.
S * |        |          |Note: The corresponding GPIO pin must also be switched to PWM function
S * |[1]     |POE1      |Channel 1 Output Enable Register
S * |        |          |0 = PWM channel 1 output to pin Disabled.
S * |        |          |1 = PWM channel 1 output to pin Enabled.
S * |        |          |Note: The corresponding GPIO pin must also be switched to PWM function
S * |[2]     |POE2      |Channel 2 Output Enable Register
S * |        |          |0 = PWM channel 2 output to pin Disabled.
S * |        |          |1 = PWM channel 2 output to pin Enabled.
S * |        |          |Note: The corresponding GPIO pin must also be switched to PWM function
S * |[3]     |POE3      |Channel 3 Output Enable Register
S * |        |          |0 = PWM channel 3 output to pin Disabled.
S * |        |          |1 = PWM channel 3 output to pin Enabled.
S * |        |          |Note: The corresponding GPIO pin must also be switched to PWM function
S * @var PWM_T::TCON
S * Offset: 0x80  PWM Trigger Control for Channel 0~3
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |PWM0TEN   |Channel 0 Center-Aligned Trigger Enable Register
S * |        |          |0 = PWM channel 0 trigger ADC function Disabled.
S * |        |          |1 = PWM channel 0 trigger ADC function Enabled.
S * |        |          |PWM can trigger ADC to start conversion when PWM counter up count to CNR if this bit is set to
S * |        |          |1.
S * |        |          |Note: This function is only supported when PWM operating at Center-aligned type.
S * |[1]     |PWM1TEN   |Channel 1 Center-Aligned Trigger Enable Register
S * |        |          |0 = PWM channel 1 trigger ADC function Disabled.
S * |        |          |1 = PWM channel 1 trigger ADC function Enabled.
S * |        |          |PWM can trigger ADC to start conversion when PWM counter up count to CNR if this bit is set to
S * |        |          |1.
S * |        |          |Note: This function is only supported when PWM operating at Center-aligned type.
S * |[2]     |PWM2TEN   |Channel 2 Center-Aligned Trigger Enable Register
S * |        |          |0 = PWM channel 2 trigger ADC function Disabled.
S * |        |          |1 = PWM channel 2 trigger ADC function Enabled.
S * |        |          |PWM can trigger ADC to start conversion when PWM counter up count to CNR if this bit is set to
S * |        |          |1.
S * |        |          |Note: This function is only supported when PWM operating at Center-aligned type.
S * |[3]     |PWM3TEN   |Channel 3 Center-Aligned Trigger Enable Register
S * |        |          |0 = PWM channel 3 trigger ADC function Disabled.
S * |        |          |1 = PWM channel 3 trigger ADC function Enabled.
S * |        |          |PWM can trigger ADC to start conversion when PWM counter up count to CNR if this bit is set to
S * |        |          |1.
S * |        |          |Note: This function is only supported when PWM operating at Center-aligned type.
S * @var PWM_T::TSTATUS
S * Offset: 0x84  PWM Trigger Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |PWM0TF    |Channel 0 Center-Aligned Trigger Flag
S * |        |          |For Center-aligned Operating mode, this bit is set to 1 by hardware when PWM counter up counts
S * |        |          |to CNR if PWM0TEN bit is set to 1.
S * |        |          |After this bit is set to 1, ADC will start conversion if ADC triggered source is selected by
S * |        |          |PWM.
S * |        |          |Software can write 1 to clear this bit.
S * |[1]     |PWM1TF    |Channel 1 Center-Aligned Trigger Flag
S * |        |          |For Center-aligned Operating mode, this bit is set to 1 by hardware when PWM counter up count to
S * |        |          |CNR if PWM1TEN bit is set to 1.
S * |        |          |After this bit is set to 1, ADC will start conversion if ADC triggered source is selected by
S * |        |          |PWM.
S * |        |          |Software can write 1 to clear this bit.
S * |[2]     |PWM2TF    |Channel 2 Center-Aligned Trigger Flag
S * |        |          |For Center-aligned Operating mode, this bit is set to 1 by hardware when PWM counter up count to
S * |        |          |CNR if PWM2TEN bit is set to 1.
S * |        |          |After this bit is set to 1, ADC will start conversion if ADC triggered source is selected by
S * |        |          |PWM.
S * |        |          |Software can write 1 to clear this bit.
S * |[3]     |PWM3TF    |Channel 3 Center-Aligned Trigger Flag
S * |        |          |For Center-aligned Operating mode, this bit is set to 1 by hardware when PWM counter up count to
S * |        |          |CNR if PWM3TEN bit is set to 1.
S * |        |          |After this bit is set to 1, ADC will start conversion if ADC triggered source is selected by
S * |        |          |PWM.
S * |        |          |Software can write 1 to clear this bit.
S * @var PWM_T::SYNCBUSY0
S * Offset: 0x88  PWM0 Synchronous Busy Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |S_BUSY    |PWM Synchronous Busy
S * |        |          |When software writes CNR0/CMR0/PPR or switches PWM0 operation mode (PCR[3]), PWM will have a
S * |        |          |busy time to update these values completely because PWM clock may be different from system clock
S * |        |          |domain.
S * |        |          |Software needs to check this busy status before writing CNR0/CMR0/PPR or switching PWM0
S * |        |          |operation mode (PCR[3]) to make sure previous setting has been updated completely.
S * |        |          |This bit will be set when software writes CNR0/CMR0/PPR or switches PWM0 operation mode (PCR[3])
S * |        |          |and will be cleared by hardware automatically when PWM update these value completely.
S * @var PWM_T::SYNCBUSY1
S * Offset: 0x8C  PWM1 Synchronous Busy Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |S_BUSY    |PWM Synchronous Busy
S * |        |          |When Software writes CNR1/CMR1/PPR or switches PWM1 operation mode (PCR[11]), PWM will have a
S * |        |          |busy time to update these values completely because PWM clock may be different from system clock
S * |        |          |domain.
S * |        |          |Software needs to check this busy status before writing CNR1/CMR1/PPR or switching PWM1
S * |        |          |operation mode (PCR[11]) to make sure previous setting has been updated completely.
S * |        |          |This bit will be set when software writes CNR1/CMR1/PPR or switches PWM1 operation mode
S * |        |          |(PCR[11]) and will be cleared by hardware automatically when PWM update these value completely.
S * @var PWM_T::SYNCBUSY2
S * Offset: 0x90  PWM2 Synchronous Busy Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |S_BUSY    |PWM Synchronous Busy
S * |        |          |When Software writes CNR2/CMR2/PPR or switch PWM2 operation mode (PCR[19]), PWM will have a busy
S * |        |          |time to update these values completely because PWM clock may be different from system clock
S * |        |          |domain.
S * |        |          |Software needs to check this busy status before writing CNR2/CMR2/PPR or switching PWM2
S * |        |          |operation mode (PCR[19]) to make sure previous setting has been updated completely.
S * |        |          |This bit will be set when software writes CNR2/CMR2/PPR or switch PWM2 operation mode (PCR[19])
S * |        |          |and will be cleared by hardware automatically when PWM update these value completely.
S * @var PWM_T::SYNCBUSY3
S * Offset: 0x94  PWM3 Synchronous Busy Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |S_BUSY    |PWM Synchronous Busy
S * |        |          |When Software writes CNR3/CMR3/PPR or switch PWM3 operation mode (PCR[27]), PWM will have a busy
S * |        |          |time to update these values completely because PWM clock may be different from system clock
S * |        |          |domain.
S * |        |          |Software need to check this busy status before writing CNR3/CMR3/PPR or switching PWM3 operation
S * |        |          |mode (PCR[27]) to make sure previous setting has been updated completely.
S * |        |          |This bit will be set when Software writes CNR3/CMR3/PPR or switch PWM3 operation mode (PCR[27])
S * |        |          |and will be cleared by hardware automatically when PWM update these value completely.
S */
S
S    __IO uint32_t PPR;           /* Offset: 0x00  PWM Prescaler Register                                             */
S    __IO uint32_t CSR;           /* Offset: 0x04  PWM Clock Source Divider Select Register                           */
S    __IO uint32_t PCR;           /* Offset: 0x08  PWM Control Register                                               */
S    __IO uint32_t CNR0;          /* Offset: 0x0C  PWM Counter Register 0                                             */
S    __IO uint32_t CMR0;          /* Offset: 0x0C  PWM Counter Register 0                                             */
S    __I  uint32_t PDR0;          /* Offset: 0x14  PWM Data Register 0                                                */
S    __IO uint32_t CNR1;          /* Offset: 0x18  PWM Counter Register 1                                             */
S    __IO uint32_t CMR1;          /* Offset: 0x1C  PWM Comparator Register 1                                          */
S    __I  uint32_t PDR1;          /* Offset: 0x20  PWM Data Register 1                                                */
S    __IO uint32_t CNR2;          /* Offset: 0x24  PWM Counter Register 2                                             */
S    __IO uint32_t CMR2;          /* Offset: 0x28  PWM Comparator Register 2                                          */
S    __I  uint32_t PDR2;          /* Offset: 0x2C  PWM Data Register 2                                                */
S    __IO uint32_t CNR3;          /* Offset: 0x30  PWM Counter Register 3                                             */
S    __IO uint32_t CMR3;          /* Offset: 0x34  PWM Comparator Register 3                                          */
S    __I  uint32_t PDR3;          /* Offset: 0x38  PWM Data Register 3                                                */
S    __IO uint32_t PBCR;          /* Offset: 0x3C  PWM Backward Compatible Register                                   */
S    __IO uint32_t PIER;          /* Offset: 0x40  PWM Interrupt Enable Register                                      */
S    __IO uint32_t PIIR;          /* Offset: 0x44  PWM Interrupt Indication Register                                  */
S    __I  uint32_t RESERVE1[2];  
S    __IO uint32_t CCR0;          /* Offset: 0x50  PWM Capture Control Register 0                                     */
S    __IO uint32_t CCR2;          /* Offset: 0x54  PWM Capture Control Register 2                                     */
S    __IO uint32_t CRLR0;         /* Offset: 0x58  PWM Capture Rising Latch Register (Channel 0)                      */
S    __IO uint32_t CFLR0;         /* Offset: 0x5C  PWM Capture Falling Latch Register (Channel 0)                     */
S    __IO uint32_t CRLR1;         /* Offset: 0x60  PWM Capture Rising Latch Register (Channel 1)                      */
S    __IO uint32_t CFLR1;         /* Offset: 0x64  PWM Capture Falling Latch Register (Channel 1)                     */
S    __IO uint32_t CRLR2;         /* Offset: 0x68  PWM Capture Rising Latch Register (Channel 2)                      */
S    __IO uint32_t CFLR2;         /* Offset: 0x6C  PWM Capture Falling Latch Register (Channel 2)                     */
S    __IO uint32_t CRLR3;         /* Offset: 0x70  PWM Capture Rising Latch Register (Channel 3)                      */
S    __IO uint32_t CFLR3;         /* Offset: 0x74  PWM Capture Falling Latch Register (Channel 3)                     */
S    __IO uint32_t CAPENR;        /* Offset: 0x78  PWM Capture Input 0~3 Enable Register                              */
S    __IO uint32_t POE;           /* Offset: 0x7C  PWM Output Enable for Channel 0~3                                  */
S    __IO uint32_t TCON;          /* Offset: 0x80  PWM Trigger Control for Channel 0~3                                */
S    __IO uint32_t TSTATUS;       /* Offset: 0x84  PWM Trigger Status Register                                        */
S    __IO uint32_t SYNCBUSY0;     /* Offset: 0x88  PWM0 Synchronous Busy Status Register                              */
S    __IO uint32_t SYNCBUSY1;     /* Offset: 0x8C  PWM1 Synchronous Busy Status Register                              */
S    __IO uint32_t SYNCBUSY2;     /* Offset: 0x90  PWM2 Synchronous Busy Status Register                              */
S    __IO uint32_t SYNCBUSY3;     /* Offset: 0x94  PWM3 Synchronous Busy Status Register                              */
S
S} PWM_T;
S
S
S/**
S    @addtogroup PWM_CONST PWM Bit Field Definition
S    Constant Definitions for PWM Controller
S@{ */
S
S
S/* PWM PPR Bit Field Definitions */
S#define PWM_PPR_DZI23_Pos                       24                                  /*!< PWM_T::PPR: DZI23 Position */
S#define PWM_PPR_DZI23_Msk                       (0xFFul << PWM_PPR_DZI23_Pos)       /*!< PWM_T::PPR: DZI23 Mask */
S
S#define PWM_PPR_DZI01_Pos                       16                                  /*!< PWM_T::PPR: DZI01 Position */
S#define PWM_PPR_DZI01_Msk                       (0xFFul << PWM_PPR_DZI01_Pos)       /*!< PWM_T::PPR: DZI01 Mask */
S
S#define PWM_PPR_CP23_Pos                        8                                   /*!< PWM_T::PPR: CP23 Position */
S#define PWM_PPR_CP23_Msk                        (0xFFul << PWM_PPR_CP23_Pos)        /*!< PWM_T::PPR: CP23 Mask */
S
S#define PWM_PPR_CP01_Pos                        0                                   /*!< PWM_T::PPR: CP01 Position */
S#define PWM_PPR_CP01_Msk                        (0xFFul << PWM_PPR_CP01_Pos)        /*!< PWM_T::PPR: CP01 Mask */
S
S/* PWM CSR Bit Field Definitions */
S#define PWM_CSR_CSR3_Pos                        12                                  /*!< PWM_T::CSR: CSR3 Position */
S#define PWM_CSR_CSR3_Msk                        (7ul << PWM_CSR_CSR3_Pos)           /*!< PWM_T::CSR: CSR3 Mask */
S
S#define PWM_CSR_CSR2_Pos                        8                                   /*!< PWM_T::CSR: CSR2 Position */
S#define PWM_CSR_CSR2_Msk                        (7ul << PWM_CSR_CSR2_Pos)           /*!< PWM_T::CSR: CSR2 Mask */
S
S#define PWM_CSR_CSR1_Pos                        4                                   /*!< PWM_T::CSR: CSR1 Position */
S#define PWM_CSR_CSR1_Msk                        (7ul << PWM_CSR_CSR1_Pos)           /*!< PWM_T::CSR: CSR1 Mask */
S
S#define PWM_CSR_CSR0_Pos                        0                                   /*!< PWM_T::CSR: CSR0 Position */
S#define PWM_CSR_CSR0_Msk                        (7ul << PWM_CSR_CSR0_Pos)           /*!< PWM_T::CSR: CSR0 Mask */
S
S/* PWM PCR Bit Field Definitions */
S#define PWM_PCR_PWM23TYPE_Pos                   31                                  /*!< PWM_T::PCR: PWM23TYPE Position */
S#define PWM_PCR_PWM23TYPE_Msk                   (1ul << PWM_PCR_PWM23TYPE_Pos)      /*!< PWM_T::PCR: PWM23TYPE Mask */
S
S#define PWM_PCR_PWM01TYPE_Pos                   30                                  /*!< PWM_T::PCR: PWM01TYPE Position */
S#define PWM_PCR_PWM01TYPE_Msk                   (1ul << PWM_PCR_PWM01TYPE_Pos)      /*!< PWM_T::PCR: PWM01TYPE Mask */
S
S#define PWM_PCR_CH3MOD_Pos                      27                                  /*!< PWM_T::PCR: CH3MOD Position */
S#define PWM_PCR_CH3MOD_Msk                      (1ul << PWM_PCR_CH3MOD_Pos)         /*!< PWM_T::PCR: CH3MOD Mask */
S
S#define PWM_PCR_CH3INV_Pos                      26                                  /*!< PWM_T::PCR: CH3INV Position */
S#define PWM_PCR_CH3INV_Msk                      (1ul << PWM_PCR_CH3INV_Pos)         /*!< PWM_T::PCR: CH3INV Mask */
S
S#define PWM_PCR_CH3PINV_Pos                     25                                  /*!< PWM_T::PCR: CH3PINV Position */
S#define PWM_PCR_CH3PINV_Msk                     (1ul << PWM_PCR_CH3PINV_Pos)        /*!< PWM_T::PCR: CH3PINV Mask */
S
S#define PWM_PCR_CH3EN_Pos                       24                                  /*!< PWM_T::PCR: CH3EN Position */
S#define PWM_PCR_CH3EN_Msk                       (1ul << PWM_PCR_CH3EN_Pos)          /*!< PWM_T::PCR: CH3EN Mask */
S
S#define PWM_PCR_CH2MOD_Pos                      19                                  /*!< PWM_T::PCR: CH2MOD Position */
S#define PWM_PCR_CH2MOD_Msk                      (1ul << PWM_PCR_CH2MOD_Pos)         /*!< PWM_T::PCR: CH2MOD Mask */
S
S#define PWM_PCR_CH2INV_Pos                      18                                  /*!< PWM_T::PCR: CH2INV Position */
S#define PWM_PCR_CH2INV_Msk                      (1ul << PWM_PCR_CH2INV_Pos)         /*!< PWM_T::PCR: CH2INV Mask */
S
S#define PWM_PCR_CH2PINV_Pos                     17                                  /*!< PWM_T::PCR: CH2PINV Position */
S#define PWM_PCR_CH2PINV_Msk                     (1ul << PWM_PCR_CH2PINV_Pos)        /*!< PWM_T::PCR: CH2PINV Mask */
S
S#define PWM_PCR_CH2EN_Pos                       16                                  /*!< PWM_T::PCR: CH2EN Position */
S#define PWM_PCR_CH2EN_Msk                       (1ul << PWM_PCR_CH2EN_Pos)          /*!< PWM_T::PCR: CH2EN Mask */
S
S#define PWM_PCR_CH1MOD_Pos                      11                                  /*!< PWM_T::PCR: CH1MOD Position */
S#define PWM_PCR_CH1MOD_Msk                      (1ul << PWM_PCR_CH1MOD_Pos)         /*!< PWM_T::PCR: CH1MOD Mask */
S
S#define PWM_PCR_CH1INV_Pos                      10                                  /*!< PWM_T::PCR: CH1INV Position */
S#define PWM_PCR_CH1INV_Msk                      (1ul << PWM_PCR_CH1INV_Pos)         /*!< PWM_T::PCR: CH1INV Mask */
S
S#define PWM_PCR_CH1PINV_Pos                     9                                   /*!< PWM_T::PCR: CH1PINV Position */
S#define PWM_PCR_CH1PINV_Msk                     (1ul << PWM_PCR_CH1PINV_Pos)        /*!< PWM_T::PCR: CH1PINV Mask */
S
S#define PWM_PCR_CH1EN_Pos                       8                                   /*!< PWM_T::PCR: CH1EN Position */
S#define PWM_PCR_CH1EN_Msk                       (1ul << PWM_PCR_CH1EN_Pos)          /*!< PWM_T::PCR: CH1EN Mask */
S
S#define PWM_PCR_DZEN23_Pos                      5                                   /*!< PWM_T::PCR: DZEN23 Position */
S#define PWM_PCR_DZEN23_Msk                      (1ul << PWM_PCR_DZEN23_Pos)         /*!< PWM_T::PCR: DZEN23 Mask */
S
S#define PWM_PCR_DZEN01_Pos                      4                                   /*!< PWM_T::PCR: DZEN01 Position */
S#define PWM_PCR_DZEN01_Msk                      (1ul << PWM_PCR_DZEN01_Pos)         /*!< PWM_T::PCR: DZEN01 Mask */
S
S#define PWM_PCR_CH0MOD_Pos                      3                                   /*!< PWM_T::PCR: CH0MOD Position */
S#define PWM_PCR_CH0MOD_Msk                      (1ul << PWM_PCR_CH0MOD_Pos)         /*!< PWM_T::PCR: CH0MOD Mask */
S
S#define PWM_PCR_CH0INV_Pos                      2                                   /*!< PWM_T::PCR: CH0INV Position */
S#define PWM_PCR_CH0INV_Msk                      (1ul << PWM_PCR_CH0INV_Pos)         /*!< PWM_T::PCR: CH0INV Mask */
S
S#define PWM_PCR_CH0PINV_Pos                      1                                  /*!< PWM_T::PCR: CH0PINV Position */
S#define PWM_PCR_CH0PINV_Msk                     (1ul << PWM_PCR_CH0PINV_Pos)        /*!< PWM_T::PCR: CH0PINV Mask */
S
S#define PWM_PCR_CH0EN_Pos                       0                                   /*!< PWM_T::PCR: CH0EN Position */
S#define PWM_PCR_CH0EN_Msk                       (1ul << PWM_PCR_CH0EN_Pos)          /*!< PWM_T::PCR: CH0EN Mask */
S
S/* PWM CNR Bit Field Definitions */
S#define PWM_CNR_CNR_Pos                         0                                   /*!< PWM_T::CNR0: CNR Position */
S#define PWM_CNR_CNR_Msk                         (0xFFFFul << PWM_CNR_CNR_Pos)       /*!< PWM_T::CNR0: CNR Mask */
S
S/* PWM CMR Bit Field Definitions */
S#define PWM_CMR_CMR_Pos                         0                                   /*!< PWM_T::CMR0: CMR Position */
S#define PWM_CMR_CMR_Msk                         (0xFFFFul << PWM_CMR_CMR_Pos)       /*!< PWM_T::CMR0: CMR Mask */
S
S/* PWM PDR Bit Field Definitions */
S#define PWM_PDR_PDR_Pos                         0                                   /*!< PWM_T::PDR0: PDR Position */
S#define PWM_PDR_PDR_Msk                         (0xFFFFul << PWM_PDR_PDR_Pos)       /*!< PWM_T::PDR0: PDR Mask */
S
S/* PWM PBCR Bit Field Definitions */
S#define PWM_PBCR_BCn_Pos                         0                                  /*!< PWM_T::PBCR: BCn Position */
S#define PWM_PBCR_BCn_Msk                         (1ul << PWM_PBCR_BCn_Pos)          /*!< PWM_T::PBCR: BCn Mask */
S
S/* PWM PIER Bit Field Definitions */
S
S#define PWM_PIER_INT23TYPE_Pos                  17                                  /*!< PWM_T::PIER: INT23TYPE Position */
S#define PWM_PIER_INT23TYPE_Msk                     (1ul << PWM_PIER_INT23TYPE_Pos)  /*!< PWM_T::PIER: INT23TYPE Mask */
S
S#define PWM_PIER_INT01TYPE_Pos                  16                                  /*!< PWM_T::PIER: INT01TYPE Position */
S#define PWM_PIER_INT01TYPE_Msk                     (1ul << PWM_PIER_INT01TYPE_Pos)  /*!< PWM_T::PIER: INT01TYPE Mask */
S
S#define PWM_PIER_PWMDIE3_Pos                    11                                  /*!< PWM_T::PIER: PWMDIE3 Position */
S#define PWM_PIER_PWMDIE3_Msk                     (1ul << PWM_PIER_PWMDIE3_Pos)      /*!< PWM_T::PIER: PWMDIE3 Mask */
S
S#define PWM_PIER_PWMDIE2_Pos                    10                                  /*!< PWM_T::PIER: PWMDIE2 Position */
S#define PWM_PIER_PWMDIE2_Msk                     (1ul << PWM_PIER_PWMDIE2_Pos)      /*!< PWM_T::PIER: PWMDIE2 Mask */
S
S#define PWM_PIER_PWMDIE1_Pos                    9                                   /*!< PWM_T::PIER: PWMDIE1 Position */
S#define PWM_PIER_PWMDIE1_Msk                     (1ul << PWM_PIER_PWMDIE1_Pos)      /*!< PWM_T::PIER: PWMDIE1 Mask */
S
S#define PWM_PIER_PWMDIE0_Pos                    8                                   /*!< PWM_T::PIER: PWMDIE0 Position */
S#define PWM_PIER_PWMDIE0_Msk                     (1ul << PWM_PIER_PWMDIE0_Pos)      /*!< PWM_T::PIER: PWMDIE0 Mask */
S
S#define PWM_PIER_PWMIE3_Pos                     3                                   /*!< PWM_T::PIER: PWMIE3 Position */
S#define PWM_PIER_PWMIE3_Msk                     (1ul << PWM_PIER_PWMIE3_Pos)        /*!< PWM_T::PIER: PWMIE3 Mask */
S
S#define PWM_PIER_PWMIE2_Pos                     2                                   /*!< PWM_T::PIER: PWMIE2 Position */
S#define PWM_PIER_PWMIE2_Msk                     (1ul << PWM_PIER_PWMIE2_Pos)        /*!< PWM_T::PIER: PWMIE2 Mask */
S
S#define PWM_PIER_PWMIE1_Pos                     1                                   /*!< PWM_T::PIER: PWMIE1 Position */
S#define PWM_PIER_PWMIE1_Msk                     (1ul << PWM_PIER_PWMIE1_Pos)        /*!< PWM_T::PIER: PWMIE1 Mask */
S
S#define PWM_PIER_PWMIE0_Pos                     0                                   /*!< PWM_T::PIER: PWMIE0 Position */
S#define PWM_PIER_PWMIE0_Msk                     (1ul << PWM_PIER_PWMIE0_Pos)        /*!< PWM_T::PIER: PWMIE0 Mask */
S
S/* PWM PIIR Bit Field Definitions */
S#define PWM_PIIR_PWMDIF3_Pos                    11                                  /*!< PWM_T::PIIR: PWMDIF3 Position */
S#define PWM_PIIR_PWMDIF3_Msk                    (1ul << PWM_PIIR_PWMDIF3_Pos)       /*!< PWM_T::PIIR: PWMDIF3 Mask */
S
S#define PWM_PIIR_PWMDIF2_Pos                    10                                  /*!< PWM_T::PIIR: PWMDIF2 Position */
S#define PWM_PIIR_PWMDIF2_Msk                    (1ul << PWM_PIIR_PWMDIF2_Pos)       /*!< PWM_T::PIIR: PWMDIF2 Mask */
S
S#define PWM_PIIR_PWMDIF1_Pos                    9                                   /*!< PWM_T::PIIR: PWMDIF1 Position */
S#define PWM_PIIR_PWMDIF1_Msk                    (1ul << PWM_PIIR_PWMDIF1_Pos)       /*!< PWM_T::PIIR: PWMDIF1 Mask */
S
S#define PWM_PIIR_PWMDIF0_Pos                    8                                   /*!< PWM_T::PIIR: PWMDIF0 Position */
S#define PWM_PIIR_PWMDIF0_Msk                    (1ul << PWM_PIIR_PWMDIF0_Pos)       /*!< PWM_T::PIIR: PWMDIF0 Mask */
S
S#define PWM_PIIR_PWMIF3_Pos                     3                                   /*!< PWM_T::PIIR: PWMIF3 Position */
S#define PWM_PIIR_PWMIF3_Msk                     (1ul << PWM_PIIR_PWMIF3_Pos)        /*!< PWM_T::PIIR: PWMIF3 Mask */
S
S#define PWM_PIIR_PWMIF2_Pos                     2                                   /*!< PWM_T::PIIR: PWMIF2 Position */
S#define PWM_PIIR_PWMIF2_Msk                     (1ul << PWM_PIIR_PWMIF2_Pos)        /*!< PWM_T::PIIR: PWMIF2 Mask */
S
S#define PWM_PIIR_PWMIF1_Pos                     1                                   /*!< PWM_T::PIIR: PWMIF1 Position */
S#define PWM_PIIR_PWMIF1_Msk                     (1ul << PWM_PIIR_PWMIF1_Pos)        /*!< PWM_T::PIIR: PWMIF1 Mask */
S
S#define PWM_PIIR_PWMIF0_Pos                     0                                   /*!< PWM_T::PIIR: PWMIF0 Position */
S#define PWM_PIIR_PWMIF0_Msk                     (1ul << PWM_PIIR_PWMIF0_Pos)        /*!< PWM_T::PIIR: PWMIF0 Mask */
S
S/* PWM CCR0 Bit Field Definitions */
S#define PWM_CCR0_CFLRI1_Pos                     23                                  /*!< PWM_T::CCR0: CFLRI1 Position */
S#define PWM_CCR0_CFLRI1_Msk                     (1ul << PWM_CCR0_CFLRI1_Pos)        /*!< PWM_T::CCR0: CFLRI1 Mask */
S
S#define PWM_CCR0_CRLRI1_Pos                     22                                  /*!< PWM_T::CCR0: CRLRI1 Position */
S#define PWM_CCR0_CRLRI1_Msk                     (1ul << PWM_CCR0_CRLRI1_Pos)        /*!< PWM_T::CCR0: CRLRI1 Mask */
S
S#define PWM_CCR0_CAPIF1_Pos                     20                                  /*!< PWM_T::CCR0: CAPIF1 Position */
S#define PWM_CCR0_CAPIF1_Msk                     (1ul << PWM_CCR0_CAPIF1_Pos)        /*!< PWM_T::CCR0: CAPIF1 Mask */
S
S#define PWM_CCR0_CAPCH1EN_Pos                   19                                  /*!< PWM_T::CCR0: CAPCH1EN Position */
S#define PWM_CCR0_CAPCH1EN_Msk                   (1ul << PWM_CCR0_CAPCH1EN_Pos)      /*!< PWM_T::CCR0: CAPCH1EN Mask */
S
S#define PWM_CCR0_CFL_IE1_Pos                    18                                  /*!< PWM_T::CCR0: CFL_IE1 Position */
S#define PWM_CCR0_CFL_IE1_Msk                    (1ul << PWM_CCR0_CFL_IE1_Pos)       /*!< PWM_T::CCR0: CFL_IE1 Mask */
S
S#define PWM_CCR0_CRL_IE1_Pos                    17                                  /*!< PWM_T::CCR0: CRL_IE1 Position */
S#define PWM_CCR0_CRL_IE1_Msk                    (1ul << PWM_CCR0_CRL_IE1_Pos)       /*!< PWM_T::CCR0: CRL_IE1 Mask */
S
S#define PWM_CCR0_INV1_Pos                       16                                  /*!< PWM_T::CCR0: INV1 Position */
S#define PWM_CCR0_INV1_Msk                       (1ul << PWM_CCR0_INV1_Pos)          /*!< PWM_T::CCR0: INV1 Mask */
S
S#define PWM_CCR0_CFLRI0_Pos                     7                                   /*!< PWM_T::CCR0: CFLRI0 Position */
S#define PWM_CCR0_CFLRI0_Msk                     (1ul << PWM_CCR0_CFLRI0_Pos)        /*!< PWM_T::CCR0: CFLRI0 Mask */
S
S#define PWM_CCR0_CRLRI0_Pos                     6                                   /*!< PWM_T::CCR0: CRLRI0 Position */
S#define PWM_CCR0_CRLRI0_Msk                     (1ul << PWM_CCR0_CRLRI0_Pos)        /*!< PWM_T::CCR0: CRLRI0 Mask */
S
S#define PWM_CCR0_CAPIF0_Pos                     4                                   /*!< PWM_T::CCR0: CAPIF0 Position */
S#define PWM_CCR0_CAPIF0_Msk                     (1ul << PWM_CCR0_CAPIF0_Pos)        /*!< PWM_T::CCR0: CAPIF0 Mask */
S
S#define PWM_CCR0_CAPCH0EN_Pos                   3                                   /*!< PWM_T::CCR0: CAPCH0EN Position */
S#define PWM_CCR0_CAPCH0EN_Msk                   (1ul << PWM_CCR0_CAPCH0EN_Pos)      /*!< PWM_T::CCR0: CAPCH0EN Mask */
S
S#define PWM_CCR0_CFL_IE0_Pos                    2                                   /*!< PWM_T::CCR0: CFL_IE0 Position */
S#define PWM_CCR0_CFL_IE0_Msk                    (1ul << PWM_CCR0_CFL_IE0_Pos)       /*!< PWM_T::CCR0: CFL_IE0 Mask */
S
S#define PWM_CCR0_CRL_IE0_Pos                    1                                   /*!< PWM_T::CCR0: CRL_IE0 Position */
S#define PWM_CCR0_CRL_IE0_Msk                    (1ul << PWM_CCR0_CRL_IE0_Pos)       /*!< PWM_T::CCR0: CRL_IE0 Mask */
S
S#define PWM_CCR0_INV0_Pos                       0                                   /*!< PWM_T::CCR0: INV0 Position */
S#define PWM_CCR0_INV0_Msk                       (1ul << PWM_CCR0_INV0_Pos)          /*!< PWM_T::CCR0: INV0 Mask */
S
S/* PWM CCR2 Bit Field Definitions */
S#define PWM_CCR2_CFLRI3_Pos                     23                                  /*!< PWM_T::CCR2: CFLRI3 Position */
S#define PWM_CCR2_CFLRI3_Msk                     (1ul << PWM_CCR2_CFLRI3_Pos)        /*!< PWM_T::CCR2: CFLRI3 Mask */
S
S#define PWM_CCR2_CRLRI3_Pos                     22                                  /*!< PWM_T::CCR2: CRLRI3 Position */
S#define PWM_CCR2_CRLRI3_Msk                     (1ul << PWM_CCR2_CRLRI3_Pos)        /*!< PWM_T::CCR2: CRLRI3 Mask */
S
S#define PWM_CCR2_CAPIF3_Pos                     20                                  /*!< PWM_T::CCR2: CAPIF3 Position */
S#define PWM_CCR2_CAPIF3_Msk                     (1ul << PWM_CCR2_CAPIF3_Pos)        /*!< PWM_T::CCR2: CAPIF3 Mask */
S
S#define PWM_CCR2_CAPCH3EN_Pos                   19                                  /*!< PWM_T::CCR2: CAPCH3EN Position */
S#define PWM_CCR2_CAPCH3EN_Msk                   (1ul << PWM_CCR2_CAPCH3EN_Pos)      /*!< PWM_T::CCR2: CAPCH3EN Mask */
S
S#define PWM_CCR2_CFL_IE3_Pos                    18                                  /*!< PWM_T::CCR2: CFL_IE3 Position */
S#define PWM_CCR2_CFL_IE3_Msk                    (1ul << PWM_CCR2_CFL_IE3_Pos)       /*!< PWM_T::CCR2: CFL_IE3 Mask */
S
S#define PWM_CCR2_CRL_IE3_Pos                    17                                  /*!< PWM_T::CCR2: CRL_IE3 Position */
S#define PWM_CCR2_CRL_IE3_Msk                    (1ul << PWM_CCR2_CRL_IE3_Pos)       /*!< PWM_T::CCR2: CRL_IE3 Mask */
S
S#define PWM_CCR2_INV3_Pos                       16                                  /*!< PWM_T::CCR2: INV3 Position */
S#define PWM_CCR2_INV3_Msk                       (1ul << PWM_CCR2_INV3_Pos)          /*!< PWM_T::CCR2: INV3 Mask */
S
S#define PWM_CCR2_CFLRI2_Pos                     7                                   /*!< PWM_T::CCR2: CFLRI2 Position */
S#define PWM_CCR2_CFLRI2_Msk                     (1ul << PWM_CCR2_CFLRI2_Pos)        /*!< PWM_T::CCR2: CFLRI2 Mask */
S
S#define PWM_CCR2_CRLRI2_Pos                     6                                   /*!< PWM_T::CCR2: CRLRI2 Position */
S#define PWM_CCR2_CRLRI2_Msk                     (1ul << PWM_CCR2_CRLRI2_Pos)        /*!< PWM_T::CCR2: CRLRI2 Mask */
S
S#define PWM_CCR2_CAPIF2_Pos                     4                                   /*!< PWM_T::CCR2: CAPIF2 Position */
S#define PWM_CCR2_CAPIF2_Msk                     (1ul << PWM_CCR2_CAPIF2_Pos)        /*!< PWM_T::CCR2: CAPIF2 Mask */
S
S#define PWM_CCR2_CAPCH2EN_Pos                   3                                   /*!< PWM_T::CCR2: CAPCH2EN Position */
S#define PWM_CCR2_CAPCH2EN_Msk                   (1ul << PWM_CCR2_CAPCH2EN_Pos)      /*!< PWM_T::CCR2: CAPCH2EN Mask */
S
S#define PWM_CCR2_CFL_IE2_Pos                    2                                   /*!< PWM_T::CCR2: CFL_IE2 Position */
S#define PWM_CCR2_CFL_IE2_Msk                    (1ul << PWM_CCR2_CFL_IE2_Pos)       /*!< PWM_T::CCR2: CFL_IE2 Mask */
S
S#define PWM_CCR2_CRL_IE2_Pos                    1                                   /*!< PWM_T::CCR2: CRL_IE2 Position */
S#define PWM_CCR2_CRL_IE2_Msk                    (1ul << PWM_CCR2_CRL_IE2_Pos)       /*!< PWM_T::CCR2: CRL_IE2 Mask */
S
S#define PWM_CCR2_INV2_Pos                       0                                   /*!< PWM_T::CCR2: INV2 Position */
S#define PWM_CCR2_INV2_Msk                       (1ul << PWM_CCR2_INV2_Pos)          /*!< PWM_T::CCR2: INV2 Mask */
S
S/* PWM CRLR Bit Field Definitions */
S#define PWM_CRLR_CRLR_Pos                       0                                   /*!< PWM_T::CRLR0: CRLR Position */
S#define PWM_CRLR_CRLR_Msk                       (0xFFFFul << PWM_CRLR_CRLR_Pos)     /*!< PWM_T::CRLR0: CRLR Mask */
S
S/* PWM CFLR Bit Field Definitions */
S#define PWM_CFLR_CFLR_Pos                       0                                   /*!< PWM_T::CFLR0: CFLR Position */
S#define PWM_CFLR_CFLR_Msk                       (0xFFFFul << PWM_CFLR_CFLR_Pos)     /*!< PWM_T::CFLR0: CFLR Mask */
S
S/* PWM CAPENR Bit Field Definitions */
S#define PWM_CAPENR_CINEN3_Pos                   3                                   /*!< PWM_T::CAPENR: CINEN3 Position */
S#define PWM_CAPENR_CINEN3_Msk                   (1ul << PWM_CAPENR_CINEN3_Pos)      /*!< PWM_T::CAPENR: CINEN3 Mask */
S
S#define PWM_CAPENR_CINEN2_Pos                   2                                   /*!< PWM_T::CAPENR: CINEN2 Position */
S#define PWM_CAPENR_CINEN2_Msk                   (1ul << PWM_CAPENR_CINEN2_Pos)      /*!< PWM_T::CAPENR: CINEN2 Mask */
S
S#define PWM_CAPENR_CINEN1_Pos                   1                                   /*!< PWM_T::CAPENR: CINEN1 Position */
S#define PWM_CAPENR_CINEN1_Msk                   (1ul << PWM_CAPENR_CINEN1_Pos)      /*!< PWM_T::CAPENR: CINEN1 Mask */
S
S#define PWM_CAPENR_CINEN0_Pos                   0                                   /*!< PWM_T::CAPENR: CINEN0 Position */
S#define PWM_CAPENR_CINEN0_Msk                   (1ul << PWM_CAPENR_CINEN0_Pos)      /*!< PWM_T::CAPENR: CINEN0 Mask */
S
S/* PWM POE Bit Field Definitions */
S#define PWM_POE_POE3_Pos                        3                                   /*!< PWM_T::POE: POE3 Position */
S#define PWM_POE_POE3_Msk                        (1ul << PWM_POE_POE3_Pos)           /*!< PWM_T::POE: POE3 Mask */
S
S#define PWM_POE_POE2_Pos                        2                                   /*!< PWM_T::POE: POE2 Position */
S#define PWM_POE_POE2_Msk                        (1ul << PWM_POE_POE2_Pos)           /*!< PWM_T::POE: POE2 Mask */
S
S#define PWM_POE_POE1_Pos                        1                                   /*!< PWM_T::POE: POE1 Position */
S#define PWM_POE_POE1_Msk                        (1ul << PWM_POE_POE1_Pos)           /*!< PWM_T::POE: POE1 Mask */
S
S#define PWM_POE_POE0_Pos                        0                                   /*!< PWM_T::POE: POE0 Position */
S#define PWM_POE_POE0_Msk                        (1ul << PWM_POE_POE0_Pos)           /*!< PWM_T::POE: POE0 Mask */
S
S/* PWM TCON Bit Field Definitions */
S
S#define PWM_TCON_PWM3TEN_Pos                    3                                   /*!< PWM_T::TCON: PWM3TEN Position */
S#define PWM_TCON_PWM3TEN_Msk                    (1ul << PWM_TCON_PWM3TEN_Pos)       /*!< PWM_T::TCON: PWM3TEN Mask */
S
S#define PWM_TCON_PWM2TEN_Pos                    2                                   /*!< PWM_T::TCON: PWM2TEN Position */
S#define PWM_TCON_PWM2TEN_Msk                    (1ul << PWM_TCON_PWM2TEN_Pos)       /*!< PWM_T::TCON: PWM2TEN Mask */
S
S#define PWM_TCON_PWM1TEN_Pos                    1                                   /*!< PWM_T::TCON: PWM1TEN Position */
S#define PWM_TCON_PWM1TEN_Msk                    (1ul << PWM_TCON_PWM1TEN_Pos)       /*!< PWM_T::TCON: PWM1TEN Mask */
S
S#define PWM_TCON_PWM0TEN_Pos                    0                                   /*!< PWM_T::TCON: PWM0TEN Position */
S#define PWM_TCON_PWM0TEN_Msk                    (1ul << PWM_TCON_PWM0TEN_Pos)       /*!< PWM_T::TCON: PWM0TEN Mask */
S
S/* PWM TSTATUS Bit Field Definitions */
S
S#define PWM_TSTATUS_PWM3TF_Pos                  3                                   /*!< PWM_T::TSTATUS: PWM3TF Position */
S#define PWM_TSTATUS_PWM3TF_Msk                  (1ul << PWM_TSTATUS_PWM3TF_Pos)     /*!< PWM_T::TSTATUS: PWM3TF Mask */
S
S#define PWM_TSTATUS_PWM2TF_Pos                  2                                   /*!< PWM_T::TSTATUS: PWM2TF Position */
S#define PWM_TSTATUS_PWM2TF_Msk                  (1ul << PWM_TSTATUS_PWM2TF_Pos)     /*!< PWM_T::TSTATUS: PWM2TF Mask */
S
S#define PWM_TSTATUS_PWM1TF_Pos                  1                                   /*!< PWM_T::TSTATUS: PWM1TF Position */
S#define PWM_TSTATUS_PWM1TF_Msk                  (1ul << PWM_TSTATUS_PWM1TF_Pos)     /*!< PWM_T::TSTATUS: PWM1TF Mask */
S
S#define PWM_TSTATUS_PWM0TF_Pos                  0                                   /*!< PWM_T::TSTATUS: PWM0TF Position */
S#define PWM_TSTATUS_PWM0TF_Msk                  (1ul << PWM_TSTATUS_PWM0TF_Pos)     /*!< PWM_T::TSTATUS: PWM0TF Mask */
S
S/* PWM SYNCBUSY0 Bit Field Definitions */
S#define PWM_SYNCBUSY0_S_BUSY_Pos                0                                   /*!< PWM_T::SYNCBUSY0: S_BUSY Position */
S#define PWM_SYNCBUSY0_S_BUSY_Msk                (1ul << PWM_SYNCBUSY0_S_BUSY_Pos)   /*!< PWM_T::SYNCBUSY0: S_BUSY Mask */
S
S/* PWM SYNCBUSY1 Bit Field Definitions */
S#define PWM_SYNCBUSY1_S_BUSY_Pos                0                                   /*!< PWM_T::SYNCBUSY1: S_BUSY Position */
S#define PWM_SYNCBUSY1_S_BUSY_Msk                (1ul << PWM_SYNCBUSY1_S_BUSY_Pos)   /*!< PWM_T::SYNCBUSY1: S_BUSY Mask */
S
S/* PWM SYNCBUSY2 Bit Field Definitions */
S#define PWM_SYNCBUSY2_S_BUSY_Pos                0                                   /*!< PWM_T::SYNCBUSY2: S_BUSY Position */
S#define PWM_SYNCBUSY2_S_BUSY_Msk                (1ul << PWM_SYNCBUSY2_S_BUSY_Pos)   /*!< PWM_T::SYNCBUSY2: S_BUSY Mask */
S
S/* PWM SYNCBUSY3 Bit Field Definitions */
S#define PWM_SYNCBUSY3_S_BUSY_Pos                0                                   /*!< PWM_T::SYNCBUSY3: S_BUSY Position */
S#define PWM_SYNCBUSY3_S_BUSY_Msk                (1ul << PWM_SYNCBUSY3_S_BUSY_Pos)   /*!< PWM_T::SYNCBUSY3: S_BUSY Mask */
S/*@}*/ /* end of group PWM_CONST */
S/*@}*/ /* end of group PWM */
S
S
S/*---------------------- Real Time Clock Controller -------------------------*/
S/**
S    @addtogroup RTC Real Time Clock Controller (RTC)
S    Memory Mapped Structure for RTC Controller
S@{ */
S
S
Stypedef struct
S{
S
S
S/**
S * @var RTC_T::INIR
S * Offset: 0x00  RTC Initiation Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |INIR0_Active|RTC Active Status (Read Only)
S * |        |          |0 = RTC is at reset state.
S * |        |          |1 = RTC is at normal active state.
S * |[31:1]  |INIR[31:1]|RTC Initiation
S * |        |          |When RTC block is powered on, RTC is at reset state.
S * |        |          |User has to write a number (0xa5eb1357) to INIR to make RTC leaving reset state.
S * |        |          |Once the INIR is written as 0xa5eb1357, the RTC will be in un-reset state permanently.
S * |        |          |The INIR is a write-only field and read value will be always 0.
S * @var RTC_T::AER
S * Offset: 0x04  RTC Access Enable Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |AER       |RTC Register Access Enable Password (Write Only)
S * |        |          |Writing 0xA965 to this register will enable RTC access and keep 1024 RTC clocks.
S * |[16]    |ENF       |RTC Register Access Enable Flag (Read Only)
S * |        |          |0 = RTC register read/write access Disabled.
S * |        |          |1 = RTC register read/write access Enabled.
S * |        |          |This bit will be set after AER[15:0] is load a 0xA965, and will be cleared automatically after
S * |        |          |1024 RTC clocks.
S * @var RTC_T::FCR
S * Offset: 0x08  RTC Frequency Compensation Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[5:0]   |FRACTION  |Fraction Part
S * |        |          |Formula = (fraction part of detected value) x 60.
S * |        |          |Note: Digit in FCR must be expressed as hexadecimal number.
S * |[11:8]  |INTEGER   |Integer Part
S * @var RTC_T::TLR
S * Offset: 0x0C  Time Loading Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |1SEC      |1-Sec Time Digit (0~9)
S * |[6:4]   |10SEC     |10-Sec Time Digit (0~5)
S * |[11:8]  |1MIN      |1-Min Time Digit (0~9)
S * |[14:12] |10MIN     |10-Min Time Digit (0~5)
S * |[19:16] |1HR       |1-Hour Time Digit (0~9)
S * |[21:20] |10HR      |10-Hour Time Digit (0~2)
S * @var RTC_T::CLR
S * Offset: 0x10  Calendar Loading Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |1DAY      |1-Day Calendar Digit (0~9)
S * |[5:4]   |10DAY     |10-Day Calendar Digit (0~3)
S * |[11:8]  |1MON      |1-Month Calendar Digit (0~9)
S * |[12]    |10MON     |10-Month Calendar Digit (0~1)
S * |[19:16] |1YEAR     |1-Year Calendar Digit (0~9)
S * |[23:20] |10YEAR    |10-Year Calendar Digit (0~9)
S * @var RTC_T::TSSR
S * Offset: 0x14  Time Scale Selection Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |24H_12H   |24-Hour / 12-Hour Time Scale Selection
S * |        |          |It indicates that RTC TLR and TAR counter are in 24-hour time scale or 12-hour time scale.
S * |        |          |0 = 24-hour time scale selected.
S * |        |          |1 = 24-hour time scale selected.
S * @var RTC_T::DWR
S * Offset: 0x18  Day of the Week Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[2:0]   |DWR       |Day Of The Week Register
S * |        |          |000 = Sunday.
S * |        |          |001 = Monday.
S * |        |          |010 = Tuesday.
S * |        |          |011 = Wednesday.
S * |        |          |100 = Thursday.
S * |        |          |101 = Friday.
S * |        |          |110 = Saturday.
S * |        |          |111 = Reserved.
S * @var RTC_T::TAR
S * Offset: 0x1C  Time Alarm Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |1SEC      |1-Sec Time Digit of Alarm Setting (0~9)
S * |[6:4]   |10SEC     |10-Sec Time Digit of Alarm Setting (0~5)
S * |[11:8]  |1MIN      |1-Min Time Digit of Alarm Setting (0~9)
S * |[14:12] |10MIN     |10-Min Time Digit of Alarm Setting (0~5)
S * |[19:16] |1HR       |1-Hour Time Digit of Alarm Setting (0~9)
S * |[21:20] |10HR      |10-Hour Time Digit of Alarm Setting (0~2)
S * @var RTC_T::CAR
S * Offset: 0x20  Calendar Alarm Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |1DAY      |1-Day Calendar Digit of Alarm Setting (0~9)
S * |[5:4]   |10DAY     |10-Day Calendar Digit of Alarm Setting (0~3)
S * |[11:8]  |1MON      |1-Month Calendar Digit of Alarm Setting (0~9)
S * |[12]    |10MON     |10-Month Calendar Digit of Alarm Setting (0~1)
S * |[19:16] |1YEAR     |1-Year Calendar Digit of Alarm Setting (0~9)
S * |[23:20] |10YEAR    |10-Year Calendar Digit of Alarm Setting (0~9)
S * @var RTC_T::LIR
S * Offset: 0x24  Leap Year Indicator Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |LIR       |Leap Year Indication Register (Read Only)
S * |        |          |0 = This year is not a leap year.
S * |        |          |1 = This year is a leap year.
S * @var RTC_T::RIER
S * Offset: 0x28  RTC Interrupt Enable Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |AIER      |Alarm Interrupt Enable
S * |        |          |This bit is used to enable/disable RTC Alarm Interrupt, and generate an interrupt signal if AIF
S * |        |          |(RIIR[0] RTC Alarm Interrupt Flag) is set to 1.
S * |        |          |0 = RTC Alarm Interrupt Disabled.
S * |        |          |1 = RTC Alarm Interrupt Enabled.
S * |        |          |Note: This bit will also trigger a wake-up event while system runs in Idle/Power-down mode and
S * |        |          |RTC Alarm Interrupt signal generated.
S * |[1]     |TIER      |Time Tick Interrupt Enable
S * |        |          |This bit is used to enable/disable RTC Time Tick Interrupt, and generate an interrupt signal if
S * |        |          |TIF (RIIR[1] RTC Time Tick Interrupt Flag) is set to 1.
S * |        |          |0 = RTC Time Tick Interrupt Disabled.
S * |        |          |1 = RTC Time Tick Interrupt Enabled.
S * |        |          |Note: This bit will also trigger a wake-up event while system runs in Idle/Power-down mode and
S * |        |          |RTC Time Tick Interrupt signal generated.
S * |[2]     |SNOOPIER  |Snoop Detection Interrupt Enable
S * |        |          |This bit is used to enable/disable RTC Snoop Detection Interrupt, and generate an interrupt
S * |        |          |signal if SNOOPIF (RIIR[2] RTC Snoop Detection Interrupt Flag) is set to 1.
S * |        |          |0 = Snoop detected interrupt Disabled.
S * |        |          |1 = Snoop detected interrupt Enabled.
S * |        |          |Note: This bit will also trigger a wake-up event while system runs in Idle/Power-down mode and
S * |        |          |RTC Snoop Interrupt signal generated.
S * @var RTC_T::RIIR
S * Offset: 0x2C  RTC Interrupt Indicator Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |AIF       |RTC Alarm Interrupt Flag
S * |        |          |When RTC time counters TLR and CLR match the alarm setting time registers TAR and CAR, this bit
S * |        |          |will be set to 1 and an interrupt will be generated if RTC Alarm Interrupt enabled AIER
S * |        |          |(RIER[0]) is set to 1.
S * |        |          |Chip will be wake-up if RTC Alarm Interrupt is enabled when chip is at Power-down mode.
S * |        |          |0 = Alarm condition is not matched.
S * |        |          |1 = Alarm condition is matched.
S * |        |          |Note: Write 1 to clear this bit.
S * |[1]     |TIF       |RTC Time Tick Interrupt Flag
S * |        |          |When RTC time tick happened, this bit will be set to 1 and an interrupt will be generated if RTC
S * |        |          |Tick Interrupt enabled TIER (RIER[1]) is set to 1.
S * |        |          |Chip will also be wake-up if RTC Tick Interrupt is enabled and this bit is set to 1 when chip is
S * |        |          |running at Power-down mode.
S * |        |          |0 = Tick condition does not occur.
S * |        |          |1 = Tick condition occur.
S * |        |          |Note: Write 1 to clear to clear this bit.
S * |[2]     |SNOOPIF   |Snoop Detection Interrupt Flag
S * |        |          |When snooper pin transition event is detected, this bit is set to 1 and an interrupt is
S * |        |          |generated if Snoop Detection Interrupt enabled SNOOPIER (RIER[2]) is set to1.
S * |        |          |Chip will be wake-up from Power-down mode if Snoop Detection Interrupt is enabled.
S * |        |          |0 = No snoop event is detected.
S * |        |          |1 = Snoop event is detected.
S * |        |          |Note: Write 1 to clear this bit.
S * @var RTC_T::TTR
S * Offset: 0x30  RTC Time Tick Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[2:0]   |TTR       |Time Tick Register
S * |        |          |These bits are used to select RTC time tick period for Periodic Time Tick Interrupt request.
S * |        |          |000 = Time tick is 1 second.
S * |        |          |001 = Time tick is 1/2 second.
S * |        |          |010 = Time tick is 1/4 second.
S * |        |          |011 = Time tick is 1/8 second.
S * |        |          |100 = Time tick is 1/16 second.
S * |        |          |101 = Time tick is 1/32 second.
S * |        |          |110 = Time tick is 1/64 second.
S * |        |          |111 = Time tick is 1/28 second.
S * |        |          |Note: This register can be read back after the RTC register access enable bit ENF (AER[16]) is
S * |        |          |active.
S * @var RTC_T::SPRCTL
S * Offset: 0x3C  RTC Spare Functional Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |SNOOPEN   |Snoop Detection Enable
S * |        |          |0 = Snoop detection function Disabled.
S * |        |          |1 = Snoop detection function Enabled.
S * |[1]     |SNOOPLEVEL|Snoop Detection Level Selection
S * |        |          |This bit controls snoop detect event is high level/rising edge or low level/falling edge.
S * |        |          |0 = Low level/Falling edge detection.
S * |        |          |1 = High level/Rising edge detection.
S * |[2]     |SPREN     |SPR Register Enable
S * |        |          |0 = Spare register is Disabled.
S * |        |          |1 = Spare register is Enabled.
S * |        |          |Note: When spare register is disabled, RTC SPR0 ~ SPR19 cannot be accessed.
S * |[3]     |SNOOPMODE |Snoop Detection Mode Selection
S * |        |          |This bit controls snoop detect event is edge or level detection.
S * |        |          |0 = Level detection.
S * |        |          |1 = Edge detection.
S * |[5]     |SPRCFLG   |Spare Register Clear Flag
S * |        |          |This bit indicates if the SPR0 ~ SPR19 content is cleared when snoop specify event is detected.
S * |        |          |0 = Spare register content is not cleared.
S * |        |          |1 = Spare register content is cleared.
S * |        |          |Note: Writes 1 to clear this bit.
S * |[7]     |SPRRDY    |SPR Register Ready
S * |        |          |This bit indicates if the registers SPRCTL, SPR0 ~ SPR19 are ready to be accessed.
S * |        |          |After user writing registers SPRCTL, SPR0 ~ SPR19, read this bit to check if these registers are
S * |        |          |updated done is necessary.
S * |        |          |0 = SPRCTL, SPR0 ~ SPR19 updating is in progress.
S * |        |          |1 = SPRCTL, SPR0 ~ SPR19 are updated done and ready to be accessed.
S * |        |          |Note: This bit is read only and any write to it won't take any effect.
S * @var RTC_T::SPR
S * Offset: 0x40  RTC Spare Register 0 ~ 19
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |SPARE     |SPARE Register
S * |        |          |This field is used to store back-up information defined by software.
S * |        |          |This field will be cleared by hardware automatically once a snooper pin event is detected.
S * |        |          |Before store back-up information in to SPARE register, software should write 0xA965 to AER to
S * |        |          |make sure register read/write enable.
S */
S
S    __IO uint32_t INIR;          /* Offset: 0x00  RTC Initiation Register                                            */
S    __IO uint32_t AER;           /* Offset: 0x04  RTC Access Enable Register                                         */
S    __IO uint32_t FCR;           /* Offset: 0x08  RTC Frequency Compensation Register                                */
S    __IO uint32_t TLR;           /* Offset: 0x0C  Time Loading Register                                              */
S    __IO uint32_t CLR;           /* Offset: 0x10  Calendar Loading Register                                          */
S    __IO uint32_t TSSR;          /* Offset: 0x14  Time Scale Selection Register                                      */
S    __IO uint32_t DWR;           /* Offset: 0x18  Day of the Week Register                                           */
S    __IO uint32_t TAR;           /* Offset: 0x1C  Time Alarm Register                                                */
S    __IO uint32_t CAR;           /* Offset: 0x20  Calendar Alarm Register                                            */
S    __I  uint32_t LIR;           /* Offset: 0x24  Leap Year Indicator Register                                       */
S    __IO uint32_t RIER;          /* Offset: 0x28  RTC Interrupt Enable Register                                      */
S    __IO uint32_t RIIR;          /* Offset: 0x2C  RTC Interrupt Indicator Register                                   */
S    __IO uint32_t TTR;           /* Offset: 0x30  RTC Time Tick Register                                             */
S    __I  uint32_t RESERVED[2];  
S    __IO uint32_t SPRCTL;        /* Offset: 0x3C  RTC Spare Functional Control Register                              */
S    __IO uint32_t SPR[20];       /* Offset: 0x40  RTC Spare Register 0 ~ 19                                          */
S
S} RTC_T;
S
S
S/**
S    @addtogroup RTC_CONST RTC Bit Field Definition
S    Constant Definitions for RTC Controller
S@{ */
S
S
S
S/* RTC INIR Bit Field Definitions */
S#define RTC_INIR_INIR_Pos       0                                               /*!< RTC_T::INIR: INIR Position */
S#define RTC_INIR_INIR_Msk       (0xFFFFFFFFul << RTC_INIR_INIR_Pos)             /*!< RTC_T::INIR: INIR Mask */
S
S#define RTC_INIR_ACTIVE_Pos     0                                               /*!< RTC_T::INIR: ACTIVE Position */
S#define RTC_INIR_ACTIVE_Msk     (1ul << RTC_INIR_ACTIVE_Pos)                    /*!< RTC_T::INIR: ACTIVE Mask */
S
S/* RTC AER Bit Field Definitions */
S#define RTC_AER_ENF_Pos         16                                              /*!< RTC_T::AER: ENF Position */
S#define RTC_AER_ENF_Msk         (1ul << RTC_AER_ENF_Pos)                        /*!< RTC_T::AER: ENF Mask */
S
S#define RTC_AER_AER_Pos         0                                               /*!< RTC_T::AER: AER Position */
S#define RTC_AER_AER_Msk         (0xFFFFul << RTC_AER_AER_Pos)                   /*!< RTC_T::AER: AER Mask */
S
S/* RTC FCR Bit Field Definitions */
S#define RTC_FCR_INTEGER_Pos     8                                               /*!< RTC_T::FCR: INTEGER Position */
S#define RTC_FCR_INTEGER_Msk     (0xFul << RTC_FCR_INTEGER_Pos)                  /*!< RTC_T::FCR: INTEGER Mask */
S
S#define RTC_FCR_FRACTION_Pos    0                                               /*!< RTC_T::FCR: FRACTION Position */
S#define RTC_FCR_FRACTION_Msk    (0x3Ful << RTC_FCR_FRACTION_Pos)                /*!< RTC_T::FCR: FRACTION Mask */
S
S/* RTC TLR Bit Field Definitions */
S#define RTC_TLR_10HR_Pos        20                                              /*!< RTC_T::TLR: 10HR Position */
S#define RTC_TLR_10HR_Msk        (0x3ul << RTC_TLR_10HR_Pos)                     /*!< RTC_T::TLR: 10HR Mask */
S
S#define RTC_TLR_1HR_Pos         16                                              /*!< RTC_T::TLR: 1HR Position */
S#define RTC_TLR_1HR_Msk         (0xFul << RTC_TLR_1HR_Pos)                      /*!< RTC_T::TLR: 1HR Mask */
S
S#define RTC_TLR_10MIN_Pos       12                                              /*!< RTC_T::TLR: 10MIN Position */
S#define RTC_TLR_10MIN_Msk       (0x7ul << RTC_TLR_10MIN_Pos)                    /*!< RTC_T::TLR: 10MIN Mask */
S
S#define RTC_TLR_1MIN_Pos        8                                               /*!< RTC_T::TLR: 1MIN Position */
S#define RTC_TLR_1MIN_Msk        (0xFul << RTC_TLR_1MIN_Pos)                     /*!< RTC_T::TLR: 1MIN Mask */
S
S#define RTC_TLR_10SEC_Pos       4                                               /*!< RTC_T::TLR: 10SEC Position */
S#define RTC_TLR_10SEC_Msk       (0x7ul << RTC_TLR_10SEC_Pos)                    /*!< RTC_T::TLR: 10SEC Mask */
S
S#define RTC_TLR_1SEC_Pos        0                                               /*!< RTC_T::TLR: 1SEC Position */
S#define RTC_TLR_1SEC_Msk        (0xFul << RTC_TLR_1SEC_Pos)                     /*!< RTC_T::TLR: 1SEC Mask */
S
S/* RTC CLR Bit Field Definitions */
S#define RTC_CLR_10YEAR_Pos      20                                              /*!< RTC_T::CLR: 10YEAR Position */
S#define RTC_CLR_10YEAR_Msk      (0xFul << RTC_CLR_10YEAR_Pos)                   /*!< RTC_T::CLR: 10YEAR Mask */
S
S#define RTC_CLR_1YEAR_Pos       16                                              /*!< RTC_T::CLR: 1YEAR Position */
S#define RTC_CLR_1YEAR_Msk       (0xFul << RTC_CLR_1YEAR_Pos)                    /*!< RTC_T::CLR: 1YEAR Mask */
S
S#define RTC_CLR_10MON_Pos       12                                              /*!< RTC_T::CLR: 10MON Position */
S#define RTC_CLR_10MON_Msk       (1ul << RTC_CLR_10MON_Pos)                      /*!< RTC_T::CLR: 10MON Mask */
S
S#define RTC_CLR_1MON_Pos        8                                               /*!< RTC_T::CLR: 1MON Position */
S#define RTC_CLR_1MON_Msk        (0xFul << RTC_CLR_1MON_Pos)                     /*!< RTC_T::CLR: 1MON Mask */
S
S#define RTC_CLR_10DAY_Pos       4                                               /*!< RTC_T::CLR: 10DAY Position */
S#define RTC_CLR_10DAY_Msk       (0x3ul << RTC_CLR_10DAY_Pos)                    /*!< RTC_T::CLR: 10DAY Mask */
S
S#define RTC_CLR_1DAY_Pos        0                                               /*!< RTC_T::CLR: 1DAY Position */
S#define RTC_CLR_1DAY_Msk        (0xFul << RTC_CLR_1DAY_Pos)                     /*!< RTC_T::CLR: 1DAY Mask */
S
S/* RTC TSSR Bit Field Definitions */
S#define RTC_TSSR_24H_12H_Pos    0                                               /*!< RTC_T::TSSR: 24H_12H Position */
S#define RTC_TSSR_24H_12H_Msk    (1ul << RTC_TSSR_24H_12H_Pos)                   /*!< RTC_T::TSSR: 24H_12H Mask */
S
S/* RTC DWR Bit Field Definitions */
S#define RTC_DWR_DWR_Pos         0                                               /*!< RTC_T::DWR: DWR Position */
S#define RTC_DWR_DWR_Msk         (0x7ul << RTC_DWR_DWR_Pos)                      /*!< RTC_T::DWR: DWR Mask */
S
S/* RTC TAR Bit Field Definitions */
S#define RTC_TAR_10HR_Pos        20                                              /*!< RTC_T::TAR: 10HR Position */
S#define RTC_TAR_10HR_Msk        (0x3ul << RTC_TAR_10HR_Pos)                     /*!< RTC_T::TAR: 10HR Mask */
S
S#define RTC_TAR_1HR_Pos         16                                              /*!< RTC_T::TAR: 1HR Position */
S#define RTC_TAR_1HR_Msk         (0xFul << RTC_TAR_1HR_Pos)                      /*!< RTC_T::TAR: 1HR Mask */
S
S#define RTC_TAR_10MIN_Pos       12                                              /*!< RTC_T::TAR: 10MIN Position */
S#define RTC_TAR_10MIN_Msk       (0x7ul << RTC_TAR_10MIN_Pos)                    /*!< RTC_T::TAR: 10MIN Mask */
S
S#define RTC_TAR_1MIN_Pos        8                                               /*!< RTC_T::TAR: 1MIN Position */
S#define RTC_TAR_1MIN_Msk        (0xFul << RTC_TAR_1MIN_Pos)                     /*!< RTC_T::TAR: 1MIN Mask */
S
S#define RTC_TAR_10SEC_Pos       4                                               /*!< RTC_T::TAR: 10SEC Position */
S#define RTC_TAR_10SEC_Msk       (0x7ul << RTC_TAR_10SEC_Pos)                    /*!< RTC_T::TAR: 10SEC Mask */
S
S#define RTC_TAR_1SEC_Pos        0                                               /*!< RTC_T::TAR: 1SEC Position */
S#define RTC_TAR_1SEC_Msk        (0xFul << RTC_TAR_1SEC_Pos)                     /*!< RTC_T::TAR: 1SEC Mask */
S
S/* RTC CAR Bit Field Definitions */
S#define RTC_CAR_10YEAR_Pos      20                                              /*!< RTC_T::CAR: 10YEAR Position */
S#define RTC_CAR_10YEAR_Msk      (0xFul << RTC_CAR_10YEAR_Pos)                   /*!< RTC_T::CAR: 10YEAR Mask */
S
S#define RTC_CAR_1YEAR_Pos       16                                              /*!< RTC_T::CAR: 1YEAR Position */
S#define RTC_CAR_1YEAR_Msk       (0xFul << RTC_CAR_1YEAR_Pos)                    /*!< RTC_T::CAR: 1YEAR Mask */
S
S#define RTC_CAR_10MON_Pos       12                                              /*!< RTC_T::CAR: 10MON Position */
S#define RTC_CAR_10MON_Msk       (1ul << RTC_CAR_10MON_Pos)                      /*!< RTC_T::CAR: 10MON Mask */
S
S#define RTC_CAR_1MON_Pos        8                                               /*!< RTC_T::CAR: 1MON Position */
S#define RTC_CAR_1MON_Msk        (0xFul << RTC_CAR_1MON_Pos)                     /*!< RTC_T::CAR: 1MON Mask */
S
S#define RTC_CAR_10DAY_Pos       4                                               /*!< RTC_T::CAR: 10DAY Position */
S#define RTC_CAR_10DAY_Msk       (0x3ul << RTC_CAR_10DAY_Pos)                    /*!< RTC_T::CAR: 10DAY Mask */
S
S#define RTC_CAR_1DAY_Pos        0                                               /*!< RTC_T::CAR: 1DAY Position */
S#define RTC_CAR_1DAY_Msk        (0xFul << RTC_CAR_1DAY_Pos)                     /*!< RTC_T::CAR: 1DAY Mask */
S
S/* RTC LIR Bit Field Definitions */
S#define RTC_LIR_LIR_Pos         0                                               /*!< RTC_T::LIR: LIR Position */
S#define RTC_LIR_LIR_Msk         (1ul << RTC_LIR_LIR_Pos)                        /*!< RTC_T::LIR: LIR Mask */
S
S/* RTC RIER Bit Field Definitions */
S#define RTC_RIER_SNOOPIER_Pos   2                                               /*!< RTC_T::RIER: SNOOPIER Position */
S#define RTC_RIER_SNOOPIER_Msk   (1ul << RTC_RIER_SNOOPIER_Pos)                  /*!< RTC_T::RIER: SNOOPIER Mask */
S
S#define RTC_RIER_TIER_Pos       1                                               /*!< RTC_T::RIER: TIER Position */
S#define RTC_RIER_TIER_Msk       (1ul << RTC_RIER_TIER_Pos)                      /*!< RTC_T::RIER: TIER Mask */
S
S#define RTC_RIER_AIER_Pos       0                                               /*!< RTC_T::RIER: AIER Position */
S#define RTC_RIER_AIER_Msk       (1ul << RTC_RIER_AIER_Pos)                      /*!< RTC_T::RIER: AIER Mask */
S
S/* RTC RIIR Bit Field Definitions */
S#define RTC_RIIR_SNOOPIF_Pos    2                                               /*!< RTC_T::RIIR: SNOOPIF Position */
S#define RTC_RIIR_SNOOPIF_Msk    (1ul << RTC_RIIR_SNOOPIF_Pos)                   /*!< RTC_T::RIIR: SNOOPIF Mask */
S
S#define RTC_RIIR_TIF_Pos        1                                               /*!< RTC_T::RIIR: TIF Position */
S#define RTC_RIIR_TIF_Msk        (1ul << RTC_RIIR_TIF_Pos)                       /*!< RTC_T::RIIR: TIF Mask */
S
S#define RTC_RIIR_AIF_Pos        0                                               /*!< RTC_T::RIIR: AIF Position */
S#define RTC_RIIR_AIF_Msk        (1ul << RTC_RIIR_AIF_Pos)                       /*!< RTC_T::RIIR: AIF Mask */
S
S/* RTC TTR Bit Field Definitions */
S#define RTC_TTR_TTR_Pos         0                                               /*!< RTC_T::TTR: TTR Position */
S#define RTC_TTR_TTR_Msk         (0x7ul << RTC_TTR_TTR_Pos)                      /*!< RTC_T::TTR: TTR Mask */
S
S/* RTC SPRCTL Bit Field Definitions */
S#define RTC_SPRCTL_SPRRDY_Pos       7                                           /*!< RTC_T::SPRCTL: SPRRDY Position */
S#define RTC_SPRCTL_SPRRDY_Msk       (1ul << RTC_SPRCTL_SPRRDY_Pos)              /*!< RTC_T::SPRCTL: SPRRDY Mask */
S
S#define RTC_SPRCTL_SPRCFLG_Pos      5                                           /*!< RTC_T::SPRCTL: SPRCFLG Position */
S#define RTC_SPRCTL_SPRCFLG_Msk      (1ul << RTC_SPRCTL_SPRCFLG_Pos)             /*!< RTC_T::SPRCTL: SPRCFLG Mask */
S
S#define RTC_SPRCTL_SNOOPMODE_Pos    3                                           /*!< RTC_T::SPRCTL: SNOOPMODE Position */
S#define RTC_SPRCTL_SNOOPMODE_Msk    (1ul << RTC_SPRCTL_SNOOPMODE_Pos)           /*!< RTC_T::SPRCTL: SNOOPMODE Mask */
S
S#define RTC_SPRCTL_SPREN_Pos        2                                           /*!< RTC_T::SPRCTL: SPREN Position */
S#define RTC_SPRCTL_SPREN_Msk        (1ul << RTC_SPRCTL_SPREN_Pos)               /*!< RTC_T::SPRCTL: SPREN Mask */
S
S#define RTC_SPRCTL_SNOOPLEVEL_Pos   1                                           /*!< RTC_T::SPRCTL: SNOOPLEVEL Position */
S#define RTC_SPRCTL_SNOOPLEVEL_Msk   (1ul << RTC_SPRCTL_SNOOPLEVEL_Pos)          /*!< RTC_T::SPRCTL: SNOOPLEVEL Mask */
S
S#define RTC_SPRCTL_SNOOPEN_Pos      0                                           /*!< RTC_T::SPRCTL: SNOOPEN Position */
S#define RTC_SPRCTL_SNOOPEN_Msk      (1ul << RTC_SPRCTL_SNOOPEN_Pos)             /*!< RTC_T::SPRCTL: SNOOPEN Mask */
S/*@}*/ /* end of group RTC_CONST */
S/*@}*/ /* end of group RTC */
S
S
S/*---------------------- Smart Card Host Interface Controller -------------------------*/
S/**
S    @addtogroup SC Smart Card Host Interface Controller (SC)
S    Memory Mapped Structure for SC Controller
S@{ */
S
S
S
Stypedef struct
S{
S
S
S    /**
S * @var SC_T::RBR
S * Offset: 0x00  SC Receiving Buffer Register.
S    * ---------------------------------------------------------------------------------------------------
S    * |Bits    |Field     |Descriptions
S    * | :----: | :----:   | :---- |
S    * |[7:0]   |RBR       |Receiving Buffer
S    * |        |          |By reading RBR, the SC will return an 8-bit received data.
S * @var SC_T::THR
S * Offset: 0x00  SC Transmit Holding Register
S     * ---------------------------------------------------------------------------------------------------
S     * |Bits    |Field     |Descriptions
S     * | :----: | :----:   | :---- |
S     * |[7:0]   |THR       |Transmit Holding Buffer
S     * |        |          |By writing data to THR, the SC will send out an 8-bit data.
S     * |        |          |Note: If SC_CEN(SC_CTL[0]) is not enabled, THR cannot be programmed.
S * @var SC_T::CTL
S * Offset: 0x04  SC Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |SC_CEN    |SC Engine Enable Control
S * |        |          |Set this bit to 1 to enable SC operation.
S * |        |          |If this bit is cleared, SC will force all transition to IDLE state.
S * |[1]     |DIS_RX    |RX Transition Disable Control
S * |        |          |0 = The receiver Enabled.
S * |        |          |1 = The receiver Disabled.
S * |        |          |Note:
S * |        |          |If AUTO_CON_EN (SC_CTL[3])is enabled, these fields must be ignored.
S * |[2]     |DIS_TX    |TX Transition Disable Control
S * |        |          |0 = The transceiver Enabled.
S * |        |          |1 = The transceiver Disabled.
S * |[3]     |AUTO_CON_EN|Auto Convention Enable Control
S * |        |          |0 = Auto-convention Disabled.
S * |        |          |1 = Auto-convention Enabled.
S * |        |          |When hardware receives TS in answer to reset state and the TS is direct convention,
S * |        |          |CON_SEL(SC_CTL[5:4]) will be set to 00 automatically, otherwise if the TS is inverse convention,
S * |        |          |and CON_SEL (SC_CTL[5:4]) will be set to 11.
S * |        |          |If software enables auto convention function, the setting step must be done before Answer to
S * |        |          |Reset state and the first data must be 0x3B or 0x3F.
S * |        |          |After hardware received first data and stored it at buffer, hardware will decided the convention
S * |        |          |and change the CON_SEL (SC_CTL[5:4]) bits automatically.
S * |        |          |If the first data is not 0x3B or 0x3F, hardware will generate an interrupt INT_ACON_ERR (if
S * |        |          |ACON_ERR IE (SC_IER[10]) = 1) to CPU.
S * |[5:4]   |CON_SEL   |Convention Selection
S * |        |          |00 = Direct convention.
S * |        |          |01 = Reserved.
S * |        |          |10 = Reserved.
S * |        |          |11 = Inverse convention.
S * |        |          |Note:
S * |        |          |If AUTO_CON_EN(SC_CTL[3]) enabled, this fields are ignored.
S * |[7:6]   |RX_FTRI_LEV|Rx Buffer Trigger Level
S * |        |          |When the number of bytes in the receiving buffer equals the RX_FTRI_LEV, the RDA_IF will be set
S * |        |          |(if IER [RDA_IEN] is enabled, an interrupt will be generated).
S * |        |          |00 = INTR_RDA Trigger Level with 01 Bytes.
S * |        |          |01 = INTR_RDA Trigger Level with 02 Bytes.
S * |        |          |10 = INTR_RDA Trigger Level with 03 Bytes.
S * |        |          |11 = Reserved.
S * |[12:8]  |BGT       |Block Guard Time (BGT)
S * |        |          |Block guard time means the minimum bit length between the leading edges of two consecutive
S * |        |          |characters between different transfer directions.
S * |        |          |This field indicates the counter for the bit length of block guard time.
S * |        |          |According to ISO7816-3, in T = 0 mode, software must fill 15 (real block guard time = 16.5) to
S * |        |          |this field; in T = 1 mode, software must fill 21 (real block guard time = 22.5) to it.
S * |        |          |Note:
S * |        |          |The real block guard time is BGT + 1.
S * |[14:13] |TMR_SEL   |Timer Selection
S * |        |          |00 = All internal timer function Disabled.
S * |        |          |01 = Internal 24 bit timer Enabled.
S * |        |          |Software can configure it by setting SC_TMR0 [23:0].
S * |        |          |SC_TMR1 and SC_TMR2 will be ignored in this mode.
S * |        |          |10 = internal 24 bit timer and 8 bit internal timer Enabled.
S * |        |          |Software can configure the 24 bit timer by setting SC_TMR0 [23:0] and configure the 8 bit timer
S * |        |          |by setting SC_TMR1[7:0].
S * |        |          |SC_TMR2 will be ignored in this mode.
S * |        |          |11 = Internal 24 bit timer and two 8 bit timers Enabled.
S * |        |          |Software can configure them by setting SC_TMR0 [23:0], SC_TMR1 [7:0] and SC_TMR2 [7:0].
S * |[15]    |SLEN      |Stop Bit Length
S * |        |          |This field indicates the length of stop bit.
S * |        |          |0 = The stop bit length is 2 ETU.
S * |        |          |1= The stop bit length is 1 ETU.
S * |        |          |Note:
S * |        |          |The default stop bit length is 2. SMC and UART adopts SLEN to program the stop bit length
S * |[18:16] |RX_ERETRY |RX Error Retry Count Number
S * |        |          |This field indicates the maximum number of receiver retries that are allowed when parity error
S * |        |          |has occurred
S * |        |          |Note1: The real retry number is RX_ERETRY + 1, so 8 is the maximum retry number.
S * |        |          |Note2: This field cannot be changed when RX_ERETRY_EN enabled.
S * |        |          |The change flow is to disable RX_ETRTRY_EN first and then fill in new retry value.
S * |[19]    |RX_ERETRY_EN|RX Error Retry Enable Control
S * |        |          |This bit enables receiver retry function when parity error has occurred.
S * |        |          |0 = RX error retry function Disabled.
S * |        |          |1 = RX error retry function Enabled.
S * |        |          |Note: Software must fill in the RX_ERETRY value before enabling this bit.
S * |[22:20] |TX_ERETRY |TX Error Retry Count Number
S * |        |          |This field indicates the maximum number of transmitter retries that are allowed when parity
S * |        |          |error has occurred.
S * |        |          |Note1: The real retry number is TX_ERETRY + 1, so 8 is the maximum retry number.
S * |        |          |Note2: This field cannot be changed when TX_ERETRY_EN enabled.
S * |        |          |The change flow is to disable TX_ETRTRY_EN first and then fill in new retry value.
S * |[23]    |TX_ERETRY_EN|TX Error Retry Enable Control
S * |        |          |This bit enables transmitter retry function when parity error has occurred.
S * |        |          |0 = TX error retry function Disabled.
S * |        |          |1 = TX error retry function Enabled.
S * |[25:24] |CD_DEB_SEL|Card Detect De-Bounce Selection
S * |        |          |This field indicates the card detect de-bounce selection.
S * |        |          |00 = De-bounce sample card insert once per 384 (128 * 3) engine clocks and de-bounce sample card
S * |        |          |removal once per 128 engine clocks.
S * |        |          |01 = De-bounce sample card insert once per 192 (64 * 3) engine clocks and de-bounce sample card
S * |        |          |removal once per 64 engine clocks.
S * |        |          |10 = De-bounce sample card insert once per 96 (32 * 3) engine clocks and de-bounce sample card
S * |        |          |removal once per 32 engine clocks.
S * |        |          |11 = De-bounce sample card insert once per 48 (16 * 3) engine clocks and de-bounce sample card
S * |        |          |removal once per 16 engine clocks.
S * |[30]    |SYNC      |SYNC Flag Indicator
S * |        |          |Due to synchronization, software should check this bit before writing a new value to RX_ERETRY
S * |        |          |and TX_ERETRY.
S * |        |          |0 = synchronizing is completion, user can write new data to RX_ERETRY and TX_ERETRY.
S * |        |          |1 = Last value is synchronizing.
S * |        |          |Note: This bit is read only.
S * @var SC_T::ALTCTL
S * Offset: 0x08  SC Alternate Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |TX_RST    |TX Software Reset
S * |        |          |When TX_RST is set, all the bytes in the transmit buffer and TX internal state machine will be
S * |        |          |cleared.
S * |        |          |0 = No effect.
S * |        |          |1 = Reset the TX internal state machine and pointers.
S * |        |          |Note:
S * |        |          |This bit will be auto cleared after reset is complete.
S * |[1]     |RX_RST    |Rx Software Reset
S * |        |          |When RX_RST is set, all the bytes in the receiver buffer and Rx internal state machine will be
S * |        |          |cleared.
S * |        |          |0 = No effect.
S * |        |          |1 = Reset the Rx internal state machine and pointers.
S * |        |          |Note:
S * |        |          |This bit will be auto cleared after reset is complete.
S * |[2]     |DACT_EN   |Deactivation Sequence Generator Enable Control
S * |        |          |This bit enables SC controller to initiate the card by deactivation sequence
S * |        |          |0 = No effect.
S * |        |          |1 = Deactivation sequence generator Enabled.
S * |        |          |Note1:
S * |        |          |When the deactivation sequence completed, this bit will be cleared automatically and the
S * |        |          |INIT_IS(SC_ISR[8]) will be set to 1.
S * |        |          |Note2:
S * |        |          |This field will be cleared by TX_RST (SC_ALTCTL[0]) and RX_RST(SC_ALTCTL[1]).
S * |        |          |So don't fill this bit, TX_RST, and RX_RST at the same time.
S * |        |          |Note3:
S * |        |          |If SC_CEN (SC_CTL[0]) is not enabled, this filed cannot be programmed.
S * |[3]     |ACT_EN    |Activation Sequence Generator Enable Control
S * |        |          |This bit enables SC controller to initiate the card by activation sequence
S * |        |          |0 = No effect.
S * |        |          |1 = Activation sequence generator Enabled.
S * |        |          |Note1:
S * |        |          |When the activation sequence completed, this bit will be cleared automatically and the
S * |        |          |INIT_IS(SC_ISR[8]) will be set to 1.
S * |        |          |Note2:
S * |        |          |This field will be cleared by TX_RST(SC_ALTCTL[0]) and RX_RST(SC_ALTCTL[1]), so don't fill this
S * |        |          |bit, TX_RST(SC_ALTCTL[0]), and RX_RST(SC_ALTCTL[1]) at the same time.
S * |        |          |Note3:
S * |        |          |If SC_CEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.
S * |[4]     |WARST_EN  |Warm Reset Sequence Generator Enable Control
S * |        |          |This bit enables SC controller to initiate the card by warm reset sequence
S * |        |          |0 = No effect.
S * |        |          |1 = Warm reset sequence generator Enabled.
S * |        |          |Note1:
S * |        |          |When the warm reset sequence completed, this bit will be cleared automatically and the
S * |        |          |INIT_IS(SC_ISR[8]) will be set to 1.
S * |        |          |Note2:
S * |        |          |This field will be cleared by TX_RST(SC_ALTCTL[0]) and RX_RST(SC_ALTCTL[1]), so don't fill this
S * |        |          |bit, TX_RST, and RX_RST at the same time.
S * |        |          |Note3:
S * |        |          |If SC_CEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.
S * |[5]     |TMR0_SEN  |Internal Timer0 Start Enable Control
S * |        |          |This bit enables Timer 0 to start counting.
S * |        |          |Software can fill 0 to stop it and set 1 to reload and count.
S * |        |          |0 = Stops counting.
S * |        |          |1 = Start counting.
S * |        |          |Note1:
S * |        |          |This field is used for internal 24 bit timer when TMR_SEL (SC_CTL[14:13]) = 01.
S * |        |          |Note2:
S * |        |          |If the operation mode is not in auto-reload mode (SC_TMR0[26] = 0), this bit will be
S * |        |          |auto-cleared by hardware.
S * |        |          |Note3:
S * |        |          |This field will be cleared by TX_RST(SC_ALTCTL[0]) and RX_RST(SC_ALTCTL[1]).
S * |        |          |So don't fill this bit, TX_RST and RX_RST at the same time.
S * |        |          |Note4: If SC_CEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.
S * |[6]     |TMR1_SEN  |Internal Timer1 Start Enable Control
S * |        |          |This bit enables Timer 1 to start counting.
S * |        |          |Software can fill 0 to stop it and set 1 to reload and count.
S * |        |          |0 = Stops counting.
S * |        |          |1 = Start counting.
S * |        |          |Note1:
S * |        |          |This field is used for internal 8 bit timer when TMR_SEL(SC_CTL[14:13]) = 10 or
S * |        |          |TMR_SEL(SC_CTL[14:13]) = 11.
S * |        |          |Don't filled TMR1_SEN when TMR_SEL(SC_CTL[14:13]) = 00 or TMR_SEL(SC_CTL[14:13]) = 01.
S * |        |          |Note2:
S * |        |          |If the operation mode is not in auto-reload mode (SC_TMR1[26] = 0), this bit will be
S * |        |          |auto-cleared by hardware.
S * |        |          |Note3:
S * |        |          |This field will be cleared by TX_RST(SC_ALTCTL[0]) and RX_RST(SC_ALTCTL[1]), so don't fill this
S * |        |          |bit, TX_RST(SC_ALTCTL[0]), and RX_RST(SC_ALTCTL[1]) at the same time.
S * |        |          |Note4:
S * |        |          |If SC_CEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.
S * |[7]     |TMR2_SEN  |Internal Timer2 Start Enable Control
S * |        |          |This bit enables Timer 2 to start counting.
S * |        |          |Software can fill 0 to stop it and set 1 to reload and count.
S * |        |          |0 = Stops counting.
S * |        |          |1 = Start counting.
S * |        |          |Note1:
S * |        |          |This field is used for internal 8 bit timer when TMR_SEL(SC_CTL[14:13]) = 11.
S * |        |          |Don't filled TMR2_SEN when TMR_SEL(SC_CTL[14:13]) = 00 or TMR_SEL(SC_CTL[14:13]) = 01 or
S * |        |          |TMR_SEL(SC_CTL[14:13]) = 10.
S * |        |          |Note2:
S * |        |          |If the operation mode is not in auto-reload mode (SC_TMR2[26] = 0), this bit will be
S * |        |          |auto-cleared by hardware.
S * |        |          |Note3:
S * |        |          |This field will be cleared by TX_RST(SC_ALTCTL[0]) and RX_RST(SC_ALTCTL[1]).
S * |        |          |So don't fill this bit, TX_RST(SC_ALTCTL[0]), and RX_RST(SC_ALTCTL[1]) at the same time.
S * |        |          |Note4:
S * |        |          |If SC_CEN(SC_CTL[0]) is not enabled, this filed cannot be programmed.
S * |[9:8]   |INIT_SEL  |Initial Timing Selection
S * |        |          |This fields indicates the timing of hardware initial state (activation or warm-reset or
S * |        |          |deactivation).
S * |        |          |Unit: SC clock
S * |        |          |Activation: refer to SC Activation Sequence in Figure 5-100.
S * |        |          |Warm-reset: refer to Warm-Reset Sequence in Figure 5-101.
S * |        |          |Deactivation: refer to Deactivation Sequence in Figure 5-102.
S * |[12]    |RX_BGT_EN |Receiver Block Guard Time Function Enable Control
S * |        |          |0 = Receiver block guard time function Disabled.
S * |        |          |1 = Receiver block guard time function Enabled.
S * |[13]    |TMR0_ATV  |Internal Timer0 Active State (Read Only)
S * |        |          |This bit indicates the timer counter status of timer0.
S * |        |          |0 = Timer0 is not active.
S * |        |          |1 = Timer0 is active.
S * |[14]    |TMR1_ATV  |Internal Timer1 Active State (Read Only)
S * |        |          |This bit indicates the timer counter status of timer1.
S * |        |          |0 = Timer1 is not active.
S * |        |          |1 = Timer1 is active.
S * |[15]    |TMR2_ATV  |Internal Timer2 Active State (Read Only)
S * |        |          |This bit indicates the timer counter status of timer2.
S * |        |          |0 = Timer2 is not active.
S * |        |          |1 = Timer2 is active.
S * |[16]    |OUTSEL    |Smartcard Data Pin Output Mode Selection
S * |        |          |Use this bit to select smartcard data pin (SC_DATA) output mode
S * |        |          |0 = Quasi mode.
S * |        |          |1 = Open-drain mode.
S * @var SC_T::EGTR
S * Offset: 0x0C  SC Extend Guard Time Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |EGT       |Extended Guard Time
S * |        |          |This field indicates the extended guard timer value.
S * |        |          |Note:
S * |        |          |The counter is ETU base and the real extended guard time is EGT.
S * @var SC_T::RFTMR
S * Offset: 0x10  SC Receive buffer Time-out Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[8:0]   |RFTM      |SC Receiver Buffer Time-Out (ETU Base)
S * |        |          |The time-out counter resets and starts counting whenever the RX buffer received a new data word.
S * |        |          |Once the counter decrease to 1 and no new data is received or CPU does not read data by reading
S * |        |          |SC_RBR buffer, a receiver time-out interrupt INT_RTMR will be generated(if RTMR_IE(SC_IER[9]) = 1).
S * |        |          |Note1: The counter unit is ETU based and the interval of time-out is RFTM + 0.5
S * |        |          |Note2: Fill all 0 to this field indicates to disable this function.
S * @var SC_T::ETUCR
S * Offset: 0x14  SC ETU Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[11:0]  |ETU_RDIV  |ETU Rate Divider
S * |        |          |The field indicates the clock rate divider.
S * |        |          |The real ETU is ETU_RDIV + 1.
S * |        |          |Note:
S * |        |          |Software can configure this field, but this field must be greater than 0x004.
S * |[15]    |COMPEN_EN |Compensation Mode Enable Control
S * |        |          |This bit enables clock compensation function.
S * |        |          |When this bit enabled, hardware will alternate between n clock cycles and n-1 clock cycles,
S * |        |          |where n is the value to be written into the ETU_RDIV .
S * |        |          |0 = Compensation function Disabled.
S * |        |          |1 = Compensation function Enabled.
S * @var SC_T::IER
S * Offset: 0x18  SC Interrupt Enable Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |RDA_IE    |Receive Data Reach Interrupt Enable Control
S * |        |          |This field is used for received data reaching trigger level RX_FTRI_LEV (SC_CTL[7:6]) interrupt
S * |        |          |enable.
S * |        |          |0 = Receive data reach trigger level interrupt Disabled.
S * |        |          |1 = Receive data reach trigger level interrupt Enabled.
S * |[1]     |TXBE_IE   |Transmit Buffer Empty Interrupt Enable Control
S * |        |          |This field is used for transmit buffer empty interrupt enable.
S * |        |          |0 = Transmit buffer empty interrupt Disabled.
S * |        |          |1 = Transmit buffer empty interrupt Enabled.
S * |[2]     |TERR_IE   |Transfer Error Interrupt Enable Control
S * |        |          |This field is used for transfer error interrupt enable.
S * |        |          |The transfer error states is at SC_SR register which includes receiver break error
S * |        |          |RX_EBR_F(SC_SR[6]), frame error RX_EFR_F(SC_SR[5]), parity error RX_EPA_F(SC_SR[4]), receiver
S * |        |          |buffer overflow error RX_OVER_F(SC_SR[0]), transmit buffer overflow error TX_OVER_F(SC_SR[8]),
S * |        |          |receiver retry over limit error RX_OVER_REERR(SC_SR[22]) and transmitter retry over limit error
S * |        |          |TX_OVER_REERR(SC_SR[30]).
S * |        |          |0 = Transfer error interrupt Disabled.
S * |        |          |1 = Transfer error interrupt Enabled.
S * |[3]     |TMR0_IE   |Timer0 Interrupt Enable Control
S * |        |          |This field is used to enable TMR0 interrupt enable.
S * |        |          |0 = Timer0 interrupt Disabled.
S * |        |          |1 = Timer0 interrupt Enabled.
S * |[4]     |TMR1_IE   |Timer1 Interrupt Enable Control
S * |        |          |This field is used to enable the TMR1 interrupt.
S * |        |          |0 = Timer1 interrupt Disabled.
S * |        |          |1 = Timer1 interrupt Enabled.
S * |[5]     |TMR2_IE   |Timer2 Interrupt Enable Control
S * |        |          |This field is used for TMR2 interrupt enable.
S * |        |          |0 = Timer2 interrupt Disabled.
S * |        |          |1 = Timer2 interrupt Enabled.
S * |[6]     |BGT_IE    |Block Guard Time Interrupt Enable Control
S * |        |          |This field is used for block guard time interrupt enable.
S * |        |          |0 = Block guard time Disabled.
S * |        |          |1 = Block guard time Enabled.
S * |[7]     |CD_IE     |Card Detect Interrupt Enable Control
S * |        |          |This field is used for card detect interrupt enable. The card detect status is
S * |        |          |CD_INS_F(SC_SR[12])
S * |        |          |0 = Card detect interrupt Disabled.
S * |        |          |1 = Card detect interrupt Enabled.
S * |[8]     |INIT_IE   |Initial End Interrupt Enable Control
S * |        |          |This field is used for activation (ACT_EN(SC_ALTCTL[3] = 1)), deactivation ((DACT_EN
S * |        |          |SC_ALTCTL[2]) = 1) and warm reset (WARST_EN (SC_ALTCTL [4])) sequence interrupt enable.
S * |        |          |0 = Initial end interrupt Disabled.
S * |        |          |1 = Initial end interrupt Enabled.
S * |[9]     |RTMR_IE   |Receiver Buffer Time-Out Interrupt Enable Control
S * |        |          |This field is used for receiver buffer time-out interrupt enable.
S * |        |          |0 = Receiver buffer time-out interrupt Disabled.
S * |        |          |1 = Receiver buffer time-out interrupt Enabled.
S * |[10]    |ACON_ERR_IE|Auto Convention Error Interrupt Enable Control
S * |        |          |This field is used for auto-convention error interrupt enable.
S * |        |          |0 = Auto-convention error interrupt Disabled.
S * |        |          |1 = Auto-convention error interrupt Enabled.
S * @var SC_T::ISR
S * Offset: 0x1C  SC Interrupt Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |RDA_IS    |Receive Data Reach Interrupt Status Flag (Read Only)
S * |        |          |This field is used for received data reaching trigger level RX_FTRI_LEV (SC_CTL[7:6]) interrupt
S * |        |          |status flag.
S * |        |          |Note: This field is the status flag of received data reaching RX_FTRI_LEV (SC_CTL[7:6]).
S * |        |          |If software reads data from SC_RBR and receiver buffer data byte number is less than RX_FTRI_LEV
S * |        |          |(SC_CTL[7:6]), this bit will be cleared automatically.
S * |[1]     |TBE_IS    |Transmit Buffer Empty Interrupt Status Flag (Read Only)
S * |        |          |This field is used for transmit buffer empty interrupt status flag.
S * |        |          |Note: This field is the status flag of transmit buffer empty state.
S * |        |          |If software wants to clear this bit, software must write data to THR(SC_THR[7:0]) buffer and
S * |        |          |then this bit will be cleared automatically.
S * |[2]     |TERR_IS   |Transfer Error Interrupt Status Flag (Read Only)
S * |        |          |This field is used for transfer error interrupt status flag.
S * |        |          |The transfer error states is at SC_SR register which includes receiver break error
S * |        |          |RX_EBR_F(SC_SR[6]), 
S * |        |          |frame error RX_EFR_F(SC_TRSR[5]), parity error RX_EPA_F(SC_TRSR[4]) and receiver buffer overflow
S * |        |          |error RX_OVER_F(SC_TRSR[0]), 
S * |        |          |transmit buffer overflow error TX_OVER_F(SC_TRSR[8]), receiver retry over limit error
S * |        |          |RX_OVER_REERR(SC_TRSR[22]) and transmitter retry over limit error TX_OVER_REERR(SC_TRSR[30]).
S * |        |          |Note: This field is the status flag of
S * |        |          |RX_EBR_F(SC_TRSR[6]), RX_EFR_F(SC_TRSR[5]), RX_EPA_F(SC_TRSR[4]), RX_OVER_F(SC_TRSR[0]),
S * |        |          |TX_OVER_F(SC_TRSR[8]), RX_OVER_REERR(SC_TRSR[22]) or TX_OVER_REERR(SC_TRSR[30]).
S * |        |          |So, if software wants to clear this bit, software must write 1 to each field.
S * |[3]     |TMR0_IS   |Timer0 Interrupt Status Flag (Read Only)
S * |        |          |This field is used for TMR0 interrupt status flag.
S * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
S * |[4]     |TMR1_IS   |Timer1 Interrupt Status Flag (Read Only)
S * |        |          |This field is used for TMR1 interrupt status flag.
S * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
S * |[5]     |TMR2_IS   |Timer2 Interrupt Status Flag (Read Only)
S * |        |          |This field is used for TMR2 interrupt status flag.
S * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
S * |[6]     |BGT_IS    |Block   Guard Time Interrupt Status Flag (Read Only)
S * |        |          |This field   is used for block guard time interrupt status flag.
S * |        |          |Note1: This bit is valid when RX_BGT_EN   (SC_ALTCTL[12]) is enabled.
S * |        |          |Note2: This bit is read only, but it can be cleared by   writing "1" to it.
S * |[7]     |CD_IS     |Card Detect Interrupt Status Flag (Read Only)
S * |        |          |This field is used for card detect interrupt status flag.
S * |        |          |The card detect status is CD_INS_F (SC_SR[12]) and CD_REM_F(SC_SR[11]).
S * |        |          |Note:
S * |        |          |This field is the status flag of CD_INS_F(SC_SR[12]) or CD_REM_F(SC_TRSR[11])].
S * |        |          |So if software wants to clear this bit, software must write 1 to this field.
S * |[8]     |INIT_IS   |Initial End Interrupt Status Flag (Read Only)
S * |        |          |This field is used for activation (ACT_EN(SC_ALTCTL[3])), deactivation (DACT_EN (SC_ALTCTL[2]))
S * |        |          |and warm reset (WARST_EN (SC_ALTCTL[4])) sequence interrupt status flag.
S * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
S * |[9]     |RTMR_IS   |Receiver Buffer Time-Out Interrupt Status Flag (Read Only)
S * |        |          |This field is used for receiver buffer time-out interrupt status flag.
S * |        |          |Note: This field is the status flag of receiver buffer time-out state.
S * |        |          |If software wants to clear this bit, software must read all receiver buffer remaining data by
S * |        |          |reading SC_RBR buffer,.
S * |[10]    |ACON_ERR_IS|Auto Convention Error Interrupt Status Flag (Read Only)
S * |        |          |This field indicates auto convention sequence error.
S * |        |          |If the received TS at ATR state is neither 0x3B nor 0x3F, this bit will be set.
S * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
S * @var SC_T::TRSR
S * Offset: 0x20  SC Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |RX_OVER_F |RX Overflow Error Status Flag (Read Only)
S * |        |          |This bit is set when RX buffer overflow.
S * |        |          |If the number of received bytes is greater than Rx Buffer size (4 bytes), this bit will be set.
S * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
S * |[1]     |RX_EMPTY_F|Receiver Buffer Empty Status Flag(Read Only)
S * |        |          |This bit indicates RX buffer empty or not.
S * |        |          |When the last byte of Rx buffer has been read by CPU, hardware sets this bit high.
S * |        |          |It will be cleared when SC receives any new data.
S * |[2]     |RX_FULL_F |Receiver Buffer Full Status Flag (Read Only)
S * |        |          |This bit indicates RX buffer full or not.
S * |        |          |This bit is set when RX pointer is equal to 4, otherwise it is cleared by hardware.
S * |[4]     |RX_EPA_F  |Receiver Parity Error Status Flag (Read Only)
S * |        |          |This bit is set to logic 1 whenever the received character does not have a valid
S * |        |          |"parity bit".
S * |        |          |Note1:
S * |        |          |This bit is read only, but it can be cleared by writing 1 to it.
S * |        |          |Note2:
S * |        |          |If CPU sets receiver retries function by setting RX_ERETRY_EN(SC_CTL[19]) , hardware will not
S * |        |          |set this flag.
S * |[5]     |RX_EFR_F  |Receiver Frame Error Status Flag (Read Only)
S * |        |          |This bit is set to logic 1 whenever the received character does not have a valid "stop bit"
S * |        |          |(that is, the stop bit following the last data bit or parity bit is detected as logic 0).
S * |        |          |Note1:
S * |        |          |This bit is read only, but it can be cleared by writing 1 to it.
S * |        |          |Note2:
S * |        |          |If CPU sets receiver retries function by setting RX_ERETRY_EN(SC_CTL[19]) , hardware will not
S * |        |          |set this flag.
S * |[6]     |RX_EBR_F  |Receiver Break Error Status Flag (Read Only)
S * |        |          |This bit is set to logic 1 whenever the received data input (RX) held in the "spacing state"
S * |        |          |(logic 0) is longer than a full word transmission time (that is, the total time of "start bit" +
S * |        |          |data bits + parity + stop bits).
S * |        |          |Note1:
S * |        |          |This bit is read only, but it can be cleared by writing 1 to it.
S * |        |          |Note2:
S * |        |          |If CPU sets receiver retries function by setting RX_ERETRY_EN(SC_CTL[19]) , hardware will not
S * |        |          |set this flag.
S * |[8]     |TX_OVER_F |TX Overflow Error Interrupt Status Flag (Read Only)
S * |        |          |If TX buffer is full, an additional write to THR(SC_THR[7:0]) will cause this bit be set to "1"
S * |        |          |by hardware.
S * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
S * |[9]     |TX_EMPTY_F|Transmit Buffer Empty Status Flag (Read Only)
S * |        |          |This bit indicates TX buffer empty or not.
S * |        |          |When the last byte of TX buffer has been transferred to Transmitter Shift Register, hardware
S * |        |          |sets this bit high.
S * |        |          |It will be cleared when writing data into THR(SC_THR[7:0]) (TX buffer not empty).
S * |[10]    |TX_FULL_F |Transmit Buffer Full Status Flag (Read Only)
S * |        |          |This bit indicates TX buffer full or not.This bit is set when TX pointer is equal to 4,
S * |        |          |otherwise is cleared by hardware.
S * |[17:16] |RX_POINT_F|Receiver Buffer Pointer Status Flag (Read Only)
S * |        |          |This field indicates the RX buffer pointer status flag.
S * |        |          |When SC receives one byte from external device, RX_POINT_F(SC_SR[17:16]) increases one.
S * |        |          |When one byte of RX buffer is read by CPU, RX_POINT_F(SC_SR[17:16]) decreases one.
S * |[21]    |RX_REERR  |Receiver Retry Error (Read Only)
S * |        |          |This bit is set by hardware when RX has any error and retries transfer.
S * |        |          |Note1: This bit is read only, but it can be cleared by writing 1 to it.
S * |        |          |Note2 This bit is a flag and cannot generate any interrupt to CPU.
S * |        |          |Note3: If CPU enables receiver retry function by setting RX_ERETRY_EN
S * |        |          |(SC_CTL[19]) , the RX_EPA_F(SC_TRSR[4]) flag will be ignored (hardware will not set
S * |        |          |RX_EPA_F(SC_TRSR[4])).
S * |[22]    |RX_OVER_REERR|Receiver Over Retry Error (Read Only)
S * |        |          |This bit is set by hardware when RX transfer error retry over retry number limit.
S * |        |          |Note1: This bit is read only, but it can be cleared by writing 1 to it.
S * |        |          |Note2: If CPU enables receiver retries function by setting RX_ERETRY_EN
S * |        |          |(SC_CTL[19]), the RX_EPA_F(SC_TRSR[4]) flag will be ignored (hardware will not set
S * |        |          |RX_EPA_F(SC_TRSR[4])).
S * |[23]    |RX_ATV    |Receiver In Active Status Flag (Read Only)
S * |        |          |This bit is set by hardware when RX transfer is in active.
S * |        |          |This bit is cleared automatically when RX transfer is finished.
S * |[25:24] |TX_POINT_F|Transmit Buffer Pointer Status Flag (Read Only)
S * |        |          |This field indicates the TX buffer pointer status flag.
S * |        |          |When CPU writes data into SC_THR, TX_POINT_F increases one.
S * |        |          |When one byte of TX Buffer is transferred to transmitter shift register, TX_POINT_F decreases
S * |        |          |one.
S * |[29]    |TX_REERR  |Transmitter Retry Error (Read Only)
S * |        |          |This bit is set by hardware when transmitter re-transmits.
S * |        |          |Note1: This bit is read only, but it can be cleared by writing 1 to it.
S * |        |          |Note2 This bit is a flag and cannot generate any interrupt to CPU.
S * |[30]    |TX_OVER_REERR|Transmitter Over Retry Error (Read Only)
S * |        |          |This bit is set by hardware when transmitter re-transmits over retry number limitation.
S * |        |          |Note: This bit is read only, but it can be cleared by writing 1 to it.
S * |[31]    |TX_ATV    |Transmit In Active Status Flag (Read Only)
S * |        |          |0 = This bit is cleared automatically when TX transfer is finished or the last byte transmission
S * |        |          |has completed.
S * |        |          |1 = This bit is set by hardware when TX transfer is in active and the STOP bit of the last byte
S * |        |          |has been transmitted.
S * @var SC_T::PINCSR
S * Offset: 0x24  SC Pin Control State Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |POW_EN    |SC_POW_EN Pin Signal
S * |        |          |Software can set POW_EN (SC_PINCSR[0]) and POW_INV (SC_PINCSR[11])to decide SC_PWR pin is in
S * |        |          |high or low level.
S * |        |          |Write this field to drive SC_PWR pin
S * |        |          |Refer POW_INV (SC_PINCSR[11]) description for programming SC_PWR pin voltage level.
S * |        |          |Read this field to get SC_PWR pin status.
S * |        |          |0 = SC_PWR pin status is low.
S * |        |          |1 = SC_PWR pin status is high.
S * |        |          |Note: When operating at activation, warm reset or deactivation mode, this bit will be changed
S * |        |          |automatically.
S * |        |          |So don't fill this field when operating in these modes.
S * |[1]     |SC_RST    |SC_RST Pin Signal
S * |        |          |This bit is the pin status of SC_RST but user can drive SC_RST pin to high or low by setting
S * |        |          |this bit.
S * |        |          |Write this field to drive SC_RST pin.
S * |        |          |0 = Drive SC_RST pin to low.
S * |        |          |1 = Drive SC_RST pin to high.
S * |        |          |Read this field to get SC_RST pin status.
S * |        |          |0 = SC_RST pin status is low.
S * |        |          |1 = SC_RST pin status is high.
S * |        |          |Note: When operating at activation, warm reset or deactivation mode, this bit will be changed
S * |        |          |automatically.
S * |        |          |So don't fill this field when operating in these modes.
S * |[2]     |CD_REM_F  |Card Detect Removal Status Of SC_CD Pin (Read Only)
S * |        |          |This bit is set whenever a card has been removed.
S * |        |          |0 = No effect.
S * |        |          |1 = Card removed.
S * |        |          |Note1: This bit is read only, but it can be cleared by writing "1" to it.
S * |        |          |Note2: Card detect engine will start after SC_CEN (SC_CTL[0] )set.
S * |[3]     |CD_INS_F  |Card Detect Insert Status Of SC_CD Pin (Read Only)
S * |        |          |This bit is set whenever card has been inserted.
S * |        |          |0 = No effect.
S * |        |          |1 = Card insert.
S * |        |          |Note1: This bit is read only, but it can be cleared by writing "1" to it.
S * |        |          |Note2: The
S * |        |          |card detect engine will start after SC_CEN (SC_CTL[0] )set.
S * |[4]     |CD_PIN_ST |Card Detect Status Of SC_CD Pin Status (Read Only)
S * |        |          |This bit is the pin status flag of SC_CD
S * |        |          |0 = The SC_CD pin state at low.
S * |        |          |1 = The SC_CD pin state at high.
S * |[6]     |CLK_KEEP  |SC Clock Enable Control
S * |        |          |0 = SC clock generation Disabled.
S * |        |          |1 = SC clock always keeps free running.
S * |        |          |Note: When operating in activation, warm reset or deactivation mode, this bit will be changed
S * |        |          |automatically.
S * |        |          |So don't fill this field when operating in these modes.
S * |[7]     |ADAC_CD_EN|Auto Deactivation When Card Removal
S * |        |          |0 = Auto deactivation Disabled when hardware detected the card removal.
S * |        |          |1 = Auto deactivation Enabled when hardware detected the card removal.
S * |        |          |Note: When the card is removed, hardware will stop any process and then do deactivation sequence
S * |        |          |(if this bit be setting).
S * |        |          |If this process completes.
S * |        |          |Hardware will generate an initial end.
S * |        |          |interrupt to CPU.
S * |[8]     |SC_OEN_ST |SC Data Output Enable Pin Status (Read Only)
S * |        |          |This bit is the pin status of SC_DATA_OEN
S * |        |          |0 = The SC_DATA_OEN pin state at low.
S * |        |          |1 = The SC_DATA_OEN pin state at high.
S * |[9]     |SC_DATA_O |SC Data Output Pin
S * |        |          |This bit is the pin status of SC_DATA_O but user can drive SC_DATA_O pin to high or low by
S * |        |          |setting this bit.
S * |        |          |0 = Drive SC_DATA_O pin to low.
S * |        |          |1 = Drive SC_DATA_O pin to high.
S * |        |          |Note: When SC is at activation, warm reset or deactivation mode, this bit will be changed
S * |        |          |automatically.
S * |        |          |So don't fill this field when SC is in these modes.
S * |[10]    |CD_LEV    |Card Detect Level
S * |        |          |0 = When hardware detects the card detect pin from high to low, it indicates a card is detected.
S * |        |          |1 = When hardware detects the card detect pin from low to high, it indicates a card is detected.
S * |        |          |Note: Software must select card detect level before Smart Card engine is enabled
S * |[11]    |POW_INV   |SC_POW Pin Inverse
S * |        |          |This bit is used for inverse the SC_POW pin.
S * |        |          |There are four kinds of combination for SC_POW pin setting by POW_INV(SC_PINCSR[11]) and
S * |        |          |POW_EN(SC_PINCSR[0]).
S * |        |          |POW_INV (SC_PINCSR[11]) is bit 1 and POW_EN(SC_PINCSR[0]) is bit 0 for SC_POW_Pin as high or low
S * |        |          |voltage selection.
S * |        |          |00 = SC_POW_ Pin is 0.
S * |        |          |01 = SC_POW _Pin is 1.
S * |        |          |10 = SC_POW _Pin is 1.
S * |        |          |11 = SC_POW_ Pin is 0.
S * |        |          |Note: Software must select POW_INV (SC_PINCSR[11]) before Smart Card is enabled by SC_CEN
S * |        |          |(SC_CTL[0]).
S * |[16]    |SC_DATA_I_ST|SC Data Pin Status (Read Only)
S * |        |          |This bit is the pin status of SC_DATA
S * |        |          |0 = The SC_DATA pin is low.
S * |        |          |1 = The SC_DATA pin is high.
S * |[30]    |SYNC      |SYNC Flag Indicator
S * |        |          |Due to synchronization, software should check this bit when writing a new value to SC_PINCSR
S * |        |          |register.
S * |        |          |0 = Synchronizing is completion, user can write new data to SC_PINCSR register.
S * |        |          |1 = Last value is synchronizing.
S * |        |          |Note: This bit is read only.
S * @var SC_T::TMR0
S * Offset: 0x28  SC Internal Timer Control Register 0
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[23:0]  |CNT0      |Timer 0 Counter Value (ETU Base)
S * |        |          |This field indicates the internal timer operation values.
S * |[27:24] |MODE      |Timer 0 Operation Mode Selection
S * |        |          |This field indicates the internal 24-bit timer operation selection.
S * |        |          |Refer to 5.15.5.4 for programming Timer0
S * @var SC_T::TMR1
S * Offset: 0x2C  SC Internal Timer Control Register 1
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |CNT1      |Timer 1 Counter Value (ETU Base)
S * |        |          |This field indicates the internal timer operation values.
S * |[27:24] |MODE      |Timer 1 Operation Mode Selection
S * |        |          |This field indicates the internal 8-bit timer operation selection.
S * |        |          |Refer to 5.15.5.4 for programming Timer1
S * @var SC_T::TMR2
S * Offset: 0x30  SC Internal Timer Control Register 2
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |CNT2      |Timer 2 Counter Value (ETU Base)
S * |        |          |This field indicates the internal timer operation values.
S * |[27:24] |MODE      |Timer 2 Operation Mode Selection
S * |        |          |This field indicates the internal 8-bit timer operation selection
S * |        |          |Refer to 5.15.5.4 for programming Timer2
S * @var SC_T::UACTL
S * Offset: 0x34  SC UART Mode Control Register.
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |UA_MODE_EN|UART Mode Enable Control
S * |        |          |0 = Smart Card mode.
S * |        |          |1 = UART mode.
S * |        |          |Note1: When operating in UART mode, user must set CON_SEL (SC_CTL[5:4]) = 00 and
S * |        |          |AUTO_CON_EN(SC_CTL[3]) = 0.
S * |        |          |Note2: When operating in Smart Card mode, user must set UA_MODE_EN(SC_UACTL [0]) = 00.
S * |        |          |Note3: When UART is enabled, hardware will generate a reset to reset FIFO and internal state
S * |        |          |machine.
S * |[5:4]   |DATA_LEN10|Data Length
S * |        |          |00 = Character Data Length is 8 bits.
S * |        |          |01 = Character Data Length is 7 bits.
S * |        |          |10 = Character Data length is 6 bits.
S * |        |          |11 = Character Data Length is 5 bits.
S * |        |          |Note: In smart card mode, this DATA_LEN must be '00'
S * |[6]     |PBDIS     |Parity Bit Disable Control
S * |        |          |0 = Parity bit is generated or checked between the "last data word bit" and "stop bit" of the
S * |        |          |serial data.
S * |        |          |1 = Parity bit is not generated (transmitting data) or checked (receiving data) during transfer.
S * |        |          |Note: In smart card mode, this field must be '0' (default setting is with parity bit)
S * |[7]     |OPE       |Odd Parity Enable Control
S * |        |          |0 = Even number of logic 1's are transmitted or check the data word and parity bits in receiving
S * |        |          |mode.
S * |        |          |1 = Odd number of logic 1's are transmitted or check the data word and parity bits in receiving
S * |        |          |mode.
S * |        |          |Note: This bit has effect only when PBDIS bit is '0'.
S * @var SC_T::TDRA
S * Offset: 0x38  SC Timer Current Data Register A
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[23:0]  |TDR0      |Timer0 Current Data value(Read Only)
S * |        |          |This field indicates the current count values of timer0.
S * @var SC_T::TDRB
S * Offset: 0x3C  SC Timer Current Data Register B
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |TDR1      |Timer1 Current Data value(Read Only)
S * |        |          |This field indicates the current count values of timer1.
S * |[15:8]  |TDR2      |Timer2 Current Data value (Read Only)
S * |        |          |This field indicates the current count values of timer2.
S */
S    
S    union {
S    __I  uint32_t RBR;           /* Offset: 0x00  SC Receiving Buffer Register.                                      */
S    __O  uint32_t THR;           /* Offset: 0x00  SC Transmit Holding Register                                       */
S    };
S    __IO uint32_t CTL;           /* Offset: 0x04  SC Control Register                                                */
S    __IO uint32_t ALTCTL;        /* Offset: 0x08  SC Alternate Control Register                                      */
S    __IO uint32_t EGTR;          /* Offset: 0x0C  SC Extend Guard Time Register                                      */
S    __IO uint32_t RFTMR;         /* Offset: 0x10  SC Receive buffer Time-out Register                                */
S    __IO uint32_t ETUCR;         /* Offset: 0x14  SC ETU Control Register                                            */
S    __IO uint32_t IER;           /* Offset: 0x18  SC Interrupt Enable Control Register                               */
S    __IO uint32_t ISR;           /* Offset: 0x1C  SC Interrupt Status Register                                       */
S    __IO uint32_t TRSR;          /* Offset: 0x20  SC Status Register                                                 */
S    __IO uint32_t PINCSR;        /* Offset: 0x24  SC Pin Control State Register                                      */
S    __IO uint32_t TMR0;          /* Offset: 0x28  SC Internal Timer Control Register 0                               */
S    __IO uint32_t TMR1;          /* Offset: 0x2C  SC Internal Timer Control Register 1                               */
S    __IO uint32_t TMR2;          /* Offset: 0x30  SC Internal Timer Control Register 2                               */
S    __IO uint32_t UACTL;         /* Offset: 0x34  SC UART Mode Control Register.                                     */
S    __I  uint32_t TDRA;          /* Offset: 0x38  SC Timer Current Data Register A                                   */
S    __I  uint32_t TDRB;          /* Offset: 0x3C  SC Timer Current Data Register B                                   */
S
S} SC_T;
S
S
S/**
S    @addtogroup SC_CONST SC Bit Field Definition
S    Constant Definitions for SC Controller
S@{ */
S
S
S/* SC RBR Bit Field Definitions */
S#define SC_RBR_RBR_Pos                      0                                /*!< SC_T::RBR: RBR Position */
S#define SC_RBR_RBR_Msk                      (0xFFul << SC_RBR_RBR_Pos)       /*!< SC_T::RBR: RBR Mask */
S
S/* SC THR Bit Field Definitions */
S#define SC_THR_THR_Pos                      0                                /*!< SC_T::THR: THR Position */
S#define SC_THR_THR_Msk                      (0xFFul << SC_THR_THR_Pos)       /*!< SC_T::THR: THR Mask */
S
S/* SC CTL Bit Field Definitions */
S#define SC_CTL_SYNC_Pos                     30                               /*!< SC_T::CTL: SYNC Position */
S#define SC_CTL_SYNC_Msk                     (1ul << SC_CTL_SYNC_Pos)   /*!< SC_T::CTL: SYNC Mask */
S
S#define SC_CTL_CD_DEB_SEL_Pos               24                               /*!< SC_T::CTL: CD_DEB_SEL Position */
S#define SC_CTL_CD_DEB_SEL_Msk               (3ul << SC_CTL_CD_DEB_SEL_Pos)   /*!< SC_T::CTL: CD_DEB_SEL Mask */
S
S#define SC_CTL_TX_ERETRY_EN_Pos             23                               /*!< SC_T::CTL: TX_ERETRY_EN Position */
S#define SC_CTL_TX_ERETRY_EN_Msk             (1ul << SC_CTL_TX_ERETRY_EN_Pos) /*!< SC_T::CTL: TX_ERETRY_EN Mask */
S
S#define SC_CTL_TX_ERETRY_Pos                20                               /*!< SC_T::CTL: TX_ERETRY Position */
S#define SC_CTL_TX_ERETRY_Msk                (7ul << SC_CTL_TX_ERETRY_Pos)    /*!< SC_T::CTL: TX_ERETRY Mask */
S
S#define SC_CTL_RX_ERETRY_EN_Pos             19                               /*!< SC_T::CTL: RX_ERETRY_EN Position */
S#define SC_CTL_RX_ERETRY_EN_Msk             (1ul << SC_CTL_RX_ERETRY_EN_Pos) /*!< SC_T::CTL: RX_ERETRY_EN Mask */
S
S#define SC_CTL_RX_ERETRY_Pos                16                               /*!< SC_T::CTL: RX_ERETRY Position */
S#define SC_CTL_RX_ERETRY_Msk                (7ul << SC_CTL_RX_ERETRY_Pos)    /*!< SC_T::CTL: RX_ERETRY Mask */
S
S#define SC_CTL_SLEN_Pos                     15                               /*!< SC_T::CTL: SLEN Position */
S#define SC_CTL_SLEN_Msk                     (1ul << SC_CTL_SLEN_Pos)         /*!< SC_T::CTL: SLEN Mask */
S
S#define SC_CTL_TMR_SEL_Pos                  13                               /*!< SC_T::CTL: TMR_SEL Position */
S#define SC_CTL_TMR_SEL_Msk                  (3ul << SC_CTL_TMR_SEL_Pos)      /*!< SC_T::CTL: TMR_SEL Mask */
S
S#define SC_CTL_BGT_Pos                      8                                /*!< SC_T::CTL: BGT Position */
S#define SC_CTL_BGT_Msk                      (0x1Ful << SC_CTL_BGT_Pos)       /*!< SC_T::CTL: BGT Mask */
S
S#define SC_CTL_RX_FTRI_LEV_Pos              6                                /*!< SC_T::CTL: RX_FTRI_LEV Position */
S#define SC_CTL_RX_FTRI_LEV_Msk              (3ul << SC_CTL_RX_FTRI_LEV_Pos)  /*!< SC_T::CTL: RX_FTRI_LEV Mask */
S
S#define SC_CTL_CON_SEL_Pos                  4                                /*!< SC_T::CTL: CON_SEL Position */
S#define SC_CTL_CON_SEL_Msk                  (3ul << SC_CTL_CON_SEL_Pos)      /*!< SC_T::CTL: CON_SEL Mask */
S
S#define SC_CTL_AUTO_CON_EN_Pos              3                                /*!< SC_T::CTL: AUTO_CON_EN Position */
S#define SC_CTL_AUTO_CON_EN_Msk              (1ul << SC_CTL_AUTO_CON_EN_Pos)  /*!< SC_T::CTL: AUTO_CON_EN Mask */
S
S#define SC_CTL_DIS_TX_Pos                   2                                /*!< SC_T::CTL: DIS_TX Position */
S#define SC_CTL_DIS_TX_Msk                   (1ul << SC_CTL_DIS_TX_Pos)       /*!< SC_T::CTL: DIS_TX Mask */
S
S#define SC_CTL_DIS_RX_Pos                   1                                /*!< SC_T::CTL: DIS_RX Position */
S#define SC_CTL_DIS_RX_Msk                   (1ul << SC_CTL_DIS_RX_Pos)       /*!< SC_T::CTL: DIS_RX Mask */
S
S#define SC_CTL_SC_CEN_Pos                   0                                /*!< SC_T::CTL: SC_CEN Position */
S#define SC_CTL_SC_CEN_Msk                   (1ul << SC_CTL_SC_CEN_Pos)       /*!< SC_T::CTL: SC_CEN Mask */
S
S/* SC ALTCTL Bit Field Definitions */
S#define SC_ALTCTL_OUTSEL_Pos                16                               /*!< SC_T::ALTCTL: OUTSEL Position */
S#define SC_ALTCTL_OUTSEL_Msk                (1ul << SC_ALTCTL_OUTSEL_Pos)   /*!< SC_T::ALTCTL: OUTSEL Mask */
S
S#define SC_ALTCTL_TMR2_ATV_Pos              15                               /*!< SC_T::ALTCTL: TMR2_ATV Position */
S#define SC_ALTCTL_TMR2_ATV_Msk              (1ul << SC_ALTCTL_TMR2_ATV_Pos)  /*!< SC_T::ALTCTL: TMR2_ATV Mask */
S
S#define SC_ALTCTL_TMR1_ATV_Pos              14                               /*!< SC_T::ALTCTL: TMR1_ATV Position */
S#define SC_ALTCTL_TMR1_ATV_Msk              (1ul << SC_ALTCTL_TMR1_ATV_Pos)  /*!< SC_T::ALTCTL: TMR1_ATV Mask */
S
S#define SC_ALTCTL_TMR0_ATV_Pos              13                               /*!< SC_T::ALTCTL: TMR0_ATV Position */
S#define SC_ALTCTL_TMR0_ATV_Msk              (1ul << SC_ALTCTL_TMR0_ATV_Pos)  /*!< SC_T::ALTCTL: TMR0_ATV Mask */
S
S#define SC_ALTCTL_RX_BGT_EN_Pos             12                               /*!< SC_T::ALTCTL: RX_BGT_EN Position */
S#define SC_ALTCTL_RX_BGT_EN_Msk             (1ul << SC_ALTCTL_RX_BGT_EN_Pos) /*!< SC_T::ALTCTL: RX_BGT_EN Mask */
S
S#define SC_ALTCTL_INIT_SEL_Pos              8                                /*!< SC_T::ALTCTL: INIT_SEL Position */
S#define SC_ALTCTL_INIT_SEL_Msk              (3ul << SC_ALTCTL_INIT_SEL_Pos)  /*!< SC_T::ALTCTL: INIT_SEL Mask */
S
S#define SC_ALTCTL_TMR2_SEN_Pos              7                                /*!< SC_T::ALTCTL: TMR2_SEN Position */
S#define SC_ALTCTL_TMR2_SEN_Msk              (1ul << SC_ALTCTL_TMR2_SEN_Pos)  /*!< SC_T::ALTCTL: TMR2_SEN Mask */
S
S#define SC_ALTCTL_TMR1_SEN_Pos              6                                /*!< SC_T::ALTCTL: TMR1_SEN Position */
S#define SC_ALTCTL_TMR1_SEN_Msk              (1ul << SC_ALTCTL_TMR1_SEN_Pos)  /*!< SC_T::ALTCTL: TMR1_SEN Mask */
S
S#define SC_ALTCTL_TMR0_SEN_Pos              5                                /*!< SC_T::ALTCTL: TMR0_SEN Position */
S#define SC_ALTCTL_TMR0_SEN_Msk              (1ul << SC_ALTCTL_TMR0_SEN_Pos)  /*!< SC_T::ALTCTL: TMR0_SEN Mask */
S
S#define SC_ALTCTL_WARST_EN_Pos              4                                /*!< SC_T::ALTCTL: WARST_EN Position */
S#define SC_ALTCTL_WARST_EN_Msk              (1ul << SC_ALTCTL_WARST_EN_Pos)  /*!< SC_T::ALTCTL: WARST_EN Mask */
S
S#define SC_ALTCTL_ACT_EN_Pos                3                                /*!< SC_T::ALTCTL: ACT_EN Position */
S#define SC_ALTCTL_ACT_EN_Msk                (1ul << SC_ALTCTL_ACT_EN_Pos)    /*!< SC_T::ALTCTL: ACT_EN Mask */
S
S#define SC_ALTCTL_DACT_EN_Pos               2                                /*!< SC_T::ALTCTL: DACT_EN Position */
S#define SC_ALTCTL_DACT_EN_Msk               (1ul << SC_ALTCTL_DACT_EN_Pos)   /*!< SC_T::ALTCTL: DACT_EN Mask */
S
S#define SC_ALTCTL_RX_RST_Pos                1                                /*!< SC_T::ALTCTL: RX_RST Position */
S#define SC_ALTCTL_RX_RST_Msk                (1ul << SC_ALTCTL_RX_RST_Pos)    /*!< SC_T::ALTCTL: RX_RST Mask */
S
S#define SC_ALTCTL_TX_RST_Pos                0                                /*!< SC_T::ALTCTL: TX_RST Position */
S#define SC_ALTCTL_TX_RST_Msk                (1ul << SC_ALTCTL_TX_RST_Pos)    /*!< SC_T::ALTCTL: TX_RST Mask */
S
S/* SC EGTR Bit Field Definitions */
S#define SC_EGTR_EGT_Pos                     0                               /*!< SC_T::EGTR: EGT Position */
S#define SC_EGTR_EGT_Msk                     (0xFFul << SC_EGTR_EGT_Pos)     /*!< SC_T::EGTR: EGT Mask */
S
S/* SC RFTMR Bit Field Definitions */
S#define SC_RFTMR_RFTM_Pos                   0                               /*!< SC_T::RFTMR: RFTM Position */
S#define SC_RFTMR_RFTM_Msk                   (0x1FFul << SC_RFTMR_RFTM_Pos)  /*!< SC_T::RFTMR: RFTM Mask */
S
S/* SC ETUCR Bit Field Definitions */
S#define SC_ETUCR_COMPEN_EN_Pos              15                               /*!< SC_T::ETUCR: COMPEN_EN Position */
S#define SC_ETUCR_COMPEN_EN_Msk              (1ul << SC_ETUCR_COMPEN_EN_Pos)  /*!< SC_T::ETUCR: COMPEN_EN Mask */
S
S#define SC_ETUCR_ETU_RDIV_Pos               0                                   /*!< SC_T::ETUCR: ETU_RDIV Position */
S#define SC_ETUCR_ETU_RDIV_Msk               (0xFFFul << SC_ETUCR_ETU_RDIV_Pos)  /*!< SC_T::ETUCR: ETU_RDIV Mask */
S
S/* SC IER Bit Field Definitions */
S#define SC_IER_ACON_ERR_IE_Pos              10                                  /*!< SC_T::IER: ACON_ERR_IE Position */
S#define SC_IER_ACON_ERR_IE_Msk              (1ul << SC_IER_ACON_ERR_IE_Pos)     /*!< SC_T::IER: ACON_ERR_IE Mask */
S
S#define SC_IER_RTMR_IE_Pos                  9                               /*!< SC_T::IER: RTMR_IE Position */
S#define SC_IER_RTMR_IE_Msk                  (1ul << SC_IER_RTMR_IE_Pos)     /*!< SC_T::IER: RTMR_IE Mask */
S
S#define SC_IER_INIT_IE_Pos                  8                               /*!< SC_T::IER: INIT_IE Position */
S#define SC_IER_INIT_IE_Msk                  (1ul << SC_IER_INIT_IE_Pos)     /*!< SC_T::IER: INIT_IE Mask */
S
S#define SC_IER_CD_IE_Pos                    7                               /*!< SC_T::IER: CD_IE Position */
S#define SC_IER_CD_IE_Msk                    (1ul << SC_IER_CD_IE_Pos)       /*!< SC_T::IER: CD_IE Mask */
S
S#define SC_IER_BGT_IE_Pos                   6                               /*!< SC_T::IER: BGT_IE Position */
S#define SC_IER_BGT_IE_Msk                   (1ul << SC_IER_BGT_IE_Pos)      /*!< SC_T::IER: BGT_IE Mask */
S
S#define SC_IER_TMR2_IE_Pos                  5                               /*!< SC_T::IER: TMR2_IE Position */
S#define SC_IER_TMR2_IE_Msk                  (1ul << SC_IER_TMR2_IE_Pos)     /*!< SC_T::IER: TMR2_IE Mask */
S
S#define SC_IER_TMR1_IE_Pos                  4                               /*!< SC_T::IER: TMR1_IE Position */
S#define SC_IER_TMR1_IE_Msk                  (1ul << SC_IER_TMR1_IE_Pos)     /*!< SC_T::IER: TMR1_IE Mask */
S
S#define SC_IER_TMR0_IE_Pos                  3                               /*!< SC_T::IER: TMR0_IE Position */
S#define SC_IER_TMR0_IE_Msk                  (1ul << SC_IER_TMR0_IE_Pos)     /*!< SC_T::IER: TMR0_IE Mask */
S
S#define SC_IER_TERR_IE_Pos                  2                               /*!< SC_T::IER: TERR_IE Position */
S#define SC_IER_TERR_IE_Msk                  (1ul << SC_IER_TERR_IE_Pos)     /*!< SC_T::IER: TERR_IE Mask */
S
S#define SC_IER_TBE_IE_Pos                   1                               /*!< SC_T::IER: TBE_IE Position */
S#define SC_IER_TBE_IE_Msk                   (1ul << SC_IER_TBE_IE_Pos)      /*!< SC_T::IER: TBE_IE Mask */
S
S#define SC_IER_RDA_IE_Pos                   0                               /*!< SC_T::IER: RDA_IE Position */
S#define SC_IER_RDA_IE_Msk                   (1ul << SC_IER_RDA_IE_Pos)      /*!< SC_T::IER: RDA_IE Mask */
S
S/* SC ISR Bit Field Definitions */
S#define SC_ISR_ACON_ERR_IS_Pos              10                              /*!< SC_T::ISR: ACON_ERR_IS Position */
S#define SC_ISR_ACON_ERR_IS_Msk              (1ul << SC_ISR_ACON_ERR_IS_Pos) /*!< SC_T::ISR: ACON_ERR_IS Mask */
S
S#define SC_ISR_RTMR_IS_Pos                  9                               /*!< SC_T::ISR: RTMR_IS Position */
S#define SC_ISR_RTMR_IS_Msk                  (1ul << SC_ISR_RTMR_IS_Pos)     /*!< SC_T::ISR: RTMR_IS Mask */
S
S#define SC_ISR_INIT_IS_Pos                  8                               /*!< SC_T::ISR: INIT_IS Position */
S#define SC_ISR_INIT_IS_Msk                  (1ul << SC_ISR_INIT_IS_Pos)     /*!< SC_T::ISR: INIT_IS Mask */
S
S#define SC_ISR_CD_IS_Pos                    7                               /*!< SC_T::ISR: CD_IS Position */
S#define SC_ISR_CD_IS_Msk                    (1ul << SC_ISR_CD_IS_Pos)       /*!< SC_T::ISR: CD_IS Mask */
S
S#define SC_ISR_BGT_IS_Pos                   6                               /*!< SC_T::ISR: BGT_IS Position */
S#define SC_ISR_BGT_IS_Msk                   (1ul << SC_ISR_BGT_IS_Pos)      /*!< SC_T::ISR: BGT_IS Mask */
S
S#define SC_ISR_TMR2_IS_Pos                  5                               /*!< SC_T::ISR: TMR2_IS Position */
S#define SC_ISR_TMR2_IS_Msk                  (1ul << SC_ISR_TMR2_IS_Pos)     /*!< SC_T::ISR: TMR2_IS Mask */
S
S#define SC_ISR_TMR1_IS_Pos                  4                               /*!< SC_T::ISR: TMR1_IS Position */
S#define SC_ISR_TMR1_IS_Msk                  (1ul << SC_ISR_TMR1_IS_Pos)     /*!< SC_T::ISR: TMR1_IS Mask */
S
S#define SC_ISR_TMR0_IS_Pos                  3                               /*!< SC_T::ISR: TMR0_IS Position */
S#define SC_ISR_TMR0_IS_Msk                  (1ul << SC_ISR_TMR0_IS_Pos)     /*!< SC_T::ISR: TMR0_IS Mask */
S
S#define SC_ISR_TERR_IS_Pos                  2                               /*!< SC_T::ISR: TERR_IS Position */
S#define SC_ISR_TERR_IS_Msk                  (1ul << SC_ISR_TERR_IS_Pos)     /*!< SC_T::ISR: TERR_IS Mask */
S
S#define SC_ISR_TBE_IS_Pos                   1                               /*!< SC_T::ISR: TXBE_IS Position */
S#define SC_ISR_TBE_IS_Msk                   (1ul << SC_ISR_TBE_IS_Pos)      /*!< SC_T::ISR: TXBE_IS Mask */
S
S#define SC_ISR_RDA_IS_Pos                   0                               /*!< SC_T::ISR: RDA_IS Position */
S#define SC_ISR_RDA_IS_Msk                   (1ul << SC_ISR_RDA_IS_Pos)      /*!< SC_T::ISR: RDA_IS Mask */
S
S
S/* SC TRSR Bit Field Definitions */
S#define SC_TRSR_TX_ATV_Pos                  31                              /*!< SC_T::TRSR: TX_ATV Position */
S#define SC_TRSR_TX_ATV_Msk                  (1ul << SC_TRSR_TX_ATV_Pos)     /*!< SC_T::TRSR: TX_ATV Mask */
S
S#define SC_TRSR_TX_OVER_REERR_Pos           30                                  /*!< SC_T::TRSR: TX_OVER_REERR Position */
S#define SC_TRSR_TX_OVER_REERR_Msk           (1ul << SC_TRSR_TX_OVER_REERR_Pos)  /*!< SC_T::TRSR: TX_OVER_REERR Mask */
S
S#define SC_TRSR_TX_REERR_Pos                29                               /*!< SC_T::TRSR: TX_REERR Position */
S#define SC_TRSR_TX_REERR_Msk                (1ul << SC_TRSR_TX_REERR_Pos)    /*!< SC_T::TRSR: TX_REERR Mask */
S
S#define SC_TRSR_TX_POINT_F_Pos              24                               /*!< SC_T::TRSR: TX_POINT_F Position */
S#define SC_TRSR_TX_POINT_F_Msk              (3ul << SC_TRSR_TX_POINT_F_Pos)  /*!< SC_T::TRSR: TX_POINT_F Mask */
S
S#define SC_TRSR_RX_ATV_Pos                  23                               /*!< SC_T::TRSR: RX_ATV Position */
S#define SC_TRSR_RX_ATV_Msk                  (1ul << SC_TRSR_RX_ATV_Pos)      /*!< SC_T::TRSR: RX_ATV Mask */
S
S#define SC_TRSR_RX_OVER_REERR_Pos           22                                  /*!< SC_T::TRSR: RX_OVER_REERR Position */
S#define SC_TRSR_RX_OVER_REERR_Msk           (1ul << SC_TRSR_RX_OVER_REERR_Pos)  /*!< SC_T::TRSR: RX_OVER_REERR Mask */
S
S#define SC_TRSR_RX_REERR_Pos                21                                  /*!< SC_T::TRSR: RX_REERR Position */
S#define SC_TRSR_RX_REERR_Msk                (1ul << SC_TRSR_RX_REERR_Pos)       /*!< SC_T::TRSR: RX_REERR Mask */
S
S#define SC_TRSR_RX_POINT_F_Pos              16                                  /*!< SC_T::TRSR: RX_POINT_F Position */
S#define SC_TRSR_RX_POINT_F_Msk              (3ul << SC_TRSR_RX_POINT_F_Pos)     /*!< SC_T::TRSR: RX_POINT_F Mask */
S
S#define SC_TRSR_TX_FULL_F_Pos               10                                  /*!< SC_T::TRSR: TX_FULL_F Position */
S#define SC_TRSR_TX_FULL_F_Msk               (1ul << SC_TRSR_TX_FULL_F_Pos)      /*!< SC_T::TRSR: TX_FULL_F Mask */
S
S#define SC_TRSR_TX_EMPTY_F_Pos              9                                   /*!< SC_T::TRSR: TX_EMPTY_F Position */
S#define SC_TRSR_TX_EMPTY_F_Msk              (1ul << SC_TRSR_TX_EMPTY_F_Pos)     /*!< SC_T::TRSR: TX_EMPTY_F Mask */
S
S#define SC_TRSR_TX_OVER_F_Pos               8                                   /*!< SC_T::TRSR: TX_OVER_F Position */
S#define SC_TRSR_TX_OVER_F_Msk               (1ul << SC_TRSR_TX_OVER_F_Pos)      /*!< SC_T::TRSR: TX_OVER_F Mask */
S
S#define SC_TRSR_RX_EBR_F_Pos                6                                   /*!< SC_T::TRSR: RX_EBR_F Position */
S#define SC_TRSR_RX_EBR_F_Msk                (1ul << SC_TRSR_RX_EBR_F_Pos)       /*!< SC_T::TRSR: RX_EBR_F Mask */
S
S#define SC_TRSR_RX_EFR_F_Pos                5                                   /*!< SC_T::TRSR: RX_EFR_F Position */
S#define SC_TRSR_RX_EFR_F_Msk                (1ul << SC_TRSR_RX_EFR_F_Pos)       /*!< SC_T::TRSR: RX_EFR_F Mask */
S
S#define SC_TRSR_RX_EPA_F_Pos                4                                   /*!< SC_T::TRSR: RX_EPA_F Position */
S#define SC_TRSR_RX_EPA_F_Msk                (1ul << SC_TRSR_RX_EPA_F_Pos)       /*!< SC_T::TRSR: RX_EPA_F Mask */
S
S#define SC_TRSR_RX_FULL_F_Pos               2                                   /*!< SC_T::TRSR: RX_FULL_F Position */
S#define SC_TRSR_RX_FULL_F_Msk               (1ul << SC_TRSR_RX_FULL_F_Pos)      /*!< SC_T::TRSR: RX_FULL_F Mask */
S
S#define SC_TRSR_RX_EMPTY_F_Pos              1                                   /*!< SC_T::TRSR: RX_EMPTY_F Position */
S#define SC_TRSR_RX_EMPTY_F_Msk              (1ul << SC_TRSR_RX_EMPTY_F_Pos)     /*!< SC_T::TRSR: RX_EMPTY_F Mask */
S
S#define SC_TRSR_RX_OVER_F_Pos               0                                   /*!< SC_T::TRSR: RX_OVER_F Position */
S#define SC_TRSR_RX_OVER_F_Msk               (1ul << SC_TRSR_RX_OVER_F_Pos)      /*!< SC_T::TRSR: RX_OVER_F Mask */
S
S/* SC PINCSR Bit Field Definitions */
S#define SC_PINCSR_SYNC_Pos                  30                                  /*!< SC_T::PINCSR: SYNC Position */
S#define SC_PINCSR_SYNC_Msk                  (1ul << SC_PINCSR_SYNC_Pos)         /*!< SC_T::PINCSR: SYNC Mask */
S
S#define SC_PINCSR_SC_DATA_I_ST_Pos          16                                  /*!< SC_T::PINCSR: SC_DATA_I_ST Position */
S#define SC_PINCSR_SC_DATA_I_ST_Msk          (1ul << SC_PINCSR_SC_DATA_I_ST_Pos) /*!< SC_T::PINCSR: SC_DATA_I_ST Mask */
S
S#define SC_PINCSR_POW_INV_Pos               11                                  /*!< SC_T::PINCSR: POW_INV Position */
S#define SC_PINCSR_POW_INV_Msk               (1ul << SC_PINCSR_POW_INV_Pos)      /*!< SC_T::PINCSR: POW_INV Mask */
S
S#define SC_PINCSR_CD_LEV_Pos                10                                  /*!< SC_T::PINCSR: CD_LEV Position */
S#define SC_PINCSR_CD_LEV_Msk                (1ul << SC_PINCSR_CD_LEV_Pos)       /*!< SC_T::PINCSR: CD_LEV Mask */
S
S#define SC_PINCSR_SC_DATA_O_Pos             9                                   /*!< SC_T::PINCSR: SC_DATA_O Position */
S#define SC_PINCSR_SC_DATA_O_Msk             (1ul << SC_PINCSR_SC_DATA_O_Pos)    /*!< SC_T::PINCSR: SC_DATA_O Mask */
S
S#define SC_PINCSR_SC_OEN_ST_Pos             8                                   /*!< SC_T::PINCSR: SC_OEN_ST Position */
S#define SC_PINCSR_SC_OEN_ST_Msk             (1ul << SC_PINCSR_SC_OEN_ST_Pos)    /*!< SC_T::PINCSR: SC_OEN_ST Mask */
S
S#define SC_PINCSR_ADAC_CD_EN_Pos            7                                   /*!< SC_T::PINCSR: ADAC_CD_EN Position */
S#define SC_PINCSR_ADAC_CD_EN_Msk            (1ul << SC_PINCSR_ADAC_CD_EN_Pos)   /*!< SC_T::PINCSR: ADAC_CD_EN Mask */
S
S#define SC_PINCSR_CLK_KEEP_Pos              6                                   /*!< SC_T::PINCSR: CLK_KEEP Position */
S#define SC_PINCSR_CLK_KEEP_Msk              (1ul << SC_PINCSR_CLK_KEEP_Pos)     /*!< SC_T::PINCSR: CLK_KEEP Mask */
S
S#define SC_PINCSR_CD_PIN_ST_Pos             4                                   /*!< SC_T::PINCSR: CD_PIN_ST Position */
S#define SC_PINCSR_CD_PIN_ST_Msk             (1ul << SC_PINCSR_CD_PIN_ST_Pos)    /*!< SC_T::PINCSR: CD_PIN_ST Mask */
S
S#define SC_PINCSR_CD_INS_F_Pos              3                                   /*!< SC_T::PINCSR: CD_INS_F Position */
S#define SC_PINCSR_CD_INS_F_Msk              (1ul << SC_PINCSR_CD_INS_F_Pos)     /*!< SC_T::PINCSR: CD_INS_F Mask */
S
S#define SC_PINCSR_CD_REM_F_Pos              2                                   /*!< SC_T::PINCSR: CD_REM_F Position */
S#define SC_PINCSR_CD_REM_F_Msk              (1ul << SC_PINCSR_CD_REM_F_Pos)     /*!< SC_T::PINCSR: CD_REM_F Mask */
S
S#define SC_PINCSR_SC_RST_Pos                1                                   /*!< SC_T::PINCSR: SC_RST Position */
S#define SC_PINCSR_SC_RST_Msk                (1ul << SC_PINCSR_SC_RST_Pos)       /*!< SC_T::PINCSR: SC_RST Mask */
S
S#define SC_PINCSR_POW_EN_Pos                0                                   /*!< SC_T::PINCSR: POW_EN Position */
S#define SC_PINCSR_POW_EN_Msk                (1ul << SC_PINCSR_POW_EN_Pos)       /*!< SC_T::PINCSR: POW_EN Mask */
S
S/* SC TMR0 Bit Field Definitions */
S#define SC_TMR0_MODE_Pos                    24                              /*!< SC_T::TMR0: MODE Position */
S#define SC_TMR0_MODE_Msk                    (0xFul << SC_TMR0_MODE_Pos)     /*!< SC_T::TMR0: MODE Mask */
S
S#define SC_TMR0_CNT_Pos                     0                               /*!< SC_T::TMR0: CNT Position */
S#define SC_TMR0_CNT_Msk                     (0xFFFFFFul << SC_TMR0_CNT_Pos) /*!< SC_T::TMR0: CNT Mask */
S
S/* SC TMR1 Bit Field Definitions */
S#define SC_TMR1_MODE_Pos                    24                              /*!< SC_T::TMR1: MODE Position */
S#define SC_TMR1_MODE_Msk                    (0xFul << SC_TMR1_MODE_Pos)     /*!< SC_T::TMR1: MODE Mask */
S
S#define SC_TMR1_CNT_Pos                     0                               /*!< SC_T::TMR1: CNT Position */
S#define SC_TMR1_CNT_Msk                     (0xFFul << SC_TMR1_CNT_Pos)     /*!< SC_T::TMR1: CNT Mask */
S
S/* SC TMR2 Bit Field Definitions */
S#define SC_TMR2_MODE_Pos                    24                              /*!< SC_T::TMR2: MODE Position */
S#define SC_TMR2_MODE_Msk                    (0xFul << SC_TMR2_MODE_Pos)     /*!< SC_T::TMR2: MODE Mask */
S
S#define SC_TMR2_CNT_Pos                     0                               /*!< SC_T::TMR2: CNT Position */
S#define SC_TMR2_CNT_Msk                     (0xFFul << SC_TMR2_CNT_Pos)     /*!< SC_T::TMR2: CNT Mask */
S
S/* SC UACTL Bit Field Definitions */
S#define SC_UACTL_OPE_Pos                   7                                /*!< SC_T::UACTL: OPE Position */
S#define SC_UACTL_OPE_Msk                   (1ul << SC_UACTL_OPE_Pos)        /*!< SC_T::UACTL: OPE Mask */
S
S#define SC_UACTL_PBDIS_Pos                 6                                /*!< SC_T::UACTL: PBDIS Position */
S#define SC_UACTL_PBDIS_Msk                 (1ul << SC_UACTL_PBDIS_Pos)      /*!< SC_T::UACTL: PBDIS Mask */
S
S#define SC_UACTL_DATA_LEN_Pos              4                                /*!< SC_T::UACTL: DATA_LEN Position */
S#define SC_UACTL_DATA_LEN_Msk              (3ul << SC_UACTL_DATA_LEN_Pos)   /*!< SC_T::UACTL: DATA_LEN Mask */
S
S#define SC_UACTL_UA_MODE_EN_Pos            0                                /*!< SC_T::UACTL: UA_MODE_EN Position */
S#define SC_UACTL_UA_MODE_EN_Msk            (1ul << SC_UACTL_UA_MODE_EN_Pos) /*!< SC_T::UACTL: UA_MODE_EN Mask */
S
S/* SC TDRA Bit Field Definitions */
S#define SC_TDRA_TDR0_Pos                    0                                   /*!< SC_T::TDRA: TDR0 Position */
S#define SC_TDRA_TDR0_Msk                    (0xFFFFFFul << SC_TDRA_TDR0_Pos)    /*!< SC_T::TDRA: TDR0 Mask */
S
S/* SC TDRB Bit Field Definitions */
S#define SC_TDRB_TDR2_Pos                    8                               /*!< SC_T::TDRB: TDR2 Position */
S#define SC_TDRB_TDR2_Msk                    (0xFFul << SC_TDRB_TDR2_Pos)    /*!< SC_T::TDRB: TDR2 Mask */
S
S#define SC_TDRB_TDR1_Pos                    0                               /*!< SC_T::TDRB: TDR1 Position */
S#define SC_TDRB_TDR1_Msk                    (0xFFul << SC_TDRB_TDR1_Pos)    /*!< SC_T::TDRB: TDR1 Mask */
S
S/*@}*/ /* end of group SC_CONST */
S/*@}*/ /* end of group SMARTCARD */
S
S
S/*---------------------- Serial Peripheral Interface Controller -------------------------*/
S/**
S    @addtogroup SPI Serial Peripheral Interface Controller (SPI)
S    Memory Mapped Structure for SPI Controller
S@{ */
S
S
S
Stypedef struct
S{
S
S
S/**
S * @var SPI_T::CNTRL
S * Offset: 0x00  Control and Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |GO_BUSY   |SPI Transfer Control Bit And Busy Status
S * |        |          |0 = Data transfer stopped.
S * |        |          |1 = In Master mode, writing 1 to this bit to start the SPI data transfer; in Slave mode,
S * |        |          |    writing 1 to this bit indicates that the slave is ready to communicate with a master.
S * |        |          |If FIFO mode is disabled, during the data transfer, this bit keeps the value of 1.
S * |        |          |As the transfer is finished, this bit will be cleared automatically.
S * |        |          |Software can read this bit to check if the SPI is in busy status.
S * |        |          |In FIFO mode, this bit will be controlled by hardware.
S * |        |          |Software should not modify this bit.
S * |        |          |In Slave mode, this bit always returns 1 when this register is read by software.
S * |        |          |In Master mode, this bit reflects the busy or idle status of SPI.
S * |        |          |Note:
S * |        |          |1. When FIFO mode is disabled, all configurations should be set before writing 1 to this GO_BUSY
S * |        |          |bit.
S * |        |          |2. When FIFO mode is disabled and the software uses TX or RX PDMA function to transfer data,
S * |        |          |this bit
S * |        |          |   will be cleared after the PDMA finishes the data transfer.
S * |[1]     |RX_NEG    |Receive On Negative Edge
S * |        |          |0 = Received data input signal is latched on the rising edge of SPI bus clock.
S * |        |          |1 = Received data input signal is latched on the falling edge of SPI bus clock.
S * |[2]     |TX_NEG    |Transmit On Negative Edge
S * |        |          |0 = Transmitted data output signal is changed on the rising edge of SPI bus clock.
S * |        |          |1 = Transmitted data output signal is changed on the falling edge of SPI bus clock.
S * |[7:3]   |TX_BIT_LEN|Transmit Bit Length
S * |        |          |This field specifies how many bits can be transmitted / received in one transaction.
S * |        |          |The minimum bit length is 8 bits and can up to 32 bits.
S * |        |          |TX_BIT_LEN = 0x08 ... 8 bits.
S * |        |          |TX_BIT_LEN = 0x09 ... 9 bits.
S * |        |          |......
S * |        |          |TX_BIT_LEN = 0x1F ... 31 bits.
S * |        |          |TX_BIT_LEN = 0x00 ... 32 bits.
S * |[10]    |LSB       |Send LSB First
S * |        |          |0 = The MSB, which bit of transmit/receive register depends on the setting of TX_BIT_LEN, is
S * |        |          |transmitted/received first.
S * |        |          |1 = The LSB, bit 0 of the SPI TX0/1 register, is sent first to the SPI data output pin, and the
S * |        |          |first bit received from
S * |        |          | the SPI data input pin will be put in the LSB position of the RX register (bit 0 of SPI_RX0/1).
S * |[11]    |CLKP      |Clock Polarity
S * |        |          |0 = SPI bus clock is idle low.
S * |        |          |1 = SPI bus clock is idle high.
S * |[15:12] |SP_CYCLE  |Suspend Interval (Master Only)
S * |        |          |The four bits provide configurable suspend interval between two successive transmit/receive
S * |        |          |transaction in a transfer.
S * |        |          |The definition of the suspend interval is the interval between the last clock edge of the
S * |        |          |preceding transaction word
S * |        |          |and the first clock edge of the following transaction word.
S * |        |          |The default value is 0x3.
S * |        |          |The period of the suspend interval is obtained according to the following equation.
S * |        |          |(SP_CYCLE[3:0] + 0.5) * period of SPI bus clock cycle
S * |        |          |Example:
S * |        |          |SP_CYCLE = 0x0 ... 0.5 SPI bus clock cycle.
S * |        |          |SP_CYCLE = 0x1 ... 1.5 SPI bus clock cycle.
S * |        |          |......
S * |        |          |SP_CYCLE = 0xE ... 14.5 SPI bus clock cycle.
S * |        |          |SP_CYCLE = 0xF ... 15.5 SPI bus clock cycle.
S * |        |          |If the variable clock function is enabled and the transmit FIFO buffer is not empty, the minimum
S * |        |          |period of suspend
S * |        |          |interval between the successive transactions is (6.5 + SP_CYCLE) * SPI bus clock cycle.
S * |[16]    |IF        |Unit Transfer Interrupt Flag
S * |        |          |0 = No transaction has been finished since this bit was cleared to 0.
S * |        |          |1 = SPI controller has finished one unit transfer.
S * |        |          |Note: This bit will be cleared by writing 1 to itself.
S * |[17]    |IE        |Unit Transfer Interrupt Enable
S * |        |          |0 = SPI unit transfer interrupt Disabled.
S * |        |          |1 = SPI unit transfer interrupt Enabled.
S * |[18]    |SLAVE     |Slave Mode Enable
S * |        |          |0 = Master mode.
S * |        |          |1 = Slave mode.
S * |[19]    |REORDER   |Byte Reorder Function Enable
S * |        |          |0 = Byte Reorder function Disabled.
S * |        |          |1 = Byte Reorder function Enabled.
S * |        |          |A byte suspend interval will be inserted among each byte.
S * |        |          |The period of the byte suspend interval depends on the setting of SP_CYCLE.
S * |        |          |Note:
S * |        |          |1. Byte Reorder function is only available if TX_BIT_LEN is defined as 16, 24, and 32 bits.
S * |        |          |2. In Slave mode with level-trigger configuration, the slave select pin must be kept at active
S * |        |          |state during the
S * |        |          |   byte suspend interval.
S * |        |          |3. The Byte Reorder function is not supported when the variable bus clock function or Dual I/O
S * |        |          |mode is enabled.
S * |[21]    |FIFO      |FIFO Mode Enable
S * |        |          |0 = FIFO mode Disabled.
S * |        |          |1 = FIFO mode Enabled.
S * |        |          |Note:
S * |        |          |1. Before enabling FIFO mode, the other related settings should be set in advance.
S * |        |          |2. In Master mode, if the FIFO mode is enabled, the GO_BUSY bit will be set to 1 automatically
S * |        |          |after writing data
S * |        |          | to the transmit FIFO buffer; the GO_BUSY bit will be cleared to 0 automatically when the SPI
S * |        |          |controller is in idle.
S * |        |          | If all data stored at transmit FIFO buffer are sent out, the TX_EMPTY bit will be set to 1 and
S * |        |          |the GO_BUSY bit will be cleared to 0.
S * |        |          |3. After clearing this bit to 0, user must wait for at least 2 peripheral clock periods before
S * |        |          |setting this bit to 1 again.
S * |[22]    |TWOB      |2-Bit Transfer Mode Enable
S * |        |          |0 = 2-bit Transfer mode Disabled.
S * |        |          |1 = 2-bit Transfer mode Enabled.
S * |        |          |Note: When 2-bit Transfer mode is enabled, the serial transmitted 2-bit data are from SPI_TX1/0,
S * |        |          |and the received 2-bit data input are put in SPI_RX1/0.
S * |[23]    |VARCLK_EN |Variable Clock Enable (Master Only)
S * |        |          |0 = SPI clock output frequency is fixed and decided only by the value of DIVIDER.
S * |        |          |1 = SPI clock output frequency is variable.
S * |        |          |The output frequency is decided by the value of VARCLK, DIVIDER, and DIVIDER2.
S * |        |          |Note: When this VARCLK_EN bit is set to 1, the setting of TX_BIT_LEN must be programmed as 0x10
S * |        |          |(16-bit mode).
S * |[24]    |RX_EMPTY  |Receive FIFO Buffer Empty Indicator (Read Only)
S * |        |          |It is a mutual mirror bit of SPI_STATUS[24].
S * |        |          |0 = Receive FIFO buffer is not empty.
S * |        |          |1 = Receive FIFO buffer is empty.
S * |[25]    |RX_FULL   |Receive FIFO Buffer Full Indicator (Read Only)
S * |        |          |It is a mutual mirror bit of SPI_STATUS[25].
S * |        |          |0 = Receive FIFO buffer is not full.
S * |        |          |1 = Receive FIFO buffer is full.
S * |[26]    |TX_EMPTY  |Transmit FIFO Buffer Empty Indicator (Read Only)
S * |        |          |It is a mutual mirror bit of SPI_STATUS[26].
S * |        |          |0 = Transmit FIFO buffer is not empty.
S * |        |          |1 = Transmit FIFO buffer is empty.
S * |[27]    |TX_FULL   |Transmit FIFO Buffer Full Indicator (Read Only)
S * |        |          |It is a mutual mirror bit of SPI_STATUS[27].
S * |        |          |0 = Transmit FIFO buffer is not full.
S * |        |          |1 = Transmit FIFO buffer is full.
S * @var SPI_T::DIVIDER
S * Offset: 0x04  Clock Divider Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |DIVIDER   |Clock Divider 1 Register
S * |        |          |The value in this field is the frequency divider for generating the SPI peripheral clock and the
S * |        |          |SPI bus clock of SPI master.
S * |        |          |The frequency is obtained according to the following equation.
S * |        |          |If the bit of BCn, SPI_CNTRL2[31], is set to 0,
S * |        |          |   SPI peripheral clock frequency = system clock frequency / (DIVIDER + 1) / 2
S * |        |          |else if BCn is set to 1,
S * |        |          |   SPI peripheral clock frequency = SPI peripheral clock source frequency / (DIVIDER + 1)
S * |        |          |The SPI peripheral clock source is defined in the CLKSEL1 register.
S * |[23:16] |DIVIDER2  |Clock Divider 2 Register (Master Only)
S * |        |          |The value in this field is the 2nd frequency divider for generating the second clock of the
S * |        |          |variable clock function.
S * |        |          |The frequency is obtained according to the following equation:
S * |        |          |   f_clk2 = SPI peripheral clock frequency / (DIVIDER2 + 1) / 2
S * |        |          |If the VARCLK_EN bit is cleared to 0, this setting is unmeaning.
S * @var SPI_T::SSR
S * Offset: 0x08  Slave Select Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[1:0]   |SSR       |Slave Select Control Bits (Master Only)
S * |        |          |If AUTOSS bit is cleared, writing 1 to any bit of this field sets the proper SPIn_SPISS0/1
S * |        |          |line to an active state and writing 0 sets the line back to inactive state.
S * |        |          |If the AUTOSS bit is set, writing 0 to any bit location of this field will keep the
S * |        |          |corresponding
S * |        |          |SPIn_SPISS0/1 line at inactive state; writing 1 to any bit location of this field will select
S * |        |          |appropriate SPIn_SPISS0/1 line to be automatically driven to active state for the duration of
S * |        |          |the
S * |        |          |transmit/receive, and will be driven to inactive state for the rest of the time.
S * |        |          |The active state of SPIn_SPISS0/1 is specified in SS_LVL.
S * |        |          |Note: SPIn_SPISS0 is defined as the slave select input in Slave mode.
S * |[2]     |SS_LVL    |Slave Select Active Level
S * |        |          |This bit defines the active status of slave select signal (SPIn_SPISS0/1).
S * |        |          |0 = The slave select signal SPIn_SPISS0/1 is active on low-level/falling-edge.
S * |        |          |1 = The slave select signal SPIn_SPISS0/1 is active on high-level/rising-edge.
S * |[3]     |AUTOSS    |Automatic Slave Select Function Enable (Master Only)
S * |        |          |0 = If this bit is cleared, slave select signals will be asserted/de-asserted by setting
S * |        |          |/clearing
S * |        |          |    the corresponding bits of SPI_SSR[1:0].
S * |        |          |1 = If this bit is set, SPIn_SPISS0/1 signals will be generated automatically.
S * |        |          | It means that device/slave select signal, which is set in SPI_SSR[1:0], will be asserted by the
S * |        |          | SPI controller when transmit/receive is started, and will be de-asserted after each
S * |        |          |transmit/receive is finished.
S * |[4]     |SS_LTRIG  |Slave Select Level Trigger Enable (Slave Only)
S * |        |          |0 = Slave select signal is edge-trigger.
S * |        |          |    This is the default value.
S * |        |          |    The SS_LVL bit decides the signal is active after a falling-edge or rising-edge.
S * |        |          |1 = Slave select signal is level-trigger.
S * |        |          |    The SS_LVL bit decides the signal is active low or active high.
S * |[5]     |LTRIG_FLAG|Level Trigger Accomplish Flag
S * |        |          |In Slave mode, this bit indicates whether the received bit number meets the requirement or not
S * |        |          |after the current transaction done.
S * |        |          |0 = Transferred bit length of one transaction does not meet the specified requirement.
S * |        |          |1 = Transferred bit length meets the specified requirement which defined in TX_BIT_LEN.
S * |        |          |Note: This bit is READ only.
S * |        |          |As the GO_BUSY bit is set to 1 by software, the LTRIG_FLAG will be cleared to 0 after 4 SPI
S * |        |          |peripheral clock periods plus 1 system clock period.
S * |        |          |In FIFO mode, this bit has no meaning.
S * @var SPI_T::RX
S * Offset: 0x10  Data Receive Register 0
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |RX        |Data Receive Register
S * |        |          |The data receive register holds the datum received from SPI data input pin.
S * |        |          |If FIFO mode is disabled, the last received data can be accessed through software by reading
S * |        |          |this register.
S * |        |          |If the FIFO bit is set as 1 and the RX_EMPTY bit, SPI_CNTRL[24] or SPI_STATUS[24], is not set to
S * |        |          |1, the receive
S * |        |          |FIFO buffer can be accessed through software by reading this register. This is a read-only
S * |        |          |register.
S * @var SPI_T::TX
S * Offset: 0x20  Data Transmit Register 0
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |TX        |Data Transmit Register
S * |        |          |The data transmit registers hold the data to be transmitted in the next transfer.
S * |        |          |The number of valid bits depends on the setting of transmit bit length field of the SPI_CNTRL
S * |        |          |register.
S * |        |          |For example, if TX_BIT_LEN is set to 0x08, the bits TX[7:0] will be transmitted in next
S * |        |          |transfer.
S * |        |          |If TX_BIT_LEN is set to 0x00, the SPI controller will perform a 32-bit transfer.
S * |        |          |Note 1: When the SPI controller is configured as a slave device and FIFO mode is disabled, if
S * |        |          |the SPI
S * |        |          | controller attempts to transmit data to a master, the transmit data register should be updated
S * |        |          |        by software before setting the GO_BUSY bit to 1.
S * |        |          |Note 2: In Master mode, SPI controller will start to transfer after 5 peripheral clock cycles
S * |        |          |after user writes to this register.
S * @var SPI_T::VARCLK
S * Offset: 0x34  Variable Clock Pattern Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |VARCLK    |Variable Clock Pattern
S * |        |          |This register defines the clock pattern of the SPI transfer.
S * |        |          |If the variable clock function is disabled, this setting is unmeaning.
S * @var SPI_T::DMA
S * Offset: 0x38  SPI DMA Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |TX_DMA_GO |Transmit DMA Start
S * |        |          |Setting this bit to 1 will start the transmit PDMA process.
S * |        |          |SPI controller will issue request to PDMA controller automatically.
S * |        |          |Hardware will clear this bit to 0 automatically after PDMA transfer done.
S * |        |          |If the SPI transmit PDMA function is used to transfer data, the GO_BUSY bit should not be set to
S * |        |          |1 by software.
S * |        |          |The PDMA control logic of SPI controller will set it automatically whenever necessary.
S * |        |          |In Slave mode and when FIFO mode is disabled, the minimal suspend interval between two
S * |        |          |successive transactions
S * |        |          |must be larger than (8 SPI clock periods + 14 APB clock periods) for edge-trigger mode or
S * |        |          |(9.5 SPI clock periods + 14 APB clock periods) for level-trigger mode.
S * |        |          |If the 2-bit Transfer mode is enabled, additional 18 APB clock periods for the above conditions
S * |        |          |is required.
S * |[1]     |RX_DMA_GO |Receive DMA Start
S * |        |          |Setting this bit to 1 will start the receive PDMA process.
S * |        |          |The SPI controller will issue request to PDMA controller automatically when the SPI receive
S * |        |          |buffer is not empty.
S * |        |          |This bit will be cleared to 0 by hardware automatically after PDMA transfer is done.
S * |        |          |If the software uses the receive PDMA function to access the received data of SPI and does not
S * |        |          |use the transmit
S * |        |          |PDMA function, the GO_BUSY bit should be set by software.
S * |        |          |Enabling FIFO mode is recommended if the software uses more than one PDMA channel to transfer
S * |        |          |data.
S * |        |          |In Slave mode and when FIFO mode is disabled, if the software only uses one PDMA channel for SPI
S * |        |          |receive PDMA
S * |        |          |function and the other PDMA channels are not in use, the minimal suspend interval between two
S * |        |          |successive
S * |        |          |transactions must be larger than (9 SPI slave peripheral clock periods + 4 APB clock periods)
S * |        |          |for Edge-trigger
S * |        |          |mode or (9.5 SPI slave peripheral clock periods + 4 APB clock periods) for Level-trigger mode.
S * |[2]     |PDMA_RST  |PDMA Reset
S * |        |          |0 = No effect.
S * |        |          |1 = Reset the PDMA control logic of the SPI controller. This bit will be cleared to 0
S * |        |          |automatically.
S * @var SPI_T::CNTRL2
S * Offset: 0x3C  Control and Status Register 2
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[8]     |NOSLVSEL  |Slave 3-Wire Mode Enable
S * |        |          |This is used to ignore the slave select signal in Slave mode.
S * |        |          |The SPI controller can work with 3-wire interface including SPIn_CLK, SPIn_MISO, and SPIn_MOSI.
S * |        |          |0 = 4-wire bi-direction interface.
S * |        |          |1 = 3-wire bi-direction interface.
S * |        |          |Note: In Slave 3-wire mode, the SS_LTRIG, SPI_SSR[4] will be set as 1 automatically.
S * |[9]     |SLV_ABORT |Slave 3-Wire Mode Abort Control
S * |        |          |In normal operation, there is an interrupt event when the received data meet the required bits
S * |        |          |which defined in TX_BIT_LEN.
S * |        |          |If the received bits are less than the requirement and there is no more SPI clock input over the
S * |        |          |one transfer time in
S * |        |          |Slave 3-wire mode, the user can set this bit to force the current transfer done and then the
S * |        |          |user can get a transfer done interrupt event.
S * |        |          |Note: This bit will be cleared to 0 automatically by hardware after it is set to 1 by software.
S * |[10]    |SSTA_INTEN|Slave 3-Wire Mode Start Interrupt Enable
S * |        |          |Used to enable interrupt when the transfer has started in Slave 3-wire mode.
S * |        |          |If there is no transfer done interrupt over the time period which is defined by user after the
S * |        |          |transfer start,
S * |        |          |the user can set the SLV_ABORT bit to force the transfer done.
S * |        |          |0 = Transaction start interrupt Disabled.
S * |        |          |1 = Transaction start interrupt Enabled.
S * |        |          |It will be cleared to 0 as the current transfer is done or the SLV_START_INTSTS bit is cleared.
S * |[11]    |SLV_START_INTSTS|Slave 3-Wire Mode Start Interrupt Status
S * |        |          |This bit indicates if a transaction has started in Slave 3-wire mode.
S * |        |          |It is a mutual mirror bit of SPI_STATUS[11].
S * |        |          |0 = Slave has not detected any SPI clock transition since the SSTA_INTEN bit was set to 1.
S * |        |          |1 = A transaction has started in Slave 3-wire mode.
S * |        |          |It will be cleared automatically when a transaction is done or by writing 1 to this bit.
S * |[12]    |DUAL_IO_DIR|Dual I/O Mode Direction Control
S * |        |          |0 = Dual Input mode.
S * |        |          |1 = Dual Output mode.
S * |[13]    |DUAL_IO_EN|Dual I/O Mode Enable
S * |        |          |0 = Dual I/O mode Disabled.
S * |        |          |1 = Dual I/O mode Enabled.
S * |[16]    |SS_INT_OPT|Slave Select Inactive Interrupt Option
S * |        |          |This setting is only available if the SPI controller is configured as level trigger slave
S * |        |          |device.
S * |        |          |0 = As the slave select signal goes to inactive level, the IF bit will NOT be set to 1.
S * |        |          |1 = As the slave select signal goes to inactive level, the IF bit will be set to 1.
S * |[31]    |BCn       |SPI Peripheral Clock Backward Compatible Option
S * |        |          |0 = Backward compatible clock configuration.
S * |        |          |1 = Clock configuration is not backward compatible.
S * |        |          |Refer to the description of SPI_DIVIDER register for details.
S * @var SPI_T::FIFO_CTL
S * Offset: 0x40  SPI FIFO Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |RX_CLR    |Clear Receive FIFO Buffer
S * |        |          |0 = No effect.
S * |        |          |1 = Clear receive FIFO buffer.
S * |        |          |The RX_FULL flag will be cleared to 0 and the RX_EMPTY flag will be set to 1.
S * |        |          |This bit will be cleared to 0 by hardware after it is set to 1 by software.
S * |[1]     |TX_CLR    |Clear Transmit FIFO Buffer
S * |        |          |0 = No effect.
S * |        |          |1 = Clear transmit FIFO buffer.
S * |        |          |The TX_FULL flag will be cleared to 0 and the TX_EMPTY flag will be set to 1.
S * |        |          |This bit will be cleared to 0 by hardware after it is set to 1 by software.
S * |[2]     |RX_INTEN  |Receive Threshold Interrupt Enable
S * |        |          |0 = RX threshold interrupt Disabled.
S * |        |          |1 = RX threshold interrupt Enabled.
S * |[3]     |TX_INTEN  |Transmit Threshold Interrupt Enable
S * |        |          |0 = TX threshold interrupt Disabled.
S * |        |          |1 = TX threshold interrupt Enabled.
S * |[6]     |RXOV_INTEN|Receive FIFO Overrun Interrupt Enable
S * |        |          |0 = Receive FIFO overrun interrupt Disabled.
S * |        |          |1 = Receive FIFO overrun interrupt Enabled.
S * |[21]    |TIMEOUT_INTEN|Receive FIFO Time-Out Interrupt Enable
S * |        |          |0 = Time-out interrupt Disabled.
S * |        |          |1 = Time-out interrupt Enabled.
S * |[26:24] |RX_THRESHOLD|Receive FIFO Threshold
S * |        |          |If the valid data count of the receive FIFO buffer is larger than the RX_THRESHOLD setting,
S * |        |          |the RX_INTSTS bit will be set to 1, else the RX_INTSTS bit will be cleared to 0.
S * |[30:28] |TX_THRESHOLD|Transmit FIFO Threshold
S * |        |          |If the valid data count of the transmit FIFO buffer is less than or equal to the TX_THRESHOLD
S * |        |          |setting, the TX_INTSTS bit will be set to 1, else the TX_INTSTS bit will be cleared to 0.
S * @var SPI_T::STATUS
S * Offset: 0x44  SPI Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |RX_INTSTS |Receive FIFO Threshold Interrupt Status (Read Only)
S * |        |          |0 = The valid data count within the Rx FIFO buffer is smaller than or equal to the setting value
S * |        |          |of RX_THRESHOLD.
S * |        |          |1 = The valid data count within the receive FIFO buffer is larger than the setting value of
S * |        |          |RX_THRESHOLD.
S * |        |          |Note: If RX_INTEN = 1 and RX_INTSTS = 1, the SPI controller will generate a SPI interrupt
S * |        |          |request.
S * |[2]     |RX_OVERRUN|Receive FIFO Overrun Status
S * |        |          |When the receive FIFO buffer is full, the follow-up data will be dropped and this bit will be
S * |        |          |set to 1.
S * |        |          |Note: This bit will be cleared by writing 1 to itself.
S * |[4]     |TX_INTSTS |Transmit FIFO Threshold Interrupt Status (Read Only)
S * |        |          |0 = The valid data count within the transmit FIFO buffer is larger than the setting value of
S * |        |          |TX_THRESHOLD.
S * |        |          |1 = The valid data count within the transmit FIFO buffer is less than or equal to the setting
S * |        |          |value of TX_THRESHOLD.
S * |        |          |Note: If TX_INTEN = 1 and TX_INTSTS = 1, the SPI controller will generate a SPI interrupt
S * |        |          |request.
S * |[11]    |SLV_START_INTSTS|Slave Start Interrupt Status
S * |        |          |It is used to dedicate if a transaction has started in Slave 3-wire mode.
S * |        |          |It is a mutual mirror bit of SPI_CNTRL2[11].
S * |        |          |0 = Slave has not detected any SPI clock transition since the SSTA_INTEN bit was set to 1.
S * |        |          |1 = A transaction has started in Slave 3-wire mode.
S * |        |          |It will be cleared as a transaction is done or by writing 1 to this bit.
S * |[15:12] |RX_FIFO_COUNT|Receive FIFO Data Count (Read Only)
S * |        |          |This bit field indicates the valid data count of receive FIFO buffer.
S * |[16]    |IF        |SPI Unit Transfer Interrupt Flag
S * |        |          |It is a mutual mirror bit of SPI_CNTRL[16].
S * |        |          |0 = No transaction has been finished since this bit was cleared to 0.
S * |        |          |1 = SPI controller has finished one unit transfer.
S * |        |          |Note: This bit will be cleared by writing 1 to itself.
S * |[20]    |TIMEOUT   |Time-Out Interrupt Flag
S * |        |          |0 = No receive FIFO time-out event.
S * |        |          |1 = Receive FIFO buffer is not empty and no read operation on receive FIFO buffer over 64 SPI
S * |        |          |clock
S * |        |          |period in Master mode or over 576 SPI peripheral clock period in Slave mode.
S * |        |          |When the received FIFO buffer is read by software, the time-out status will be cleared
S * |        |          |automatically.
S * |        |          |Note: This bit will be cleared by writing 1 to itself.
S * |[24]    |RX_EMPTY  |Receive FIFO Buffer Empty Indicator (Read Only)
S * |        |          |It is a mutual mirror bit of SPI_CNTRL[24].
S * |        |          |0 = Receive FIFO buffer is not empty.
S * |        |          |1 = Receive FIFO buffer is empty.
S * |[25]    |RX_FULL   |Receive FIFO Buffer Empty Indicator (Read Only)
S * |        |          |It is a mutual mirror bit of SPI_CNTRL[25].
S * |        |          |0 = Receive FIFO buffer is not empty.
S * |        |          |1 = Receive FIFO buffer is empty.
S * |[26]    |TX_EMPTY  |Transmit FIFO Buffer Empty Indicator (Read Only)
S * |        |          |It is a mutual mirror bit of SPI_CNTRL[26].
S * |        |          |0 = Transmit FIFO buffer is not empty.
S * |        |          |1 = Transmit FIFO buffer is empty.
S * |[27]    |TX_FULL   |Transmit FIFO Buffer Full Indicator (Read Only)
S * |        |          |It is a mutual mirror bit of SPI_CNTRL[27].
S * |        |          |0 = Transmit FIFO buffer is not full.
S * |        |          |1 = Transmit FIFO buffer is full.
S * |[31:28] |TX_FIFO_COUNT|Transmit FIFO Data Count (Read Only)
S * |        |          |This bit field indicates the valid data count of transmit FIFO buffer.
S */
S
S    __IO uint32_t CNTRL;         /* Offset: 0x00  Control and Status Register                                        */
S    __IO uint32_t DIVIDER;       /* Offset: 0x04  Clock Divider Register                                             */
S    __IO uint32_t SSR;           /* Offset: 0x08  Slave Select Register                                              */
S    __I  uint32_t RESERVE0;     
S    __I  uint32_t RX[2];         /* Offset: 0x10  Data Receive Register 0                                            */
S    __I  uint32_t RESERVE1;     
S    __I  uint32_t RESERVE2;     
S    __O  uint32_t TX[2];         /* Offset: 0x14  Data Receive Register 1                                            */
S    __I  uint32_t RESERVE3;     
S    __I  uint32_t RESERVE4;     
S    __I  uint32_t RESERVE5;     
S    __IO uint32_t VARCLK;        /* Offset: 0x20  Data Transmit Register 0                                           */
S    __IO uint32_t DMA;           /* Offset: 0x24  Data Transmit Register 1                                           */
S    __IO uint32_t CNTRL2;        /* Offset: 0x34  Variable Clock Pattern Register                                    */
S    __IO uint32_t FIFO_CTL;      /* Offset: 0x38  SPI DMA Control Register                                           */
S    __IO uint32_t STATUS;        /* Offset: 0x3C  Control and Status Register 2                                      */
S
S} SPI_T;
S
S
S
S/**
S    @addtogroup SPI_CONST SPI Bit Field Definition
S    Constant Definitions for SPI Controller
S@{ */
S
S
S/* SPI_CNTRL Bit Field Definitions */
S#define SPI_CNTRL_TX_FULL_Pos      27                                     /*!< SPI_T::CNTRL: TX_FULL Position */
S#define SPI_CNTRL_TX_FULL_Msk      (1ul << SPI_CNTRL_TX_FULL_Pos)         /*!< SPI_T::CNTRL: TX_FULL Mask     */
S
S#define SPI_CNTRL_TX_EMPTY_Pos     26                                     /*!< SPI_T::CNTRL: TX_EMPTY Position */
S#define SPI_CNTRL_TX_EMPTY_Msk     (1ul << SPI_CNTRL_TX_EMPTY_Pos)        /*!< SPI_T::CNTRL: TX_EMPTY Mask     */
S
S#define SPI_CNTRL_RX_FULL_Pos      25                                     /*!< SPI_T::CNTRL: RX_FULL Position */
S#define SPI_CNTRL_RX_FULL_Msk      (1ul << SPI_CNTRL_RX_FULL_Pos)         /*!< SPI_T::CNTRL: RX_FULL Mask     */
S
S#define SPI_CNTRL_RX_EMPTY_Pos     24                                     /*!< SPI_T::CNTRL: RX_EMPTY Position */
S#define SPI_CNTRL_RX_EMPTY_Msk     (1ul << SPI_CNTRL_RX_EMPTY_Pos)        /*!< SPI_T::CNTRL: RX_EMPTY Mask     */
S
S#define SPI_CNTRL_VARCLK_EN_Pos    23                                     /*!< SPI_T::CNTRL: VARCLK_EN Position */
S#define SPI_CNTRL_VARCLK_EN_Msk    (1ul << SPI_CNTRL_VARCLK_EN_Pos)       /*!< SPI_T::CNTRL: VARCLK_EN Mask     */
S
S#define SPI_CNTRL_TWOB_Pos         22                                     /*!< SPI_T::CNTRL: TWOB Position */
S#define SPI_CNTRL_TWOB_Msk         (1ul << SPI_CNTRL_TWOB_Pos)            /*!< SPI_T::CNTRL: TWOB Mask     */
S
S#define SPI_CNTRL_FIFO_Pos         21                                     /*!< SPI_T::CNTRL: FIFO Position */
S#define SPI_CNTRL_FIFO_Msk         (1ul << SPI_CNTRL_FIFO_Pos)            /*!< SPI_T::CNTRL: FIFO Mask     */
S
S#define SPI_CNTRL_REORDER_Pos      19                                     /*!< SPI_T::CNTRL: REORDER Position */
S#define SPI_CNTRL_REORDER_Msk      (1ul << SPI_CNTRL_REORDER_Pos)         /*!< SPI_T::CNTRL: REORDER Mask     */
S
S#define SPI_CNTRL_SLAVE_Pos        18                                     /*!< SPI_T::CNTRL: SLAVE Position */
S#define SPI_CNTRL_SLAVE_Msk        (1ul << SPI_CNTRL_SLAVE_Pos)           /*!< SPI_T::CNTRL: SLAVE Mask     */
S
S#define SPI_CNTRL_IE_Pos           17                                     /*!< SPI_T::CNTRL: IE Position */
S#define SPI_CNTRL_IE_Msk           (1ul << SPI_CNTRL_IE_Pos)              /*!< SPI_T::CNTRL: IE Mask     */
S
S#define SPI_CNTRL_IF_Pos           16                                     /*!< SPI_T::CNTRL: IF Position */
S#define SPI_CNTRL_IF_Msk           (1ul << SPI_CNTRL_IF_Pos)              /*!< SPI_T::CNTRL: IF Mask     */
S
S#define SPI_CNTRL_SP_CYCLE_Pos     12                                     /*!< SPI_T::CNTRL: SP_CYCLE Position */
S#define SPI_CNTRL_SP_CYCLE_Msk     (0xFul << SPI_CNTRL_SP_CYCLE_Pos)      /*!< SPI_T::CNTRL: SP_CYCLE Mask     */
S
S#define SPI_CNTRL_CLKP_Pos         11                                     /*!< SPI_T::CNTRL: CLKP Position */
S#define SPI_CNTRL_CLKP_Msk         (1ul << SPI_CNTRL_CLKP_Pos)            /*!< SPI_T::CNTRL: CLKP Mask     */
S
S#define SPI_CNTRL_LSB_Pos          10                                     /*!< SPI_T::CNTRL: LSB Position */
S#define SPI_CNTRL_LSB_Msk          (1ul << SPI_CNTRL_LSB_Pos)             /*!< SPI_T::CNTRL: LSB Mask     */
S
S#define SPI_CNTRL_TX_BIT_LEN_Pos   3                                      /*!< SPI_T::CNTRL: TX_BIT_LEN Position */
S#define SPI_CNTRL_TX_BIT_LEN_Msk   (0x1Ful << SPI_CNTRL_TX_BIT_LEN_Pos)   /*!< SPI_T::CNTRL: TX_BIT_LEN Mask     */
S
S#define SPI_CNTRL_TX_NEG_Pos       2                                      /*!< SPI_T::CNTRL: TX_NEG Position */
S#define SPI_CNTRL_TX_NEG_Msk       (1ul << SPI_CNTRL_TX_NEG_Pos)          /*!< SPI_T::CNTRL: TX_NEG Mask     */
S
S#define SPI_CNTRL_RX_NEG_Pos       1                                      /*!< SPI_T::CNTRL: RX_NEG Position */
S#define SPI_CNTRL_RX_NEG_Msk       (1ul << SPI_CNTRL_RX_NEG_Pos)          /*!< SPI_T::CNTRL: RX_NEG Mask     */
S
S#define SPI_CNTRL_GO_BUSY_Pos      0                                      /*!< SPI_T::CNTRL: GO_BUSY Position */
S#define SPI_CNTRL_GO_BUSY_Msk      (1ul << SPI_CNTRL_GO_BUSY_Pos)         /*!< SPI_T::CNTRL: GO_BUSY Mask     */
S
S/* SPI_DIVIDER Bit Field Definitions */
S#define SPI_DIVIDER_DIVIDER2_Pos   16                                     /*!< SPI_T::DIVIDER: DIVIDER2 Position */
S#define SPI_DIVIDER_DIVIDER2_Msk   (0xFFul << SPI_DIVIDER_DIVIDER2_Pos)   /*!< SPI_T::DIVIDER: DIVIDER2 Mask */
S
S#define SPI_DIVIDER_DIVIDER_Pos    0                                      /*!< SPI_T::DIVIDER: DIVIDER Position */
S#define SPI_DIVIDER_DIVIDER_Msk    (0xFFul << SPI_DIVIDER_DIVIDER_Pos)    /*!< SPI_T::DIVIDER: DIVIDER Mask */
S
S/* SPI_SSR Bit Field Definitions */
S#define SPI_SSR_LTRIG_FLAG_Pos     5                                 /*!< SPI_T::SSR: LTRIG_FLAG Position */
S#define SPI_SSR_LTRIG_FLAG_Msk     (1ul << SPI_SSR_LTRIG_FLAG_Pos)   /*!< SPI_T::SSR: LTRIG_FLAG Mask */
S
S#define SPI_SSR_SS_LTRIG_Pos       4                                 /*!< SPI_T::SSR: SS_LTRIG Position */
S#define SPI_SSR_SS_LTRIG_Msk       (1ul << SPI_SSR_SS_LTRIG_Pos)     /*!< SPI_T::SSR: SS_LTRIG Mask */
S
S#define SPI_SSR_AUTOSS_Pos         3                                 /*!< SPI_T::SSR: AUTOSS Position */
S#define SPI_SSR_AUTOSS_Msk         (1ul << SPI_SSR_AUTOSS_Pos)       /*!< SPI_T::SSR: AUTOSS Mask */
S
S#define SPI_SSR_SS_LVL_Pos         2                                 /*!< SPI_T::SSR: SS_LVL Position */
S#define SPI_SSR_SS_LVL_Msk         (1ul << SPI_SSR_SS_LVL_Pos)       /*!< SPI_T::SSR: SS_LVL Mask */
S
S#define SPI_SSR_SSR_Pos            0                                 /*!< SPI_T::SSR: SSR Position */
S#define SPI_SSR_SSR_Msk            (3ul << SPI_SSR_SSR_Pos)          /*!< SPI_T::SSR: SSR Mask */
S
S/* SPI_DMA Bit Field Definitions */
S#define SPI_DMA_PDMA_RST_Pos   2                                     /*!< SPI_T::DMA: PDMA_RST Position */
S#define SPI_DMA_PDMA_RST_Msk   (1ul << SPI_DMA_PDMA_RST_Pos)         /*!< SPI_T::DMA: PDMA_RST Mask */
S
S#define SPI_DMA_RX_DMA_GO_Pos   1                                    /*!< SPI_T::DMA: RX_DMA_GO Position */
S#define SPI_DMA_RX_DMA_GO_Msk   (1ul << SPI_DMA_RX_DMA_GO_Pos)       /*!< SPI_T::DMA: RX_DMA_GO Mask */
S
S#define SPI_DMA_TX_DMA_GO_Pos   0                                    /*!< SPI_T::DMA: TX_DMA_GO Position */
S#define SPI_DMA_TX_DMA_GO_Msk   (1ul << SPI_DMA_TX_DMA_GO_Pos)       /*!< SPI_T::DMA: TX_DMA_GO Mask */
S
S/* SPI_CNTRL2 Bit Field Definitions */
S#define SPI_CNTRL2_BCn_Pos   31                                                      /*!< SPI_T::CNTRL2: BCn Position */
S#define SPI_CNTRL2_BCn_Msk   (1ul << SPI_CNTRL2_BCn_Pos)                             /*!< SPI_T::CNTRL2: BCn Mask */
S
S#define SPI_CNTRL2_SS_INT_OPT_Pos   16                                               /*!< SPI_T::CNTRL2: SS_INT_OPT Position */
S#define SPI_CNTRL2_SS_INT_OPT_Msk   (1ul << SPI_CNTRL2_SS_INT_OPT_Pos)               /*!< SPI_T::CNTRL2: SS_INT_OPT Mask */
S
S#define SPI_CNTRL2_DUAL_IO_EN_Pos   13                                               /*!< SPI_T::CNTRL2: DUAL_IO_EN Position */
S#define SPI_CNTRL2_DUAL_IO_EN_Msk   (1ul << SPI_CNTRL2_DUAL_IO_EN_Pos)               /*!< SPI_T::CNTRL2: DUAL_IO_EN Mask */
S
S#define SPI_CNTRL2_DUAL_IO_DIR_Pos   12                                              /*!< SPI_T::CNTRL2: DUAL_IO_DIR Position */
S#define SPI_CNTRL2_DUAL_IO_DIR_Msk   (1ul << SPI_CNTRL2_DUAL_IO_DIR_Pos)             /*!< SPI_T::CNTRL2: DUAL_IO_DIR Mask */
S
S#define SPI_CNTRL2_SLV_START_INTSTS_Pos   11                                         /*!< SPI_T::CNTRL2: SLV_START_INTSTS Position */
S#define SPI_CNTRL2_SLV_START_INTSTS_Msk   (1ul << SPI_CNTRL2_SLV_START_INTSTS_Pos)   /*!< SPI_T::CNTRL2: SLV_START_INTSTS Mask */
S
S#define SPI_CNTRL2_SSTA_INTEN_Pos   10                                               /*!< SPI_T::CNTRL2: SSTA_INTEN Position */
S#define SPI_CNTRL2_SSTA_INTEN_Msk   (1ul << SPI_CNTRL2_SSTA_INTEN_Pos)               /*!< SPI_T::CNTRL2: SSTA_INTEN Mask */
S
S#define SPI_CNTRL2_SLV_ABORT_Pos    9                                                /*!< SPI_T::CNTRL2: SLV_ABORT Position */
S#define SPI_CNTRL2_SLV_ABORT_Msk    (1ul << SPI_CNTRL2_SLV_ABORT_Pos)                /*!< SPI_T::CNTRL2: SLV_ABORT Mask */
S
S#define SPI_CNTRL2_NOSLVSEL_Pos     8                                                /*!< SPI_T::CNTRL2: NOSLVSEL Position */
S#define SPI_CNTRL2_NOSLVSEL_Msk     (1ul << SPI_CNTRL2_NOSLVSEL_Pos)                 /*!< SPI_T::CNTRL2: NOSLVSEL Mask */
S
S/* SPI_FIFO_CTL Bit Field Definitions */
S#define SPI_FIFO_CTL_TX_THRESHOLD_Pos   28                                         /*!< SPI_T::FIFO_CTL: TX_THRESHOLD Position */
S#define SPI_FIFO_CTL_TX_THRESHOLD_Msk   (7ul << SPI_FIFO_CTL_TX_THRESHOLD_Pos)     /*!< SPI_T::FIFO_CTL: TX_THRESHOLD Mask */
S
S#define SPI_FIFO_CTL_RX_THRESHOLD_Pos   24                                         /*!< SPI_T::FIFO_CTL: RX_THRESHOLD Position */
S#define SPI_FIFO_CTL_RX_THRESHOLD_Msk   (7ul << SPI_FIFO_CTL_RX_THRESHOLD_Pos)     /*!< SPI_T::FIFO_CTL: RX_THRESHOLD Mask */
S
S#define SPI_FIFO_CTL_TIMEOUT_INTEN_Pos   21                                        /*!< SPI_T::FIFO_CTL: TIMEOUT_INTEN Position */
S#define SPI_FIFO_CTL_TIMEOUT_INTEN_Msk   (1ul << SPI_FIFO_CTL_TIMEOUT_INTEN_Pos)   /*!< SPI_T::FIFO_CTL: TIMEOUT_INTEN Mask */
S
S#define SPI_FIFO_CTL_RXOV_INTEN_Pos    6                                           /*!< SPI_T::FIFO_CTL: RXOV_INTEN Position */
S#define SPI_FIFO_CTL_RXOV_INTEN_Msk    (1ul << SPI_FIFO_CTL_RXOV_INTEN_Pos)        /*!< SPI_T::FIFO_CTL: RXOV_INTEN Mask */
S
S#define SPI_FIFO_CTL_TX_INTEN_Pos    3                                             /*!< SPI_T::FIFO_CTL: TX_INTEN Position */
S#define SPI_FIFO_CTL_TX_INTEN_Msk    (1ul << SPI_FIFO_CTL_TX_INTEN_Pos)            /*!< SPI_T::FIFO_CTL: TX_INTEN Mask */
S
S#define SPI_FIFO_CTL_RX_INTEN_Pos    2                                             /*!< SPI_T::FIFO_CTL: RX_INTEN Position */
S#define SPI_FIFO_CTL_RX_INTEN_Msk    (1ul << SPI_FIFO_CTL_RX_INTEN_Pos)            /*!< SPI_T::FIFO_CTL: RX_INTEN Mask */
S
S#define SPI_FIFO_CTL_TX_CLR_Pos     1                                              /*!< SPI_T::FIFO_CTL: TX_CLR Position */
S#define SPI_FIFO_CTL_TX_CLR_Msk     (1ul << SPI_FIFO_CTL_TX_CLR_Pos)               /*!< SPI_T::FIFO_CTL: TX_CLR Mask */
S
S#define SPI_FIFO_CTL_RX_CLR_Pos      0                                             /*!< SPI_T::FIFO_CTL: RX_CLR Position */
S#define SPI_FIFO_CTL_RX_CLR_Msk      (1ul << SPI_FIFO_CTL_RX_CLR_Pos)              /*!< SPI_T::FIFO_CTL: RX_CLR Mask */
S
S/* SPI_STATUS Bit Field Definitions */
S#define SPI_STATUS_TX_FIFO_COUNT_Pos   28                                            /*!< SPI_T::STATUS: TX_FIFO_COUNT Position */
S#define SPI_STATUS_TX_FIFO_COUNT_Msk   (0xFul << SPI_STATUS_TX_FIFO_COUNT_Pos)       /*!< SPI_T::STATUS: TX_FIFO_COUNT Mask */
S
S#define SPI_STATUS_TX_FULL_Pos   27                                                  /*!< SPI_T::STATUS: TX_FULL Position */
S#define SPI_STATUS_TX_FULL_Msk   (1ul << SPI_STATUS_TX_FULL_Pos)                     /*!< SPI_T::STATUS: TX_FULL Mask */
S
S#define SPI_STATUS_TX_EMPTY_Pos   26                                                 /*!< SPI_T::STATUS: TX_EMPTY Position */
S#define SPI_STATUS_TX_EMPTY_Msk   (1ul << SPI_STATUS_TX_EMPTY_Pos)                   /*!< SPI_T::STATUS: TX_EMPTY Mask */
S
S#define SPI_STATUS_RX_FULL_Pos   25                                                  /*!< SPI_T::STATUS: RX_FULL Position */
S#define SPI_STATUS_RX_FULL_Msk   (1ul << SPI_STATUS_RX_FULL_Pos)                     /*!< SPI_T::STATUS: RX_FULL Mask */
S
S#define SPI_STATUS_RX_EMPTY_Pos   24                                                 /*!< SPI_T::STATUS: RX_EMPTY Position */
S#define SPI_STATUS_RX_EMPTY_Msk   (1ul << SPI_STATUS_RX_EMPTY_Pos)                   /*!< SPI_T::STATUS: RX_EMPTY Mask */
S
S#define SPI_STATUS_TIMEOUT_Pos   20                                                  /*!< SPI_T::STATUS: TIMEOUT Position */
S#define SPI_STATUS_TIMEOUT_Msk   (1ul << SPI_STATUS_TIMEOUT_Pos)                     /*!< SPI_T::STATUS: TIMEOUT Mask */
S
S#define SPI_STATUS_IF_Pos   16                                                       /*!< SPI_T::STATUS: IF Position */
S#define SPI_STATUS_IF_Msk   (1ul << SPI_STATUS_IF_Pos)                               /*!< SPI_T::STATUS: IF Mask     */
S
S#define SPI_STATUS_RX_FIFO_COUNT_Pos   12                                            /*!< SPI_T::STATUS: RX_FIFO_COUNT Position */
S#define SPI_STATUS_RX_FIFO_COUNT_Msk   (0xFul << SPI_STATUS_RX_FIFO_COUNT_Pos)       /*!< SPI_T::STATUS: RX_FIFO_COUNT Mask */
S
S#define SPI_STATUS_SLV_START_INTSTS_Pos   11                                         /*!< SPI_T::STATUS: SLV_START_INTSTS Position */
S#define SPI_STATUS_SLV_START_INTSTS_Msk   (1ul << SPI_STATUS_SLV_START_INTSTS_Pos)   /*!< SPI_T::STATUS: SLV_START_INTSTS Mask */
S
S#define SPI_STATUS_TX_INTSTS_Pos   4                                                 /*!< SPI_T::STATUS: TX_INTSTS Position */
S#define SPI_STATUS_TX_INTSTS_Msk   (1ul << SPI_STATUS_TX_INTSTS_Pos)                 /*!< SPI_T::STATUS: TX_INTSTS Mask */
S
S#define SPI_STATUS_RX_OVERRUN_Pos   2                                                /*!< SPI_T::STATUS: RX_OVERRUN Position */
S#define SPI_STATUS_RX_OVERRUN_Msk   (1ul << SPI_STATUS_RX_OVERRUN_Pos)               /*!< SPI_T::STATUS: RX_OVERRUN Mask */
S
S#define SPI_STATUS_RX_INTSTS_Pos   0                                                 /*!< SPI_T::STATUS: RX_INTSTS Position */
S#define SPI_STATUS_RX_INTSTS_Msk   (1ul << SPI_STATUS_RX_INTSTS_Pos)                 /*!< SPI_T::STATUS: RX_INTSTS Mask */
S/*@}*/ /* end of group SPI_CONST */
S/*@}*/ /* end of group SPI */
S
S
S
S
S/*---------------------- System Manger Controller -------------------------*/
S/**
S    @addtogroup SYS System Manger Controller (SYS)
S    Memory Mapped Structure for SYS Controller
S@{ */
S
S
S
Stypedef struct
S{
S
S
S
S/**
S * @var GCR_T::PDID
S * Offset: 0x00  Part Device Identification Number Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |PDID      |Part Device Identification Number
S * |        |          |This register reflects device part number code.
S * |        |          |Software can read this register to identify which device is used.
S * @var GCR_T::RSTSRC
S * Offset: 0x04  System Reset Source Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |RSTS_POR  |Power-on Reset Flag
S * |        |          |The RSTS_POR flag is set by the "reset signal" from the Power-On Reset (POR) controller or bit
S * |        |          |CHIP_RST (IPRSTC1[0]) to indicate the previous reset source.
S * |        |          |0 = No reset from POR or CHIP_RST (IPRSTC1[0]).
S * |        |          |1 = Power-on Reset (POR) or CHIP_RST (IPRSTC1[0]) had issued the reset signal to reset the
S * |        |          |system.
S * |        |          |Note: Write 1 to clear this bit to 0.
S * |[1]     |RSTS_RESET|Reset Pin Reset Flag
S * |        |          |The RSTS_RESET flag is set by the "Reset Signal" from the /RESET pin to indicate the previous
S * |        |          |reset source.
S * |        |          |0 = No reset from /RESET pin.
S * |        |          |1 = The Pin /RESET had issued the reset signal to reset the system.
S * |        |          |Note: Write 1 to clear this bit to 0.
S * |[2]     |RSTS_WDT  |Watchdog Reset Flag
S * |        |          |The RSTS_WDT flag is set by The "Reset Signal" from the Watchdog Timer to indicate the previous
S * |        |          |reset source
S * |        |          |0 = No reset from watchdog timer.
S * |        |          |1 = The watchdog timer had issued the reset signal to reset the system.
S * |        |          |Note: Write 1 to clear this bit to 0.
S * |[3]     |RSTS_LVR  |Low Voltage Reset Flag
S * |        |          |The RSTS_LVR flag Is Set By The "Reset Signal" From The Low-Voltage-Reset Controller To Indicate
S * |        |          |The Previous Reset Source
S * |        |          |0 = No reset from LVR.
S * |        |          |1 = The LVR controller had issued the reset signal to reset the system.
S * |        |          |Note: Write 1 to clear this bit to 0.
S * |[4]     |RSTS_BOD  |Brown-out Detector Reset Flag
S * |        |          |The RSTS_BOD flag is set by the "Reset Signal" from the Brown-Out Detector to indicate the
S * |        |          |previous reset source.
S * |        |          |0 = No reset from BOD.
S * |        |          |1 = The BOD had issued the reset signal to reset the system.
S * |        |          |Note: Write 1 to clear this bit to 0.
S * |[5]     |RSTS_SYS  |System Reset Flag
S * |        |          |The RSTS_SYS flag is set by the "Reset Signal" from the Cortex-M0 kernel to indicate the
S * |        |          |previous reset source.
S * |        |          |0 = No reset from Cortex-M0.
S * |        |          |1 = The Cortex-M0 had issued the reset signal to reset the system by writing 1 to bit
S * |        |          |SYSRESETREQ (AIRCR[2], Application Interrupt and Reset Control Register, address = 0xE000ED0C)
S * |        |          |in system control registers of Cortex-M0 kernel.
S * |        |          |Note: Write 1 to clear this bit to 0.
S * |[7]     |RSTS_CPU  |CPU Reset Flag
S * |        |          |The RSTS_CPU flag is set by hardware if software writes CPU_RST (IPRSTC1[1]) 1 to reset
S * |        |          |Cortex-M0 CPU kernel and flash. Memory Controller (FMC)
S * |        |          |0 = No reset from CPU.
S * |        |          |1 = Cortex-M0 CPU kernel and FMC are reset by software setting CPU_RST(IPRSTC1[1]) to 1.
S * |        |          |Note: Write 1 to clear this bit to 0.
S * @var GCR_T::IPRSTC1
S * Offset: 0x08  IP Reset Control Register 1
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |CHIP_RST  |CHIP One-Shot Reset (Write Protect)
S * |        |          |Setting this bit will reset the whole chip, including CPU kernel and all peripherals, and this
S * |        |          |bit will automatically return to 0 after the 2 clock cycles.
S * |        |          |The CHIP_RST is the same as the POR reset, all the chip controllers are reset and the chip
S * |        |          |setting from flash are also reload.
S * |        |          |0 = CHIP normal operation.
S * |        |          |1 = CHIP one-shot reset.
S * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register.
S * |[1]     |CPU_RST   |CPU Kernel One-Shot Reset (Write Protect)
S * |        |          |Setting this bit will only reset the CPU kernel and Flash Memory Controller(FMC), and this bit
S * |        |          |will automatically return 0 after the two clock cycles.
S * |        |          |0 = CPU normal operation.
S * |        |          |1 = CPU one-shot reset.
S * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register.
S * |[2]     |PDMA_RST  |PDMA Controller Reset (Write Protect)
S * |        |          |Setting this bit to 1 will generate a reset signal to the PDMA.
S * |        |          |User need to set this bit to 0 to release from reset state.
S * |        |          |0 = PDMA controller normal operation.
S * |        |          |1 = PDMA controller reset.
S * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register.
S * |[3]     |EBI_RST   |EBI Controller Reset (Write Protect)
S * |        |          |Setting this bit to 1 will generate a reset signal to the EBI.
S * |        |          |User need to set this bit to 0 to release from reset state.
S * |        |          |0 = EBI controller normal operation.
S * |        |          |1 = EBI controller reset.
S * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register.
S * @var GCR_T::IPRSTC2
S * Offset: 0x0C  IP Reset Control Register 2
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[1]     |GPIO_RST  |GPIO Controller Reset
S * |        |          |0 = GPIO controller normal operation.
S * |        |          |1 = GPIO controller reset.
S * |[2]     |TMR0_RST  |Timer0 Controller Reset
S * |        |          |0 = Timer0 controller normal operation.
S * |        |          |1 = Timer0 controller reset.
S * |[3]     |TMR1_RST  |Timer1 Controller Reset
S * |        |          |0 = Timer1 controller normal operation.
S * |        |          |1 = Timer1 controller reset.
S * |[4]     |TMR2_RST  |Timer2 Controller Reset
S * |        |          |0 = Timer2 controller normal operation.
S * |        |          |1 = Timer2 controller reset.
S * |[5]     |TMR3_RST  |Timer3 Controller Reset
S * |        |          |0 = Timer3 controller normal operation.
S * |        |          |1 = Timer3 controller reset.
S * |[8]     |I2C0_RST  |I2C0 Controller Reset
S * |        |          |0 = I2C0 controller normal operation.
S * |        |          |1 = I2C0 controller reset.
S * |[9]     |I2C1_RST  |I2C1 Controller Reset
S * |        |          |0 = I2C1 controller normal operation.
S * |        |          |1 = I2C1 controller reset.
S * |[12]    |SPI0_RST  |SPI0 Controller Reset
S * |        |          |0 = SPI0 controller normal operation.
S * |        |          |1 = SPI0 controller reset.
S * |[13]    |SPI1_RST  |SPI1 Controller Reset
S * |        |          |0 = SPI1 controller normal operation.
S * |        |          |1 = SPI1 controller reset.
S * |[14]    |SPI2_RST  |SPI2 Controller Reset
S * |        |          |0 = SPI2 controller normal operation.
S * |        |          |1 = SPI2 controller reset.
S * |[15]    |SPI3_RST  |SPI3 Controller Reset
S * |        |          |0 = SPI3 controller normal operation.
S * |        |          |1 = SPI3 controller reset.
S * |[16]    |UART0_RST |UART0 Controller Reset
S * |        |          |0 = UART0 controller normal operation.
S * |        |          |1 = UART0 controller reset.
S * |[17]    |UART1_RST |UART1 Controller Reset
S * |        |          |0 = UART1 controller normal operation.
S * |        |          |1 = UART1 controller reset.
S * |[18]    |UART2_RST |UART2 Controller Reset
S * |        |          |0 = UART2 controller normal operation.
S * |        |          |1 = UART2 controller reset.
S * |[20]    |PWM03_RST |PWM03 Controller Reset
S * |        |          |0 = PWM03 controller normal operation.
S * |        |          |1 = PWM03 controller reset.
S * |[21]    |PWM47_RST |PWM47 Controller Reset
S * |        |          |0 = PWM47 controller normal operation.
S * |        |          |1 = PWM47 controller reset.
S * |[22]    |ACMP_RST  |Analog Comparator Controller Reset
S * |        |          |0 = Analog Comparator controller normal operation.
S * |        |          |1 = Analog Comparator controller reset.
S * |[23]    |PS2_RST   |PS/2 Controller Reset
S * |        |          |0 = PS/2 controller normal operation.
S * |        |          |1 = PS/2 controller reset.
S * |[24]    |CAN0_RST  |CAN0 Controller Reset
S * |        |          |0 = CAN0 controller normal operation.
S * |        |          |1 = CAN0 controller reset.
S * |[25]    |CAN1_RST  |CAN1 Controller Reset
S * |        |          |0 = CAN1 controller normal operation.
S * |        |          |1 = CAN1 controller reset.
S * |[27]    |USBD_RST  |USB Device Controller Reset
S * |        |          |0 = USB device controller normal operation.
S * |        |          |1 = USB device controller reset.
S * |[28]    |ADC_RST   |ADC Controller Reset
S * |        |          |0 = ADC controller normal operation.
S * |        |          |1 = ADC controller reset.
S * |[29]    |I2S_RST   |I2S Controller Reset
S * |        |          |0 = I2S controller normal operation.
S * |        |          |1 = I2S controller reset.
S * @var GCR_T::IPRSTC3
S * Offset: 0x10  IP Reset Control Register 3
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |SC0_RST   |SC0 Controller Reset
S * |        |          |0 = SC0 controller normal operation.
S * |        |          |1 = SC0 controller reset.
S * |[1]     |SC1_RST   |SC1 Controller Reset
S * |        |          |0 = SC1 controller normal operation.
S * |        |          |1 = SC1 controller reset.
S * |[2]     |SC2_RST   |SC2 Controller Reset
S * |        |          |0 = SC2 controller normal operation.
S * |        |          |1 = SC2 controller reset.
S * @var GCR_T::BODCR
S * Offset: 0x18  Brown-out Detector Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |BOD_EN    |Brown-Out Detector Enable Bit (Write Protect)
S * |        |          |The default value is set by flash memory controller user configuration register CBODEN
S * |        |          |(Config0[23]) bit.
S * |        |          |0 = Brown-out Detector function Disabled.
S * |        |          |1 = Brown-out Detector function Enabled.
S * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register.
S * |[2:1]   |BOD_VL    |Brown-Out Detector Threshold Voltage Selection (Write Protect)
S * |        |          |The default value is set by flash controller user configuration register CBOV (Config0[22:21])
S * |        |          |bit.
S * |        |          |00 = Brown-out voltage is 2.2V.
S * |        |          |01 = Brown-out voltage is 2.7V.
S * |        |          |10 = Brown-out voltage is 3.7V.
S * |        |          |11 = Brown-out voltage is 4.4V.
S * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register.
S * |[3]     |BOD_RSTEN |Brown-out Reset Enable Control (Write Protect)
S * |        |          |0 = Brown-out "INTERRUPT" function Enabled.
S * |        |          |While the BOD function is enabled (BOD_EN high) and BOD interrupt function is enabled (BOD_RSTEN
S * |        |          |low), BOD will assert an interrupt if BOD_OUT is high.
S * |        |          |BOD interrupt will keep till to the BOD_EN set to 0. BOD interrupt can be blocked by disabling
S * |        |          |the NVIC BOD interrupt or disabling BOD function (set BOD_EN low).
S * |        |          |1 = Brown-out "RESET" function Enabled.
S * |        |          |Note1: While the Brown-out Detector function is enabled (BOD_EN high) and BOD reset function is
S * |        |          |enabled (BOD_RSTEN high), BOD will assert a signal to reset chip when the detected voltage is
S * |        |          |lower than the threshold (BOD_OUT high).
S * |        |          |Note2: The default value is set by flash controller user configuration register CBORST
S * |        |          |(Config0[20]) bit.
S * |        |          |Note3: This bit is write protected bit. Refer to the REGWRPROT register.
S * |[4]     |BOD_INTF  |Brown-out Detector Interrupt Flag
S * |        |          |0 = Brown-out Detector does not detect any voltage draft at VDD down through or up through the
S * |        |          |voltage of BOD_VL setting.
S * |        |          |1 = When Brown-out Detector detects the VDD is dropped down through the voltage of BOD_VL
S * |        |          |setting or the VDD is raised up through the voltage of BOD_VL setting, this bit is set to 1 and
S * |        |          |the Brown-out interrupt is requested if Brown-out interrupt is enabled.
S * |        |          |Note: Write 1 to clear this bit to 0.
S * |[5]     |BOD_LPM   |Brown-out Detector Low Power Mode (Write Protection)
S * |        |          |0 = BOD operated in Normal mode (default).
S * |        |          |1 = BOD Low Power mode Enabled.
S * |        |          |Note1: The BOD consumes about 100 uA in Normal mode, and the low power mode can reduce the
S * |        |          |current to about 1/10 but slow the BOD response.
S * |        |          |Note2: This bit is write protected bit. Refer to the REGWRPROT register.
S * |[6]     |BOD_OUT   |Brown-out Detector Output Status
S * |        |          |0 = Brown-out Detector output status is 0. It means the detected voltage is higher than BOD_VL
S * |        |          |setting or BOD_EN is 0.
S * |        |          |1 = Brown-out Detector output status is 1. It means the detected voltage is lower than BOD_VL
S * |        |          |setting. If the BOD_EN is 0, BOD function disabled, this bit always responds to 0.
S * |[7]     |LVR_EN    |Low Voltage Reset Enable Bit (Write Protect)
S * |        |          |The LVR function reset the chip when the input power voltage is lower than LVR circuit setting.
S * |        |          |LVR function is enabled by default.
S * |        |          |0 = Low Voltage Reset function Disabled.
S * |        |          |1 = Low Voltage Reset function Enabled - After enabling the bit, the LVR function will be active
S * |        |          |with 100us delay for LVR output stable (default).
S * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register.
S * @var GCR_T::TEMPCR
S * Offset: 0x1C  Temperature Sensor Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |VTEMP_EN  |Temperature Sensor Enable Control
S * |        |          |This bit is used to enable/disable temperature sensor function.
S * |        |          |0 = Temperature sensor function Disabled (default).
S * |        |          |1 = Temperature sensor function Enabled.
S * |        |          |Note: After this bit is set to 1, the value of temperature can be obtained from ADC conversion
S * |        |          |result by ADC channel selecting channel 7 and alternative multiplexer channel selecting
S * |        |          |temperature sensor.
S * |        |          |Please refer to the ADC function chapter for detail ADC conversion functional description.
S * @var GCR_T::PORCR
S * Offset: 0x24  Power-on-Reset Controller Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |POR_DIS_CODE|Power-on Reset Enable Control (Write Protect)
S * |        |          |When powered on, the POR circuit generates a reset signal to reset the whole chip function, but
S * |        |          |noise on the power may cause the POR active again.
S * |        |          |User can disable internal POR circuit to avoid unpredictable noise to cause chip reset by
S * |        |          |writing 0x5AA5 to this field.
S * |        |          |The POR function will be active again when this field is set to another value or chip is reset
S * |        |          |by other reset source, including:
S * |        |          |nRESET, Watchdog, LVR reset, BOD reset, ICE reset command and the software-chip reset function.
S * |        |          |Note: These bits are write protected bit. Refer to the REGWRPROT register.
S * @var GCR_T::GPA_MFP
S * Offset: 0x30  GPIOA Multiple Function and Input Type Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |GPA_MFP0  |PA.0 Pin Function Selection
S * |        |          |Bit PA0_SC0PWR (ALT_MFP1[2]) and GPA_MFP[0] determine the PA.0 function.
S * |        |          |(PA0_SC0PWR, GPA_MFP0) value and function mapping is as following list.
S * |        |          |(0, 0) = GPIO function is selected.
S * |        |          |(0, 1) = ADC0 function is selected.
S * |        |          |(1, 1) = SC0_PWR function is selected.  
S * |[1]     |GPA_MFP1  |PA.1 Pin Function Selection
S * |        |          |Bit EBI_HB_EN[4] (ALT_MFP[20]), EBI_EN (ALT_MFP[11]), PA1_SC0RST (ALT_MFP1[3]) and GPA_MFP[1]
S * |        |          |determine the PA.1 function.
S * |        |          |(EBI_HB_EN[4], EBI_EN, PA1_SC0RST, GPA_MFP1) value and function mapping is as following list.
S * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 0, 1) = ADC1 function is selected.
S * |        |          |(0, 0, 1, 1) = SC0_RST function is selected.
S * |        |          |(1, 1, 0, 1) = AD12 function is selected.          
S * |[2]     |GPA_MFP2  |PA.2 Pin Function Selection
S * |        |          |Bits EBI_HB_EN[3] (ALT_MFP[19]), EBI_EN (ALT_MFP[11]), PA2_SC0CLK (ALT_MFP1[0]) and GPA_MFP[2]
S * |        |          |determine the PA.2 function.
S * |        |          |(EBI_HB_EN[3], EBI_EN, PA2_SC0CLK, GPA_MFP2) value and function mapping is as following list.
S * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 0, 1) = ADC2 function is selected.
S * |        |          |(0, 0, 1, 1) = SC0_CLK/UART3_TXD function is selected.
S * |        |          |(1, 1, 0, 1) = AD11 function is selected.         
S * |[3]     |GPA_MFP3  |PA.3 Pin Function Selection   
S * |        |          |Bits EBI_HB_EN[2] (ALT_MFP[18]), EBI_EN (ALT_MFP[11]), PA3_SC0DAT (ALT_MFP1[1]) and GPA_MFP[3]
S * |        |          |determine the PA.3 function.
S * |        |          |(EBI_HB_EN[2], EBI_EN, PA3_SC0DAT, GPA_MFP3) value and function mapping is as following list.
S * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 0, 1) = ADC3 function is selected.
S * |        |          |(0, 0, 1, 1) = SC0_DAT/UART3_RXD function is selected.
S * |        |          |(1, 1, 0, 1) = AD10 function is selected.
S * |[4]     |GPA_MFP4  |PA.4 Pin Function Selection     
S * |        |          |Bits EBI_HB_EN[1] (ALT_MFP[17]), EBI_EN (ALT_MFP[11]), PA4_SC1PWR (ALT_MFP1[7]) and GPA_MFP[4]
S * |        |          |determine the PA.4 function.
S * |        |          |(EBI_HB_EN[1], EBI_EN, PA4_SC1PWR, GPA_MFP4) value and function mapping is as following list.
S * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 0, 1) = ADC4 function is selected.
S * |        |          |(0, 0, 1, 1) = SC1_PWR function is selected.
S * |        |          |(1, 1, 0, 1) = AD9 function is selected.     
S * |[5]     |GPA_MFP5  |PA.5 Pin Function Selection    
S * |        |          |Bits EBI_HB_EN[0] (ALT_MFP[16]), EBI_EN (ALT_MFP[11]),PA5_SC1RST (ALT_MFP1[8]) and GPA_MFP[5]
S * |        |          |determine the PA.5 function.
S * |        |          |(EBI_HB_EN[0], EBI_EN, PA5_SC1RST, GPA_MFP5) value and function mapping is as following list,
S * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 0, 1) = ADC5 function is selected.
S * |        |          |(0, 0, 1, 1) = SC1_RST function is selected.
S * |        |          |(1, 1, 0, 1) = AD8 function is selected.     
S * |[6]     |GPA_MFP6  |PA.6 Pin Function Selection
S * |        |          |Bits EBI_EN (ALT_MFP[11]), PA6_SC1CLK (ALT_MFP1[5]) and GPA_MFP[6] determine the PA.6 function.
S * |        |          |(EBI_EN, PA6_SC1CLK, GPA_MFP6) value and function mapping is as following list.
S * |        |          |(0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 1) = ADC6 function is selected.
S * |        |          |(0, 1, 1) = SC1_CLK/UART4_TXD function is selected.
S * |        |          |(1, 0, 1) = AD7 function is selected.     
S * |[7]     |GPA_MFP7  |PA.7 Pin Function Selection
S * |        |          |Bits EBI_EN (ALT_MFP[11]), PA7_SC1DAT (ALT_MFP1[6]), PA7_S21 (ALT_MFP[2]) and GPA_MFP[7]
S * |        |          |determine the PA.7 function.
S * |        |          |(EBI_EN, PA7_SC1DAT, PA7_S21, GPA_MFP7) value and function mapping is as following list.
S * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 0, 1) = ADC7 function is selected.
S * |        |          |(0, 0, 1, 1) = SPI2_SS1 function is selected.
S * |        |          |(0, 1, 0, 1) = SC1_DAT/UART4_RXD function is selected.
S * |        |          |(1, 0, 0, 1) = AD6 function is selected.     
S * |[8]     |GPA_MFP8  |PA.8 Pin Function Selection
S * |        |          |Bit GPA_MFP[8] determines the PA.8 function.
S * |        |          |0 = GPIO function is selected to the pin PA.8.
S * |        |          |1 = I2C0_SDA function is selected to the pin PA.8.
S * |[10]    |GPA_MFP9  |PA.9 Pin Function Selection
S * |        |          |Bit GPA_MFP[9] determines the PA.9 function.
S * |        |          |0 = GPIO function is selected.
S * |        |          |1 = I2C0_SCL function is selected.
S * |[10]    |GPA_MFP10 |PA.10 Pin Function Selection
S * |        |          |Bits EBI_EN (ALT_MFP[11]), PA10_11_CAN1 (ALT_MFP[28]) and GPA_MFP[10] determine the PA.10
S * |        |          |function.
S * |        |          |(EBI_EN, PA10_11_CAN1, GPA_MFP10) value and function mapping is as following list.
S * |        |          |(0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 1) = I2C1_SDA function is selected.
S * |        |          |(0, 1, 1) = CAN1_TXD function is selected.
S * |        |          |(1, 0, 1) =nWR(EBI) function is selected.     
S * |[11]    |GPA_MFP11 |PA.11 Pin Function Selection
S * |        |          |Bits EBI_EN (ALT_MFP[11]), PA10_11_CAN1 (ALT_MFP[28]) and GPA_MFP[11] determine the PA.11
S * |        |          |function.
S * |        |          |(EBI_EN, PA10_11_CAN1, GPA_MFP11) value and function mapping is as following list.
S * |        |          |(0,0, 0) = GPIO function is selected.
S * |        |          |(0,0, 1) = I2C1_SCL function is selected.
S * |        |          |(0, 1, 1) = CAN1_RXD function is selected.
S * |        |          |(1, 0, 1) = nRD(EBI) function is selected.     
S * |[12]    |GPA_MFP12 |PA.12 Pin Function Selection
S * |        |          |Bits EBI_HB_EN[5] (ALT_MFP[21]), EBI_EN (ALT_MFP[11]), PA12_SC2DAT (ALT_MFP1[11]) and
S * |        |          |GPA_MFP[12] determine the PA.12 function.
S * |        |          |(EBI_HB_EN[5], EBI_EN, PA12_SC2DAT, GPA_MFP12) value and function mapping is as following list.
S * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 0, 1) = PWM0 function is selected.
S * |        |          |(0, 0, 1, 1) = SC2_DAT/UART5_RXD function is selected.
S * |        |          |(1, 1, 0, 1) = AD13 function is selected.       
S * |[13]    |GPA_MFP13 |PA.13 Pin Function Selection     
S * |        |          |Bits EBI_HB_EN[6] (ALT_MFP[22]), EBI_EN (ALT_MFP[11]), PA13_SC2CLK (ALT_MFP1[10]) and
S * |        |          |GPA_MFP[13] determine the PA.13 function.
S * |        |          |(EBI_HB_EN[6], EBI_EN, PA13_SC2CLK, GPA_MFP13) value and function mapping is as following list.
S * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 0, 1) = PWM1 function is selected.
S * |        |          |(0, 0, 1, 1) = SC2_CLK/UART5_TXD function is selected.
S * |        |          |(1, 1, 0, 1) = AD14 function is selected.        
S * |[14]    |GPA_MFP14 |PA.14 Pin Function Selection
S * |        |          |Bits EBI_HB_EN[7] (ALT_MFP[23]), EBI_EN (ALT_MFP[11]), PA14_SC2RST (ALT_MFP1[13]) and
S * |        |          |GPA_MFP[14] determine the PA.14 function.
S * |        |          |(EBI_HB_EN , EBI_EN, PA14_SC2RST, GPA_MFP14) value and function mapping is as following list.
S * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 0, 1) = PWM2 function is selected.
S * |        |          |(0, 0, 1, 1) = SC2_RST function is selected.
S * |        |          |(1, 1, 0, 1) = AD15 function is selected.        
S * |[15]    |GPA_MFP15 |PA.15 Pin Function Selection     
S * |        |          |Bits PA15_SC2PWR (ALT_MFP1[12]), PA15_I2SMCLK (ALT_MFP[9]) and GPA_MFP[15] determine the PA.15
S * |        |          |function.
S * |        |          |(PA15_SC2PWR, PA15_I2SMCLK, GPA_MFP15) value and function mapping is as following list.
S * |        |          |(0, 0, 0) = GPIOA function is selected.
S * |        |          |(0, 0, 1) = PWM3 function is selected.
S * |        |          |(0, 1, 1) = I2S_MCLK function is selected.
S * |        |          |(1, 0, 1) = SC2_PWR function is selected.         
S * |[31:16] |GPA_TYPEn |Trigger Function Selection
S * |        |          |0 = GPIOA[15:0] I/O input Schmitt Trigger function Disabled.
S * |        |          |1 = GPIOA[15:0] I/O input Schmitt Trigger function Enabled.
S * @var GCR_T::GPB_MFP
S * Offset: 0x34  GPIOB Multiple Function and Input Type Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |GPB_MFP0  |PB.0 Pin Function Selection     
S * |        |          |Bit GPB_MFP[0] determines the PB.0 function.
S * |        |          |0 = GPIO function is selected to the pin PB.0.
S * |        |          |1 = UART0_RXD function is selected to the pin PB.0.       
S * |[1]     |GPB_MFP1  |PB.1 Pin Function Selection
S * |        |          |Bit GPB_MFP[1] determines the PB.1 function.
S * |        |          |0 = GPIO function is selected to the pin PB.1.
S * |        |          |1 = UART0_TXD function is selected to the pin PB.1.     
S * |[2]     |GPB_MFP2  |PB.2 Pin Function Selection
S * |        |          |Bits EBI_nWRL_EN (ALT_MFP[13]), EBI_EN (ALT_MFP[11]), PB2_TM2 (ALT_MFP2[4]), PB2_CPO0
S * |        |          |(ALT_MFP[30]), PB2_T2EX (ALT_MFP[26]) and GPB_MFP[2] determine the PB.2 function.
S * |        |          |(EBI_nWRL_EN, EBI_EN, PB2_TM2, PB2_CPO0, PB2_T2EX, GPB_MFP2) value and function mapping is as
S * |        |          |following list.
S * |        |          |(0, 0, 0, 0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 0, 0, 0, 1) = UART0_nRTS function is selected.
S * |        |          |(0, 0, 0, 0, 1, 1) = TM2_EXT function is selected.
S * |        |          |(0, 0, 0, 1, 0, 1) = ACMP0_O function is selected.
S * |        |          |(0, 0, 1, 0, 0, 1) = TM2 function is selected.
S * |        |          |(1, 1, 0, 0, 0, 1) = nWRL(EBI) function is selected.     
S * |[3]     |GPB_MFP3  |PB.3 Pin Function Selection
S * |        |          |PB3_SC2CD (ALT_MFP1[14]), PB3_T3EX (ALT_MFP[27]) and GPB_MFP[3] determine the PB.3 function.
S * |        |          |(EBI_nWRH_EN, EBI_EN, PB3_TM3, PB3_SC2CD, PB3_T3EX, GPB_MFP3) value and function mapping is as
S * |        |          |following list.
S * |        |          |(0, 0, 0, 0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 0, 0, 0, 1) = UART0_nCTS function is selected.
S * |        |          |(0, 0, 0, 0, 1, 1) = TM3_EXT function is selected.
S * |        |          |(0, 0, 0, 1, 0, 1) = SC2_CD function is selected.
S * |        |          |(0, 0, 1, 0, 0, 1) = TM3 function is selected.
S * |        |          |(1, 1, 0, 0, 0, 1) = nWRH(EBI) function is selected.              
S * |[4]     |GPB_MFP4  |PB.4 Pin Function Selection
S * |        |          |Bit GPB_MFP[4] determines the PB.4 function.
S * |        |          |0 = GPIO function is selected to the pin PB.4.
S * |        |          |1 = UART1_RXD function is selected to the pin PB.4.     
S * |[5]     |GPB_MFP5  |PB 5 Pin Function Selection
S * |        |          |Bit GPB_MFP[5] determines the PB.5 function.
S * |        |          |0 = GPIO function is selected to the pin PB.5.
S * |        |          |1 = UART1_TXD function is selected to the pin PB.5.     
S * |[6]     |GPB_MFP6  |PB.6 Pin Function Selection 
S * |        |          |Bit EBI_EN (ALT_MFP[11]), GPB_MFP[6] determines the PB.6 function.
S * |        |          |(EBI_EN, GPB_MFP6) value and function mapping is as following list.
S * |        |          |(0, 0) = GPIO function is selected to the pin PB.6.
S * |        |          |(0, 1) = UART1_nRTS function is selected to the pin PB.6.
S * |        |          |(1, 1) = ALE(EBI) function is selected to the pin PB.6.
S * |[7]     |GPB_MFP7  |PB.7 Pin Function Selection
S * |        |          |Bit EBI_EN (ALT_MFP[11]), GPB_MFP[7] determines the PB.7 function.
S * |        |          |(EBI_EN, GPB_MFP7) value and function mapping is as following list.
S * |        |          |(0, 0) = GPIO function is selected to the pin PB.7.
S * |        |          |(0, 1) = UART1_nCTS function is selected to the pin PB.7.
S * |        |          |(1, 1) = nCS(EBI) function is selected to the pin PB.7.         
S * |[8]     |GPB_MFP8  |PB.8 Pin Function Selection
S * |        |          |Bits PB8_CLKO (ALT_MFP[29]) and GPB_MFP[8] determine the PB.8 function.
S * |        |          |(PB8_CLKO, GPB_MFP8) value and function mapping is as following list.
S * |        |          |(0, 0) = GPIO function is selected.
S * |        |          |(0, 1) = TM0 function is selected.
S * |        |          |(1, 1) = CLKO function is selected.          
S * |[9]     |GPB_MFP9  |PB.9 Pin Function Selection
S * |        |          |Bits PB9_S11 (ALT_MFP[1]) and GPB_MFP[9] determine the PB.9 function.
S * |        |          |(PB9_S11, GPB_MFP9) value and function mapping is as following list.
S * |        |          |(0, 0) = GPIO function is selected.
S * |        |          |(0, 1) = TM1 function is selected.
S * |        |          |(1, 1) = SPI1_SS1 function is selected.         
S * |[10]    |GPB_MFP10 |PB.10 Pin Function Selection
S * |        |          |Bits PB10_S01 (ALT_MFP[0]) and GPB_MFP[10] determine the PB.10 function.
S * |        |          |(PB10_S01, GPB_MFP10) value and function mapping is as following list.
S * |        |          |(0, 0) = GPIO function is selected.
S * |        |          |(0, 1) = TM2 function is selected.
S * |        |          |(1, 1) = SPI0_SS1 function is selected.     
S * |[11]    |GPB_MFP11 |PB.11 Pin Function Selection
S * |        |          |Bits PB11_PWM4 (ALT_MFP[4]) and GPB_MFP[11] determine the PB.11 function.
S * |        |          |(PB11_PWM4, GPB_MFP11) value and function mapping is as following list.
S * |        |          |(0, 0) = GPIO function is selected.
S * |        |          |(0, 1) = TM3 function is selected.     
S * |        |          |(1, 1) = PWM4 function is selected.     
S * |[13]    |GPB_MFP13 |PB.13 Pin Function Selection
S * |        |          |Bit EBI_EN (ALT_MFP[11]), GPB_MFP[13] determines the PB.13 function.
S * |        |          |(EBI_EN, GPB_MFP13) value and function mapping is as following list
S * |        |          |(0, 0) = GPIO function is selected to the pin PB.13.
S * |        |          |(0, 1) = ACMP1_O function is selected to the pin PB.13.
S * |        |          |(1, 1) = AD1 function is selected.     
S * |[14]    |GPB_MFP14 |PB.14 Pin Function Selection
S * |        |          |Bits PB14_15_EBI (ALT_MFP2[1]), PB14_S31 (ALT_MFP[3]) and GPB_MFP[14] determine the PB.14
S * |        |          |function.
S * |        |          |(PB14_15_EBI , PB14_S31, GPB_MFP14) value and function mapping is as following list
S * |        |          |(0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 1) = INT0 function is selected.
S * |        |          |(0, 1, 1) = SPI3_SS1 function is selected.
S * |        |          |(1, 0, 1) = AD0 function is selected.     
S * |[15]    |GPB_MFP15 |PB.15 Pin Function Selection
S * |        |          |Bits PB14_15_EBI (ALT_MFP2[1]), PB15_T0EX (ALT_MFP[24]), PB15_TM0 (ALT_MFP2[2]) and GPB_MFP[15]
S * |        |          |determine the PB.15 function.
S * |        |          |(PB14_15_EBI, PB15_T0EX, PB15_TM0, GPB_MFP15) value and function mapping is as following list.
S * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 0, 1) = INT1 function is selected.
S * |        |          |(0 ,0, 1, 1) = TM0 function is selected.
S * |        |          |(0, 1, 0, 1) = TM0_EXT function is selected.
S * |        |          |(1, 0, 0, 1) = AD6 function is selected.     
S * |[31:16] |GPB_TYPEn |Trigger Function Selection
S * |        |          |0 = GPIOB[15:0] I/O input Schmitt Trigger function Disabled.
S * |        |          |1 = GPIOB[15:0] I/O input Schmitt Trigger function Enabled.
S * @var GCR_T::GPC_MFP
S * Offset: 0x38  GPIOC Multiple Function and Input Type Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |GPC_MFP0  |PC.0 Pin Function Selection
S * |        |          |Bits PC0_I2SLRCLK (ALT_MFP[5]) and GPC_MFP[0] determine the PC.0 function.
S * |        |          |(PC0_I2SLRCLK, GPC_MFP0) value and function mapping is as following list.
S * |        |          |(0, 0) = GPIO function is selected.
S * |        |          |(0, 1) = SPI0_SS0 function is selected.
S * |        |          |(1, 1) = I2S_LRCK function is selected.          
S * |[1]     |GPC_MFP1  |PC.1 Pin Function Selection
S * |        |          |Bits PC1_I2SBCLK (ALT_MFP[6]) and GPC_MFP[1] determine the PC.1 function.
S * |        |          |(PC1_I2SBCLK, GPC_MFP1) value and function mapping is as following list.
S * |        |          |(0, 0) = GPIO function is selected.
S * |        |          |(0, 1) = SPI0_CLK function is selected.
S * |        |          |(1, 1) = I2S_BCLK function is selected.     
S * |[2]     |GPC_MFP2  |PC.2 Pin Function Selection
S * |        |          |Bits PC2_I2SDI (ALT_MFP[7]) and GPC_MFP[2] determine the PC.2 function.
S * |        |          |(PC2_I2SDI, GPC_MFP2) value and function mapping is as following list.
S * |        |          |(0, 0) = GPIO function is selected.
S * |        |          |(0, 1) = SPI0_MISO0 function is selected.
S * |        |          |(1, 1) = I2S_DI function is selected.
S * |[3]     |GPC_MFP3  |PC.3 Pin Function Selection
S * |        |          |Bits PC3_I2SDO (ALT_MFP[8]) and GPC_MFP[3] determine the PC.3 function.
S * |        |          |(PC3_I2SDO, GPC_MFP3) value and function mapping is as following list.
S * |        |          |(0, 0) = GPIO function is selected.
S * |        |          |(0, 1) = SPI0_MOSI0 function is selected.
S * |        |          |(1, 1) = I2S_DO function is selected.     
S * |[4]     |GPC_MFP4  |PC.4 Pin Function Selection
S * |        |          |Bit GPC_MFP[9] determines the PC.4 function.
S * |        |          |0 = GPIO function is selected to the pin PC.4.
S * |        |          |1 = SPI0_MISO1 function is selected to the pin PC.4.     
S * |[5]     |GPC_MFP5  |PC.5 Pin Function Selection
S * |        |          |Bit GPC_MFP[9] determines the PC.5 function.
S * |        |          |0 = GPIO function is selected to the pin PC.5.
S * |        |          |1 = SPI0_MOSI1 function is selected to the pin PC.5.     
S * |[6]     |GPC_MFP6  |PC.6 Pin Function Selection
S * |        |          |Bits EBI_EN (ALT_MFP[11]). PC6_SC0CD (ALT_MFP1[4]) and GPC_MFP[6] determine the PC.6 function.
S * |        |          |(EBI_EN, PC6_SC0CD, GPC_MFP6) value and function mapping is as following list.
S * |        |          |(0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 1) = ACMP0_P function is selected.
S * |        |          |(0, 1, 1) = SC0_CD function is selected.
S * |        |          |(1, 0, 1) = AD4 function is selected.     
S * |[7]     |GPC_MFP7  |PC.7 Pin Function Selection
S * |        |          |Bits EBI_EN (ALT_MFP[11]), PC7_SC1CD (ALT_MFP1[9]) and GPC_MFP[7] determine the PC.7 function.
S * |        |          |(EBI_EN, PC7_SC1CD, GPC_MFP7) value and function mapping is as following list.
S * |        |          |(0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 1) = ACMP0_N function is selected.
S * |        |          |(0, 1, 1) = SC1_CD function is selected.
S * |        |          |(1, 0, 1) = AD5 function is selected.      
S * |[8]     |GPC_MFP8  |PC.8 Pin Function Selection
S * |        |          |Bits EBI_MCLK_EN (ALT_MFP[12]), EBI_EN (ALT_MFP[11]), GPC_MFP[8] determine the PC.8 function.
S * |        |          |(EBI_MCLK_EN, EBI_EN, GPC_MFP8) value and function mapping is as following list.
S * |        |          |(0, 0, 0) = GPIO function is selected to the pin PC.8.
S * |        |          |(0, 0 ,1) = SPI1_SS0 function is selected to the pin PC.8.
S * |        |          |(1, 1, 1) = MCLK(EBI) function is selected to the pin PC.8.     
S * |[9]     |GPC_MFP9  |PC.9 Pin Function Selection
S * |        |          |Bit GPC_MFP[9] determines the PC.9 function.
S * |        |          |0 = GPIO function is selected to the pin PC.9.
S * |        |          |1 = SPI1_CLK function is selected to the pin PC.9.          
S * |[10]    |GPC_MFP10 |PC.10 Pin Function Selection
S * |        |          |Bit GPC_MFP[10] determines the PC.10 function.
S * |        |          |0 = GPIO function is selected to the pin PC.10.
S * |        |          |1 = SPI1_MISO0 function is selected to the pin PC.10.    
S * |[11]    |GPC_MFP11 |PC.11 Pin Function Selection
S * |        |          |Bit GPC_MFP[11] determines the PC.11 function.
S * |        |          |0 = GPIO function is selected to the pin PC.11.
S * |        |          |1 = SPI1_MOSI0 function is selected to the pin PC.11.        
S * |[12]    |GPC_MFP12 |PC.12 Pin Function Selection
S * |        |          |Bit GPC_MFP[12] determines the PC.12 function.
S * |        |          |0 = GPIO function is selected to the pin PC.12.
S * |        |          |1 = SPI1_MISO1 function is selected to the pin PC.12.      
S * |[13]    |GPC_MFP13 |PC.13 Pin Function Selection
S * |        |          |Bit GPC_MFP[13] determines the PC.13 function.
S * |        |          |0 = GPIO function is selected to the pin PC.13.
S * |        |          |1 = SPI1_MOSI1 function is selected to the pin PC.13.     
S * |[14]    |GPC_MFP14 |PC.14 Pin Function Selection
S * |        |          |Bits EBI_EN (ALT_MFP[11]) and GPC_MFP[14] determine the PC.14 function.
S * |        |          |(EBI_EN, GPC_MFP14) value and function mapping is as following list
S * |        |          |(0, 0) = GPIO function is selected.
S * |        |          |(0, 1) = ACMP1_P function is selected.
S * |        |          |(1, 1) = AD2 function is selected.       
S * |[15]    |GPC_MFP15 |PC.15 Pin Function Selection
S * |        |          |Bits EBI_EN (ALT_MFP[11]) and GPC_MFP[15] determine the PC.15 function.
S * |        |          |(EBI_EN, GPC_MFP15) value and function mapping is as following list
S * |        |          |(0, 0) = GPIO function is selected.
S * |        |          |(0, 1) = ACMP1_N function is selected.
S * |        |          |(1, 1) = AD3 function is selected.        
S * |[31:16] |GPC_TYPEn |Trigger Function Selection
S * |        |          |0 = GPIOC[15:0] I/O input Schmitt Trigger function Disabled.
S * |        |          |1 = GPIOC[15:0] I/O input Schmitt Trigger function Enabled.
S * @var GCR_T::GPD_MFP
S * Offset: 0x3C  GPIOD Multiple Function and Input Type Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |GPD_MFP0  |PD.0 Pin Function Selection
S * |        |          |Bit GPD_MFP[0] determines the PD.0 function.
S * |        |          |0 = GPIO function is selected to the pin PD.0.
S * |        |          |1 = SPI2_SS0 function is selected to the pin PD.0.     
S * |[1]     |GPD_MFP1  |PD.1 Pin Function Selection
S * |        |          |Bit GPD_MFP[1] determines the PD.1 function.
S * |        |          |0 = GPIO function is selected to the pin PD.1.
S * |        |          |1 = SPI2_CLK function is selected to the pin PD.1.
S * |[2]     |GPD_MFP2  |PD.2 Pin Function Selection
S * |        |          |Bit GPD_MFP[2] determines the PD.2 function.
S * |        |          |0 = GPIO function is selected to the pin PD.2.
S * |        |          |1 = SPI2_MISO0 function is selected to the pin PD.2.     
S * |[3]     |GPD_MFP3  |PD.3 Pin Function Selection
S * |        |          |Bit GPD_MFP[3] determines the PD.3 function.
S * |        |          |0 = GPIO function is selected to the pin PD.3.
S * |        |          |1 = SPI2_MOSI0 function is selected to the pin PD.3.     
S * |[4]     |GPD_MFP4  |PD.4 Pin Function Selection
S * |        |          |Bit GPD_MFP[4] determines the PD.4 function.
S * |        |          |0 = GPIO function is selected to the pin PD.4.
S * |        |          |1 = SPI2_MISO1 function is selected to the pin PD.4.     
S * |[5]     |GPD_MFP5  |PD.5 Pin Function Selection
S * |        |          |Bit GPD_MFP[9] determines the PD.5 function.
S * |        |          |0 = GPIO function is selected to the pin PD.5.
S * |        |          |1 = SPI2_MOSI1 function is selected to the pin PD.5.     
S * |[6]     |GPD_MFP6  |PD.6 Pin Function Selection
S * |        |          |Bit GPD_MFP[9] determines the PD.6 function.
S * |        |          |0 = The GPIO function is selected to the pin PD.6.
S * |        |          |1 = The CAN0_RXD function is selected to the pin PD.6.     .
S * |[7]     |GPD_MFP7  |PD.7 Pin Function Selection
S * |        |          |Bit GPD_MFP[7] determines the PD.7 function.
S * |        |          |0 = The GPIO function is selected to the pin PD.7.
S * |        |          |1 = The CAN0_TXD function is selected to the pin PD.7.     
S * |[8]     |GPD_MFP8  |PD.8 Pin Function Selection
S * |        |          |Bit GPD_MFP[8] determines the PD.8 function.
S * |        |          |0 = GPIO function is selected to the pin PD.8.
S * |        |          |1 = SPI3_SS0 function is selected to the pin PD.8.     
S * |[9]     |GPD_MFP9  |PD.9 Pin Function Selection
S * |        |          |Bit GPD_MFP[9] determines the PD.9 function.
S * |        |          |0 = GPIO is function is selected to the pin PD.9.
S * |        |          |1 = SPI3_CLK function is selected to the pin PD.9.     
S * |[10]    |GPD_MFP10 |PD.10 Pin Function Selection
S * |        |          |Bit GPD_MFP[10] determines the PD.10 function.
S * |        |          |0 = GPIO function is selected to the pin PD.10.
S * |        |          |1 = SPI3_MISO0 function is selected to the pin PD.10.     
S * |[11]    |GPD_MFP11 |PD.11 Pin Function Selection
S * |        |          |Bit GPD_MFP[11] determines the PD.11 function.
S * |        |          |0 = GPIO function is selected to the pin PD.11.
S * |        |          |1 = SPI3_MOSI0 function is selected to the pin PD.11.     
S * |[12]    |GPD_MFP12 |PD.12 Pin Function Selection
S * |        |          |Bit GPD_MFP[12] determines the PD.12 function.
S * |        |          |0 = GPIO function is selected to the pin PD.12.
S * |        |          |1 = SPI3_MISO1 function is selected to the pin PD.12.     
S * |[13]    |GPD_MFP13 |PD.13 Pin Function Selection
S * |        |          |Bit GPD_MFP[13] determines the PD.13 function.
S * |        |          |0 = GPIO function is selected to the pin PD.13.
S * |        |          |1 = SPI3_MOSI1 function is selected to the pin PD.13.     
S * |[14]    |GPD_MFP14 |PD.14 Pin Function Selection
S * |        |          |Bits PD14_15_CAN1 (ALT_MFP2[0]) and GPD_MFP[14] determine the PD.14 function.
S * |        |          |(PD14_15_CAN1, GPD_MFP14) value and function mapping is as following list.
S * |        |          |(0, 0) = GPIO function is selected.
S * |        |          |(0, 1) = UART2_RXD function is selected.
S * |        |          |(1, 1) = CAN1_RXD function is selected.     
S * |[15]    |GPD_MFP15 |PD.15 Pin Function Selection
S * |        |          |Bits PD14_15_CAN1 (ALT_MFP2[0]) and GPD_MFP[15] determine the PD.15 function.
S * |        |          |(PD14_15_CAN1, GPD_MFP15) value and function mapping is as following list.
S * |        |          |(0, 0) = GPIO function is selected.
S * |        |          |(0, 1) = UART2_TXD function is selected.
S * |        |          |(1, 1) = CAN1_TXD function is selected.     
S * |[31:16] |GPD_TYPEn |Trigger Function Selection
S * |        |          |0 = GPIOD[15:0] I/O input Schmitt Trigger function Disabled.
S * |        |          |1 = GPIOD[15:0] I/O input Schmitt Trigger function Enabled.
S * @var GCR_T::GPE_MFP
S * Offset: 0x40  GPIOE Multiple Function and Input Type Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |GPE_MFP0  |PE.0 Pin Function Selection
S * |        |          |Bit GPE_MFP[0] determines the PE.0 function.
S * |        |          |0 = GPIO function is selected to the pin PE.0.
S * |        |          |1 = PWM6 function is selected to the pin PE.0.     
S * |[1]     |GPE_MFP1  |PE.1 Pin Function Selection
S * |        |          |Bit GPE_MFP[1] determines the PE.1 function.
S * |        |          |0 = GPIO function is selected to the pin PE.1.
S * |        |          |1 = PWM7 function is selected to the pin PE.1.     
S * |[5]     |GPE_MFP5  |PE.5 Pin Function Selection
S * |        |          |Bits PE5_T1EX (ALT_MFP[25]), PE5_TM1 (ALT_MFP2[3]) and GPE_MFP5 determine the PE.5 function.
S * |        |          |(PE5_T1EX, GPE_MFP5) value and function mapping is as following list.
S * |        |          |(0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 1) = PWM5 function is selected.
S * |        |          |(1, 0, 1) = TM1_EXT function is selected.
S * |        |          |(0, 1, 1) = TM1 function is selected.     
S * |[31:16] |GPE_TYPEn |Trigger Function Selection
S * |        |          |0 = GPIOD[15:0] I/O input Schmitt Trigger function Disabled.
S * |        |          |1 = GPIOD[15:0] I/O input Schmitt Trigger function Enabled.
S * @var GCR_T::GPF_MFP
S * Offset: 0x44  GPIOF Multiple Function and Input Type Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |GPF_MFP0  |PF.0 Pin Function Selection
S * |        |          |Bit GPF_MFP[0] determines the PF.0 function
S * |        |          |0 = GPIO function is selected to the pin PF.0.
S * |        |          |1 = XT1_OUT function is selected to the pin PF.0.
S * |        |          |Note: This bit is read only and is decided by user configuration CGPFMFP (CONFIG0[27]).     
S * |[1]     |GPF_MFP1  |PF.1 Pin Function Selection
S * |        |          |Bit GPF_MFP[1] determines the PF.1 function.
S * |        |          |0 = GPIO function is selected to the pin PF.1.
S * |        |          |1 = XT1_IN function is selected to the pin PF.1.
S * |        |          |Note: This bit is read only and is decided by user configuration CGPFMFP (CONFIG0[27]).     
S * |[2]     |GPF_MFP2  |PF.2 Pin Function Selection
S * |        |          |Bit GPF_MFP[2] determines the PF.2 function.
S * |        |          |0 = GPIO function is selected to the pin PF.2.
S * |        |          |1 = PS/2_DAT function is selected to the pin PF.2.     
S * |[3]     |GPF_MFP3  |PF.3 Pin Function Selection
S * |        |          |Bit GPF_MFP[3] determines the PF.3 function.
S * |        |          |0 = GPIO function is selected to the pin PF.3.
S * |        |          |1 = PS/2_CLK function is selected to the pin PF.3.     
S * |[19:16] |GPF_TYPEn |Trigger Function Selection
S * |        |          |0 = GPIOF[3:0] I/O input Schmitt Trigger function Disabled.
S * |        |          |1 = GPIOF[3:0] I/O input Schmitt Trigger function Enabled.
S * @var GCR_T::ALT_MFP
S * Offset: 0x50  Alternative Multiple Function Pin Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |PB10_S01  |PB.10 Pin Alternative Function Selection
S * |        |          |Bits PB10_S01 (ALT_MFP[0]) and GPB_MFP[10] determine the PB.10 function.
S * |        |          |(PB10_S01, GPB_MFP10) value and function mapping is as following list.
S * |        |          |(0, 0) = GPIO function is selected.
S * |        |          |(0, 1) = TM2 function is selected.
S * |        |          |(1, 1) = SPI0_SS1 function is selected.       
S * |[1]     |PB9_S11   |PB.9 Pin Alternative Function Selection
S * |        |          |Bits PB9_S11 (ALT_MFP[1]) and GPB_MFP[9] determine the PB.9 function.
S * |        |          |(PB9_S11, GPB_MFP9) value and function mapping is as following list.
S * |        |          |(0, 0) = GPIO function is selected.
S * |        |          |(0, 1) = TM1 function is selected.
S * |        |          |(1, 1) = SPI1_SS1 function is selected.           
S * |[2]     |PA7_S21   |PA.7 Pin Alternative Function Selection
S * |        |          |Bits EBI_EN (ALT_MFP[11]), PA7_SC1DAT (ALT_MFP1[6]), PA7_S21 (ALT_MFP[2]) and GPA_MFP[7]
S * |        |          |determine the PA.7 function.
S * |        |          |(EBI_EN, PA7_SC1DAT, PA7_S21, GPA_MFP7) value and function mapping is as following list.
S * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 0, 1) = ADC7 function is selected.
S * |        |          |(0, 0, 1, 1) = SPI2_SS1 function is selected.
S * |        |          |(0, 1, 0, 1) = SC1_DAT/UART4_RXD function is selected.
S * |        |          |(1, 0, 0, 1) = AD6 function is selected.                  
S * |[3]     |PB14_S31  |PB.14 Pin Alternative Function Selection
S * |        |          |Bits PB14_15_EBI (ALT_MFP2[1]), PB14_S31 (ALT_MFP[3]) and GPB_MFP[14] determine the PB.14
S * |        |          |function.
S * |        |          |(PB14_15_EBI , PB14_S31, GPB_MFP14) value and function mapping is as following list
S * |        |          |(0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 1) = INT0 function is selected.
S * |        |          |(0, 1, 1) = SPI3_SS1 function is selected.
S * |        |          |(1, 0, 1) = AD0 function is selected.    
S * |[4]     |PB11_PWM4 |PB.11 Pin Alternative Function Selection     
S * |        |          |Bits PB11_PWM4 (ALT_MFP[4]) and GPB_MFP[11] determine the PB.11 function.
S * |        |          |(PB11_PWM4, GPB_MFP11) value and function mapping is as following list.
S * |        |          |(0, 0) = GPIO function is selected.
S * |        |          |(0, 1) = TM3 function is selected.     
S * |        |          |(1, 1) = PWM4 function is selected.      
S * |[5]     |PC0_I2SLRCLK|PC.0 Pin Alternative Function Selection
S * |        |          |Bits PC0_I2SLRCLK (ALT_MFP[5]) and GPC_MFP[0] determine the PC.0 function.
S * |        |          |(PC0_I2SLRCLK, GPC_MFP0) value and function mapping is as following list.
S * |        |          |(0, 0) = GPIO function is selected.
S * |        |          |(0, 1) = SPI0_SS0 function is selected.
S * |        |          |(1, 1) = I2S_LRCK function is selected.         
S * |[6]     |PC1_I2SBCLK|PC.1 Pin Alternative Function Selection
S * |        |          |Bits PC0_I2SLRCLK (ALT_MFP[5]) and GPC_MFP[0] determine the PC.0 function.
S * |        |          |(PC0_I2SLRCLK, GPC_MFP0) value and function mapping is as following list.
S * |        |          |(0, 0) = GPIO function is selected.
S * |        |          |(0, 1) = SPI0_SS0 function is selected.
S * |        |          |(1, 1) = I2S_LRCK function is selected.         
S * |[7]     |PC2_I2SDI |PC.2 Pin Alternative Function Selection
S * |        |          |Bits PC2_I2SDI (ALT_MFP[7]) and GPC_MFP[2] determine the PC.2 function.
S * |        |          |(PC2_I2SDI, GPC_MFP2) value and function mapping is as following list.
S * |        |          |(0, 0) = GPIO function is selected.
S * |        |          |(0, 1) = SPI0_MISO0 function is selected.
S * |        |          |(1, 1) = I2S_DI function is selected.     
S * |[8]     |PC3_I2SDO |PC.3 Pin Alternative Function Selection
S * |        |          |Bits PC3_I2SDO (ALT_MFP[8]) and GPC_MFP[3] determine the PC.3 function.
S * |        |          |(PC3_I2SDO, GPC_MFP3) value and function mapping is as following list.
S * |        |          |(0, 0) = GPIO function is selected.
S * |        |          |(0, 1) = SPI0_MOSI0 function is selected.
S * |        |          |(1, 1) = I2S_DO function is selected. 
S * |[9]     |PA15_I2SMCLK|PA.15 Pin Alternative Function Selection
S * |        |          |Bits PA15_SC2PWR (ALT_MFP1[12]), PA15_I2SMCLK (ALT_MFP[9]) and GPA_MFP[15] determine the PA.15
S * |        |          |function.
S * |        |          |(PA15_SC2PWR, PA15_I2SMCLK, GPA_MFP15) value and function mapping is as following list.
S * |        |          |(0, 0, 0) = GPIOA function is selected.
S * |        |          |(0, 0, 1) = PWM3 function is selected.
S * |        |          |(0, 1, 1) = I2S_MCLK function is selected.
S * |        |          |(1, 0, 1) = SC2_PWR function is selected.  
S * |[11]    |EBI_EN    |EBI Pin Function Selection
S * |        |          |EBI_EN is use to switch GPIO function to EBI function (AD[15:0], ALE, RE, WE, CS, MCLK), it need
S * |        |          |additional registers EBI_EN[7:0] and EBI_MCLK_EN for some GPIO to switch to EBI
S * |        |          |function(AD[15:8], MCLK).
S * |[12]    |EBI_MCLK_EN|PC.8 Pin Alternative Function Selection
S * |        |          |Bits EBI_MCLK_EN (ALT_MFP[12]), EBI_EN (ALT_MFP[11]), GPC_MFP[8] determine the PC.8 function.
S * |        |          |(EBI_MCLK_EN, EBI_EN, GPC_MFP8) value and function mapping is as following list.
S * |        |          |(0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0 ,1) = SPI1_SS0 function is selected.
S * |        |          |(1, 1, 1) = MCLK(EBI) function is selected.
S * |[13]    |EBI_nWRL_EN|PB.2 Pin Alternative Function Selection
S * |        |          |Bits EBI_nWRL_EN (ALT_MFP[13]), EBI_EN (ALT_MFP[11]), PB2_TM2 (ALT_MFP2[4]), PB2_CPO0
S * |        |          |(ALT_MFP[30]), PB2_T2EX (ALT_MFP[26]) and GPB_MFP[2] determine the PB.2 function.
S * |        |          |(EBI_nWRL_EN, EBI_EN, PB2_TM2, PB2_CPO0, PB2_T2EX, GPB_MFP2) value and function mapping is as
S * |        |          |following list.
S * |        |          |(0, 0, 0, 0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 0, 0, 0, 1) = UART0_nRTS function is selected.
S * |        |          |(0, 0, 0, 0, 1, 1) = TM2_EXT function is selected.
S * |        |          |(0, 0, 0, 1, 0, 1) = ACMP0_O function is selected.
S * |        |          |(0, 0, 1, 0, 0, 1) = TM2 function is selected.
S * |        |          |(1, 1, 0, 0, 0, 1) = nWRL(EBI) function is selected. 
S * |[14]    |EBI_nWRH_EN|PB.3 Pin Alternative Function Selection
S * |        |          |PB3_SC2CD (ALT_MFP1[14]), PB3_T3EX (ALT_MFP[27]) and GPB_MFP[3] determine the PB.3 function.
S * |        |          |(EBI_nWRH_EN, EBI_EN, PB3_TM3, PB3_SC2CD, PB3_T3EX, GPB_MFP3) value and function mapping is as
S * |        |          |following list.
S * |        |          |(0, 0, 0, 0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 0, 0, 0, 1) = UART0_nCTS function is selected.
S * |        |          |(0, 0, 0, 0, 1, 1) = TM3_EXT function is selected.
S * |        |          |(0, 0, 0, 1, 0, 1) = SC2_CD function is selected.
S * |        |          |(0, 0, 1, 0, 0, 1) = TM3 function is selected.
S * |        |          |(1, 1, 0, 0, 0, 1) = nWRH(EBI) function is selected.   
S * |[16]    |EBI_HB_EN[0]|PA.5 Pin Alternative Function Selection
S * |        |          |Bits EBI_HB_EN[0] (ALT_MFP[16]), EBI_EN (ALT_MFP[11]),PA5_SC1RST (ALT_MFP1[8]) and GPA_MFP[5]
S * |        |          |determine the PA.5 function.
S * |        |          |(EBI_HB_EN[0], EBI_EN, PA5_SC1RST, GPA_MFP5) value and function mapping is as following list,
S * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 0, 1) = ADC5 function is selected.
S * |        |          |(0, 0, 1, 1) = SC1_RST function is selected.
S * |        |          |(1, 1, 0, 1) = AD8 function is selected.    
S * |[17]    |EBI_HB_EN[1]|PA.4 Pin Alternative Function Selection
S * |        |          |Bits EBI_HB_EN[1] (ALT_MFP[17]), EBI_EN (ALT_MFP[11]), PA4_SC1PWR (ALT_MFP1[7]) and GPA_MFP[4]
S * |        |          |determine the PA.4 function.
S * |        |          |(EBI_HB_EN[1], EBI_EN, PA4_SC1PWR, GPA_MFP4) value and function mapping is as following list.
S * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 0, 1) = ADC4 function is selected.
S * |        |          |(0, 0, 1, 1) = SC1_PWR function is selected.
S * |        |          |(1, 1, 0, 1) = AD9 function is selected.        
S * |[18]    |EBI_HB_EN[2]|PA.3 Pin Alternative Function Selection
S * |        |          |Bits EBI_HB_EN[2] (ALT_MFP[18]), EBI_EN (ALT_MFP[11]), PA3_SC0DAT (ALT_MFP1[1]) and GPA_MFP[3]
S * |        |          |determine the PA.3 function.
S * |        |          |(EBI_HB_EN[2], EBI_EN, PA3_SC0DAT, GPA_MFP3) value and function mapping is as following list.
S * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 0, 1) = ADC3 function is selected.
S * |        |          |(0, 0, 1, 1) = SC0_DAT/UART3_RXD function is selected.
S * |        |          |(1, 1, 0, 1) = AD10 function is selected.
S * |[19]    |EBI_HB_EN[3]|PA.2 Pin Alternative Function Selection
S * |        |          |Bits EBI_HB_EN[3] (ALT_MFP[19]), EBI_EN (ALT_MFP[11]), PA2_SC0CLK (ALT_MFP1[0]) and GPA_MFP[2]
S * |        |          |determine the PA.2 function.
S * |        |          |(EBI_HB_EN[3], EBI_EN, PA2_SC0CLK, GPA_MFP2) value and function mapping is as following list.
S * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 0, 1) = ADC2 function is selected.
S * |        |          |(0, 0, 1, 1) = SC0_CLK/UART3_TXD function is selected.
S * |        |          |(1, 1, 0, 1) = AD11 function is selected.   
S * |[20]    |EBI_HB_EN[4]|PA.1 Pin Alternative Function Selection
S * |        |          |Bit EBI_HB_EN[4] (ALT_MFP[20]), EBI_EN (ALT_MFP[11]), PA1_SC0RST (ALT_MFP1[3]) and GPA_MFP[1]
S * |        |          |determine the PA.1 function.
S * |        |          |(EBI_HB_EN[4], EBI_EN, PA1_SC0RST, GPA_MFP1) value and function mapping is as following list.
S * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 0, 1) = ADC1 function is selected.
S * |        |          |(0, 0, 1, 1) = SC0_RST function is selected.
S * |        |          |(1, 1, 0, 1) = AD12 function is selected.   
S * |[21]    |EBI_HB_EN[5]|PA.12 Pin Alternative Function Selection
S * |        |          |Bits EBI_HB_EN[5] (ALT_MFP[21]), EBI_EN (ALT_MFP[11]), PA12_SC2DAT (ALT_MFP1[11]) and
S * |        |          |GPA_MFP[12] determine the PA.12 function.
S * |        |          |(EBI_HB_EN[5], EBI_EN, PA12_SC2DAT, GPA_MFP12) value and function mapping is as following list.
S * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 0, 1) = PWM0 function is selected.
S * |        |          |(0, 0, 1, 1) = SC2_DAT/UART5_RXD function is selected.
S * |        |          |(1, 1, 0, 1) = AD13 function is selected.
S * |[22]    |EBI_HB_EN[6]|PA.13 Pin Alternative Function Selection
S * |        |          |Bits EBI_HB_EN[6] (ALT_MFP[22]), EBI_EN (ALT_MFP[11]), PA13_SC2CLK (ALT_MFP1[10]) and
S * |        |          |GPA_MFP[13] determine the PA.13 function.
S * |        |          |(EBI_HB_EN[6], EBI_EN, PA13_SC2CLK, GPA_MFP13) value and function mapping is as following list.
S * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 0, 1) = PWM1 function is selected.
S * |        |          |(0, 0, 1, 1) = SC2_CLK/UART5_TXD function is selected.
S * |        |          |(1, 1, 0, 1) = AD14 function is selected. 
S * |[23]    |EBI_HB_EN[7]|PA.14 Pin Alternative Function Selection     
S * |        |          |Bits EBI_HB_EN[7] (ALT_MFP[23]), EBI_EN (ALT_MFP[11]), PA14_SC2RST (ALT_MFP1[13]) and
S * |        |          |GPA_MFP[14] determine the PA.14 function.
S * |        |          |(EBI_HB_EN , EBI_EN, PA14_SC2RST, GPA_MFP14) value and function mapping is as following list.
S * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 0, 1) = PWM2 function is selected.
S * |        |          |(0, 0, 1, 1) = SC2_RST function is selected.
S * |        |          |(1, 1, 0, 1) = AD15 function is selected.       
S * |[24]    |PB15_T0EX |PB.15 Pin Alternative Function Selection  
S * |        |          |Bits PB14_15_EBI (ALT_MFP2[1]), PB15_T0EX (ALT_MFP[24]), PB15_TM0 (ALT_MFP2[2]) and GPB_MFP[15]
S * |        |          |determine the PB.15 function.
S * |        |          |(PB14_15_EBI, PB15_T0EX, PB15_TM0, GPB_MFP15) value and function mapping is as following list.
S * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 0, 1) = INT1 function is selected.
S * |        |          |(0 ,0, 1, 1) = TM0 function is selected.
S * |        |          |(0, 1, 0, 1) = TM0_EXT function is selected.
S * |        |          |(1, 0, 0, 1) = AD6 function is selected.  
S * |[25]    |PE5_T1EX  |PE.5 Pin Alternative Function Selection
S * |        |          |Bits PE5_T1EX (ALT_MFP[25]), PE5_TM1 (ALT_MFP2[3]) and GPE_MFP5 determine the PE.5 function.
S * |        |          |(PE5_T1EX, GPE_MFP5) value and function mapping is as following list.
S * |        |          |(0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 1) = PWM5 function is selected.
S * |        |          |(1, 0, 1) = TM1_EXT function is selected.
S * |        |          |(0, 1, 1) = TM1 function is selected.        
S * |[26]    |PB2_T2EX  |PB.2 Pin Alternative Function Selection
S * |        |          |Bits PB2_TM2 (ALT_MFP2[4]), PB2_CPO0 (ALT_MFP[30]), PB2_T2EX (ALT_MFP[26]) and GPB_MFP[2]
S * |        |          |determine the PB.2 function.
S * |        |          |(PB2_TM2, PB2_CPO0, PB2_T2EX, GPB_MFP2) value and function mapping is as following list.
S * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 0, 1) = UART0_nRTS function is selected.
S * |        |          |(0, 0, 1, 1) = TM2_EXT function is selected.
S * |        |          |(0, 1, 0, 1) = ACMP0_O function is selected.          
S * |[27]    |PB3_T3EX  |PB.3 Pin Alternative Function Selection
S * |        |          |Bits PB3_TM3 (ALT_MFP2[5]), PB3_SC2CD (ALT_MFP1[14]), PB3_T3EX (ALT_MFP[27]) and GPB_MFP[3]
S * |        |          |determine the PB.3 function.
S * |        |          |(PB3_TM3, PB3_SC2CD, PB3_T3EX, GPB_MFP3) value and function mapping is as following list.
S * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 0, 1) = UART0_nCTS function is selected.
S * |        |          |(0, 0, 1, 1) = TM3_EXT function is selected.
S * |        |          |(0, 1, 0, 1) = SC2_CD function is selected.
S * |        |          |(1, 0, 0, 1) = TM3 function is selected.            
S * |[28]    |PA10_11_CAN1|PA.10 and PA.11 Pin Alternative Function Selection
S * |        |          |Bits PA10_11_CAN1 (ALT_MFP[28]) and GPA_MFP[10] determine the PA.10 function.
S * |        |          |(PA10_11_CAN1, GPA_MFP10) value and function mapping is as following list.
S * |        |          |(0, 0) = GPIO function is selected.
S * |        |          |(0, 1) = I2C1_SDA function is selected.
S * |        |          |(1, 1) = CAN1_TXD function is selected.
S * |        |          |Bits PA10_11_CAN1 (ALT_MFP[28]) and GPA_MFP[11] determine the PA.11 function.
S * |        |          |(PA10_11_CAN1, GPA_MFP11) value and function mapping is as following list.
S * |        |          |(0, 0) = GPIO function is selected.
S * |        |          |(0, 1) = I2C1_SCL function is selected.
S * |        |          |(1, 1) = CAN1_RXD function is selected.          
S * |[29]    |PB8_CLKO  |PB.8 Pin Alternative Function Selection
S * |        |          |Bits PB8_CLKO (ALT_MFP[29]) and GPB_MFP[8] determine the PB.8 function.
S * |        |          |(PB8_CLKO, GPB_MFP8) value and function mapping is as following list.
S * |        |          |(0, 0) = GPIO function is selected.
S * |        |          |(0, 1) = TM0 function is selected.
S * |        |          |(1, 1) = CLKO function is selected.                   
S * |[30]    |PB2_CPO0  |PB.2 Pin Alternative Function Selection
S * |        |          |Bits PB2_TM2 (ALT_MFP2[4]), PB2_CPO0 (ALT_MFP[30]), PB2_T2EX (ALT_MFP[26]) and GPB_MFP[2]
S * |        |          |determine the PB.2 function.
S * |        |          |(PB2_TM2, PB2_CPO0, PB2_T2EX, GPB_MFP2) value and function mapping is as following list.
S * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 0, 1) = UART0_nRTS function is selected.
S * |        |          |(0, 0, 1, 1) = TM2_EXT function is selected.
S * |        |          |(0, 1, 0, 1) = ACMP0_O function is selected.
S * @var GCR_T::ALT_MFP1
S * Offset: 0x58  Alternative Multiple Function Pin Control Register 1
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |PA2_SC0CLK|PA.2 Pin Alternative Function Selection
S * |        |          |Bits EBI_HB_EN[3] (ALT_MFP[19]), EBI_EN (ALT_MFP[11]), PA2_SC0CLK (ALT_MFP1[0]) and GPA_MFP[2]
S * |        |          |determine the PA.2 function.
S * |        |          |(EBI_HB_EN[3], EBI_EN, PA2_SC0CLK, GPA_MFP2) value and function mapping is as following list.
S * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 0, 1) = ADC2 function is selected.
S * |        |          |(0, 0, 1, 1) = SC0_CLK/UART3_TXD function is selected.
S * |        |          |(1, 1, 0, 1) = AD11 function is selected.               
S * |[1]     |PA3_SC0DAT|PA.3 Pin Alternative Function Selection 
S * |        |          |Bits EBI_HB_EN[2] (ALT_MFP[18]), EBI_EN (ALT_MFP[11]), PA3_SC0DAT (ALT_MFP1[1]) and GPA_MFP[3]
S * |        |          |determine the PA.3 function.
S * |        |          |(EBI_HB_EN[2], EBI_EN, PA3_SC0DAT, GPA_MFP3) value and function mapping is as following list.
S * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 0, 1) = ADC3 function is selected.
S * |        |          |(0, 0, 1, 1) = SC0_DAT/UART3_RXD function is selected.
S * |        |          |(1, 1, 0, 1) = AD10 function is selected.   
S * |[2]     |PA0_SC0PWR|PA.0 Pin Alternative Function Selection
S * |        |          |Bit PA0_SC0PWR (ALT_MFP1[2]) and GPA_MFP[0] determine the PA.0 function.
S * |        |          |(PA0_SC0PWR, GPA_MFP0) value and function mapping is as following list.
S * |        |          |(0, 0) = GPIO function is selected.
S * |        |          |(0, 1) = ADC0 function is selected.
S * |        |          |(1, 1) = SC0_PWR function is selected.  
S * |[3]     |PA1_SC0RST|PA.1 Pin Alternative Function Selection     
S * |        |          |Bit EBI_HB_EN[4] (ALT_MFP[20]), EBI_EN (ALT_MFP[11]), PA1_SC0RST (ALT_MFP1[3]) and GPA_MFP[1]
S * |        |          |determine the PA.1 function.
S * |        |          |(EBI_HB_EN[4], EBI_EN, PA1_SC0RST, GPA_MFP1) value and function mapping is as following list.
S * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 0, 1) = ADC1 function is selected.
S * |        |          |(0, 0, 1, 1) = SC0_RST function is selected.
S * |        |          |(1, 1, 0, 1) = AD12 function is selected.       
S * |[4]     |PC6_SC0CD |PC.6 Pin Alternative Function Selection
S * |        |          |Bits EBI_EN (ALT_MFP[11]). PC6_SC0CD (ALT_MFP1[4]) and GPC_MFP[6] determine the PC.6 function.
S * |        |          |(EBI_EN, PC6_SC0CD, GPC_MFP6) value and function mapping is as following list.
S * |        |          |(0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 1) = ACMP0_P function is selected.
S * |        |          |(0, 1, 1) = SC0_CD function is selected.
S * |        |          |(1, 0, 1) = AD4 function is selected.        
S * |[5]     |PA6_SC1CLK|PA.6 Pin Alternative Function Selection     
S * |        |          |Bits EBI_EN (ALT_MFP[11]), PA6_SC1CLK (ALT_MFP1[5]) and GPA_MFP[6] determine the PA.6 function.
S * |        |          |(EBI_EN, PA6_SC1CLK, GPA_MFP6) value and function mapping is as following list.
S * |        |          |(0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 1) = ADC6 function is selected.
S * |        |          |(0, 1, 1) = SC1_CLK/UART4_TXD function is selected.
S * |        |          |(1, 0, 1) = AD7 function is selected.          
S * |[6]     |PA7_SC1DAT|PA.7 Pin Alternative Function Selection
S * |        |          |Bits EBI_EN (ALT_MFP[11]), PA7_SC1DAT (ALT_MFP1[6]), PA7_S21 (ALT_MFP[2]) and GPA_MFP[7]
S * |        |          |determine the PA.7 function.
S * |        |          |(EBI_EN, PA7_SC1DAT, PA7_S21, GPA_MFP7) value and function mapping is as following list.
S * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 0, 1) = ADC7 function is selected.
S * |        |          |(0, 0, 1, 1) = SPI2_SS1 function is selected.
S * |        |          |(0, 1, 0, 1) = SC1_DAT/UART4_RXD function is selected.
S * |        |          |(1, 0, 0, 1) = AD6 function is selected.          
S * |[7]     |PA4_SC1PWR|PA.4 Pin Alternative Function Selection
S * |        |          |Bits EBI_HB_EN[1] (ALT_MFP[17]), EBI_EN (ALT_MFP[11]), PA4_SC1PWR (ALT_MFP1[7]) and GPA_MFP[4]
S * |        |          |determine the PA.4 function.
S * |        |          |(EBI_HB_EN[1], EBI_EN, PA4_SC1PWR, GPA_MFP4) value and function mapping is as following list.
S * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 0, 1) = ADC4 function is selected.
S * |        |          |(0, 0, 1, 1) = SC1_PWR function is selected.
S * |        |          |(1, 1, 0, 1) = AD9 function is selected.     
S * |[8]     |PA5_SC1RST|PA.5 Pin Alternative Function Selection
S * |        |          |Bits EBI_HB_EN[0] (ALT_MFP[16]), EBI_EN (ALT_MFP[11]),PA5_SC1RST (ALT_MFP1[8]) and GPA_MFP[5]
S * |        |          |determine the PA.5 function.
S * |        |          |(EBI_HB_EN[0], EBI_EN, PA5_SC1RST, GPA_MFP5) value and function mapping is as following list,
S * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 0, 1) = ADC5 function is selected.
S * |        |          |(0, 0, 1, 1) = SC1_RST function is selected.
S * |        |          |(1, 1, 0, 1) = AD8 function is selected.     
S * |[9]     |PC7_SC1CD |PC.7 Pin Alternative Function Selection     
S * |        |          |Bits EBI_EN (ALT_MFP[11]), PC7_SC1CD (ALT_MFP1[9]) and GPC_MFP[7] determine the PC.7 function.
S * |        |          |(EBI_EN, PC7_SC1CD, GPC_MFP7) value and function mapping is as following list.
S * |        |          |(0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 1) = ACMP0_N function is selected.
S * |        |          |(0, 1, 1) = SC1_CD function is selected.
S * |        |          |(1, 0, 1) = AD5 function is selected.   
S * |[10]    |PA13_SC2CLK|PA.13 Pin Alternative Function Selection 
S * |        |          |Bits EBI_HB_EN[6] (ALT_MFP[22]), EBI_EN (ALT_MFP[11]), PA13_SC2CLK (ALT_MFP1[10]) and
S * |        |          |GPA_MFP[13] determine the PA.13 function.
S * |        |          |(EBI_HB_EN[6], EBI_EN, PA13_SC2CLK, GPA_MFP13) value and function mapping is as following list.
S * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 0, 1) = PWM1 function is selected.
S * |        |          |(0, 0, 1, 1) = SC2_CLK/UART5_TXD function is selected.
S * |        |          |(1, 1, 0, 1) = AD14 function is selected.         
S * |[11]    |PA12_SC2DAT|PA.12 Pin Alternative Function Selection 
S * |        |          |Bits EBI_HB_EN[5] (ALT_MFP[21]), EBI_EN (ALT_MFP[11]), PA12_SC2DAT (ALT_MFP1[11]) and
S * |        |          |GPA_MFP[12] determine the PA.12 function.
S * |        |          |(EBI_HB_EN[5], EBI_EN, PA12_SC2DAT, GPA_MFP12) value and function mapping is as following list.
S * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 0, 1) = PWM0 function is selected.
S * |        |          |(0, 0, 1, 1) = SC2_DAT/UART5_RXD function is selected.
S * |        |          |(1, 1, 0, 1) = AD13 function is selected.           
S * |[12]    |PA15_SC2PWR|PA.15 Pin Alternative Function Selection
S * |        |          |Bits PA15_SC2PWR (ALT_MFP1[12]), PA15_I2SMCLK (ALT_MFP[9]) and GPA_MFP[15] determine the PA.15
S * |        |          |function.
S * |        |          |(PA15_SC2PWR, PA15_I2SMCLK, GPA_MFP15) value and function mapping is as following list.
S * |        |          |(0, 0, 0) = GPIOA function is selected.
S * |        |          |(0, 0, 1) = PWM3 function is selected.
S * |        |          |(0, 1, 1) = I2S_MCLK function is selected.
S * |        |          |(1, 0, 1) = SC2_PWR function is selected.             
S * |[13]    |PA14_SC2RST|PA.14 Pin Alternative Function Selection
S * |        |          |Bits EBI_HB_EN[7] (ALT_MFP[23]), EBI_EN (ALT_MFP[11]), PA14_SC2RST (ALT_MFP1[13]) and
S * |        |          |GPA_MFP[14] determine the PA.14 function.
S * |        |          |(EBI_HB_EN , EBI_EN, PA14_SC2RST, GPA_MFP14) value and function mapping is as following list.
S * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 0, 1) = PWM2 function is selected.
S * |        |          |(0, 0, 1, 1) = SC2_RST function is selected.
S * |        |          |(1, 1, 0, 1) = AD15 function is selected.             
S * |[14]    |PB3_SC2CD |PB.3 Pin Alternative Function Selection
S * |        |          |PB3_SC2CD (ALT_MFP1[14]), PB3_T3EX (ALT_MFP[27]) and GPB_MFP[3] determine the PB.3 function.
S * |        |          |(EBI_nWRH_EN, EBI_EN, PB3_TM3, PB3_SC2CD, PB3_T3EX, GPB_MFP3) value and function mapping is as
S * |        |          |following list.
S * |        |          |(0, 0, 0, 0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 0, 0, 0, 1) = UART0_nCTS function is selected.
S * |        |          |(0, 0, 0, 0, 1, 1) = TM3_EXT function is selected.
S * |        |          |(0, 0, 0, 1, 0, 1) = SC2_CD function is selected.
S * |        |          |(0, 0, 1, 0, 0, 1) = TM3 function is selected.
S * |        |          |(1, 1, 0, 0, 0, 1) = nWRH(EBI) function is selected.
S * @var GCR_T::ALT_MFP2
S * Offset: 0x5C  Alternative Multiple Function Pin Control Register 2
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |PD14_15_CAN1|PD.14 and PD.15 Pin Alternative Function Selection     
S * |        |          |Bits PD14_15_CAN1 (ALT_MFP2[0]) and GPD_MFP[14] determine the PD.14 function.
S * |        |          |(PD14_15_CAN1, GPD_MFP14) value and function mapping is as following list.
S * |        |          |(0, 0) = GPIO function is selected.
S * |        |          |(0, 1) = UART2_RXD function is selected.
S * |        |          |(1, 1) = CAN1_RXD function is selected.     
S * |        |          |Bits PD14_15_CAN1 (ALT_MFP2[0]) and GPD_MFP[15] determine the PD.15 function.
S * |        |          |(PD14_15_CAN1, GPD_MFP15) value and function mapping is as following list.
S * |        |          |(0, 0) = GPIO function is selected.
S * |        |          |(0, 1) = UART2_TXD function is selected.
S * |        |          |(1, 1) = CAN1_TXD function is selected.    
S * |[0]     |PB14_15_EBI|PB.14 and PB.15 Pin Alternative Function Selection 
S * |        |          |Bits PB14_15_EBI (ALT_MFP2[1]), PB14_S31 (ALT_MFP[3]) and GPB_MFP[14] determine the PB.14
S * |        |          |function.
S * |        |          |(PB14_15_EBI , PB14_S31, GPB_MFP14) value and function mapping is as following list
S * |        |          |(0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 1) = INT0 function is selected.
S * |        |          |(0, 1, 1) = SPI3_SS1 function is selected.
S * |        |          |(1, 0, 1) = AD0 function is selected.     
S * |        |          |Bits PB14_15_EBI (ALT_MFP2[1]), PB15_T0EX (ALT_MFP[24]), PB15_TM0 (ALT_MFP2[2]) and GPB_MFP[15]
S * |        |          |determine the PB.15 function.
S * |        |          |(PB14_15_EBI, PB15_T0EX, PB15_TM0, GPB_MFP15) value and function mapping is as following list.
S * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 0, 1) = INT1 function is selected.
S * |        |          |(0 ,0, 1, 1) = TM0 function is selected.
S * |        |          |(0, 1, 0, 1) = TM0_EXT function is selected.
S * |        |          |(1, 0, 0, 1) = AD6 function is selected.  
S * |[2]     |PB15_TM0  |PB.15 Pin Alternative Function Selection 
S * |        |          |Bits PB14_15_EBI (ALT_MFP2[1]), PB15_T0EX (ALT_MFP[24]), PB15_TM0 (ALT_MFP2[2]) and GPB_MFP[15]
S * |        |          |determine the PB.15 function.
S * |        |          |(PB14_15_EBI, PB15_T0EX, PB15_TM0, GPB_MFP15) value and function mapping is as following list.
S * |        |          |(0, 0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 0, 1) = INT1 function is selected.
S * |        |          |(0 ,0, 1, 1) = TM0 function is selected.
S * |        |          |(0, 1, 0, 1) = TM0_EXT function is selected.
S * |        |          |(1, 0, 0, 1) = AD6 function is selected.  
S * |[3]     |PE5_TM1   |PE.5 Pin Alternative Function Selection      
S * |        |          |Bits PE5_T1EX (ALT_MFP[25]), PE5_TM1 (ALT_MFP2[3]) and GPE_MFP5 determine the PE.5 function.
S * |        |          |(PE5_T1EX, GPE_MFP5) value and function mapping is as following list.
S * |        |          |(0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 1) = PWM5 function is selected.
S * |        |          |(1, 0, 1) = TM1_EXT function is selected.
S * |        |          |(0, 1, 1) = TM1 function is selected.         
S * |[4]     |PB2_TM2   |PB.2 Pin Alternative Function Selection 
S * |        |          |Bits EBI_nWRL_EN (ALT_MFP[13]), EBI_EN (ALT_MFP[11]), PB2_TM2 (ALT_MFP2[4]), PB2_CPO0
S * |        |          |(ALT_MFP[30]), PB2_T2EX (ALT_MFP[26]) and GPB_MFP[2] determine the PB.2 function.
S * |        |          |(EBI_nWRL_EN, EBI_EN, PB2_TM2, PB2_CPO0, PB2_T2EX, GPB_MFP2) value and function mapping is as
S * |        |          |following list.
S * |        |          |(0, 0, 0, 0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 0, 0, 0, 1) = UART0_nRTS function is selected.
S * |        |          |(0, 0, 0, 0, 1, 1) = TM2_EXT function is selected.
S * |        |          |(0, 0, 0, 1, 0, 1) = ACMP0_O function is selected.
S * |        |          |(0, 0, 1, 0, 0, 1) = TM2 function is selected.
S * |        |          |(1, 1, 0, 0, 0, 1) = nWRL(EBI) function is selected.     
S * |[5]     |PB3_TM3   |PB.2 Pin Alternative Function Selection 
S * |        |          |PB3_SC2CD (ALT_MFP1[14]), PB3_T3EX (ALT_MFP[27]) and GPB_MFP[3] determine the PB.3 function.
S * |        |          |(EBI_nWRH_EN, EBI_EN, PB3_TM3, PB3_SC2CD, PB3_T3EX, GPB_MFP3) value and function mapping is as
S * |        |          |following list.
S * |        |          |(0, 0, 0, 0, 0, 0) = GPIO function is selected.
S * |        |          |(0, 0, 0, 0, 0, 1) = UART0_nCTS function is selected.
S * |        |          |(0, 0, 0, 0, 1, 1) = TM3_EXT function is selected.
S * |        |          |(0, 0, 0, 1, 0, 1) = SC2_CD function is selected.
S * |        |          |(0, 0, 1, 0, 0, 1) = TM3 function is selected.
S * |        |          |(1, 1, 0, 0, 0, 1) = nWRH(EBI) function is selected.
S * @var GCR_T::IRCTRIMCTL
S * Offset: 0x80  IRC Trim Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[1:0]   |TRIM_SEL  |Trim Frequency Selection
S * |        |          |This field indicates the target frequency of internal 22.1184 MHz high speed oscillator will
S * |        |          |trim to precise 22.1184MHz or 24MHz automatically.
S * |        |          |If no any target frequency is selected (TRIM_SEL is 00), the HIRC auto trim function is
S * |        |          |disabled.
S * |        |          |During auto trim operation, if clock error detected because of CLKERR_STOP_EN is set to 1 or
S * |        |          |trim retry limitation counts reached, this field will be cleared to 00 automatically.
S * |        |          |00 = HIRC auto trim function Disabled.
S * |        |          |01 = HIRC auto trim function Enabled and HIRC trimmed to 22.1184 MHz.
S * |        |          |10 = HIRC auto trim function Enabled and HIRC trimmed to 24 MHz.
S * |        |          |11 = Reserved.
S * |[5:4]   |TRIM_LOOP |Trim Calculation Loop
S * |        |          |This field defines that trim value calculation is based on how many 32.768 kHz clocks in.
S * |        |          |For example, if TRIM_LOOP is set as 00, auto trim circuit will calculate trim value based on the
S * |        |          |average frequency difference in 4 32.768 kHz clock.
S * |        |          |00 = Trim value calculation is based on average difference in 4 clocks.
S * |        |          |01 = Trim value calculation is based on average difference in 8 clocks.
S * |        |          |10 = Trim value calculation is based on average difference in 16 clocks.
S * |        |          |11 = Trim value calculation is based on average difference in 32 clocks.
S * |[7:6]   |TRIM_RETRY_CNT|Trim Value Update Limitation Count
S * |        |          |The field defines that how many times of HIRC trim value is updated by auto trim circuit before
S * |        |          |the HIRC frequency locked.
S * |        |          |Once the HIRC locked, the internal trim value update counter will be reset.
S * |        |          |If the trim value update counter reached this limitation value and frequency of HIRC still
S * |        |          |doesn't lock, the auto trim operation will be disabled and TRIM_SEL will be cleared to 00.
S * |        |          |00 = Trim retry count limitation is 64.
S * |        |          |01 = Trim retry count limitation is 128.
S * |        |          |10 = Trim retry count limitation is 256.
S * |        |          |11 = Trim retry count limitation is 512.
S * |[8]     |CLKERR_STOP_EN|Clock Error Stop Enable
S * |        |          |When this bit is set to 0, the trim operation is keep going if clock is inaccuracy.
S * |        |          |When this bit is set to 1, the trim operation is stopped if clock is inaccuracy.
S * @var GCR_T::IRCTRIMIEN
S * Offset: 0x84  IRC Trim Interrupt Enable Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[1]     |TRIM_FAIL_IEN|Trim Failure Interrupt Enable
S * |        |          |This bit controls if an interrupt will be triggered while HIRC trim value update limitation
S * |        |          |count reached and HIRC frequency still not locked on target frequency set by TRIM_SEL
S * |        |          |(IRCTRIMCTL[1:0]).
S * |        |          |If this bit is high and TRIM_FAIL_INT (IRCTRIMINT[1]) is set during auto trim operation.
S * |        |          |An interrupt will be triggered to notify that HIRC trim value update limitation count was
S * |        |          |reached.
S * |        |          |0 = TRIM_FAIL_INT (IRCTRIMINT[1]) status to trigger an interrupt to CPU Disabled.
S * |        |          |1 = TRIM_FAIL_INT (IRCTRIMINT[1]) status to trigger an interrupt to CPU Enabled.
S * |[2]     |CLKERR_IEN|Clock Error Interrupt Enable
S * |        |          |This bit controls if CPU would get an interrupt while clock is inaccuracy during auto trim
S * |        |          |operation.
S * |        |          |If this bit is set to1, and CLKERR_INT (IRCTRIMINT[2]) is set during auto trim operation.
S * |        |          |An interrupt will be triggered to notify the clock frequency is inaccuracy.
S * |        |          |0 = CLKERR_INT (IRCTRIMINT[2]) status to trigger an interrupt to CPU Disabled.
S * |        |          |1 = CLKERR_INT (IRCTRIMINT[2]) status to trigger an interrupt to CPU Enabled.
S * @var GCR_T::IRCTRIMINT
S * Offset: 0x88  IRC Trim Interrupt Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |FREQ_LOCK |HIRC Frequency Lock Status
S * |        |          |This bit indicates the internal 22.1184 MHz high speed oscillator frequency is locked.
S * |        |          |This is a status bit and doesn't trigger any interrupt.
S * |[1]     |TRIM_FAIL_INT|Trim Failure Interrupt Status
S * |        |          |This bit indicates that internal 22.1184 MHz high speed oscillator trim value update limitation
S * |        |          |count reached and the internal 22.1184 MHz high speed oscillator clock frequency still doesn't
S * |        |          |be locked.
S * |        |          |Once this bit is set, the auto trim operation stopped and TRIM_SEL (IRCTRIMCTL [1:0]) will be
S * |        |          |cleared to 00 by hardware automatically.
S * |        |          |If this bit is set and TRIM_FAIL_IEN (IRCTRIMIEN[1]) is high, an interrupt will be triggered to
S * |        |          |notify that HIRC trim value update limitation count was reached.
S * |        |          |Write 1 to clear this to 0.
S * |        |          |0 = Trim value update limitation count did not reach.
S * |        |          |1 = Trim value update limitation count reached and internal 22.1184 MHz high speed oscillator
S * |        |          |frequency was still not locked.
S * |[2]     |CLKERR_INT|Clock Error Interrupt Status
S * |        |          |When the frequency of external 32.768 kHz low speed crystal or internal 22.1184 MHz high speed
S * |        |          |oscillator is shift larger to unreasonable value, this bit will be set and to be an indicate
S * |        |          |that clock frequency is inaccuracy
S * |        |          |Once this bit is set to 1, the auto trim operation stopped and TRIM_SEL (IRCTRIMCTL [1:0]) will
S * |        |          |be cleared to 00 by hardware automatically if CLKERR_STOP_EN (IRCTRIMCTL [8]) is set to 1.
S * |        |          |If this bit is set and CLKERR_IEN (IRCTRIMIEN [2]) is high, an interrupt will be triggered to
S * |        |          |notify the clock frequency is inaccuracy.
S * |        |          |Write 1 to clear this to 0.
S * |        |          |0 = Clock frequency is accurate.
S * |        |          |1 = Clock frequency is inaccurate.
S * @var GCR_T::REGWRPROT
S * Offset: 0x100  Register Write Protection Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |REGPROTDIS|Register Write-Protection Disable Index (Read Only)
S * |        |          |0 = Write-protection is enabled for writing protected registers.
S * |        |          |Any write to the protected register is ignored.
S * |        |          |1 = Write-protection is disabled for writing protected registers.
S * |        |          |The Protected registers are:
S * |        |          |IPRSTC1: address 0x5000_0008
S * |        |          |BODCR: address 0x5000_0018
S * |        |          |PORCR: address 0x5000_0024
S * |        |          |PWRCON: address 0x5000_0200 (bit[6] is not protected for power wake-up interrupt clear)
S * |        |          |APBCLK bit[0]: address 0x5000_0208 (bit[0] is watchdog clock enable)
S * |        |          |CLKSEL0: address 0x5000_0210 (for HCLK and CPU STCLK clock source selection)
S * |        |          |CLKSEL1 bit[1:0]: address 0x5000_0214 (for watchdog clock source selection)
S * |        |          |NMI_SEL bit[8]: address 0x5000_0380 (for NMI_EN clock source selection)
S * |        |          |ISPCON: address 0x5000_C000 (Flash ISP Control register)
S * |        |          |ISPTRG: address 0x5000_C010 (ISP Trigger Control register)
S * |        |          |WTCR: address 0x4000_4000
S * |        |          |FATCON: address 0x5000_C018
S * |        |          |Note: The bits which are write-protected will be noted as" (Write Protect)" beside the
S * |        |          |description.
S * |[7:0]   |REGWRPROT |Register Write-Protection Code (Write Only)
S * |        |          |Some registers have write-protection function.
S * |        |          |Writing these registers have to disable the protected function by writing the sequence value
S * |        |          |"59h", "16h", "88h" to this field.
S * |        |          |After this sequence is completed, the REGPROTDIS bit will be set to 1 and write-protection
S * |        |          |registers can be normal write.
S */
S
S    __I  uint32_t PDID;          /* Offset: 0x00  Part Device Identification Number Register                         */
S    __IO uint32_t RSTSRC;        /* Offset: 0x04  System Reset Source Register                                       */
S    __IO uint32_t IPRSTC1;       /* Offset: 0x08  IP Reset Control Register 1                                        */
S    __IO uint32_t IPRSTC2;       /* Offset: 0x0C  IP Reset Control Register 2                                        */
S    __IO uint32_t IPRSTC3;       /* Offset: 0x10  IP Reset Control Register 3                                        */
S    __I  uint32_t RESERVE0;     
S    __IO uint32_t BODCR;         /* Offset: 0x18  Brown-out Detector Control Register                                */
S    __IO uint32_t TEMPCR;        /* Offset: 0x1C  Temperature Sensor Control Register                                */
S    __I  uint32_t RESERVE1;     
S    __IO uint32_t PORCR;         /* Offset: 0x24  Power-on-Reset Controller Register                                 */
S    __I  uint32_t RESERVE2[2];  
S    __IO uint32_t GPA_MFP;       /* Offset: 0x30  GPIOA Multiple Function and Input Type Control Register            */
S    __IO uint32_t GPB_MFP;       /* Offset: 0x34  GPIOB Multiple Function and Input Type Control Register            */
S    __IO uint32_t GPC_MFP;       /* Offset: 0x38  GPIOC Multiple Function and Input Type Control Register            */
S    __IO uint32_t GPD_MFP;       /* Offset: 0x3C  GPIOD Multiple Function and Input Type Control Register            */
S    __IO uint32_t GPE_MFP;       /* Offset: 0x40  GPIOE Multiple Function and Input Type Control Register            */
S    __IO uint32_t GPF_MFP;       /* Offset: 0x44  GPIOF Multiple Function and Input Type Control Register            */
S    __I  uint32_t RESERVE3[2];  
S    __IO uint32_t ALT_MFP;       /* Offset: 0x50  Alternative Multiple Function Pin Control Register                 */
S    __I  uint32_t RESERVE4;     
S    __IO uint32_t ALT_MFP1;      /* Offset: 0x58  Alternative Multiple Function Pin Control Register 1               */
S    __IO uint32_t ALT_MFP2;      /* Offset: 0x5C  Alternative Multiple Function Pin Control Register 2               */
S    __I  uint32_t RESERVE5[8];  
S    __IO uint32_t IRCTRIMCTL;    /* Offset: 0x80  IRC Trim Control Register                                          */
S    __IO uint32_t IRCTRIMIEN;    /* Offset: 0x84  IRC Trim Interrupt Enable Register                                 */
S    __IO uint32_t IRCTRIMINT;    /* Offset: 0x88  IRC Trim Interrupt Status Register                                 */
S    __I  uint32_t RESERVE6[29]; 
S    __IO uint32_t REGWRPROT;     /* Offset: 0x100  Register Write Protection Register                                */
S
S} GCR_T;
S
S
S/**
S    @addtogroup SYS_CONST SYS Bit Field Definition
S    Constant Definitions for SYS Controller
S@{ */
S
S
S/* GCR RSTSRC Bit Field Definitions */
S#define SYS_RSTSRC_RSTS_CPU_Pos                 7                                   /*!< GCR_T::RSTSRC: RSTS_CPU Position */
S#define SYS_RSTSRC_RSTS_CPU_Msk                 (1ul << SYS_RSTSRC_RSTS_CPU_Pos)    /*!< GCR_T::RSTSRC: RSTS_CPU Mask */
S
S#define SYS_RSTSRC_RSTS_SYS_Pos                 5                                   /*!< GCR_T::RSTSRC: RSTS_SYS Position */
S#define SYS_RSTSRC_RSTS_SYS_Msk                 (1ul << SYS_RSTSRC_RSTS_SYS_Pos)    /*!< GCR_T::RSTSRC: RSTS_SYS Mask */
S
S#define SYS_RSTSRC_RSTS_BOD_Pos                 4                                   /*!< GCR_T::RSTSRC: RSTS_BOD Position */
S#define SYS_RSTSRC_RSTS_BOD_Msk                 (1ul << SYS_RSTSRC_RSTS_BOD_Pos)    /*!< GCR_T::RSTSRC: RSTS_BOD Mask */
S
S#define SYS_RSTSRC_RSTS_LVR_Pos                 3                                   /*!< GCR_T::RSTSRC: RSTS_LVR Position */
S#define SYS_RSTSRC_RSTS_LVR_Msk                 (1ul << SYS_RSTSRC_RSTS_LVR_Pos)    /*!< GCR_T::RSTSRC: RSTS_LVR Mask */
S
S#define SYS_RSTSRC_RSTS_WDT_Pos                 2                                   /*!< GCR_T::RSTSRC: RSTS_WDT Position */
S#define SYS_RSTSRC_RSTS_WDT_Msk                 (1ul << SYS_RSTSRC_RSTS_WDT_Pos)    /*!< GCR_T::RSTSRC: RSTS_WDT Mask */
S
S#define SYS_RSTSRC_RSTS_RESET_Pos               1                                   /*!< GCR_T::RSTSRC: RSTS_RESET Position */
S#define SYS_RSTSRC_RSTS_RESET_Msk               (1ul << SYS_RSTSRC_RSTS_RESET_Pos)  /*!< GCR_T::RSTSRC: RSTS_RESET Mask */
S
S#define SYS_RSTSRC_RSTS_POR_Pos                 0                                   /*!< GCR_T::RSTSRC: RSTS_POR Position */
S#define SYS_RSTSRC_RSTS_POR_Msk                 (1ul << SYS_RSTSRC_RSTS_POR_Pos)    /*!< GCR_T::RSTSRC: RSTS_POR Mask */
S
S/* GCR IPRSTC1 Bit Field Definitions */
S#define SYS_IPRSTC1_EBI_RST_Pos                 3                                   /*!< GCR_T::IPRSTC1: EBI_RST Position */
S#define SYS_IPRSTC1_EBI_RST_Msk                 (1ul << SYS_IPRSTC1_EBI_RST_Pos)    /*!< GCR_T::IPRSTC1: EBI_RST Mask */
S
S#define SYS_IPRSTC1_PDMA_RST_Pos                2                                   /*!< GCR_T::IPRSTC1: PDMA_RST Position */
S#define SYS_IPRSTC1_PDMA_RST_Msk                (1ul << SYS_IPRSTC1_PDMA_RST_Pos)   /*!< GCR_T::IPRSTC1: PDMA_RST Mask */
S
S#define SYS_IPRSTC1_CPU_RST_Pos                 1                                   /*!< GCR_T::IPRSTC1: CPU_RST Position */
S#define SYS_IPRSTC1_CPU_RST_Msk                 (1ul << SYS_IPRSTC1_CPU_RST_Pos)    /*!< GCR_T::IPRSTC1: CPU_RST Mask */
S
S#define SYS_IPRSTC1_CHIP_RST_Pos                0                                   /*!< GCR_T::IPRSTC1: CHIP_RST Position */
S#define SYS_IPRSTC1_CHIP_RST_Msk                (1ul << SYS_IPRSTC1_CHIP_RST_Pos)   /*!< GCR_T::IPRSTC1: CHIP_RST Mask */
S
S/* GCR IPRSTC2 Bit Field Definitions */
S#define SYS_IPRSTC2_I2S_RST_Pos                 29                                  /*!< GCR_T::IPRSTC2: I2S_RST Position */
S#define SYS_IPRSTC2_I2S_RST_Msk                 (1ul << SYS_IPRSTC2_I2S_RST_Pos)    /*!< GCR_T::IPRSTC2: I2S_RST Mask */
S
S#define SYS_IPRSTC2_ADC_RST_Pos                 28                                  /*!< GCR_T::IPRSTC2: ADC_RST Position */
S#define SYS_IPRSTC2_ADC_RST_Msk                 (1ul << SYS_IPRSTC2_ADC_RST_Pos)    /*!< GCR_T::IPRSTC2: ADC_RST Mask */
S
S#define SYS_IPRSTC2_USBD_RST_Pos                27                                  /*!< GCR_T::IPRSTC2: USBD_RST Position */
S#define SYS_IPRSTC2_USBD_RST_Msk                (1ul << SYS_IPRSTC2_USBD_RST_Pos)   /*!< GCR_T::IPRSTC2: USBD_RST Mask */
S
S#define SYS_IPRSTC2_CAN1_RST_Pos                25                                  /*!< GCR_T::IPRSTC2: CAN1_RST Position */
S#define SYS_IPRSTC2_CAN1_RST_Msk                (1ul << SYS_IPRSTC2_CAN1_RST_Pos)   /*!< GCR_T::IPRSTC2: CAN1_RST Mask */
S
S#define SYS_IPRSTC2_CAN0_RST_Pos                24                                  /*!< GCR_T::IPRSTC2: CAN0_RST Position */
S#define SYS_IPRSTC2_CAN0_RST_Msk                (1ul << SYS_IPRSTC2_CAN0_RST_Pos)   /*!< GCR_T::IPRSTC2: CAN0_RST Mask */
S
S#define SYS_IPRSTC2_PS2_RST_Pos                 23                                  /*!< GCR_T::IPRSTC2: PS2_RST Position */
S#define SYS_IPRSTC2_PS2_RST_Msk                 (1ul << SYS_IPRSTC2_PS2_RST_Pos)    /*!< GCR_T::IPRSTC2: PS2_RST Mask */
S
S#define SYS_IPRSTC2_ACMP_RST_Pos                22                                  /*!< GCR_T::IPRSTC2: ACMP_RST Position */
S#define SYS_IPRSTC2_ACMP_RST_Msk                (1ul << SYS_IPRSTC2_ACMP_RST_Pos)   /*!< GCR_T::IPRSTC2: ACMP_RST Mask */
S
S#define SYS_IPRSTC2_PWM47_RST_Pos               21                                  /*!< GCR_T::IPRSTC2: PWM47_RST Position */
S#define SYS_IPRSTC2_PWM47_RST_Msk               (1ul << SYS_IPRSTC2_PWM47_RST_Pos)  /*!< GCR_T::IPRSTC2: PWM47_RST Mask */
S
S#define SYS_IPRSTC2_PWM03_RST_Pos               20                                  /*!< GCR_T::IPRSTC2: PWM03_RST Position */
S#define SYS_IPRSTC2_PWM03_RST_Msk               (1ul << SYS_IPRSTC2_PWM03_RST_Pos)  /*!< GCR_T::IPRSTC2: PWM03_RST Mask */
S
S#define SYS_IPRSTC2_UART2_RST_Pos               18                                  /*!< GCR_T::IPRSTC2: UART2_RST Position */
S#define SYS_IPRSTC2_UART2_RST_Msk               (1ul << SYS_IPRSTC2_UART2_RST_Pos)  /*!< GCR_T::IPRSTC2: UART2_RST Mask */
S
S#define SYS_IPRSTC2_UART1_RST_Pos               17                                  /*!< GCR_T::IPRSTC2: UART1_RST Position */
S#define SYS_IPRSTC2_UART1_RST_Msk               (1ul << SYS_IPRSTC2_UART1_RST_Pos)  /*!< GCR_T::IPRSTC2: UART1_RST Mask */
S
S#define SYS_IPRSTC2_UART0_RST_Pos               16                                  /*!< GCR_T::IPRSTC2: UART0_RST Position */
S#define SYS_IPRSTC2_UART0_RST_Msk               (1ul << SYS_IPRSTC2_UART0_RST_Pos)  /*!< GCR_T::IPRSTC2: UART0_RST Mask */
S
S#define SYS_IPRSTC2_SPI3_RST_Pos                15                                  /*!< GCR_T::IPRSTC2: SPI3_RST Position */
S#define SYS_IPRSTC2_SPI3_RST_Msk                (1ul << SYS_IPRSTC2_SPI3_RST_Pos)   /*!< GCR_T::IPRSTC2: SPI3_RST Mask */
S
S#define SYS_IPRSTC2_SPI2_RST_Pos                14                                  /*!< GCR_T::IPRSTC2: SPI2_RST Position */
S#define SYS_IPRSTC2_SPI2_RST_Msk                (1ul << SYS_IPRSTC2_SPI2_RST_Pos)   /*!< GCR_T::IPRSTC2: SPI2_RST Mask */
S
S#define SYS_IPRSTC2_SPI1_RST_Pos                13                                  /*!< GCR_T::IPRSTC2: SPI1_RST Position */
S#define SYS_IPRSTC2_SPI1_RST_Msk                (1ul << SYS_IPRSTC2_SPI1_RST_Pos)   /*!< GCR_T::IPRSTC2: SPI1_RST Mask */
S
S#define SYS_IPRSTC2_SPI0_RST_Pos                12                                  /*!< GCR_T::IPRSTC2: SPI0_RST Position */
S#define SYS_IPRSTC2_SPI0_RST_Msk                (1ul << SYS_IPRSTC2_SPI0_RST_Pos)   /*!< GCR_T::IPRSTC2: SPI0_RST Mask */
S
S#define SYS_IPRSTC2_I2C1_RST_Pos                9                                   /*!< GCR_T::IPRSTC2: I2C1_RST Position */
S#define SYS_IPRSTC2_I2C1_RST_Msk                (1ul << SYS_IPRSTC2_I2C1_RST_Pos)   /*!< GCR_T::IPRSTC2: I2C1_RST Mask */
S
S#define SYS_IPRSTC2_I2C0_RST_Pos                8                                   /*!< GCR_T::IPRSTC2: I2C0_RST Position */
S#define SYS_IPRSTC2_I2C0_RST_Msk                (1ul << SYS_IPRSTC2_I2C0_RST_Pos)   /*!< GCR_T::IPRSTC2: I2C0_RST Mask */
S
S#define SYS_IPRSTC2_TMR3_RST_Pos                5                                   /*!< GCR_T::IPRSTC2: TMR3_RST Position */
S#define SYS_IPRSTC2_TMR3_RST_Msk                (1ul << SYS_IPRSTC2_TMR3_RST_Pos)   /*!< GCR_T::IPRSTC2: TMR3_RST Mask */
S
S#define SYS_IPRSTC2_TMR2_RST_Pos                4                                   /*!< GCR_T::IPRSTC2: TMR2_RST Position */
S#define SYS_IPRSTC2_TMR2_RST_Msk                (1ul << SYS_IPRSTC2_TMR2_RST_Pos)   /*!< GCR_T::IPRSTC2: TMR2_RST Mask */
S
S#define SYS_IPRSTC2_TMR1_RST_Pos                3                                   /*!< GCR_T::IPRSTC2: TMR1_RST Position */
S#define SYS_IPRSTC2_TMR1_RST_Msk                (1ul << SYS_IPRSTC2_TMR1_RST_Pos)   /*!< GCR_T::IPRSTC2: TMR1_RST Mask */
S
S#define SYS_IPRSTC2_TMR0_RST_Pos                2                                   /*!< GCR_T::IPRSTC2: TMR0_RST Position */
S#define SYS_IPRSTC2_TMR0_RST_Msk                (1ul << SYS_IPRSTC2_TMR0_RST_Pos)   /*!< GCR_T::IPRSTC2: TMR0_RST Mask */
S
S#define SYS_IPRSTC2_GPIO_RST_Pos                1                                   /*!< GCR_T::IPRSTC2: GPIO_RST Position */
S#define SYS_IPRSTC2_GPIO_RST_Msk                (1ul << SYS_IPRSTC2_GPIO_RST_Pos)   /*!< GCR_T::IPRSTC2: GPIO_RST Mask */
S
S/* GCR IPRSTC3 Bit Field Definitions */
S#define SYS_IPRSTC3_SC2_RST_Pos                 2                                   /*!< GCR_T::IPRSTC3: SC2_RST Position */
S#define SYS_IPRSTC3_SC2_RST_Msk                 (1ul << SYS_IPRSTC3_SC2_RST_Pos)    /*!< GCR_T::IPRSTC3: SC2_RST Mask */
S
S#define SYS_IPRSTC3_SC1_RST_Pos                 1                                   /*!< GCR_T::IPRSTC3: SC1_RST Position */
S#define SYS_IPRSTC3_SC1_RST_Msk                 (1ul << SYS_IPRSTC3_SC1_RST_Pos)    /*!< GCR_T::IPRSTC3: SC1_RST Mask */
S
S#define SYS_IPRSTC3_SC0_RST_Pos                 0                                   /*!< GCR_T::IPRSTC3: SC0_RST Position */
S#define SYS_IPRSTC3_SC0_RST_Msk                 (1ul << SYS_IPRSTC3_SC0_RST_Pos)    /*!< GCR_T::IPRSTC3: SC0_RST Mask */
S
S/* GCR BODCR Bit Field Definitions */
S#define SYS_BODCR_LVR_EN_Pos                    7                                   /*!< GCR_T::BODCR: LVR_EN Position */
S#define SYS_BODCR_LVR_EN_Msk                    (1ul << SYS_BODCR_LVR_EN_Pos)       /*!< GCR_T::BODCR: LVR_EN Mask */
S
S#define SYS_BODCR_BOD_OUT_Pos                   6                                   /*!< GCR_T::BODCR: BOD_OUT Position */
S#define SYS_BODCR_BOD_OUT_Msk                   (1ul << SYS_BODCR_BOD_OUT_Pos)      /*!< GCR_T::BODCR: BOD_OUT Mask */
S
S#define SYS_BODCR_BOD_LPM_Pos                   5                                   /*!< GCR_T::BODCR: BOD_LPM Position */
S#define SYS_BODCR_BOD_LPM_Msk                   (1ul << SYS_BODCR_BOD_LPM_Pos)      /*!< GCR_T::BODCR: BOD_LPM Mask */
S
S#define SYS_BODCR_BOD_INTF_Pos                  4                                   /*!< GCR_T::BODCR: BOD_INTF Position */
S#define SYS_BODCR_BOD_INTF_Msk                  (1ul << SYS_BODCR_BOD_INTF_Pos)     /*!< GCR_T::BODCR: BOD_INTF Mask */
S
S#define SYS_BODCR_BOD_RSTEN_Pos                 3                                   /*!< GCR_T::BODCR: BOD_RSTEN Position */
S#define SYS_BODCR_BOD_RSTEN_Msk                 (1ul << SYS_BODCR_BOD_RSTEN_Pos)    /*!< GCR_T::BODCR: BOD_RSTEN Mask */
S
S#define SYS_BODCR_BOD_VL_Pos                    1                                   /*!< GCR_T::BODCR: BOD_VL Position */
S#define SYS_BODCR_BOD_VL_Msk                    (3ul << SYS_BODCR_BOD_VL_Pos)       /*!< GCR_T::BODCR: BOD_VL Mask */
S
S#define SYS_BODCR_BOD_EN_Pos                    0                                   /*!< GCR_T::BODCR: BOD_EN Position */
S#define SYS_BODCR_BOD_EN_Msk                    (1ul << SYS_BODCR_BOD_EN_Pos)       /*!< GCR_T::BODCR: BOD_EN Mask */
S
S/* GCR TEMPCR Bit Field Definitions */
S#define SYS_TEMPCR_VTEMP_EN_Pos                 0                                   /*!< GCR_T::TEMPCR: VTEMP_EN Position */
S#define SYS_TEMPCR_VTEMP_EN_Msk                 (1ul << SYS_TEMPCR_VTEMP_EN_Pos)    /*!< GCR_T::TEMPCR: VTEMP_EN Mask */
S
S/* GCR PORCR Bit Field Definitions */
S#define SYS_PORCR_POR_DIS_CODE_Pos              0                                           /*!< GCR_T::PORCR: POR_DIS_CODE Position */
S#define SYS_PORCR_POR_DIS_CODE_Msk              (0xFFFFul << SYS_PORCR_POR_DIS_CODE_Pos)    /*!< GCR_T::PORCR: POR_DIS_CODE Mask */
S
S/* GCR GPAMFP Bit Field Definitions */
S#define SYS_GPA_MFP_GPA_TYPE_Pos                 16                                         /*!< GCR_T::GPA_MFP: GPA_TYPE Position */
S#define SYS_GPA_MFP_GPA_TYPE_Msk                 (0xFFFFul << SYS_GPA_MFP_GPA_TYPE_Pos)     /*!< GCR_T::GPA_MFP: GPA_TYPE Mask */
S
S#define SYS_GPA_MFP_GPA_MFP_Pos                  0                                          /*!< GCR_T::GPA_MFP: GPA_MFP Position */
S#define SYS_GPA_MFP_GPA_MFP_Msk                  (0xFFFFul << SYS_GPA_MFP_GPA_MFP_Pos)      /*!< GCR_T::GPA_MFP: GPA_MFP Mask */
S
S
S/* GCR GPBMFP Bit Field Definitions */
S#define SYS_GPB_MFP_GPB_TYPE_Pos                 16                                         /*!< GCR_T::GPB_MFP: GPB_TYPE Position */
S#define SYS_GPB_MFP_GPB_TYPE_Msk                 (0xFFFFul << SYS_GPB_MFP_GPB_TYPE_Pos)     /*!< GCR_T::GPB_MFP: GPB_TYPE Mask */
S
S#define SYS_GPB_MFP_GPB_MFP_Pos                  0                                          /*!< GCR_T::GPB_MFP: GPB_MFP Position */
S#define SYS_GPB_MFP_GPB_MFP_Msk                  (0xFFFFul << SYS_GPB_MFP_GPB_MFP_Pos)      /*!< GCR_T::GPB_MFP: GPB_MFP Mask */
S
S/* GCR GPCMFP Bit Field Definitions */
S#define SYS_GPC_MFP_GPC_TYPE_Pos                 16                                         /*!< GCR_T::GPC_MFP: GPC_TYPE Position */
S#define SYS_GPC_MFP_GPC_TYPE_Msk                 (0xFFFFul << SYS_GPC_MFP_GPC_TYPE_Pos)     /*!< GCR_T::GPC_MFP: GPC_TYPE Mask */
S
S#define SYS_GPC_MFP_GPC_MFP_Pos                  0                                          /*!< GCR_T::GPC_MFP: GPC_MFP Position */
S#define SYS_GPC_MFP_GPC_MFP_Msk                  (0xFFFFul << SYS_GPC_MFP_GPC_MFP_Pos)      /*!< GCR_T::GPC_MFP: GPC_MFP Mask */
S
S/* GCR GPDMFP Bit Field Definitions */
S#define SYS_GPD_MFP_GPD_TYPE_Pos                 16                                         /*!< GCR_T::GPD_MFP: GPD_TYPE Position */
S#define SYS_GPD_MFP_GPD_TYPE_Msk                 (0xFFFFul << SYS_GPD_MFP_GPD_TYPE_Pos)     /*!< GCR_T::GPD_MFP: GPD_TYPE Mask */
S
S#define SYS_GPD_MFP_GPD_MFP_Pos                  0                                          /*!< GCR_T::GPD_MFP: GPD_MFP Position */
S#define SYS_GPD_MFP_GPD_MFP_Msk                  (0xFFFFul << SYS_GPD_MFP_GPD_MFP_Pos)      /*!< GCR_T::GPD_MFP: GPD_MFP Mask */
S
S/* GCR GPEMFP Bit Field Definitions */
S#define SYS_GPE_MFP_GPE_TYPE_Pos                 16                                         /*!< GCR_T::GPE_MFP: GPE_TYPE Position */
S#define SYS_GPE_MFP_GPE_TYPE_Msk                 (0xFFFFul << SYS_GPE_MFP_GPE_TYPE_Pos)     /*!< GCR_T::GPE_MFP: GPE_TYPE Mask */
S
S#define SYS_GPE_MFP_GPE_MFP5_Pos                 5                                          /*!< GCR_T::GPE_MFP: GPE_MFP5 Position */
S#define SYS_GPE_MFP_GPE_MFP5_Msk                 (1ul << SYS_GPE_MFP_GPE_MFP5_Pos)          /*!< GCR_T::GPE_MFP: GPE_MFP5 Mask */
S
S#define SYS_GPE_MFP_GPE_MFP1_Pos                 1                                          /*!< GCR_T::GPE_MFP: GPE_MFP1 Position */
S#define SYS_GPE_MFP_GPE_MFP1_Msk                 (1ul << SYS_GPE_MFP_GPE_MFP1_Pos)          /*!< GCR_T::GPE_MFP: GPE_MFP1 Mask */
S
S#define SYS_GPE_MFP_GPE_MFP0_Pos                 0                                          /*!< GCR_T::GPE_MFP: GPE_MFP0 Position */
S#define SYS_GPE_MFP_GPE_MFP0_Msk                 (1ul << SYS_GPE_MFP_GPE_MFP0_Pos)          /*!< GCR_T::GPE_MFP: GPE_MFP0 Mask */
S
S/* GCR GPFMFP Bit Field Definitions */
S#define SYS_GPF_MFP_GPF_TYPE_Pos                 16                                         /*!< GCR_T::GPF_MFP: GPF_TYPE Position */
S#define SYS_GPF_MFP_GPF_TYPE_Msk                 (0xFul << SYS_GPF_MFP_GPF_TYPE_Pos)        /*!< GCR_T::GPF_MFP: GPF_TYPE Mask */
S
S#define SYS_GPF_MFP_GPF_MFP3_Pos                 3                                          /*!< GCR_T::GPF_MFP: GPF_MFP3 Position */
S#define SYS_GPF_MFP_GPF_MFP3_Msk                 (1ul << SYS_GPF_MFP_GPF_MFP3_Pos)          /*!< GCR_T::GPF_MFP: GPF_MFP3 Mask */
S
S#define SYS_GPF_MFP_GPF_MFP2_Pos                 2                                          /*!< GCR_T::GPF_MFP: GPF_MFP2 Position */
S#define SYS_GPF_MFP_GPF_MFP2_Msk                 (1ul << SYS_GPF_MFP_GPF_MFP2_Pos)          /*!< GCR_T::GPF_MFP: GPF_MFP2 Mask */
S
S#define SYS_GPF_MFP_GPF_MFP1_Pos                 1                                          /*!< GCR_T::GPF_MFP: GPF_MFP1 Position */
S#define SYS_GPF_MFP_GPF_MFP1_Msk                 (1ul << SYS_GPF_MFP_GPF_MFP1_Pos)          /*!< GCR_T::GPF_MFP: GPF_MFP1 Mask */
S
S#define SYS_GPF_MFP_GPF_MFP0_Pos                 0                                          /*!< GCR_T::GPF_MFP: GPF_MFP0 Position */
S#define SYS_GPF_MFP_GPF_MFP0_Msk                 (1ul << SYS_GPF_MFP_GPF_MFP0_Pos)          /*!< GCR_T::GPF_MFP: GPF_MFP0 Mask */
S
S/* GCR ALTMFP Bit Field Definitions */
S#define SYS_ALT_MFP_PB2_CPO0_Pos                 30                                         /*!< GCR_T::ALT_MFP: PB2_CPO0 Position */
S#define SYS_ALT_MFP_PB2_CPO0_Msk                 (1ul << SYS_ALT_MFP_PB2_CPO0_Pos)          /*!< GCR_T::ALT_MFP: PB2_CPO0 Mask */
S
S#define SYS_ALT_MFP_PB8_CLKO_Pos                 29                                         /*!< GCR_T::ALT_MFP: PB8_CLKO Position */
S#define SYS_ALT_MFP_PB8_CLKO_Msk                 (1ul << SYS_ALT_MFP_PB8_CLKO_Pos)          /*!< GCR_T::ALT_MFP: PB8_CLKO Mask */
S
S#define SYS_ALT_MFP_PA10_11_CAN1_Pos             28                                         /*!< GCR_T::ALT_MFP: PA10_11_CAN1 Position */
S#define SYS_ALT_MFP_PA10_11_CAN1_Msk             (1ul << SYS_ALT_MFP_PA10_11_CAN1_Pos)      /*!< GCR_T::ALT_MFP: PA10_11_CAN1 Mask */
S
S#define SYS_ALT_MFP_PB3_T3EX_Pos                 27                                         /*!< GCR_T::ALT_MFP: PB3_T3EX Position */
S#define SYS_ALT_MFP_PB3_T3EX_Msk                 (1ul << SYS_ALT_MFP_PB3_T3EX_Pos)          /*!< GCR_T::ALT_MFP: PB3_T3EX Mask */
S
S#define SYS_ALT_MFP_PB2_T2EX_Pos                 26                                         /*!< GCR_T::ALT_MFP: PB2_T2EX Position */
S#define SYS_ALT_MFP_PB2_T2EX_Msk                 (1ul << SYS_ALT_MFP_PB2_T2EX_Pos)          /*!< GCR_T::ALT_MFP: PB3_T3EX Mask */
S
S#define SYS_ALT_MFP_PE5_T1EX_Pos                 25                                         /*!< GCR_T::ALT_MFP: PE5_T1EX Position */
S#define SYS_ALT_MFP_PE5_T1EX_Msk                 (1ul << SYS_ALT_MFP_PE5_T1EX_Pos)          /*!< GCR_T::ALT_MFP: PE5_T1EX Mask */
S
S#define SYS_ALT_MFP_PB15_T0EX_Pos                24                                         /*!< GCR_T::ALT_MFP: PB15_T0EX Position */
S#define SYS_ALT_MFP_PB15_T0EX_Msk                (1ul << SYS_ALT_MFP_PB15_T0EX_Pos)         /*!< GCR_T::ALT_MFP: PB15_T0EX Mask */
S
S#define SYS_ALT_MFP_EBI_HB_EN_Pos                16                                         /*!< GCR_T::ALT_MFP: EBI_HB_EN Position */
S#define SYS_ALT_MFP_EBI_HB_EN_Msk                (0xFFul << SYS_ALT_MFP_EBI_HB_EN_Pos)      /*!< GCR_T::ALT_MFP: EBI_HB_EN Mask */
S
S#define SYS_ALT_MFP_EBI_nWRH_EN_Pos              14                                         /*!< GCR_T::ALT_MFP: EBI_nWRH_EN Position */
S#define SYS_ALT_MFP_EBI_nWRH_EN_Msk              (1ul << SYS_ALT_MFP_EBI_nWRH_EN_Pos)       /*!< GCR_T::ALT_MFP: EBI_nWRH_EN Mask */
S
S#define SYS_ALT_MFP_EBI_nWRL_EN_Pos              13                                         /*!< GCR_T::ALT_MFP: EBI_nWRL_EN Position */
S#define SYS_ALT_MFP_EBI_nWRL_EN_Msk              (1ul << SYS_ALT_MFP_EBI_nWRL_EN_Pos)       /*!< GCR_T::ALT_MFP: EBI_nWRL_EN Mask */
S
S#define SYS_ALT_MFP_EBI_MCLK_EN_Pos              12                                         /*!< GCR_T::ALT_MFP: EBI_MCLK_EN Position */
S#define SYS_ALT_MFP_EBI_MCLK_EN_Msk              (1ul << SYS_ALT_MFP_EBI_MCLK_EN_Pos)       /*!< GCR_T::ALT_MFP: EBI_MCLK_EN Mask */
S
S#define SYS_ALT_MFP_EBI_EN_Pos                   11                                         /*!< GCR_T::ALT_MFP: EBI_EN Position */
S#define SYS_ALT_MFP_EBI_EN_Msk                   (1ul << SYS_ALT_MFP_EBI_EN_Pos)            /*!< GCR_T::ALT_MFP: EBI_EN Mask */
S
S#define SYS_ALT_MFP_PA15_I2SMCLK_Pos             9                                          /*!< GCR_T::ALT_MFP: PA15_I2SMCLK Position */
S#define SYS_ALT_MFP_PA15_I2SMCLK_Msk             (1ul << SYS_ALT_MFP_PA15_I2SMCLK_Pos)      /*!< GCR_T::ALT_MFP: PA15_I2SMCLK Mask */
S
S#define SYS_ALT_MFP_PC3_I2SDO_Pos                8                                          /*!< GCR_T::ALT_MFP: PC3_I2SDO Position */
S#define SYS_ALT_MFP_PC3_I2SDO_Msk                (1ul << SYS_ALT_MFP_PC3_I2SDO_Pos)         /*!< GCR_T::ALT_MFP: PC3_I2SDO Mask */
S
S#define SYS_ALT_MFP_PC2_I2SDI_Pos                7                                          /*!< GCR_T::ALT_MFP: PC2_I2SDI Position */
S#define SYS_ALT_MFP_PC2_I2SDI_Msk                (1ul << SYS_ALT_MFP_PC2_I2SDI_Pos)         /*!< GCR_T::ALT_MFP: PC2_I2SDI Mask */
S
S#define SYS_ALT_MFP_PC1_I2SBCLK_Pos              6                                          /*!< GCR_T::ALT_MFP: PC1_I2SBCLK Position */
S#define SYS_ALT_MFP_PC1_I2SBCLK_Msk              (1ul << SYS_ALT_MFP_PC1_I2SBCLK_Pos)       /*!< GCR_T::ALT_MFP: PC1_I2SBCLK Mask */
S
S#define SYS_ALT_MFP_PC0_I2SLRCLK_Pos             5                                          /*!< GCR_T::ALT_MFP: PC0_I2SLRCLK Position */
S#define SYS_ALT_MFP_PC0_I2SLRCLK_Msk             (1ul << SYS_ALT_MFP_PC0_I2SLRCLK_Pos)      /*!< GCR_T::ALT_MFP: PC0_I2SLRCLK Mask */
S
S#define SYS_ALT_MFP_PB11_PWM4_Pos                4                                          /*!< GCR_T::ALT_MFP: PB11_PWM4 Position */
S#define SYS_ALT_MFP_PB11_PWM4_Msk                (1ul << SYS_ALT_MFP_PB11_PWM4_Pos)         /*!< GCR_T::ALT_MFP: PB11_PWM4 Mask */
S
S#define SYS_ALT_MFP_PB14_S31_Pos                 3                                          /*!< GCR_T::ALT_MFP: PB14_S31 Position */
S#define SYS_ALT_MFP_PB14_S31_Msk                 (1ul << SYS_ALT_MFP_PB14_S31_Pos)          /*!< GCR_T::ALT_MFP: PB14_S31 Mask */
S
S#define SYS_ALT_MFP_PA7_S21_Pos                  2                                          /*!< GCR_T::ALT_MFP: PA7_S21 Position */
S#define SYS_ALT_MFP_PA7_S21_Msk                  (1ul << SYS_ALT_MFP_PA7_S21_Pos)           /*!< GCR_T::ALT_MFP: PA7_S21 Mask */
S
S#define SYS_ALT_MFP_PB9_S11_Pos                  1                                          /*!< GCR_T::ALT_MFP: PB9_S11 Position */
S#define SYS_ALT_MFP_PB9_S11_Msk                  (1ul << SYS_ALT_MFP_PB9_S11_Pos)           /*!< GCR_T::ALT_MFP: PB9_S11 Mask */
S
S#define SYS_ALT_MFP_PB10_S01_Pos                 0                                          /*!< GCR_T::ALT_MFP: PB10_S01 Position */
S#define SYS_ALT_MFP_PB10_S01_Msk                 (1ul << SYS_ALT_MFP_PB10_S01_Pos)          /*!< GCR_T::ALT_MFP: PB10_S01 Mask */
S
S/* GCR ALTMFP1 Bit Field Definitions */
S#define SYS_ALT_MFP1_PB3_SC2CD_Pos              14                                          /*!< GCR_T::ALT_MFP1: PB3_SC2CD Position */
S#define SYS_ALT_MFP1_PB3_SC2CD_Msk              (1ul << SYS_ALT_MFP1_PB3_SC2CD_Pos)         /*!< GCR_T::ALT_MFP1: PB3_SC2CD Mask */
S
S#define SYS_ALT_MFP1_PA14_SC2RST_Pos            13                                          /*!< GCR_T::ALT_MFP1: PA14_SC2RST Position */
S#define SYS_ALT_MFP1_PA14_SC2RST_Msk            (1ul << SYS_ALT_MFP1_PA14_SC2RST_Pos)       /*!< GCR_T::ALT_MFP1: PA14_SC2RST Mask */
S
S#define SYS_ALT_MFP1_PA15_SC2PWR_Pos            12                                          /*!< GCR_T::ALT_MFP1: PA15_SC2PWR Position */
S#define SYS_ALT_MFP1_PA15_SC2PWR_Msk            (1ul << SYS_ALT_MFP1_PA15_SC2PWR_Pos)       /*!< GCR_T::ALT_MFP1: PA15_SC2PWR Mask */
S
S#define SYS_ALT_MFP1_PA12_SC2DAT_Pos            11                                          /*!< GCR_T::ALT_MFP1: PA12_SC2DAT Position */
S#define SYS_ALT_MFP1_PA12_SC2DAT_Msk            (1ul << SYS_ALT_MFP1_PA12_SC2DAT_Pos)        /*!< GCR_T::ALT_MFP1: PA12_SC2DAT Mask */
S
S#define SYS_ALT_MFP1_PA13_SC2CLK_Pos            10                                          /*!< GCR_T::ALT_MFP1: PA13_SC2CLK Position */
S#define SYS_ALT_MFP1_PA13_SC2CLK_Msk            (1ul << SYS_ALT_MFP1_PA13_SC2CLK_Pos)        /*!< GCR_T::ALT_MFP1: PA13_SC2CLK Mask */
S
S#define SYS_ALT_MFP1_PC7_SC1CD_Pos              9                                          /*!< GCR_T::ALT_MFP1: PC7_SC1CD Position */
S#define SYS_ALT_MFP1_PC7_SC1CD_Msk              (1ul << SYS_ALT_MFP1_PC7_SC1CD_Pos)        /*!< GCR_T::ALT_MFP1: PC7_SC1CD Mask */
S
S#define SYS_ALT_MFP1_PA5_SC1RST_Pos             8                                           /*!< GCR_T::ALT_MFP1: PA5_SC1RST Position */
S#define SYS_ALT_MFP1_PA5_SC1RST_Msk             (1ul << SYS_ALT_MFP1_PA5_SC1RST_Pos)        /*!< GCR_T::ALT_MFP1: PA5_SC1RST Mask */
S
S#define SYS_ALT_MFP1_PA4_SC1PWR_Pos             7                                           /*!< GCR_T::ALT_MFP1: PA4_SC1PWR Position */
S#define SYS_ALT_MFP1_PA4_SC1PWR_Msk             (1ul << SYS_ALT_MFP1_PA4_SC1PWR_Pos)        /*!< GCR_T::ALT_MFP1: PA4_SC1PWR Mask */
S
S#define SYS_ALT_MFP1_PA7_SC1DAT_Pos             6                                           /*!< GCR_T::ALT_MFP1: PA7_SC1DAT Position */
S#define SYS_ALT_MFP1_PA7_SC1DAT_Msk             (1ul << SYS_ALT_MFP1_PA7_SC1DAT_Pos)        /*!< GCR_T::ALT_MFP1: PA7_SC1DAT Mask */
S
S#define SYS_ALT_MFP1_PA6_SC1CLK_Pos             5                                           /*!< GCR_T::ALT_MFP1: PA6_SC1CLK Position */
S#define SYS_ALT_MFP1_PA6_SC1CLK_Msk             (1ul << SYS_ALT_MFP1_PA6_SC1CLK_Pos)        /*!< GCR_T::ALT_MFP1: PA6_SC1CLK Mask */
S
S#define SYS_ALT_MFP1_PC6_SC0CD_Pos              4                                           /*!< GCR_T::ALT_MFP1: PC6_SC0CD Position */
S#define SYS_ALT_MFP1_PC6_SC0CD_Msk              (1ul << SYS_ALT_MFP1_PC6_SC0CD_Pos)         /*!< GCR_T::ALT_MFP1: PC6_SC0CD Mask */
S
S#define SYS_ALT_MFP1_PA1_SC0RST_Pos             3                                           /*!< GCR_T::ALT_MFP1: PA1_SC0RST Position */
S#define SYS_ALT_MFP1_PA1_SC0RST_Msk             (1ul << SYS_ALT_MFP1_PA1_SC0RST_Pos)        /*!< GCR_T::ALT_MFP1: PA1_SC0RST Mask */
S
S#define SYS_ALT_MFP1_PA0_SC0PWR_Pos             2                                           /*!< GCR_T::ALT_MFP1: PA0_SC0PWR Position */
S#define SYS_ALT_MFP1_PA0_SC0PWR_Msk             (1ul << SYS_ALT_MFP1_PA0_SC0PWR_Pos)        /*!< GCR_T::ALT_MFP1: PA0_SC0PWR Mask */
S
S#define SYS_ALT_MFP1_PA3_SC0DAT_Pos             1                                           /*!< GCR_T::ALT_MFP1: PA3_SC0DAT Position */
S#define SYS_ALT_MFP1_PA3_SC0DAT_Msk             (1ul << SYS_ALT_MFP1_PA3_SC0DAT_Pos)        /*!< GCR_T::ALT_MFP1: PA3_SC0DAT Mask */
S
S#define SYS_ALT_MFP1_PA2_SC0CLK_Pos             0                                           /*!< GCR_T::ALT_MFP1: PA2_SC0CLK Position */
S#define SYS_ALT_MFP1_PA2_SC0CLK_Msk             (1ul << SYS_ALT_MFP1_PA2_SC0CLK_Pos)        /*!< GCR_T::ALT_MFP1: PA2_SC0CLK Mask */
S
S/* GCR ALTMFP2 Bit Field Definitions */
S#define SYS_ALT_MFP2_PB3_TM3_Pos                5                                           /*!< GCR_T::ALT_MFP2: PB3_TM3 Position */
S#define SYS_ALT_MFP2_PB3_TM3_Msk                (1ul << SYS_ALT_MFP2_PB3_TM3_Pos)           /*!< GCR_T::ALT_MFP2: PB3_TM3 Mask */
S
S#define SYS_ALT_MFP2_PB2_TM2_Pos                4                                           /*!< GCR_T::ALT_MFP2: PB2_TM2 Position */
S#define SYS_ALT_MFP2_PB2_TM2_Msk                (1ul << SYS_ALT_MFP2_PB2_TM2_Pos)           /*!< GCR_T::ALT_MFP2: PB2_TM2 Mask */
S
S#define SYS_ALT_MFP2_PE5_TM1_Pos                3                                           /*!< GCR_T::ALT_MFP2: PE5_TM1 Position */
S#define SYS_ALT_MFP2_PE5_TM1_Msk                (1ul << SYS_ALT_MFP2_PE5_TM1_Pos)           /*!< GCR_T::ALT_MFP2: PE5_TM1 Mask */
S
S#define SYS_ALT_MFP2_PB15_TM0_Pos               2                                           /*!< GCR_T::ALT_MFP2: PB15_TM0 Position */
S#define SYS_ALT_MFP2_PB15_TM0_Msk               (1ul << SYS_ALT_MFP2_PB15_TM0_Pos)          /*!< GCR_T::ALT_MFP2: PB15_TM0 Mask */
S
S#define SYS_ALT_MFP2_PB14_15_EBI_Pos            0                                           /*!< GCR_T::ALT_MFP2: PB14_15_EBI Position */
S#define SYS_ALT_MFP2_PB14_15_EBI_Msk            (1ul << SYS_ALT_MFP2_PB14_15_EBI_Pos)       /*!< GCR_T::ALT_MFP2: PB14_15_EBI Mask */
S
S#define SYS_ALT_MFP2_PD14_15_CAN1_Pos           0                                           /*!< GCR_T::ALT_MFP2: PD14_15_CAN1 Position */
S#define SYS_ALT_MFP2_PD14_15_CAN1_Msk           (1ul << SYS_ALT_MFP2_PD14_15_CAN1_Pos)      /*!< GCR_T::ALT_MFP2: PD14_15_CAN1 Mask */
S
S/* GCR IRCTRIMCTL Bit Field Definitions */
S#define SYS_IRCTRIMCTL_CLKERR_STOP_EN_Pos       8                                           /*!< GCR_T::IRCTRIMCTL: CLKERR_STOP_EN Position */
S#define SYS_IRCTRIMCTL_CLKERR_STOP_EN_Msk       (1ul << SYS_IRCTRIMCTL_CLKERR_STOP_EN_Pos)  /*!< GCR_T::IRCTRIMCTL: CLKERR_STOP_EN Mask */
S
S#define SYS_IRCTRIMCTL_TRIM_RETRY_CNT_Pos       6                                           /*!< GCR_T::IRCTRIMCTL: TRIM_RETRY_CNT Position */
S#define SYS_IRCTRIMCTL_TRIM_RETRY_CNT_Msk       (3ul << SYS_IRCTRIMCTL_TRIM_RETRY_CNT_Pos)  /*!< GCR_T::IRCTRIMCTL: TRIM_RETRY_CNT Mask */
S
S#define SYS_IRCTRIMCTL_TRIM_LOOP_Pos            4                                           /*!< GCR_T::IRCTRIMCTL: TRIM_LOOP Position */
S#define SYS_IRCTRIMCTL_TRIM_LOOP_Msk            (3ul << SYS_IRCTRIMCTL_TRIM_LOOP_Pos)       /*!< GCR_T::IRCTRIMCTL: TRIM_LOOP Mask */
S
S#define SYS_IRCTRIMCTL_TRIM_SEL_Pos             0                                           /*!< GCR_T::IRCTRIMCTL: TRIM_SEL Position */
S#define SYS_IRCTRIMCTL_TRIM_SEL_Msk             (3ul << SYS_IRCTRIMCTL_TRIM_SEL_Pos)        /*!< GCR_T::IRCTRIMCTL: TRIM_SEL Mask */
S
S/* GCR IRCTRIMIEN Bit Field Definitions */
S#define SYS_IRCTRIMIEN_CLKERR_IEN_Pos           2                                           /*!< GCR_T::IRCTRIMIEN: CLKERR_IEN Position */
S#define SYS_IRCTRIMIEN_CLKERR_IEN_Msk           (1ul << SYS_IRCTRIMIEN_CLKERR_IEN_Pos)      /*!< GCR_T::IRCTRIMIEN: CLKERR_IEN Mask */
S
S#define SYS_IRCTRIMIEN_TRIM_FAIL_IEN_Pos        1                                           /*!< GCR_T::IRCTRIMIEN: TRIM_FAIL_IEN Position */
S#define SYS_IRCTRIMIEN_TRIM_FAIL_IEN_Msk        (1ul << SYS_IRCTRIMIEN_TRIM_FAIL_IEN_Pos)   /*!< GCR_T::IRCTRIMIEN: TRIM_FAIL_IEN Mask */
S
S/* GCR IRCTRIMINT Bit Field Definitions */
S#define SYS_IRCTRIMINT_CLKERR_INT_Pos           2                                           /*!< GCR_T::IRCTRIMINT: CLKERR_INT Position */
S#define SYS_IRCTRIMINT_CLKERR_INT_Msk           (1ul << SYS_IRCTRIMINT_CLKERR_INT_Pos)      /*!< GCR_T::IRCTRIMINT: CLKERR_INT Mask */
S
S#define SYS_IRCTRIMINT_TRIM_FAIL_INT_Pos        1                                           /*!< GCR_T::IRCTRIMINT: TRIM_FAIL_INT Position */
S#define SYS_IRCTRIMINT_TRIM_FAIL_INT_Msk        (1ul << SYS_IRCTRIMINT_TRIM_FAIL_INT_Pos)   /*!< GCR_T::IRCTRIMINT: TRIM_FAIL_INT Mask */
S
S#define SYS_IRCTRIMINT_FREQ_LOCK_Pos            0                                           /*!< GCR_T::IRCTRIMINT: FREQ_LOCK Position */
S#define SYS_IRCTRIMINT_FREQ_LOCK_Msk            (1ul << SYS_IRCTRIMINT_FREQ_LOCK_Pos)       /*!< GCR_T::IRCTRIMINT: FREQ_LOCK Mask */
S
S/* GCR REGWRPROT Bit Field Definitions */
S#define SYS_REGWRPROT_REGWRPROT_Pos             0                                           /*!< GCR_T::REGWRPROT: REGWRPROT Position */
S#define SYS_REGWRPROT_REGWRPROT_Msk             (0xFFul << SYS_REGWRPROT_REGWRPROT_Pos)     /*!< GCR_T::REGWRPROT: REGWRPROT Mask */
S
S#define SYS_REGWRPROT_REGPROTDIS_Pos            0                                       /*!< GCR_T::REGWRPROT: REGPROTDIS Position */
S#define SYS_REGWRPROT_REGPROTDIS_Msk            (1ul << SYS_REGWRPROT_REGPROTDIS_Pos)   /*!< GCR_T::REGWRPROT: REGPROTDIS Mask */
S/*@}*/ /* end of group SYS_CONST */
S
S
S
Stypedef struct
S{
S
S/**
S * @var GCR_INT_T::IRQSRC[32]
S * Offset: 0x00-0x7C  IRQn(n=0~31) Interrupt Source Identity Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[5:0]   |INT_SRC   |Interrupt Source Identity
S * |        |          |IRQ_SRC[0].0 - BOD INT
S * |        |          |IRQ_SRC[1].0 - WDT INT
S * |        |          |IRQ_SRC[1].1 - WWDT INT
S * |        |          |IRQ_SRC[2].0 - EINT0, external interrupt 0 from PB.14
S * |        |          |IRQ_SRC[3].0 - EINT1, external interrupt 1 from PB.15
S * |        |          |IRQ_SRC[4].0 - GPA INT
S * |        |          |IRQ_SRC[4].1 - GPB INT
S * |        |          |IRQ_SRC[5].0 - GPC INT
S * |        |          |IRQ_SRC[5].1 - GPD INT
S * |        |          |IRQ_SRC[5].2 - GPE INT
S * |        |          |IRQ_SRC[5].3 - GPF INT
S * |        |          |IRQ_SRC[6].0 - PWM0 INT
S * |        |          |IRQ_SRC[6].1 - PWM1 INT
S * |        |          |IRQ_SRC[6].2 - PWM2 INT
S * |        |          |IRQ_SRC[6].3 - PWM3 INT
S * |        |          |IRQ_SRC[7].0 - PWM4 INT
S * |        |          |IRQ_SRC[7].1 - PWM5 INT
S * |        |          |IRQ_SRC[7].2 - PWM6 INT
S * |        |          |IRQ_SRC[7].3 - PWM7 INT
S * |        |          |IRQ_SRC[8].0 - TMR0 INT
S * |        |          |IRQ_SRC[9].0 - TMR1 INT
S * |        |          |IRQ_SRC[10].0 - TMR2 INT
S * |        |          |IRQ_SRC[11].0 - TMR3 INT
S * |        |          |IRQ_SRC[12].0 - UART0 INT
S * |        |          |IRQ_SRC[12].1 - UART2 INT
S * |        |          |IRQ_SRC[13].0 - UART1 INT
S * |        |          |IRQ_SRC[14].0 - SPI0 INT
S * |        |          |IRQ_SRC[15].0 - SPI1 INT
S * |        |          |IRQ_SRC[16].0 - SPI2 INT
S * |        |          |IRQ_SRC[17].0 - SPI3 INT
S * |        |          |IRQ_SRC[18].0 - I2C0 INT
S * |        |          |IRQ_SRC[19].0 - I2C1 INT
S * |        |          |IRQ_SRC[22].0 - SC0 INT
S * |        |          |IRQ_SRC[22].1 - SC1 INT
S * |        |          |IRQ_SRC[22].2 - SC2 INT
S * |        |          |IRQ_SRC[23].0 - USB INT
S * |        |          |IRQ_SRC[24].0 - PS2 INT
S * |        |          |IRQ_SRC[25].0 - ACMP INT
S * |        |          |IRQ_SRC[26].0 - PDMA INT
S * |        |          |IRQ_SRC[27].0 - I2S INT
S * |        |          |IRQ_SRC[28].0 - Power Down Wake up INT
S * |        |          |IRQ_SRC[29].0 - ADC INT
S * |        |          |IRQ_SRC[30].0 - IRC INT
S * |        |          |IRQ_SRC[31].0 - RTC INT
S * @var GCR_INT_T::NMISEL
S * Offset: 0x80  NMI Interrupt Source Select Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[4:0]   |NMI_SEL   |NMI interrupt source selection
S * |        |          |The NMI interrupt to Cortex-M0 can be selected from one of IRQ0~IRQ31 by setting NMI_SEL with
S * |        |          |IRQ number.
S * |        |          |The default NMI interrupt is assigned as IRQ0 interrupt if NMI is enabled by setting NMI_SEL[8].
S * |[8]     |NMI_EN    |NMI interrupt enable (Write Protect)
S * |        |          |0 = IRQ0~31 assigned to NMI interrupt Disabled. (NMI still can be software triggered by setting
S * |        |          |its pending flag.)
S * |        |          |1 = IRQ0~31 assigned to NMI interrupt Enabled.
S * |        |          |Note: This bit is write protected bit. Refer to the REGWRPROT register.
S * @var GCR_INT_T::MCUIRQ
S * Offset: 0x84  MCU Interrupt Request Source Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |MCU_IRQ   |MCU IRQ Source Register
S * |        |          |The MCU_IRQ collects all the interrupts from the peripherals and generates the synchronous
S * |        |          |interrupt to Cortex-M0.
S * |        |          |When the MCU_IRQ[n] is 0:
S * |        |          |0 = No effect.
S * |        |          |1 = Generate an interrupt to Cortex_M0 NVIC[n].
S * |        |          |When the MCU_IRQ[n] is 1 (means an interrupt is assert):
S * |        |          |0 = No effect.
S * |        |          |1 = Clear the interrupt and MCU_IRQ[n].
S * @var GCR_INT_T::MCUIRQCR
S * Offset: 0x88  MCU Interrupt Request Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |FAST_IRQ  |Fast IRQ Latency Enable
S * |        |          |0 = MCU IRQ latency is fixed at 13 clock cycles of HCLK, 
S * |        |          |    MCU will enter IRQ handler after this fixed latency when interrupt happened.
S * |        |          |1 = MCU IRQ latency will not fixed, MCU will enter IRQ handler as soon as possible when
S * |        |          |interrupt happened.
S */
S
S    __I  uint32_t IRQSRC[32];   /* Offset: 0x00-0x7C  IRQn(n=0~31) Interrupt Source Identity Register               */
S    __IO uint32_t NMISEL;       /* Offset: 0x80  NMI Interrupt Source Select Control Register                       */
S    __IO uint32_t MCUIRQ;       /* Offset: 0x84  MCU Interrupt Request Source Register                              */
S    __IO uint32_t MCUIRQCR;     /* Offset: 0x88  MCU MCU Interrupt Request Control Register                         */ 
S
S} GCR_INT_T;
S
S
S/**
S    @addtogroup INT_CONST INT Bit Field Definition
S    Constant Definitions for INT Controller
S@{ */
S
S
S/* INT IRQSRC Bit Field Definitions */
S#define INT_IRQSRC_INT_SRC_Pos                  0                                   /*!< GCR_INT_T::IRQSRC: INT_SRC Position */
S#define INT_IRQSRC_INT_SRC_Msk                  (0xFul << INT_IRQSRC_INT_SRC_Pos)
S
S/* INT NMISEL Bit Field Definitions */
S#define INT_NMISEL_NMI_EN_Pos                   8                                   /*!< GCR_INT_T::NMISEL: NMI_EN Position */
S#define INT_NMISEL_NMI_EN_Msk                   (1ul << INT_NMISEL_NMI_EN_Pos)      /*!< GCR_INT_T::NMISEL: NMI_EN Mask */
S
S#define INT_NMISEL_NMI_SEL_Pos                  0                                   /*!< GCR_INT_T::NMISEL: NMI_SEL Position */
S#define INT_NMISEL_NMI_SEL_Msk                  (0x1Ful << INT_NMISEL_NMI_SEL_Pos)  /*!< GCR_INT_T::NMISEL: NMI_SEL Mask */
S
S/* INT MCUIRQ Bit Field Definitions */
S#define INT_MCUIRQ_MCU_IRQ_Pos                  0                                           /*!< GCR_INT_T::MCUIRQ: MCU_IRQ Position */
S#define INT_MCUIRQ_MCU_IRQ_Msk                  (0xFFFFFFFFul << INT_MCUIRQ_MCU_IRQ_Pos)    /*!< GCR_INT_T::MCUIRQ: MCU_IRQ Mask */
S
S/* INT MCUIRQCR Bit Field Definitions */
S#define INT_MCUIRQCR_MCU_IRQ_Pos                0                                   /*!< GCR_INT_T::MCUIRQCR: FAST_IRQ Position */
S#define INT_MCUIRQCR_MCU_IRQ_Msk                (1ul << INT_MCUIRQCR_MCU_IRQ_Pos)   /*!< GCR_INT_T::MCUIRQCR: FAST_IRQ Mask */
S
S/*@}*/ /* end of group INT_CONST */
S/*@}*/ /* end of group SYS */
S
S
S/*---------------------- Timer Controller -------------------------*/
S/**
S    @addtogroup TIMER Timer Controller (TIMER)
S    Memory Mapped Structure for TMR Controller
S@{ */
S
S
Stypedef struct
S{
S
S
S/**
S * @var TIMER_T::TCSR
S * Offset: 0x00  Timer Control and Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |PRESCALE  |Prescale Counter
S * |        |          |Timer input clock source is divided by (PRESCALE+1) before it is fed to the Timer up counter.
S * |        |          |If this field is 0 (PRESCALE = 0), then there is no scaling.
S * |[16]    |TDR_EN    |Data Load Enable Control
S * |        |          |When TDR_EN is set, TDR (Timer Data Register) will be updated continuously with the 24-bit
S * |        |          |up-timer value as the timer is counting.
S * |        |          |0 = Timer Data Register update Disabled.
S * |        |          |1 = Timer Data Register update Enabled while Timer counter is active.
S * |[23]    |WAKE_EN   |Wake Up Function Enable Control
S * |        |          |0 = Wake-up trigger event Disabled.
S * |        |          |1 = Wake-up trigger event Enabled.
S * |[24]    |CTB       |Counter Mode Enable Control
S * |        |          |This bit is for external counting pin function enabled.
S * |        |          |When timer is used as an event counter, this bit should be set to 1 and select HCLK as timer
S * |        |          |clock source.
S * |        |          |0 = External counter mode Disabled.
S * |        |          |1 = External counter mode Enabled.
S * |[25]    |CACT      |Timer Active Status (Read Only)
S * |        |          |This bit indicates the 24-bit up counter status.
S * |        |          |0 = 24-bit up counter is not active.
S * |        |          |1 = 24-bit up counter is active.
S * |[26]    |CRST      |Timer Reset
S * |        |          |0 = No effect.
S * |        |          |1 = Reset 8-bit prescale counter, 24-bit up counter value and CEN bit if CACT is 1.
S * |[28:27] |MODE      |Timer Operating Mode
S * |        |          |00 = The Timer controller is operated in One-shot mode.
S * |        |          |01 = The Timer controller is operated in Periodic mode.
S * |        |          |10 = The Timer controller is operated in Toggle-output mode.
S * |        |          |11 = The Timer controller is operated in Continuous Counting mode.
S * |[29]    |IE        |Interrupt Enable Control
S * |        |          |0 = Timer Interrupt function Disabled.
S * |        |          |1 = Timer Interrupt function Enabled.
S * |        |          |If this bit is enabled, when the timer interrupt flag (TISR[0] TIF) is set to 1, the timer
S * |        |          |interrupt signal is generated and inform to CPU.
S * |[30]    |CEN       |Timer Enable Control
S * |        |          |0 = Stops/Suspends counting.
S * |        |          |1 = Starts counting.
S * |        |          |Note1: In stop status, and then set CEN to 1 will enable the 24-bit up counter to keep counting
S * |        |          |from the last stop counting value.
S * |        |          |Note2: This bit is auto-cleared by hardware in one-shot mode (TCSR [28:27] = 00) when the timer
S * |        |          |interrupt flag (TISR[0] TIF) is generated.
S * |[31]    |DBGACK_TMR|ICE Debug Mode Acknowledge Disable (Write Protect)
S * |        |          |0 = ICE debug mode acknowledgement effects TIMER counting.
S * |        |          |TIMER counter will be held while CPU is held by ICE.
S * |        |          |1 = ICE debug mode acknowledgement Disabled.
S * |        |          |TIMER counter will keep going no matter CPU is held by ICE or not.
S * @var TIMER_T::TCMPR
S * Offset: 0x04  Timer Compare Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[23:0]  |TCMP      |Timer Compared Value
S * |        |          |TCMP is a 24-bit compared value register.
S * |        |          |When the internal 24-bit up counter value is equal to TCMP value, the TIF flag will set to 1.
S * |        |          |Time-out period = (Period of Timer clock input) * (8-bit PRESCALE + 1) * (24-bit TCMP).
S * |        |          |Note1: Never write 0x0 or 0x1 in TCMP field, or the core will run into unknown state.
S * |        |          |Note2: When timer is operating at continuous counting mode, the 24-bit up counter will keep
S * |        |          |counting continuously even if user writes a new value into TCMP field.
S * |        |          |But if timer is operating at other modes, the 24-bit up counter will restart counting and using
S * |        |          |newest TCMP value to be the timer compared value if user writes a new value into TCMP field.
S * @var TIMER_T::TISR
S * Offset: 0x08  Timer Interrupt Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |TIF       |Timer Interrupt Flag
S * |        |          |This bit indicates the interrupt flag status of Timer while TDR value reaches to TCMP value.
S * |        |          |0 = No effect.
S * |        |          |1 = TDR value matches the TCMP value.
S * |        |          |Note: This bit is cleared by writing 1 to it.
S * |[1]     |TWF       |Timer Wake-Up Flag
S * |        |          |This bit indicates the interrupt wake-up flag status of Timer.
S * |        |          |0 = Timer does not cause CPU wake-up.
S * |        |          |1 = CPU wake-up from Idle or Power-down mode if Timer time-out interrupt signal generated.
S * |        |          |Note: This bit is cleared by writing 1 to it.
S * @var TIMER_T::TDR
S * Offset: 0x0C  Timer Data Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[23:0]  |TDR       |Timer Data Register
S * |        |          |If TDR_EN (TCSR[16]) is set to 1, TDR register will be updated continuously to monitor 24-bit up
S * |        |          |counter value.
S * @var TIMER_T::TCAP
S * Offset: 0x10  Timer Capture Data Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[23:0]  |TCAP      |Timer Capture Data Register
S * |        |          |When TEXIF flag is set to 1, the current TDR value will be auto-loaded into this TCAP filed
S * |        |          |immediately.
S * @var TIMER_T::TEXCON
S * Offset: 0x14  Timer External Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |TX_PHASE  |Timer External Count Pin Phase Detect Selection
S * |        |          |This bit indicates the detection phase of TMx pin.
S * |        |          |0 = A falling edge of TMx pin will be counted.
S * |        |          |1 = A rising edge of TMx pin will be counted.
S * |[2:1]   |TEX_EDGE  |Timer External Capture Pin Edge Detect Selection
S * |        |          |00 = A 1 to 0 transition on TMx_EXT pin will be detected.
S * |        |          |01 = A 0 to 1 transition on TMx_EXT pin will be detected.
S * |        |          |10 = Either 1 to 0 or 0 to 1 transition on TMx_EXT pin will be detected.
S * |        |          |11 = Reserved.
S * |[3]     |TEXEN     |Timer External Pin Function Enable
S * |        |          |This bit enables the RSTCAPSEL function on the TxEX pin.
S * |        |          |0 = RSTCAPSEL function of TxEX pin will be ignored.
S * |        |          |1 = RSTCAPSEL function of TxEX pin is active.
S * |[4]     |RSTCAPSEL |Timer External Reset Counter / Timer External Capture Mode Selection
S * |        |          |0 = Transition on TMx_EXT
S * |        |          |pin is using to save the TDR value into TCAP value if TEXIF flag is set to 1.
S * |        |          |1 = Transition on TMx_EXT pin is using to reset the 24-bit up counter.
S * |[5]     |TEXIEN    |Timer External Capture Interrupt Enable Control
S * |        |          |0 = TMx_EXT pin detection Interrupt Disabled.
S * |        |          |1 = TMx_EXT pin detection Interrupt Enabled.
S * |        |          |If TEXIEN enabled, Timer will raise an external capture interrupt signal and inform to CPU while
S * |        |          |TEXIF flag is set to 1.
S * |[6]     |TEXDB     |Timer External Capture Input Pin De-Bounce Enable Control
S * |        |          |0 = TMx_EXT pin de-bounce Disabled.
S * |        |          |1 = TMx_EXT pin de-bounce Enabled.
S * |        |          |If this bit is enabled, the edge detection of TMx_EXT pin is detected with de-bounce circuit.
S * |[7]     |TCDB      |Timer External Counter Input Pin De-Bounce Enable Control
S * |        |          |0 = TMx pin de-bounce Disabled.
S * |        |          |1 = TMx pin de-bounce Enabled.
S * |        |          |If this bit is enabled, the edge detection of TMx pin is detected with de-bounce circuit.
S * @var TIMER_T::TEXISR
S * Offset: 0x18  Timer External Interrupt Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |TEXIF     |Timer External Capture Interrupt Flag
S * |        |          |This bit indicates the external capture interrupt flag status.
S * |        |          |When TEXEN enabled, TMx_EXT pin selected as external capture function, and a transition on
S * |        |          |TMx_EXT pin matched the TEX_EDGE setting, this flag will set to 1 by hardware.
S * |        |          |0 = TMx_EXT pin interrupt did not occur.
S * |        |          |1 = TMx_EXT pin interrupt occurred.
S * |        |          |Note: This bit is cleared by writing 1 to it.
S */
S
S    __IO uint32_t TCSR;          /* Offset: 0x00  Timer Control and Status Register                                  */
S    __IO uint32_t TCMPR;         /* Offset: 0x04  Timer Compare Register                                             */
S    __IO uint32_t TISR;          /* Offset: 0x08  Timer Interrupt Status Register                                    */
S    __I  uint32_t TDR;           /* Offset: 0x0C  Timer Data Register                                                */
S    __I  uint32_t TCAP;          /* Offset: 0x10  Timer Capture Data Register                                        */
S    __IO uint32_t TEXCON;        /* Offset: 0x14  Timer External Control Register                                    */
S    __IO uint32_t TEXISR;        /* Offset: 0x18  Timer External Interrupt Status Register                           */
S
S} TIMER_T;
S
S
S/**
S    @addtogroup TIMER_CONST TIMER Bit Field Definition
S    Constant Definitions for TIMER Controller
S@{ */
S
S
S/* TIMER TCSR Bit Field Definitions */
S#define TIMER_TCSR_DBGACK_TMR_Pos   31                                          /*!< TIMER_T::TCSR: DBGACK_TMR Position */
S#define TIMER_TCSR_DBGACK_TMR_Msk   (1ul << TIMER_TCSR_DBGACK_TMR_Pos)          /*!< TIMER_T::TCSR: DBGACK_TMR Mask */
S
S#define TIMER_TCSR_CEN_Pos          30                                          /*!< TIMER_T::TCSR: CEN Position */
S#define TIMER_TCSR_CEN_Msk          (1ul << TIMER_TCSR_CEN_Pos)                 /*!< TIMER_T::TCSR: CEN Mask */
S
S#define TIMER_TCSR_IE_Pos           29                                          /*!< TIMER_T::TCSR: IE Position */
S#define TIMER_TCSR_IE_Msk           (1ul << TIMER_TCSR_IE_Pos)                  /*!< TIMER_T::TCSR: IE Mask */
S
S#define TIMER_TCSR_MODE_Pos         27                                          /*!< TIMER_T::TCSR: MODE Position */
S#define TIMER_TCSR_MODE_Msk         (0x3ul << TIMER_TCSR_MODE_Pos)              /*!< TIMER_T::TCSR: MODE Mask */
S
S#define TIMER_TCSR_CRST_Pos         26                                          /*!< TIMER_T::TCSR: CRST Position */
S#define TIMER_TCSR_CRST_Msk         (1ul << TIMER_TCSR_CRST_Pos)                /*!< TIMER_T::TCSR: CRST Mask */
S
S#define TIMER_TCSR_CACT_Pos         25                                          /*!< TIMER_T::TCSR: CACT Position */
S#define TIMER_TCSR_CACT_Msk         (1ul << TIMER_TCSR_CACT_Pos)                /*!< TIMER_T::TCSR: CACT Mask */
S
S#define TIMER_TCSR_CTB_Pos          24                                          /*!< TIMER_T::TCSR: CTB Position */
S#define TIMER_TCSR_CTB_Msk          (1ul << TIMER_TCSR_CTB_Pos)                 /*!< TIMER_T::TCSR: CTB Mask */
S
S#define TIMER_TCSR_WAKE_EN_Pos      23                                          /*!< TIMER_T::TCSR: WAKE_EN Position */
S#define TIMER_TCSR_WAKE_EN_Msk      (1ul << TIMER_TCSR_WAKE_EN_Pos)             /*!< TIMER_T::TCSR: WAKE_EN Mask */
S
S#define TIMER_TCSR_TDR_EN_Pos       16                                          /*!< TIMER_T::TCSR: TDR_EN Position */
S#define TIMER_TCSR_TDR_EN_Msk       (1ul << TIMER_TCSR_TDR_EN_Pos)              /*!< TIMER_T::TCSR: TDR_EN Mask */
S
S#define TIMER_TCSR_PRESCALE_Pos     0                                           /*!< TIMER_T::TCSR: PRESCALE Position */
S#define TIMER_TCSR_PRESCALE_Msk     (0xFFul << TIMER_TCSR_PRESCALE_Pos)         /*!< TIMER_T::TCSR: PRESCALE Mask */
S
S/* TIMER TCMPR Bit Field Definitions */
S#define TIMER_TCMP_TCMP_Pos         0                                           /*!< TIMER_T::TCMPR: TCMP Position */
S#define TIMER_TCMP_TCMP_Msk         (0xFFFFFFul << TIMER_TCMP_TCMP_Pos)         /*!< TIMER_T::TCMPR: TCMP Mask */
S
S/* TIMER TISR Bit Field Definitions */
S#define TIMER_TISR_TWF_Pos          1                                           /*!< TIMER_T::TISR: TWF Position */
S#define TIMER_TISR_TWF_Msk          (1ul << TIMER_TISR_TWF_Pos)                 /*!< TIMER_T::TISR: TWF Mask */
S
S#define TIMER_TISR_TIF_Pos          0                                           /*!< TIMER_T::TISR: TIF Position */
S#define TIMER_TISR_TIF_Msk          (1ul << TIMER_TISR_TIF_Pos)                 /*!< TIMER_T::TISR: TIF Mask */
S
S/* TIMER TDR Bit Field Definitions */
S#define TIMER_TDR_TDR_Pos           0                                           /*!< TIMER_T::TDR: TDR Position */
S#define TIMER_TDR_TDR_Msk           (0xFFFFFFul << TIMER_TDR_TDR_Pos)           /*!< TIMER_T::TDR: TDR Mask */
S
S/* TIMER TCAP Bit Field Definitions */
S#define TIMER_TCAP_TCAP_Pos         0                                           /*!< TIMER_T::TCAP: TCAP Position */
S#define TIMER_TCAP_TCAP_Msk         (0xFFFFFFul << TIMER_TCAP_TCAP_Pos)         /*!< TIMER_T::TCAP: TCAP Mask */
S
S/* TIMER TEXCON Bit Field Definitions */
S#define TIMER_TEXCON_TCDB_Pos       7                                           /*!< TIMER_T::TEXCON: TCDB Position */
S#define TIMER_TEXCON_TCDB_Msk       (1ul << TIMER_TEXCON_TCDB_Pos)              /*!< TIMER_T::TEXCON: TCDB Mask */
S
S#define TIMER_TEXCON_TEXDB_Pos      6                                           /*!< TIMER_T::TEXCON: TEXDB Position */
S#define TIMER_TEXCON_TEXDB_Msk      (1ul << TIMER_TEXCON_TEXDB_Pos)             /*!< TIMER_T::TEXCON: TEXDB Mask */
S
S#define TIMER_TEXCON_TEXIEN_Pos     5                                           /*!< TIMER_T::TEXCON: TEXIEN Position */
S#define TIMER_TEXCON_TEXIEN_Msk     (1ul << TIMER_TEXCON_TEXIEN_Pos)            /*!< TIMER_T::TEXCON: TEXIEN Mask */
S
S#define TIMER_TEXCON_RSTCAPSEL_Pos  4                                           /*!< TIMER_T::TEXCON: RSTCAPSEL Position */
S#define TIMER_TEXCON_RSTCAPSEL_Msk  (1ul << TIMER_TEXCON_RSTCAPSEL_Pos)         /*!< TIMER_T::TEXCON: RSTCAPSEL Mask */
S
S#define TIMER_TEXCON_TEXEN_Pos      3                                           /*!< TIMER_T::TEXCON: TEXEN Position */
S#define TIMER_TEXCON_TEXEN_Msk      (1ul << TIMER_TEXCON_TEXEN_Pos)             /*!< TIMER_T::TEXCON: TEXEN Mask */
S
S#define TIMER_TEXCON_TEX_EDGE_Pos   1                                           /*!< TIMER_T::TEXCON: TEX_EDGE Position */
S#define TIMER_TEXCON_TEX_EDGE_Msk   (0x3ul << TIMER_TEXCON_TEX_EDGE_Pos)        /*!< TIMER_T::TEXCON: TEX_EDGE Mask */
S
S#define TIMER_TEXCON_TX_PHASE_Pos   0                                           /*!< TIMER_T::TEXCON: TX_PHASE Position */
S#define TIMER_TEXCON_TX_PHASE_Msk   (1ul << TIMER_TEXCON_TX_PHASE_Pos)          /*!< TIMER_T::TEXCON: TX_PHASE Mask */
S
S/* TIMER TEXISR Bit Field Definitions */
S#define TIMER_TEXISR_TEXIF_Pos      0                                           /*!< TIMER_T::TEXISR: TEXIF Position */
S#define TIMER_TEXISR_TEXIF_Msk      (1ul << TIMER_TEXISR_TEXIF_Pos)             /*!< TIMER_T::TEXISR: TEXIF Mask */
S/*@}*/ /* end of group TIMER_CONST */
S/*@}*/ /* end of group TIMER */
S
S
S/*---------------------- Universal Asynchronous Receiver/Transmitter Controller -------------------------*/
S/**
S    @addtogroup UART Universal Asynchronous Receiver/Transmitter Controller (UART)
S    Memory Mapped Structure for UART Controller
S@{ */
S
S
S
Stypedef struct
S{
S
S/**
S * @var UART_T::DATA
S * Offset: 0x00  UART Data Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |DATA      |Data Register
S * |        |          |By writing to this register, the UART will send out an 8-bit data through the UART_TXD pin (LSB
S * |        |          |first).
S * |        |          |By reading this register, the UART will return an 8-bit data received from UART_RXD pin (LSB
S * |        |          |first).
S * @var UART_T::THR
S * Offset: 0x00  UART Transmit Holding Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |THR       |Transmit Holding Register
S * |        |          |By writing to this register, the UART will send out an 8-bit data through the UART_TXD pin (LSB
S * |        |          |first).
S * @var UART_T::RBR
S * Offset: 0x00  UART Receive Buffer Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |RBR       |Receive Buffer Register (Read Only)
S * |        |          |By reading this register, the UART will return an 8-bit data received from UART_RXD pin (LSB
S * |        |          |first).
S * @var UART_T::IER
S * Offset: 0x04  UART Interrupt Enable Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |RDA_IEN   |Receive Data Available Interrupt Enable Control
S * |        |          |0 = RDA_INT Masked off.
S * |        |          |1 = RDA_INT Enabled.
S * |[1]     |THRE_IEN  |Transmit Holding Register Empty Interrupt Enable Control
S * |        |          |0 = THRE_INT Masked off.
S * |        |          |1 = THRE_INT Enabled.
S * |[2]     |RLS_IEN   |Receive Line Status Interrupt Enable Control
S * |        |          |0 = RLS_INT Masked off.
S * |        |          |1 = RLS_INT Enabled
S * |[3]     |MODEM_IEN |Modem Status Interrupt Enable Control (Not Available In UART2 Channel)
S * |        |          |0 = MODEM_INT Masked off.
S * |        |          |1 = MODEM_INT Enabled.
S * |[4]     |TOUT_IEN  |RX Time-Out Interrupt Enable Control
S * |        |          |0 = TOUT_INT Masked off.
S * |        |          |1 = TOUT_INT Enabled.
S * |[5]     |BUF_ERR_IEN|Buffer Error Interrupt Enable Control
S * |        |          |0 = BUF_ERR_INT Masked off.
S * |        |          |1 = BUF_ERR_INT Enabled.
S * |[6]     |WAKE_EN   |UART Wake-Up Function Enable (Not Available In UART2 Channel)
S * |        |          |0 = UART wake-up function Disabled.
S * |        |          |1 = UART wake-up function Enabled, when the chip is in Power-down mode, an external CTS
S * |        |          |change will wake-up chip from Power-down mode.
S * |[8]     |LIN_IEN   |LIN Bus Interrupt Enable
S * |        |          |0 = Lin bus interrupt Disabled.
S * |        |          |1 = Lin bus interrupt Enabled.
S * |        |          |Note: This field is used for LIN function mode.
S * |[11]    |TIME_OUT_EN|Time-Out Counter Enable
S * |        |          |0 = Time-out counter Disabled.
S * |        |          |1 = Time-out counter Enabled.
S * |[12]    |AUTO_RTS_EN|RTS Auto Flow Control Enable (Not Available in UART2 Channel)
S * |        |          |0 = RTS auto flow control Disabled.
S * |        |          |1 = RTS auto flow control Enabled.
S * |        |          |When RTS auto-flow is enabled, if the number of bytes in the RX FIFO equals the RTS_TRI_LEV
S * |        |          |(UA_FCR [19:16]), the UART will de-assert RTS signal.
S * |[13]    |AUTO_CTS_EN|CTS Auto Flow Control Enable (Not Available in UART2 Channel)
S * |        |          |0 = CTS auto flow control Disabled.
S * |        |          |1 = CTS auto flow control Enabled.
S * |        |          |When CTS auto-flow is enabled, the UART will send data to external device when CTS input
S * |        |          |assert (UART will not send data to device until CTS is asserted).
S * |[14]    |DMA_TX_EN |TX DMA Enable (Not Available In UART2 Channel)
S * |        |          |This bit can enable or disable TX DMA service.
S * |        |          |0 = TX DMA Disabled.
S * |        |          |1 = TX DMA Enabled.
S * |[15]    |DMA_RX_EN |RX DMA Enable (Not Available In UART2 Channel)
S * |        |          |This bit can enable or disable RX DMA service.
S * |        |          |0 = RX DMA Disabled.
S * |        |          |1 = RX DMA Enabled.
S * @var UART_T::FCR
S * Offset: 0x08  UART FIFO Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[1]     |RFR       |RX Field Software Reset
S * |        |          |When RFR is set, all the byte in the receiver FIFO and RX internal state machine are cleared.
S * |        |          |0 = No effect.
S * |        |          |1 = Reset the RX internal state machine and pointers.
S * |        |          |Note: This bit will automatically clear at least 3 UART peripheral clock cycles.
S * |[2]     |TFR       |TX Field Software Reset
S * |        |          |When TFR is set, all the byte in the transmit FIFO and TX internal state machine are cleared.
S * |        |          |0 = No effect.
S * |        |          |1 = Reset the TX internal state machine and pointers.
S * |        |          |Note: This bit will automatically clear at least 3 UART peripheral clock cycles.
S * |[7:4]   |RFITL     |RX FIFO Interrupt Trigger Level
S * |        |          |When the number of bytes in the receive FIFO equals the RFITL, the RDA_IF will be set (if
S * |        |          |RDA_IEN (UA_IER[0]) enabled, and an interrupt will be generated).
S * |        |          |0000 = RX FIFO Interrupt Trigger Level is 1 byte.
S * |        |          |0001 = RX FIFO Interrupt Trigger Level is 4 bytes.
S * |        |          |0010 = RX FIFO Interrupt Trigger Level is 8 bytes.
S * |        |          |0011 = RX FIFO Interrupt Trigger Level is 14 bytes.
S * |        |          |0100 = RX FIFO Interrupt Trigger Level is 30/14 bytes (High Speed/Normal Speed).
S * |        |          |0101 = RX FIFO Interrupt Trigger Level is 46/14 bytes (High Speed/Normal Speed).
S * |        |          |0110 = RX FIFO Interrupt Trigger Level is 62/14 bytes (High Speed/Normal Speed).
S * |        |          |Other = Reserved.
S * |[8]     |RX_DIS    |Receiver Disable Register
S * |        |          |The receiver is disabled or not (set 1 to disable receiver).
S * |        |          |0 = Receiver Enabled.
S * |        |          |1 = Receiver Disabled.
S * |        |          |Note: This field is used for RS-485 Normal Multi-drop mode. It should be programmed before
S * |        |          |RS485_NMM (UA_ALT_CSR[8]) is programmed.
S * |[19:16] |RTS_TRI_LEV|RTS Trigger Level For Auto-Flow Control Use (Not Available In UART2 Channel)
S * |        |          |0000 = RTS Trigger Level is 1 byte.
S * |        |          |0001 = RTS Trigger Level is 4 bytes.
S * |        |          |0010 = RTS Trigger Level is 8 bytes.
S * |        |          |0011 = RTS Trigger Level is 14 bytes.
S * |        |          |0100 = RTS Trigger Level is 30/14 bytes (High Speed/Normal Speed).
S * |        |          |0101 = RTS Trigger Level is 46/14 bytes (High Speed/Normal Speed).
S * |        |          |0110 = RTS Trigger Level is 62/14 bytes (High Speed/Normal Speed).
S * |        |          |Other = Reserved.
S * |        |          |Note: This field is used for RTS auto-flow control.
S * @var UART_T::LCR
S * Offset: 0x0C  UART Line Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[1:0]   |WLS       |Word Length Selection
S * |        |          |00 = Word length is 5-bit.
S * |        |          |01 = Word length is 6-bit.
S * |        |          |10 = Word length is 7-bit
S * |        |          |11 = Word length is 8-bit
S * |[2]     |NSB       |Number Of "STOP Bit"
S * |        |          |0 = One " STOP bit" is generated in the transmitted data.
S * |        |          |1 = When select 5-bit word length, 1.5 "STOP bit" is generated in the transmitted data.
S * |        |          |When select 6-,7- and 8-bit word length, 2 "STOP bit" is generated in the transmitted data.
S * |[3]     |PBE       |Parity Bit Enable
S * |        |          |0 = No parity bit.
S * |        |          |1 = Parity bit is generated on each outgoing character and is checked on each incoming data.
S * |[4]     |EPE       |Even Parity Enable
S * |        |          |0 = Odd number of logic 1's is transmitted and checked in each word.
S * |        |          |1 = Even number of logic 1's is transmitted and checked in each word.
S * |        |          |This bit has effect only when PBE (UA_LCR[3]) is set.
S * |[5]     |SPE       |Stick Parity Enable
S * |        |          |0 = Stick parity Disabled.
S * |        |          |1 = If PBE (UA_LCR[3]) and EBE (UA_LCR[4]) are logic 1, the parity bit is transmitted and
S * |        |          |checked as logic 0.
S * |        |          |If PBE (UA_LCR[3]) is 1 and EBE (UA_LCR[4]) is 0 then the parity bit is transmitted and checked
S * |        |          |as 1.
S * |[6]     |BCB       |Break Control Bit
S * |        |          |When this bit is set to logic 1, the serial data output (TX) is forced to the Spacing State
S * |        |          |(logic 0).
S * |        |          |This bit acts only on TX and has no effect on the transmitter logic.
S * @var UART_T::MCR
S * Offset: 0x10  UART Modem Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[1]     |RTS       |RTS (Request-To-Send) Signal Control (Not Available In UART2 Channel)
S * |        |          |This bit is direct control internal RTS signal active or not, and then drive the RTS pin output
S * |        |          |with LEV_RTS bit configuration.
S * |        |          |0 = RTS signal is active.
S * |        |          |1 = RTS signal is inactive.
S * |        |          |Note1: This RTS signal control bit is not effective when RTS auto-flow control is enabled in
S * |        |          |UART function mode.
S * |        |          |Note2: This RTS signal control bit is not effective when RS-485 auto direction mode (AUD) is
S * |        |          |enabled in RS-485 function mode.
S * |[9]     |LEV_RTS   |RTS Pin Active Level (Not Available In UART2 Channel)
S * |        |          |This bit defines the active level state of RTS pin output.
S * |        |          |0 = RTS pin output is high level active.
S * |        |          |1 = RTS pin output is low level active.
S * |[13]    |RTS_ST    |RTS Pin State (Read Only) (Not Available In UART2 Channel)
S * |        |          |This bit mirror from RTS pin output of voltage logic status.
S * |        |          |0 = RTS pin output is low level voltage logic state.
S * |        |          |1 = RTS pin output is high level voltage logic state.
S * @var UART_T::MSR
S * Offset: 0x14  UART Modem Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |DCTSF     |Detect CTS State Change Flag (Not Available In UART2 Channel)
S * |        |          |This bit is set whenever CTS input has change state, and it will generate Modem interrupt to CPU
S * |        |          |when MODEM_IEN (UA_IER [3]) is set to 1.
S * |        |          |0 = CTS input has not change state.
S * |        |          |1 = CTS input has change state.
S * |        |          |Note: This bit can be cleared by writing "1" to it.
S * |[4]     |CTS_ST    |CTS Pin Status (Read Only) (Not Available In UART2 Channel)
S * |        |          |This bit mirror from CTS pin input of voltage logic status.
S * |        |          |0 = CTS pin input is low level voltage logic state.
S * |        |          |1 = CTS pin input is high level voltage logic state.
S * |        |          |Note: This bit echoes when UART Controller peripheral clock is enabled, and CTS multi-function
S * |        |          |port is selected.
S * |[8]     |LEV_CTS   |CTS Pin Active Level
S * |        |          |This bit defines the active level state of CTS pin input.
S * |        |          |0 = CTS pin input is high level active.
S * |        |          |1 = CTS pin input is low level active.
S * @var UART_T::FSR
S * Offset: 0x18  UART FIFO Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |RX_OVER_IF|RX Overflow Error Interrupt Flag
S * |        |          |This bit is set when RX FIFO overflow.
S * |        |          |If the number of bytes of received data is greater than RX_FIFO (UA_RBR) size, 64/16/16 bytes of
S * |        |          |UART0/UART1/UART2, this bit will be set.
S * |        |          |0 = RX FIFO is not overflow.
S * |        |          |1 = RX FIFO is overflow.
S * |        |          |Note: This bit can be cleared by writing "1" to it.
S * |[3]     |RS485_ADD_DETF|RS-485 Address Byte Detection Flag 
S * |        |          |0 = Receiver detects a data that is not an address bit (bit 9 ='1').
S * |        |          |1 = Receiver detects a data that is an address bit (bit 9 ='1').
S * |        |          |Note1: This field is used for RS-485 function mode and RS485_ADD_EN (UA_ALT_CSR[15]) is set to 1
S * |        |          |to enable Address detection mode.
S * |        |          |Note2: This bit can be cleared by writing '1' to it.
S * |[4]     |PEF       |Parity Error Flag 
S * |        |          |This bit is set to logic 1 whenever the received character does not have a valid "parity bit",
S * |        |          |and is reset whenever the CPU writes 1 to this bit.
S * |        |          |0 = No parity error is generated.
S * |        |          |1 = Parity error is generated.
S * |        |          |Note: This bit can be cleared by writing "1" to it.
S * |[5]     |FEF       |Framing Error Flag
S * |        |          |This bit is set to logic 1 whenever the received character does not have a valid "stop bit"
S * |        |          |(that is, the stop bit following the last data bit or parity bit is detected as logic 0), and is
S * |        |          |reset whenever the CPU writes 1 to this bit.
S * |        |          |0 = No framing error is generated.
S * |        |          |1 = Framing error is generated.
S * |        |          |Note: This bit can be cleared by writing "1" to it.
S * |[6]     |BIF       |Break Interrupt Flag
S * |        |          |This bit is set to logic 1 whenever the received data input(RX) is held in the "spacing state"
S * |        |          |(logic 0) for longer than a full word transmission time (that is, the total time of "start bit"
S * |        |          |+ data bits + parity + stop bits) and is reset whenever the CPU writes 1 to this bit.
S * |        |          |0 = No Break interrupt is generated.
S * |        |          |1 = Break interrupt is generated.
S * |        |          |Note: This bit can be cleared by writing "1" to it.
S * |[13:8]  |RX_POINTER|RX FIFO Pointer (Read Only)
S * |        |          |This field indicates the RX FIFO Buffer Pointer.
S * |        |          |When UART receives one byte from external device, then RX_POINTER increases one.
S * |        |          |When one byte of RX FIFO is read by CPU, then RX_POINTER decreases one.
S * |        |          |The Maximum value shown in RX_POINTER is 63/15/15 (UART0/UART1/UART2).
S * |        |          |When the using level of RX FIFO Buffer equal to 64/16/16, the RX_FULL bit is set to 1 and
S * |        |          |RX_POINTER will show 0.
S * |        |          |As one byte of RX FIFO is read by CPU, the RX_FULL bit is cleared to 0 and RX_POINTER will show
S * |        |          |63/15/15 (UART0/UART1/UART2).
S * |[14]    |RX_EMPTY  |Receiver FIFO Empty (Read Only)
S * |        |          |This bit initiate RX FIFO empty or not.
S * |        |          |0 = RX FIFO is not empty.
S * |        |          |1 = RX FIFO is empty.
S * |        |          |Note: When the last byte of RX FIFO has been read by CPU, hardware sets this bit high. It will
S * |        |          |be cleared when UART receives any new data.
S * |[15]    |RX_FULL   |Receiver FIFO Full (Read Only)
S * |        |          |This bit initiates RX FIFO is full or not.
S * |        |          |0 = RX FIFO is not full.
S * |        |          |1 = RX FIFO is full.
S * |        |          |Note: This bit is set when the number of usage in RX FIFO Buffer is equal to
S * |        |          |64/16/16(UART0/UART1/UART2), otherwise is cleared by hardware.
S * |[21:16] |TX_POINTER|TX FIFO Pointer (Read Only)
S * |        |          |This field indicates the TX FIFO Buffer Pointer.
S * |        |          |When CPU writes one byte into UA_THR, then TX_POINTER increases one.
S * |        |          |When one byte of TX FIFO is transferred to Transmitter Shift Register, then TX_POINTER decreases
S * |        |          |one.
S * |        |          |The Maximum value shown in TX_POINTER is 63/15/15 (UART0/UART1/UART2).
S * |        |          |When the using level of TX FIFO Buffer equal to 64/16/16, the TX_FULL bit is set to 1 and
S * |        |          |TX_POINTER will show 0.
S * |        |          |As one byte of TX FIFO is transferred to Transmitter Shift Register, the TX_FULL bit is cleared
S * |        |          |to 0 and TX_POINTER will show 63/15/15 (UART0/UART1/UART2).
S * |[22]    |TX_EMPTY  |Transmitter FIFO Empty (Read Only)
S * |        |          |This bit indicates TX FIFO empty or not.
S * |        |          |0 = TX FIFO is not empty.
S * |        |          |1 = TX FIFO is empty.
S * |        |          |Note: When the last byte of TX FIFO has been transferred to Transmitter Shift Register, hardware
S * |        |          |sets this bit high. It will be cleared when writing data into THR (TX FIFO not empty).
S * |[23]    |TX_FULL   |Transmitter FIFO Full (Read Only)
S * |        |          |This bit indicates TX FIFO full or not.
S * |        |          |0 = TX FIFO is not full.
S * |        |          |1 = TX FIFO is full.
S * |        |          |This bit is set when the number of usage in TX FIFO Buffer is equal to
S * |        |          |64/16/16(UART0/UART1/UART2), otherwise is cleared by hardware.
S * |[24]    |TX_OVER_IF|TX Overflow Error Interrupt Flag 
S * |        |          |If TX FIFO (UA_THR) is full, an additional write to UA_THR will cause this bit to logic 1.
S * |        |          |0 = TX FIFO is not overflow.
S * |        |          |1 = TX FIFO is overflow.
S * |        |          |Note: This bit can be cleared by writing "1" to it.
S * |[28]    |TE_FLAG   |Transmitter Empty Flag (Read Only)
S * |        |          |This bit is set by hardware when TX FIFO (UA_THR) is empty and the STOP bit of the last byte has
S * |        |          |been transmitted.
S * |        |          |0 = TX FIFO is not empty.
S * |        |          |1 = TX FIFO is empty.
S * |        |          |Note: This bit is cleared automatically when TX FIFO is not empty or the last byte transmission
S * |        |          |has not completed.
S * @var UART_T::ISR
S * Offset: 0x1C  UART Interrupt Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |RDA_IF    |Receive Data Available Interrupt Flag (Read Only)
S * |        |          |When the number of bytes in the RX FIFO equals the RFITL then the RDA_IF(UA_ISR[0]) will be set.
S * |        |          |If RDA_IEN (UA_IER [0]) is enabled, the RDA interrupt will be generated.
S * |        |          |0 = No RDA interrupt flag is generated.
S * |        |          |1 = RDA interrupt flag is generated.
S * |        |          |Note: This bit is read only and it will be cleared when the number of unread bytes of RX FIFO
S * |        |          |drops below the threshold level RFITL(UA_FCR[7:4]).
S * |[1]     |THRE_IF   |Transmit Holding Register Empty Interrupt Flag (Read Only)
S * |        |          |This bit is set when the last data of TX FIFO is transferred to Transmitter Shift Register.
S * |        |          |If THRE_IEN (UA_IER[1]) is enabled, the THRE interrupt will be generated.
S * |        |          |0 = No THRE interrupt flag is generated.
S * |        |          |1 = THRE interrupt flag is generated.
S * |        |          |Note: This bit is read only and it will be cleared when writing data into THR (TX FIFO not
S * |        |          |empty).
S * |[2]     |RLS_IF    |Receive Line Interrupt Flag
S * |        |          |This bit is set when the RX receive data have parity error, frame error or break error (at least
S * |        |          |one of 3 bits, BIF(UA_FSR[6]), FEF(UA_FSR[5]) and PEF(UA_FSR[4]), is set).
S * |        |          |If RLS_IEN (UA_IER [2]) is enabled, the RLS interrupt will be generated.
S * |        |          |0 = No RLS interrupt flag is generated.
S * |        |          |1 = RLS interrupt flag is generated.
S * |        |          |Note1: In RS-485 function mode, this field is set include receiver detect and received address
S * |        |          |byte character (bit9 = '1') bit. At the same time, the bit of RS485_ADD_DETF(UA_FSR[3]) is also
S * |        |          |set.
S * |        |          |Note2: This bit is read only and reset to 0 when all bits of BIF(UA_FSR[6]), FEF(UA_FSR[5]) and
S * |        |          |PEF(UA_FSR[4]) are cleared.
S * |        |          |Note3: In RS-485 function mode, this bit is read only and reset to 0 when all bits of
S * |        |          |BIF(UA_FSR[6]) , FEF(UA_FSR[5]) and PEF(UA_FSR[4]) and RS485_ADD_DETF (UA_FSR[3]) are cleared.
S * |[3]     |MODEM_IF  |MODEM Interrupt Flag (Read Only) (Not Available In UART2 Channel)
S * |        |          |This bit is set when the CTS pin has state change (DCTSF (UA_MSR[0]) = 1).
S * |        |          |If MODEM_IEN (UA_IER [3]) is enabled, the Modem interrupt will be generated.
S * |        |          |0 = No Modem interrupt flag is generated.
S * |        |          |1 = Modem interrupt flag is generated.
S * |        |          |Note: This bit is read only and reset to 0 when bit DCTSF is cleared by a write 1 on
S * |        |          |DCTSF(UA_MSR[0]).
S * |[4]     |TOUT_IF   |Time-out Interrupt Flag (Read Only)
S * |        |          |This bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the
S * |        |          |time-out counter equal to TOIC(UA_TOR[7:0]).
S * |        |          |If TOUT_IEN (UA_IER [4]) is enabled, the Time-out interrupt will be generated.
S * |        |          |0 = No Time-out interrupt flag is generated.
S * |        |          |1 = Time-out interrupt flag is generated.
S * |        |          |Note: This bit is read only and user can read UA_RBR (RX is in active) to clear it.
S * |[5]     |BUF_ERR_IF|Buffer Error Interrupt Flag (Read Only)
S * |        |          |This bit is set when the TX FIFO or RX FIFO overflows (TX_OVER_IF (UA_FSR[24]) or RX_OVER_IF
S * |        |          |(UA_FSR[0]) is set).
S * |        |          |When BUF_ERR_IF (UA_ISR[5])is set, the transfer is not correct.
S * |        |          |If BUF_ERR_IEN (UA_IER [8]) is enabled, the buffer error interrupt will be generated.
S * |        |          |0 = No buffer error interrupt flag is generated.
S * |        |          |1 = Buffer error interrupt flag is generated.
S * |        |          |Note: This bit is read only and reset to 0 when all bits of TX_OVER_IF(UA_FSR[24]) and
S * |        |          |RX_OVER_IF(UA_FSR[0]) are cleared.
S * |[7]     |LIN_IF    |LIN Bus Flag (Read Only)
S * |        |          |This bit is set when LIN slave header detect (LINS_HDET_F (UA_LIN_SR[0] = 1)), LIN break detect
S * |        |          |(LIN_BKDET_F(UA_LIN_SR[9]=1)), 
S * |        |          |bit error detect (BIT_ERR_F(UA_LIN_SR[9])=1), LIN slave ID parity error
S * |        |          |(LINS_IDPERR_F(UA_LIN_SR[2]) = 1) or LIN slave header error detect (LINS_HERR_F (UA_LIN_SR[1])).
S * |        |          |If LIN_ IEN (UA_IER [8]) is enabled the LIN interrupt will be generated.
S * |        |          |0 = None of LINS_HDET_F, LIN_BKDET_F, BIT_ERR_F, LINS_IDPERR_F and LINS_HERR_F is generated.
S * |        |          |1 = At least one of LINS_HDET_F, LIN_BKDET_F, BIT_ERR_F, LINS_IDPERR_F and LINS_HERR_F is
S * |        |          |generated.
S * |        |          |Note: This bit is read only. This bit is cleared when LINS_HDET_F(UA_LIN_SR[0]),
S * |        |          |LIN_BKDET_F(UA_LIN_SR[9]), BIT_ERR_F(UA_LIN_SR[9]), LINS_IDPENR_F (UA_LIN_SR[2]) and
S * |        |          |LINS_HERR_F(UA_LIN_SR[1]) all are cleared.
S * |[8]     |RDA_INT   |Receive Data Available Interrupt Indicator (Read Only)
S * |        |          |This bit is set if RDA_IEN (UA_IER[0]) and RDA_IF (UA_ISR[0]) are both set to 1.
S * |        |          |0 = No RDA interrupt is generated.
S * |        |          |1 = RDA interrupt is generated.
S * |[9]     |THRE_INT  |Transmit Holding Register Empty Interrupt Indicator (Read Only)
S * |        |          |This bit is set if THRE_IEN (UA_IER[1])and THRE_IF(UA_SR[1]) are both set to 1.
S * |        |          |0 = No THRE interrupt is generated.
S * |        |          |1 = THRE interrupt is generated.
S * |[10]    |RLS_INT   |Receive Line Status Interrupt Indicator (Read Only)
S * |        |          |This bit is set if RLS_IEN (UA_IER[2]) and RLS_IF(UA_ISR[2]) are both set to 1.
S * |        |          |0 = No RLS interrupt is generated.
S * |        |          |1 = RLS interrupt is generated
S * |[11]    |MODEM_INT |MODEM Status Interrupt Indicator (Read Only) (Not Available In UART2 Channel)
S * |        |          |This bit is set if MODEM_IEN(UA_IER[3]) and MODEM_IF(UA_ISR[4]) are both set to 1
S * |        |          |0 = No Modem interrupt is generated.
S * |        |          |1 = Modem interrupt is generated.
S * |[12]    |TOUT_INT  |Time-Out Interrupt Indicator (Read Only)
S * |        |          |This bit is set if TOUT_IEN(UA_IER[4]) and TOUT_IF(UA_ISR[4]) are both set to 1.
S * |        |          |0 = No Time-Out interrupt is generated.
S * |        |          |1 = Time-Out interrupt is generated.
S * |[13]    |BUF_ERR_INT|Buffer Error Interrupt Indicator (Read Only)
S * |        |          |This bit is set if BUF_ERR_IEN(UA_IER[5]) and BUF_ERR_IF(UA_ISR[5]) are both set to 1.
S * |        |          |0 = No buffer error interrupt is generated.
S * |        |          |1 = Buffer error interrupt is generated.
S * |[15]    |LIN_INT   |LIN Bus Interrupt Indicator (Read Only)
S * |        |          |This bit is set if LIN_IEN (UA_IER[8]) and LIN _IF(UA_ISR[7]) are both set to 1.
S * |        |          |0 = No LIN Bus interrupt is generated.
S * |        |          |1 = The LIN Bus interrupt is generated.
S * |[18]    |HW_RLS_IF |In DMA Mode, Receive Line Status Flag (Read Only)
S * |        |          |This bit is set when the RX receive data have parity error, frame error or break error (at least
S * |        |          |one of 3 bits, BIF (UA_FSR[6]), FEF (UA_FSR[5]) and PEF (UA_FSR[4]) is set).
S * |        |          |If RLS_IEN (UA_IER [2]) is enabled, the RLS interrupt will be generated.
S * |        |          |0 = No RLS interrupt flag is generated in DMA mode.
S * |        |          |1 = RLS interrupt flag is generated in DMA mode.
S * |        |          |Note1: In RS-485 function mode, this field include receiver detect any address byte received
S * |        |          |address byte character (bit9 = '1') bit.
S * |        |          |Note2: In UART function mode, this bit is read only and reset to 0 when all bits of
S * |        |          |BIF(UA_FSR[6]) , FEF(UA_FSR[5]) and PEF(UA_FSR[4]) are cleared.
S * |        |          |Note3: In RS-485 function mode, this bit is read only and reset to 0 when all bits of
S * |        |          |BIF(UA_FSR[6]) , FEF(UA_FSR[5]) and PEF(UA_FSR[4]) and RS485_ADD_DETF (UA_FSR[3]) are cleared.
S * |[19]    |HW_MODEM_IF|In DMA Mode, MODEM Interrupt Flag (Read Only) (Not Available In UART2 Channel)
S * |        |          |This bit is set when the CTS pin has state change (DCTSF (US_MSR[0] =1)).
S * |        |          |If MODEM_IEN (UA_IER [3]) is enabled, the Modem interrupt will be generated.
S * |        |          |0 = No Modem interrupt flag is generated in DMA mode.
S * |        |          |1 = Modem interrupt flag is generated in DMA mode.
S * |        |          |Note: This bit is read only and reset to 0 when the bit DCTSF(US_MSR[0]) is cleared by writing 1
S * |        |          |on DCTSF (US_MSR[0]).
S * |[20]    |HW_TOUT_IF|In DMA Mode, Time-Out Interrupt Flag (Read Only)
S * |        |          |This bit is set when the RX FIFO is not empty and no activities occurred in the RX FIFO and the
S * |        |          |time-out counter equal to TOIC (UA_TOR[7:0]).
S * |        |          |If TOUT_IEN (UA_IER [4]) is enabled, the Tout interrupt will be generated.
S * |        |          |0 = No Time-out interrupt flag is generated in DMA mode.
S * |        |          |1 = Time-out interrupt flag is generated in DMA mode.
S * |        |          |Note: This bit is read only and user can read UA_RBR (RX is in active) to clear it.
S * |[21]    |HW_BUF_ERR_IF|In DMA Mode, Buffer Error Interrupt Flag (Read Only)
S * |        |          |This bit is set when the TX or RX FIFO overflows (TX_OVER_IF (UA__FSR[24]) or RX_OVER_IF
S * |        |          |(UA_FSR[0]) is set).
S * |        |          |When BUF_ERR_IF (UA_ISR[5]) is set, the transfer maybe is not correct.
S * |        |          |If BUF_ERR_IEN (UA_IER [5]) is enabled, the buffer error interrupt will be generated.
S * |        |          |0 = No buffer error interrupt flag is generated in DMA mode.
S * |        |          |1 = Buffer error interrupt flag is generated in DMA mode.
S * |        |          |Note: This bit is cleared when both TX_OVER_IF (UA_FSR[24]]) and RX_OVER_IF (UA_FSR[0]) are
S * |        |          |cleared.
S * |[26]    |HW_RLS_INT|In DMA Mode, Receive Line Status Interrupt Indicator (Read Only)
S * |        |          |This bit is set if RLS_IEN (UA_IER[2])and HW_RLS_IF(UA_ISR[18]) are both set to 1.
S * |        |          |0 = No RLS interrupt is generated in DMA mode.
S * |        |          |1 = RLS interrupt is generated in DMA mode.
S * |[27]    |HW_MODEM_INT|In DMA Mode, MODEM Status Interrupt Indicator (Read Only) (Not Available In UART2 Channel)
S * |        |          |This bit is set if MODEM_IEN(UA_IER[3]) and HW_MODEM_IF(UA_ ISR[3]) are both set to 1.
S * |        |          |0 = No Modem interrupt is generated in DMA mode.
S * |        |          |1 = Modem interrupt is generated in DMA mode.
S * |[28]    |HW_TOUT_INT|In DMA Mode, Time-Out Interrupt Indicator (Read Only)
S * |        |          |This bit is set if TOUT_IEN (UA_IER[4])and HW_TOUT_IF(UA_ISR[20]) are both set to 1.
S * |        |          |0 = No Tout interrupt is generated in DMA mode.
S * |        |          |1 = Tout interrupt is generated in DMA mode.
S * |[29]    |HW_BUF_ERR_INT|In DMA Mode, Buffer Error Interrupt Indicator (Read Only)
S * |        |          |This bit is set if BUF_ERR_IEN (UA_IER[5]) and HW_BUF_ERR_IF (UA_ISR[5])are both set to 1.
S * |        |          |0 = No buffer error interrupt is generated in DMA mode.
S * |        |          |1 = Buffer error interrupt is generated in DMA mode.
S * @var UART_T::TOR
S * Offset: 0x20  UART Time-out Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7:0]   |TOIC      |Time-out Interrupt Comparator
S * |        |          |The time-out counter resets and starts counting (the counting clock = baud rate) whenever the RX
S * |        |          |FIFO receives a new data word.
S * |        |          |Once the content of time-out counter is equal to that of time-out interrupt comparator (TOIC
S * |        |          |(UA_TOR[7:0])), a receiver time-out interrupt is generated if TOUT_IEN (UA_IER [4]) enabled.
S * |        |          |A new incoming data word or RX FIFO empty will clear TOUT_IF(UA_IER[4]).
S * |        |          |In order to avoid receiver time-out interrupt generation immediately during one character is
S * |        |          |being received, TOIC (UA_TOR[7:0]) value should be set between 40 and 255.
S * |        |          |So, for example, if TOIC (UA_TOR[7:0]) is set with 40, the time-out interrupt is generated after
S * |        |          |four characters are not received when 1 stop bit and no parity check is set for UART transfer.
S * |[15:8]  |DLY       |TX Delay Time Value
S * |        |          |This field is used to programming the transfer delay time between the last stop bit and next
S * |        |          |start bit.
S * @var UART_T::BAUD
S * Offset: 0x24  UART Baud Rate Divisor Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[15:0]  |BRD       |Baud Rate Divider
S * |        |          |The field indicates the baud rate divider.
S * |[27:24] |DIVIDER_X |Divider X
S * |        |          |The baud rate divider M = X+1.
S * |[28]    |DIV_X_ONE |Divider X Equal To 1
S * |        |          |0 = Divider M is X+1 (the equation of M = X+1, but DIVIDER_X[27:24] must >= 8).
S * |        |          |1 = Divider M is 1.
S * |[29]    |DIV_X_EN  |Divider X Enable
S * |        |          |The BRD = Baud Rate Divider, and the baud rate equation is
S * |        |          |Baud Rate = Clock / [M * (BRD + 2)]; The default value of M is 16.
S * |        |          |0 = Divider X Disabled (the equation of M = 16).
S * |        |          |1 = Divider X Enabled (the equation of M = X+1, but DIVIDER_X [27:24] must >= 8).
S * |        |          |Note: In IrDA mode, this bit must disable.
S * @var UART_T::IRCR
S * Offset: 0x28  UART IrDA Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[1]     |TX_SELECT |IrDA Receiver/Transmitter Selection Enable Control
S * |        |          |0 = IrDA Transmitter Disabled and Receiver Enabled.
S * |        |          |1 = IrDA Transmitter Enabled and Receiver Disabled.
S * |[5]     |INV_TX    |IrDA inverse Transmitting Output Signal Control
S * |        |          |0 = None inverse transmitting signal.
S * |        |          |1 = Inverse transmitting output signal.
S * |[6]     |INV_RX    |IrDA inverse Receive Input Signal Control
S * |        |          |0 = None inverse receiving input signal.
S * |        |          |1 = Inverse receiving input signal.
S * @var UART_T::ALT_CSR
S * Offset: 0x2C  UART Alternate Control/Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |LIN_BKFL  |UART LIN Break Field Length
S * |        |          |This field indicates a 4-bit LIN TX break field count.
S * |        |          |Note1: This break field length is UA_LIN_BKFL + 1
S * |        |          |Note2: According to LIN spec, the reset value is 0xC (break field length = 13).
S * |[6]     |LIN_RX_EN |LIN RX Enable
S * |        |          |0 = LIN RX mode Disabled.
S * |        |          |1 = LIN RX mode Enabled.
S * |[7]     |LIN_TX_EN |LIN TX Break Mode Enable
S * |        |          |0 = LIN TX Break mode Disabled.
S * |        |          |1 = LIN TX Break mode Enabled.
S * |        |          |Note: When TX break field transfer operation finished, this bit will be cleared automatically.
S * |[8]     |RS485_NMM |RS-485 Normal Multi-Drop Operation Mode (NMM)
S * |        |          |0 = RS-485 Normal Multi-drop Operation mode (NMM) Disabled.
S * |        |          |1 = RS-485 Normal Multi-drop Operation mode (NMM) Enabled.
S * |        |          |Note: It cannot be active with RS-485_AAD operation mode.
S * |[9]     |RS485_AAD |RS-485 Auto Address Detection Operation Mode (AAD)
S * |        |          |0 = RS-485 Auto Address Detection Operation mode (AAD) Disabled.
S * |        |          |1 = RS-485 Auto Address Detection Operation mode (AAD) Enabled.
S * |        |          |Note: It cannot be active with RS-485_NMM operation mode.
S * |[10]    |RS485_AUD |RS-485 Auto Direction Mode (AUD)
S * |        |          |0 = RS-485 Auto Direction Operation mode (AUO) Disabled.
S * |        |          |1 = RS-485 Auto Direction Operation mode (AUO) Enabled.
S * |        |          |Note: It can be active with RS-485_AAD or RS-485_NMM operation mode.
S * |[15]    |RS485_ADD_EN|RS-485 Address Detection Enable
S * |        |          |This bit is used to enable RS-485 Address Detection mode.
S * |        |          |0 = Address detection mode Disabled.
S * |        |          |1 = Address detection mode Enabled.
S * |        |          |Note: This bit is used for RS-485 any operation mode.
S * |[31:24] |ADDR_MATCH|Address Match Value Register
S * |        |          |This field contains the RS-485 address match values.
S * |        |          |Note: This field is used for RS-485 auto address detection mode.
S * @var UART_T::FUN_SEL
S * Offset: 0x30  UART Function Select Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[1:0]   |FUN_SEL   |Function Select Enable
S * |        |          |00 = UART function Enabled.
S * |        |          |01 = LIN function Enabled.
S * |        |          |10 = IrDA function Enabled.
S * |        |          |11 = RS-485 function Enabled.
S * @var UART_T::LIN_CTL
S * Offset: 0x34  UART LIN Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |LINS_EN   |LIN Slave Mode Enable Control
S * |        |          |0 = LIN slave mode Disabled.
S * |        |          |1 = LIN slave mode Enabled.
S * |[1]     |LINS_HDET_EN|LIN Slave Header Detection Enable Control
S * |        |          |0 = LIN slave header detection Disabled.
S * |        |          |1 = LIN slave header detection Enabled.
S * |        |          |Note1: This bit only valid when in LIN slave mode (LINS_EN (UA_LIN_CTL[0]) = 1).
S * |        |          |Note2: In LIN function mode, when detect header field (break + sync + frame ID), LINS_HDET_F
S * |        |          |(UA_LIN_SR [0]) flag will be asserted. If the LIN_IEN (UA_IER[8]) = 1, an interrupt will be
S * |        |          |generated.
S * |[2]     |LINS_ARS_EN|LIN Slave Automatic Resynchronization Mode Enable Control
S * |        |          |0 = LIN automatic resynchronization Disabled.
S * |        |          |1 = LIN automatic resynchronization Enabled.
S * |        |          |Note1: This bit only valid when in LIN slave mode (LINS_EN (UA_LIN_CTL[0]) = 1).
S * |        |          |Note2: When operation in Automatic Resynchronization mode, the baud rate setting must be mode2
S * |        |          |(BAUD_M1 (UA_BAUD [29]) and BAUD_M0 (UA_BAUD [28]) must be 1). 
S * |        |          |(Slave mode with automatic resynchronization).
S * |[3]     |LINS_DUM_EN|LIN Slave Divider Update Method Enable Control
S * |        |          |0 = UA_BAUD updated is written by software (if no automatic resynchronization update occurs at
S * |        |          |the same time).
S * |        |          |1 = UA_BAUD is updated at the next received character. User must set the bit before checksum
S * |        |          |reception.
S * |        |          |Note1: This bit only valid when in LIN slave mode (LINS_EN (UA_LIN_CTL[0]) = 1).
S * |        |          |Note2: This bit used for LIN Slave Automatic Resynchronization mode.
S * |        |          |(for Non-Automatic Resynchronization mode, this bit should be kept cleared).
S * |        |          |(Slave mode with automatic resynchronization).
S * |[4]     |LIN_MUTE_EN|LIN Mute Mode Enable Control
S * |        |          |0 = LIN mute mode Disabled.
S * |        |          |1 = LIN mute mode Enabled.
S * |        |          |Note: The exit from mute mode condition and each control and interactions of this field are
S * |        |          |explained in (LIN slave mode).
S * |[8]     |LIN_SHD   |LIN TX Send Header Enable Control
S * |        |          |The LIN TX header can be "break field" or "break and sync field" or "break, sync and frame ID
S * |        |          |field", it is depend on setting LIN_HEAD_SEL (UA_LIN_CTL[23:22]).
S * |        |          |0 = Send LIN TX header Disabled.
S * |        |          |1 = Send LIN TX header Enabled.
S * |        |          |Note1: These registers are shadow registers of LIN_SHD (UA_ALT_CSR [7]); user can read/write it
S * |        |          |by setting LIN_SHD (UA_ALT_CSR [7]) or LIN_SHD (UA_LIN_CTL [8]).
S * |        |          |Note2: When transmitter header field (it may be "break" or "break + sync" or "break + sync +
S * |        |          |frame ID" selected by LIN_HEAD_SEL (UA_LIN_CTL[23:22]) field) transfer operation finished, this
S * |        |          |bit will be cleared automatically.
S * |[9]     |LIN_IDPEN |LIN ID Parity Enable Control
S * |        |          |0 = LIN frame ID parity Disabled.
S * |        |          |1 = LIN frame ID parity Enabled.
S * |        |          |Note1: This bit can be used for LIN master to sending header field LIN_SHD (UA_LIN_CTL[8]) = 1
S * |        |          |and LIN_HEAD_SEL (UA_LIN_CTL[23:22]) = 10 or be used for enable LIN slave received frame ID
S * |        |          |parity checked.
S * |        |          |Note2: This bit is only use when the operation header transmitter is in LIN_HEAD_SEL
S * |        |          |(UA_LIN_CTL[23:22]) = 10.
S * |[10]    |LIN_BKDET_EN|LIN Break Detection Enable Control
S * |        |          |When detect consecutive dominant greater than 11 bits, and are followed by a delimiter
S * |        |          |character, the LIN_BKDET_F (UA_LIN_SR[8]) flag is set in UA_LIN_SR register at the end of break
S * |        |          |field.
S * |        |          |If the LIN_IEN (UA_IER [8])=1, an interrupt will be generated.
S * |        |          |0 = LIN break detection Disabled.
S * |        |          |1 = LIN break detection Enabled.
S * |[11]    |LIN_RX_DIS|LIN Receiver Disable Control
S * |        |          |If the receiver is enabled (LIN_RX_DIS (UA_LIN_CTL[11]) = 0), all received byte data will be
S * |        |          |accepted and stored in the RX-FIFO, and if the receiver is disabled (LIN_RX_DIS (UA_LIN_CTL[11])
S * |        |          |= 1), all received byte data will be ignore.
S * |        |          |0 = LIN receiver Enabled.
S * |        |          |1 = LIN receiver Disabled.
S * |        |          |Note: This bit is only valid when operating in LIN function mode (FUN_SEL (UA_FUN_SEL[1:0]) =
S * |        |          |01).
S * |[12]    |BIT_ERR_EN|Bit Error Detect Enable Control
S * |        |          |0 = Bit error detection function Disabled.
S * |        |          |1 = Bit error detection Enabled.
S * |        |          |Note: In LIN function mode, when occur bit error, the BIT_ERR_F (UA_LIN_SR[9]) flag will be
S * |        |          |asserted. If the LIN_IEN (UA_IER[8]) = 1, an interrupt will be generated.
S * |[19:16] |LIN_BKFL  |LIN Break Field Length
S * |        |          |This field indicates a 4-bit LIN TX break field count.
S * |        |          |Note1: These registers are shadow registers of LIN_BKFL, User can read/write it by setting
S * |        |          |LIN_BKFL (UA_ALT_CSR[3:0]) or LIN_BKFL (UA_LIN_CTL[19:16]).
S * |        |          |Note2: This break field length is LIN_BKFL + 1.
S * |        |          |Note3: According to LIN spec, the reset value is 12 (break field length = 13).
S * |[21:20] |LIN_BS_LEN|LIN Break/Sync Delimiter Length
S * |        |          |00 = The LIN break/sync delimiter length is 1 bit time.
S * |        |          |10 = The LIN break/sync delimiter length is 2 bit time.
S * |        |          |10 = The LIN break/sync delimiter length is 3 bit time.
S * |        |          |11 = The LIN break/sync delimiter length is 4 bit time.
S * |        |          |Note: This bit used for LIN master to sending header field.
S * |[23:22] |LIN_HEAD_SEL|LIN Header Select
S * |        |          |00 = The LIN header includes "break field".
S * |        |          |01 = The LIN header includes "break field" and "sync field".
S * |        |          |10 = The LIN header includes "break field", "sync field" and "frame ID field".
S * |        |          |11 = Reserved.
S * |        |          |Note: This bit is used to master mode for LIN to send header field (LIN_SHD (UA_LIN_CTL [8]) = 1)
S * |        |          |or used to slave to indicates exit from mute mode condition (LIN_MUTE_EN (UA_LIN_CTL[4]) = 1).
S * |[31:24] |LIN_PID   |LIN PID Register
S * |        |          |This field contains the LIN frame ID value when in LIN function mode, the frame ID parity can be
S * |        |          |generated by software or hardware depends on LIN_IDPEN (UA_LIN_CTL[9]) = 1.
S * |        |          |If the parity generated by hardware, user fill ID0~ID5, (LIN_PID [29:24] )hardware will
S * |        |          |calculate P0 (LIN_PID[30]) and P1 (LIN_PID[31]), otherwise user must filled frame ID and parity
S * |        |          |in this field.
S * |        |          |Note1: User can fill any 8-bit value to this field and the bit 24 indicates ID0 (LSB first).
S * |        |          |Note2: This field can be used for LIN master mode or slave mode.
S * @var UART_T::LIN_SR
S * Offset: 0x38  UART LIN Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |LINS_HDET_F|LIN Slave Header Detection Flag
S * |        |          |This bit is set by hardware when a LIN header is detected in LIN slave mode and be cleared by
S * |        |          |writing 1 to it.
S * |        |          |0 = LIN header not detected.
S * |        |          |1 = LIN header detected (break + sync + frame ID).
S * |        |          |Note1: This bit is can be cleared by writing 1 to it.
S * |        |          |Note2: This bit is only valid when in LIN slave mode (LINS_EN (UA_LIN_CTL [0]) = 1) and enable
S * |        |          |LIN slave header detection function (LINS_HDET_EN (UA_LIN_CTL [1])).
S * |        |          |Note3: When enable ID parity check LIN_IDPEN (UA_LIN_CTL [9]), if hardware detect complete
S * |        |          |header ("break + sync + frame ID"), the LINS_HEDT_F will be set whether the frame ID correct or
S * |        |          |not.
S * |[1]     |LINS_HERR_F|LIN Slave Header Error Flag
S * |        |          |This bit is set by hardware when a LIN header error is detected in LIN slave mode and be cleared
S * |        |          |by writing 1 to it.
S * |        |          |The header errors include "break delimiter is too short (less than 0.5 bit time)", "frame error
S * |        |          |in sync field or Identifier field", "sync field data is not 0x55 in Non-Automatic
S * |        |          |Resynchronization mode", "sync field deviation error with Automatic Resynchronization mode",
S * |        |          |"sync field measure time-out with Automatic Resynchronization mode" and "LIN header reception
S * |        |          |time-out".
S * |        |          |0 = LIN header error not detected.
S * |        |          |1 = LIN header error detected.
S * |        |          |Note1: This bit can be cleared by writing 1 to it.
S * |        |          |Note2: This bit is only valid when UART is operated in LIN slave mode (LINS_EN (UA_LIN_CTL [0])
S * |        |          |= 1) and enables LIN slave header detection function (LINS_HDET_EN (UA_LIN_CTL [1])).
S * |[2]     |LINS_IDPERR_F|LIN Slave ID Parity Error Flag
S * |        |          |This bit is set by hardware when receipted frame ID parity is not correct.
S * |        |          |0 = No active.
S * |        |          |1 = Receipted frame ID parity is not correct.
S * |        |          |Note1: This bit iscan be cleared by writing "1" to it.
S * |        |          |Note2: This bit is only valid when in LIN slave mode (LINS_EN (UA_LIN_CTL [0])= 1) and enable
S * |        |          |LIN frame ID parity check function LIN_IDPEN (UA_LIN_CTL [9]).
S * |[3]     |LINS_SYNC_F|LIN Slave Sync Field
S * |        |          |This bit indicates that the LIN sync field is being analyzed in Automatic Resynchronization
S * |        |          |mode.
S * |        |          |When the receiver header have some error been detect, user must reset the internal circuit to
S * |        |          |re-search new frame header by writing 1 to this bit.
S * |        |          |0 = The current character is not at LIN sync state.
S * |        |          |1 = The current character is at LIN sync state.
S * |        |          |Note1: This bit is only valid when in LIN Slave mode (LINS_EN(UA_LIN_CTL[0]) = 1).
S * |        |          |Note2: This bitcan be cleared by writing 1 to it.
S * |        |          |Note3: When writing 1 to it, hardware will reload the initial baud rate and re-search a new
S * |        |          |frame header.
S * |[8]     |LIN_BKDET_F|LIN Break Detection Flag
S * |        |          |This bit is set by hardware when a break is detected and be cleared by writing 1 to it through
S * |        |          |software.
S * |        |          |0 = LIN break not detected.
S * |        |          |1 = LIN break detected.
S * |        |          |Note1: This bitcan be cleared by writing 1 to it.
S * |        |          |Note2: This bit is only valid when LIN break detection function is enabled (LIN_BKDET_EN
S * |        |          |(UA_LIN_CTL[10]) =1).
S * |[9]     |BIT_ERR_F |Bit Error Detect Status Flag
S * |        |          |At TX transfer state, hardware will monitoring the bus state, if the input pin (SIN) state not
S * |        |          |equals to the output pin (SOUT) state, BIT_ERR_F (UA_LIN_SR[9]) will be set.
S * |        |          |When occur bit error, if the LIN_IEN (UA_IER[8]) = 1, an interrupt will be generated.
S * |        |          |Note1: This bit iscan be cleared by writing 1 to it.
S * |        |          |Note2: This bit is only valid when enable bit error detection function (BIT_ERR_EN (UA_LIN_CTL
S * |        |          |[12]) = 1).
S */
S
S    union {
S        __IO uint32_t DATA;          /* Offset: 0x00  UART Data Register                                                 */
S        __IO uint32_t THR;           /* Offset: 0x00  UART Transmit Holding Register                                     */
S        __IO uint32_t RBR;           /* Offset: 0x00  UART Receive Buffer Register                                       */
S    };
S    __IO uint32_t IER;           /* Offset: 0x04  UART Interrupt Enable Register                                     */
S    __IO uint32_t FCR;           /* Offset: 0x08  UART FIFO Control Register                                         */
S    __IO uint32_t LCR;           /* Offset: 0x0C  UART Line Control Register                                         */
S    __IO uint32_t MCR;           /* Offset: 0x10  UART Modem Control Register                                        */
S    __IO uint32_t MSR;           /* Offset: 0x14  UART Modem Status Register                                         */
S    __IO uint32_t FSR;           /* Offset: 0x18  UART FIFO Status Register                                          */
S    __IO uint32_t ISR;           /* Offset: 0x1C  UART Interrupt Status Register                                     */
S    __IO uint32_t TOR;           /* Offset: 0x20  UART Time-out Register                                             */
S    __IO uint32_t BAUD;          /* Offset: 0x24  UART Baud Rate Divisor Register                                    */
S    __IO uint32_t IRCR;          /* Offset: 0x28  UART IrDA Control Register                                         */
S    __IO uint32_t ALT_CSR;       /* Offset: 0x2C  UART Alternate Control/Status Register                             */
S    __IO uint32_t FUN_SEL;       /* Offset: 0x30  UART Function Select Register                                      */
S    __IO uint32_t LIN_CTL;       /* Offset: 0x34  UART LIN Control Register                                          */
S    __IO uint32_t LIN_SR;        /* Offset: 0x38  UART LIN Status Register                                           */
S    
S
S} UART_T;
S
S
S
S/**
S    @addtogroup UART_CONST UART Bit Field Definition
S    Constant Definitions for UART Controller
S@{ */
S
S
S/* UART THR Bit Field Definitions */
S#define UART_THR_THR_Pos         0                                          /*!< UART_T::THR: THR Position  */
S#define UART_THR_THR_Msk        (0xFul << UART_THR_THR_Pos)                 /*!< UART_T::THR: THR Mask      */
S
S/* UART RBR Bit Field Definitions */
S#define UART_RBR_RBR_Pos         0                                          /*!< UART_T::RBR: RBR Posistion */
S#define UART_RBR_RBR_Msk        (0xFul << UART_RBR_RBR_Pos)                 /*!< UART_T::RBR: RBR Mask      */
S
S/* UART IER Bit Field Definitions */
S#define UART_IER_DMA_RX_EN_Pos      15                                      /*!< UART_T::IER: RX DMA Enable Posistion */
S#define UART_IER_DMA_RX_EN_Msk      (1ul << UART_IER_DMA_RX_EN_Pos)         /*!< UART_T::IER: RX DMA Enable Mask      */
S
S#define UART_IER_DMA_TX_EN_Pos      14                                      /*!< UART_T::IER: TX DMA Enable Posistion */
S#define UART_IER_DMA_TX_EN_Msk      (1ul << UART_IER_DMA_TX_EN_Pos)         /*!< UART_T::IER: TX DMA Enable Mask      */
S
S#define UART_IER_AUTO_CTS_EN_Pos    13                                      /*!< UART_T::IER: AUTO_CTS_EN Posistion      */
S#define UART_IER_AUTO_CTS_EN_Msk    (1ul << UART_IER_AUTO_CTS_EN_Pos)       /*!< UART_T::IER: AUTO_CTS_EN Mask           */
S
S#define UART_IER_AUTO_RTS_EN_Pos    12                                      /*!< UART_T::IER: AUTO_RTS_EN Posistion      */
S#define UART_IER_AUTO_RTS_EN_Msk    (1ul << UART_IER_AUTO_RTS_EN_Pos)       /*!< UART_T::IER: AUTO_RTS_EN Mask           */
S
S#define UART_IER_TIME_OUT_EN_Pos    11                                      /*!< UART_T::IER: TIME_OUT_EN Posistion      */
S#define UART_IER_TIME_OUT_EN_Msk    (1ul << UART_IER_TIME_OUT_EN_Pos)       /*!< UART_T::IER: TIME_OUT_EN Mask           */
S
S#define UART_IER_LIN_IEN_Pos        8                                       /*!< UART_T::IER: LIN_IEN Posistion          */
S#define UART_IER_LIN_IEN_Msk        (1ul << UART_IER_LIN_IEN_Pos)           /*!< UART_T::IER: LIN_IEN Mask               */
S
S#define UART_IER_WAKE_EN_Pos        6                                       /*!< UART_T::IER: WAKE_EN Posistion          */
S#define UART_IER_WAKE_EN_Msk        (1ul << UART_IER_WAKE_EN_Pos)           /*!< UART_T::IER: WAKE_EN Mask               */
S
S#define UART_IER_BUF_ERR_IEN_Pos    5                                       /*!< UART_T::IER: BUF_ERR_IEN Posistion      */
S#define UART_IER_BUF_ERR_IEN_Msk    (1ul << UART_IER_BUF_ERR_IEN_Pos)       /*!< UART_T::IER: BUF_ERR_IEN Mask           */
S
S#define UART_IER_TOUT_IEN_Pos        4                                      /*!< UART_T::IER: TOUT_IEN Posistion          */
S#define UART_IER_TOUT_IEN_Msk        (1ul << UART_IER_TOUT_IEN_Pos)         /*!< UART_T::IER: TOUT_IEN Mask               */
S
S#define UART_IER_MODEM_IEN_Pos      3                                       /*!< UART_T::IER: MODEM_IEN Posistion        */
S#define UART_IER_MODEM_IEN_Msk      (1ul << UART_IER_MODEM_IEN_Pos)         /*!< UART_T::IER: MODEM_IEN Mask             */
S
S#define UART_IER_RLS_IEN_Pos        2                                       /*!< UART_T::IER: RLS_IEN Posistion          */
S#define UART_IER_RLS_IEN_Msk        (1ul << UART_IER_RLS_IEN_Pos)           /*!< UART_T::IER: RLS_IEN Mask               */
S
S#define UART_IER_THRE_IEN_Pos       1                                       /*!< UART_T::IER: THRE_IEN Posistion         */
S#define UART_IER_THRE_IEN_Msk       (1ul << UART_IER_THRE_IEN_Pos)          /*!< UART_T::IER: THRE_IEN Mask              */
S
S#define UART_IER_RDA_IEN_Pos        0                                       /*!< UART_T::IER: RDA_IEN Position           */
S#define UART_IER_RDA_IEN_Msk        (1ul << UART_IER_RDA_IEN_Pos)           /*!< UART_T::IER: RDA_IEN Mask               */
S
S/* UART FCR Bit Field Definitions */
S#define UART_FCR_RTS_TRI_LEV_Pos    16                                      /*!< UART_T::FCR: RTS_TRI_LEV Position       */
S#define UART_FCR_RTS_TRI_LEV_Msk    (0xFul << UART_FCR_RTS_TRI_LEV_Pos)     /*!< UART_T::FCR: RTS_TRI_LEV Mask           */
S
S#define UART_FCR_RX_DIS_Pos         8                                       /*!< UART_T::FCR: RX_DIS Position            */
S#define UART_FCR_RX_DIS_Msk         (1ul << UART_FCR_RX_DIS_Pos)            /*!< UART_T::FCR: RX_DIS Mask                */
S
S#define UART_FCR_RFITL_Pos          4                                       /*!< UART_T::FCR: RFITL Position             */
S#define UART_FCR_RFITL_Msk          (0xFul << UART_FCR_RFITL_Pos)           /*!< UART_T::FCR: RFITL Mask                 */
S
S#define UART_FCR_TFR_Pos            2                                       /*!< UART_T::FCR: TFR Position               */
S#define UART_FCR_TFR_Msk            (1ul << UART_FCR_TFR_Pos)               /*!< UART_T::FCR: TFR Mask                   */
S
S#define UART_FCR_RFR_Pos            1                                       /*!< UART_T::FCR: RFR Position               */
S#define UART_FCR_RFR_Msk            (1ul << UART_FCR_RFR_Pos)               /*!< UART_T::FCR: RFR Mask                   */
S
S/* UART LCR Bit Field Definitions */
S#define UART_LCR_BCB_Pos            6                                       /*!< UART_T::LCR: BCB Position               */
S#define UART_LCR_BCB_Msk            (1ul << UART_LCR_BCB_Pos)               /*!< UART_T::LCR: BCB Mask                   */
S
S#define UART_LCR_SPE_Pos            5                                       /*!< UART_T::LCR: SPE Position               */
S#define UART_LCR_SPE_Msk            (1ul << UART_LCR_SPE_Pos)               /*!< UART_T::LCR: SPE Mask                   */
S
S#define UART_LCR_EPE_Pos            4                                       /*!< UART_T::LCR: EPE Position               */
S#define UART_LCR_EPE_Msk            (1ul << UART_LCR_EPE_Pos)               /*!< UART_T::LCR: EPE Mask                   */
S
S#define UART_LCR_PBE_Pos            3                                       /*!< UART_T::LCR: PBE Position               */
S#define UART_LCR_PBE_Msk            (1ul << UART_LCR_PBE_Pos)               /*!< UART_T::LCR: PBE Mask                   */
S
S#define UART_LCR_NSB_Pos            2                                       /*!< UART_T::LCR: NSB Position               */
S#define UART_LCR_NSB_Msk            (1ul << UART_LCR_NSB_Pos)               /*!< UART_T::LCR: NSB Mask                   */
S
S#define UART_LCR_WLS_Pos            0                                       /*!< UART_T::LCR: WLS Position               */
S#define UART_LCR_WLS_Msk            (0x3ul << UART_LCR_WLS_Pos)             /*!< UART_T::LCR: WLS Mask                   */
S
S/* UART MCR Bit Field Definitions */
S#define UART_MCR_RTS_ST_Pos         13                                      /*!< UART_T::MCR: RTS_ST Position            */
S#define UART_MCR_RTS_ST_Msk         (1ul << UART_MCR_RTS_ST_Pos)            /*!< UART_T::MCR: RTS_ST Mask                */
S
S#define UART_MCR_LEV_RTS_Pos        9                                       /*!< UART_T::MCR: LEV_RTS Position           */
S#define UART_MCR_LEV_RTS_Msk        (1ul << UART_MCR_LEV_RTS_Pos)           /*!< UART_T::MCR: LEV_RTS Mask               */
S
S#define UART_MCR_RTS_Pos            1                                       /*!< UART_T::MCR: RTS Position               */
S#define UART_MCR_RTS_Msk            (1ul << UART_MCR_RTS_Pos)               /*!< UART_T::MCR: RTS Mask                   */
S
S/* UART MSR Bit Field Definitions */
S#define UART_MSR_LEV_CTS_Pos        8                                       /*!< UART_T::MSR: LEV_CTS Position           */
S#define UART_MSR_LEV_CTS_Msk        (1ul << UART_MSR_LEV_CTS_Pos)           /*!< UART_T::MSR: LEV_CTS Mask               */
S
S#define UART_MSR_CTS_ST_Pos         4                                       /*!< UART_T::MSR: CTS_ST Position            */
S#define UART_MSR_CTS_ST_Msk         (1ul << UART_MSR_CTS_ST_Pos)            /*!< UART_T::MSR: CTS_ST Mask                */
S
S#define UART_MSR_DCTSF_Pos          0                                       /*!< UART_T::MSR: DCTST Position             */
S#define UART_MSR_DCTSF_Msk          (1ul << UART_MSR_DCTSF_Pos)             /*!< UART_T::MSR: DCTST Mask                 */
S
S
S/* UART FSR Bit Field Definitions */
S#define UART_FSR_TE_FLAG_Pos        28                                      /*!< UART_T::FSR: TE_FLAG Position           */
S#define UART_FSR_TE_FLAG_Msk        (1ul << UART_FSR_TE_FLAG_Pos)           /*!< UART_T::FSR: TE_FLAG Mask               */
S
S#define UART_FSR_TX_OVER_IF_Pos     24                                      /*!< UART_T::FSR: TX_OVER_IF Position        */
S#define UART_FSR_TX_OVER_IF_Msk     (1ul << UART_FSR_TX_OVER_IF_Pos)        /*!< UART_T::FSR: TX_OVER_IF Mask            */
S
S#define UART_FSR_TX_FULL_Pos        23                                      /*!< UART_T::FSR: TX_FULL Position           */
S#define UART_FSR_TX_FULL_Msk        (1ul << UART_FSR_TX_FULL_Pos)           /*!< UART_T::FSR: TX_FULL Mask               */
S
S#define UART_FSR_TX_EMPTY_Pos       22                                      /*!< UART_T::FSR: TX_EMPTY Position          */
S#define UART_FSR_TX_EMPTY_Msk       (1ul << UART_FSR_TX_EMPTY_Pos)          /*!< UART_T::FSR: TX_EMPTY Mask              */
S
S#define UART_FSR_TX_POINTER_Pos     16                                      /*!< UART_T::FSR: TX_POINTER Position        */
S#define UART_FSR_TX_POINTER_Msk     (0x3Ful << UART_FSR_TX_POINTER_Pos)     /*!< UART_T::FSR: TX_POINTER Mask            */
S
S#define UART_FSR_RX_FULL_Pos        15                                      /*!< UART_T::FSR: RX_FULL Position           */
S#define UART_FSR_RX_FULL_Msk        (1ul << UART_FSR_RX_FULL_Pos)           /*!< UART_T::FSR: RX_FULL Mask               */
S
S#define UART_FSR_RX_EMPTY_Pos       14                                      /*!< UART_T::FSR: RX_EMPTY Position          */
S#define UART_FSR_RX_EMPTY_Msk       (1ul << UART_FSR_RX_EMPTY_Pos)          /*!< UART_T::FSR: RX_EMPTY Mask              */
S
S#define UART_FSR_RX_POINTER_Pos     8                                       /*!< UART_T::FSR: RX_POINTERS Position       */
S#define UART_FSR_RX_POINTER_Msk     (0x3Ful << UART_FSR_RX_POINTER_Pos)     /*!< UART_T::FSR: RX_POINTER Mask            */
S
S#define UART_FSR_BIF_Pos            6                                       /*!< UART_T::FSR: BIF Position               */
S#define UART_FSR_BIF_Msk            (1ul << UART_FSR_BIF_Pos)               /*!< UART_T::FSR: BIF Mask                   */
S
S#define UART_FSR_FEF_Pos            5                                       /*!< UART_T::FSR: FEF Position               */
S#define UART_FSR_FEF_Msk            (1ul << UART_FSR_FEF_Pos)               /*!< UART_T::FSR: FEF Mask                   */
S
S#define UART_FSR_PEF_Pos            4                                       /*!< UART_T::FSR: PEF Position               */
S#define UART_FSR_PEF_Msk            (1ul << UART_FSR_PEF_Pos)               /*!< UART_T::FSR: PEF Mask                   */
S
S#define UART_FSR_RS485_ADD_DETF_Pos 3                                       /*!< UART_T::FSR: RS485_ADD_DETF Position    */
S#define UART_FSR_RS485_ADD_DETF_Msk (1ul << UART_FSR_RS485_ADD_DETF_Pos)    /*!< UART_T::FSR: RS485_ADD_DETF Mask        */
S
S#define UART_FSR_RX_OVER_IF_Pos     0                                       /*!< UART_T::FSR: RX_OVER_IF Position        */
S#define UART_FSR_RX_OVER_IF_Msk     (1ul << UART_FSR_RX_OVER_IF_Pos)        /*!< UART_T::FSR: RX_OVER_IF Mask            */
S
S/* UART ISR Bit Field Definitions */
S#define UART_ISR_HW_BUF_ERR_INT_Pos 29                                      /*!< UART_T::ISR: HW BUF_ERR_INT Position    */
S#define UART_ISR_HW_BUF_ERR_INT_Msk (1ul << UART_ISR_HW_BUF_ERR_INT_Pos)    /*!< UART_T::ISR: HW BUF_ERR_INT Mask        */
S
S#define UART_ISR_HW_TOUT_INT_Pos    28                                      /*!< UART_T::ISR: HW TOUT_INT Position       */
S#define UART_ISR_HW_TOUT_INT_Msk    (1ul << UART_ISR_HW_TOUT_INT_Pos)       /*!< UART_T::ISR: HW TOUT_INT Mask           */
S
S#define UART_ISR_HW_MODEM_INT_Pos   27                                      /*!< UART_T::ISR: HW MODEM_INT Position      */
S#define UART_ISR_HW_MODEM_INT_Msk   (1ul << UART_ISR_HW_MODEM_INT_Pos)      /*!< UART_T::ISR: HW MODEM_INT Mask          */
S
S#define UART_ISR_HW_RLS_INT_Pos     26                                      /*!< UART_T::ISR: HW RLS_INT Position        */
S#define UART_ISR_HW_RLS_INT_Msk     (1ul << UART_ISR_HW_RLS_INT_Pos)        /*!< UART_T::ISR: HW RLS_INT Position        */
S
S#define UART_ISR_HW_BUF_ERR_IF_Pos  21                                      /*!< UART_T::ISR: HW BUF_ERR_IF Position     */
S#define UART_ISR_HW_BUF_ERR_IF_Msk  (1ul << UART_ISR_HW_BUF_ERR_IF_Pos)     /*!< UART_T::ISR: HW BUF_ERR_IF Mask         */
S
S#define UART_ISR_HW_TOUT_IF_Pos     20                                      /*!< UART_T::ISR: HW TOUT_IF Position        */
S#define UART_ISR_HW_TOUT_IF_Msk     (1ul << UART_ISR_HW_TOUT_IFF_Pos)       /*!< UART_T::ISR: HW TOUT_IF Mask            */
S
S#define UART_ISR_HW_MODEM_IF_Pos    19                                      /*!< UART_T::ISR: HW MODEM_IF Position       */
S#define UART_ISR_HW_MODEM_IF_Msk    (1ul << UART_ISR_HW_MODEM_IF_Pos)       /*!< UART_T::ISR: HW MODEM_IF Mask           */
S
S#define UART_ISR_HW_RLS_IF_Pos      18                                      /*!< UART_T::ISR: HW RLS_IF Position         */
S#define UART_ISR_HW_RLS_IF_Msk      (1ul << UART_ISR_HW_RLS_IF_Pos)         /*!< UART_T::ISR: HW RLS_IF Mark             */
S
S#define UART_ISR_LIN_INT_Pos        15                                      /*!< UART_T::ISR: LIN_INT Position           */
S#define UART_ISR_LIN_INT_Msk        (1ul << UART_ISR_LIN_INT_Pos)           /*!< UART_T::ISR: LIN_INT Mask               */
S
S#define UART_ISR_BUF_ERR_INT_Pos    13                                      /*!< UART_T::ISR: BUF_ERR_INT Position       */
S#define UART_ISR_BUF_ERR_INT_Msk    (1ul << UART_ISR_BUF_ERR_INT_Pos)       /*!< UART_T::ISR: BUF_ERR_INT Mask           */
S
S#define UART_ISR_TOUT_INT_Pos       12                                      /*!< UART_T::ISR: TOUT_INT Position          */
S#define UART_ISR_TOUT_INT_Msk       (1ul << UART_ISR_TOUT_INT_Pos)          /*!< UART_T::ISR: TOUT_INT Mask              */
S
S#define UART_ISR_MODEM_INT_Pos      11                                      /*!< UART_T::ISR: MODEM_INT Position         */
S#define UART_ISR_MODEM_INT_Msk      (1ul << UART_ISR_MODEM_INT_Pos)         /*!< UART_T::ISR: MODEM_INT Mask             */
S
S#define UART_ISR_RLS_INT_Pos        10                                      /*!< UART_T::ISR: RLS_INT Position           */
S#define UART_ISR_RLS_INT_Msk        (1ul << UART_ISR_RLS_INT_Pos)           /*!< UART_T::ISR: RLS_INT Mask               */
S
S#define UART_ISR_THRE_INT_Pos       9                                       /*!< UART_T::ISR: THRE_INT Position          */
S#define UART_ISR_THRE_INT_Msk       (1ul << UART_ISR_THRE_INT_Pos)          /*!< UART_T::ISR: THRE_INT Mask              */
S
S#define UART_ISR_RDA_INT_Pos        8                                       /*!< UART_T::ISR: RDA_INT Position           */
S#define UART_ISR_RDA_INT_Msk        (1ul << UART_ISR_RDA_INT_Pos)           /*!< UART_T::ISR: RDA_INT Mask               */
S
S#define UART_ISR_LIN_IF_Pos         7                                       /*!< UART_T::ISR: LIN RX_IF Position         */
S#define UART_ISR_LIN_IF_Msk         (1ul << UART_ISR_LIN_IF_Pos)            /*!< UART_T::ISR: LIN RX_IF Mask             */
S
S#define UART_ISR_BUF_ERR_IF_Pos     5                                       /*!< UART_T::ISR: BUF_ERR_IF Position        */
S#define UART_ISR_BUF_ERR_IF_Msk     (1ul << UART_ISR_BUF_ERR_IF_Pos)        /*!< UART_T::ISR: BUF_ERR_IF Mask            */
S
S#define UART_ISR_TOUT_IF_Pos        4                                       /*!< UART_T::ISR: TOUT_IF Position           */
S#define UART_ISR_TOUT_IF_Msk        (1ul << UART_ISR_TOUT_IF_Pos)           /*!< UART_T::ISR: TOUT_IF Mask               */
S
S#define UART_ISR_MODEM_IF_Pos       3                                       /*!< UART_T::ISR: MODEM_IF Position          */
S#define UART_ISR_MODEM_IF_Msk       (1ul << UART_ISR_MODEM_IF_Pos)          /*!< UART_T::ISR: MODEM_IF Mask              */
S
S#define UART_ISR_RLS_IF_Pos         2                                       /*!< UART_T::ISR: RLS_IF Position            */
S#define UART_ISR_RLS_IF_Msk         (1ul << UART_ISR_RLS_IF_Pos)            /*!< UART_T::ISR: RLS_IF Mask                */
S
S#define UART_ISR_THRE_IF_Pos        1                                       /*!< UART_T::ISR: THRE_IF Position           */
S#define UART_ISR_THRE_IF_Msk        (1ul << UART_ISR_THRE_IF_Pos)           /*!< UART_T::ISR: THRE_IF Mask               */
S
S#define UART_ISR_RDA_IF_Pos         0                                       /*!< UART_T::ISR: RDA_IF Position            */
S#define UART_ISR_RDA_IF_Msk         (1ul << UART_ISR_RDA_IF_Pos)            /*!< UART_T::ISR: RDA_IF Mask                */
S
S
S/* UART TOR Bit Field Definitions */
S#define UART_TOR_DLY_Pos           8                                        /*!< UART_T::TOR: DLY Position               */
S#define UART_TOR_DLY_Msk           (0xFFul << UART_TOR_DLY_Pos)             /*!< UART_T::TOR: DLY Mask                   */
S
S#define UART_TOR_TOIC_Pos          0                                        /*!< UART_T::TOR: TOIC Position              */
S#define UART_TOR_TOIC_Msk          (0xFFul << UART_TOR_TOIC_Pos)
S
S/* UART BAUD Bit Field Definitions */
S#define UART_BAUD_DIV_X_EN_Pos    29                                        /*!< UART_T::BAUD: DIV_X_EN Position         */
S#define UART_BAUD_DIV_X_EN_Msk    (1ul << UART_BAUD_DIV_X_EN_Pos)           /*!< UART_T::BAUD: DIV_X_EN Mask             */
S
S#define UART_BAUD_DIV_X_ONE_Pos   28                                        /*!< UART_T::BAUD: DIV_X_ONE Position        */
S#define UART_BAUD_DIV_X_ONE_Msk   (1ul << UART_BAUD_DIV_X_ONE_Pos)          /*!< UART_T::BAUD: DIV_X_ONE Mask            */
S
S#define UART_BAUD_DIVIDER_X_Pos   24                                        /*!< UART_T::BAUD: DIVIDER_X Position        */
S#define UART_BAUD_DIVIDER_X_Msk   (0xFul << UART_BAUD_DIVIDER_X_Pos)        /*!< UART_T::BAUD: DIVIDER_X Mask            */
S
S#define UART_BAUD_BRD_Pos         0                                         /*!< UART_T::BAUD: BRD Position              */
S#define UART_BAUD_BRD_Msk         (0xFFFFul << UART_BAUD_BRD_Pos)           /*!< UART_T::BAUD: BRD Mask                  */
S
S/* UART IRCR Bit Field Definitions */
S#define UART_IRCR_INV_RX_Pos      6                                         /*!< UART_T::IRCR: INV_RX Position           */
S#define UART_IRCR_INV_RX_Msk     (1ul << UART_IRCR_INV_RX_Pos)              /*!< UART_T::IRCR: INV_RX Mask               */
S
S#define UART_IRCR_INV_TX_Pos      5                                         /*!< UART_T::IRCR: INV_TX Position           */
S#define UART_IRCR_INV_TX_Msk     (1ul << UART_IRCR_INV_TX_Pos)              /*!< UART_T::IRCR: INV_TX Mask               */
S
S#define UART_IRCR_TX_SELECT_Pos   1                                         /*!< UART_T::IRCR: TX_SELECT Position        */
S#define UART_IRCR_TX_SELECT_Msk   (1ul << UART_IRCR_TX_SELECT_Pos)          /*!< UART_T::IRCR: TX_SELECT Mask            */
S
S/* UART ALT_CSR Bit Field Definitions */
S#define UART_ALT_CSR_ADDR_MATCH_Pos      24                                      /*!< UART_T::ALT_CSR: ADDR_MATCH Position    */
S#define UART_ALT_CSR_ADDR_MATCH_Msk     (0xFFul << UART_ALT_CSR_ADDR_MATCH_Pos)  /*!< UART_T::ALT_CSR: ADDR_MATCH Mask        */
S
S#define UART_ALT_CSR_RS485_ADD_EN_Pos   15                                       /*!< UART_T::ALT_CSR: RS485_ADD_EN Position  */
S#define UART_ALT_CSR_RS485_ADD_EN_Msk   (1ul << UART_ALT_CSR_RS485_ADD_EN_Pos)   /*!< UART_T::ALT_CSR: RS485_ADD_EN Mask      */
S
S#define UART_ALT_CSR_RS485_AUD_Pos      10                                       /*!< UART_T::ALT_CSR: RS485_AUD Position     */
S#define UART_ALT_CSR_RS485_AUD_Msk      (1ul << UART_ALT_CSR_RS485_AUD_Pos)      /*!< UART_T::ALT_CSR: RS485_AUD Mask         */
S
S#define UART_ALT_CSR_RS485_AAD_Pos      9                                        /*!< UART_T::ALT_CSR: RS485_AAD Position     */
S#define UART_ALT_CSR_RS485_AAD_Msk      (1ul << UART_ALT_CSR_RS485_AAD_Pos)      /*!< UART_T::ALT_CSR: RS485_AAD Mask         */
S
S#define UART_ALT_CSR_RS485_NMM_Pos      8                                        /*!< UART_T::ALT_CSR: RS485_NMM Position     */
S#define UART_ALT_CSR_RS485_NMM_Msk      (1ul << UART_ALT_CSR_RS485_NMM_Pos)      /*!< UART_T::ALT_CSR: RS485_NMM Mask         */
S
S#define UART_ALT_CSR_LIN_TX_EN_Pos      7                                        /*!< UART_T::ALT_CSR: LIN TX Break Mode Enable Position     */
S#define UART_ALT_CSR_LIN_TX_EN_Msk      (1ul << UART_ALT_CSR_LIN_TX_EN_Pos)      /*!< UART_T::ALT_CSR: LIN TX Break Mode Enable Mask         */
S
S#define UART_ALT_CSR_LIN_RX_EN_Pos      6                                        /*!< UART_T::ALT_CSR: LIN RX Enable Position     */
S#define UART_ALT_CSR_LIN_RX_EN_Msk      (1ul << UART_ALT_CSR_LIN_RX_EN_Pos)      /*!< UART_T::ALT_CSR: LIN RX Enable Mask         */
S
S#define UART_ALT_CSR_UA_LIN_BKFL_Pos    0                                        /*!< UART_T::ALT_CSR: UART LIN Break Field Length Position     */
S#define UART_ALT_CSR_UA_LIN_BKFL_Msk    (0xFul << UART_ALT_CSR_UA_LIN_BKFL_Pos)  /*!< UART_T::ALT_CSR: UART LIN Break Field Length Mask         */
S
S/* UART FUN_SEL Bit Field Definitions */
S#define UART_FUN_SEL_FUN_SEL_Pos        0                                        /*!< UART_T::FUN_SEL: FUN_SEL Position       */
S#define UART_FUN_SEL_FUN_SEL_Msk       (0x3ul << UART_FUN_SEL_FUN_SEL_Pos)       /*!< UART_T::FUN_SEL: FUN_SEL Mask           */
S
S/* UART LIN_CTL Bit Field Definitions */
S#define UART_LIN_CTL_LIN_PID_Pos        24                                        /*!< UART_T::LIN_CTL: LIN_PID Position       */
S#define UART_LIN_CTL_LIN_PID_Msk        (0xFFul << UART_LIN_CTL_LIN_PID_Pos)      /*!< UART_T::LIN_CTL: LIN_PID Mask           */
S
S#define UART_LIN_CTL_LIN_HEAD_SEL_Pos   22                                        /*!< UART_T::LIN_CTL: LIN_HEAD_SEL Position       */
S#define UART_LIN_CTL_LIN_HEAD_SEL_Msk   (0x3ul << UART_LIN_CTL_LIN_HEAD_SEL_Pos)  /*!< UART_T::LIN_CTL: LIN_HEAD_SEL Mask           */
S
S#define UART_LIN_CTL_LIN_BS_LEN_Pos     20                                        /*!< UART_T::LIN_CTL: LIN_BS_LEN Position       */
S#define UART_LIN_CTL_LIN_BS_LEN_Msk     (0x3ul << UART_LIN_CTL_LIN_BS_LEN_Pos)    /*!< UART_T::LIN_CTL: LIN_BS_LEN Mask           */
S
S#define UART_LIN_CTL_LIN_BKFL_Pos       16                                        /*!< UART_T::LIN_CTL: LIN_BKFL Position       */
S#define UART_LIN_CTL_LIN_BKFL_Msk       (0xFul << UART_LIN_CTL_LIN_BKFL_Pos)      /*!< UART_T::LIN_CTL: LIN_BKFL Mask           */
S
S#define UART_LIN_CTL_BIT_ERR_EN_Pos     12                                        /*!< UART_T::LIN_CTL: BIT_ERR_EN Position       */
S#define UART_LIN_CTL_BIT_ERR_EN_Msk     (1ul << UART_LIN_CTL_BIT_ERR_EN_Pos)      /*!< UART_T::LIN_CTL: BIT_ERR_EN Mask           */
S
S#define UART_LIN_CTL_LIN_RX_DIS_Pos     11                                        /*!< UART_T::LIN_CTL: LIN_RX_DIS Position       */
S#define UART_LIN_CTL_LIN_RX_DIS_Msk     (1ul << UART_LIN_CTL_LIN_RX_DIS_Pos)      /*!< UART_T::LIN_CTL: LIN_RX_DIS Mask           */
S
S#define UART_LIN_CTL_LIN_BKDET_EN_Pos   10                                        /*!< UART_T::LIN_CTL: LIN_BKDET_EN Position       */
S#define UART_LIN_CTL_LIN_BKDET_EN_Msk   (1ul << UART_LIN_CTL_LIN_BKDET_EN_Pos)    /*!< UART_T::LIN_CTL: LIN_BKDET_EN Mask           */
S
S#define UART_LIN_CTL_LIN_IDPEN_Pos      9                                         /*!< UART_T::LIN_CTL: LIN_IDPEN Position       */
S#define UART_LIN_CTL_LIN_IDPEN_Msk      (1ul << UART_LIN_CTL_LIN_IDPEN_Pos)       /*!< UART_T::LIN_CTL: LIN_IDPEN Mask           */
S
S#define UART_LIN_CTL_LIN_SHD_Pos        8                                         /*!< UART_T::LIN_CTL: LIN_SHD Position       */
S#define UART_LIN_CTL_LIN_SHD_Msk        (1ul << UART_LIN_CTL_LIN_SHD_Pos)         /*!< UART_T::LIN_CTL: LIN_SHD Mask           */
S
S#define UART_LIN_CTL_LIN_MUTE_EN_Pos    4                                          /*!< UART_T::LIN_CTL: LIN_MUTE_EN Position       */
S#define UART_LIN_CTL_LIN_MUTE_EN_Msk    (1ul << UART_LIN_CTL_LIN_MUTE_EN_Pos)      /*!< UART_T::LIN_CTL: LIN_MUTE_EN Mask           */
S
S#define UART_LIN_CTL_LINS_DUM_EN_Pos    3                                          /*!< UART_T::LIN_CTL: LINS_DUM_EN Position       */
S#define UART_LIN_CTL_LINS_DUM_EN_Msk    (1ul << UART_LIN_CTL_LINS_DUM_EN_Pos)      /*!< UART_T::LIN_CTL: LINS_DUM_EN Mask           */
S
S#define UART_LIN_CTL_LINS_ARS_EN_Pos    2                                          /*!< UART_T::LIN_CTL: LINS_ARS_EN Position       */
S#define UART_LIN_CTL_LINS_ARS_EN_Msk    (1ul << UART_LIN_CTL_LINS_ARS_EN_Pos)      /*!< UART_T::LIN_CTL: LINS_ARS_EN Mask           */
S
S#define UART_LIN_CTL_LINS_HDET_EN_Pos   1                                          /*!< UART_T::LIN_CTL: LINS_HDET_EN Position       */
S#define UART_LIN_CTL_LINS_HDET_EN_Msk   (1ul << UART_LIN_CTL_LINS_HDET_EN_Pos)     /*!< UART_T::LIN_CTL: LINS_HDET_EN Mask           */
S
S#define UART_LIN_CTL_LINS_EN_Pos        0                                          /*!< UART_T::LIN_CTL: LINS_EN Position       */
S#define UART_LIN_CTL_LINS_EN_Msk        (1ul << UART_LIN_CTL_LINS_EN_Pos)          /*!< UART_T::LIN_CTL: LINS_EN Mask           */
S
S/* UART LIN_SR Bit Field Definitions */
S#define UART_LIN_SR_BIT_ERR_F_Pos       9                                           /*!< UART_T::LIN_SR: BIT_ERR_F Position         */
S#define UART_LIN_SR_BIT_ERR_F_Msk       (1ul << UART_LIN_SR_BIT_ERR_F_Pos)          /*!< UART_T::LIN_SR: BIT_ERR_F Mask             */
S
S#define UART_LIN_SR_LINS_BKDET_F_Pos    8                                           /*!< UART_T::LIN_SR: LINS_BKDET_F Position      */
S#define UART_LIN_SR_LINS_BKDET_F_Msk    (1ul << UART_LIN_SR_LINS_BKDET_F_Pos)       /*!< UART_T::LIN_SR: LINS_BKDET_F Mask          */
S
S#define UART_LIN_SR_LINS_SYNC_F_Pos     3                                           /*!< UART_T::LIN_SR: LINS_SYNC_F Position       */
S#define UART_LIN_SR_LINS_SYNC_F_Msk     (1ul << UART_LIN_SR_LINS_SYNC_F_Pos)        /*!< UART_T::LIN_SR: LINS_SYNC_F Mask           */
S
S#define UART_LIN_SR_LINS_IDPERR_F_Pos   2                                           /*!< UART_T::LIN_SR: LINS_IDPERR_F Position     */
S#define UART_LIN_SR_LINS_IDPERR_F_Msk   (1ul << UART_LIN_SR_LINS_IDPERR_F_Pos)      /*!< UART_T::LIN_SR: LINS_IDPERR_F Mask         */
S
S#define UART_LIN_SR_LINS_HERR_F_Pos     1                                           /*!< UART_T::LIN_SR: LINS_HERR_F Position       */
S#define UART_LIN_SR_LINS_HERR_F_Msk     (1ul << UART_LIN_SR_LINS_HERR_F_Pos)        /*!< UART_T::LIN_SR: LINS_HERR_F Mask           */
S
S#define UART_LIN_SR_LINS_HDET_F_Pos     0                                           /*!< UART_T::LIN_SR: LINS_HDET_F Position       */
S#define UART_LIN_SR_LINS_HDET_F_Msk     (1ul << UART_LIN_SR_LINS_HDET_F_Pos)        /*!< UART_T::LIN_SR: LINS_HDET_F Mask           */
S
S/*@}*/ /* end of group UART_CONST */
S/*@}*/ /* end of group UART */
S
S
S/*---------------------- Universal Serial Bus Device Controller -------------------------*/
S/**
S    @addtogroup USBD Universal Serial Bus Device Controller (USBD)
S    Memory Mapped Structure for USBD Controller
S@{ */
S
S
Stypedef struct
S{
S
S
S/**
S * @var USBD_EP_T::BUFSEG
S * Offset: 0x500/0x510/0x520/0x530/0x540/0x550/0x560/0x570  Endpoint 0~7 Buffer Segmentation Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[8:3]   |BUFSEG    |Endpoint Buffer Segmentation
S * |        |          |It is used to indicate the offset address for each endpoint with the USB SRAM starting address
S * |        |          |The effective starting address of the endpoint is
S * |        |          |USB_SRAM address + { BUFSEG[8:3], 3'b000}
S * |        |          |Where the USB_SRAM address = USBD_BA+0x100h.
S * |        |          |Refer to the section 5.4.4.7 for the endpoint SRAM structure and its description.
S * @var USBD_EP_T::MXPLD
S * Offset: 0x504/0x514/0x524/0x534/0x544/0x554/0x564/0x574  Endpoint 0~7 Maximal Payload Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[8:0]   |MXPLD     |Maximal Payload
S * |        |          |Define the data length which is transmitted to host (IN token) or the actual data length which
S * |        |          |is received from the host (OUT token).
S * |        |          |It also used to indicate that the endpoint is ready to be transmitted in IN token or received in
S * |        |          |OUT token.
S * |        |          |(1) When the register is written by CPU,
S * |        |          |For IN token, the value of MXPLD is used to define the data length to be transmitted and
S * |        |          |indicate the data buffer is ready.
S * |        |          |For OUT token, it means that the controller is ready to receive data from the host and the value
S * |        |          |of MXPLD is the maximal data length comes from host.
S * |        |          |(2) When the register is read by CPU,
S * |        |          |For IN token, the value of MXPLD is indicated by the data length be transmitted to host
S * |        |          |For OUT token, the value of MXPLD is indicated the actual data length receiving from host.
S * |        |          |Note: Once MXPLD is written, the data packets will be transmitted/received immediately after
S * |        |          |IN/OUT token arrived.
S * @var USBD_EP_T::CFG
S * Offset: 0x508/0x518/0x528/0x538/0x548/0x558/0x568/0x578  Endpoint 0~7 Configuration Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[3:0]   |EP_NUM    |Endpoint Number
S * |        |          |These bits are used to define the endpoint number of the current endpoint.
S * |[4]     |ISOCH     |Isochronous Endpoint
S * |        |          |This bit is used to set the endpoint as Isochronous endpoint, no handshake.
S * |        |          |0 = No Isochronous endpoint.
S * |        |          |1 = Isochronous endpoint.
S * |[6:5]   |STATE     |Endpoint STATE
S * |        |          |00 = Endpoint is Disabled.
S * |        |          |01 = Out endpoint.
S * |        |          |10 = IN endpoint.
S * |        |          |11 = Undefined.
S * |[7]     |DSQ_SYNC  |Data Sequence Synchronization
S * |        |          |0 = DATA0 PID.
S * |        |          |1 = DATA1 PID.
S * |        |          |Note: It is used to specify the DATA0 or DATA1 PID in the following IN token transaction.
S * |        |          |Hardware will toggle automatically in IN token base on the bit.
S * |[9]     |CSTALL    |Clear STALL Response
S * |        |          |0 = Disable the device to clear the STALL handshake in setup stage.
S * |        |          |1 = Clear the device to response STALL handshake in setup stage.
S * @var USBD_EP_T::CFGP
S * Offset: 0x50C/0x51C/0x52C/0x53C/0x54C/0x55C/0x56C/0x57C  Endpoint 0~7 Set Stall and Clear In/Out Ready Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |CLRRDY    |Clear Ready
S * |        |          |When the USB_MXPLD register is set by user, it means that the endpoint is ready to transmit or
S * |        |          |receive data.
S * |        |          |If the user wants to turn off this transaction before the transaction start, users can set this
S * |        |          |bit to 1 to turn it off and it will be cleared to 0 automatically.
S * |        |          |For IN token, write '1' to clear the IN token had ready to transmit the data to USB.
S * |        |          |For OUT token, write '1' to clear the OUT token had ready to receive the data from USB.
S * |        |          |This bit is write 1 only and is always 0 when it is read back.
S * |[1]     |SSTALL    |Set STALL
S * |        |          |0 = Disable the device to response STALL.
S * |        |          |1 = Set the device to respond STALL automatically.
S */
S
S    __IO uint32_t BUFSEG;        /* Offset: 0x500/0x510/0x520/0x530/0x540/0x550/0x560/0x570  Endpoint 0~7 Buffer Segmentation Register */
S    __IO uint32_t MXPLD;         /* Offset: 0x504/0x514/0x524/0x534/0x544/0x554/0x564/0x574  Endpoint 0~7 Maximal Payload Register */
S    __IO uint32_t CFG;           /* Offset: 0x508/0x518/0x528/0x538/0x548/0x558/0x568/0x578  Endpoint 0~7 Configuration Register */
S    __IO uint32_t CFGP;          /* Offset: 0x50C/0x51C/0x52C/0x53C/0x54C/0x55C/0x56C/0x57C  Endpoint 0~7 Set Stall and Clear In/Out Ready Control Register */
S
S} USBD_EP_T;
S
S
S
S
S
S
Stypedef struct
S{
S
S
S/**
S * @var USBD_T::INTEN
S * Offset: 0x00  USB Interrupt Enable Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |BUS_IE    |Bus Event Interrupt Enable
S * |        |          |0 = BUS event interrupt Disabled.
S * |        |          |1 = BUS event interrupt Enabled.
S * |[1]     |USB_IE    |USB Event Interrupt Enable
S * |        |          |0 = USB event interrupt Disabled.
S * |        |          |1 = USB event interrupt Enabled.
S * |[2]     |FLDET_IE  |Floating Detection Interrupt Enable
S * |        |          |0 = Floating detection Interrupt Disabled.
S * |        |          |1 = Floating detection Interrupt Enabled.
S * |[3]     |WAKEUP_IE |USB Wake-Up Interrupt Enable
S * |        |          |0 = Wake-up Interrupt Disabled.
S * |        |          |1 = Wake-up Interrupt Enabled.
S * |[8]     |WAKEUP_EN |Wake-Up Function Enable
S * |        |          |0 = USB wake-up function Disabled.
S * |        |          |1 = USB wake-up function Enabled.
S * |[15]    |INNAK_EN  |Active NAK Function And Its Status In IN Token
S * |        |          |0 = When device responds NAK after receiving IN token, IN NAK status will not be
S * |        |          |    updated to USBD_EPSTS register, so that the USB interrupt event will not be asserted.
S * |        |          |1 = IN NAK status will be updated to USBD_EPSTS register and the USB interrupt event
S * |        |          |    will be asserted, when the device responds NAK after receiving IN token.
S * @var USBD_T::INTSTS
S * Offset: 0x04  USB Interrupt Event Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |BUS_STS   |BUS Interrupt Status
S * |        |          |The BUS event means that there is one of the suspense or the resume function in the bus.
S * |        |          |0 = No BUS event occurred.
S * |        |          |1 = Bus event occurred; check USB_ATTR[3:0] to know which kind of bus event was occurred,
S * |        |          |cleared by write 1 to USB_INTSTS[0].
S * |[1]     |USB_STS   |USB Event Interrupt Status
S * |        |          |The USB event includes the SETUP Token, IN Token, OUT ACK, ISO IN, or ISO OUT events in the bus.
S * |        |          |0 = No USB event occurred.
S * |        |          |1 = USB event occurred, check EPSTS0~7 to know which kind of USB event occurred.
S * |        |          |Cleared by write 1 to USB_INTSTS[1] or EPEVT0~7 and SETUP (USB_INTSTS[31]).
S * |[2]     |FLDET_STS |Floating Detection Interrupt Status
S * |        |          |0 = There is not attached/detached event in the USB.
S * |        |          |1 = There is attached/detached event in the USB bus and it is cleared by write 1 to
S * |        |          |USB_INTSTS[2].
S * |[3]     |WAKEUP_STS|Wake-Up Interrupt Status
S * |        |          |0 = No Wake-up event occurred.
S * |        |          |1 = Wake-up event occurred, cleared by write 1 to USB_INTSTS[3].
S * |[16]    |EPEVT0    |Endpoint 0's USB Event Status
S * |        |          |0 = No event occurred on endpoint 0.
S * |        |          |1 = USB event occurred on Endpoint 0, check USB_EPSTS[10:8] to know which kind of USB event was
S * |        |          |occurred, cleared by write 1 to USB_INTSTS[16] or USB_INTSTS[1].
S * |[17]    |EPEVT1    |Endpoint 1's USB Event Status
S * |        |          |0 = No event occurred on endpoint 1.
S * |        |          |1 = USB event occurred on Endpoint 1, check USB_EPSTS[13:11] to know which kind of USB event was
S * |        |          |occurred, cleared by write 1 to USB_INTSTS[17] or USB_INTSTS[1].
S * |[18]    |EPEVT2    |Endpoint 2's USB Event Status
S * |        |          |0 = No event occurred on endpoint 2.
S * |        |          |1 = USB event occurred on Endpoint 2, check USB_EPSTS[16:14] to know which kind of USB event was
S * |        |          |occurred, cleared by write 1 to USB_INTSTS[18] or USB_INTSTS[1].
S * |[19]    |EPEVT3    |Endpoint 3's USB Event Status
S * |        |          |0 = No event occurred on endpoint 3.
S * |        |          |1 = USB event occurred on Endpoint 3, check USB_EPSTS[19:17] to know which kind of USB event was
S * |        |          |occurred, cleared by write 1 to USB_INTSTS[19] or USB_INTSTS[1].
S * |[20]    |EPEVT4    |Endpoint 4's USB Event Status
S * |        |          |0 = No event occurred on endpoint 4.
S * |        |          |1 = USB event occurred on Endpoint 4, check USB_EPSTS[22:20] to know which kind of USB event was
S * |        |          |occurred, cleared by write 1 to USB_INTSTS[20] or USB_INTSTS[1].
S * |[21]    |EPEVT5    |Endpoint 5's USB Event Status
S * |        |          |0 = No event occurred on endpoint 5.
S * |        |          |1 = USB event occurred on Endpoint 5, check USB_EPSTS[25:23] to know which kind of USB event was
S * |        |          |occurred, cleared by write 1 to USB_INTSTS[21] or USB_INTSTS[1].
S * |[22]    |EPEVT6    |Endpoint 6's USB Event Status
S * |        |          |0 = No event occurred on endpoint 6.
S * |        |          |1 = USB event occurred on Endpoint 6, check USB_EPSTS[28:26] to know which kind of USB event was
S * |        |          |occurred, cleared by write 1 to USB_INTSTS[22] or USB_INTSTS[1].
S * |[23]    |EPEVT7    |Endpoint 7's USB Event Status
S * |        |          |0 = No event occurred on endpoint 7.
S * |        |          |1 = USB event occurred on Endpoint 7, check USB_EPSTS[31:29] to know which kind of USB event was
S * |        |          |occurred, cleared by write 1 to USB_INTSTS[23] or USB_INTSTS[1].
S * |[31]    |SETUP     |Setup Event Status
S * |        |          |0 = No Setup event.
S * |        |          |1 = SETUP event occurred, cleared by write 1 to USB_INTSTS[31].
S * @var USBD_T::FADDR
S * Offset: 0x08  USB Device Function Address Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[6:0]   |FADDR     |USB Device Function Address
S * @var USBD_T::EPSTS
S * Offset: 0x0C  USB Endpoint Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[7]     |OVERRUN   |Overrun
S * |        |          |It indicates that the received data is over the maximum payload number or not.
S * |        |          |0 = No overrun.
S * |        |          |1 = Out Data is more than the Max Payload in MXPLD register or the Setup Data is more than 8
S * |        |          |Bytes.
S * |[10:8]  |EPSTS0    |Endpoint 0 Bus Status
S * |        |          |These bits are used to indicate the current status of this endpoint
S * |        |          |000 = In ACK.
S * |        |          |001 = In NAK.
S * |        |          |010 = Out Packet Data0 ACK.
S * |        |          |110 = Out Packet Data1 ACK.
S * |        |          |011 = Setup ACK.
S * |        |          |111 = Isochronous transfer end.
S * |[13:11] |EPSTS1    |Endpoint 1 Bus Status
S * |        |          |These bits are used to indicate the current status of this endpoint
S * |        |          |000 = In ACK.
S * |        |          |001 = In NAK.
S * |        |          |010 = Out Packet Data0 ACK.
S * |        |          |110 = Out Packet Data1 ACK.
S * |        |          |011 = Setup ACK.
S * |        |          |111 = Isochronous transfer end.
S * |[16:14] |EPSTS2    |Endpoint 2 Bus Status
S * |        |          |These bits are used to indicate the current status of this endpoint
S * |        |          |000 = In ACK.
S * |        |          |001 = In NAK.
S * |        |          |010 = Out Packet Data0 ACK.
S * |        |          |110 = Out Packet Data1 ACK.
S * |        |          |011 = Setup ACK.
S * |        |          |111 = Isochronous transfer end.
S * |[19:17] |EPSTS3    |Endpoint 3 Bus Status
S * |        |          |These bits are used to indicate the current status of this endpoint
S * |        |          |000 = In ACK.
S * |        |          |001 = In NAK.
S * |        |          |010 = Out Packet Data0 ACK.
S * |        |          |110 = Out Packet Data1 ACK.
S * |        |          |011 = Setup ACK.
S * |        |          |111 = Isochronous transfer end.
S * |[22:20] |EPSTS4    |Endpoint 4 Bus Status
S * |        |          |These bits are used to indicate the current status of this endpoint
S * |        |          |000 = In ACK.
S * |        |          |001 = In NAK.
S * |        |          |010 = Out Packet Data0 ACK.
S * |        |          |110 = Out Packet Data1 ACK.
S * |        |          |011 = Setup ACK.
S * |        |          |111 = Isochronous transfer end.
S * |[25:23] |EPSTS5    |Endpoint 5 Bus Status
S * |        |          |These bits are used to indicate the current status of this endpoint
S * |        |          |000 = In ACK.
S * |        |          |001 = In NAK.
S * |        |          |010 = Out Packet Data0 ACK.
S * |        |          |110 = Out Packet Data1 ACK.
S * |        |          |011 = Setup ACK.
S * |        |          |111 = Isochronous transfer end.
S * |[28:26] |EPSTS6    |Endpoint 6 Bus Status
S * |        |          |These bits are used to indicate the current status of this endpoint
S * |        |          |000 = In ACK.
S * |        |          |001 = In NAK.
S * |        |          |010 = Out Packet Data0 ACK.
S * |        |          |110 = Out Packet Data1 ACK.
S * |        |          |011 = Setup ACK.
S * |        |          |111 = Isochronous transfer end.
S * |[31:29] |EPSTS7    |Endpoint 7 Bus Status
S * |        |          |These bits are used to indicate the current status of this endpoint
S * |        |          |000 = In ACK.
S * |        |          |001 = In NAK.
S * |        |          |010 = Out Packet Data0 ACK.
S * |        |          |110 = Out Packet Data1 ACK.
S * |        |          |011 = Setup ACK.
S * |        |          |111 = Isochronous transfer end.
S * @var USBD_T::ATTR
S * Offset: 0x10  USB Bus Status and Attribution Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |USBRST    |USB Reset Status
S * |        |          |0 = Bus no reset.
S * |        |          |1 = Bus reset when SE0 (single-ended 0) is presented more than 2.5us.
S * |        |          |Note: This bit is read only.
S * |[1]     |SUSPEND   |Suspend Status
S * |        |          |0 = Bus no suspend.
S * |        |          |1 = Bus idle more than 3ms, either cable is plugged off or host is sleeping.
S * |        |          |Note: This bit is read only.
S * |[2]     |RESUME    |Resume Status
S * |        |          |0 = No bus resume.
S * |        |          |1 = Resume from suspend.
S * |        |          |Note: This bit is read only.
S * |[3]     |TIMEOUT   |Time-Out Status
S * |        |          |0 = No time-out.
S * |        |          |1 = No Bus response more than 18 bits time.
S * |        |          |Note: This bit is read only.
S * |[4]     |PHY_EN    |PHY Transceiver Function Enable
S * |        |          |0 = PHY transceiver function Disabled.
S * |        |          |1 = PHY transceiver function Enabled.
S * |[5]     |RWAKEUP   |Remote Wake-Up
S * |        |          |0 = Release the USB bus from K state.
S * |        |          |1 = Force USB bus to K (USB_D+ low, USB_D- high) state, used for remote wake-up.
S * |[7]     |USB_EN    |USB Controller Enable
S * |        |          |0 = USB Controller Disabled.
S * |        |          |1 = USB Controller Enabled.
S * |[8]     |DPPU_EN   |Pull-Up Resistor On USB_D+ Enable
S * |        |          |0 = Pull-up resistor in USB_D+ pin Disabled.
S * |        |          |1 = Pull-up resistor in USB_D+ pin Enabled.
S * |[9]     |PWRDN     |Power-Down PHY Transceiver, Low Active
S * |        |          |0 = Power-down related circuit of PHY transceiver.
S * |        |          |1 = Turn-on related circuit of PHY transceiver.
S * |[10]    |BYTEM     |CPU Access USB SRAM Size Mode Selection
S * |        |          |0 = Word mode: The size of the transfer from CPU to USB SRAM can be Word only.
S * |        |          |1 = Byte mode: The size of the transfer from CPU to USB SRAM can be Byte only.
S * @var USBD_T::FLDET
S * Offset: 0x14  USB Floating Detection Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |FLDET     |Device Floating Detected
S * |        |          |0 = Controller is not attached into the USB host.
S * |        |          |1 =Controller is attached into the BUS.
S * @var USBD_T::STBUFSEG
S * Offset: 0x18  Setup Token Buffer Segmentation Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[8:3]   |STBUFSEG  |Setup Token Buffer Segmentation
S * |        |          |It is used to indicate the offset address for the SETUP token with the USB Device SRAM starting
S * |        |          |address The effective starting address is
S * |        |          |USB_SRAM address + {STBUFSEG[8:3], 3'b000}
S * |        |          |Where the USB_SRAM address = USBD_BA+0x100h.
S * |        |          |Note: It is used for SETUP token only.
S * @var USBD_T::DRVSE0
S * Offset: 0x90  USB Drive SE0 Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |DRVSE0    |Drive Single Ended Zero In USB Bus
S * |        |          |The Single Ended Zero (SE0) is when both lines (USB_D+ and USB_D-) are being pulled low.
S * |        |          |0 = None.
S * |        |          |1 = Force USB PHY transceiver to drive SE0.
S */
S
S    __IO uint32_t INTEN;         /* Offset: 0x00  USB Interrupt Enable Register                                      */
S    __IO uint32_t INTSTS;        /* Offset: 0x04  USB Interrupt Event Status Register                                */
S    __IO uint32_t FADDR;         /* Offset: 0x08  USB Device Function Address Register                               */
S    __I  uint32_t EPSTS;         /* Offset: 0x0C  USB Endpoint Status Register                                       */
S    __IO uint32_t ATTR;          /* Offset: 0x10  USB Bus Status and Attribution Register                            */
S    __I  uint32_t FLDET;         /* Offset: 0x14  USB Floating Detection Register                                    */
S    __IO uint32_t STBUFSEG;      /* Offset: 0x18  Setup Token Buffer Segmentation Register                           */
S    __I  uint32_t RESERVE1[29];  
S    __IO uint32_t DRVSE0;        /* Offset: 0x90  USB Drive SE0 Control Register                                     */
S    __I  uint32_t RESERVE2[283];
S        USBD_EP_T EP[8];         /* Offset: 0x500 Endpoint 0~7 Control Registers                                     */
S
S} USBD_T;
S
S
S/**
S    @addtogroup USBD_CONST USBD Bit Field Definition
S    Constant Definitions for USBD Controller
S@{ */
S
S
S/* USBD INTEN Bit Field Definitions */
S#define USBD_INTEN_INNAK_EN_Pos    15                                    /*!< USBD_T::INTEN: INNAK_EN Position */
S#define USBD_INTEN_INNAK_EN_Msk    (1ul << USBD_INTEN_INNAK_EN_Pos)      /*!< USBD_T::INTEN: INNAK_EN Mask */
S
S#define USBD_INTEN_WAKEUP_EN_Pos   8                                     /*!< USBD_T::INTEN: RWAKEUP Position */
S#define USBD_INTEN_WAKEUP_EN_Msk   (1ul << USBD_INTEN_WAKEUP_EN_Pos)     /*!< USBD_T::INTEN: RWAKEUP Mask */
S
S#define USBD_INTEN_WAKEUP_IE_Pos   3                                     /*!< USBD_T::INTEN: WAKEUP_IE Position */
S#define USBD_INTEN_WAKEUP_IE_Msk   (1ul << USBD_INTEN_WAKEUP_IE_Pos)     /*!< USBD_T::INTEN: WAKEUP_IE Mask */
S
S#define USBD_INTEN_FLDET_IE_Pos    2                                     /*!< USBD_T::INTEN: FLDET_IE Position */
S#define USBD_INTEN_FLDET_IE_Msk    (1ul << USBD_INTEN_FLDET_IE_Pos)      /*!< USBD_T::INTEN: FLDET_IE Mask */
S
S#define USBD_INTEN_USB_IE_Pos      1                                     /*!< USBD_T::INTEN: USB_IE Position */
S#define USBD_INTEN_USB_IE_Msk      (1ul << USBD_INTEN_USB_IE_Pos)        /*!< USBD_T::INTEN: USB_IE Mask */
S
S#define USBD_INTEN_BUS_IE_Pos      0                                     /*!< USBD_T::INTEN: BUS_IE Position */
S#define USBD_INTEN_BUS_IE_Msk      (1ul << USBD_INTEN_BUS_IE_Pos)        /*!< USBD_T::INTEN: BUS_IE Mask */
S
S/* USBD INTSTS Bit Field Definitions */
S#define USBD_INTSTS_SETUP_Pos        31                                  /*!< USBD_T::INTSTS: SETUP Position */
S#define USBD_INTSTS_SETUP_Msk        (1ul << USBD_INTSTS_SETUP_Pos)      /*!< USBD_T::INTSTS: SETUP Mask */
S
S#define USBD_INTSTS_EPEVT7_Pos       23                                  /*!< USBD_T::INTSTS: EPEVT7 Position */
S#define USBD_INTSTS_EPEVT7_Msk       (0x1ul << USBD_INTSTS_EPEVT7_Pos)   /*!< USBD_T::INTSTS: EPEVT7 Mask     */
S
S#define USBD_INTSTS_EPEVT6_Pos       22                                  /*!< USBD_T::INTSTS: EPEVT6 Position */
S#define USBD_INTSTS_EPEVT6_Msk       (0x1ul << USBD_INTSTS_EPEVT6_Pos)   /*!< USBD_T::INTSTS: EPEVT6 Mask     */
S
S#define USBD_INTSTS_EPEVT5_Pos       21                                  /*!< USBD_T::INTSTS: EPEVT5 Position */
S#define USBD_INTSTS_EPEVT5_Msk       (0x1ul << USBD_INTSTS_EPEVT5_Pos)   /*!< USBD_T::INTSTS: EPEVT5 Mask     */
S
S#define USBD_INTSTS_EPEVT4_Pos       20                                  /*!< USBD_T::INTSTS: EPEVT4 Position */
S#define USBD_INTSTS_EPEVT4_Msk       (0x1ul << USBD_INTSTS_EPEVT4_Pos)   /*!< USBD_T::INTSTS: EPEVT4 Mask     */
S
S#define USBD_INTSTS_EPEVT3_Pos       19                                  /*!< USBD_T::INTSTS: EPEVT3 Position */
S#define USBD_INTSTS_EPEVT3_Msk       (0x1ul << USBD_INTSTS_EPEVT3_Pos)   /*!< USBD_T::INTSTS: EPEVT3 Mask     */
S
S#define USBD_INTSTS_EPEVT2_Pos       18                                  /*!< USBD_T::INTSTS: EPEVT2 Position */
S#define USBD_INTSTS_EPEVT2_Msk       (0x1ul << USBD_INTSTS_EPEVT2_Pos)   /*!< USBD_T::INTSTS: EPEVT2 Mask     */
S
S#define USBD_INTSTS_EPEVT1_Pos       17                                  /*!< USBD_T::INTSTS: EPEVT1 Position */
S#define USBD_INTSTS_EPEVT1_Msk       (0x1ul << USBD_INTSTS_EPEVT1_Pos)   /*!< USBD_T::INTSTS: EPEVT1 Mask     */
S
S#define USBD_INTSTS_EPEVT0_Pos       16                                  /*!< USBD_T::INTSTS: EPEVT0 Position */
S#define USBD_INTSTS_EPEVT0_Msk       (0x1ul << USBD_INTSTS_EPEVT0_Pos)   /*!< USBD_T::INTSTS: EPEVT0 Mask     */
S
S#define USBD_INTSTS_WAKEUP_STS_Pos   3                                   /*!< USBD_T::INTSTS: WAKEUP_STS Position */
S#define USBD_INTSTS_WAKEUP_STS_Msk   (1ul << USBD_INTSTS_WAKEUP_STS_Pos) /*!< USBD_T::INTSTS: WAKEUP_STS Mask */
S
S#define USBD_INTSTS_FLDET_STS_Pos    2                                   /*!< USBD_T::INTSTS: FLDET_STS Position */
S#define USBD_INTSTS_FLDET_STS_Msk    (1ul << USBD_INTSTS_FLDET_STS_Pos)  /*!< USBD_T::INTSTS: FLDET_STS Mask */
S
S#define USBD_INTSTS_USB_STS_Pos      1                                   /*!< USBD_T::INTSTS: USB_STS Position */
S#define USBD_INTSTS_USB_STS_Msk      (1ul << USBD_INTSTS_USB_STS_Pos)    /*!< USBD_T::INTSTS: USB_STS Mask */
S
S#define USBD_INTSTS_BUS_STS_Pos      0                                   /*!< USBD_T::INTSTS: BUS_STS Position */
S#define USBD_INTSTS_BUS_STS_Msk      (1ul << USBD_INTSTS_BUS_STS_Pos)    /*!< USBD_T::INTSTS: BUS_STS Mask */
S
S/* USBD FADDR Bit Field Definitions */
S#define USBD_FADDR_FADDR_Pos     0                                       /*!< USBD_T::FADDR: FADDR Position */
S#define USBD_FADDR_FADDR_Msk     (0x7Ful << USBD_FADDR_FADDR_Pos)        /*!< USBD_T::FADDR: FADDR Mask */
S
S/* USBD EPSTS Bit Field Definitions */
S#define USBD_EPSTS_EPSTS5_Pos    23                                      /*!< USBD_T::EPSTS: EPSTS5 Position */
S#define USBD_EPSTS_EPSTS5_Msk    (7ul << USBD_EPSTS_EPSTS5_Pos)          /*!< USBD_T::EPSTS: EPSTS5 Mask */
S
S#define USBD_EPSTS_EPSTS4_Pos    20                                      /*!< USBD_T::EPSTS: EPSTS4 Position */
S#define USBD_EPSTS_EPSTS4_Msk    (7ul << USBD_EPSTS_EPSTS4_Pos)          /*!< USBD_T::EPSTS: EPSTS5 Mask */
S
S#define USBD_EPSTS_EPSTS3_Pos    17                                      /*!< USBD_T::EPSTS: EPSTS3 Position */
S#define USBD_EPSTS_EPSTS3_Msk    (7ul << USBD_EPSTS_EPSTS3_Pos)          /*!< USBD_T::EPSTS: EPSTS3 Mask */
S
S#define USBD_EPSTS_EPSTS2_Pos    14                                      /*!< USBD_T::EPSTS: EPSTS2 Position */
S#define USBD_EPSTS_EPSTS2_Msk    (7ul << USBD_EPSTS_EPSTS2_Pos)          /*!< USBD_T::EPSTS: EPSTS2 Mask */
S
S#define USBD_EPSTS_EPSTS1_Pos    11                                      /*!< USBD_T::EPSTS: EPSTS1 Position */
S#define USBD_EPSTS_EPSTS1_Msk    (7ul << USBD_EPSTS_EPSTS1_Pos)          /*!< USBD_T::EPSTS: EPSTS1 Mask */
S
S#define USBD_EPSTS_EPSTS0_Pos    8                                       /*!< USBD_T::EPSTS: EPSTS0 Position */
S#define USBD_EPSTS_EPSTS0_Msk    (7ul << USBD_EPSTS_EPSTS0_Pos)          /*!< USBD_T::EPSTS: EPSTS0 Mask */
S
S#define USBD_EPSTS_OVERRUN_Pos   7                                       /*!< USBD_T::EPSTS: OVERRUN Position */
S#define USBD_EPSTS_OVERRUN_Msk   (1ul << USBD_EPSTS_OVERRUN_Pos)         /*!< USBD_T::EPSTS: OVERRUN Mask */
S
S/* USBD ATTR Bit Field Definitions */
S#define USBD_ATTR_BYTEM_Pos      10                                      /*!< USBD_T::ATTR: BYTEM Position */
S#define USBD_ATTR_BYTEM_Msk      (1ul << USBD_ATTR_BYTEM_Pos)            /*!< USBD_T::ATTR: BYTEM Mask */
S
S#define USBD_ATTR_PWRDN_Pos      9                                       /*!< USBD_T::ATTR: PWRDN Position */
S#define USBD_ATTR_PWRDN_Msk      (1ul << USBD_ATTR_PWRDN_Pos)            /*!< USBD_T::ATTR: PWRDN Mask */
S
S#define USBD_ATTR_DPPU_EN_Pos    8                                       /*!< USBD_T::ATTR: DPPU_EN Position */
S#define USBD_ATTR_DPPU_EN_Msk    (1ul << USBD_ATTR_DPPU_EN_Pos)          /*!< USBD_T::ATTR: DPPU_EN Mask */
S
S#define USBD_ATTR_USB_EN_Pos     7                                       /*!< USBD_T::ATTR: USB_EN Position */
S#define USBD_ATTR_USB_EN_Msk     (1ul << USBD_ATTR_USB_EN_Pos)           /*!< USBD_T::ATTR: USB_EN Mask */
S
S#define USBD_ATTR_RWAKEUP_Pos    5                                       /*!< USBD_T::ATTR: RWAKEUP Position */
S#define USBD_ATTR_RWAKEUP_Msk    (1ul << USBD_ATTR_RWAKEUP_Pos)          /*!< USBD_T::ATTR: RWAKEUP Mask */
S
S#define USBD_ATTR_PHY_EN_Pos     4                                       /*!< USBD_T::ATTR: PHY_EN Position */
S#define USBD_ATTR_PHY_EN_Msk     (1ul << USBD_ATTR_PHY_EN_Pos)           /*!< USBD_T::ATTR: PHY_EN Mask */
S
S#define USBD_ATTR_TIMEOUT_Pos    3                                       /*!< USBD_T::ATTR: TIMEOUT Position */
S#define USBD_ATTR_TIMEOUT_Msk    (1ul << USBD_ATTR_TIMEOUT_Pos)          /*!< USBD_T::ATTR: TIMEOUT Mask */
S
S#define USBD_ATTR_RESUME_Pos     2                                       /*!< USBD_T::ATTR: RESUME Position */
S#define USBD_ATTR_RESUME_Msk     (1ul << USBD_ATTR_RESUME_Pos)           /*!< USBD_T::ATTR: RESUME Mask */
S
S#define USBD_ATTR_SUSPEND_Pos    1                                       /*!< USBD_T::ATTR: SUSPEND Position */
S#define USBD_ATTR_SUSPEND_Msk    (1ul << USBD_ATTR_SUSPEND_Pos)          /*!< USBD_T::ATTR: SUSPEND Mask */
S
S#define USBD_ATTR_USBRST_Pos     0                                       /*!< USBD_T::ATTR: USBRST Position */
S#define USBD_ATTR_USBRST_Msk     (1ul << USBD_ATTR_USBRST_Pos)           /*!< USBD_T::ATTR: USBRST Mask */
S
S/* USBD FLDET Bit Field Definitions */
S#define USBD_FLDET_FLDET_Pos     0                                       /*!< USBD_T::FLDET: FLDET Position */
S#define USBD_FLDET_FLDET_Msk     (1ul << USBD_FLDET_FLDET_Pos)           /*!< USBD_T::FLDET: FLDET Mask */
S
S/* USBD STBUFSEG Bit Field Definitions */
S#define USBD_STBUFSEG_STBUFSEG_Pos   3                                        /*!< USBD_T::STBUFSEG: STBUFSEG Position */
S#define USBD_STBUFSEG_STBUFSEG_Msk   (0x3Ful << USBD_STBUFSEG_STBUFSEG_Pos)   /*!< USBD_T::STBUFSEG: STBUFSEG Mask */
S
S/* USBD BUFSEG Bit Field Definitions */
S#define USBD_BUFSEG_BUFSEG_Pos   3                                       /*!< USBD_EP_T::BUFSEG: BUFSEG Position */
S#define USBD_BUFSEG_BUFSEG_Msk   (0x3Ful << USBD_BUFSEG_BUFSEG_Pos)      /*!< USBD_EP_T::BUFSEG: BUFSEG Mask */
S
S/* USBD MXPLD Bit Field Definitions */
S#define USBD_MXPLD_MXPLD_Pos    0                                        /*!< USBD_EP_T::MXPLD: MXPLD Position */
S#define USBD_MXPLD_MXPLD_Msk    (0x1FFul << USBD_MXPLD_MXPLD_Pos)        /*!< USBD_EP_T::MXPLD: MXPLD Mask */
S
S/* USBD CFG Bit Field Definitions */
S#define USBD_CFG_CSTALL_Pos     9                                        /*!< USBD_EP_T::CFG: CSTALL Position */
S#define USBD_CFG_CSTALL_Msk     (1ul << USBD_CFG_CSTALL_Pos)             /*!< USBD_EP_T::CFG: CSTALL Mask */
S
S#define USBD_CFG_DSQ_SYNC_Pos   7                                        /*!< USBD_EP_T::CFG: DSQ_SYNC Position */
S#define USBD_CFG_DSQ_SYNC_Msk   (1ul << USBD_CFG_DSQ_SYNC_Pos)           /*!< USBD_EP_T::CFG: DSQ_SYNC Mask */
S
S#define USBD_CFG_STATE_Pos      5                                        /*!< USBD_EP_T::CFG: STATE Position */
S#define USBD_CFG_STATE_Msk      (3ul << USBD_CFG_STATE_Pos)              /*!< USBD_EP_T::CFG: STATE Mask */
S
S#define USBD_CFG_ISOCH_Pos      4                                        /*!< USBD_EP_T::CFG: ISOCH Position */
S#define USBD_CFG_ISOCH_Msk      (1ul << USBD_CFG_ISOCH_Pos)              /*!< USBD_EP_T::CFG: ISOCH Mask */
S
S#define USBD_CFG_EP_NUM_Pos     0                                        /*!< USBD_EP_T::CFG: EP_NUM Position */
S#define USBD_CFG_EP_NUM_Msk     (0xFul << USBD_CFG_EP_NUM_Pos)           /*!< USBD_EP_T::CFG: EP_NUM Mask */
S
S/* USBD CFGP Bit Field Definitions */
S#define USBD_CFGP_SSTALL_Pos    1                                        /*!< USBD_EP_T::CFGP: SSTALL Position */
S#define USBD_CFGP_SSTALL_Msk    (1ul << USBD_CFGP_SSTALL_Pos)            /*!< USBD_EP_T::CFGP: SSTALL Mask */
S
S#define USBD_CFGP_CLRRDY_Pos    0                                        /*!< USBD_EP_T::CFGP: CLRRDY Position */
S#define USBD_CFGP_CLRRDY_Msk    (1ul << USBD_CFGP_CLRRDY_Pos)            /*!< USBD_EP_T::CFGP: CLRRDY Mask */
S
S/* USBD DRVSE0 Bit Field Definitions */
S#define USBD_DRVSE0_DRVSE0_Pos   0                                       /*!< USBD_T::DRVSE0: DRVSE0 Position */
S#define USBD_DRVSE0_DRVSE0_Msk   (1ul << USBD_DRVSE0_DRVSE0_Pos)         /*!< USBD_T::DRVSE0: DRVSE0 Mask */
S/*@}*/ /* end of group USBD_CONST */
S/*@}*/ /* end of group USBD */
S
S
S/*---------------------- Watch Dog Timer Controller -------------------------*/
S/**
S    @addtogroup WDT Watch Dog Timer Controller (WDT)
S    Memory Mapped Structure for WDT Controller
S@{ */
S
S
Stypedef struct
S{
S
S
S/**
S * @var WDT_T::WTCR
S * Offset: 0x00  Watchdog Timer Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |WTR       |Reset Watchdog Timer Up Counter (Write Protect)
S * |        |          |0 = No effect.
S * |        |          |1 = Reset the internal 18-bit WDT up counter value.
S * |        |          |Note: This bit will be automatically cleared by hardware.
S * |[1]     |WTRE      |Watchdog Timer Reset Enable (Write Protect)
S * |        |          |Setting this bit will enable the WDT time-out reset function if the WDT up counter value has not
S * |        |          |been cleared after the specific WDT reset delay period expires.
S * |        |          |0 = WDT time-out reset function Disabled.
S * |        |          |1 = WDT time-out reset function Enabled.
S * |[2]     |WTRF      |Watchdog Timer Time-out Reset Flag
S * |        |          |This bit indicates the system has been reset by WDT time-out reset or not.
S * |        |          |0 = WDT time-out reset did not occur.
S * |        |          |1 = WDT time-out reset occurred.
S * |        |          |Note: This bit is cleared by writing 1 to it.
S * |[3]     |WTIF      |Watchdog Timer Time-out Interrupt Flag
S * |        |          |This bit will set to 1 while WDT up counter value reaches the selected WDT time-out interval.
S * |        |          |0 = WDT time-out interrupt did not occur.
S * |        |          |1 = WDT time-out interrupt occurred.
S * |        |          |Note: This bit is cleared by writing 1 to it.
S * |[4]     |WTWKE     |Watchdog Timer Time-out Wake-Up Function Control
S * |        |          |(Write Protect)
S * |        |          |If this bit is set to 1, while WTIF is generated to 1 and WTIE enabled, the WDT time-out
S * |        |          |interrupt signal will generate a wake-up trigger event to chip.
S * |        |          |0 = Wake-up trigger event Disabled if WDT time-out interrupt signal generated.
S * |        |          |1 = Wake-up trigger event Enabled if WDT time-out interrupt signal generated.
S * |        |          |Note: Chip can be woken-up by WDT time-out interrupt signal generated only if WDT clock source
S * |        |          |is selected to 10 kHz oscillator.
S * |[5]     |WTWKF     |Watchdog Timer Time-out Wake-Up Flag
S * |        |          |This bit indicates the interrupt wake-up flag status of WDT.
S * |        |          |0 = WDT does not cause chip wake-up.
S * |        |          |1 = Chip wake-up from Idle or Power-down mode if WDT time-out interrupt signal generated.
S * |        |          |Note: This bit is cleared by writing 1 to it.
S * |[6]     |WTIE      |Watchdog Timer Time-out Interrupt Enable Control (Write Protect)
S * |        |          |If this bit is enabled, the WDT time-out interrupt signal is generated and inform to CPU.
S * |        |          |0 = WDT time-out interrupt Disabled.
S * |        |          |1 = WDT time-out interrupt Enabled.
S * |[7]     |WTE       |Watchdog Timer Enable Control (Write Protect)
S * |        |          |0 = WDT Disabled. (This action will reset the internal up counter value.)
S * |        |          |1 = WDT Enabled.
S * |        |          |Note: If CWDTEN (CONFIG0[31] Watchdog Enable) bit is set to 0, this bit is forced as 1 and
S * |        |          | user cannot change this bit to 0.
S * |[10:8]  |WTIS      |Watchdog Timer Time-out Interval Selection (Write Protect)
S * |        |          |These three bits select the time-out interval period for the WDT.
S * |        |          |000 = 24 *TWDT.
S * |        |          |001 = 26 * TWDT.
S * |        |          |010 = 28 * TWDT.
S * |        |          |011 = 210 * TWDT.
S * |        |          |100 = 212 * TWDT.
S * |        |          |101 = 214 * TWDT.
S * |        |          |110 = 216 * TWDT.
S * |        |          |111 = 218 * TWDT.
S * |[31]    |DBGACK_WDT|ICE Debug Mode Acknowledge Disable Control (Write Protect)
S * |        |          |0 = ICE debug mode acknowledgement effects WDT counting.
S * |        |          |WDT up counter will be held while CPU is held by ICE.
S * |        |          |1 = ICE debug mode acknowledgement Disabled.
S * |        |          |WDT up counter will keep going no matter CPU is held by ICE or not.
S * @var WDT_T::WTCRALT
S * Offset: 0x04  Watchdog Timer Alternative Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[1:0]   |WTRDSEL   |Watchdog Timer Reset Delay Selection (Write Protect)
S * |        |          |When WDT time-out happened, user has a time named WDT Reset Delay Period to clear WDT counter to
S * |        |          |prevent WDT time-out reset happened.
S * |        |          |User can select a suitable value of WDT Reset Delay Period for different WDT time-out period.
S * |        |          |These bits are protected bit.
S * |        |          |It means programming this bit needs to write "59h", "16h", "88h" to address 0x5000_0100 to
S * |        |          |disable register protection.
S * |        |          |Reference the register REGWRPROT at address GCR_BA+0x100.
S * |        |          |00 = Watchdog Timer Reset Delay Period is 1026 * WDT_CLK.
S * |        |          |01 = Watchdog Timer Reset Delay Period is 130 * WDT_CLK.
S * |        |          |10 = Watchdog Timer Reset Delay Period is 18 * WDT_CLK.
S * |        |          |11 = Watchdog Timer Reset Delay Period is 3 * WDT_CLK.
S * |        |          |Note: This register will be reset to 0 if WDT time-out reset happened.
S */
S
S    __IO uint32_t WTCR;          /* Offset: 0x00  Watchdog Timer Control Register                                    */
S    __IO uint32_t WTCRALT;       /* Offset: 0x04  Watchdog Timer Alternative Control Register                        */
S
S} WDT_T;
S
S
S
S/**
S    @addtogroup WDT_CONST WDT Bit Field Definition
S    Constant Definitions for WDT Controller
S@{ */
S
S
S
S/* WDT WTCR Bit Field Definitions */
S#define WDT_WTCR_DBGACK_WDT_Pos 31                                              /*!< WDT_T::WTCR: DBGACK_WDT Position */
S#define WDT_WTCR_DBGACK_WDT_Msk (1ul << WDT_WTCR_DBGACK_WDT_Pos)                /*!< WDT_T::WTCR: DBGACK_WDT Mask */
S
S#define WDT_WTCR_WTIS_Pos       8                                               /*!< WDT_T::WTCR: WTIS Position */
S#define WDT_WTCR_WTIS_Msk       (0x7ul << WDT_WTCR_WTIS_Pos)                    /*!< WDT_T::WTCR: WTIS Mask */
S
S#define WDT_WTCR_WTE_Pos        7                                               /*!< WDT_T::WTCR: WTE Position */
S#define WDT_WTCR_WTE_Msk        (1ul << WDT_WTCR_WTE_Pos)                       /*!< WDT_T::WTCR: WTE Mask */
S
S#define WDT_WTCR_WTIE_Pos       6                                               /*!< WDT_T::WTCR: WTIE Position */
S#define WDT_WTCR_WTIE_Msk       (1ul << WDT_WTCR_WTIE_Pos)                      /*!< WDT_T::WTCR: WTIE Mask */
S
S#define WDT_WTCR_WTWKF_Pos      5                                               /*!< WDT_T::WTCR: WTWKF Position */
S#define WDT_WTCR_WTWKF_Msk      (1ul << WDT_WTCR_WTWKF_Pos)                     /*!< WDT_T::WTCR: WTWKF Mask */
S
S#define WDT_WTCR_WTWKE_Pos      4                                               /*!< WDT_T::WTCR: WTWKE Position */
S#define WDT_WTCR_WTWKE_Msk      (1ul << WDT_WTCR_WTWKE_Pos)                     /*!< WDT_T::WTCR: WTWKE Mask */
S
S#define WDT_WTCR_WTIF_Pos       3                                               /*!< WDT_T::WTCR: WTIF Position */
S#define WDT_WTCR_WTIF_Msk       (1ul << WDT_WTCR_WTIF_Pos)                      /*!< WDT_T::WTCR: WTIF Mask */
S
S#define WDT_WTCR_WTRF_Pos       2                                               /*!< WDT_T::WTCR: WTRF Position */
S#define WDT_WTCR_WTRF_Msk       (1ul << WDT_WTCR_WTRF_Pos)                      /*!< WDT_T::WTCR: WTRF Mask */
S
S#define WDT_WTCR_WTRE_Pos       1                                               /*!< WDT_T::WTCR: WTRE Position */
S#define WDT_WTCR_WTRE_Msk       (1ul << WDT_WTCR_WTRE_Pos)                      /*!< WDT_T::WTCR: WTRE Mask */
S
S#define WDT_WTCR_WTR_Pos        0                                               /*!< WDT_T::WTCR: WTR Position */
S#define WDT_WTCR_WTR_Msk        (1ul << WDT_WTCR_WTR_Pos)                       /*!< WDT_T::WTCR: WTR Mask */
S
S/* WDT WTCRALT Bit Field Definitions */
S#define WDT_WTCRALT_WTRDSEL_Pos 0                                               /*!< WDT_T::WTCRALT: WTRDSEL Position */
S#define WDT_WTCRALT_WTRDSEL_Msk (0x3ul << WDT_WTCRALT_WTRDSEL_Pos)              /*!< WDT_T::WTCRALT: WTRDSEL Mask */
S/*@}*/ /* end of group WDT_CONST */
S/*@}*/ /* end of group WDT */
S
S
S/*---------------------- Window Watchdog Timer -------------------------*/
S/**
S    @addtogroup WWDT Window Watchdog Timer (WWDT)
S    Memory Mapped Structure for WWDT Controller
S@{ */
S
S
Stypedef struct
S{
S
S
S/**
S * @var WWDT_T::WWDTRLD
S * Offset: 0x00  Window Watchdog Timer Reload Counter Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[31:0]  |WWDTRLD   |WWDT Reload Counter Register
S * |        |          |Writing 0x00005AA5 to this register will reload the WWDT counter value to 0x3F.
S * |        |          |Note: User can only write WWDTRLD to reload WWDT counter value when current WWDT
S * |        |          | counter value between 0 and WINCMP. If user writes WWDTRLD when current WWDT
S * |        |          | counter value is larger than WINCMP, WWDT reset signal will generate immediately.
S * @var WWDT_T::WWDTCR
S * Offset: 0x04  Window Watchdog Timer Control Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |WWDTEN    |WWDT Enable Control
S * |        |          |0 = WWDT counter is stopped.
S * |        |          |1 = WWDT counter is starting counting.
S * |[1]     |WWDTIE    |WWDT Interrupt Enable Control
S * |        |          |If this bit is enabled, the WWDT counter compare match interrupt signal is generated and inform
S * |        |          |to CPU.
S * |        |          |0 = WWDT counter compare match interrupt Disabled.
S * |        |          |1 = WWDT counter compare match interrupt Enabled.
S * |[11:8]  |PERIODSEL |WWDT Counter Prescale Period Selection
S * |        |          |0000 = Pre-scale is 1; Max time-out period is 1 * 64 * TWWDT.
S * |        |          |0001 = Pre-scale is 2; Max time-out period is 2 * 64 * TWWDT.
S * |        |          |0010 = Pre-scale is 4; Max time-out period is 4 * 64 * TWWDT.
S * |        |          |0011 = Pre-scale is 8; Max time-out period is 8 * 64 * TWWDT.
S * |        |          |0100 = Pre-scale is 16; Max time-out period is 16 * 64 * TWWDT.
S * |        |          |0101 = Pre-scale is 32; Max time-out period is 32 * 64 * TWWDT.
S * |        |          |0110 = Pre-scale is 64; Max time-out period is 64 * 64 * TWWDT.
S * |        |          |0111 = Pre-scale is 128; Max time-out period is 128 * 64 * TWWDT.
S * |        |          |1000 = Pre-scale is 192; Max time-out period is 192 * 64 * TWWDT.
S * |        |          |1001 = Pre-scale is 256; Max time-out period is 256 * 64 * TWWDT.
S * |        |          |1010 = Pre-scale is 384; Max time-out period is 384 * 64 * TWWDT.
S * |        |          |1011 = Pre-scale is 512; Max time-out period is 512 * 64 * TWWDT.
S * |        |          |1100 = Pre-scale is 768; Max time-out period is 768 * 64 * TWWDT.
S * |        |          |1101 = Pre-scale is 1024; Max time-out period is 1024 * 64 * TWWDT.
S * |        |          |1110 = Pre-scale is 1536; Max time-out period is 1536 * 64 * TWWDT.
S * |        |          |1111 = Pre-scale is 2048; Max time-out period is 2048 * 64 * TWWDT.
S * |[21:16] |WINCMP    |WWDT Window Compare Register
S * |        |          |Set this register to adjust the valid reload window.
S * |        |          |Note: User can only write WWDTRLD to reload WWDT counter value when current WWDT counter value
S * |        |          |between 0 and WINCMP.
S * |        |          |If user writes WWDTRLD when current WWDT counter value larger than WINCMP, WWDT reset signal
S * |        |          |will generate immediately.
S * |[31]    |DBGACK_WWDT|ICE Debug Mode Acknowledge Disable Control
S * |        |          |0 = ICE debug mode acknowledgement effects WWDT counting.
S * |        |          |WWDT down counter will be held while CPU is held by ICE.
S * |        |          |1 = ICE debug mode acknowledgement Disabled.
S * |        |          |WWDT down counter will keep going no matter CPU is held by ICE or not.
S * @var WWDT_T::WWDTSR
S * Offset: 0x08  Window Watchdog Timer Status Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[0]     |WWDTIF    |WWDT Compare Match Interrupt Flag
S * |        |          |This bit indicates the interrupt flag status of WWDT while WWDT counter value matches WINCMP
S * |        |          |value.
S * |        |          |0 = No effect.
S * |        |          |1 = WWDT counter value matches WINCMP value.
S * |        |          |Note: This bit is cleared by writing 1 to it.
S * |[1]     |WWDTRF    |WWDT Time-out Reset Flag
S * |        |          |This bit indicates the system has been reset by WWDT time-out reset or not.
S * |        |          |0 = WWDT time-out reset did not occur.
S * |        |          |1 = WWDT time-out reset occurred.
S * |        |          |Note: This bit is cleared by writing 1 to it.
S * @var WWDT_T::WWDTCVR
S * Offset: 0x0C  Window Watchdog Timer Counter Value Register
S * ---------------------------------------------------------------------------------------------------
S * |Bits    |Field     |Descriptions
S * | :----: | :----:   | :---- |
S * |[5:0]   |WWDTCVAL  |WWDT Counter Value
S * |        |          |WWDTCVAL will be updated continuously to monitor 6-bit down counter value.
S */
S
S    __IO uint32_t WWDTRLD;       /* Offset: 0x00  Window Watchdog Timer Reload Counter Register                      */
S    __IO uint32_t WWDTCR;        /* Offset: 0x04  Window Watchdog Timer Control Register                             */
S    __IO uint32_t WWDTSR;        /* Offset: 0x08  Window Watchdog Timer Status Register                              */
S    __I  uint32_t WWDTCVR;       /* Offset: 0x0C  Window Watchdog Timer Counter Value Register                       */
S
S} WWDT_T;
S
S
S/**
S    @addtogroup WWDT_CONST WWDT Bit Field Definition
S    Constant Definitions for WWDT Controller
S@{ */
S
S
S
S/* WWDT WWDTRLD Bit Field Definitions */
S#define WWDT_WWDTRLD_WWDTRLD_Pos    0                                           /*!< WWDT_T::WWDTRLD: WWDTRLD Position */
S#define WWDT_WWDTRLD_WWDTRLD_Msk    (0xFFFFFFFFul << WWDT_WWDTRLD_WWDTRLD_Pos)  /*!< WWDT_T::WWDTRLD: WWDTRLD Mask */
S
S/* WWDT WWDTCR Bit Field Definitions */
S#define WWDT_WWDTCR_DBGACK_WWDT_Pos 31                                          /*!< WWDT_T::WWDTCR: DBGACK_WWDT Position */
S#define WWDT_WWDTCR_DBGACK_WWDT_Msk (1ul << WWDT_WWDTCR_DBGACK_WWDT_Pos)        /*!< WWDT_T::WWDTCR: DBGACK_WWDT Mask */
S
S#define WWDT_WWDTCR_WINCMP_Pos      16                                          /*!< WWDT_T::WWDTCR: WINCMP Position */
S#define WWDT_WWDTCR_WINCMP_Msk      (0x3Ful << WWDT_WWDTCR_WINCMP_Pos)          /*!< WWDT_T::WWDTCR: WINCMP Mask */
S
S#define WWDT_WWDTCR_PERIODSEL_Pos   8                                           /*!< WWDT_T::WWDTCR: PERIODSEL Position */
S#define WWDT_WWDTCR_PERIODSEL_Msk   (0xFul << WWDT_WWDTCR_PERIODSEL_Pos)        /*!< WWDT_T::WWDTCR: PERIODSEL Mask */
S
S#define WWDT_WWDTCR_WWDTIE_Pos      1                                           /*!< WWDT_T::WWDTCR: WWDTIE Position */
S#define WWDT_WWDTCR_WWDTIE_Msk      (1ul << WWDT_WWDTCR_WWDTIE_Pos)             /*!< WWDT_T::WWDTCR: WWDTIE Mask */
S
S#define WWDT_WWDTCR_WWDTEN_Pos      0                                           /*!< WWDT_T::WWDTCR: WWDTEN Position */
S#define WWDT_WWDTCR_WWDTEN_Msk      (1ul << WWDT_WWDTCR_WWDTEN_Pos)             /*!< WWDT_T::WWDTCR: WWDTEN Mask */
S
S/* WWDT WWDTSR Bit Field Definitions */
S#define WWDT_WWDTSR_WWDTRF_Pos      1                                           /*!< WWDT_T::WWDTSR: WWDTRF Position */
S#define WWDT_WWDTSR_WWDTRF_Msk      (1ul << WWDT_WWDTSR_WWDTRF_Pos)             /*!< WWDT_T::WWDTSR: WWDTRF Mask */
S
S#define WWDT_WWDTSR_WWDTIF_Pos      0                                           /*!< WWDT_T::WWDTSR: WWDTIF Position */
S#define WWDT_WWDTSR_WWDTIF_Msk      (1ul << WWDT_WWDTSR_WWDTIF_Pos)             /*!< WWDT_T::WWDTSR: WWDTIF Mask */
S
S/* WWDT WWDTCVR Bit Field Definitions */
S#define WWDT_WWDTCVR_WWDTCVAL_Pos   0                                           /*!< WWDT_T::WWDTCVR: WWDTCVAL Position */
S#define WWDT_WWDTCVR_WWDTCVAL_Msk   (0x3Ful << WWDT_WWDTCVR_WWDTCVAL_Pos)       /*!< WWDT_T::WWDTCVR: WWDTCVAL Mask */
S/*@}*/ /* end of group WWDT_CONST */
S/*@}*/ /* end of group WWDT */
S/*@}*/ /* end of group */
S
S
S/******************************************************************************/
S/*                         Peripheral memory map                              */
S/******************************************************************************/
S/** @addtogroup PERIPHERAL_MEM_MAP Peripheral Memory Map
S  Memory Mapped Structure for Peripheral
S  @{
S */
S/* Peripheral and SRAM base address */
S#define FLASH_BASE          ((     uint32_t)0x00000000)
S#define SRAM_BASE           ((     uint32_t)0x20000000)
S#define AHB_BASE            ((     uint32_t)0x50000000)
S#define APB1_BASE           ((     uint32_t)0x40000000)
S#define APB2_BASE           ((     uint32_t)0x40100000)
S
S/* Peripheral memory map */
S#define GPIO_BASE           (AHB_BASE        + 0x4000)                   /*!< GPIO Base Address                                   */
S#define PA_BASE             (GPIO_BASE               )                   /*!< GPIO PORTA Base Address                             */
S#define PB_BASE             (GPIO_BASE       + 0x0040)                   /*!< GPIO PORTB Base Address                             */
S#define PC_BASE             (GPIO_BASE       + 0x0080)                   /*!< GPIO PORTC Base Address                             */
S#define PD_BASE             (GPIO_BASE       + 0x00C0)                   /*!< GPIO PORTD Base Address                             */
S#define PE_BASE             (GPIO_BASE       + 0x0100)                   /*!< GPIO PORTE Base Address                             */
S#define PF_BASE             (GPIO_BASE       + 0x0140)                   /*!< GPIO PORTF Base Address                             */
S#define GPIO_DBNCECON_BASE  (GPIO_BASE       + 0x0180)                   /*!< GPIO De-bounce Cycle Control Base Address           */
S#define GPIO_PIN_DATA_BASE  (GPIO_BASE       + 0x0200)                   /*!< GPIO Pin Data Input/Output Control Base Address     */
S
S
S#define UART0_BASE           (APB1_BASE      + 0x50000)
S#define UART1_BASE           (APB2_BASE      + 0x50000)
S#define UART2_BASE           (APB2_BASE      + 0x54000)
S
S
S#define TIMER0_BASE          (APB1_BASE      + 0x10000)                 /*!< Timer0 Base Address                              */
S#define TIMER1_BASE          (APB1_BASE      + 0x10020)                 /*!< Timer1 Base Address                              */
S#define TIMER2_BASE          (APB2_BASE      + 0x10000)                 /*!< Timer2 Base Address                              */
S#define TIMER3_BASE          (APB2_BASE      + 0x10020)                 /*!< Timer3 Base Address                              */
S
S#define WDT_BASE             (APB1_BASE      + 0x4000)                  /*!< Watchdog Timer Base Address                      */
S
S#define WWDT_BASE            (APB1_BASE      + 0x4100)                  /*!< Window Watchdog Timer Base Address               */
S
S#define SPI0_BASE            (APB1_BASE      + 0x30000)                 /*!< SPI0 Base Address                                */
S#define SPI1_BASE            (APB1_BASE      + 0x34000)                 /*!< SPI1 Base Address                                */
S#define SPI2_BASE            (APB2_BASE      + 0x30000)                 /*!< SPI2 Base Address                                */
S#define SPI3_BASE            (APB2_BASE      + 0x34000)                 /*!< SPI3 Base Address                                */
S
S#define I2C0_BASE            (APB1_BASE      + 0x20000)                 /*!< I2C0 Base Address                                */
S#define I2C1_BASE            (APB2_BASE      + 0x20000)                 /*!< I2C1 Base Address                                */
S
S#define RTC_BASE             (APB1_BASE      + 0x08000)                 /*!< RTC Base Address                                 */
S
S#define ADC_BASE             (APB1_BASE      + 0xE0000)                 /*!< ADC Base Address                                 */
S
S#define ACMP_BASE            (APB1_BASE      + 0xD0000)                 /*!< ACMP Base Address                                */
S
S#define CLK_BASE             (AHB_BASE       + 0x00200)                 /*!< System Clock Controller Base Address             */
S
S#define GCR_BASE             (AHB_BASE       + 0x00000)                 /*!< System Global Controller Base Address            */
S
S#define INT_BASE             (AHB_BASE       + 0x00300)                 /*!< Interrupt Source Controller Base Address         */
S
S#define FMC_BASE             (AHB_BASE       + 0x0C000)
S
S#define PS2_BASE             (APB2_BASE      + 0x00000)                 /*!< PS/2 Base Address                                */
S
S#define CAN0_BASE            (APB2_BASE      + 0x80000)                 /*!< CAN0 Base Address                                */
S#define CAN1_BASE            (APB2_BASE      + 0x84000)                 /*!< CAN1 Base Address                                */
S
S#define USBD_BASE            (APB1_BASE      + 0x60000)                 /*!< USBD Base Address                                */
S
S#define PDMA0_BASE           (AHB_BASE       + 0x08000)                 /*!< PDMA0 Base Address                               */
S#define PDMA1_BASE           (AHB_BASE       + 0x08100)                 /*!< PDMA1 Base Address                               */
S#define PDMA2_BASE           (AHB_BASE       + 0x08200)                 /*!< PDMA2 Base Address                               */
S#define PDMA3_BASE           (AHB_BASE       + 0x08300)                 /*!< PDMA3 Base Address                               */
S#define PDMA4_BASE           (AHB_BASE       + 0x08400)                 /*!< PDMA4 Base Address                               */
S#define PDMA5_BASE           (AHB_BASE       + 0x08500)                 /*!< PDMA5 Base Address                               */
S#define PDMA6_BASE           (AHB_BASE       + 0x08600)                 /*!< PDMA6 Base Address                               */
S#define PDMA7_BASE           (AHB_BASE       + 0x08700)                 /*!< PDMA7 Base Address                               */
S#define PDMA8_BASE           (AHB_BASE       + 0x08800)                 /*!< PDMA8 Base Address                               */
S
S#define PDMA_GCR_BASE        (AHB_BASE       + 0x08F00)                 /*!< PDMA Grobal Base Address                         */
S
S#define CRC_BASE             (AHB_BASE       + 0x08E00)                 /*!< CRC Base Address                                 */
S
S#define PWMA_BASE            (APB1_BASE      + 0x40000)                 /*!< PWMA Base Address                                */
S#define PWMB_BASE            (APB2_BASE      + 0x40000)                 /*!< PWMB Base Address                                */
S
S#define SC0_BASE             (APB2_BASE      + 0x90000)                 /*!< SC0 Base Address                                 */
S#define SC1_BASE             (APB2_BASE      + 0x94000)                 /*!< SC1 Base Address                                 */
S#define SC2_BASE             (APB2_BASE      + 0x98000)                 /*!< SC2 Base Address                                 */
S
S#define I2S_BASE             (APB2_BASE      + 0xA0000)                 /*!< I2S Base Address                                 */
S
S#define EBI_BASE             (AHB_BASE       + 0x10000)                 /*!< EBI Base Address                                 */
S/*@}*/ /* end of group PERIPHERAL_MEM_MAP */
S
S/******************************************************************************/
S/*                         Peripheral Definitions                             */
S/******************************************************************************/
S
S/** @addtogroup PERIPHERAL Peripheral Definitions
S  The Definitions of Peripheral
S  @{
S */
S#define PA                  ((GPIO_T *) PA_BASE)                        /*!< GPIO PORTA Configuration Struct                        */
S#define PB                  ((GPIO_T *) PB_BASE)                        /*!< GPIO PORTB Configuration Struct                        */
S#define PC                  ((GPIO_T *) PC_BASE)                        /*!< GPIO PORTC Configuration Struct                        */
S#define PD                  ((GPIO_T *) PD_BASE)                        /*!< GPIO PORTD Configuration Struct                        */
S#define PE                  ((GPIO_T *) PE_BASE)                        /*!< GPIO PORTE Configuration Struct                        */
S#define PF                  ((GPIO_T *) PF_BASE)                        /*!< GPIO PORTF Configuration Struct                        */
S#define GPIO                ((GPIO_DBNCECON_T *) GPIO_DBNCECON_BASE)    /*!< Interrupt De-bounce Cycle Control Configuration Struct */
S
S#define UART0               ((UART_T *) UART0_BASE)
S#define UART1               ((UART_T *) UART1_BASE)
S#define UART2               ((UART_T *) UART2_BASE)
S
S#define TIMER0              ((TIMER_T *) TIMER0_BASE)                   /*!< Timer0 Configuration Struct                      */
S#define TIMER1              ((TIMER_T *) TIMER1_BASE)                   /*!< Timer1 Configuration Struct                      */
S#define TIMER2              ((TIMER_T *) TIMER2_BASE)                   /*!< Timer2 Configuration Struct                      */
S#define TIMER3              ((TIMER_T *) TIMER3_BASE)                   /*!< Timer3 Configuration Struct                      */
S
S#define WDT                 ((WDT_T *) WDT_BASE)                        /*!< Watchdog Timer Configuration Struct              */
S
S#define WWDT                ((WWDT_T *) WWDT_BASE)                      /*!< Window Watchdog Timer Configuration Struct       */
S
S#define SPI0                ((SPI_T *) SPI0_BASE)                       /*!< SPI0 Configuration Struct                        */
S#define SPI1                ((SPI_T *) SPI1_BASE)                       /*!< SPI1 Configuration Struct                        */
S#define SPI2                ((SPI_T *) SPI2_BASE)                       /*!< SPI2 Configuration Struct                        */
S#define SPI3                ((SPI_T *) SPI3_BASE)                       /*!< SPI3 Configuration Struct                        */
S
S#define I2C0                ((I2C_T *) I2C0_BASE)                       /*!< I2C0 Configuration Struct                        */
S#define I2C1                ((I2C_T *) I2C1_BASE)                       /*!< I2C1 Configuration Struct                        */
S
S#define I2S                 ((I2S_T *) I2S_BASE)                        /*!< I2S Configuration Struct                         */
S
S#define RTC                 ((RTC_T *) RTC_BASE)                        /*!< RTC Configuration Struct                         */
S
S#define ADC                 ((ADC_T *) ADC_BASE)                        /*!< ADC Configuration Struct                         */
S
S#define ACMP                ((ACMP_T *) ACMP_BASE)                      /*!< ACMP Configuration Struct                        */
S
S#define CLK                 ((CLK_T *) CLK_BASE)                        /*!< System Clock Controller Configuration Struct     */
S
S#define SYS                 ((GCR_T *) GCR_BASE)                        /*!< System Global Controller Configuration Struct    */
S
S#define SYSINT              ((GCR_INT_T *) INT_BASE)                    /*!< Interrupt Source Controller Configuration Struct */
S
S#define FMC                 ((FMC_T *) FMC_BASE)
S
S#define PS2                 ((PS2_T *) PS2_BASE)                        /*!< PS/2 Configuration Struct                        */
S
S#define CAN                 ((CAN_T *) CAN0_BASE)
S#define CAN0                ((CAN_T *) CAN0_BASE)                                               /*!< CAN0 Configuration Struct                        */
S#define CAN1                ((CAN_T *) CAN1_BASE)                                               /*!< CAN1 Configuration Struct                        */
S
S#define USBD                ((USBD_T *) USBD_BASE)                      /*!< USBD Configuration Struct                        */
S
S#define PDMA0               ((PDMA_T *) PDMA0_BASE)                     /*!< PDMA0 Configuration Struct                       */
S#define PDMA1               ((PDMA_T *) PDMA1_BASE)                     /*!< PDMA1 Configuration Struct                       */
S#define PDMA2               ((PDMA_T *) PDMA2_BASE)                     /*!< PDMA2 Configuration Struct                       */
S#define PDMA3               ((PDMA_T *) PDMA3_BASE)                     /*!< PDMA3 Configuration Struct                       */
S#define PDMA4               ((PDMA_T *) PDMA4_BASE)                     /*!< PDMA4 Configuration Struct                       */
S#define PDMA5               ((PDMA_T *) PDMA5_BASE)                     /*!< PDMA5 Configuration Struct                       */
S#define PDMA6               ((PDMA_T *) PDMA6_BASE)                     /*!< PDMA6 Configuration Struct                       */
S#define PDMA7               ((PDMA_T *) PDMA7_BASE)                     /*!< PDMA7 Configuration Struct                       */
S#define PDMA8               ((PDMA_T *) PDMA8_BASE)                     /*!< PDMA8 Configuration Struct                       */
S
S#define PDMA_GCR            ((PDMA_GCR_T *) PDMA_GCR_BASE)              /*!< PDMA Global Configuration Struct                 */
S
S#define CRC                 ((CRC_T *) CRC_BASE)                        /*!< CRC Configuration Struct                         */
S
S#define PWMA                ((PWM_T *) PWMA_BASE)                       /*!< PWMA Configuration Struct                        */
S#define PWMB                ((PWM_T *) PWMB_BASE)                       /*!< PWMB Configuration Struct                        */
S
S#define SC0                 ((SC_T *) SC0_BASE)                         /*!< SC0 Configuration Struct                        */
S#define SC1                 ((SC_T *) SC1_BASE)                         /*!< SC1 Configuration Struct                        */
S#define SC2                 ((SC_T *) SC2_BASE)                         /*!< SC2 Configuration Struct                        */
S
S#define EBI                 ((EBI_T *) EBI_BASE)                        /*!< EBI Configuration Struct                         */
S
S/*@}*/ /* end of group PERIPHERAL */
S
S#define UNLOCKREG(x)        do{*((__IO uint32_t *)(GCR_BASE + 0x100)) = 0x59;*((__IO uint32_t *)(GCR_BASE + 0x100)) = 0x16;*((__IO uint32_t *)(GCR_BASE + 0x100)) = 0x88;}while(*((__IO uint32_t *)(GCR_BASE + 0x100))==0)
S#define LOCKREG(x)          *((__IO uint32_t *)(GCR_BASE + 0x100)) = 0x00
S
S#define REGCOPY(dest, src)  *((uint32_t *)&(dest)) = *((uint32_t *)&(src))
S#define CLEAR(dest)         *((uint32_t *)&(dest)) = 0
S
S//=============================================================================
S/** @addtogroup IO_ROUTINE I/O routines
S  The Declaration of I/O routines
S  @{
S */
S
Stypedef volatile unsigned char  vu8;        ///< Define 8-bit unsigned volatile data type
Stypedef volatile unsigned short vu16;       ///< Define 16-bit unsigned volatile data type
Stypedef volatile unsigned long  vu32;       ///< Define 32-bit unsigned volatile data type
S
S/**
S  * @brief Get a 8-bit unsigned value from specified address
S  * @param[in] addr Address to get 8-bit data from
S  * @return  8-bit unsigned value stored in specified address
S  */
S#define M8(addr)  (*((vu8  *) (addr)))
S
S/**
S  * @brief Get a 16-bit unsigned value from specified address
S  * @param[in] addr Address to get 16-bit data from
S  * @return  16-bit unsigned value stored in specified address
S  * @note The input address must be 16-bit aligned
S  */
S#define M16(addr) (*((vu16 *) (addr)))
S
S/**
S  * @brief Get a 32-bit unsigned value from specified address
S  * @param[in] addr Address to get 32-bit data from
S  * @return  32-bit unsigned value stored in specified address
S  * @note The input address must be 32-bit aligned
S  */
S#define M32(addr) (*((vu32 *) (addr)))
S
S/**
S  * @brief Set a 32-bit unsigned value to specified I/O port
S  * @param[in] port Port address to set 32-bit data
S  * @param[in] value Value to write to I/O port
S  * @return  None
S  * @note The output port must be 32-bit aligned
S  */
S#define outpw(port,value)     *((volatile unsigned int *)(port)) = value
S
S/**
S  * @brief Get a 32-bit unsigned value from specified I/O port
S  * @param[in] port Port address to get 32-bit data from
S  * @return  32-bit unsigned value stored in specified I/O port
S  * @note The input port must be 32-bit aligned
S  */
S#define inpw(port)            (*((volatile unsigned int *)(port)))
S
S/**
S  * @brief Set a 16-bit unsigned value to specified I/O port
S  * @param[in] port Port address to set 16-bit data
S  * @param[in] value Value to write to I/O port
S  * @return  None
S  * @note The output port must be 16-bit aligned
S  */
S#define outps(port,value)     *((volatile unsigned short *)(port)) = value
S
S/**
S  * @brief Get a 16-bit unsigned value from specified I/O port
S  * @param[in] port Port address to get 16-bit data from
S  * @return  16-bit unsigned value stored in specified I/O port
S  * @note The input port must be 16-bit aligned
S  */
S#define inps(port)            (*((volatile unsigned short *)(port)))
S
S/**
S  * @brief Set a 8-bit unsigned value to specified I/O port
S  * @param[in] port Port address to set 8-bit data
S  * @param[in] value Value to write to I/O port
S  * @return  None
S  */
S#define outpb(port,value)     *((volatile unsigned char *)(port)) = value
S
S/**
S  * @brief Get a 8-bit unsigned value from specified I/O port
S  * @param[in] port Port address to get 8-bit data from
S  * @return  8-bit unsigned value stored in specified I/O port
S  */
S#define inpb(port)            (*((volatile unsigned char *)(port)))
S
S/**
S  * @brief Set a 32-bit unsigned value to specified I/O port
S  * @param[in] port Port address to set 32-bit data
S  * @param[in] value Value to write to I/O port
S  * @return  None
S  * @note The output port must be 32-bit aligned
S  */
S#define outp32(port,value)    *((volatile unsigned int *)(port)) = value
S
S/**
S  * @brief Get a 32-bit unsigned value from specified I/O port
S  * @param[in] port Port address to get 32-bit data from
S  * @return  32-bit unsigned value stored in specified I/O port
S  * @note The input port must be 32-bit aligned
S  */
S#define inp32(port)           (*((volatile unsigned int *)(port)))
S
S/**
S  * @brief Set a 16-bit unsigned value to specified I/O port
S  * @param[in] port Port address to set 16-bit data
S  * @param[in] value Value to write to I/O port
S  * @return  None
S  * @note The output port must be 16-bit aligned
S  */
S#define outp16(port,value)    *((volatile unsigned short *)(port)) = value
S
S/**
S  * @brief Get a 16-bit unsigned value from specified I/O port
S  * @param[in] port Port address to get 16-bit data from
S  * @return  16-bit unsigned value stored in specified I/O port
S  * @note The input port must be 16-bit aligned
S  */
S#define inp16(port)           (*((volatile unsigned short *)(port)))
S
S/**
S  * @brief Set a 8-bit unsigned value to specified I/O port
S  * @param[in] port Port address to set 8-bit data
S  * @param[in] value Value to write to I/O port
S  * @return  None
S  */
S#define outp8(port,value)     *((volatile unsigned char *)(port)) = value
S
S/**
S  * @brief Get a 8-bit unsigned value from specified I/O port
S  * @param[in] port Port address to get 8-bit data from
S  * @return  8-bit unsigned value stored in specified I/O port
S  */
S#define inp8(port)            (*((volatile unsigned char *)(port)))
S
S/*@}*/ /* end of group IO_ROUTINE */
S
S
S
S
S/** @addtogroup legacy_Constants Legacy Constants
S  Legacy Constants
S  @{
S*/
S
S
S#define E_SUCCESS   0
S#ifndef NULL
S#define NULL        0
S#endif
S
S#define TRUE        1
S#define FALSE       0
S
S#define ENABLE     1
S#define DISABLE    0
S
S/* Define one bit mask */
S#define BIT0    0x00000001
S#define BIT1    0x00000002
S#define BIT2    0x00000004
S#define BIT3    0x00000008
S#define BIT4    0x00000010
S#define BIT5    0x00000020
S#define BIT6    0x00000040
S#define BIT7    0x00000080
S#define BIT8    0x00000100
S#define BIT9    0x00000200
S#define BIT10   0x00000400
S#define BIT11   0x00000800
S#define BIT12   0x00001000
S#define BIT13   0x00002000
S#define BIT14   0x00004000
S#define BIT15   0x00008000
S#define BIT16   0x00010000
S#define BIT17   0x00020000
S#define BIT18   0x00040000
S#define BIT19   0x00080000
S#define BIT20   0x00100000
S#define BIT21   0x00200000
S#define BIT22   0x00400000
S#define BIT23   0x00800000
S#define BIT24   0x01000000
S#define BIT25   0x02000000
S#define BIT26   0x04000000
S#define BIT27   0x08000000
S#define BIT28   0x10000000
S#define BIT29   0x20000000
S#define BIT30   0x40000000
S#define BIT31   0x80000000
S
S/* Byte Mask Definitions */
S#define BYTE0_Msk               (0x000000FF)
S#define BYTE1_Msk               (0x0000FF00)
S#define BYTE2_Msk               (0x00FF0000)
S#define BYTE3_Msk               (0xFF000000)
S
S#define _GET_BYTE0(u32Param)    (((u32Param) & BYTE0_Msk)      )  /*!< Extract Byte 0 (Bit  0~ 7) from parameter u32Param */
S#define _GET_BYTE1(u32Param)    (((u32Param) & BYTE1_Msk) >>  8)  /*!< Extract Byte 1 (Bit  8~15) from parameter u32Param */
S#define _GET_BYTE2(u32Param)    (((u32Param) & BYTE2_Msk) >> 16)  /*!< Extract Byte 2 (Bit 16~23) from parameter u32Param */
S#define _GET_BYTE3(u32Param)    (((u32Param) & BYTE3_Msk) >> 24)  /*!< Extract Byte 3 (Bit 24~31) from parameter u32Param */
S
S/*@}*/ /* end of group legacy_Constants */
S
S/*@}*/ /* end of group Definitions */
S
S
S/******************************************************************************/
S/*                         Peripheral header files                            */
S/******************************************************************************/
S#include "SYS.h"
S#include "ADC.h"
S#include "CAN.h"
S#include "FMC.h"
S#include "GPIO.h"
S#include "I2C.h"
S#include "PWM.h"
S#include "SPI.h"
S#include "CRC.h"
S#include "TIMER.h"
S#include "WDT.h"
S#include "WWDT.h"
S#include "RTC.h"
S#include "UART.h"
S#include "I2S.h"
S#include "USBD.h"
S#include "PDMA.h"
S#include "SC.h"
S#include "SCUART.h"
S#include "PS2.h"
S#include "CLK.h"
S#include "ACMP.h"
S#include "EBI.h"
N#endif
N
N/*@}*/ /* end of REGISTER group Definitions */
N
N
L 16 ".\Libraries\StdDriver\inc\ADC.h" 2
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup ADC_Driver ADC Driver
N  @{
N*/
N
N/** @addtogroup ADC_EXPORTED_CONSTANTS ADC Exported Constants
N  @{
N*/
N/*---------------------------------------------------------------------------------------------------------*/
N/*  ADCR Constant Definitions                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_ADCR_ADEN_CONVERTER_DISABLE   (0UL<<ADC_ADCR_ADEN_Pos)   /*!< ADC converter disable          */
N#define ADC_ADCR_ADEN_CONVERTER_ENABLE    (1UL<<ADC_ADCR_ADEN_Pos)   /*!< ADC converter enable           */
N
N#define ADC_ADCR_ADMD_SINGLE            (0UL<<ADC_ADCR_ADMD_Pos)     /*!< Single mode                */
N#define ADC_ADCR_ADMD_SINGLE_CYCLE      (2UL<<ADC_ADCR_ADMD_Pos)     /*!< Single cycle scan mode     */
N#define ADC_ADCR_ADMD_CONTINUOUS        (3UL<<ADC_ADCR_ADMD_Pos)     /*!< Continuous scan mode       */
N
N#define ADC_ADCR_DIFFEN_SINGLE_END      (0UL<<ADC_ADCR_DIFFEN_Pos)   /*!< Single end input mode      */
N#define ADC_ADCR_DIFFEN_DIFFERENTIAL    (1UL<<ADC_ADCR_DIFFEN_Pos)   /*!< Differential input type    */
N
N#define ADC_ADCR_DMOF_UNSIGNED_OUTPUT   (0UL<<ADC_ADCR_DMOF_Pos)     /*!< Select the straight binary format as the output format of the conversion result   */
N#define ADC_ADCR_DMOF_TWOS_COMPLEMENT   (1UL<<ADC_ADCR_DMOF_Pos)     /*!< Select the 2's complement format as the output format of the conversion result    */
N
N#define ADC_ADCR_TRGEN_DISABLE          (0UL<<ADC_ADCR_TRGEN_Pos)    /*!< Disable triggering of A/D conversion by external STADC pin or PWM   */
N#define ADC_ADCR_TRGEN_ENABLE           (1UL<<ADC_ADCR_TRGEN_Pos)    /*!< Enable triggering of A/D conversion by external STADC pin or PWM  */
N
N#define ADC_ADCR_TRGS_STADC             (0UL<<ADC_ADCR_TRGS_Pos)     /*!< A/D conversion is started by external STADC pin */
N#define ADC_ADCR_TRGS_PWM               (3UL<<ADC_ADCR_TRGS_Pos)     /*!< A/D conversion is started by PWM */
N
N#define ADC_ADCR_TRGCOND_LOW_LEVEL      (0UL<<ADC_ADCR_TRGCOND_Pos)  /*!< STADC Low level active     */
N#define ADC_ADCR_TRGCOND_HIGH_LEVEL     (1UL<<ADC_ADCR_TRGCOND_Pos)  /*!< STADC High level active    */
N#define ADC_ADCR_TRGCOND_FALLING_EDGE   (2UL<<ADC_ADCR_TRGCOND_Pos)  /*!< STADC Falling edge active  */
N#define ADC_ADCR_TRGCOND_RISING_EDGE    (3UL<<ADC_ADCR_TRGCOND_Pos)  /*!< STADC Rising edge active   */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ADCHER Constant Definitions                                                                             */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_ADCHER_PRESEL_EXT_INPUT_SIGNAL         (0UL<<ADC_ADCHER_PRESEL_Pos)    /*!< The input source of channel 7 is the external analog input                   */
N#define ADC_ADCHER_PRESEL_INT_BANDGAP              (1UL<<ADC_ADCHER_PRESEL_Pos)    /*!< The input source of channel 7 is the internal bandgap voltage                */
N#define ADC_ADCHER_PRESEL_INT_TEMPERATURE_SENSOR   (2UL<<ADC_ADCHER_PRESEL_Pos)    /*!< The input source of channel 7 is the output of internal temperature sensor   */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ADCMPR Constant Definitions                                                                             */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_ADCMPR_CMPD(x)                    ((x) << ADC_ADCMPR_CMPD_Pos)          /*!< Compare value for compare function            */
N#define ADC_ADCMPR_CMPMATCNT(x)               (((x)-1) << ADC_ADCMPR_CMPMATCNT_Pos) /*!< Match count for compare function              */
N#define ADC_ADCMPR_CMPCH(x)                   ((x) << ADC_ADCMPR_CMPCH_Pos)         /*!< Compare channel for compare function          */
N#define ADC_ADCMPR_CMPCOND_LESS_THAN          (0<<ADC_ADCMPR_CMPCOND_Pos)           /*!< The compare condition is "less than"          */
N#define ADC_ADCMPR_CMPCOND_GREATER_OR_EQUAL   (1<<ADC_ADCMPR_CMPCOND_Pos)           /*!< The compare condition is "greater than or equal to" */
N#define ADC_ADCMPR_CMPIE_INTERRUPT_ENABLE     (ADC_ADCMPR_CMPIE_Msk)                /*!< The compare function interrupt enable */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ADC Interrupt Constant Definitions                                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_ADF_INT         (ADC_ADSR_ADF_Msk)          /*!< ADC convert complete interrupt */
N#define ADC_CMP0_INT        (ADC_ADSR_CMPF0_Msk)        /*!< ADC comparator 0 interrupt */
N#define ADC_CMP1_INT        (ADC_ADSR_CMPF1_Msk)        /*!< ADC comparator 1 interrupt */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ADC Operation Mode Constant Definitions                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_SINGLE_MODE         0   /*!< ADC single mode            */
N#define ADC_SINGLE_CYCLE_MODE   2   /*!< ADC single-cycle scan mode */
N#define ADC_CONTINUOUS_MODE     3   /*!< ADC continuous scan mode   */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ADC Trigger Condition Constant Definitions                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_LOW_LEVEL      0   /*!< ADC external trigger condition is low level trigger    */
N#define ADC_HIGH_LEVEL     1   /*!< ADC external trigger condition is high level trigger   */
N#define ADC_FALLING_EDGE   2   /*!< ADC external trigger condition is falling edge trigger */
N#define ADC_RISING_EDGE    3   /*!< ADC external trigger condition is rising edge trigger  */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* ADC Compare Condition Constant Definitions                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_LESS_THAN          0   /*!< ADC compare condition is "less than the compare value"                */
N#define ADC_GREATER_OR_EQUAL   1   /*!< ADC compare condition is "greater than or equal to the compare value" */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Constant Definitions of ADC Channel 7 Input Source                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ADC_CH7_EXT_INPUT_SIGNAL         0   /*!< External input signal       */
N#define ADC_CH7_INT_BANDGAP              1   /*!< Internal band-gap voltage   */
N#define ADC_CH7_INT_TEMPERATURE_SENSOR   2   /*!< Internal temperature sensor */
N
N
N/*@}*/ /* end of group ADC_EXPORTED_CONSTANTS */
N
N/** @addtogroup ADC_EXPORTED_FUNCTIONS ADC Exported Functions
N  @{
N*/
N
N/**
N  * @brief Configure the analog input source of channel 7.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32Source Decides the analog input source of channel 7. Valid values are:
N  *                       - \ref ADC_ADCHER_PRESEL_EXT_INPUT_SIGNAL        : External analog input.
N  *                       - \ref ADC_ADCHER_PRESEL_INT_BANDGAP             : Internal bandgap voltage.
N  *                       - \ref ADC_ADCHER_PRESEL_INT_TEMPERATURE_SENSOR  : Output of internal temperature sensor.
N  * @return None
N  * @details Channel 7 supports 3 input sources: External analog voltage, internal Band-gap voltage, and internal temperature sensor output.
N  * @note While using VBG as channel 7 source, ADC module clock must /b not exceed 300kHz.
N  */
N#define ADC_CONFIG_CH7(adc, u32Source) ((adc)->ADCHER = ((adc)->ADCHER & ~ADC_ADCHER_PRESEL_Msk) | (u32Source))
N
N/**
N  * @brief Enable PDMA transfer.
N  * @param[in] adc The pointer of the specified ADC module
N  * @return None
N  * @details Enable PDMA to transfer the conversion data.
N  * @note While enable PDMA transfer, software must set ADIE = 0 to disable interrupt.
N  */
N#define ADC_ENABLE_PDMA(adc) ((adc)->ADCR |= ADC_ADCR_PTEN_Msk)
N
N/**
N  * @brief Disable PDMA transfer.
N  * @param[in] adc The pointer of the specified ADC module
N  * @return None
N  * @details Disable PDMA to transfer the conversion data.
N  */
N#define ADC_DISABLE_PDMA(adc) ((adc)->ADCR &= ~ADC_ADCR_PTEN_Msk)
N
N/**
N  * @brief Get conversion data of specified channel.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32ChNum  ADC Channel, valid value are from 0 to 7.
N  * @return 16-bit data.
N  * @details Read RSLT bit field to get conversion data.
N  */
N#define ADC_GET_CONVERSION_DATA(adc, u32ChNum) ((adc)->ADDR[(u32ChNum)] & ADC_ADDR_RSLT_Msk)
N
N/**
N  * @brief Return the user-specified interrupt flags.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32Mask The combination of following interrupt status bits. Each bit corresponds to a interrupt status.
N  *                    Valid values are:
N  *                     - \ref ADC_ADF_INT          :Convert complete interrupt flag.
N  *                     - \ref ADC_CMP0_INT         :Comparator 0 interrupt flag.
N  *                     - \ref ADC_CMP1_INT         :Comparator 1 interrupt flag.
N  * @return User specified interrupt flags.
N  * @details Get the status of the ADC interrupt flag.
N  */
N#define ADC_GET_INT_FLAG(adc, u32Mask) ((adc)->ADSR & (u32Mask))
N
N/**
N  * @brief This macro clear the selected interrupt status bits.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32Mask The combination of following interrupt status bits. Each bit corresponds to a interrupt status.
N  *                    Valid values are:
N  *                     - \ref ADC_ADF_INT          :Convert complete interrupt flag.
N  *                     - \ref ADC_CMP0_INT         :Comparator 0 interrupt flag.
N  *                     - \ref ADC_CMP1_INT         :Comparator 1 interrupt flag.
N  * @return None
N  * @details ADF (ADSR[0])/CMPF0 (ADSR[1])/CMPF0 (ADSR[2]) can be cleared by writing 1 to itself.
N  */
N#define ADC_CLR_INT_FLAG(adc, u32Mask) ((adc)->ADSR = (u32Mask))
N
N/**
N  * @brief Get the busy state of ADC.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @retval 0 ADC is not busy.
N  * @retval 1 ADC is busy.
N  * @details BUSY(ADSR[3])is mirror of as ADST bit (ADCR[11]).
N  */
N#define ADC_IS_BUSY(adc) ((adc)->ADSR & ADC_ADSR_BUSY_Msk ? 1 : 0)
N
N/**
N  * @brief Check if the ADC conversion data is over written or not.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32ChNum ADC Channel, valid value are from 0 to 7.
N  * @retval 0 ADC data is not overrun.
N  * @retval 1 ADC data is overrun.
N  * @details OVERRUN (ADSR[23:16]) is a mirror to OVERRUN (ADDR0~7[16]).
N  */
N#define ADC_IS_DATA_OVERRUN(adc, u32ChNum) ((adc)->ADSR & (0x1 << (ADC_ADSR_OVERRUN_Pos + (u32ChNum))) ? 1 : 0)
N
N/**
N  * @brief Check if the ADC conversion data is valid or not.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32ChNum ADC Channel, valid value are from 0 to 7.
N  * @retval 0 ADC data is not valid.
N  * @retval 1 ADC data is valid.
N  * @details VALID (ADDR0~7[17]) is set to 1 when corresponding channel analog input conversion is completed and cleared by hardware after ADDR register is read.
N  */
N#define ADC_IS_DATA_VALID(adc, u32ChNum) ((adc)->ADSR & (0x1<<(ADC_ADSR_VALID_Pos+(u32ChNum))) ? 1 : 0)
N
N/**
N  * @brief Power down ADC module.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @return None
N  * @details Disable A/D converter analog circuit for saving power consumption.
N  * @note None
N  */
N#define ADC_POWER_DOWN(adc) ((adc)->ADCR &= ~ADC_ADCR_ADEN_Msk)
N
N/**
N  * @brief Power on ADC module.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @return None
N  * @details Before starting A/D conversion function, ADEN bit (ADCR[0]) should be set to 1.
N  */
N#define ADC_POWER_ON(adc) ((adc)->ADCR |= ADC_ADCR_ADEN_Msk)
N
N/**
N  * @brief Configure the comparator 0 and enable it.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32ChNum  Specifies the source channel, valid value are from 0 to 7.
N  * @param[in] u32Condition Specifies the compare condition. Valid values are:
N  *                          - \ref ADC_ADCMPR_CMPCOND_LESS_THAN            :The compare condition is "less than the compare value".
N  *                          - \ref ADC_ADCMPR_CMPCOND_GREATER_OR_EQUAL     :The compare condition is "greater than or equal to the compare value.
N  * @param[in] u32Data Specifies the compare value, valid value are between 0 ~ 0xFFF.
N  * @param[in] u32MatchCount Specifies the match count setting, valid values are between 1~16.
N  * @return None
N  * @details For example, ADC_ENABLE_CMP0(ADC, 5, ADC_ADCMPR_CMPCOND_GREATER_OR_EQUAL, 0x800, 10);
N  *          Means ADC will assert comparator 0 flag if channel 5 conversion result is greater or
N  *          equal to 0x800 for 10 times continuously.
N  * \hideinitializer
N  */
N#define ADC_ENABLE_CMP0(adc, \
N                        u32ChNum, \
N                        u32Condition, \
N                        u32Data, \
N                        u32MatchCount) ((adc)->ADCMPR[0] = ((u32ChNum) << ADC_ADCMPR_CMPCH_Pos) | \
N                                                          (u32Condition) | \
N                                                         ((u32Data) << ADC_ADCMPR_CMPD_Pos) | \
N                                                         (((u32MatchCount) - 1) << ADC_ADCMPR_CMPMATCNT_Pos) |\
N                                                          ADC_ADCMPR_CMPEN_Msk)
X#define ADC_ENABLE_CMP0(adc,                         u32ChNum,                         u32Condition,                         u32Data,                         u32MatchCount) ((adc)->ADCMPR[0] = ((u32ChNum) << ADC_ADCMPR_CMPCH_Pos) |                                                           (u32Condition) |                                                          ((u32Data) << ADC_ADCMPR_CMPD_Pos) |                                                          (((u32MatchCount) - 1) << ADC_ADCMPR_CMPMATCNT_Pos) |                                                          ADC_ADCMPR_CMPEN_Msk)
N
N/**
N  * @brief Disable comparator 0.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @return None
N  * @details Set CMPEN (ADCMPR0[0]) to 0 to disable ADC controller to compare CMPD (ADCMPR0[27:16]).
N  */
N#define ADC_DISABLE_CMP0(adc) ((adc)->ADCMPR[0] = 0)
N
N/**
N  * @brief Configure the comparator 1 and enable it.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32ChNum  Specifies the source channel, valid value are from 0 to 7.
N  * @param[in] u32Condition Specifies the compare condition. Valid values are:
N  *                          - \ref ADC_ADCMPR_CMPCOND_LESS_THAN            :The compare condition is "less than the compare value".
N  *                          - \ref ADC_ADCMPR_CMPCOND_GREATER_OR_EQUAL     :The compare condition is "greater than or equal to the compare value.
N  * @param[in] u32Data Specifies the compare value, valid value are between 0 ~ 0xFFF.
N  * @param[in] u32MatchCount Specifies the match count setting, valid values are between 1~16.
N  * @return None
N  * @details For example, ADC_ENABLE_CMP1(ADC, 5, ADC_ADCMPR_CMPCOND_GREATER_OR_EQUAL, 0x800, 10);
N  *          Means ADC will assert comparator 1 flag if channel 5 conversion result is greater or
N  *          equal to 0x800 for 10 times continuously.
N  * \hideinitializer
N  */
N#define ADC_ENABLE_CMP1(adc, \
N                        u32ChNum, \
N                        u32Condition, \
N                        u32Data, \
N                        u32MatchCount) ((adc)->ADCMPR[1] = ((u32ChNum) << ADC_ADCMPR_CMPCH_Pos) | \
N                                                          (u32Condition) | \
N                                                         ((u32Data) << ADC_ADCMPR_CMPD_Pos) | \
N                                                         (((u32MatchCount) - 1) << ADC_ADCMPR_CMPMATCNT_Pos) |\
N                                                          ADC_ADCMPR_CMPEN_Msk)
X#define ADC_ENABLE_CMP1(adc,                         u32ChNum,                         u32Condition,                         u32Data,                         u32MatchCount) ((adc)->ADCMPR[1] = ((u32ChNum) << ADC_ADCMPR_CMPCH_Pos) |                                                           (u32Condition) |                                                          ((u32Data) << ADC_ADCMPR_CMPD_Pos) |                                                          (((u32MatchCount) - 1) << ADC_ADCMPR_CMPMATCNT_Pos) |                                                          ADC_ADCMPR_CMPEN_Msk)
N
N/**
N  * @brief Disable comparator 1.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @return None
N  * @details Set CMPEN (ADCMPR1[0]) to 0 to disable ADC controller to compare CMPD (ADCMPR1[27:16]).
N  */
N#define ADC_DISABLE_CMP1(adc) ((adc)->ADCMPR[1] = 0)
N
N/**
N  * @brief Set ADC input channel.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32Mask  Channel enable bit. Each bit corresponds to a input channel. Bit 0 is channel 0, bit 1 is channel 1..., bit 7 is channel 7.
N  * @return None
N  * @details Enabled channel will be converted while ADC starts.
N  * @note NUC230_240 series MCU ADC can only convert 1 channel at a time. If more than 1 channels are enabled, only channel
N  *       with smallest number will be convert.
N  */
N#define ADC_SET_INPUT_CHANNEL(adc, u32Mask) ((adc)->ADCHER = ((adc)->ADCHER & ~ADC_ADCHER_CHEN_Msk) | (u32Mask))
N
N/**
N  * @brief Set the output format mode.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @param[in] u32Format Decides the output format. Valid values are:
N  *                       - \ref ADC_ADCR_DMOF_UNSIGNED_OUTPUT      :Select the straight binary format as the output format of the conversion result.
N  *                       - \ref ADC_ADCR_DMOF_TWOS_COMPLEMENT      :Select the 2's complement format as the output format of the conversion result.
N  * @return None
N  * @details  The macro is used to set A/D differential input mode output format.
N  */
N#define ADC_SET_DMOF(adc, u32Format) ((adc)->ADCR = ((adc)->ADCR & ~ADC_ADCR_DMOF_Msk) | (u32Format))
N
N/**
N  * @brief Start the A/D conversion.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @return None
N  * @details ADST (ADCR[11]) can be set to 1 from three sources: software, PWM Center-aligned trigger and external pin STADC.
N  */
N#define ADC_START_CONV(adc) ((adc)->ADCR |= ADC_ADCR_ADST_Msk)
N
N/**
N  * @brief Stop the A/D conversion.
N  * @param[in] adc The pointer of the specified ADC module.
N  * @return None
N  * @details ADST (ADCR[11]) will be cleared to 0 by hardware automatically at the ends of single mode and single-cycle scan mode.
N  *          In continuous scan mode, A/D conversion is continuously performed until software writes 0 to this bit or chip reset.
N  */
N#define ADC_STOP_CONV(adc) ((adc)->ADCR &= ~ADC_ADCR_ADST_Msk)
N
Nvoid ADC_Open(ADC_T *adc,
N              uint32_t u32InputMode,
N              uint32_t u32OpMode,
N              uint32_t u32ChMask);
Nvoid ADC_Close(ADC_T *adc);
Nvoid ADC_EnableHWTrigger(ADC_T *adc,
N                         uint32_t u32Source,
N                         uint32_t u32Param);
Nvoid ADC_DisableHWTrigger(ADC_T *adc);
Nvoid ADC_EnableInt(ADC_T *adc, uint32_t u32Mask);
Nvoid ADC_DisableInt(ADC_T *adc, uint32_t u32Mask);
N
N
N
N/*@}*/ /* end of group ADC_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group ADC_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__ADC_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 12444 ".\Libraries\Device\Nuvoton\NUC230_240\Include\NUC230_240.h" 2
N#include "CAN.h"
L 1 ".\Libraries\StdDriver\inc\CAN.h" 1
N/**************************************************************************//**
N * @file     can.h
N * @version  V3.00
N * $Revision: 2 $
N * $Date: 15/05/06 10:18a $
N * @brief    NUC230_240 Series CAN Driver Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __CAN_H__
N#define __CAN_H__
N
N#include "NUC230_240.h"
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup CAN_Driver CAN Driver
N  @{
N*/
N
N/** @addtogroup CAN_EXPORTED_CONSTANTS CAN Exported Constants
N  @{
N*/
N/*---------------------------------------------------------------------------------------------------------*/
N/* CAN Test Mode Constant Definitions                                                                      */
N/*---------------------------------------------------------------------------------------------------------*/
N#define    CAN_NORMAL_MODE   0
N#define    CAN_BASIC_MODE    1
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Message ID Type Constant Definitions                                                                    */
N/*---------------------------------------------------------------------------------------------------------*/
N#define    CAN_STD_ID    0
N#define    CAN_EXT_ID    1
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Message Frame Type Constant Definitions                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N#define    CAN_REMOTE_FRAME    0
N#define    CAN_DATA_FRAME    1
N
N/*@}*/ /* end of group CAN_EXPORTED_CONSTANTS */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CAN message structure                                                                                  */
N/*---------------------------------------------------------------------------------------------------------*/
Ntypedef struct
N{
N    uint32_t  IdType;
N    uint32_t  FrameType;
N    uint32_t  Id;
N    uint8_t   DLC;
N    uint8_t   Data[8];
N} STR_CANMSG_T;
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CAN mask message structure                                                                             */
N/*---------------------------------------------------------------------------------------------------------*/
Ntypedef struct
N{
N    uint8_t   u8Xtd;
N    uint8_t   u8Dir;
N    uint32_t  u32Id;
N    uint8_t   u8IdType;
N} STR_CANMASK_T;
N
N#define MSG(id)  (id)
N
N
N/** @addtogroup CAN_EXPORTED_FUNCTIONS CAN Exported Functions
N  @{
N*/
N
N/**
N * @brief Get interrupt status.
N *
N * @param[in] can The base address of can module.
N *
N * @return CAN module status register value.
N *
N * @details Status Interrupt is generated by bits BOff (CAN_STATUS[7]), EWarn (CAN_STATUS[6]),
N *          EPass (CAN_STATUS[5]), RxOk (CAN_STATUS[4]), TxOk (CAN_STATUS[3]), and LEC (CAN_STATUS[2:0]).
N */
N#define CAN_GET_INT_STATUS(can) ((can)->STATUS)
N
N/**
N * @brief Get specified interrupt pending status.
N *
N * @param[in] can The base address of can module.
N *
N * @return The source of the interrupt.
N *
N * @details If several interrupts are pending, the CAN Interrupt Register will point to the pending interrupt
N *          with the highest priority, disregarding their chronological order.
N */
N#define CAN_GET_INT_PENDING_STATUS(can) ((can)->IIDR)
N
N/**
N * @brief Disable wake-up function.
N *
N * @param[in] can The base address of can module.
N *
N * @return None
N *
N * @details  The macro is used to disable wake-up function.
N */
N#define CAN_DISABLE_WAKEUP(can) ((can)->WU_EN = 0)
N
N/**
N * @brief Enable wake-up function.
N *
N * @param[in] can The base address of can module.
N *
N * @return None
N *
N * @details User can wake-up system when there is a falling edge in the CAN_Rx pin.
N */
N#define CAN_ENABLE_WAKEUP(can) ((can)->WU_EN = CAN_WUEN_WAKUP_EN_Msk)
N
N/**
N * @brief Get specified Message Object new data into bit value.
N *
N * @param[in] can The base address of can module.
N * @param[in] u32MsgNum Specified Message Object number, valid value are from 0 to 31.
N *
N * @return Specified Message Object new data into bit value.
N *
N * @details The NewDat bit (CAN_IFn_MCON[15]) of a specific Message Object can be set/reset by the software through the IFn Message Interface Registers
N *          or by the Message Handler after reception of a Data Frame or after a successful transmission.
N */
N#define CAN_GET_NEW_DATA_IN_BIT(can, u32MsgNum) ((u32MsgNum) < 16 ? (can)->NDAT1 & (1 << (u32MsgNum)) : (can)->NDAT2 & (1 << ((u32MsgNum)-16)))
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define CAN functions prototype                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
Nuint32_t CAN_SetBaudRate(CAN_T *tCAN, uint32_t u32BaudRate);
Nuint32_t CAN_Open(CAN_T *tCAN, uint32_t u32BaudRate, uint32_t u32Mode);
Nvoid CAN_Close(CAN_T *tCAN);
Nvoid CAN_CLR_INT_PENDING_BIT(CAN_T *tCAN, uint8_t u32MsgNum);
Nvoid CAN_EnableInt(CAN_T *tCAN, uint32_t u32Mask);
Nvoid CAN_DisableInt(CAN_T *tCAN, uint32_t u32Mask);
Nint32_t CAN_Transmit(CAN_T *tCAN, uint32_t u32MsgNum , STR_CANMSG_T* pCanMsg);
Nint32_t CAN_Receive(CAN_T *tCAN, uint32_t u32MsgNum , STR_CANMSG_T* pCanMsg);
Nint32_t CAN_SetMultiRxMsg(CAN_T *tCAN, uint32_t u32MsgNum , uint32_t u32MsgCount, uint32_t u32IDType, uint32_t u32ID);
Nint32_t CAN_SetRxMsg(CAN_T *tCAN, uint32_t u32MsgNum , uint32_t u32IDType, uint32_t u32ID);
Nint32_t CAN_SetTxMsg(CAN_T *tCAN, uint32_t u32MsgNum , STR_CANMSG_T* pCanMsg);
Nint32_t CAN_TriggerTxMsg(CAN_T  *tCAN, uint32_t u32MsgNum);
N
N
N/*@}*/ /* end of group CAN_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group CAN_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__CAN_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 12445 ".\Libraries\Device\Nuvoton\NUC230_240\Include\NUC230_240.h" 2
N#include "FMC.h"
L 1 ".\Libraries\StdDriver\inc\FMC.h" 1
N/**************************************************************************//**
N * @file     FMC.h
N * @version  V3.0
N * $Revision: 6 $
N * $Date: 15/05/20 11:49a $
N * @brief    NUC230_240 Series Flash Memory Controller Driver Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __FMC_H__
N#define __FMC_H__
N
N#include "NUC230_240.h"
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup FMC_Driver FMC Driver
N  @{
N*/
N
N/** @addtogroup FMC_EXPORTED_CONSTANTS FMC Exported Constants
N  @{
N*/
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define Base Address                                                                                     */
N/*---------------------------------------------------------------------------------------------------------*/
N#define FMC_APROM_BASE          0x00000000UL    /*!< APROM  Base Address         */
N#define FMC_LDROM_BASE          0x00100000UL    /*!< LDROM  Base Address         */
N#define FMC_CONFIG_BASE         0x00300000UL    /*!< CONFIG Base Address         */
N
N#define FMC_FLASH_PAGE_SIZE     0x200           /*!< Flash Page Size (512 Bytes) */
N#define FMC_LDROM_SIZE          0x1000          /*!< LDROM Size (4K Bytes)       */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  ISPCON constant definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define FMC_ISPCON_BS_LDROM     0x2     /*!< ISPCON setting to select to boot from LDROM */
N#define FMC_ISPCON_BS_APROM     0x0     /*!< ISPCON setting to select to boot from APROM */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  ISPCMD constant definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define FMC_ISPCMD_READ        0x00     /*!< ISP Command: Read Flash       */
N#define FMC_ISPCMD_PROGRAM     0x21     /*!< ISP Command: Program Flash    */
N#define FMC_ISPCMD_PAGE_ERASE  0x22     /*!< ISP Command: Page Erase Flash */
N#define FMC_ISPCMD_VECMAP      0x2e     /*!< ISP Command: Set VECMAP       */
N#define FMC_ISPCMD_READ_UID    0x04     /*!< ISP Command: Read Unique ID   */
N#define FMC_ISPCMD_READ_CID    0x0B     /*!< ISP Command: Read Company ID   */
N#define FMC_ISPCMD_READ_DID    0x0C     /*!< ISP Command: Read Device ID    */
N
N
N/*@}*/ /* end of group FMC_EXPORTED_CONSTANTS */
N
N/** @addtogroup FMC_EXPORTED_FUNCTIONS FMC Exported Functions
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  FMC Macro Definitions                                                                                  */
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N * @brief      Enable ISP Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will set ISPEN bit of ISPCON control register to enable ISP function.
N *
N */
N#define FMC_ENABLE_ISP()          (FMC->ISPCON |=  FMC_ISPCON_ISPEN_Msk)
N
N
N/**
N * @brief      Disable ISP Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will clear ISPEN bit of ISPCON control register to disable ISP function.
N *
N */
N#define FMC_DISABLE_ISP()         (FMC->ISPCON &= ~FMC_ISPCON_ISPEN_Msk)
N
N
N/**
N * @brief      Enable LDROM Update Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will set LDUEN bit of ISPCON control register to enable LDROM update function.
N *             User needs to set LDUEN bit before they can update LDROM.
N *
N */
N#define FMC_ENABLE_LD_UPDATE()    (FMC->ISPCON |=  FMC_ISPCON_LDUEN_Msk)
N
N
N
N/**
N * @brief      Disable LDROM Update Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will set ISPEN bit of ISPCON control register to disable LDROM update function.
N *
N */
N#define FMC_DISABLE_LD_UPDATE()   (FMC->ISPCON &= ~FMC_ISPCON_LDUEN_Msk)  /*!< Disable LDROM Update Function  */
N
N
N
N/**
N * @brief      Enable User Configuration Update Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will set CFGUEN bit of ISPCON control register to enable User Configuration update function.
N *             User needs to set CFGUEN bit before they can update User Configuration area.
N *
N */
N#define FMC_ENABLE_CFG_UPDATE()   (FMC->ISPCON |=  FMC_ISPCON_CFGUEN_Msk)
N
N/**
N * @brief      Disable User Configuration Update Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will clear CFGUEN bit of ISPCON control register to disable User Configuration update function.
N *
N */
N#define FMC_DISABLE_CFG_UPDATE()  (FMC->ISPCON &= ~FMC_ISPCON_CFGUEN_Msk)           /*!< Disable CONFIG Update Function */
N
N
N/**
N * @brief      Enable APROM Update Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will set APUEN bit of ISPCON control register to enable APROM update function.
N *             User needs to set APUEN bit before they can update APROM in APROM boot mode.
N *
N */
N#define FMC_ENABLE_AP_UPDATE()    (FMC->ISPCON |=  FMC_ISPCON_APUEN_Msk)
N
N
N/**
N * @brief      Disable APROM Update Function
N *
N * @param      None
N *
N * @return     None
N *
N * @details    This function will clear APUEN bit of ISPCON control register to disable APROM update function.
N *
N */
N#define FMC_DISABLE_AP_UPDATE()   (FMC->ISPCON &= ~FMC_ISPCON_APUEN_Msk)            /*!< Disable APROM Update Function  */
N
N/**
N * @brief      Get ISP fail flag
N *
N * @param      None
N *
N * @retval     0 Previous ISP command execution result is successful
N * @retval     1 Previous ISP command execution result is fail
N *
N * @details    ISPFF flag of ISPCON is used to indicate ISP command success or fail.
N *             This function will return the ISPFF flag to identify ISP command OK or fail.
N *
N */
N#define FMC_GET_FAIL_FLAG()       ((FMC->ISPCON & FMC_ISPCON_ISPFF_Msk) ? 1 : 0)
N
N
N/**
N * @brief      Select booting from APROM
N *
N * @param      None
N *
N * @return     None
N *
N * @details    If MCU is working without IAP, user need to set BS bit of ISPCON and reset CPU to execute the code of LDROM/APROM.
N *             This function is used to set BS bit of ISPCON to boot to APROM.
N *
N * @note       To valid new BS bit setting, user also need to trigger CPU reset or System Reset Request after setting BS bit.
N *
N */
N#define FMC_SET_APROM_BOOT()      (FMC->ISPCON &= ~FMC_ISPCON_BS_Msk)
N
N/**
N * @brief      Select booting from APROM
N *
N * @param      None
N *
N * @return     None
N *
N * @details    If MCU is working without IAP, user need to set/clear BS bit of ISPCON and reset CPU to execute the code of APROM/LDROM.
N *             This function is used to clear BS bit of ISPCON to boot to LDROM.
N *
N * @note       To valid new BS bit setting, user also need to trigger CPU reset or System Reset Request after clear BS bit.
N *
N */
N#define FMC_SET_LDROM_BOOT()      (FMC->ISPCON |= FMC_ISPCON_BS_Msk)
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* inline functions                                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N * @brief      Program 32-bit data into specified address of flash
N *
N * @param[in]  u32addr  Flash address include APROM, LDROM, Data Flash, and CONFIG
N * @param[in]  u32data  32-bit Data to program
N *
N * @return     None
N *
N * @details    To program word data into Flash include APROM, LDROM, Data Flash, and CONFIG.
N *             The corresponding functions in CONFIG are listed in FMC section of Technical Reference Manual.
N *
N */
Nstatic __INLINE void FMC_Write(uint32_t u32addr, uint32_t u32data)
Xstatic __inline void FMC_Write(uint32_t u32addr, uint32_t u32data)
N{
N    FMC->ISPCMD = FMC_ISPCMD_PROGRAM;   /* Set ISP Command Code */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x21;    
N    FMC->ISPADR = u32addr;              /* Set Target ROM Address. The address must be word alignment. */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADR = u32addr;               
N    FMC->ISPDAT = u32data;              /* Set Data to Program */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT = u32data;               
N    FMC->ISPTRG = 0x1;                  /* Trigger to start ISP procedure */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = 0x1;                   
N    __ISB();                            /* To make sure ISP/CPU be Synchronized */
X    __isb(0xF);                             
N    while(FMC->ISPTRG);                 /* Waiting for ISP Done */
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG);                  
N}
N
N/**
N * @brief       Read 32-bit Data from specified address of flash
N *
N * @param[in]   u32addr  Flash address include APROM, LDROM, Data Flash, and CONFIG
N *
N * @return      The data of specified address
N *
N * @details     To read word data from Flash include APROM, LDROM, Data Flash, and CONFIG.
N *
N */
Nstatic __INLINE uint32_t FMC_Read(uint32_t u32addr)
Xstatic __inline uint32_t FMC_Read(uint32_t u32addr)
N{
N    FMC->ISPCMD = FMC_ISPCMD_READ; /* Set ISP Command Code */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x00;  
N    FMC->ISPADR = u32addr;         /* Set Target ROM Address. The address must be word alignment. */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADR = u32addr;          
N    FMC->ISPTRG = 0x1;             /* Trigger to start ISP procedure */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = 0x1;              
N    __ISB();                       /* To make sure ISP/CPU be Synchronized */
X    __isb(0xF);                        
N    while(FMC->ISPTRG);            /* Waiting for ISP Done */
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG);             
N
N    return FMC->ISPDAT;
X    return ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT;
N}
N
N
N/**
N * @brief      Flash page erase
N *
N * @param[in]  u32addr  Flash address including APROM, LDROM, Data Flash, and CONFIG
N *
N * @details    To do flash page erase. The target address could be APROM, LDROM, Data Flash, or CONFIG.
N *             The page size is 512 bytes.
N *
N * @retval      0 Success
N * @retval     -1 Erase failed
N *
N */
Nstatic __INLINE int32_t FMC_Erase(uint32_t u32addr)
Xstatic __inline int32_t FMC_Erase(uint32_t u32addr)
N{
N    FMC->ISPCMD = FMC_ISPCMD_PAGE_ERASE; /* Set ISP Command Code */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x22;  
N    FMC->ISPADR = u32addr;               /* Set Target ROM Address. The address must be page alignment. */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADR = u32addr;                
N    FMC->ISPTRG = 0x1;                   /* Trigger to start ISP procedure */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = 0x1;                    
N    __ISB();                             /* To make sure ISP/CPU be Synchronized */
X    __isb(0xF);                              
N    while(FMC->ISPTRG);                  /* Waiting for ISP Done */
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG);                   
N
N    /* Check ISPFF flag to know whether erase OK or fail. */
N    if(FMC->ISPCON & FMC_ISPCON_ISPFF_Msk)
X    if(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCON & (1ul << 6))
N    {
N        FMC->ISPCON |= FMC_ISPCON_ISPFF_Msk;
X        ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCON |= (1ul << 6);
N        return -1;
N    }
N    return 0;
N}
N
N/**
N * @brief       Read Unique ID
N *
N * @param[in]   u8index  UID index. 0 = UID[31:0], 1 = UID[63:32], 2 = UID[95:64]
N *
N * @return      The 32-bit unique ID data of specified UID index.
N *
N * @details     To read out 96-bit Unique ID.
N *
N */
Nstatic __INLINE uint32_t FMC_ReadUID(uint8_t u8index)
Xstatic __inline uint32_t FMC_ReadUID(uint8_t u8index)
N{
N    FMC->ISPCMD = FMC_ISPCMD_READ_UID; /* Set ISP Command Code */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x04;  
N    FMC->ISPADR = (u8index << 2);      /* Set UID Address. It must be word alignment. */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADR = (u8index << 2);       
N    FMC->ISPTRG = 0x1;                 /* Trigger to start ISP procedure */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = 0x1;                  
N    __ISB();                           /* To make sure ISP/CPU be Synchronized */
X    __isb(0xF);                            
N    while(FMC->ISPTRG);                /* Waiting for ISP Done */
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG);                 
N
N    return FMC->ISPDAT;
X    return ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT;
N}
N
N
N/**
N  * @brief    Read company ID
N  *
N  * @param    None
N  *
N  * @return   The company ID (32-bit)
N  *
N  * @details  The company ID of Nuvoton is fixed to be 0xDA
N  *
N  */
Nstatic __INLINE uint32_t FMC_ReadCID(void)
Xstatic __inline uint32_t FMC_ReadCID(void)
N{
N    FMC->ISPCMD = FMC_ISPCMD_READ_CID;           /* Set ISP Command Code */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x0B;            
N    FMC->ISPADR = 0x0;                           /* Must keep 0x0 when read CID */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADR = 0x0;                            
N    FMC->ISPTRG = FMC_ISPTRG_ISPGO_Msk;          /* Trigger to start ISP procedure */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = (1ul << 0);           
N    __ISB();                                     /* To make sure ISP/CPU be Synchronized */
X    __isb(0xF);                                      
N    while(FMC->ISPTRG & FMC_ISPTRG_ISPGO_Msk) ;  /* Waiting for ISP Done */
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG & (1ul << 0)) ;   
N
N    return FMC->ISPDAT;
X    return ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT;
N}
N
N/**
N  * @brief    Read product ID
N  *
N  * @param    None
N  *
N  * @return   The product ID (32-bit)
N  *
N  * @details  This function is used to read product ID.
N  *
N  */
Nstatic __INLINE uint32_t FMC_ReadPID(void)
Xstatic __inline uint32_t FMC_ReadPID(void)
N{
N    FMC->ISPCMD = FMC_ISPCMD_READ_DID;          /* Set ISP Command Code */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x0C;           
N    FMC->ISPADR = 0x04;                         /* Must keep 0x4 when read PID */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADR = 0x04;                          
N    FMC->ISPTRG = FMC_ISPTRG_ISPGO_Msk;         /* Trigger to start ISP procedure */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = (1ul << 0);          
N    __ISB();                                    /* To make sure ISP/CPU be Synchronized */
X    __isb(0xF);                                     
N    while(FMC->ISPTRG & FMC_ISPTRG_ISPGO_Msk);  /* Waiting for ISP Done */
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG & (1ul << 0));   
N
N    return FMC->ISPDAT;
X    return ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT;
N}
N
N/**
N  * @brief      To read UCID
N  *
N  * @param[in]  u32Index    Index of the UCID to read. u32Index must be 0, 1, 2, or 3.
N  *
N  * @return     The UCID of specified index
N  *
N  * @details    This function is used to read unique chip ID (UCID).
N  *
N  */
Nstatic __INLINE uint32_t FMC_ReadUCID(uint32_t u32Index)
Xstatic __inline uint32_t FMC_ReadUCID(uint32_t u32Index)
N{
N    FMC->ISPCMD = FMC_ISPCMD_READ_UID;          /* Set ISP Command Code */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x04;           
N    FMC->ISPADR = (0x04 * u32Index) + 0x10;     /* The UCID is at offset 0x10 with word alignment. */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADR = (0x04 * u32Index) + 0x10;      
N    FMC->ISPTRG = FMC_ISPTRG_ISPGO_Msk;         /* Trigger to start ISP procedure */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = (1ul << 0);          
N    __ISB();                                    /* To make sure ISP/CPU be Synchronized */
X    __isb(0xF);                                     
N    while(FMC->ISPTRG & FMC_ISPTRG_ISPGO_Msk);  /* Waiting for ISP Done */
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG & (1ul << 0));   
N
N    return FMC->ISPDAT;
X    return ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPDAT;
N}
N
N
N
N/**
N * @brief       Set vector mapping address
N *
N * @param[in]   u32PageAddr  The page address to remap to address 0x0. The address must be page alignment.
N *
N * @return      None
N *
N * @details     This function is used to set VECMAP to map specified page to vector page (0x0).
N *
N * @note
N *              VECMAP only valid when new IAP function is enabled. (CBS = 10'b or 00'b)
N *
N */
Nstatic __INLINE void FMC_SetVectorPageAddr(uint32_t u32PageAddr)
Xstatic __inline void FMC_SetVectorPageAddr(uint32_t u32PageAddr)
N{
N    FMC->ISPCMD = FMC_ISPCMD_VECMAP; /* Set ISP Command Code */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPCMD = 0x2e;  
N    FMC->ISPADR = u32PageAddr;       /* The address of specified page which will be map to address 0x0. It must be page alignment. */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPADR = u32PageAddr;        
N    FMC->ISPTRG = 0x1;               /* Trigger to start ISP procedure */
X    ((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG = 0x1;                
N    __ISB();                         /* To make sure ISP/CPU be Synchronized */
X    __isb(0xF);                          
N    while(FMC->ISPTRG);              /* Waiting for ISP Done */
X    while(((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPTRG);               
N}
N
N
N/**
N * @brief       Get current vector mapping address.
N *
N * @param       None
N *
N * @return      The current vector mapping address.
N *
N * @details     To get VECMAP value which is the page address for remapping to vector page (0x0).
N *
N * @note
N *              VECMAP only valid when new IAP function is enabled. (CBS = 10'b or 00'b)
N *
N */
Nstatic __INLINE uint32_t FMC_GetVECMAP(void)
Xstatic __inline uint32_t FMC_GetVECMAP(void)
N{
N    return (FMC->ISPSTA & FMC_ISPSTA_VECMAP_Msk);
X    return (((FMC_T *) ((( uint32_t)0x50000000) + 0x0C000))->ISPSTA & (0xFFFul << 9));
N}
N
Nextern void FMC_Open(void);
Nextern void FMC_Close(void);
Nextern void FMC_EnableAPUpdate(void);
Nextern void FMC_DisableAPUpdate(void);
Nextern void FMC_EnableConfigUpdate(void);
Nextern void FMC_DisableConfigUpdate(void);
Nextern void FMC_EnableLDUpdate(void);
Nextern void FMC_DisableLDUpdate(void);
Nextern int32_t FMC_ReadConfig(uint32_t *u32Config, uint32_t u32Count);
Nextern int32_t FMC_WriteConfig(uint32_t *u32Config, uint32_t u32Count);
Nextern void FMC_SetBootSource(int32_t i32BootSrc);
Nextern int32_t FMC_GetBootSource(void);
Nextern uint32_t FMC_ReadDataFlashBaseAddr(void);
N
N/*@}*/ /* end of group FMC_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group FMC_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N
N#endif
N
L 12446 ".\Libraries\Device\Nuvoton\NUC230_240\Include\NUC230_240.h" 2
N#include "GPIO.h"
L 1 ".\Libraries\StdDriver\inc\GPIO.h" 1
N/**************************************************************************//**
N * @file     GPIO.h
N * @version  V3.00
N * $Revision: 4 $
N * $Date: 15/05/06 10:18a $
N * @brief    NUC230_240 Series General Purpose I/O Driver Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __GPIO_H__
N#define __GPIO_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup GPIO_Driver GPIO Driver
N  @{
N*/
N
N/** @addtogroup GPIO_EXPORTED_CONSTANTS GPIO Exported Constants
N  @{
N*/
N#define GPIO_PIN_MAX            16 /*!< Specify Maximum Pins of Each GPIO Port */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PMD Constant Definitions                                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_PMD_INPUT          0x0UL /*!< Input Mode */
N#define GPIO_PMD_OUTPUT         0x1UL /*!< Output Mode */
N#define GPIO_PMD_OPEN_DRAIN     0x2UL /*!< Open-Drain Mode */
N#define GPIO_PMD_QUASI          0x3UL /*!< Quasi-bidirectional Mode */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  GPIO Interrupt Type Constant Definitions                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_INT_RISING         0x00010000UL /*!< Interrupt enable by Input Rising Edge */
N#define GPIO_INT_FALLING        0x00000001UL /*!< Interrupt enable by Input Falling Edge */
N#define GPIO_INT_BOTH_EDGE      0x00010001UL /*!< Interrupt enable by both Rising Edge and Falling Edge */
N#define GPIO_INT_HIGH           0x01010000UL /*!< Interrupt enable by Level-High */
N#define GPIO_INT_LOW            0x01000001UL /*!< Interrupt enable by Level-Level */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  IMD Constant Definitions                                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_IMD_EDGE           0UL /*!< IMD Setting for Edge Trigger Mode */
N#define GPIO_IMD_LEVEL          1UL /*!< IMD Setting for Edge Level Mode */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  DBNCECON Constant Definitions                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define GPIO_INT_CLK_ON         0x00000020UL /*!< DBNCECON setting for all IO pins edge detection circuit is always active after reset */
N#define GPIO_INT_CLK_OFF        0x00000000UL /*!< DBNCECON setting for edge detection circuit is active only if IO pin corresponding GPIOx_IEN bit is set to 1 */
N
N#define GPIO_DBCLKSRC_LIRC      0x00000010UL /*!< DBNCECON setting for de-bounce counter clock source is the internal 10 kHz */
N#define GPIO_DBCLKSRC_HCLK      0x00000000UL /*!< DBNCECON setting for de-bounce counter clock source is the HCLK */
N
N#define GPIO_DBCLKSEL_1         0x00000000UL /*!< DBNCECON setting for sampling cycle = 1 clocks */
N#define GPIO_DBCLKSEL_2         0x00000001UL /*!< DBNCECON setting for sampling cycle = 2 clocks */
N#define GPIO_DBCLKSEL_4         0x00000002UL /*!< DBNCECON setting for sampling cycle = 4 clocks */
N#define GPIO_DBCLKSEL_8         0x00000003UL /*!< DBNCECON setting for sampling cycle = 8 clocks */
N#define GPIO_DBCLKSEL_16        0x00000004UL /*!< DBNCECON setting for sampling cycle = 16 clocks */
N#define GPIO_DBCLKSEL_32        0x00000005UL /*!< DBNCECON setting for sampling cycle = 32 clocks */
N#define GPIO_DBCLKSEL_64        0x00000006UL /*!< DBNCECON setting for sampling cycle = 64 clocks */
N#define GPIO_DBCLKSEL_128       0x00000007UL /*!< DBNCECON setting for sampling cycle = 128 clocks */
N#define GPIO_DBCLKSEL_256       0x00000008UL /*!< DBNCECON setting for sampling cycle = 256 clocks */
N#define GPIO_DBCLKSEL_512       0x00000009UL /*!< DBNCECON setting for sampling cycle = 512 clocks */
N#define GPIO_DBCLKSEL_1024      0x0000000AUL /*!< DBNCECON setting for sampling cycle = 1024 clocks */
N#define GPIO_DBCLKSEL_2048      0x0000000BUL /*!< DBNCECON setting for sampling cycle = 2048 clocks */
N#define GPIO_DBCLKSEL_4096      0x0000000CUL /*!< DBNCECON setting for sampling cycle = 4096 clocks */
N#define GPIO_DBCLKSEL_8192      0x0000000DUL /*!< DBNCECON setting for sampling cycle = 8192 clocks */
N#define GPIO_DBCLKSEL_16384     0x0000000EUL /*!< DBNCECON setting for sampling cycle = 16384 clocks */
N#define GPIO_DBCLKSEL_32768     0x0000000FUL /*!< DBNCECON setting for sampling cycle = 32768 clocks */
N
N
N/* Define GPIO Pin Data Input/Output. It could be used to control each I/O pin by pin address mapping.
N   Example 1:
N
N       PA0 = 1;
N
N   It is used to set GPIO PA.0 to high;
N
N   Example 2:
N
N       if (PA0)
N           PA0 = 0;
N
N   If GPIO PA.0 pin status is high, then set GPIO PA.0 data output to low.
N */
N#define GPIO_PIN_DATA(port, pin)    (*((volatile uint32_t *)((GPIO_PIN_DATA_BASE+(0x40*(port))) + ((pin)<<2))))
N#define PA0             GPIO_PIN_DATA(0, 0 ) /*!< Specify PA.0 Pin Data Input/Output */
N#define PA1             GPIO_PIN_DATA(0, 1 ) /*!< Specify PA.1 Pin Data Input/Output */
N#define PA2             GPIO_PIN_DATA(0, 2 ) /*!< Specify PA.2 Pin Data Input/Output */
N#define PA3             GPIO_PIN_DATA(0, 3 ) /*!< Specify PA.3 Pin Data Input/Output */
N#define PA4             GPIO_PIN_DATA(0, 4 ) /*!< Specify PA.4 Pin Data Input/Output */
N#define PA5             GPIO_PIN_DATA(0, 5 ) /*!< Specify PA.5 Pin Data Input/Output */
N#define PA6             GPIO_PIN_DATA(0, 6 ) /*!< Specify PA.6 Pin Data Input/Output */
N#define PA7             GPIO_PIN_DATA(0, 7 ) /*!< Specify PA.7 Pin Data Input/Output */
N#define PA8             GPIO_PIN_DATA(0, 8 ) /*!< Specify PA.8 Pin Data Input/Output */
N#define PA9             GPIO_PIN_DATA(0, 9 ) /*!< Specify PA.9 Pin Data Input/Output */
N#define PA10            GPIO_PIN_DATA(0, 10) /*!< Specify PA.10 Pin Data Input/Output */
N#define PA11            GPIO_PIN_DATA(0, 11) /*!< Specify PA.11 Pin Data Input/Output */
N#define PA12            GPIO_PIN_DATA(0, 12) /*!< Specify PA.12 Pin Data Input/Output */
N#define PA13            GPIO_PIN_DATA(0, 13) /*!< Specify PA.13 Pin Data Input/Output */
N#define PA14            GPIO_PIN_DATA(0, 14) /*!< Specify PA.14 Pin Data Input/Output */
N#define PA15            GPIO_PIN_DATA(0, 15) /*!< Specify PA.15 Pin Data Input/Output */
N#define PB0             GPIO_PIN_DATA(1, 0 ) /*!< Specify PB.0 Pin Data Input/Output */
N#define PB1             GPIO_PIN_DATA(1, 1 ) /*!< Specify PB.1 Pin Data Input/Output */
N#define PB2             GPIO_PIN_DATA(1, 2 ) /*!< Specify PB.2 Pin Data Input/Output */
N#define PB3             GPIO_PIN_DATA(1, 3 ) /*!< Specify PB.3 Pin Data Input/Output */
N#define PB4             GPIO_PIN_DATA(1, 4 ) /*!< Specify PB.4 Pin Data Input/Output */
N#define PB5             GPIO_PIN_DATA(1, 5 ) /*!< Specify PB.5 Pin Data Input/Output */
N#define PB6             GPIO_PIN_DATA(1, 6 ) /*!< Specify PB.6 Pin Data Input/Output */
N#define PB7             GPIO_PIN_DATA(1, 7 ) /*!< Specify PB.7 Pin Data Input/Output */
N#define PB8             GPIO_PIN_DATA(1, 8 ) /*!< Specify PB.8 Pin Data Input/Output */
N#define PB9             GPIO_PIN_DATA(1, 9 ) /*!< Specify PB.9 Pin Data Input/Output */
N#define PB10            GPIO_PIN_DATA(1, 10) /*!< Specify PB.10 Pin Data Input/Output */
N#define PB11            GPIO_PIN_DATA(1, 11) /*!< Specify PB.11 Pin Data Input/Output */
N#define PB12            GPIO_PIN_DATA(1, 12) /*!< Specify PB.12 Pin Data Input/Output */
N#define PB13            GPIO_PIN_DATA(1, 13) /*!< Specify PB.13 Pin Data Input/Output */
N#define PB14            GPIO_PIN_DATA(1, 14) /*!< Specify PB.14 Pin Data Input/Output */
N#define PB15            GPIO_PIN_DATA(1, 15) /*!< Specify PB.15 Pin Data Input/Output */
N#define PC0             GPIO_PIN_DATA(2, 0 ) /*!< Specify PC.0 Pin Data Input/Output */
N#define PC1             GPIO_PIN_DATA(2, 1 ) /*!< Specify PC.1 Pin Data Input/Output */
N#define PC2             GPIO_PIN_DATA(2, 2 ) /*!< Specify PC.2 Pin Data Input/Output */
N#define PC3             GPIO_PIN_DATA(2, 3 ) /*!< Specify PC.3 Pin Data Input/Output */
N#define PC4             GPIO_PIN_DATA(2, 4 ) /*!< Specify PC.4 Pin Data Input/Output */
N#define PC5             GPIO_PIN_DATA(2, 5 ) /*!< Specify PC.5 Pin Data Input/Output */
N#define PC6             GPIO_PIN_DATA(2, 6 ) /*!< Specify PC.6 Pin Data Input/Output */
N#define PC7             GPIO_PIN_DATA(2, 7 ) /*!< Specify PC.7 Pin Data Input/Output */
N#define PC8             GPIO_PIN_DATA(2, 8 ) /*!< Specify PC.8 Pin Data Input/Output */
N#define PC9             GPIO_PIN_DATA(2, 9 ) /*!< Specify PC.9 Pin Data Input/Output */
N#define PC10            GPIO_PIN_DATA(2, 10) /*!< Specify PC.10 Pin Data Input/Output */
N#define PC11            GPIO_PIN_DATA(2, 11) /*!< Specify PC.11 Pin Data Input/Output */
N#define PC12            GPIO_PIN_DATA(2, 12) /*!< Specify PC.12 Pin Data Input/Output */
N#define PC13            GPIO_PIN_DATA(2, 13) /*!< Specify PC.13 Pin Data Input/Output */
N#define PC14            GPIO_PIN_DATA(2, 14) /*!< Specify PC.14 Pin Data Input/Output */
N#define PC15            GPIO_PIN_DATA(2, 15) /*!< Specify PC.15 Pin Data Input/Output */
N#define PD0             GPIO_PIN_DATA(3, 0 ) /*!< Specify PD.0 Pin Data Input/Output */
N#define PD1             GPIO_PIN_DATA(3, 1 ) /*!< Specify PD.1 Pin Data Input/Output */
N#define PD2             GPIO_PIN_DATA(3, 2 ) /*!< Specify PD.2 Pin Data Input/Output */
N#define PD3             GPIO_PIN_DATA(3, 3 ) /*!< Specify PD.3 Pin Data Input/Output */
N#define PD4             GPIO_PIN_DATA(3, 4 ) /*!< Specify PD.4 Pin Data Input/Output */
N#define PD5             GPIO_PIN_DATA(3, 5 ) /*!< Specify PD.5 Pin Data Input/Output */
N#define PD6             GPIO_PIN_DATA(3, 6 ) /*!< Specify PD.6 Pin Data Input/Output */
N#define PD7             GPIO_PIN_DATA(3, 7 ) /*!< Specify PD.7 Pin Data Input/Output */
N#define PD8             GPIO_PIN_DATA(3, 8 ) /*!< Specify PD.8 Pin Data Input/Output */
N#define PD9             GPIO_PIN_DATA(3, 9 ) /*!< Specify PD.9 Pin Data Input/Output */
N#define PD10            GPIO_PIN_DATA(3, 10) /*!< Specify PD.10 Pin Data Input/Output */
N#define PD11            GPIO_PIN_DATA(3, 11) /*!< Specify PD.11 Pin Data Input/Output */
N#define PD12            GPIO_PIN_DATA(3, 12) /*!< Specify PD.12 Pin Data Input/Output */
N#define PD13            GPIO_PIN_DATA(3, 13) /*!< Specify PD.13 Pin Data Input/Output */
N#define PD14            GPIO_PIN_DATA(3, 14) /*!< Specify PD.14 Pin Data Input/Output */
N#define PD15            GPIO_PIN_DATA(3, 15) /*!< Specify PD.15 Pin Data Input/Output */
N#define PE0             GPIO_PIN_DATA(4, 0 ) /*!< Specify PE.0 Pin Data Input/Output */
N#define PE1             GPIO_PIN_DATA(4, 1 ) /*!< Specify PE.1 Pin Data Input/Output */
N#define PE2             GPIO_PIN_DATA(4, 2 ) /*!< Specify PE.2 Pin Data Input/Output */
N#define PE3             GPIO_PIN_DATA(4, 3 ) /*!< Specify PE.3 Pin Data Input/Output */
N#define PE4             GPIO_PIN_DATA(4, 4 ) /*!< Specify PE.4 Pin Data Input/Output */
N#define PE5             GPIO_PIN_DATA(4, 5 ) /*!< Specify PE.5 Pin Data Input/Output */
N#define PE6             GPIO_PIN_DATA(4, 6 ) /*!< Specify PE.6 Pin Data Input/Output */
N#define PE7             GPIO_PIN_DATA(4, 7 ) /*!< Specify PE.7 Pin Data Input/Output */
N#define PE8             GPIO_PIN_DATA(4, 8 ) /*!< Specify PE.8 Pin Data Input/Output */
N#define PE9             GPIO_PIN_DATA(4, 9 ) /*!< Specify PE.9 Pin Data Input/Output */
N#define PE10            GPIO_PIN_DATA(4, 10) /*!< Specify PE.10 Pin Data Input/Output */
N#define PE11            GPIO_PIN_DATA(4, 11) /*!< Specify PE.11 Pin Data Input/Output */
N#define PE12            GPIO_PIN_DATA(4, 12) /*!< Specify PE.12 Pin Data Input/Output */
N#define PE13            GPIO_PIN_DATA(4, 13) /*!< Specify PE.13 Pin Data Input/Output */
N#define PE14            GPIO_PIN_DATA(4, 14) /*!< Specify PE.14 Pin Data Input/Output */
N#define PE15            GPIO_PIN_DATA(4, 15) /*!< Specify PE.15 Pin Data Input/Output */
N#define PF0             GPIO_PIN_DATA(5, 0 ) /*!< Specify PF.0 Pin Data Input/Output */
N#define PF1             GPIO_PIN_DATA(5, 1 ) /*!< Specify PF.1 Pin Data Input/Output */
N#define PF2             GPIO_PIN_DATA(5, 2 ) /*!< Specify PF.2 Pin Data Input/Output */
N#define PF3             GPIO_PIN_DATA(5, 3 ) /*!< Specify PF.3 Pin Data Input/Output */
N
N
N/*@}*/ /* end of group GPIO_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup GPIO_EXPORTED_FUNCTIONS GPIO Exported Functions
N  @{
N*/
N
N/**
N * @brief       Clear GPIO Pin Interrupt Flag
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port.
N *                          It could be BIT0 ~ BIT15 for PA, PB, PC, PD and PE GPIO port.
N *                          It could be BIT0 ~ BIT3 for PF GPIO port.
N *
N * @return      None
N *
N * @details     Clear the interrupt status of specified GPIO pin.
N */
N#define GPIO_CLR_INT_FLAG(port, u32PinMask)         ((port)->ISRC = (u32PinMask))
N
N/**
N * @brief       Disable Pin De-bounce Function
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port.
N *                          It could be BIT0 ~ BIT15 for PA, PB, PC, PD and PE GPIO port.
N *                          It could be BIT0 ~ BIT3 for PF GPIO port.
N *
N * @return      None
N *
N * @details     Disable the interrupt de-bounce function of specified GPIO pin.
N */
N#define GPIO_DISABLE_DEBOUNCE(port, u32PinMask)     ((port)->DBEN &= ~(u32PinMask))
N
N/**
N * @brief       Enable Pin De-bounce Function
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port.
N *                          It could be BIT0 ~ BIT15 for PA, PB, PC, PD and PE GPIO port.
N *                          It could be BIT0 ~ BIT3 for PF GPIO port.
N *
N * @return      None
N *
N * @details     Enable the interrupt de-bounce function of specified GPIO pin.
N */
N#define GPIO_ENABLE_DEBOUNCE(port, u32PinMask)      ((port)->DBEN |= (u32PinMask))
N
N/**
N * @brief       Disable I/O Digital Input Path
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port.
N *                          It could be BIT0 ~ BIT15 for PA, PB, PC, PD and PE GPIO port.
N *                          It could be BIT0 ~ BIT3 for PF GPIO port.
N *
N * @return      None
N *
N * @details     Disable I/O digital input path of specified GPIO pin.
N */
N#define GPIO_DISABLE_DIGITAL_PATH(port, u32PinMask) ((port)->OFFD |= ((u32PinMask)<<16))
N
N/**
N * @brief       Enable I/O Digital Input Path
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port.
N *                          It could be BIT0 ~ BIT15 for PA, PB, PC, PD and PE GPIO port.
N *                          It could be BIT0 ~ BIT3 for PF GPIO port.
N *
N * @return      None
N *
N * @details     Enable I/O digital input path of specified GPIO pin.
N */
N#define GPIO_ENABLE_DIGITAL_PATH(port, u32PinMask)  ((port)->OFFD &= ~((u32PinMask)<<16))
N
N/**
N * @brief       Disable I/O DOUT mask
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port.
N *                          It could be BIT0 ~ BIT15 for PA, PB, PC, PD and PE GPIO port.
N *                          It could be BIT0 ~ BIT3 for PF GPIO port.
N *
N * @return      None
N *
N * @details     Disable I/O DOUT mask of specified GPIO pin.
N */
N#define GPIO_DISABLE_DOUT_MASK(port, u32PinMask)    ((port)->DMASK &= ~(u32PinMask))
N
N/**
N * @brief       Enable I/O DOUT mask
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port.
N *                          It could be BIT0 ~ BIT15 for PA, PB, PC, PD and PE GPIO port.
N *                          It could be BIT0 ~ BIT3 for PF GPIO port.
N *
N * @return      None
N *
N * @details     Enable I/O DOUT mask of specified GPIO pin.
N */
N#define GPIO_ENABLE_DOUT_MASK(port, u32PinMask) ((port)->DMASK |= (u32PinMask))
N
N/**
N * @brief       Get GPIO Pin Interrupt Flag
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32PinMask  The single or multiple pins of specified GPIO port.
N *                          It could be BIT0 ~ BIT15 for PA, PB, PC, PD and PE GPIO port.
N *                          It could be BIT0 ~ BIT3 for PF GPIO port.
N *
N * @retval      0           No interrupt at specified GPIO pin
N * @retval      1           The specified GPIO pin generate an interrupt
N *
N * @details     Get the interrupt status of specified GPIO pin.
N */
N#define GPIO_GET_INT_FLAG(port, u32PinMask)     ((port)->ISRC & (u32PinMask))
N
N/**
N * @brief       Set De-bounce Sampling Cycle Time
N *
N * @param[in]   u32ClkSrc    The de-bounce counter clock source. It could be GPIO_DBCLKSRC_HCLK or GPIO_DBCLKSRC_LIRC.
N * @param[in]   u32ClkSel    The de-bounce sampling cycle selection. It could be \n
N *                              GPIO_DBCLKSEL_1, GPIO_DBCLKSEL_2, GPIO_DBCLKSEL_4, GPIO_DBCLKSEL_8, \n
N *                              GPIO_DBCLKSEL_16, GPIO_DBCLKSEL_32, GPIO_DBCLKSEL_64, GPIO_DBCLKSEL_128, \n
N *                              GPIO_DBCLKSEL_256, GPIO_DBCLKSEL_512, GPIO_DBCLKSEL_1024, GPIO_DBCLKSEL_2048, \n
N *                              GPIO_DBCLKSEL_4096, GPIO_DBCLKSEL_8192, GPIO_DBCLKSEL_16384, GPIO_DBCLKSEL_32768.
N *
N * @return      None
N *
N * @details     Set the interrupt de-bounce sampling cycle time based on the debounce counter clock source. \n
N *              Example: _GPIO_SET_DEBOUNCE_TIME(GPIO_DBNCECON_DBCLKSRC_IRC10K, GPIO_DBNCECON_DBCLKSEL_4). \n
N *              It's meaning the De-debounce counter clock source is internal 10 KHz and sampling cycle selection is 4. \n
N *              Then the target de-bounce sampling cycle time is (2^4)*(1/(10*1000)) s = 16*0.0001 s = 1600 us,
N *              and system will sampling interrupt input once per 1600 us.
N */
N#define GPIO_SET_DEBOUNCE_TIME(u32ClkSrc, u32ClkSel)    (GPIO->DBNCECON = (GPIO_DBNCECON_ICLK_ON_Msk | (u32ClkSrc) | (u32ClkSel)))
N
N/**
N * @brief       Get GPIO Port IN Data
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N *
N * @retval      The specified port data
N *
N * @details     Get the PIN register of specified GPIO port.
N */
N#define GPIO_GET_IN_DATA(port)  ((port)->PIN)
N
N/**
N * @brief       Set GPIO Port OUT Data
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32Data     GPIO port data.
N *
N * @return      None
N *
N * @details     Set the Data into specified GPIO port.
N */
N#define GPIO_SET_OUT_DATA(port, u32Data)    ((port)->DOUT = (u32Data))
N
N/**
N * @brief       Toggle Specified GPIO pin
N *
N * @param[in]   u32Pin      Pxy
N *
N * @return      None
N *
N * @details     Toggle the specified GPIO pint.
N */
N#define GPIO_TOGGLE(u32Pin) ((u32Pin) ^= 1)
N
N/**
N * @brief       Enable External GPIO Interrupt 0
N *
N * @param[in]   port            GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32Pin          The pin of specified GPIO port.
N *                              It could be 0 ~ 15 for PA, PB, PC, PD and PE GPIO port.
N *                              It could be 0 ~ 3 for PF GPIO port.
N * @param[in]   u32IntAttribs   The interrupt attribute of specified GPIO pin. It could be \n
N *                              GPIO_INT_RISING, GPIO_INT_FALLING, GPIO_INT_BOTH_EDGE, GPIO_INT_HIGH, GPIO_INT_LOW.
N *
N * @return      None
N *
N * @details     This function is used to enable specified GPIO pin interrupt.
N */
N#define GPIO_EnableEINT0    GPIO_EnableInt
N
N
N/**
N * @brief       Disable External GPIO Interrupt 0
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32Pin      The pin of specified GPIO port.
N *                          It could be 0 ~ 15 for PA, PB, PC, PD and PE GPIO port.
N *                          It could be 0 ~ 3 for PF GPIO port.
N *
N * @return      None
N *
N * @details     This function is used to enable specified GPIO pin interrupt.
N */
N#define GPIO_DisableEINT0   GPIO_DisableInt
N
N
N/**
N * @brief       Enable External GPIO Interrupt 1
N *
N * @param[in]   port            GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32Pin          The pin of specified GPIO port.
N *                              It could be 0 ~ 15 for PA, PB, PC, PD and PE GPIO port.
N *                              It could be 0 ~ 3 for PF GPIO port.
N * @param[in]   u32IntAttribs   The interrupt attribute of specified GPIO pin. It could be \n
N *                              GPIO_INT_RISING, GPIO_INT_FALLING, GPIO_INT_BOTH_EDGE, GPIO_INT_HIGH, GPIO_INT_LOW.
N *
N * @return      None
N *
N * @details     This function is used to enable specified GPIO pin interrupt.
N */
N#define GPIO_EnableEINT1    GPIO_EnableInt
N
N
N/**
N * @brief       Disable External GPIO Interrupt 1
N *
N * @param[in]   port        GPIO port. It could be PA, PB, PC, PD, PE or PF.
N * @param[in]   u32Pin      The pin of specified GPIO port.
N *                          It could be 0 ~ 15 for PA, PB, PC, PD and PE GPIO port.
N *                          It could be 0 ~ 3 for PF GPIO port.
N *
N * @return      None
N *
N * @details     This function is used to enable specified GPIO pin interrupt.
N */
N#define GPIO_DisableEINT1   GPIO_DisableInt
N
N
Nvoid GPIO_SetMode(GPIO_T *port, uint32_t u32PinMask, uint32_t u32Mode);
Nvoid GPIO_EnableInt(GPIO_T *port, uint32_t u32Pin, uint32_t u32IntAttribs);
Nvoid GPIO_DisableInt(GPIO_T *port, uint32_t u32Pin);
N
N
N/*@}*/ /* end of group GPIO_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group GPIO_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__GPIO_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 12447 ".\Libraries\Device\Nuvoton\NUC230_240\Include\NUC230_240.h" 2
N#include "I2C.h"
L 1 ".\Libraries\StdDriver\inc\I2C.h" 1
N/**************************************************************************//**
N * @file     I2C.h
N * @version  V3.0
N * $Revision: 6 $
N * $Date: 15/05/22 11:23a $
N * @brief    NUC230_240 Series I2C Driver Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __I2C_H__
N#define __I2C_H__
N
N#include "NUC230_240.h"
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup I2C_Driver I2C Driver
N  @{
N*/
N
N/** @addtogroup I2C_EXPORTED_CONSTANTS I2C Exported Constants
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  I2CON constant definitions.                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define I2C_I2CON_STA_SI            0x28UL /*!< I2CON setting for I2C control bits. It would set STA and SI bits          */
N#define I2C_I2CON_STA_SI_AA         0x2CUL /*!< I2CON setting for I2C control bits. It would set STA, SI and AA bits      */
N#define I2C_I2CON_STO_SI            0x18UL /*!< I2CON setting for I2C control bits. It would set STO and SI bits          */
N#define I2C_I2CON_STO_SI_AA         0x1CUL /*!< I2CON setting for I2C control bits. It would set STO, SI and AA bits      */
N#define I2C_I2CON_SI                0x08UL /*!< I2CON setting for I2C control bits. It would set SI bit                   */
N#define I2C_I2CON_SI_AA             0x0CUL /*!< I2CON setting for I2C control bits. It would set SI and AA bits           */
N#define I2C_I2CON_STA               0x20UL /*!< I2CON setting for I2C control bits. It would set STA bit                  */
N#define I2C_I2CON_STO               0x10UL /*!< I2CON setting for I2C control bits. It would set STO bit                  */
N#define I2C_I2CON_AA                0x04UL /*!< I2CON setting for I2C control bits. It would set AA bit                   */
N
N#define I2C_GCMODE_ENABLE           1      /*!< Enable  I2C GC Mode                                                       */
N#define I2C_GCMODE_DISABLE          0      /*!< Disable I2C GC Mode                                                       */
N
N/*@}*/ /* end of group I2C_EXPORTED_CONSTANTS */
N
N/** @addtogroup I2C_EXPORTED_FUNCTIONS I2C Exported Functions
N  @{
N*/
N/**
N *    @brief        The macro is used to set I2C bus condition at One Time
N *
N *    @param[in]    i2c        Specify I2C port
N *    @param[in]    u8Ctrl     A byte writes to I2C control register
N *
N *    @return       None
N *
N *    @details      Set I2CON register to control I2C bus conditions of START, STOP, SI, ACK.
N */
N#define I2C_SET_CONTROL_REG(i2c, u8Ctrl) ((i2c)->I2CON = ((i2c)->I2CON & ~0x3c) | (u8Ctrl))
N
N/**
N *    @brief        The macro is used to set START condition of I2C Bus
N *
N *    @param[in]    i2c        Specify I2C port
N *
N *    @return       None
N *
N *    @details      Set the I2C bus START condition in I2CON register.
N */
N#define I2C_START(i2c)  ((i2c)->I2CON = ((i2c)->I2CON & ~I2C_I2CON_SI_Msk) | I2C_I2CON_STA_Msk)
N
N/**
N *    @brief        The macro is used to wait I2C bus status get ready
N *
N *    @param[in]    i2c        Specify I2C port
N *
N *    @return       None
N *
N *    @details      When a new status is presented of I2C bus, the SI flag will be set in I2CON register.
N */
N#define I2C_WAIT_READY(i2c)     while(!((i2c)->I2CON & I2C_I2CON_SI_Msk))
N
N/**
N *    @brief        The macro is used to Read I2C Bus Data Register
N *
N *    @param[in]    i2c        Specify I2C port
N *
N *    @return       A byte of I2C data register
N *
N *    @details      I2C controller read data from bus and save it in I2CDAT register.
N */
N#define I2C_GET_DATA(i2c)   ((i2c)->I2CDAT)
N
N/**
N *    @brief        Write a Data to I2C Data Register
N *
N *    @param[in]    i2c         Specify I2C port
N *    @param[in]    u8Data      A byte that writes to data register
N *
N *    @return       None
N *
N *    @details      When write a data to I2CDAT register, the I2C controller will shift it to I2C bus.
N */
N#define I2C_SET_DATA(i2c, u8Data) ((i2c)->I2CDAT = (u8Data))
N
N/**
N *    @brief        Get I2C Bus status code
N *
N *    @param[in]    i2c        Specify I2C port
N *
N *    @return       I2C status code
N *
N *    @details      To get this status code to monitor I2C bus event.
N */
N#define I2C_GET_STATUS(i2c) ((i2c)->I2CSTATUS)
N
N/**
N *    @brief        Get Time-out flag from I2C Bus
N *
N *    @param[in]    i2c     Specify I2C port
N *
N *    @retval       0       I2C Bus time-out is not happened
N *    @retval       1       I2C Bus time-out is happened
N *
N *    @details      When I2C bus occurs time-out event, the time-out flag will be set.
N */
N#define I2C_GET_TIMEOUT_FLAG(i2c)   ( ((i2c)->I2CTOC & I2C_I2CTOC_TIF_Msk) == I2C_I2CTOC_TIF_Msk ? 1:0 )
N
N/**
N *    @brief        To get wake-up flag from I2C Bus
N *
N *    @param[in]    i2c     Specify I2C port
N *
N *    @retval       0       Chip is not woken-up from power-down mode
N *    @retval       1       Chip is woken-up from power-down mode
N *
N *    @details      I2C bus occurs wake-up event, wake-up flag will be set.
N */
N#define I2C_GET_WAKEUP_FLAG(i2c) ( ((i2c)->I2CWKUPSTS & I2C_I2CWKUPSTS_WKUPIF_Msk) == I2C_I2CWKUPSTS_WKUPIF_Msk ? 1:0  )
N
N/**
N *    @brief        To clear wake-up flag
N *
N *    @param[in]    i2c     Specify I2C port
N *
N *    @return       None
N *
N *    @details      If wake-up flag is set, use this macro to clear it.
N */
N#define I2C_CLEAR_WAKEUP_FLAG(i2c)  ((i2c)->I2CWKUPSTS |= I2C_I2CWKUPSTS_WKUPIF_Msk)
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* inline functions                                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/**
N *    @brief        The macro is used to set STOP condition of I2C Bus
N *
N *    @param[in]    i2c        Specify I2C port
N *
N *    @return       None
N *
N *    @details      Set the I2C bus STOP condition in I2CON register and wait STOP condition finish.
N */
Nstatic __INLINE void I2C_STOP(I2C_T *i2c)
Xstatic __inline void I2C_STOP(I2C_T *i2c)
N{
N    (i2c)->I2CON |= (I2C_I2CON_SI_Msk | I2C_I2CON_STO_Msk);
X    (i2c)->I2CON |= ((1ul << 3) | (1ul << 4));
N    while((i2c)->I2CON & I2C_I2CON_STO_Msk);
X    while((i2c)->I2CON & (1ul << 4));
N}
N
Nvoid I2C_ClearTimeoutFlag(I2C_T *i2c);
Nvoid I2C_Close(I2C_T *i2c);
Nvoid I2C_Trigger(I2C_T *i2c, uint8_t u8Start, uint8_t u8Stop, uint8_t u8Si, uint8_t u8Ack);
Nvoid I2C_DisableInt(I2C_T *i2c);
Nvoid I2C_EnableInt(I2C_T *i2c);
Nuint32_t I2C_GetBusClockFreq(I2C_T *i2c);
Nuint32_t I2C_SetBusClockFreq(I2C_T *i2c, uint32_t u32BusClock);
Nuint32_t I2C_GetIntFlag(I2C_T *i2c);
Nuint32_t I2C_GetStatus(I2C_T *i2c);
Nuint32_t I2C_Open(I2C_T *i2c, uint32_t u32BusClock);
Nuint8_t I2C_GetData(I2C_T *i2c);
Nvoid I2C_SetSlaveAddr(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddr, uint8_t u8GCMode);
Nvoid I2C_SetSlaveAddrMask(I2C_T *i2c, uint8_t u8SlaveNo, uint8_t u8SlaveAddrMask);
Nvoid I2C_EnableTimeout(I2C_T *i2c, uint8_t u8LongTimeout);
Nvoid I2C_DisableTimeout(I2C_T *i2c);
Nvoid I2C_EnableWakeup(I2C_T *i2c);
Nvoid I2C_DisableWakeup(I2C_T *i2c);
Nvoid I2C_SetData(I2C_T *i2c, uint8_t u8Data);
N
N/*@}*/ /* end of group I2C_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group I2C_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N#endif //__I2C_H__
L 12448 ".\Libraries\Device\Nuvoton\NUC230_240\Include\NUC230_240.h" 2
N#include "PWM.h"
L 1 ".\Libraries\StdDriver\inc\PWM.h" 1
N/**************************************************************************//**
N * @file     pwm.h
N * @version  V3.00
N * $Revision: 4 $
N * $Date: 15/05/06 2:45p $
N * @brief    NUC230_240 series PWM driver header file
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __PWM_H__
N#define __PWM_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup PWM_Driver PWM Driver
N  @{
N*/
N
N/** @addtogroup PWM_EXPORTED_CONSTANTS PWM Exported Constants
N  @{
N*/
N#define PWM_CHANNEL_NUM                     (4)   /*!< PWM channel number */
N#define PWM_CLK_DIV_1                       (4UL) /*!< PWM clock divide by 1 */
N#define PWM_CLK_DIV_2                       (0UL) /*!< PWM clock divide by 2 */
N#define PWM_CLK_DIV_4                       (1UL) /*!< PWM clock divide by 4 */
N#define PWM_CLK_DIV_8                       (2UL) /*!< PWM clock divide by 8 */
N#define PWM_CLK_DIV_16                      (3UL) /*!< PWM clock divide by 16 */
N#define PWM_EDGE_ALIGNED                    (0UL) /*!< PWM working in edge aligned type */
N#define PWM_CENTER_ALIGNED                  (1UL) /*!< PWM working in center aligned type */
N#define PWM_PERIOD_INT_UNDERFLOW            (0)                         /*!< PWM period interrupt triggered if counter underflow */
N#define PWM_PERIOD_INT_MATCH_CNR            (PWM_PIER_INT01TYPE_Msk)    /*!< PWM period interrupt triggered if counter match CNR */
N#define PWM_CAPTURE_INT_RISING_LATCH        (PWM_CCR0_CRL_IE0_Msk)      /*!< PWM capture interrupt if channel has rising transition */
N#define PWM_CAPTURE_INT_FALLING_LATCH       (PWM_CCR0_CFL_IE0_Msk)      /*!< PWM capture interrupt if channel has falling transition */
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PWM Group channel number constants definitions                                                         */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PWM_CH0                             0x0                         /*!< PWM Group A/B channel 0 */
N#define PWM_CH1                             0x1                         /*!< PWM Group A/B channel 1 */
N#define PWM_CH2                             0x2                         /*!< PWM Group A/B channel 2 */
N#define PWM_CH3                             0x3                         /*!< PWM Group A/B channel 3 */
N#define PWM_CCR_MASK                        0x000F000F                  /*!< PWM CCR0/CCR2 bit0~3 and bit16~19 mask */
N
N/*@}*/ /* end of group PWM_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup PWM_EXPORTED_FUNCTIONS PWM Exported Functions
N  @{
N*/
N
N/**
N * @brief Enable output inverter of specified channel(s)
N * @param[in] pwm The pointer of the specified PWM module
N *                - PWMA : PWM Group A
N *                - PWMB : PWM Group B
N * @param[in] u32ChannelMask Combination of enabled channels. Each bit corresponds to a channel
N *                           Bit 0 represents channel 0, bit 1 represents channel 1...
N * @return None
N * @details This macro is used to enable capture input inverter for specified channel(s).
N * \hideinitializer
N */
N#define PWM_ENABLE_OUTPUT_INVERTER(pwm, u32ChannelMask) \
N    do{ \
N        int i;\
N                (pwm)->PCR &= ~(PWM_PCR_CH0INV_Msk|PWM_PCR_CH1INV_Msk|PWM_PCR_CH2INV_Msk|PWM_PCR_CH3INV_Msk);\
N        for(i = 0; i < 4; i++) { \
N            if((u32ChannelMask) & (1 << i)) \
N                (pwm)->PCR |= (PWM_PCR_CH0INV_Msk << (PWM_PCR_CH0INV_Pos * (i * 4))); \
N        } \
N    }while(0)
X#define PWM_ENABLE_OUTPUT_INVERTER(pwm, u32ChannelMask)     do{         int i;                (pwm)->PCR &= ~(PWM_PCR_CH0INV_Msk|PWM_PCR_CH1INV_Msk|PWM_PCR_CH2INV_Msk|PWM_PCR_CH3INV_Msk);        for(i = 0; i < 4; i++) {             if((u32ChannelMask) & (1 << i))                 (pwm)->PCR |= (PWM_PCR_CH0INV_Msk << (PWM_PCR_CH0INV_Pos * (i * 4)));         }     }while(0)
N
N/**
N * @brief Get captured rising data of specified channel
N * @param[in] pwm The pointer of the specified PWM module
N *                - PWMA : PWM Group A
N *                - PWMB : PWM Group B
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~3
N * @return The timer counter, 0~0xFFFF
N * @details This macro is used to get captured rising data for specified channel.
N */
N#define PWM_GET_CAPTURE_RISING_DATA(pwm, u32ChannelNum) (*((__IO uint32_t *) ((((uint32_t)&((pwm)->CRLR0)) + (u32ChannelNum) * 8))))
N
N/**
N * @brief Get captured falling data of specified channel
N * @param[in] pwm The pointer of the specified PWM module
N *                - PWMA : PWM Group A
N *                - PWMB : PWM Group B
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~3
N * @return The timer counter, 0~0xFFFF
N * @details This macro is used to get captured falling data for specified channel.
N */
N#define PWM_GET_CAPTURE_FALLING_DATA(pwm, u32ChannelNum) (*((__IO uint32_t *) ((((uint32_t)&((pwm)->CFLR0)) + (u32ChannelNum) * 8))))
N
N/**
N * @brief Set the prescaler of the selected channel
N * @param[in] pwm The pointer of the specified PWM module
N *                - PWMA : PWM Group A
N *                - PWMB : PWM Group B
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~3
N * @param[in] u32Prescaler Clock prescaler of specified channel. Valid values are between 1 ~ 0xFF
N * @return None
N * @details This macro is used to set timer pre-scale for specified channel.
N * @note If u32Prescaler = 0, corresponding PWM-timer will be stopped.
N * @note If u32Prescaler = x (x not equal to 0), it means Clock input is divided by (x + 1) before it is fed to the corresponding PWM counter.
N */
N#define PWM_SET_PRESCALER(pwm, u32ChannelNum, u32Prescaler) \
N    ((pwm)->PPR = ((pwm)->PPR & ~(PWM_PPR_CP01_Msk << (((u32ChannelNum) >> 1) * 8))) | ((u32Prescaler) << (((u32ChannelNum) >> 1) * 8)))
X#define PWM_SET_PRESCALER(pwm, u32ChannelNum, u32Prescaler)     ((pwm)->PPR = ((pwm)->PPR & ~(PWM_PPR_CP01_Msk << (((u32ChannelNum) >> 1) * 8))) | ((u32Prescaler) << (((u32ChannelNum) >> 1) * 8)))
N
N/**
N * @brief Set the divider of the selected channel
N * @param[in] pwm The pointer of the specified PWM module
N *                - PWMA : PWM Group A
N *                - PWMB : PWM Group B
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~3
N * @param[in] u32Divider Clock divider of specified channel. Valid values are
N *              - \ref PWM_CLK_DIV_1
N *              - \ref PWM_CLK_DIV_2
N *              - \ref PWM_CLK_DIV_4
N *              - \ref PWM_CLK_DIV_8
N *              - \ref PWM_CLK_DIV_16
N * @return None
N * @details This macro is used to set Timer clock source divider selection for specified channel.
N */
N#define PWM_SET_DIVIDER(pwm, u32ChannelNum, u32Divider) \
N    ((pwm)->CSR = ((pwm)->CSR & ~(PWM_CSR_CSR0_Msk << ((u32ChannelNum) * 4))) | ((u32Divider) << ((u32ChannelNum) * 4)))
X#define PWM_SET_DIVIDER(pwm, u32ChannelNum, u32Divider)     ((pwm)->CSR = ((pwm)->CSR & ~(PWM_CSR_CSR0_Msk << ((u32ChannelNum) * 4))) | ((u32Divider) << ((u32ChannelNum) * 4)))
N
N/**
N * @brief Set the duty of the selected channel
N * @param[in] pwm The pointer of the specified PWM module
N *                - PWMA : PWM Group A
N *                - PWMB : PWM Group B
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~3
N * @param[in] u32CMR Duty of specified channel. Valid values are between 0~0xFFFF
N * @return None
N * @details This macro is used to set PWM Comparator value for specified channel.
N * @note This new setting will take effect on next PWM period.
N */
N#define PWM_SET_CMR(pwm, u32ChannelNum, u32CMR) (*((__IO uint32_t *) ((((uint32_t)&((pwm)->CMR0)) + (u32ChannelNum) * 12))) = (u32CMR))
N
N/**
N * @brief Set the period of the selected channel
N * @param[in] pwm The pointer of the specified PWM module
N *                - PWMA : PWM Group A
N *                - PWMB : PWM Group B
N * @param[in] u32ChannelNum PWM channel number. Valid values are between 0~3
N * @param[in] u32CNR Period of specified channel. Valid values are between 0~0xFFFF
N * @return None
N * @details This macro is used to set timer loaded value(CNR) for specified channel.\n
N *          Loaded value determines the PWM period.
N * @note This new setting will take effect on next PWM period.
N * @note PWM counter will stop if period length set to 0.
N */
N#define PWM_SET_CNR(pwm, u32ChannelNum, u32CNR)  (*((__IO uint32_t *) ((((uint32_t)&((pwm)->CNR0)) + (u32ChannelNum) * 12))) = (u32CNR))
N
N/**
N * @brief Set the PWM aligned type
N * @param[in] pwm The pointer of the specified PWM module
N *                - PWMA : PWM Group A
N *                - PWMB : PWM Group B
N * @param[in] u32ChannelMask Combination of enabled channels. Each bit corresponds to a channel
N *                           Bit 0 represents channel 0, bit 1 represents channel 1...
N * @param[in] u32AlignedType PWM aligned type, valid values are:
N *                  - \ref PWM_EDGE_ALIGNED
N *                  - \ref PWM_CENTER_ALIGNED
N * @return None
N * @details This macro is used to set the PWM aligned type.
N * @note PWM trigger ADC function is only supported when PWM operating at Center-aligned type.
N * \hideinitializer
N */
N#define PWM_SET_ALIGNED_TYPE(pwm, u32ChannelMask, u32AlignedType) \
N    do{ \
N        int i; \
N        for(i = 0; i < 4; i++) { \
N            if((u32ChannelMask) & (1 << i)) \
N                (pwm)->PCR = ((pwm)->PCR & ~(PWM_PCR_PWM01TYPE_Msk << (i >> 1))) | ((u32AlignedType) << (PWM_PCR_PWM01TYPE_Pos + (i >> 1))); \
N        } \
N    }while(0)
X#define PWM_SET_ALIGNED_TYPE(pwm, u32ChannelMask, u32AlignedType)     do{         int i;         for(i = 0; i < 4; i++) {             if((u32ChannelMask) & (1 << i))                 (pwm)->PCR = ((pwm)->PCR & ~(PWM_PCR_PWM01TYPE_Msk << (i >> 1))) | ((u32AlignedType) << (PWM_PCR_PWM01TYPE_Pos + (i >> 1)));         }     }while(0)
N
N
Nuint32_t PWM_ConfigCaptureChannel(PWM_T *pwm,
N                                  uint32_t u32ChannelNum,
N                                  uint32_t u32UnitTimeNsec,
N                                  uint32_t u32CaptureEdge);
Nuint32_t PWM_ConfigOutputChannel(PWM_T *pwm,
N                                 uint32_t u32ChannelNum,
N                                 uint32_t u32Frequncy,
N                                 uint32_t u32DutyCycle);
Nvoid PWM_Start(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_Stop(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_ForceStop(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_EnableADCTrigger(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition);
Nvoid PWM_DisableADCTrigger(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_ClearADCTriggerFlag(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition);
Nuint32_t PWM_GetADCTriggerFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnableCapture(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_DisableCapture(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_EnableOutput(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_DisableOutput(PWM_T *pwm, uint32_t u32ChannelMask);
Nvoid PWM_EnableDeadZone(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Duration);
Nvoid PWM_DisableDeadZone(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnableCaptureInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge);
Nvoid PWM_DisableCaptureInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge);
Nvoid PWM_ClearCaptureIntFlag(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge);
Nuint32_t PWM_GetCaptureIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnableDutyInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32IntDutyType);
Nvoid PWM_DisableDutyInt(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_ClearDutyIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nuint32_t PWM_GetDutyIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_EnablePeriodInt(PWM_T *pwm, uint32_t u32ChannelNum,  uint32_t u32IntPeriodType);
Nvoid PWM_DisablePeriodInt(PWM_T *pwm, uint32_t u32ChannelNum);
Nvoid PWM_ClearPeriodIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
Nuint32_t PWM_GetPeriodIntFlag(PWM_T *pwm, uint32_t u32ChannelNum);
N
N
N
N/*@}*/ /* end of group PWM_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group PWM_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__PWM_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 12449 ".\Libraries\Device\Nuvoton\NUC230_240\Include\NUC230_240.h" 2
N#include "SPI.h"
L 1 ".\Libraries\StdDriver\inc\SPI.h" 1
N/**************************************************************************//**
N * @file     spi.h
N * @version  V3.0
N * $Revision: 7 $
N * $Date: 15/05/28 9:57p $
N * @brief    NUC230_240 Series SPI Driver Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __SPI_H__
N#define __SPI_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup SPI_Driver SPI Driver
N  @{
N*/
N
N/** @addtogroup SPI_EXPORTED_CONSTANTS SPI Exported Constants
N  @{
N*/
N
N#define SPI_MODE_0        (SPI_CNTRL_TX_NEG_Msk)                          /*!< CLKP=0; RX_NEG=0; TX_NEG=1 */
N#define SPI_MODE_1        (SPI_CNTRL_RX_NEG_Msk)                          /*!< CLKP=0; RX_NEG=1; TX_NEG=0 */
N#define SPI_MODE_2        (SPI_CNTRL_CLKP_Msk | SPI_CNTRL_RX_NEG_Msk)     /*!< CLKP=1; RX_NEG=1; TX_NEG=0 */
N#define SPI_MODE_3        (SPI_CNTRL_CLKP_Msk | SPI_CNTRL_TX_NEG_Msk)     /*!< CLKP=1; RX_NEG=0; TX_NEG=1 */
N
N#define SPI_SLAVE         (SPI_CNTRL_SLAVE_Msk)                           /*!< Set as slave */
N#define SPI_MASTER        (0x0)                                           /*!< Set as master */
N
N#define SPI_SS0               (1<<SPI_SSR_SSR_Pos)                       /*!< Select SPIn_SS0 */
N#define SPI_SS1               (2<<SPI_SSR_SSR_Pos)                       /*!< Select SPIn_SS1 */
N#define SPI_SS_ACTIVE_HIGH    (SPI_SSR_SS_LVL_Msk)                        /*!< SS active high */
N#define SPI_SS_ACTIVE_LOW     (0x0)                                       /*!< SS active low */
N
N#define SPI_UNIT_INT_MASK                (0x01)                           /*!< Unit transfer interrupt mask */
N#define SPI_SSTA_INT_MASK                (0x02)                           /*!< Slave 3-Wire mode start interrupt mask */
N#define SPI_FIFO_TX_INT_MASK             (0x04)                           /*!< FIFO TX interrupt mask */
N#define SPI_FIFO_RX_INT_MASK             (0x08)                           /*!< FIFO RX interrupt mask */
N#define SPI_FIFO_RXOV_INT_MASK           (0x10)                           /*!< FIFO RX overrun interrupt mask */
N#define SPI_FIFO_TIMEOUT_INT_MASK        (0x20)                           /*!< FIFO RX timeout interrupt mask */
N
N#define SPI_BUSY_MASK                    (0x01)                           /*!< Busy status mask */
N#define SPI_RX_EMPTY_MASK                (0x02)                           /*!< RX empty status mask */
N#define SPI_RX_FULL_MASK                 (0x04)                           /*!< RX full status mask */
N#define SPI_TX_EMPTY_MASK                (0x08)                           /*!< TX empty status mask */
N#define SPI_TX_FULL_MASK                 (0x10)                           /*!< TX full status mask */
N
N#define SPI_FIFO_SIZE                    (8)                              /*!< NUC230/NUC240 provides separate 8-layer transmit and receive FIFO buffers */
N
N/*@}*/ /* end of group SPI_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup SPI_EXPORTED_FUNCTIONS SPI Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Abort the current transfer in Slave 3-wire mode.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Set the SLV_ABORT bit of SPI_CNTRL2 register to abort the current transfer in Slave 3-wire mode.
N  */
N#define SPI_ABORT_3WIRE_TRANSFER(spi)   ((spi)->CNTRL2 |= SPI_CNTRL2_SLV_ABORT_Msk)
N
N/**
N  * @brief      Clear the Slave 3-wire mode start interrupt flag.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Write 1 to SLV_START_INTSTS bit of SPI_STATUS register to clear the Slave 3-wire mode start interrupt flag.
N  */
N#define SPI_CLR_3WIRE_START_INT_FLAG(spi)   ((spi)->STATUS = SPI_STATUS_SLV_START_INTSTS_Msk)
N
N/**
N  * @brief      Clear the unit transfer interrupt flag.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Write 1 to IF bit of SPI_STATUS register to clear the unit transfer interrupt flag.
N  */
N#define SPI_CLR_UNIT_TRANS_INT_FLAG(spi)   ((spi)->STATUS = SPI_STATUS_IF_Msk)
N
N/**
N  * @brief      Disable 2-bit Transfer mode.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Clear TWOB bit of SPI_CNTRL register to disable 2-bit Transfer mode.
N  */
N#define SPI_DISABLE_2BIT_MODE(spi)   ((spi)->CNTRL &= ~SPI_CNTRL_TWOB_Msk)
N
N/**
N  * @brief      Disable Slave 3-wire mode.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Clear NOSLVSEL bit of SPI_CNTRL2 register to disable Slave 3-wire mode.
N  */
N#define SPI_DISABLE_3WIRE_MODE(spi)   ((spi)->CNTRL2 &= ~SPI_CNTRL2_NOSLVSEL_Msk)
N
N/**
N  * @brief      Disable Dual I/O mode.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Clear DUAL_IO_EN bit of SPI_CNTRL2 register to disable Dual I/O mode.
N  */
N#define SPI_DISABLE_DUAL_MODE(spi)   ((spi)->CNTRL2 &= ~SPI_CNTRL2_DUAL_IO_EN_Msk)
N
N/**
N  * @brief      Enable 2-bit Transfer mode.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Set TWOB bit of SPI_CNTRL register to enable 2-bit Transfer mode.
N  */
N#define SPI_ENABLE_2BIT_MODE(spi)   ((spi)->CNTRL |= SPI_CNTRL_TWOB_Msk)
N
N/**
N  * @brief      Enable Slave 3-wire mode.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Set NOSLVSEL bit of SPI_CNTRL2 register to enable Slave 3-wire mode.
N  *             Only available in Slave mode.
N  */
N#define SPI_ENABLE_3WIRE_MODE(spi)   ((spi)->CNTRL2 |= SPI_CNTRL2_NOSLVSEL_Msk)
N
N/**
N  * @brief      Enable Dual input mode.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Clear DUAL_IO_DIR bit and set DUAL_IO_EN bit of SPI_CNTRL2 register to enable Dual input mode.
N  */
N#define SPI_ENABLE_DUAL_INPUT_MODE(spi)   ((spi)->CNTRL2 = ((spi)->CNTRL2 & (~SPI_CNTRL2_DUAL_IO_DIR_Msk)) | SPI_CNTRL2_DUAL_IO_EN_Msk)
N
N/**
N  * @brief      Enable Dual output mode.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Set DUAL_IO_DIR bit and DUAL_IO_EN bit of SPI_CNTRL2 register to enable Dual output mode.
N  */
N#define SPI_ENABLE_DUAL_OUTPUT_MODE(spi)   ((spi)->CNTRL2 |= (SPI_CNTRL2_DUAL_IO_EN_Msk | SPI_CNTRL2_DUAL_IO_DIR_Msk))
N
N/**
N  * @brief      Trigger RX PDMA function.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Set RX_DMA_GO bit of SPI_DMA register to enable RX PDMA transfer function.
N  */
N#define SPI_TRIGGER_RX_PDMA(spi)   ((spi)->DMA |= SPI_DMA_RX_DMA_GO_Msk)
N
N/**
N  * @brief      Trigger TX PDMA function.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Set TX_DMA_GO bit of SPI_DMA register to enable TX PDMA transfer function.
N  */
N#define SPI_TRIGGER_TX_PDMA(spi)   ((spi)->DMA |= SPI_DMA_TX_DMA_GO_Msk)
N
N/**
N  * @brief      Get the count of available data in RX FIFO.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     The count of available data in RX FIFO.
N  * @details    Read RX_FIFO_COUNT (SPI_STATUS[15:12]) to get the count of available data in RX FIFO.
N  */
N#define SPI_GET_RX_FIFO_COUNT(spi)   (((spi)->STATUS & SPI_STATUS_RX_FIFO_COUNT_Msk) >> SPI_STATUS_RX_FIFO_COUNT_Pos)
N
N/**
N  * @brief      Get the RX FIFO empty flag.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @retval     0 RX FIFO is not empty.
N  * @retval     1 RX FIFO is empty.
N  * @details    Read RX_EMPTY bit of SPI_STATUS register to get the RX FIFO empty flag.
N  */
N#define SPI_GET_RX_FIFO_EMPTY_FLAG(spi)   (((spi)->STATUS & SPI_STATUS_RX_EMPTY_Msk)>>SPI_STATUS_RX_EMPTY_Pos)
N
N/**
N  * @brief      Get the TX FIFO empty flag.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @retval     0 TX FIFO is not empty.
N  * @retval     1 TX FIFO is empty.
N  * @details    Read TX_EMPTY bit of SPI_STATUS register to get the TX FIFO empty flag.
N  */
N#define SPI_GET_TX_FIFO_EMPTY_FLAG(spi)   (((spi)->STATUS & SPI_STATUS_TX_EMPTY_Msk)>>SPI_STATUS_TX_EMPTY_Pos)
N
N/**
N  * @brief      Get the TX FIFO full flag.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @retval     0 TX FIFO is not full.
N  * @retval     1 TX FIFO is full.
N  * @details    Read TX_FULL bit of SPI_STATUS register to get the TX FIFO full flag.
N  */
N#define SPI_GET_TX_FIFO_FULL_FLAG(spi)   (((spi)->STATUS & SPI_STATUS_TX_FULL_Msk)>>SPI_STATUS_TX_FULL_Pos)
N
N/**
N  * @brief      Get the datum read from RX0 register.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     Data in RX0 register.
N  * @details    Read SPI_RX0 register to get the received datum.
N  */
N#define SPI_READ_RX0(spi)   ((spi)->RX[0])
N
N/**
N  * @brief      Get the datum read from RX1 register.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     Data in RX1 register.
N  * @details    Read SPI_RX1 register to get the received datum.
N  */
N#define SPI_READ_RX1(spi)   ((spi)->RX[1])
N
N/**
N  * @brief      Write datum to TX0 register.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @param[in]  u32TxData The datum which user attempt to transfer through SPI bus.
N  * @return     None.
N  * @details    Write u32TxData to TX0 register.
N  */
N#define SPI_WRITE_TX0(spi, u32TxData)   ((spi)->TX[0] = (u32TxData))
N
N/**
N  * @brief      Write datum to TX1 register.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @param[in]  u32TxData The datum which user attempt to transfer through SPI bus.
N  * @return     None.
N  * @details    Write u32TxData to TX1 register.
N  */
N#define SPI_WRITE_TX1(spi, u32TxData)   ((spi)->TX[1] = (u32TxData))
N
N/**
N  * @brief      Set SPIn_SS0, SPIn_SS1 pin to high or low state.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @param[in]  ss0 0 = Set SPIn_SS0 to low. 1 = Set SPIn_SS0 to high.
N  * @param[in]  ss1 0 = Set SPIn_SS1 to low. 1 = Set SPIn_SS1 to high.
N  * @return     None.
N  * @details    Disable automatic slave selection function and set SPIn_SS0/SPIn_SS1 pin to specified high/low state.
N  *             Only available in Master mode.
N  */
N#define SPI_SET_SS_LEVEL(spi, ss0, ss1)   ((spi)->SSR = ((spi)->SSR & ~(SPI_SSR_AUTOSS_Msk|SPI_SSR_SS_LVL_Msk|SPI_SSR_SSR_Msk)) | (((ss1)^1) << 1) | ((ss0)^1))
N
N/**
N  * @brief      Set SPIn_SS0 pin to high state.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Disable automatic slave selection function and set SPIn_SS0 pin to high state. Only available in Master mode.
N  */
N#define SPI_SET_SS0_HIGH(spi)   ((spi)->SSR = ((spi)->SSR & ~(SPI_SSR_AUTOSS_Msk|SPI_SSR_SS_LVL_Msk|SPI_SS0)))
N
N/**
N  * @brief      Set SPIn_SS1 pin to high state.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Disable automatic slave selection function and set SPIn_SS1 pin to high state. Only available in Master mode.
N  */
N#define SPI_SET_SS1_HIGH(spi)   ((spi)->SSR = ((spi)->SSR & ~(SPI_SSR_AUTOSS_Msk|SPI_SSR_SS_LVL_Msk|SPI_SS1)))
N
N/**
N  * @brief      Set SPIn_SS0 pin to low state.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Disable automatic slave selection function and set SPIn_SS0 pin to low state. Only available in Master mode.
N  */
N#define SPI_SET_SS0_LOW(spi)   ((spi)->SSR = ((spi)->SSR & ~(SPI_SSR_AUTOSS_Msk|SPI_SSR_SS_LVL_Msk|SPI_SS0)) | SPI_SS0)
N
N/**
N  * @brief      Set SPIn_SS1 pin to low state.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Disable automatic slave selection function and set SPIn_SS1 pin to low state. Only available in Master mode.
N  */
N#define SPI_SET_SS1_LOW(spi)   ((spi)->SSR = ((spi)->SSR & ~(SPI_SSR_AUTOSS_Msk|SPI_SSR_SS_LVL_Msk|SPI_SS1)) | SPI_SS1)
N
N/**
N  * @brief      Enable Byte Reorder function.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Set REORDER bit of SPI_CNTRL register to enable Byte Reorder function.
N  */
N#define SPI_ENABLE_BYTE_REORDER(spi)   ((spi)->CNTRL |= SPI_CNTRL_REORDER_Msk)
N
N/**
N  * @brief      Disable Byte Reorder function.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Clear REORDER bit of SPI_CNTRL register to disable Byte Reorder function.
N  */
N#define SPI_DISABLE_BYTE_REORDER(spi)   ((spi)->CNTRL &= ~SPI_CNTRL_REORDER_Msk)
N
N/**
N  * @brief      Set the length of suspend interval.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @param[in]  u32SuspCycle Decides the length of suspend interval.
N  * @return     None.
N  * @details    Set the length of suspend interval according to u32SuspCycle.
N  *             The length of suspend interval is ((u32SuspCycle + 0.5) * the length of one SPI bus clock cycle).
N  *             Only available in Master mode.
N  */
N#define SPI_SET_SUSPEND_CYCLE(spi, u32SuspCycle)   ((spi)->CNTRL = ((spi)->CNTRL & ~SPI_CNTRL_SP_CYCLE_Msk) | ((u32SuspCycle) << SPI_CNTRL_SP_CYCLE_Pos))
N
N/**
N  * @brief      Set the SPI transfer sequence with LSB first.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Set LSB bit of SPI_CNTRL register to set the SPI transfer sequence with LSB first.
N  */
N#define SPI_SET_LSB_FIRST(spi)   ((spi)->CNTRL |= SPI_CNTRL_LSB_Msk)
N
N/**
N  * @brief      Set the SPI transfer sequence with MSB first.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    Clear LSB bit of SPI_CNTRL register to set the SPI transfer sequence with MSB first.
N  */
N#define SPI_SET_MSB_FIRST(spi)   ((spi)->CNTRL &= ~SPI_CNTRL_LSB_Msk)
N
N/**
N  * @brief      Set the data width of a SPI transaction.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @param[in]  u32Width The bit width of transfer data.
N  * @return     None.
N  * @details    The data width can be 8 ~ 32 bits.
N  */
N#define SPI_SET_DATA_WIDTH(spi, u32Width)   ((spi)->CNTRL = ((spi)->CNTRL & ~SPI_CNTRL_TX_BIT_LEN_Msk) | (((u32Width)&0x1F) << SPI_CNTRL_TX_BIT_LEN_Pos))
N
N/**
N  * @brief      Get the SPI busy state.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @retval     0 SPI controller is not busy.
N  * @retval     1 SPI controller is busy.
N  * @details    This macro will return the busy state of SPI controller.
N  */
N#define SPI_IS_BUSY(spi)   ( ((spi)->CNTRL & SPI_CNTRL_GO_BUSY_Msk)>>SPI_CNTRL_GO_BUSY_Pos )
N
N/**
N  * @brief      Set the GO_BUSY bit to trigger SPI transfer.
N  * @param[in]  spi The pointer of the specified SPI module.
N  * @return     None.
N  * @details    If FIFO mode is disabled, user can use this macro to trigger the data transfer after all configuration is ready.
N  *             If FIFO mode is enabled, user should not use this macro to trigger the data transfer. SPI controller will trigger the data transfer
N  *             automatically after user write to SPI_TX0/1 register.
N  */
N#define SPI_TRIGGER(spi)   ((spi)->CNTRL |= SPI_CNTRL_GO_BUSY_Msk)
N
N
N
N/* Function prototype declaration */
Nuint32_t SPI_Open(SPI_T *spi, uint32_t u32MasterSlave, uint32_t u32SPIMode, uint32_t u32DataWidth, uint32_t u32BusClock);
Nvoid SPI_Close(SPI_T *spi);
Nvoid SPI_ClearRxFIFO(SPI_T *spi);
Nvoid SPI_ClearTxFIFO(SPI_T *spi);
Nvoid SPI_DisableAutoSS(SPI_T *spi);
Nvoid SPI_EnableAutoSS(SPI_T *spi, uint32_t u32SSPinMask, uint32_t u32ActiveLevel);
Nuint32_t SPI_SetBusClock(SPI_T *spi, uint32_t u32BusClock);
Nvoid SPI_EnableFIFO(SPI_T *spi, uint32_t u32TxThreshold, uint32_t u32RxThreshold);
Nvoid SPI_DisableFIFO(SPI_T *spi);
Nuint32_t SPI_GetBusClock(SPI_T *spi);
Nvoid SPI_EnableInt(SPI_T *spi, uint32_t u32Mask);
Nvoid SPI_DisableInt(SPI_T *spi, uint32_t u32Mask);
Nuint32_t SPI_GetIntFlag(SPI_T *spi, uint32_t u32Mask);
Nvoid SPI_ClearIntFlag(SPI_T *spi, uint32_t u32Mask);
Nuint32_t SPI_GetStatus(SPI_T *spi, uint32_t u32Mask);
N
N
N
N/**
N  * @} End of SPI Device Function Interface
N  */
N
N/**
N  * @} End of SPI Driver
N  */
N
N/**
N  * @} End of Standard Driver
N  */
N
N
N#endif
N
L 12450 ".\Libraries\Device\Nuvoton\NUC230_240\Include\NUC230_240.h" 2
N#include "CRC.h"
L 1 ".\Libraries\StdDriver\inc\CRC.h" 1
N/**************************************************************************//**
N * @file     crc.h
N * @version  V3.00
N * $Revision: 2 $
N * $Date: 15/05/06 10:18a $
N * @brief    NUC230_240 series CRC driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __CRC_H__
N#define __CRC_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup CRC_Driver CRC Driver
N  @{
N*/
N
N/** @addtogroup CRC_EXPORTED_CONSTANTS CRC Exported Constants
N  @{
N*/
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CRC Polynomial Mode Constant Definitions                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CRC_CCITT           0x00000000UL            /*!<CRC Polynomial Mode - CCITT */
N#define CRC_8               0x40000000UL            /*!<CRC Polynomial Mode - CRC8 */
N#define CRC_16              0x80000000UL            /*!<CRC Polynomial Mode - CRC16 */
N#define CRC_32              0xC0000000UL            /*!<CRC Polynomial Mode - CRC32 */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Checksum, Write data Constant Definitions                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CRC_CHECKSUM_COM    0x08000000UL            /*!<CRC Checksum Complement */
N#define CRC_CHECKSUM_RVS    0x02000000UL            /*!<CRC Checksum Reverse */
N#define CRC_WDATA_COM       0x04000000UL            /*!<CRC Write Data Complement */
N#define CRC_WDATA_RVS       0x01000000UL            /*!<CRC Write Data Reverse */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CPU Write Data Length Constant Definitions                                                             */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CRC_CPU_WDATA_8     0x00000000UL            /*!<CRC 8-bit CPU Write Data */
N#define CRC_CPU_WDATA_16    0x10000000UL            /*!<CRC 16-bit CPU Write Data */
N#define CRC_CPU_WDATA_32    0x20000000UL            /*!<CRC 32-bit CPU Write Data */
N
N/*@}*/ /* end of group CRC_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup CRC_EXPORTED_FUNCTIONS CRC Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Enable CRC Interrupt
N  *
N  * @param[in]  u32Mask     Interrupt mask
N  *
N  * @return     None
N  *
N  * @details    This macro enable the specify CRC interrupt function by u32Mask setting.
N  */
N#define CRC_ENABLE_INT(u32Mask)   (CRC->DMAIER |= (u32Mask))
N
N/**
N  * @brief      Disable CRC Interrupt
N  *
N  * @param[in]  u32Mask     Interrupt mask
N  *
N  * @return     None
N  *
N  * @details    This macro disable the specify CRC interrupt function by u32Mask setting.
N  */
N#define CRC_DISABLE_INT(u32Mask)    (CRC->DMAIER &= ~(u32Mask))
N
N/**
N  * @brief      Get CRC Interrupt Flag
N  *
N  * @param      None
N  *
N  * @return     Interrupt Flag Status
N  *
N  * @details    This macro gets the CRC interrupt flags.
N  */
N#define CRC_GET_INT_FLAG()          ((uint32_t)(CRC->DMAISR))
N
N/**
N  * @brief      Clear CRC Interrupt Flag
N  *
N  * @param[in]  u32Mask     Interrupt mask
N  *
N  * @return     None
N  *
N  * @details    This macro clear the specify CRC interrupt flag by u32Mask setting.
N  */
N#define CRC_CLR_INT_FLAG(u32Mask)   (CRC->DMAISR = (u32Mask))
N
N/**
N  * @brief      Set CRC seed value
N  *
N  * @param[in]  u32Seed     Seed value
N  *
N  * @return     None
N  *
N  * @details    This macro set CRC seed value.
N  *
N  * @note       User must to setting CRC_RST (CRC_CTL[1] CRC Engine Reset) to reload the new seed value
N  *             to CRC controller.
N  */
N#define CRC_SET_SEED(u32Seed)       { CRC->SEED = (u32Seed); CRC->CTL |= CRC_CTL_CRC_RST_Msk; }
N
N/**
N  * @brief      Get CRC Seed value
N  *
N  * @param      None
N  *
N  * @return     Seed Value
N  *
N  * @details    This macro gets the current CRC seed value.
N  */
N#define CRC_GET_SEED()              ((uint32_t)(CRC->SEED))
N
N/**
N  * @brief      CRC write data
N  *
N  * @param[in]  u32Data     write data
N  *
N  * @return     None
N  *
N  * @details    User can write data directly by this macro to perform CRC operation.
N  */
N#define CRC_WRITE_DATA(u32Data)     (CRC->WDATA = (u32Data))
N
N
N/*********************************************************************/
Nvoid CRC_Open(uint32_t u32Mode, uint32_t u32Attribute, uint32_t u32Seed, uint32_t u32DataLen);
Nvoid CRC_StartDMATransfer(uint32_t u32SrcAddr, uint32_t u32ByteCount);
Nuint32_t CRC_GetChecksum(void);
N
N/*@}*/ /* end of group CRC_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group CRC_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__CRC_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 12451 ".\Libraries\Device\Nuvoton\NUC230_240\Include\NUC230_240.h" 2
N#include "TIMER.h"
L 1 ".\Libraries\StdDriver\inc\TIMER.h" 1
N/**************************************************************************//**
N * @file     timer.h
N * @version  V3.00
N * $Revision: 3 $
N * $Date: 15/05/06 10:18a $
N * @brief    NUC230_240 series Timer driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __TIMER_H__
N#define __TIMER_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup TIMER_Driver TIMER Driver
N  @{
N*/
N
N/** @addtogroup TIMER_EXPORTED_CONSTANTS TIMER Exported Constants
N  @{
N*/
N
N#define TIMER_ONESHOT_MODE                  (0UL << TIMER_TCSR_MODE_Pos)            /*!< Timer working in one-shot mode */
N#define TIMER_PERIODIC_MODE                 (1UL << TIMER_TCSR_MODE_Pos)            /*!< Timer working in periodic mode */
N#define TIMER_TOGGLE_MODE                   (2UL << TIMER_TCSR_MODE_Pos)            /*!< Timer working in toggle-output mode */
N#define TIMER_CONTINUOUS_MODE               (3UL << TIMER_TCSR_MODE_Pos)            /*!< Timer working in continuous counting mode */
N#define TIMER_CAPTURE_FREE_COUNTING_MODE    (0UL << TIMER_TEXCON_RSTCAPSEL_Pos)     /*!< Timer capture event to get timer counter value */
N#define TIMER_CAPTURE_COUNTER_RESET_MODE    (1UL << TIMER_TEXCON_RSTCAPSEL_Pos)     /*!< Timer capture event to reset timer counter */
N#define TIMER_CAPTURE_FALLING_EDGE              (0UL << TIMER_TEXCON_TEX_EDGE_Pos)  /*!< Falling edge trigger timer capture */
N#define TIMER_CAPTURE_RISING_EDGE               (1UL << TIMER_TEXCON_TEX_EDGE_Pos)  /*!< Rising edge trigger timer capture */
N#define TIMER_CAPTURE_FALLING_AND_RISING_EDGE   (2UL << TIMER_TEXCON_TEX_EDGE_Pos)  /*!< Both falling and rising edge trigger timer capture */
N#define TIMER_COUNTER_FALLING_EDGE          (0UL << TIMER_TEXCON_TX_PHASE_Pos)      /*!< Counter increase on falling edge */
N#define TIMER_COUNTER_RISING_EDGE           (1UL << TIMER_TEXCON_TX_PHASE_Pos)      /*!< Counter increase on rising edge */
N
N/*@}*/ /* end of group TIMER_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup TIMER_EXPORTED_FUNCTIONS TIMER Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Set Timer Compare Value
N  *
N  * @param[in]  timer       The base address of Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  * @param[in]  u32Value    Timer compare value. Valid values are between 2 to 0xFFFFFF.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to set new Timer compared value.
N  */
N#define TIMER_SET_CMP_VALUE(timer, u32Value)        ((timer)->TCMPR = (u32Value))
N
N/**
N  * @brief      Set Timer Prescale Value
N  *
N  * @param[in]  timer       The base address of Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  * @param[in]  u32Value    Timer prescale value. Valid values are between 0 to 0xFF.
N  *
N  * @return     None
N  *
N  * @details    This macro is used to set new Timer prescale value.
N  * @note       Clock input is divided by (prescale + 1) before it is fed into timer.
N  */
N#define TIMER_SET_PRESCALE_VALUE(timer, u32Value)   ((timer)->TCSR = ((timer)->TCSR & ~TIMER_TCSR_PRESCALE_Msk) | (u32Value))
N
N/**
N  * @brief      Check specify Timer Status
N  *
N  * @param[in]  timer       The base address of Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @retval     0   Timer 24-bit up counter is inactive
N  * @retval     1   Timer 24-bit up counter is active
N  *
N  * @details    This macro is used to check if specify Timer channel is inactive or active.
N  */
N#define TIMER_IS_ACTIVE(timer)                      ((timer)->TCSR & TIMER_TCSR_CACT_Msk ? 1 : 0)
N
N/**
N  * @brief      Start Timer Counting
N  *
N  * @param[in]  timer       The base address of Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to start Timer counting.
N  */
Nstatic __INLINE void TIMER_Start(TIMER_T *timer)
Xstatic __inline void TIMER_Start(TIMER_T *timer)
N{
N    timer->TCSR |= TIMER_TCSR_CEN_Msk;
X    timer->TCSR |= (1ul << 30);
N}
N
N/**
N  * @brief      Stop Timer Counting
N  *
N  * @param[in]  timer       The base address of Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to stop/suspend Timer counting.
N  */
Nstatic __INLINE void TIMER_Stop(TIMER_T *timer)
Xstatic __inline void TIMER_Stop(TIMER_T *timer)
N{
N    timer->TCSR &= ~TIMER_TCSR_CEN_Msk;
X    timer->TCSR &= ~(1ul << 30);
N}
N
N/**
N  * @brief      Enable Timer Interrupt Wakeup Function
N  *
N  * @param[in]  timer       The base address of Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to enable the Timer interrupt wake-up function.
N  * @note       To wake the system from Power-down mode, timer clock source must be ether LXT or LIRC.
N  */
Nstatic __INLINE void TIMER_EnableWakeup(TIMER_T *timer)
Xstatic __inline void TIMER_EnableWakeup(TIMER_T *timer)
N{
N    timer->TCSR |= TIMER_TCSR_WAKE_EN_Msk;
X    timer->TCSR |= (1ul << 23);
N}
N
N/**
N  * @brief      Disable Timer Wakeup Function
N  *
N  * @param[in]  timer       The base address of Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to disable the Timer interrupt wake-up function.
N  */
Nstatic __INLINE void TIMER_DisableWakeup(TIMER_T *timer)
Xstatic __inline void TIMER_DisableWakeup(TIMER_T *timer)
N{
N    timer->TCSR &= ~TIMER_TCSR_WAKE_EN_Msk;
X    timer->TCSR &= ~(1ul << 23);
N}
N
N/**
N  * @brief      Enable Capture Pin De-bounce
N  *
N  * @param[in]  timer       The base address of Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to enable the capture pin detection de-bounce function.
N  */
Nstatic __INLINE void TIMER_EnableCaptureDebounce(TIMER_T *timer)
Xstatic __inline void TIMER_EnableCaptureDebounce(TIMER_T *timer)
N{
N    timer->TEXCON |= TIMER_TEXCON_TEXDB_Msk;
X    timer->TEXCON |= (1ul << 6);
N}
N
N/**
N  * @brief      Disable Capture Pin De-bounce
N  *
N  * @param[in]  timer       The base address of Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to disable the capture pin detection de-bounce function.
N  */
Nstatic __INLINE void TIMER_DisableCaptureDebounce(TIMER_T *timer)
Xstatic __inline void TIMER_DisableCaptureDebounce(TIMER_T *timer)
N{
N    timer->TEXCON &= ~TIMER_TEXCON_TEXDB_Msk;
X    timer->TEXCON &= ~(1ul << 6);
N}
N
N/**
N  * @brief      Enable Counter Pin De-bounce
N  *
N  * @param[in]  timer       The base address of Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to enable the counter pin detection de-bounce function.
N  */
Nstatic __INLINE void TIMER_EnableEventCounterDebounce(TIMER_T *timer)
Xstatic __inline void TIMER_EnableEventCounterDebounce(TIMER_T *timer)
N{
N    timer->TEXCON |= TIMER_TEXCON_TCDB_Msk;
X    timer->TEXCON |= (1ul << 7);
N}
N
N/**
N  * @brief      Disable Counter Pin De-bounce
N  *
N  * @param[in]  timer       The base address of Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to disable the counter pin detection de-bounce function.
N  */
Nstatic __INLINE void TIMER_DisableEventCounterDebounce(TIMER_T *timer)
Xstatic __inline void TIMER_DisableEventCounterDebounce(TIMER_T *timer)
N{
N    timer->TEXCON &= ~TIMER_TEXCON_TCDB_Msk;
X    timer->TEXCON &= ~(1ul << 7);
N}
N
N/**
N  * @brief      Enable Timer Time-out Interrupt
N  *
N  * @param[in]  timer       The base address of Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to enable the Timer time-out interrupt function.
N  */
Nstatic __INLINE void TIMER_EnableInt(TIMER_T *timer)
Xstatic __inline void TIMER_EnableInt(TIMER_T *timer)
N{
N    timer->TCSR |= TIMER_TCSR_IE_Msk;
X    timer->TCSR |= (1ul << 29);
N}
N
N/**
N  * @brief      Disable Timer Time-out Interrupt
N  *
N  * @param[in]  timer       The base address of Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to disable the Timer time-out interrupt function.
N  */
Nstatic __INLINE void TIMER_DisableInt(TIMER_T *timer)
Xstatic __inline void TIMER_DisableInt(TIMER_T *timer)
N{
N    timer->TCSR &= ~TIMER_TCSR_IE_Msk;
X    timer->TCSR &= ~(1ul << 29);
N}
N
N/**
N  * @brief      Enable Capture Interrupt
N  *
N  * @param[in]  timer       The base address of Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to enable the Timer capture trigger interrupt function.
N  */
Nstatic __INLINE void TIMER_EnableCaptureInt(TIMER_T *timer)
Xstatic __inline void TIMER_EnableCaptureInt(TIMER_T *timer)
N{
N    timer->TEXCON |= TIMER_TEXCON_TEXIEN_Msk;
X    timer->TEXCON |= (1ul << 5);
N}
N
N/**
N  * @brief      Disable Capture Interrupt
N  *
N  * @param[in]  timer       The base address of Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function is used to disable the Timer capture trigger interrupt function.
N  */
Nstatic __INLINE void TIMER_DisableCaptureInt(TIMER_T *timer)
Xstatic __inline void TIMER_DisableCaptureInt(TIMER_T *timer)
N{
N    timer->TEXCON &= ~TIMER_TEXCON_TEXIEN_Msk;
X    timer->TEXCON &= ~(1ul << 5);
N}
N
N/**
N  * @brief      Get Timer Time-out Interrupt Flag
N  *
N  * @param[in]  timer   The base address of Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @retval     0   Timer time-out interrupt did not occur
N  * @retval     1   Timer time-out interrupt occurred
N  *
N  * @details    This function indicates Timer time-out interrupt occurred or not.
N  */
Nstatic __INLINE uint32_t TIMER_GetIntFlag(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetIntFlag(TIMER_T *timer)
N{
N    return (timer->TISR & TIMER_TISR_TIF_Msk ? 1 : 0);
X    return (timer->TISR & (1ul << 0) ? 1 : 0);
N}
N
N/**
N  * @brief      Clear Timer time-out Interrupt Flag
N  *
N  * @param[in]  timer       The base address of Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function clears Timer time-out interrupt flag.
N  */
Nstatic __INLINE void TIMER_ClearIntFlag(TIMER_T *timer)
Xstatic __inline void TIMER_ClearIntFlag(TIMER_T *timer)
N{
N    timer->TISR = TIMER_TISR_TIF_Msk;
X    timer->TISR = (1ul << 0);
N}
N
N/**
N  * @brief      Get Timer Capture Interrupt Flag
N  *
N  * @param[in]  timer   The base address of Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @retval     0   Timer capture interrupt did not occur
N  * @retval     1   Timer capture interrupt occurred
N  *
N  * @details    This function indicates Timer capture interrupt occurred or not.
N  */
Nstatic __INLINE uint32_t TIMER_GetCaptureIntFlag(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetCaptureIntFlag(TIMER_T *timer)
N{
N    return timer->TEXISR;
N}
N
N/**
N  * @brief      Clear Timer capture Interrupt Flag
N  *
N  * @param[in]  timer       The base address of Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function clears Timer capture interrupt flag.
N  */
Nstatic __INLINE void TIMER_ClearCaptureIntFlag(TIMER_T *timer)
Xstatic __inline void TIMER_ClearCaptureIntFlag(TIMER_T *timer)
N{
N    timer->TEXISR = TIMER_TEXISR_TEXIF_Msk;
X    timer->TEXISR = (1ul << 0);
N}
N
N/**
N  * @brief      Get Timer Wakeup Flag
N  *
N  * @param[in]  timer   The base address of Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @retval     0   Timer did not wake up system
N  * @retval     1   Timer Timer wake up system
N  *
N  * @details    This function indicates Timer has waked up system or not.
N  */
Nstatic __INLINE uint32_t TIMER_GetWakeupFlag(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetWakeupFlag(TIMER_T *timer)
N{
N    return (timer->TISR & TIMER_TISR_TWF_Msk ? 1 : 0);
X    return (timer->TISR & (1ul << 1) ? 1 : 0);
N}
N
N/**
N  * @brief      Clear Timer Wake-up Flag
N  *
N  * @param[in]  timer       The base address of Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     None
N  *
N  * @details    This function clears the Timer wake-up system flag.
N  */
Nstatic __INLINE void TIMER_ClearWakeupFlag(TIMER_T *timer)
Xstatic __inline void TIMER_ClearWakeupFlag(TIMER_T *timer)
N{
N    timer->TISR = TIMER_TISR_TWF_Msk;
X    timer->TISR = (1ul << 1);
N}
N
N/**
N  * @brief      Get Capture value
N  *
N  * @param[in]  timer       The base address of Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     Capture Value
N  *
N  * @details    This function reports the current timer capture data value.
N  */
Nstatic __INLINE uint32_t TIMER_GetCaptureData(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetCaptureData(TIMER_T *timer)
N{
N    return timer->TCAP;
N}
N
N/**
N  * @brief      Get Counter value
N  *
N  * @param[in]  timer       The base address of Timer module. It could be TIMER0, TIMER1, TIMER2, TIMER3.
N  *
N  * @return     Counter Value
N  *
N  * @details    This function reports the current 24-bit timer counter value.
N  */
Nstatic __INLINE uint32_t TIMER_GetCounter(TIMER_T *timer)
Xstatic __inline uint32_t TIMER_GetCounter(TIMER_T *timer)
N{
N    return timer->TDR;
N}
N
Nuint32_t TIMER_Open(TIMER_T *timer, uint32_t u32Mode, uint32_t u32Freq);
Nvoid TIMER_Close(TIMER_T *timer);
Nvoid TIMER_Delay(TIMER_T *timer, uint32_t u32Usec);
Nvoid TIMER_EnableCapture(TIMER_T *timer, uint32_t u32CapMode, uint32_t u32Edge);
Nvoid TIMER_DisableCapture(TIMER_T *timer);
Nvoid TIMER_EnableEventCounter(TIMER_T *timer, uint32_t u32Edge);
Nvoid TIMER_DisableEventCounter(TIMER_T *timer);
Nuint32_t TIMER_GetModuleClock(TIMER_T *timer);
N
N/*@}*/ /* end of group TIMER_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group TIMER_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__TIMER_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 12452 ".\Libraries\Device\Nuvoton\NUC230_240\Include\NUC230_240.h" 2
N#include "WDT.h"
L 1 ".\Libraries\StdDriver\inc\WDT.h" 1
N/**************************************************************************//**
N * @file     wdt.h
N * @version  V3.00
N * $Revision: 2 $
N * $Date: 15/05/06 10:18a $
N * @brief    NUC230_240 series WDT driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __WDT_H__
N#define __WDT_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup WDT_Driver WDT Driver
N  @{
N*/
N
N/** @addtogroup WDT_EXPORTED_CONSTANTS WDT Exported Constants
N  @{
N*/
N/*---------------------------------------------------------------------------------------------------------*/
N/* WTCR Constants Definitions                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define WDT_TIMEOUT_2POW4           (0UL << WDT_WTCR_WTIS_Pos) /*!< Setting WDT time-out interval to 2^4 * WDT clocks */
N#define WDT_TIMEOUT_2POW6           (1UL << WDT_WTCR_WTIS_Pos) /*!< Setting WDT time-out interval to 2^6 * WDT clocks */
N#define WDT_TIMEOUT_2POW8           (2UL << WDT_WTCR_WTIS_Pos) /*!< Setting WDT time-out interval to 2^8 * WDT clocks */
N#define WDT_TIMEOUT_2POW10          (3UL << WDT_WTCR_WTIS_Pos) /*!< Setting WDT time-out interval to 2^10 * WDT clocks */
N#define WDT_TIMEOUT_2POW12          (4UL << WDT_WTCR_WTIS_Pos) /*!< Setting WDT time-out interval to 2^12 * WDT clocks */
N#define WDT_TIMEOUT_2POW14          (5UL << WDT_WTCR_WTIS_Pos) /*!< Setting WDT time-out interval to 2^14 * WDT clocks */
N#define WDT_TIMEOUT_2POW16          (6UL << WDT_WTCR_WTIS_Pos) /*!< Setting WDT time-out interval to 2^16 * WDT clocks */
N#define WDT_TIMEOUT_2POW18          (7UL << WDT_WTCR_WTIS_Pos) /*!< Setting WDT time-out interval to 2^18 * WDT clocks */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* WTCRALT Constants Definitions                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define WDT_RESET_DELAY_1026CLK     (0UL << WDT_WTCRALT_WTRDSEL_Pos) /*!< Setting WDT reset delay period to 1026 * WDT clocks */
N#define WDT_RESET_DELAY_130CLK      (1UL << WDT_WTCRALT_WTRDSEL_Pos) /*!< Setting WDT reset delay period to 130 * WDT clocks */
N#define WDT_RESET_DELAY_18CLK       (2UL << WDT_WTCRALT_WTRDSEL_Pos) /*!< Setting WDT reset delay period to 18 * WDT clocks */
N#define WDT_RESET_DELAY_3CLK        (3UL << WDT_WTCRALT_WTRDSEL_Pos) /*!< Setting WDT reset delay period to 3 * WDT clocks */
N
N/*@}*/ /* end of group WDT_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup WDT_EXPORTED_FUNCTIONS WDT Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Clear WDT Reset System Flag
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro clear WDT time-out reset system flag.
N  */
N#define WDT_CLEAR_RESET_FLAG()          (WDT->WTCR = (WDT->WTCR & ~(WDT_WTCR_WTIF_Msk | WDT_WTCR_WTWKF_Msk)) | WDT_WTCR_WTRF_Msk)
N
N/**
N  * @brief      Clear WDT Time-out Interrupt Flag
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro clear WDT time-out interrupt flag.
N  */
N#define WDT_CLEAR_TIMEOUT_INT_FLAG()    (WDT->WTCR = (WDT->WTCR & ~(WDT_WTCR_WTRF_Msk | WDT_WTCR_WTWKF_Msk)) | WDT_WTCR_WTIF_Msk)
N
N/**
N  * @brief      Clear WDT Wake-up Flag
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro clear WDT time-out wake-up system flag.
N  */
N#define WDT_CLEAR_TIMEOUT_WAKEUP_FLAG() (WDT->WTCR = (WDT->WTCR & ~(WDT_WTCR_WTRF_Msk | WDT_WTCR_WTIF_Msk)) | WDT_WTCR_WTWKF_Msk)
N
N/**
N  * @brief      Get WDT Time-out Reset Flag
N  *
N  * @param      None
N  *
N  * @retval     0   WDT did not cause system reset
N  * @retval     1   WDT caused system reset
N  *
N  * @details    This macro indicate WDT time-out to reset system or not.
N  */
N#define WDT_GET_RESET_FLAG()            ((WDT->WTCR & WDT_WTCR_WTRF_Msk)? 1 : 0)
N
N/**
N  * @brief      Get WDT Time-out Interrupt Flag
N  *
N  * @param      None
N  *
N  * @retval     0   WDT time-out interrupt did not occur
N  * @retval     1   WDT time-out interrupt occurred
N  *
N  * @details    This macro indicate WDT time-out interrupt occurred or not.
N  */
N#define WDT_GET_TIMEOUT_INT_FLAG()      ((WDT->WTCR & WDT_WTCR_WTIF_Msk)? 1 : 0)
N
N/**
N  * @brief      Get WDT Time-out Wake-up Flag
N  *
N  * @param      None
N  *
N  * @retval     0   WDT did not wake up system
N  * @retval     1   WDT waked up system
N  *
N  * @details    This macro indicate WDT time-out waked system up or not
N  */
N#define WDT_GET_TIMEOUT_WAKEUP_FLAG()   ((WDT->WTCR & WDT_WTCR_WTWKF_Msk)? 1 : 0)
N
N/**
N  * @brief      Reset WDT Counter
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro is used to reset 18-bit WDT counter.
N  * @note       If WDT is activated and enabled to reset system, user must reset WDT counter \n
N  *             before WDT time-out plus reset delay reached. Or WDT generate a reset signal.
N  */
N#define WDT_RESET_COUNTER()             (WDT->WTCR  = (WDT->WTCR & ~(WDT_WTCR_WTIF_Msk | WDT_WTCR_WTWKF_Msk | WDT_WTCR_WTRF_Msk)) | WDT_WTCR_WTR_Msk)
N
N/**
N  * @brief      Stop WDT Counting
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This function stops WDT counting and disable WDT module.
N  */
Nstatic __INLINE void WDT_Close(void)
Xstatic __inline void WDT_Close(void)
N{
N    WDT->WTCR = 0;
X    ((WDT_T *) ((( uint32_t)0x40000000) + 0x4000))->WTCR = 0;
N    return;
N}
N
N/**
N  * @brief      Enable WDT Time-out Interrupt
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This function enable the WDT time-out interrupt.
N  */
Nstatic __INLINE void WDT_EnableInt(void)
Xstatic __inline void WDT_EnableInt(void)
N{
N    WDT->WTCR |= WDT_WTCR_WTIE_Msk;
X    ((WDT_T *) ((( uint32_t)0x40000000) + 0x4000))->WTCR |= (1ul << 6);
N    return;
N}
N
N/**
N  * @brief      Disable WDT Time-out Interrupt
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This function disables the WDT time-out interrupt.
N  */
Nstatic __INLINE void WDT_DisableInt(void)
Xstatic __inline void WDT_DisableInt(void)
N{
N    // Do not touch write 1 clear bits
N    WDT->WTCR &= ~(WDT_WTCR_WTIE_Msk | WDT_WTCR_WTRF_Msk | WDT_WTCR_WTIF_Msk | WDT_WTCR_WTWKF_Msk);
X    ((WDT_T *) ((( uint32_t)0x40000000) + 0x4000))->WTCR &= ~((1ul << 6) | (1ul << 2) | (1ul << 3) | (1ul << 5));
N    return;
N}
N
Nvoid WDT_Open(uint32_t u32TimeoutInterval, uint32_t u32ResetDelay, uint32_t u32EnableReset, uint32_t u32EnableWakeup);
N
N/*@}*/ /* end of group WDT_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group WDT_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__WDT_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 12453 ".\Libraries\Device\Nuvoton\NUC230_240\Include\NUC230_240.h" 2
N#include "WWDT.h"
L 1 ".\Libraries\StdDriver\inc\WWDT.h" 1
N/**************************************************************************//**
N * @file     wwdt.h
N * @version  V3.00
N * $Revision: 2 $
N * $Date: 15/05/06 10:18a $
N * @brief    NUC230_240 series WWDT driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __WWDT_H__
N#define __WWDT_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup WWDT_Driver WWDT Driver
N  @{
N*/
N
N/** @addtogroup WWDT_EXPORTED_CONSTANTS WWDT Exported Constants
N  @{
N*/
N/*---------------------------------------------------------------------------------------------------------*/
N/* WWDTCR Constants Definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define WWDT_PRESCALER_1        (0 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< Select max time-out period to 1 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_2        (1 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< Select max time-out period to 2 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_4        (2 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< Select max time-out period to 4 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_8        (3 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< Select max time-out period to 8 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_16       (4 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< Select max time-out period to 16 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_32       (5 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< Select max time-out period to 32 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_64       (6 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< Select max time-out period to 64 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_128      (7 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< Select max time-out period to 128 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_192      (8 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< Select max time-out period to 192 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_256      (9 << WWDT_WWDTCR_PERIODSEL_Pos)  /*!< Select max time-out period to 256 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_384      (10 << WWDT_WWDTCR_PERIODSEL_Pos) /*!< Select max time-out period to 384 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_512      (11 << WWDT_WWDTCR_PERIODSEL_Pos) /*!< Select max time-out period to 512 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_768      (12 << WWDT_WWDTCR_PERIODSEL_Pos) /*!< Select max time-out period to 768 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_1024     (13 << WWDT_WWDTCR_PERIODSEL_Pos) /*!< Select max time-out period to 1024 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_1536     (14 << WWDT_WWDTCR_PERIODSEL_Pos) /*!< Select max time-out period to 1536 * (64*WWDT_CLK) */
N#define WWDT_PRESCALER_2048     (15 << WWDT_WWDTCR_PERIODSEL_Pos) /*!< Select max time-out period to 2048 * (64*WWDT_CLK) */
N
N#define WWDT_RELOAD_WORD        (0x00005AA5)                      /*!< Fill this value to WWDTRLD register to reload WWDT counter */
N
N/*@}*/ /* end of group WWDT_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup WWDT_EXPORTED_FUNCTIONS WWDT Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Clear WWDT Reset System Flag
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro is used to clear WWDT counter time-out reset system flag.
N  */
N#define WWDT_CLEAR_RESET_FLAG()     (WWDT->WWDTSR = WWDT_WWDTSR_WWDTRF_Msk)
N
N/**
N  * @brief      Clear WWDT Compared Match Interrupt Flag
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro is used to clear WWDT counter compare match interrupt flag.
N  */
N#define WWDT_CLEAR_INT_FLAG()       (WWDT->WWDTSR = WWDT_WWDTSR_WWDTIF_Msk)
N
N/**
N  * @brief      Get WWDT Reset Flag
N  *
N  * @param      None
N  *
N  * @retval     0   WWDT did not cause system reset
N  * @retval     1   WWDT counter time-out caused system reset
N  *
N  * @details    This macro is used to indicate WWDT counter time-out reset system flag.
N  */
N#define WWDT_GET_RESET_FLAG()       ((WWDT->WWDTSR & WWDT_WWDTSR_WWDTRF_Msk)? 1:0)
N
N/**
N  * @brief      Get WWDT Compared Match Interrupt Flag
N  *
N  * @param      None
N  *
N  * @retval     0   WWDT counter compare match interrupt did not occur
N  * @retval     1   WWDT counter compare match interrupt occurred
N  *
N  * @details    This macro is used to indicate WWDT counter compare match interrupt occurred or not.
N  */
N#define WWDT_GET_INT_FLAG()         ((WWDT->WWDTSR & WWDT_WWDTSR_WWDTIF_Msk)? 1:0)
N
N/**
N  * @brief      Get WWDT Counter value
N  *
N  * @param      None
N  *
N  * @return     WWDT Counter Value
N  *
N  * @details    This macro to reflects the current WWDT counter value.
N  */
N#define WWDT_GET_COUNTER()          (WWDT->WWDTCVR)
N
N/**
N  * @brief      Reload WWDT Counter
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro is used to reload the WWDT counter value to 0x3F.
N  * @note       After WWDT enabled, user must reload WWDT counter while current counter is less than compare value \n
N  *             and larger than 0, otherwise WWDT will cause system reset immediately.
N  */
N#define WWDT_RELOAD_COUNTER()       (WWDT->WWDTRLD = WWDT_RELOAD_WORD)
N
Nvoid WWDT_Open(uint32_t u32PreScale, uint32_t u32CmpValue, uint32_t u32EnableInt);
N
N/*@}*/ /* end of group WWDT_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group WWDT_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__WWDT_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 12454 ".\Libraries\Device\Nuvoton\NUC230_240\Include\NUC230_240.h" 2
N#include "RTC.h"
L 1 ".\Libraries\StdDriver\inc\RTC.h" 1
N/**************************************************************************//**
N * @file     rtc.h
N * @version  V3.00
N * $Revision: 3 $
N * $Date: 15/05/08 2:51p $
N * @brief    NUC230_240 series RTC driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __RTC_H__
N#define __RTC_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup RTC_Driver RTC Driver
N  @{
N*/
N
N/** @addtogroup RTC_EXPORTED_CONSTANTS RTC Exported Constants
N  @{
N*/
N
N#define RTC_INIT_KEY            0xA5EB1357UL    /*!< RTC Initiation Key to make RTC leaving reset state */
N#define RTC_WRITE_KEY           0x0000A965UL    /*!< RTC Access Key to enable RTC read/write accessible and kept 1024 RTC clock */
N
N#define RTC_WAIT_COUNT          0xFFFFFFFF      /*!< Initial Time-out Value */
N
N#define RTC_YEAR2000            2000            /*!< RTC Reference for compute year data */
N#define RTC_FCR_REFERENCE       32761           /*!< RTC Reference for frequency compensation */
N
N#define RTC_CLOCK_12            0               /*!< RTC as 12-hour time scale with AM and PM indication */
N#define RTC_CLOCK_24            1               /*!< RTC as 24-hour time scale */
N
N#define RTC_AM                  1               /*!< RTC as AM indication */
N#define RTC_PM                  2               /*!< RTC as PM indication */
N
N#define RTC_TICK_1_SEC          0x0UL           /*!< RTC time tick is 1 second */
N#define RTC_TICK_1_2_SEC        0x1UL           /*!< RTC time tick is 1/2 second */
N#define RTC_TICK_1_4_SEC        0x2UL           /*!< RTC time tick is 1/4 second */
N#define RTC_TICK_1_8_SEC        0x3UL           /*!< RTC time tick is 1/8 second */
N#define RTC_TICK_1_16_SEC       0x4UL           /*!< RTC time tick is 1/16 second */
N#define RTC_TICK_1_32_SEC       0x5UL           /*!< RTC time tick is 1/32 second */
N#define RTC_TICK_1_64_SEC       0x6UL           /*!< RTC time tick is 1/64 second */
N#define RTC_TICK_1_128_SEC      0x7UL           /*!< RTC time tick is 1/128 second */
N
N#define RTC_SUNDAY              0x0UL           /*!< Day of the Week is Sunday */
N#define RTC_MONDAY              0x1UL           /*!< Day of the Week is Monday */
N#define RTC_TUESDAY             0x2UL           /*!< Day of the Week is Tuesday */
N#define RTC_WEDNESDAY           0x3UL           /*!< Day of the Week is Wednesday */
N#define RTC_THURSDAY            0x4UL           /*!< Day of the Week is Thursday */
N#define RTC_FRIDAY              0x5UL           /*!< Day of the Week is Friday */
N#define RTC_SATURDAY            0x6UL           /*!< Day of the Week is Saturday */
N
N#define RTC_SNOOPER_LOW_LEVEL       0x0UL       /*!< Snooper pin detected is low-level trigger */
N#define RTC_SNOOPER_HIGH_LEVEL      0x2UL       /*!< Snooper pin detected is high-level trigger */
N#define RTC_SNOOPER_FALLING_EDGE    0x8UL       /*!< Snooper pin detected is falling-edge trigger */
N#define RTC_SNOOPER_RISING_EDGE     0xAUL       /*!< Snooper pin detected is rising-edge trigger */
N#define RTC_SNOOPER_DETECT_Msk      0xAUL       /*!< Snooper pin detected mask bits */
N
N/*@}*/ /* end of group RTC_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup RTC_EXPORTED_STRUCTS RTC Exported Structs
N  @{
N*/
N/**
N  * @details    RTC define Time Data Struct
N  */
Ntypedef struct
N{
N    uint32_t u32Year;           /*!< Year value */
N    uint32_t u32Month;          /*!< Month value */
N    uint32_t u32Day;            /*!< Day value */
N    uint32_t u32DayOfWeek;      /*!< Day of week value */
N    uint32_t u32Hour;           /*!< Hour value */
N    uint32_t u32Minute;         /*!< Minute value */
N    uint32_t u32Second;         /*!< Second value */
N    uint32_t u32TimeScale;      /*!< 12-Hour, 24-Hour */
N    uint32_t u32AmPm;           /*!< Only Time Scale select 12-hr used */
N} S_RTC_TIME_DATA_T;
N
N/*@}*/ /* end of group RTC_EXPORTED_STRUCTS */
N
N
N/** @addtogroup RTC_EXPORTED_FUNCTIONS RTC Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Indicate is Leap Year or not
N  *
N  * @param      None
N  *
N  * @retval     0   This year is not a leap year
N  * @retval     1   This year is a leap year
N  *
N  * @details    According to current date, return this year is leap year or not.
N  */
N#define RTC_IS_LEAP_YEAR()              ((RTC->LIR & RTC_LIR_LIR_Msk)? 1:0)
N
N/**
N  * @brief      Clear RTC Alarm Interrupt Flag
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro is used to clear RTC alarm interrupt flag.
N  */
N#define RTC_CLEAR_ALARM_INT_FLAG()      (RTC->RIIR = RTC_RIIR_AIF_Msk)
N
N/**
N  * @brief      Clear RTC Tick Interrupt Flag
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro is used to clear RTC tick interrupt flag.
N  */
N#define RTC_CLEAR_TICK_INT_FLAG()       (RTC->RIIR = RTC_RIIR_TIF_Msk)
N
N/**
N  * @brief      Get RTC Alarm Interrupt Flag
N  *
N  * @param      None
N  *
N  * @retval     0   RTC alarm interrupt did not occur
N  * @retval     1   RTC alarm interrupt occurred
N  *
N  * @details    This macro indicate RTC alarm interrupt occurred or not.
N  */
N#define RTC_GET_ALARM_INT_FLAG()        ((RTC->RIIR & RTC_RIIR_AIF_Msk)? 1:0)
N
N/**
N  * @brief      Get RTC Time Tick Interrupt Flag
N  *
N  * @param      None
N  *
N  * @retval     0   RTC time tick interrupt did not occur
N  * @retval     1   RTC time tick interrupt occurred
N  *
N  * @details    This macro indicate RTC time tick interrupt occurred or not.
N  */
N#define RTC_GET_TICK_INT_FLAG()         ((RTC->RIIR & RTC_RIIR_TIF_Msk)? 1:0)
N
N/**
N  * @brief      Clear RTC Snooper Interrupt Flag
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This macro clear RTC snooper pin interrupt flag.
N  */
N#define RTC_CLEAR_SNOOPER_INT_FLAG()    (RTC->RIIR = RTC_RIIR_SNOOPIF_Msk)
N
N/**
N  * @brief      Get RTC Snooper Pin Flag
N  *
N  * @param      None
N  *
N  * @retval     0   RTC snooper pin interrupt did not occur
N  * @retval     1   RTC snooper pin interrupt occurred
N  *
N  * @details    This macro indicate RTC snooper pin interrupt occurred or not.
N  */
N#define RTC_GET_SNPPOER_INT_FLAG()      ((RTC->RIIR & RTC_RIIR_SNOOPIF_Msk)? 1:0)
N
N/**
N  * @brief      Read Spare Register
N  *
N  * @param[in]  u32RegNum   The spare register number, 0~19.
N  *
N  * @return     Spare register content
N  *
N  * @details    Read the specify spare register content.
N  * @note       The returned value is valid only when SPRRDY(SPRCTL[7] SPR Register Ready) bit is set. \n
N  *             And its controlled by RTC Access Enable Register.
N  */
N#define RTC_READ_SPARE_REGISTER(u32RegNum)                  (RTC->SPR[(u32RegNum)])
N
N/**
N  * @brief      Write Spare Register
N  *
N  * @param[in]  u32RegNum    The spare register number, 0~19.
N  * @param[in]  u32RegValue  The spare register value.
N  *
N  * @return     None
N  *
N  * @details    Write specify data to spare register.
N  * @note       This macro is effect only when SPRRDY(SPRCTL[7] SPR Register Ready) bit is set. \n
N  *             And its controlled by RTC Access Enable Register.
N  */
N#define RTC_WRITE_SPARE_REGISTER(u32RegNum, u32RegValue)    (RTC->SPR[(u32RegNum)] = (u32RegValue))
N
N/**
N  * @brief      Wait RTC Access Enable
N  *
N  * @param      None
N  *
N  * @return     None
N  *
N  * @details    This function is used to enable the maximum RTC read/write accessible time.
N  */
Nstatic __INLINE void RTC_WaitAccessEnable(void)
Xstatic __inline void RTC_WaitAccessEnable(void)
N{
N    /* To wait AER bit is cleared and enable AER bit (Access bit) again */
N    while((RTC->AER & RTC_AER_ENF_Msk) == RTC_AER_ENF_Msk);
X    while((((RTC_T *) ((( uint32_t)0x40000000) + 0x08000))->AER & (1ul << 16)) == (1ul << 16));
N    RTC->AER = RTC_WRITE_KEY;
X    ((RTC_T *) ((( uint32_t)0x40000000) + 0x08000))->AER = 0x0000A965UL;
N
N    /* To wait AER bit is set and user can access the RTC registers from now on */
N    while((RTC->AER & RTC_AER_ENF_Msk) == 0x0);
X    while((((RTC_T *) ((( uint32_t)0x40000000) + 0x08000))->AER & (1ul << 16)) == 0x0);
N}
N
Nvoid RTC_Open(S_RTC_TIME_DATA_T *sPt);
Nvoid RTC_Close(void);
Nvoid RTC_32KCalibration(int32_t i32FrequencyX100);
Nvoid RTC_GetDateAndTime(S_RTC_TIME_DATA_T *sPt);
Nvoid RTC_GetAlarmDateAndTime(S_RTC_TIME_DATA_T *sPt);
Nvoid RTC_SetDateAndTime(S_RTC_TIME_DATA_T *sPt);
Nvoid RTC_SetAlarmDateAndTime(S_RTC_TIME_DATA_T *sPt);
Nvoid RTC_SetDate(uint32_t u32Year, uint32_t u32Month, uint32_t u32Day, uint32_t u32DayOfWeek);
Nvoid RTC_SetTime(uint32_t u32Hour, uint32_t u32Minute, uint32_t u32Second, uint32_t u32TimeMode, uint32_t u32AmPm);
Nvoid RTC_SetAlarmDate(uint32_t u32Year, uint32_t u32Month, uint32_t u32Day);
Nvoid RTC_SetAlarmTime(uint32_t u32Hour, uint32_t u32Minute, uint32_t u32Second, uint32_t u32TimeMode, uint32_t u32AmPm);
Nuint32_t RTC_GetDayOfWeek(void);
Nvoid RTC_SetTickPeriod(uint32_t u32TickSelection);
Nvoid RTC_EnableInt(uint32_t u32IntFlagMask);
Nvoid RTC_DisableInt(uint32_t u32IntFlagMask);
Nvoid RTC_EnableSpareRegister(void);
Nvoid RTC_DisableSpareRegister(void);
Nvoid RTC_EnableSnooperDetection(uint32_t u32PinCondition);
Nvoid RTC_DisableSnooperDetection(void);
N
N/*@}*/ /* end of group RTC_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group RTC_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__RTC_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 12455 ".\Libraries\Device\Nuvoton\NUC230_240\Include\NUC230_240.h" 2
N#include "UART.h"
L 1 ".\Libraries\StdDriver\inc\UART.h" 1
N/**************************************************************************//**
N * @file     UART.h
N * @version  V3.0
N * $Revision: 11 $
N * $Date: 15/06/04 11:14a $
N * @brief    NUC230_240 Series UART Interface Controller Driver Header File
N *
N * @note
N * Copyright (C) 2011 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __UART_H__
N#define __UART_H__
N
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup UART_Driver UART Driver
N  @{
N*/
N
N/** @addtogroup UART_EXPORTED_CONSTANTS UART Exported Constants
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART FIFO size constants definitions                                                                    */
N/*---------------------------------------------------------------------------------------------------------*/
N
N#define UART0_FIFO_SIZE 64 /*!< UART0 supports separated receive/transmit 64/64 bytes entry FIFO */
N#define UART1_FIFO_SIZE 16 /*!< UART1 supports separated receive/transmit 16/16 bytes entry FIFO */
N#define UART2_FIFO_SIZE 16 /*!< UART2 supports separated receive/transmit 16/16 bytes entry FIFO */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UA_FCR constants definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N
N#define UART_FCR_RFITL_1BYTE        (0x0 << UART_FCR_RFITL_Pos)   /*!< UA_FCR setting to set RX FIFO Trigger Level to 1 bit */
N#define UART_FCR_RFITL_4BYTES       (0x1 << UART_FCR_RFITL_Pos)   /*!< UA_FCR setting to set RX FIFO Trigger Level to 4 bits */
N#define UART_FCR_RFITL_8BYTES       (0x2 << UART_FCR_RFITL_Pos)   /*!< UA_FCR setting to set RX FIFO Trigger Level to 8 bits */
N#define UART_FCR_RFITL_14BYTES      (0x3 << UART_FCR_RFITL_Pos)   /*!< UA_FCR setting to set RX FIFO Trigger Level to 14 bits */
N
N#define UART_FCR_RTS_TRI_LEV_1BYTE        (0x0 << UART_FCR_RTS_TRI_LEV_Pos)  /*!< UA_FCR setting to set RTS Trigger Level to 1 bit */
N#define UART_FCR_RTS_TRI_LEV_4BYTES       (0x1 << UART_FCR_RTS_TRI_LEV_Pos)  /*!< UA_FCR setting to set RTS Trigger Level to 4 bits */
N#define UART_FCR_RTS_TRI_LEV_8BYTES       (0x2 << UART_FCR_RTS_TRI_LEV_Pos)  /*!< UA_FCR setting to set RTS Trigger Level to 8 bits */
N#define UART_FCR_RTS_TRI_LEV_14BYTES      (0x3 << UART_FCR_RTS_TRI_LEV_Pos)  /*!< UA_FCR setting to set RTS Trigger Level to 14 bits */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UA_LCR constants definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_WORD_LEN_5        (0) /*!< UA_LCR setting to set UART word length to 5 bits */
N#define UART_WORD_LEN_6        (1) /*!< UA_LCR setting to set UART word length to 6 bits */
N#define UART_WORD_LEN_7        (2) /*!< UA_LCR setting to set UART word length to 7 bits */
N#define UART_WORD_LEN_8        (3) /*!< UA_LCR setting to set UART word length to 8 bits */
N
N#define UART_PARITY_NONE    (0x0 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to set UART as no parity   */
N#define UART_PARITY_ODD     (0x1 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to set UART as odd parity  */
N#define UART_PARITY_EVEN    (0x3 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to set UART as even parity */
N#define UART_PARITY_MARK    (0x5 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to keep parity bit as '1'  */
N#define UART_PARITY_SPACE   (0x7 << UART_LCR_PBE_Pos) /*!< UA_LCR setting to keep parity bit as '0'  */
N
N#define UART_STOP_BIT_1     (0x0 << UART_LCR_NSB_Pos) /*!< UA_LCR setting for one stop bit  */
N#define UART_STOP_BIT_1_5   (0x1 << UART_LCR_NSB_Pos) /*!< UA_LCR setting for 1.5 stop bit when 5-bit word length  */
N#define UART_STOP_BIT_2     (0x1 << UART_LCR_NSB_Pos) /*!< UA_LCR setting for two stop bit when 6, 7, 8-bit word length */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART RTS LEVEL TRIGGER constants definitions                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_RTS_IS_HIGH_LEV_ACTIVE    (0x1 << UART_MCR_LEV_RTS_Pos) /*!< Set RTS is High Level Active */
N#define UART_RTS_IS_LOW_LEV_ACTIVE     (0x0 << UART_MCR_LEV_RTS_Pos) /*!< Set RTS is Low Level Active */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UA_IRCR constants definitions                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_IRCR_TX_SELECT         (1) /*!< Set IrDA function Tx mode */
N#define UART_IRCR_RX_SELECT         (0) /*!< Set IrDA function Rx mode */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UA_FUNC_SEL constants definitions                                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_FUNC_SEL_UART    (0x0 << UART_FUN_SEL_FUN_SEL_Pos) /*!< UA_FUNC_SEL setting to set UART Function  (Default) */
N#define UART_FUNC_SEL_LIN     (0x1 << UART_FUN_SEL_FUN_SEL_Pos) /*!< UA_FUNC_SEL setting to set LIN Function             */
N#define UART_FUNC_SEL_IrDA    (0x2 << UART_FUN_SEL_FUN_SEL_Pos) /*!< UA_FUNC_SEL setting to set IrDA Function            */
N#define UART_FUNC_SEL_RS485   (0x3 << UART_FUN_SEL_FUN_SEL_Pos) /*!< UA_FUNC_SEL setting to set RS485 Function           */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UA_LIN_CTL constants definitions                                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_LIN_CTL_LINS_EN        (0x1UL << UART_LIN_CTL_LINS_EN_Pos)       /*!< UA_LIN_CTL setting to set LIN Slave Mode Enable */
N#define UART_LIN_CTL_LINS_HDET_EN   (0x1UL << UART_LIN_CTL_LINS_HDET_EN_Pos)  /*!< UA_LIN_CTL setting to set LIN Slave Header Detection Enable */
N#define UART_LIN_CTL_LINS_ARS_EN    (0x1UL << UART_LIN_CTL_LINS_ARS_EN_Pos)   /*!< UA_LIN_CTL setting to set LIN Slave Automatic Resynchronization Mode Enable */
N#define UART_LIN_CTL_LINS_DUM_EN    (0x1UL << UART_LIN_CTL_LINS_DUM_EN_Pos)   /*!< UA_LIN_CTL setting to set LIN Slave Divider Update Method Enable */
N#define UART_LIN_CTL_LIN_MUTE_EN    (0x1UL << UART_LIN_CTL_LIN_MUTE_EN_Pos)   /*!< UA_LIN_CTL setting to set LIN Mute Mode Enable */
N#define UART_LIN_CTL_LIN_SHD        (0x1UL << UART_LIN_CTL_LIN_SHD_Pos)       /*!< UA_LIN_CTL setting to set LIN TX Send Header Enable */
N#define UART_LIN_CTL_LIN_IDPEN      (0x1UL << UART_LIN_CTL_LIN_IDPEN_Pos)     /*!< UA_LIN_CTL setting to set LIN ID Parity Enable */
N#define UART_LIN_CTL_LIN_BKDET_EN   (0x1UL << UART_LIN_CTL_LIN_BKDET_EN_Pos)  /*!< UA_LIN_CTL setting to set LIN Break Detection Enable */
N#define UART_LIN_CTL_LIN_RX_DIS     (0x1UL << UART_LIN_CTL_LIN_RX_DIS_Pos)    /*!< UA_LIN_CTL setting to set LIN Receiver Disable */
N#define UART_LIN_CTL_BIT_ERR_EN     (0x1UL << UART_LIN_CTL_BIT_ERR_EN_Pos)    /*!< UA_LIN_CTL setting to set Bit Error Detect Enable */
N#define UART_LIN_CTL_LIN_BKFL(x)    (((x)-1) << UART_LIN_CTL_LIN_BKFL_Pos)  /*!< UA_LIN_CTL setting to set LIN Break Field Length, x = 10 ~ 15, default value is 12 */
N#define UART_LIN_CTL_LIN_BS_LEN(x)  (((x)-1) << UART_LIN_CTL_LIN_BS_LEN_Pos)/*!< UA_LIN_CTL setting to set LIN Break/Sync Delimiter Length, x = 1 ~ 4 */
N#define UART_LIN_CTL_LIN_HEAD_SEL_BREAK             (0x0UL << UART_LIN_CTL_LIN_HEAD_SEL_Pos)    /*!< UA_LIN_CTL setting to set LIN Header Select to break field */
N#define UART_LIN_CTL_LIN_HEAD_SEL_BREAK_SYNC        (0x1UL << UART_LIN_CTL_LIN_HEAD_SEL_Pos)    /*!< UA_LIN_CTL setting to set LIN Header Select to break field and sync field */
N#define UART_LIN_CTL_LIN_HEAD_SEL_BREAK_SYNC_ID     (0x2UL << UART_LIN_CTL_LIN_HEAD_SEL_Pos)    /*!< UA_LIN_CTL setting to set LIN Header Select to break field, sync field and ID field*/
N#define UART_LIN_CTL_LIN_LIN_PID(x) ((x) << UART_LIN_CTL_LIN_PID_Pos)       /*!< UA_LIN_CTL setting to set LIN PID value */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* UART BAUDRATE MODE constants definitions                                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
N#define UART_BAUD_MODE0     (0) /*!< Set UART Baudrate Mode is Mode0 */
N#define UART_BAUD_MODE2     (UART_BAUD_DIV_X_EN_Msk | UART_BAUD_DIV_X_ONE_Msk) /*!< Set UART Baudrate Mode is Mode2 */
N
N
N/*@}*/ /* end of group UART_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup UART_EXPORTED_FUNCTIONS UART Exported Functions
N  @{
N*/
N
N
N/**
N *    @brief        Calculate UART baudrate mode0 divider
N *
N *    @param[in]    u32SrcFreq      UART clock frequency
N *    @param[in]    u32BaudRate     Baudrate of UART module
N *
N *    @return       UART baudrate mode0 divider
N *
N *    @details      This macro calculate UART baudrate mode0 divider.
N */
N#define UART_BAUD_MODE0_DIVIDER(u32SrcFreq, u32BaudRate)    ((((u32SrcFreq) + ((u32BaudRate)*8)) / (u32BaudRate) >> 4)-2)
N
N/**
N *    @brief        Calculate UART baudrate mode2 divider
N *
N *    @param[in]    u32SrcFreq      UART clock frequency
N *    @param[in]    u32BaudRate     Baudrate of UART module
N *
N *    @return       UART baudrate mode2 divider
N *
N *    @details      This macro calculate UART baudrate mode2 divider.
N */
N#define UART_BAUD_MODE2_DIVIDER(u32SrcFreq, u32BaudRate)    ((((u32SrcFreq) + ((u32BaudRate)/2)) / (u32BaudRate))-2)
N
N
N/**
N *    @brief        Write data
N *
N *    @param[in]    uart    The base address of UART module
N *    @param[in]    u8Data  Data byte to transmit
N *
N *    @return       None
N *
N *    @details      This macro write Data to Tx data register.
N */
N#define UART_WRITE(uart, u8Data)    ((uart)->THR = (u8Data))
N
N/**
N *    @brief        Read data
N *
N *    @param[in]    uart    The base address of UART module
N *
N *    @return       The oldest data byte in RX FIFO
N *
N *    @details      This macro read Rx data register.
N */
N#define UART_READ(uart)    ((uart)->RBR)
N
N
N/**
N *    @brief        Get Tx empty
N *
N *    @param[in]    uart    The pointer of the specified UART module.
N *
N *    @retval       0   Tx FIFO is not empty
N *    @retval       >=1 Tx FIFO is empty
N *
N *    @details      This macro get Tx empty register value.
N */
N#define UART_GET_TX_EMPTY(uart)    ((uart)->FSR & UART_FSR_TX_EMPTY_Msk)
N
N
N/**
N *    @brief        Get Rx empty
N *
N *    @param[in]    uart    The pointer of the specified UART module.
N *
N *    @retval       0   Rx FIFO is not empty
N *    @retval       >=1 Rx FIFO is empty
N *
N *    @details      This macro get Rx empty register value.
N */
N#define UART_GET_RX_EMPTY(uart)    ((uart)->FSR & UART_FSR_RX_EMPTY_Msk)
N
N/**
N *    @brief        Check specified uart port transmission is over.
N *
N *    @param[in]    uart    The pointer of the specified UART module.
N *
N *    @retval       0   Transmission is not over.
N *    @retval       1   Transmission is over.
N *
N *    @details      This macro return if Tx FIFO is empty and specified uart port transmission is over nor not.
N */
N#define UART_IS_TX_EMPTY(uart)    (((uart)->FSR & UART_FSR_TE_FLAG_Msk) >> UART_FSR_TE_FLAG_Pos)
N
N
N/**
N *    @brief        Wait specified uart port transmission is over
N *
N *    @param[in]    uart    The base address of UART module
N *
N *    @return       None
N *
N *    @details      This macro wait specified uart port transmission is over.
N */
N#define UART_WAIT_TX_EMPTY(uart)    while(!((((uart)->FSR) & UART_FSR_TE_FLAG_Msk) >> UART_FSR_TE_FLAG_Pos))
N
N/**
N *    @brief        Check RX is ready or not
N *
N *    @param[in]    uart    The base address of UART module
N *
N *    @retval       0 The number of bytes in the RX FIFO is less than the RFITL
N *    @retval       1 The number of bytes in the RX FIFO equals or larger than RFITL
N *
N *    @details      This macro check receive data available interrupt flag is set or not.
N */
N#define UART_IS_RX_READY(uart)    (((uart)->ISR & UART_ISR_RDA_IF_Msk)>>UART_ISR_RDA_IF_Pos)
N
N
N/**
N *    @brief        Check TX FIFO is full or not
N *
N *    @param[in]    uart    The base address of UART module
N *
N *    @retval       1 TX FIFO is full
N *    @retval       0 TX FIFO is not full
N *
N *    @details      This macro check TX FIFO is full or not.
N */
N#define UART_IS_TX_FULL(uart)    (((uart)->FSR & UART_FSR_TX_FULL_Msk)>>UART_FSR_TX_FULL_Pos)
N
N/**
N *    @brief        Check RX FIFO is full or not
N *
N *    @param[in]    uart    The base address of UART module
N *
N *    @retval       1 RX FIFO is full
N *    @retval       0 RX FIFO is not full
N *
N *    @details      This macro check RX FIFO is full or not.
N */
N#define UART_IS_RX_FULL(uart)    (((uart)->FSR & UART_FSR_RX_FULL_Msk)>>UART_FSR_RX_FULL_Pos)
N
N
N/**
N *    @brief        Get Tx full register value
N *
N *    @param[in]    uart    The pointer of the specified UART module.
N *
N *    @retval       0   Tx FIFO is not full.
N *    @retval       >=1 Tx FIFO is full.
N *
N *    @details      This macro get Tx full register value.
N */
N#define UART_GET_TX_FULL(uart)    ((uart)->FSR & UART_FSR_TX_FULL_Msk)
N
N
N/**
N *    @brief        Get Rx full register value
N *
N *    @param[in]    uart   The pointer of the specified UART module.
N *
N *    @retval       0   Rx FIFO is not full.
N *    @retval       >=1 Rx FIFO is full.
N *
N *    @details      This macro get Rx full register value.
N */
N#define UART_GET_RX_FULL(uart)    ((uart)->FSR & UART_FSR_RX_FULL_Msk)
N
N
N/**
N *    @brief        Enable specified UART interrupt
N *
N *    @param[in]    uart        The base address of UART module
N *    @param[in]    u32eIntSel  Interrupt type select
N *                              - UART_IER_LIN_IEN_Msk      : Lin bus interrupt
N *                              - UART_IER_WAKE_EN_Msk      : Wakeup interrupt
N *                              - UART_IER_BUF_ERR_IEN_Msk  : Buffer Error interrupt
N *                              - UART_IER_TOUT_IEN_Msk     : Rx time-out interrupt
N *                              - UART_IER_MODEM_IEN_Msk    : Modem interrupt
N *                              - UART_IER_RLS_IEN_Msk      : Rx Line status interrupt
N *                              - UART_IER_THRE_IEN_Msk     : Tx empty interrupt
N *                              - UART_IER_RDA_IEN_Msk      : Rx ready interrupt
N *
N *    @return       None
N *
N *    @details      This macro enable specified UART interrupt.
N */
N#define UART_ENABLE_INT(uart, u32eIntSel)    ((uart)->IER |= (u32eIntSel))
N
N
N/**
N *    @brief        Disable specified UART interrupt
N *
N *    @param[in]    uart        The base address of UART module
N *    @param[in]    u32eIntSel  Interrupt type select
N *                              - UART_IER_LIN_IEN_Msk      : Lin bus interrupt
N *                              - UART_IER_WAKE_EN_Msk      : Wakeup interrupt
N *                              - UART_IER_BUF_ERR_IEN_Msk  : Buffer Error interrupt
N *                              - UART_IER_TOUT_IEN_Msk     : Rx time-out interrupt
N *                              - UART_IER_MODEM_IEN_Msk    : Modem interrupt
N *                              - UART_IER_RLS_IEN_Msk      : Rx Line status interrupt
N *                              - UART_IER_THRE_IEN_Msk     : Tx empty interrupt
N *                              - UART_IER_RDA_IEN_Msk      : Rx ready interrupt
N *    @return       None
N *
N *    @details      This macro enable specified UART interrupt.
N */
N#define UART_DISABLE_INT(uart, u32eIntSel)    ((uart)->IER &= ~ (u32eIntSel))
N
N
N/**
N *    @brief        Get specified interrupt indicator status
N *
N *    @param[in]    uart            The pointer of the specified UART module.
N *    @param[in]    u32eIntTypeFlag Interrupt Type Flag, should be
N *                                  - UART_ISR_HW_BUF_ERR_INT_Msk   : In DMA Mode, Buffer Error Interrupt Indicator
N *                                  - UART_ISR_HW_TOUT_INT_Msk      : In DMA Mode, Rx Time-out Interrupt Indicator
N *                                  - UART_ISR_HW_MODEM_INT_Msk     : In DMA Mode, MODEM Status Interrupt Indicator
N *                                  - UART_ISR_HW_RLS_INT_Msk       : In DMA Mode, Rx Line Status Interrupt Indicator
N *                                  - UART_ISR_HW_BUF_ERR_IF_Msk    : In DMA Mode, Buffer Error Interrupt Flag
N *                                  - UART_ISR_HW_TOUT_IF_Msk       : In DMA Mode, Rx Time-out Interrupt Flag
N *                                  - UART_ISR_HW_MODEM_IF_Msk      : In DMA Mode, MODEM Status Interrupt Flag
N *                                  - UART_ISR_HW_RLS_IF_Msk        : In DMA Mode, Rx Line Status Interrupt Flag
N *                                  - UART_ISR_LIN_INT_Msk          : LIN Bus Interrupt Indicator
N *                                  - UART_ISR_BUF_ERR_INT_Msk      : Buffer Error Interrupt Indicator
N *                                  - UART_ISR_TOUT_INT_Msk         : Rx Time-out Interrupt Indicator
N *                                  - UART_ISR_MODEM_INT_Msk        : MODEM Status Interrupt Indicator
N *                                  - UART_ISR_RLS_INT_Msk          : Rx Line Status Interrupt Indicator
N *                                  - UART_ISR_THRE_INT_Msk         : Tx Empty Interrupt Indicator
N *                                  - UART_ISR_RDA_INT_Msk          : Rx Ready Interrupt Indicator
N *                                  - UART_ISR_LIN_IF_Msk           : LIN Bus Interrupt Flag
N *                                  - UART_ISR_BUF_ERR_IF_Msk       : Buffer Error Interrupt Flag
N *                                  - UART_ISR_TOUT_IF_Msk          : Rx Time-out Interrupt Flag
N *                                  - UART_ISR_MODEM_IF_Msk         : MODEM Status Interrupt Flag
N *                                  - UART_ISR_RLS_IF_Msk           : Rx Line Status Interrupt Flag
N *                                  - UART_ISR_THRE_IF_Msk          : Tx Empty Interrupt Flag
N *                                  - UART_ISR_RDA_IF_Msk           : Rx Ready Interrupt Flag
N *
N *    @retval       0 The specified interrupt is not happened.
N *    @retval       1 The specified interrupt is happened.
N *
N *    @details      This macro get specified interrupt flag or interrupt indicator status.
N */
N#define UART_GET_INT_FLAG(uart,u32eIntTypeFlag)    (((uart)->ISR & (u32eIntTypeFlag))?1:0)
N
N
N/**
N *    @brief        Set RTS pin to low
N *
N *    @param[in]    uart    The base address of UART module
N *
N *    @return       None
N *
N *    @details      This macro set RTS pin to low.
N */
N__STATIC_INLINE void UART_CLEAR_RTS(UART_T* uart)
Xstatic __inline void UART_CLEAR_RTS(UART_T* uart)
N{
N    (uart)->MCR |= UART_MCR_LEV_RTS_Msk;
X    (uart)->MCR |= (1ul << 9);
N    (uart)->MCR &= ~UART_MCR_RTS_Msk;
X    (uart)->MCR &= ~(1ul << 1);
N}
N
N/**
N *    @brief        Set RTS pin to high
N *
N *    @param[in]    uart    The base address of UART module
N *
N *    @return       None
N *
N *    @details      This macro set RTS pin to high.
N */
N__STATIC_INLINE void UART_SET_RTS(UART_T* uart)
Xstatic __inline void UART_SET_RTS(UART_T* uart)
N{
N    (uart)->MCR |= UART_MCR_LEV_RTS_Msk | UART_MCR_RTS_Msk;
X    (uart)->MCR |= (1ul << 9) | (1ul << 1);
N}
N
N
N/**
N *    @brief        Clear RS-485 Address Byte Detection Flag
N *
N *    @param[in]    uart    The base address of UART module
N *
N *    @return       None
N *
N *    @details      This macro clear RS-485address byte detection flag.
N */
N#define UART_RS485_CLEAR_ADDR_FLAG(uart)    ((uart)->FSR = UART_FSR_RS485_ADD_DETF_Msk)
N
N
N/**
N *    @brief        Get RS-485 Address Byte Detection Flag
N *
N *    @param[in]    uart    The base address of UART module
N *
N *    @return       RS-485 Address Byte Detection Flag
N *
N *    @details      This macro get RS-485address byte detection flag.
N */
N#define UART_RS485_GET_ADDR_FLAG(uart)    (((uart)->FSR  & UART_FSR_RS485_ADD_DETF_Msk) >> UART_FSR_RS485_ADD_DETF_Pos)
N
N
Nvoid UART_ClearIntFlag(UART_T* uart , uint32_t u32InterruptFlag);
Nvoid UART_Close(UART_T* uart);
Nvoid UART_DisableFlowCtrl(UART_T* uart);
Nvoid UART_DisableInt(UART_T*  uart, uint32_t u32InterruptFlag);
Nvoid UART_EnableFlowCtrl(UART_T* uart);
Nvoid UART_EnableInt(UART_T*  uart, uint32_t u32InterruptFlag);
Nvoid UART_Open(UART_T* uart, uint32_t u32baudrate);
Nuint32_t UART_Read(UART_T* uart, uint8_t *pu8RxBuf, uint32_t u32ReadBytes);
Nvoid UART_SetLine_Config(UART_T* uart, uint32_t u32baudrate, uint32_t u32data_width, uint32_t u32parity, uint32_t  u32stop_bits);
Nvoid UART_SetTimeoutCnt(UART_T* uart, uint32_t u32TOC);
Nvoid UART_SelectIrDAMode(UART_T* uart, uint32_t u32Buadrate, uint32_t u32Direction);
Nvoid UART_SelectRS485Mode(UART_T* uart, uint32_t u32Mode, uint32_t u32Addr);
Nvoid UART_SelectLINMode(UART_T* uart, uint32_t u32Mode, uint32_t u32BreakLength);
Nuint32_t UART_Write(UART_T* uart, uint8_t *pu8TxBuf, uint32_t u32WriteBytes);
N
N
N/*@}*/ /* end of group UART_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group UART_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__UART_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
N
L 12456 ".\Libraries\Device\Nuvoton\NUC230_240\Include\NUC230_240.h" 2
N#include "I2S.h"
L 1 ".\Libraries\StdDriver\inc\I2S.h" 1
N/**************************************************************************//**
N * @file     i2s.h
N * @version  V3.0
N * $Revision: 3 $
N * $Date: 15/08/19 11:08a $
N * @brief    NUC230_240 series I2S driver header file
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N ******************************************************************************/
N#ifndef __I2S_H__
N#define __I2S_H__
N
N#include "NUC230_240.h"
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup I2S_Driver I2S Driver
N  @{
N*/
N
N/** @addtogroup I2S_EXPORTED_CONSTANTS I2S Exported Constants
N  @{
N*/
N#define I2S_DATABIT_8           (0 << I2S_CON_WORDWIDTH_Pos)       /*!< I2S data width is 8-bit */
N#define I2S_DATABIT_16          (1 << I2S_CON_WORDWIDTH_Pos)       /*!< I2S data width is 16-bit */
N#define I2S_DATABIT_24          (2 << I2S_CON_WORDWIDTH_Pos)       /*!< I2S data width is 24-bit */
N#define I2S_DATABIT_32          (3 << I2S_CON_WORDWIDTH_Pos)       /*!< I2S data width is 32-bit */
N
N/* Audio Format */
N#define I2S_MONO                I2S_CON_MONO_Msk                   /*!< Mono channel */
N#define I2S_STEREO              0                                  /*!< Stereo channel */
N
N/* I2S Data Format */
N#define I2S_FORMAT_MSB          I2S_CON_FORMAT_Msk                 /*!< MSB data format */
N#define I2S_FORMAT_I2S          0                                  /*!< I2S data format */
N
N/* I2S Operation mode */
N#define I2S_MODE_SLAVE          I2S_CON_SLAVE_Msk                  /*!< As slave mode */
N#define I2S_MODE_MASTER         0                                  /*!< As master mode */
N
N/* I2S FIFO Threshold */
N#define I2S_FIFO_TX_LEVEL_WORD_0    0                              /*!< TX threshold is 0 word */
N#define I2S_FIFO_TX_LEVEL_WORD_1    (1 << I2S_CON_TXTH_Pos)        /*!< TX threshold is 1 word */
N#define I2S_FIFO_TX_LEVEL_WORD_2    (2 << I2S_CON_TXTH_Pos)        /*!< TX threshold is 2 words */
N#define I2S_FIFO_TX_LEVEL_WORD_3    (3 << I2S_CON_TXTH_Pos)        /*!< TX threshold is 3 words */
N#define I2S_FIFO_TX_LEVEL_WORD_4    (4 << I2S_CON_TXTH_Pos)        /*!< TX threshold is 4 words */
N#define I2S_FIFO_TX_LEVEL_WORD_5    (5 << I2S_CON_TXTH_Pos)        /*!< TX threshold is 5 words */
N#define I2S_FIFO_TX_LEVEL_WORD_6    (6 << I2S_CON_TXTH_Pos)        /*!< TX threshold is 6 words */
N#define I2S_FIFO_TX_LEVEL_WORD_7    (7 << I2S_CON_TXTH_Pos)        /*!< TX threshold is 7 words */
N
N#define I2S_FIFO_RX_LEVEL_WORD_1    0                              /*!< RX threshold is 1 word */
N#define I2S_FIFO_RX_LEVEL_WORD_2    (1 << I2S_CON_RXTH_Pos)        /*!< RX threshold is 2 words */
N#define I2S_FIFO_RX_LEVEL_WORD_3    (2 << I2S_CON_RXTH_Pos)        /*!< RX threshold is 3 words */
N#define I2S_FIFO_RX_LEVEL_WORD_4    (3 << I2S_CON_RXTH_Pos)        /*!< RX threshold is 4 words */
N#define I2S_FIFO_RX_LEVEL_WORD_5    (4 << I2S_CON_RXTH_Pos)        /*!< RX threshold is 5 words */
N#define I2S_FIFO_RX_LEVEL_WORD_6    (5 << I2S_CON_RXTH_Pos)        /*!< RX threshold is 6 words */
N#define I2S_FIFO_RX_LEVEL_WORD_7    (6 << I2S_CON_RXTH_Pos)        /*!< RX threshold is 7 words */
N#define I2S_FIFO_RX_LEVEL_WORD_8    (7 << I2S_CON_RXTH_Pos)        /*!< RX threshold is 8 words */
N
N/* I2S Record Channel */
N#define I2S_MONO_RIGHT          0                                  /*!< Record mono right channel */
N#define I2S_MONO_LEFT           I2S_CON_RXLCH_Msk                  /*!< Record mono left channel */
N
N/* I2S Channel */
N#define I2S_RIGHT               0                                  /*!< Select right channel */
N#define I2S_LEFT                1                                  /*!< Select left channel */
N
N/*@}*/ /* end of group I2S_EXPORTED_CONSTANTS */
N
N/** @addtogroup I2S_EXPORTED_FUNCTIONS I2S Exported Functions
N  @{
N*/
N/*---------------------------------------------------------------------------------------------------------*/
N/* inline functions                                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N/**
N  * @brief  Enable zero cross detection function.
N  * @param[in] i2s The base address of I2S module.
N  * @param[in] u32ChMask The mask for left or right channel. Valid values are:
N  *                    - \ref I2S_RIGHT
N  *                    - \ref I2S_LEFT
N  * @return None
N  * @details This function will set RCHZCEN or LCHZCEN bit of I2SCON register to enable zero cross detection function.
N  */
Nstatic __INLINE void I2S_ENABLE_TX_ZCD(I2S_T *i2s, uint32_t u32ChMask)
Xstatic __inline void I2S_ENABLE_TX_ZCD(I2S_T *i2s, uint32_t u32ChMask)
N{
N    if(u32ChMask == I2S_RIGHT)
X    if(u32ChMask == 0)
N        i2s->CON |= I2S_CON_RCHZCEN_Msk;
X        i2s->CON |= (1ul << 16);
N    else
N        i2s->CON |= I2S_CON_LCHZCEN_Msk;
X        i2s->CON |= (1ul << 17);
N}
N
N/**
N  * @brief  Disable zero cross detection function.
N  * @param[in] i2s The base address of I2S module.
N  * @param[in] u32ChMask The mask for left or right channel. Valid values are:
N  *                    - \ref I2S_RIGHT
N  *                    - \ref I2S_LEFT
N  * @return None
N  * @details This function will clear RCHZCEN or LCHZCEN bit of I2SCON register to disable zero cross detection function.
N  */
Nstatic __INLINE void I2S_DISABLE_TX_ZCD(I2S_T *i2s, uint32_t u32ChMask)
Xstatic __inline void I2S_DISABLE_TX_ZCD(I2S_T *i2s, uint32_t u32ChMask)
N{
N    if(u32ChMask == I2S_RIGHT)
X    if(u32ChMask == 0)
N        i2s->CON &= ~I2S_CON_RCHZCEN_Msk;
X        i2s->CON &= ~(1ul << 16);
N    else
N        i2s->CON &= ~I2S_CON_LCHZCEN_Msk;
X        i2s->CON &= ~(1ul << 17);
N}
N
N/**
N  * @brief  Enable I2S Tx DMA function.
N  * @param[in] i2s The base address of I2S module.
N  * @return None
N  * @details This macro will set TXDMA bit of I2SCON register to transmit data with PDMA.
N  */
N#define I2S_ENABLE_TXDMA(i2s)  ((i2s)->CON |= I2S_CON_TXDMA_Msk)
N
N/**
N  * @brief  Disable I2S Tx DMA function.
N  * @param[in] i2s The base address of I2S module.
N  * @return None
N  * @details This macro will clear TXDMA bit of I2SCON register to disable Tx DMA function.
N  */
N#define I2S_DISABLE_TXDMA(i2s) ((i2s)->CON &= ~I2S_CON_TXDMA_Msk)
N
N/**
N  * @brief  Enable I2S Rx DMA function.
N  * @param[in] i2s The base address of I2S module.
N  * @return None
N  * @details This macro will set RXDMA bit of I2SCON register to receive data with PDMA.
N  */
N#define I2S_ENABLE_RXDMA(i2s) ((i2s)->CON |= I2S_CON_RXDMA_Msk)
N
N/**
N  * @brief  Disable I2S Rx DMA function.
N  * @param[in] i2s The base address of I2S module.
N  * @return None
N  * @details This macro will clear RXDMA bit of I2SCON register to disable Rx DMA function.
N  */
N#define I2S_DISABLE_RXDMA(i2s) ((i2s)->CON &= ~I2S_CON_RXDMA_Msk)
N
N/**
N  * @brief  Enable I2S Tx function.
N  * @param[in] i2s The base address of I2S module.
N  * @return None
N  * @details This macro will set TXEN bit of I2SCON register to enable I2S Tx function.
N  */
N#define I2S_ENABLE_TX(i2s) ((i2s)->CON |= I2S_CON_TXEN_Msk)
N
N/**
N  * @brief  Disable I2S Tx function.
N  * @param[in] i2s The base address of I2S module.
N  * @return None
N  * @details This macro will clear TXEN bit of I2SCON register to disable I2S Tx function.
N  */
N#define I2S_DISABLE_TX(i2s) ((i2s)->CON &= ~I2S_CON_TXEN_Msk)
N
N/**
N  * @brief  Enable I2S Rx function.
N  * @param[in] i2s The base address of I2S module.
N  * @return None
N  * @details This macro will set RXEN bit of I2SCON register to enable I2S Rx function.
N  */
N#define I2S_ENABLE_RX(i2s) ((i2s)->CON |= I2S_CON_RXEN_Msk)
N
N/**
N  * @brief  Disable I2S Rx function.
N  * @param[in] i2s The base address of I2S module.
N  * @return None
N  * @details This macro will clear RXEN bit of I2SCON register to disable I2S Rx function.
N  */
N#define I2S_DISABLE_RX(i2s) ((i2s)->CON &= ~I2S_CON_RXEN_Msk)
N
N/**
N  * @brief  Enable Tx Mute function.
N  * @param[in] i2s The base address of I2S module.
N  * @return None
N  * @details This macro will set MUTE bit of I2SCON register to enable I2S Tx mute function.
N  */
N#define I2S_ENABLE_TX_MUTE(i2s)  ((i2s)->CON |= I2S_CON_MUTE_Msk)
N
N/**
N  * @brief  Disable Tx Mute function.
N  * @param[in] i2s The base address of I2S module.
N  * @return None
N  * @details This macro will clear MUTE bit of I2SCON register to disable I2S Tx mute function.
N  */
N#define I2S_DISABLE_TX_MUTE(i2s) ((i2s)->CON &= ~I2S_CON_MUTE_Msk)
N
N/**
N  * @brief  Clear Tx FIFO.
N  * @param[in] i2s The base address of I2S module.
N  * @return None
N  * @details This macro will clear Tx FIFO. The internal Tx FIFO pointer will be reset to FIFO start point.
N  */
N#define I2S_CLR_TX_FIFO(i2s) ((i2s)->CON |= I2S_CON_CLR_TXFIFO_Msk)
N
N/**
N  * @brief  Clear Rx FIFO.
N  * @param[in] i2s The base address of I2S module.
N  * @return None
N  * @details This macro will clear Rx FIFO. The internal Rx FIFO pointer will be reset to FIFO start point.
N  */
N#define I2S_CLR_RX_FIFO(i2s) ((i2s)->CON |= I2S_CON_CLR_RXFIFO_Msk)
N
N/**
N  * @brief  This function sets the recording source channel when mono mode is used.
N  * @param[in] i2s The base address of I2S module.
N  * @param[in] u32Ch left or right channel. Valid values are:
N  *                - \ref I2S_MONO_LEFT
N  *                - \ref I2S_MONO_RIGHT
N  * @return None
N  * @details This function selects the recording source channel of monaural mode.
N  */
Nstatic __INLINE void I2S_SET_MONO_RX_CHANNEL(I2S_T *i2s, uint32_t u32Ch)
Xstatic __inline void I2S_SET_MONO_RX_CHANNEL(I2S_T *i2s, uint32_t u32Ch)
N{
N    u32Ch == I2S_MONO_LEFT ?
X    u32Ch == (1ul << 23) ?
N    (i2s->CON |= I2S_CON_RXLCH_Msk) :
X    (i2s->CON |= (1ul << 23)) :
N    (i2s->CON &= ~I2S_CON_RXLCH_Msk);
X    (i2s->CON &= ~(1ul << 23));
N}
N
N/**
N  * @brief  Write data to I2S Tx FIFO.
N  * @param[in] i2s The base address of I2S module.
N  * @param[in] u32Data The value written to Tx FIFO.
N  * @return None
N  * @details This macro will write a value to Tx FIFO.
N  */
N#define I2S_WRITE_TX_FIFO(i2s, u32Data)  ((i2s)->TXFIFO = (u32Data))
N
N/**
N  * @brief  Read Rx FIFO.
N  * @param[in] i2s The base address of I2S module.
N  * @return The value read from Rx FIFO.
N  * @details This function will return a value read from Rx FIFO.
N  */
N#define I2S_READ_RX_FIFO(i2s) ((i2s)->RXFIFO )
N
N/**
N  * @brief  Get the interrupt flag.
N  * @param[in] i2s The base address of I2S module.
N  * @param[in] u32Mask The mask value for all interrupt flags.
N  * @return The interrupt flags specified by the u32mask parameter.
N  * @details This macro will return the combination flags of I2SSTATUS register. The flags are specified by the u32mask parameter.
N  */
N#define I2S_GET_INT_FLAG(i2s, u32Mask) ((i2s)->STATUS & (u32Mask))
N
N/**
N  * @brief  Clear the interrupt flag.
N  * @param[in] i2s The base address of I2S module.
N  * @param[in] u32Mask The mask value for all interrupt flags.
N  * @return None
N  * @details This macro will clear the interrupt flags specified by the u32mask parameter.
N  */
N#define I2S_CLR_INT_FLAG(i2s, u32Mask) ((i2s)->STATUS = (u32Mask))
N
N/**
N  * @brief  Get transmit FIFO level
N  * @param[in] i2s The base address of I2S module.
N  * @return Tx FIFO level
N  * @details This macro will return the number of available words in Tx FIFO.
N  */
N#define I2S_GET_TX_FIFO_LEVEL(i2s) ((((i2s)->STATUS & I2S_STATUS_TX_LEVEL_Msk) >> I2S_STATUS_TX_LEVEL_Pos) & 0xF)
N
N/**
N  * @brief  Get receive FIFO level
N  * @param[in] i2s The base address of I2S module.
N  * @return Rx FIFO level
N  * @details This macro will return the number of available words in Rx FIFO.
N  */
N#define I2S_GET_RX_FIFO_LEVEL(i2s) ((((i2s)->STATUS & I2S_STATUS_RX_LEVEL_Msk) >> I2S_STATUS_RX_LEVEL_Pos) & 0xF)
N
N
N/* Function prototype declaration */
Nuint32_t I2S_Open(I2S_T *i2s, uint32_t u32MasterSlave, uint32_t u32SampleRate, uint32_t u32WordWidth, uint32_t u32Channels, uint32_t u32DataFormat);
Nvoid I2S_Close(I2S_T *i2s);
Nvoid I2S_EnableInt(I2S_T *i2s, uint32_t u32Mask);
Nvoid I2S_DisableInt(I2S_T *i2s, uint32_t u32Mask);
Nuint32_t I2S_EnableMCLK(I2S_T *i2s, uint32_t u32BusClock);
Nvoid I2S_DisableMCLK(I2S_T *i2s);
Nvoid I2S_SetFIFO(I2S_T *i2s, uint32_t u32TxThreshold, uint32_t u32RxThreshold);
N
N/*@}*/ /* end of group I2S_EXPORTED_FUNCTIONS */
N
N
N/*@}*/ /* end of group I2S_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#endif
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
N
L 12457 ".\Libraries\Device\Nuvoton\NUC230_240\Include\NUC230_240.h" 2
N#include "USBD.h"
L 1 ".\Libraries\StdDriver\inc\USBD.h" 1
N/**************************************************************************//**
N * @file     usbd.h
N * @version  V3.0
N * $Revision: 7 $
N * $Date: 15/09/03 10:49a $
N * @brief    NUC230_240 series USB driver header file
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N
N#ifndef __USBD_H__
N#define __USBD_H__
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup USBD_Driver USBD Driver
N  @{
N*/
N
N/** @addtogroup USBD_EXPORTED_STRUCTS USBD Exported Structs
N  @{
N*/
N
N
Ntypedef struct s_usbd_info
N{
N    const uint8_t *gu8DevDesc;            /*!< Pointer for USB Device Descriptor          */
N    const uint8_t *gu8ConfigDesc;         /*!< Pointer for USB Configuration Descriptor   */
N    const uint8_t **gu8StringDesc;        /*!< Pointer for USB String Descriptor pointers */
N    const uint8_t **gu8HidReportDesc;     /*!< Pointer for USB HID Report Descriptor      */
N    const uint32_t *gu32HidReportSize;    /*!< Pointer for HID Report descriptor Size */
N    const uint32_t *gu32ConfigHidDescIdx; /*!< Pointer for HID Descriptor start index */
N
N} S_USBD_INFO_T;
N
Nextern const S_USBD_INFO_T gsInfo;
N
N/*@}*/ /* end of group USBD_EXPORTED_STRUCTS */
N
N
N
N/** @addtogroup USBD_EXPORTED_CONSTANTS USBD Exported Constants
N  @{
N*/
N
N#define USBD_BUF_BASE   (USBD_BASE+0x100)
N
N
N
N#define USBD_MAX_EP     8
N
N#define EP0     0       /*!< Endpoint 0 */
N#define EP1     1       /*!< Endpoint 1 */
N#define EP2     2       /*!< Endpoint 2 */
N#define EP3     3       /*!< Endpoint 3 */
N#define EP4     4       /*!< Endpoint 4 */
N#define EP5     5       /*!< Endpoint 5 */
N#define EP6     6       /*!< Endpoint 6 */
N#define EP7     7       /*!< Endpoint 7 */
N
N
N/*!<USB Request Type */
N#define REQ_STANDARD        0x00
N#define REQ_CLASS           0x20
N#define REQ_VENDOR          0x40
N
N/*!<USB Standard Request */
N#define GET_STATUS          0x00
N#define CLEAR_FEATURE       0x01
N#define SET_FEATURE         0x03
N#define SET_ADDRESS         0x05
N#define GET_DESCRIPTOR      0x06
N#define SET_DESCRIPTOR      0x07
N#define GET_CONFIGURATION   0x08
N#define SET_CONFIGURATION   0x09
N#define GET_INTERFACE       0x0A
N#define SET_INTERFACE       0x0B
N#define SYNC_FRAME          0x0C
N
N/*!<USB Descriptor Type */
N#define DESC_DEVICE         0x01
N#define DESC_CONFIG         0x02
N#define DESC_STRING         0x03
N#define DESC_INTERFACE      0x04
N#define DESC_ENDPOINT       0x05
N#define DESC_QUALIFIER      0x06
N#define DESC_OTHERSPEED     0x07
N
N/*!<USB HID Descriptor Type */
N#define DESC_HID            0x21
N#define DESC_HID_RPT        0x22
N
N/*!<USB Descriptor Length */
N#define LEN_DEVICE          18
N#define LEN_CONFIG          9
N#define LEN_INTERFACE       9
N#define LEN_ENDPOINT        7
N#define LEN_HID             9
N#define LEN_CCID            0x36
N
N/*!<USB Endpoint Type */
N#define EP_ISO              0x01
N#define EP_BULK             0x02
N#define EP_INT              0x03
N
N#define EP_INPUT            0x80
N#define EP_OUTPUT           0x00
N
N/*!<USB Feature Selector */
N#define FEATURE_DEVICE_REMOTE_WAKEUP    0x01
N#define FEATURE_ENDPOINT_HALT           0x00
N
N/******************************************************************************/
N/*                USB Specific Macros                                         */
N/******************************************************************************/
N
N#define USBD_WAKEUP_EN          USBD_INTEN_WAKEUP_EN_Msk    /*!< USB Wake-up Enable */
N#define USBD_DRVSE0             USBD_DRVSE0_DRVSE0_Msk      /*!< Drive SE0 */
N
N#define USBD_DPPU_EN            USBD_ATTR_DPPU_EN_Msk       /*!< USB D+ Pull-up Enable */
N#define USBD_PWRDN              USBD_ATTR_PWRDN_Msk         /*!< PHY Turn-On */
N#define USBD_PHY_EN             USBD_ATTR_PHY_EN_Msk        /*!< PHY Enable */
N#define USBD_USB_EN             USBD_ATTR_USB_EN_Msk        /*!< USB Enable */
N
N#define USBD_INT_BUS            USBD_INTEN_BUS_IE_Msk       /*!< USB Bus Event Interrupt */
N#define USBD_INT_USB            USBD_INTEN_USB_IE_Msk       /*!< USB USB Event Interrupt */
N#define USBD_INT_FLDET          USBD_INTEN_FLDET_IE_Msk     /*!< USB Float Detect Interrupt */
N#define USBD_INT_WAKEUP         (USBD_INTEN_WAKEUP_IE_Msk | USBD_INTEN_WAKEUP_EN_Msk)   /*!< USB Wake-up Interrupt */
N
N#define USBD_INTSTS_WAKEUP      USBD_INTSTS_WAKEUP_STS_Msk  /*!< USB Wakeup Interrupt Status */
N#define USBD_INTSTS_FLDET       USBD_INTSTS_FLDET_STS_Msk   /*!< USB Float Detect Interrupt Status */
N#define USBD_INTSTS_BUS         USBD_INTSTS_BUS_STS_Msk     /*!< USB Bus Event Interrupt Status */
N#define USBD_INTSTS_USB         USBD_INTSTS_USB_STS_Msk     /*!< USB USB Event Interrupt Status */
N#define USBD_INTSTS_SETUP       USBD_INTSTS_SETUP_Msk       /*!< USB Setup Event */
N#define USBD_INTSTS_EP0         USBD_INTSTS_EPEVT0_Msk      /*!< USB Endpoint 0 Event */
N#define USBD_INTSTS_EP1         USBD_INTSTS_EPEVT1_Msk      /*!< USB Endpoint 1 Event */
N#define USBD_INTSTS_EP2         USBD_INTSTS_EPEVT2_Msk      /*!< USB Endpoint 2 Event */
N#define USBD_INTSTS_EP3         USBD_INTSTS_EPEVT3_Msk      /*!< USB Endpoint 3 Event */
N#define USBD_INTSTS_EP4         USBD_INTSTS_EPEVT4_Msk      /*!< USB Endpoint 4 Event */
N#define USBD_INTSTS_EP5         USBD_INTSTS_EPEVT5_Msk      /*!< USB Endpoint 5 Event */
N#define USBD_INTSTS_EP6         USBD_INTSTS_EPEVT6_Msk      /*!< USB Endpoint 6 Event */
N#define USBD_INTSTS_EP7         USBD_INTSTS_EPEVT7_Msk      /*!< USB Endpoint 7 Event */
N
N#define USBD_STATE_USBRST       USBD_ATTR_USBRST_Msk        /*!< USB Bus Reset */
N#define USBD_STATE_SUSPEND      USBD_ATTR_SUSPEND_Msk       /*!< USB Bus Suspend */
N#define USBD_STATE_RESUME       USBD_ATTR_RESUME_Msk        /*!< USB Bus Resume */
N#define USBD_STATE_TIMEOUT      USBD_ATTR_TIMEOUT_Msk       /*!< USB Bus Timeout */
N
N#define USBD_CFGP_SSTALL        USBD_CFGP_SSTALL_Msk        /*!< Set Stall */
N#define USBD_CFG_CSTALL         USBD_CFG_CSTALL_Msk         /*!< Clear Stall */
N
N#define USBD_CFG_EPMODE_DISABLE (0ul << USBD_CFG_STATE_Pos)/*!< Endpoint Disable */
N#define USBD_CFG_EPMODE_OUT     (1ul << USBD_CFG_STATE_Pos)/*!< Out Endpoint */
N#define USBD_CFG_EPMODE_IN      (2ul << USBD_CFG_STATE_Pos)/*!< In Endpoint */
N#define USBD_CFG_TYPE_ISO       (1ul << USBD_CFG_ISOCH_Pos) /*!< Isochronous */
N
N
N/*@}*/ /* end of group USBD_EXPORTED_CONSTANTS */
N
N
N
N/** @addtogroup USBD_EXPORTED_FUNCTIONS USBD Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Compare two input numbers and return maximum one.
N  *
N  * @param[in]  a   First number to be compared.
N  * @param[in]  b   Second number to be compared.
N  *
N  * @return     Maximum value between a and b.
N  *
N  * @details    If a > b, then return a. Otherwise, return b.
N  */
N#define Maximum(a,b)        ((a)>(b) ? (a) : (b))
N
N
N/**
N  * @brief      Compare two input numbers and return minimum one
N  *
N  * @param[in]  a   First number to be compared
N  * @param[in]  b   Second number to be compared
N  *
N  * @return     Minimum value between a and b
N  *
N  * @details    If a < b, then return a. Otherwise, return b.
N  */
N#define Minimum(a,b)        ((a)<(b) ? (a) : (b))
N
N
N/**
N  * @brief    Enable USB
N  *
N  * @param    None
N  *
N  * @return   None
N  *
N  * @details  To set USB ATTR control register to enable USB and PHY.
N  *
N  */
N#define USBD_ENABLE_USB()           ((uint32_t)(USBD->ATTR |= (USBD_USB_EN|USBD_PHY_EN)))
N
N/**
N  * @brief    Disable USB
N  *
N  * @param    None
N  *
N  * @return   None
N  *
N  * @details  To set USB ATTR control register to disable USB.
N  *
N  */
N#define USBD_DISABLE_USB()          ((uint32_t)(USBD->ATTR &= ~USBD_USB_EN))
N
N/**
N  * @brief    Enable USB PHY
N  *
N  * @param    None
N  *
N  * @return   None
N  *
N  * @details  To set USB ATTR control register to enable USB PHY.
N  *
N  */
N#define USBD_ENABLE_PHY()           ((uint32_t)(USBD->ATTR |= USBD_PHY_EN))
N
N/**
N  * @brief    Disable USB PHY
N  *
N  * @param    None
N  *
N  * @return   None
N  *
N  * @details  To set USB ATTR control register to disable USB PHY.
N  *
N  */
N#define USBD_DISABLE_PHY()          ((uint32_t)(USBD->ATTR &= ~USBD_PHY_EN))
N
N/**
N  * @brief    Enable SE0. Force USB PHY transceiver to drive SE0.
N  *
N  * @param    None
N  *
N  * @return   None
N  *
N  * @details  Set DRVSE0 bit of USB_DRVSE0 register to enable software-disconnect function. Force USB PHY transceiver to drive SE0 to bus.
N  *
N  */
N#define USBD_SET_SE0()              ((uint32_t)(USBD->DRVSE0 |= USBD_DRVSE0))
N
N/**
N  * @brief    Disable SE0
N  *
N  * @param    None
N  *
N  * @return   None
N  *
N  * @details  Clear DRVSE0 bit of USB_DRVSE0 register to disable software-disconnect function.
N  *
N  */
N#define USBD_CLR_SE0()              ((uint32_t)(USBD->DRVSE0 &= ~USBD_DRVSE0))
N
N/**
N  * @brief       Set USB device address
N  *
N  * @param[in]   addr The USB device address.
N  *
N  * @return      None
N  *
N  * @details     Write USB device address to USB_FADDR register.
N  *
N  */
N#define USBD_SET_ADDR(addr)         (USBD->FADDR = (addr))
N
N/**
N  * @brief    Get USB device address
N  *
N  * @param    None
N  *
N  * @return   USB device address
N  *
N  * @details  Read USB_FADDR register to get USB device address.
N  *
N  */
N#define USBD_GET_ADDR()             ((uint32_t)(USBD->FADDR))
N
N/**
N  * @brief      Enable USB interrupt function
N  *
N  * @param[in]  intr The combination of the specified interrupt enable bits.
N  *             Each bit corresponds to a interrupt enable bit.
N  *             This parameter decides which interrupts will be enabled.
N  *             (USBD_INT_WAKEUP, USBD_INT_FLDET, USBD_INT_USB, USBD_INT_BUS)
N  *
N  * @return     None
N  *
N  * @details    Enable USB related interrupt functions specified by intr parameter.
N  *
N  */
N#define USBD_ENABLE_INT(intr)       (USBD->INTEN |= (intr))
N
N/**
N  * @brief    Get interrupt status
N  *
N  * @param    None
N  *
N  * @return   The value of USB_INTSTS register
N  *
N  * @details  Return all interrupt flags of USB_INTSTS register.
N  *
N  */
N#define USBD_GET_INT_FLAG()         ((uint32_t)(USBD->INTSTS))
N
N/**
N  * @brief      Clear USB interrupt flag
N  *
N  * @param[in]  flag The combination of the specified interrupt flags.
N  *             Each bit corresponds to a interrupt source.
N  *             This parameter decides which interrupt flags will be cleared.
N  *             (USBD_INTSTS_WAKEUP, USBD_INTSTS_FLDET, USBD_INTSTS_BUS, USBD_INTSTS_USB)
N  *
N  * @return     None
N  *
N  * @details    Clear USB related interrupt flags specified by flag parameter.
N  *
N  */
N#define USBD_CLR_INT_FLAG(flag)     (USBD->INTSTS = (flag))
N
N/**
N  * @brief    Get endpoint status
N  *
N  * @param    None
N  *
N  * @return   The value of USB_EPSTS register.
N  *
N  * @details  Return all endpoint status.
N  *
N  */
N#define USBD_GET_EP_FLAG()          ((uint32_t)(USBD->EPSTS))
N
N/**
N  * @brief    Get USB bus state
N  *
N  * @param    None
N  *
N  * @return   The value of USB_ATTR[3:0].
N  *           Bit 0 indicates USB bus reset status.
N  *           Bit 1 indicates USB bus suspend status.
N  *           Bit 2 indicates USB bus resume status.
N  *           Bit 3 indicates USB bus time-out status.
N  *
N  * @details  Return USB_ATTR[3:0] for USB bus events.
N  *
N  */
N#define USBD_GET_BUS_STATE()        ((uint32_t)(USBD->ATTR & 0xf))
N
N/**
N  * @brief    Check cable connection state
N  *
N  * @param    None
N  *
N  * @retval   0 USB cable is not attached.
N  * @retval   1 USB cable is attached.
N  *
N  * @details  Check the connection state by FLDET bit of USB_FLDET register.
N  *
N  */
N#define USBD_IS_ATTACHED()          ((uint32_t)(USBD->FLDET & USBD_FLDET_FLDET_Msk))
N
N/**
N  * @brief      Stop USB transaction of the specified endpoint ID
N  *
N  * @param[in]  ep The USB endpoint buffer number.
N  *
N  * @return     None
N  *
N  * @details    Write 1 to CLRRDY bit of USB_CFGPx register to stop USB transaction of the specified endpoint ID.
N  *
N  */
N#define USBD_STOP_TRANSACTION(ep)   (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].CFGP + (uint32_t)((ep) << 4))) |= USBD_CFGP_CLRRDY_Msk)
N
N/**
N  * @brief      Set USB DATA1 PID for the specified endpoint ID
N  *
N  * @param[in]  ep The USB endpoint buffer number.
N  *
N  * @return     None
N  *
N  * @details    Set DSQ_SYNC bit of USB_CFGx register to specify the DATA1 PID for the following IN token transaction.
N  *             Base on this setting, hardware will toggle PID between DATA0 and DATA1 automatically for IN token transactions.
N  *
N  */
N#define USBD_SET_DATA1(ep)          (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].CFG + (uint32_t)((ep) << 4))) |= USBD_CFG_DSQ_SYNC_Msk)
N
N/**
N  * @brief      Set USB DATA0 PID for the specified endpoint ID
N  *
N  * @param[in]  ep The USB endpoint buffer number.
N  *
N  * @return     None
N  *
N  * @details    Clear DSQ_SYNC bit of USB_CFGx register to specify the DATA0 PID for the following IN token transaction.
N  *             Base on this setting, hardware will toggle PID between DATA0 and DATA1 automatically for IN token transactions.
N  *
N  */
N#define USBD_SET_DATA0(ep)          (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].CFG + (uint32_t)((ep) << 4))) &= (~USBD_CFG_DSQ_SYNC_Msk))
N
N/**
N  * @brief      Set USB payload size (IN data)
N  *
N  * @param[in]  ep The USB endpoint buffer number.
N  *
N  * @param[in]  size The transfer length.
N  *
N  * @return     None
N  *
N  * @details    This macro will write the transfer length to USB_MXPLDx register for IN data transaction.
N  *
N  */
N#define USBD_SET_PAYLOAD_LEN(ep, size)  (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].MXPLD + (uint32_t)((ep) << 4))) = (size))
N
N/**
N  * @brief      Get USB payload size (OUT data)
N  *
N  * @param[in]  ep The USB endpoint buffer number.
N  *
N  * @return     The value of USB_MXPLDx register.
N  *
N  * @details    Get the data length of OUT data transaction by reading USB_MXPLDx register.
N  *
N  */
N#define USBD_GET_PAYLOAD_LEN(ep)        ((uint32_t)*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].MXPLD + (uint32_t)((ep) << 4))))
N
N/**
N  * @brief      Configure endpoint
N  *
N  * @param[in]  ep The USB endpoint buffer number.
N  *
N  * @param[in]  config The USB configuration.
N  *
N  * @return     None
N  *
N  * @details    This macro will write config parameter to USB_CFGx register of specified endpoint ID.
N  *
N  */
N#define USBD_CONFIG_EP(ep, config)      (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].CFG + (uint32_t)((ep) << 4))) = (config))
N
N/**
N  * @brief      Set USB endpoint buffer
N  *
N  * @param[in]  ep The USB endpoint buffer number.
N  *
N  * @param[in]  offset The SRAM offset.
N  *
N  * @return     None
N  *
N  * @details    This macro will set the SRAM offset for the specified endpoint ID.
N  *
N  */
N#define USBD_SET_EP_BUF_ADDR(ep, offset)    (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].BUFSEG + (uint32_t)((ep) << 4))) = (offset))
N
N/**
N  * @brief      Get the offset of the specified USB endpoint buffer
N  *
N  * @param[in]  ep The USB endpoint buffer number.
N  *
N  * @return     The offset of the specified endpoint buffer.
N  *
N  * @details    This macro will return the SRAM offset of the specified endpoint ID.
N  *
N  */
N#define USBD_GET_EP_BUF_ADDR(ep)        ((uint32_t)*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].BUFSEG + (uint32_t)((ep) << 4))))
N/**
N  * @brief       Set USB endpoint stall state
N  *
N  * @param[in]   ep  The USB endpoint ID (USB endpoint buffer number).
N  *
N  * @return      None
N  *
N  * @details     Set USB endpoint stall state for the specified endpoint ID. Endpoint will respond STALL token automatically.
N  *
N  */
N#define USBD_SET_EP_STALL(ep)        (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].CFGP + (uint32_t)((ep) << 4))) |= USBD_CFGP_SSTALL_Msk)
N
N/**
N  * @brief       Clear USB endpoint stall state
N  *
N  * @param[in]   ep  The USB endpoint ID (USB endpoint buffer number).
N  *
N  * @return      None
N  *
N  * @details     Clear USB endpoint stall state for the specified endpoint ID. Endpoint will respond ACK/NAK token.
N  */
N#define USBD_CLR_EP_STALL(ep)        (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].CFGP + (uint32_t)((ep) << 4))) &= ~USBD_CFGP_SSTALL_Msk)
N
N/**
N  * @brief       Get USB endpoint stall state
N  *
N  * @param[in]   ep  The USB endpoint ID (USB endpoint buffer number).
N  *
N  * @retval      0      USB endpoint is not stalled.
N  * @retval      Others USB endpoint is stalled.
N  *
N  * @details     Get USB endpoint stall state of the specified endpoint ID.
N  *
N  */
N#define USBD_GET_EP_STALL(ep)        (*((__IO uint32_t *) ((uint32_t)&USBD->EP[0].CFGP + (uint32_t)((ep) << 4))) & USBD_CFGP_SSTALL_Msk)
N
N/**
N  * @brief      To support byte access between USB SRAM and system SRAM
N  *
N  * @param[in]  dest Destination pointer.
N  *
N  * @param[in]  src  Source pointer.
N  *
N  * @param[in]  size Byte count.
N  *
N  * @return     None
N  *
N  * @details    This function will copy the number of data specified by size and src parameters to the address specified by dest parameter.
N  *
N  */
Nstatic __INLINE void USBD_MemCopy(uint8_t *dest, uint8_t *src, int32_t size)
Xstatic __inline void USBD_MemCopy(uint8_t *dest, uint8_t *src, int32_t size)
N{
N    while(size--) *dest++ = *src++;
N}
N
N
N/**
N  * @brief       Set USB endpoint stall state
N  *
N  * @param[in]   epnum  USB endpoint number
N  *
N  * @return      None
N  *
N  * @details     Set USB endpoint stall state. Endpoint will respond STALL token automatically.
N  *
N  */
Nstatic __INLINE void USBD_SetStall(uint8_t epnum)
Xstatic __inline void USBD_SetStall(uint8_t epnum)
N{
N    uint32_t u32CfgAddr;
N    uint32_t u32Cfg;
N    int i;
N
N    for(i = 0; i < USBD_MAX_EP; i++)
X    for(i = 0; i < 8; i++)
N    {
N        u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&USBD->EP[0].CFG; /* USBD_CFG0 */
X        u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&((USBD_T *) ((( uint32_t)0x40000000) + 0x60000))->EP[0].CFG;  
N        u32Cfg = *((__IO uint32_t *)(u32CfgAddr));
X        u32Cfg = *((volatile uint32_t *)(u32CfgAddr));
N
N        if((u32Cfg & 0xf) == epnum)
N        {
N            u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&USBD->EP[0].CFGP; /* USBD_CFGP0 */
X            u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&((USBD_T *) ((( uint32_t)0x40000000) + 0x60000))->EP[0].CFGP;  
N            u32Cfg = *((__IO uint32_t *)(u32CfgAddr));
X            u32Cfg = *((volatile uint32_t *)(u32CfgAddr));
N
N            *((__IO uint32_t *)(u32CfgAddr)) = (u32Cfg | USBD_CFGP_SSTALL);
X            *((volatile uint32_t *)(u32CfgAddr)) = (u32Cfg | (1ul << 1));
N            break;
N        }
N    }
N}
N
N/**
N  * @brief       Clear USB endpoint stall state
N  *
N  * @param[in]   epnum  USB endpoint number
N  *
N  * @return      None
N  *
N  * @details     Clear USB endpoint stall state. Endpoint will respond ACK/NAK token.
N  */
Nstatic __INLINE void USBD_ClearStall(uint8_t epnum)
Xstatic __inline void USBD_ClearStall(uint8_t epnum)
N{
N    uint32_t u32CfgAddr;
N    uint32_t u32Cfg;
N    int i;
N
N    for(i = 0; i < USBD_MAX_EP; i++)
X    for(i = 0; i < 8; i++)
N    {
N        u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&USBD->EP[0].CFG; /* USBD_CFG0 */
X        u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&((USBD_T *) ((( uint32_t)0x40000000) + 0x60000))->EP[0].CFG;  
N        u32Cfg = *((__IO uint32_t *)(u32CfgAddr));
X        u32Cfg = *((volatile uint32_t *)(u32CfgAddr));
N
N        if((u32Cfg & 0xf) == epnum)
N        {
N            u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&USBD->EP[0].CFGP; /* USBD_CFGP0 */
X            u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&((USBD_T *) ((( uint32_t)0x40000000) + 0x60000))->EP[0].CFGP;  
N            u32Cfg = *((__IO uint32_t *)(u32CfgAddr));
X            u32Cfg = *((volatile uint32_t *)(u32CfgAddr));
N
N            *((__IO uint32_t *)(u32CfgAddr)) = (u32Cfg & ~USBD_CFGP_SSTALL);
X            *((volatile uint32_t *)(u32CfgAddr)) = (u32Cfg & ~(1ul << 1));
N            break;
N        }
N    }
N}
N
N/**
N  * @brief       Get USB endpoint stall state
N  *
N  * @param[in]   epnum  USB endpoint number
N  *
N  * @retval      0      USB endpoint is not stalled.
N  * @retval      Others USB endpoint is stalled.
N  *
N  * @details     Get USB endpoint stall state.
N  *
N  */
Nstatic __INLINE uint32_t USBD_GetStall(uint8_t epnum)
Xstatic __inline uint32_t USBD_GetStall(uint8_t epnum)
N{
N    uint32_t u32CfgAddr;
N    uint32_t u32Cfg;
N    int i;
N
N    for(i = 0; i < USBD_MAX_EP; i++)
X    for(i = 0; i < 8; i++)
N    {
N        u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&USBD->EP[0].CFG; /* USBD_CFG0 */
X        u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&((USBD_T *) ((( uint32_t)0x40000000) + 0x60000))->EP[0].CFG;  
N        u32Cfg = *((__IO uint32_t *)(u32CfgAddr));
X        u32Cfg = *((volatile uint32_t *)(u32CfgAddr));
N
N        if((u32Cfg & 0xf) == epnum)
N        {
N            u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&USBD->EP[0].CFGP; /* USBD_CFGP0 */
X            u32CfgAddr = (uint32_t)(i << 4) + (uint32_t)&((USBD_T *) ((( uint32_t)0x40000000) + 0x60000))->EP[0].CFGP;  
N            break;
N        }
N    }
N
N    return ((*((__IO uint32_t *)(u32CfgAddr))) & USBD_CFGP_SSTALL);
X    return ((*((volatile uint32_t *)(u32CfgAddr))) & (1ul << 1));
N}
N
N
Nextern volatile uint8_t g_usbd_RemoteWakeupEn;
Ntypedef void (*VENDOR_REQ)(void);           /*!< Functional pointer type declaration for Vendor class */
Ntypedef void (*CLASS_REQ)(void);            /*!< Functional pointer type declaration for USB class request callback handler */
Ntypedef void (*SET_INTERFACE_REQ)(void);    /*!< Functional pointer type declaration for USB set interface request callback handler */
Ntypedef void (*SET_CONFIG_CB)(void);       /*!< Functional pointer type declaration for USB set configuration request callback handler */
N
N/*--------------------------------------------------------------------*/
Nvoid USBD_Open(const S_USBD_INFO_T *param, CLASS_REQ pfnClassReq, SET_INTERFACE_REQ pfnSetInterface);
Nvoid USBD_Start(void);
Nvoid USBD_GetSetupPacket(uint8_t *buf);
Nvoid USBD_ProcessSetupPacket(void);
Nvoid USBD_StandardRequest(void);
Nvoid USBD_PrepareCtrlIn(uint8_t *pu8Buf, uint32_t u32Size);
Nvoid USBD_CtrlIn(void);
Nvoid USBD_PrepareCtrlOut(uint8_t *pu8Buf, uint32_t u32Size);
Nvoid USBD_CtrlOut(void);
Nvoid USBD_SwReset(void);
Nvoid USBD_SetVendorRequest(VENDOR_REQ pfnVendorReq);
Nvoid USBD_SetConfigCallback(SET_CONFIG_CB pfnSetConfigCallback);
Nvoid USBD_LockEpStall(uint32_t u32EpBitmap);
N
N/*@}*/ /* end of group USBD_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group USBD_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N
N#endif //__USBD_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 12458 ".\Libraries\Device\Nuvoton\NUC230_240\Include\NUC230_240.h" 2
N#include "PDMA.h"
L 1 ".\Libraries\StdDriver\inc\PDMA.h" 1
N/**************************************************************************//**
N * @file     PDMA.h
N * @version  V1.00
N * $Revision: 4 $
N * $Date: 15/05/06 2:59p $
N * @brief    NUC230_240 Series PDMA Controller Driver Header File
N *
N * @note
N * Copyright (C) 2011 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __PDMA_H__
N#define __PDMA_H__
N
N#include "NUC230_240.h"
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  * @{
N  */
N
N/** @addtogroup PDMA_Driver PDMA Driver
N  * @{
N  */
N
N/** @addtogroup PDMA_EXPORTED_CONSTANTS PDMA Exported Constants
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Data Width Constant Definitions                                                                        */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PDMA_WIDTH_8        0x00080000UL            /*!<DMA Transfer Width 8-bit */
N#define PDMA_WIDTH_16       0x00100000UL            /*!<DMA Transfer Width 16-bit */
N#define PDMA_WIDTH_32       0x00000000UL            /*!<DMA Transfer Width 32-bit */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Address Attribute Constant Definitions                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PDMA_SAR_INC        0x00000000UL            /*!<DMA SAR increment */
N#define PDMA_SAR_FIX        0x00000020UL            /*!<DMA SAR fix address */
N#define PDMA_DAR_INC        0x00000000UL            /*!<DMA DAR increment */
N#define PDMA_DAR_FIX        0x00000080UL            /*!<DMA DAR fix address */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Peripheral Transfer Mode Constant Definitions                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define PDMA_SPI0_TX        0x00000000UL            /*!<DMA Connect to SPI0 TX */
N#define PDMA_SPI1_TX        0x00000001UL            /*!<DMA Connect to SPI1 TX */
N#define PDMA_SPI2_TX        0x00000002UL            /*!<DMA Connect to SPI2 TX */
N#define PDMA_SPI3_TX        0x00000003UL            /*!<DMA Connect to SPI2 TX */
N#define PDMA_UART0_TX       0x00000004UL            /*!<DMA Connect to UART0 TX */
N#define PDMA_UART1_TX       0x00000005UL            /*!<DMA Connect to UART1 TX */
N#define PDMA_I2S_TX         0x00000006UL            /*!<DMA Connect to I2S TX */
N#define PDMA_SPI0_RX        0x00000007UL            /*!<DMA Connect to SPI0 RX */
N#define PDMA_SPI1_RX        0x00000008UL            /*!<DMA Connect to SPI1 RX */
N#define PDMA_SPI2_RX        0x00000009UL            /*!<DMA Connect to SPI2 RX */
N#define PDMA_SPI3_RX        0x0000000AUL            /*!<DMA Connect to SPI2 RX */
N#define PDMA_UART0_RX       0x0000000BUL            /*!<DMA Connect to UART0 RX */
N#define PDMA_UART1_RX       0x0000000CUL            /*!<DMA Connect to UART1 RX */
N#define PDMA_I2S_RX         0x0000000DUL            /*!<DMA Connect to I2S RX */
N#define PDMA_ADC            0x0000000EUL            /*!<DMA Connect to ADC */
N#define PDMA_MEM            0x0000001FUL            /*!<DMA Connect to Memory */
N
N
N/*@}*/ /* end of group PDMA_EXPORTED_CONSTANTS */
N
N/** @addtogroup PDMA_EXPORTED_FUNCTIONS PDMA Exported Functions
N  @{
N*/
N
N/**
N * @brief       Get PDMA Global Interrupt Status
N *
N * @param       None
N *
N * @return      Interrupt Status
N *
N * @details     This macro gets the global interrupt status.
N */
N#define PDMA_GET_INT_STATUS()   ((uint32_t)(PDMA_GCR->GCRISR))
N
N/**
N * @brief       Get PDMA Channel Interrupt Status
N *
N * @param[in]   u32Ch   Selected DMA channel
N *
N * @return      Interrupt Status
N *
N * @details     This macro gets the channel interrupt status.
N */
N#define PDMA_GET_CH_INT_STS(u32Ch)   (*((__IO uint32_t *)((uint32_t)&PDMA0->ISR + (uint32_t)((u32Ch)*0x100))))
N
N/**
N * @brief       Clear PDMA Channel Interrupt Flag
N *
N * @param[in]   u32Ch   Selected DMA channel
N * @param[in]   u32Mask Interrupt Mask
N *
N * @return      None
N *
N * @details     This macro clear the channel interrupt flag.
N */
N#define PDMA_CLR_CH_INT_FLAG(u32Ch, u32Mask)   (*((__IO uint32_t *)((uint32_t)&PDMA0->ISR + (uint32_t)((u32Ch)*0x100))) = (u32Mask))
N
N/**
N * @brief       Check Channel Status
N *
N * @param[in]   u32Ch    The selected channel
N *
N * @retval      0        The selected channel is idle
N * @retval      1        The selected channel is busy
N *
N * @details     Check the selected channel is busy or not.
N */
N#define PDMA_IS_CH_BUSY(u32Ch)    ((*((__IO uint32_t *)((uint32_t)&PDMA0->CSR +(uint32_t)((u32Ch)*0x100)))&PDMA_CSR_TRIG_EN_Msk)? 1 : 0)
N
N/**
N * @brief       Set Source Address
N *
N * @param[in]   u32Ch     The selected channel
N * @param[in]   u32Addr   The selected address
N *
N * @return      None
N *
N * @details     This macro set the selected channel source address.
N */
N#define PDMA_SET_SRC_ADDR(u32Ch, u32Addr) (*((__IO uint32_t *)((uint32_t)&PDMA0->SAR + (uint32_t)((u32Ch)*0x100))) = (u32Addr))
N
N/**
N * @brief       Set Destination Address
N *
N * @param[in]   u32Ch     The selected channel
N * @param[in]   u32Addr   The selected address
N *
N * @return      None
N *
N * @details     This macro set the selected channel destination address.
N */
N#define PDMA_SET_DST_ADDR(u32Ch, u32Addr) (*((__IO uint32_t *)((uint32_t)&PDMA0->DAR + (uint32_t)((u32Ch)*0x100))) = (u32Addr))
N
N/**
N * @brief       Set Transfer Count
N *
N * @param[in]   u32Ch     The selected channel
N * @param[in]   u32Count  Transfer Count
N *
N * @return      None
N *
N * @details     This macro set the selected channel transfer count.
N * \hideinitializer
N */
N#define PDMA_SET_TRANS_CNT(u32Ch, u32Count) {   \
N    if (((uint32_t)*((__IO uint32_t *)((uint32_t)&PDMA0->CSR + (uint32_t)((u32Ch)*0x100))) & PDMA_CSR_APB_TWS_Msk) == PDMA_WIDTH_32)  \
N        *((__IO uint32_t *)((uint32_t)&PDMA0->BCR + (uint32_t)((u32Ch)*0x100))) = ((u32Count) << 2);  \
N    else if (((uint32_t)*((__IO uint32_t *)((uint32_t)&PDMA0->CSR + (uint32_t)((u32Ch)*0x100))) & PDMA_CSR_APB_TWS_Msk) == PDMA_WIDTH_8)  \
N        *((__IO uint32_t *)((uint32_t)&PDMA0->BCR + (uint32_t)((u32Ch)*0x100))) = (u32Count); \
N    else if (((uint32_t)*((__IO uint32_t *)((uint32_t)&PDMA0->CSR + (uint32_t)((u32Ch)*0x100))) & PDMA_CSR_APB_TWS_Msk) == PDMA_WIDTH_16) \
N        *((__IO uint32_t *)((uint32_t)&PDMA0->BCR + (uint32_t)((u32Ch)*0x100))) = ((u32Count) << 1);  \
N}
X#define PDMA_SET_TRANS_CNT(u32Ch, u32Count) {       if (((uint32_t)*((__IO uint32_t *)((uint32_t)&PDMA0->CSR + (uint32_t)((u32Ch)*0x100))) & PDMA_CSR_APB_TWS_Msk) == PDMA_WIDTH_32)          *((__IO uint32_t *)((uint32_t)&PDMA0->BCR + (uint32_t)((u32Ch)*0x100))) = ((u32Count) << 2);      else if (((uint32_t)*((__IO uint32_t *)((uint32_t)&PDMA0->CSR + (uint32_t)((u32Ch)*0x100))) & PDMA_CSR_APB_TWS_Msk) == PDMA_WIDTH_8)          *((__IO uint32_t *)((uint32_t)&PDMA0->BCR + (uint32_t)((u32Ch)*0x100))) = (u32Count);     else if (((uint32_t)*((__IO uint32_t *)((uint32_t)&PDMA0->CSR + (uint32_t)((u32Ch)*0x100))) & PDMA_CSR_APB_TWS_Msk) == PDMA_WIDTH_16)         *((__IO uint32_t *)((uint32_t)&PDMA0->BCR + (uint32_t)((u32Ch)*0x100))) = ((u32Count) << 1);  }
N
N/**
N * @brief       Stop the channel
N *
N * @param[in]   u32Ch     The selected channel
N *
N * @return      None
N *
N * @details     This macro stop the selected channel.
N */
N#define PDMA_STOP(u32Ch) (*((__IO uint32_t *)((uint32_t)&PDMA0->CSR + (uint32_t)((u32Ch)*0x100))) &= ~PDMA_CSR_PDMACEN_Msk)
N
Nvoid PDMA_Open(uint32_t u32Mask);
Nvoid PDMA_Close(void);
Nvoid PDMA_SetTransferCnt(uint32_t u32Ch, uint32_t u32Width, uint32_t u32TransCount);
Nvoid PDMA_SetTransferAddr(uint32_t u32Ch, uint32_t u32SrcAddr, uint32_t u32SrcCtrl, uint32_t u32DstAddr, uint32_t u32DstCtrl);
Nvoid PDMA_SetTransferMode(uint32_t u32Ch, uint32_t u32Periphral, uint32_t u32ScatterEn, uint32_t u32DescAddr);
Nvoid PDMA_Trigger(uint32_t u32Ch);
Nvoid PDMA_EnableInt(uint32_t u32Ch, uint32_t u32Mask);
Nvoid PDMA_DisableInt(uint32_t u32Ch, uint32_t u32Mask);
N
N
N/**
N  * @} End of PDMA Device Function Interface
N  */
N
N/**
N  * @} End of PDMA Driver
N  */
N
N/**
N  * @} End of Standard Driver
N  */
N
N#endif  // __PDMA_H__ 
L 12459 ".\Libraries\Device\Nuvoton\NUC230_240\Include\NUC230_240.h" 2
N#include "SC.h"
L 1 ".\Libraries\StdDriver\inc\SC.h" 1
N/**************************************************************************//**
N * @file     sc.h
N * @version  V3.00
N * $Revision: 6 $
N * $Date: 15/05/12 1:49p $
N * @brief    NUC230_240 series Smartcard (SC) driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __SC_H__
N#define __SC_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup SC_Driver SC Driver
N  @{
N*/
N
N/** @addtogroup SC_EXPORTED_CONSTANTS SC Exported Constants
N  @{
N*/
N#define SC_INTERFACE_NUM        3                /*!< Smartcard interface numbers */
N#define SC_PIN_STATE_HIGH       1                /*!< Smartcard pin status high   */
N#define SC_PIN_STATE_LOW        0                /*!< Smartcard pin status low    */
N#define SC_PIN_STATE_IGNORE     0xFFFFFFFF       /*!< Ignore pin status           */
N#define SC_CLK_ON               1                /*!< Smartcard clock on          */
N#define SC_CLK_OFF              0                /*!< Smartcard clock off         */
N
N#define SC_TMR_MODE_0                   (0ul << SC_TMR0_MODE_Pos)     /*!<Timer Operation Mode 0, down count                                                      */
N#define SC_TMR_MODE_1                   (1ul << SC_TMR0_MODE_Pos)     /*!<Timer Operation Mode 1, down count, start after detect start bit                        */
N#define SC_TMR_MODE_2                   (2ul << SC_TMR0_MODE_Pos)     /*!<Timer Operation Mode 2, down count, start after receive start bit                       */
N#define SC_TMR_MODE_3                   (3ul << SC_TMR0_MODE_Pos)     /*!<Timer Operation Mode 3, down count, use for activation, only timer 0 support this mode  */
N#define SC_TMR_MODE_4                   (4ul << SC_TMR0_MODE_Pos)     /*!<Timer Operation Mode 4, down count with reload after timeout                            */
N#define SC_TMR_MODE_5                   (5ul << SC_TMR0_MODE_Pos)     /*!<Timer Operation Mode 5, down count, start after detect start bit, reload after timeout  */
N#define SC_TMR_MODE_6                   (6ul << SC_TMR0_MODE_Pos)     /*!<Timer Operation Mode 6, down count, start after receive start bit, reload after timeout */
N#define SC_TMR_MODE_7                   (7ul << SC_TMR0_MODE_Pos)     /*!<Timer Operation Mode 7, down count, start and reload after detect start bit             */
N#define SC_TMR_MODE_8                   (8ul << SC_TMR0_MODE_Pos)     /*!<Timer Operation Mode 8, up count                                                        */
N#define SC_TMR_MODE_F                   (0xF << SC_TMR0_MODE_Pos)     /*!<Timer Operation Mode 15, down count, reload after detect start bit                      */
N
N
N/*@}*/ /* end of group SC_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup SC_EXPORTED_FUNCTIONS SC Exported Functions
N  @{
N*/
N
N/**
N  * @brief Enable smartcard interrupt.
N  * @param[in] sc Base address of smartcard module.
N  * @param[in] u32Mask Interrupt mask to be enabled. A combination of
N  *             - \ref SC_IER_ACON_ERR_IE_Msk
N  *             - \ref SC_IER_RTMR_IE_Msk
N  *             - \ref SC_IER_INIT_IE_Msk
N  *             - \ref SC_IER_CD_IE_Msk
N  *             - \ref SC_IER_BGT_IE_Msk
N  *             - \ref SC_IER_TMR2_IE_Msk
N  *             - \ref SC_IER_TMR1_IE_Msk
N  *             - \ref SC_IER_TMR0_IE_Msk
N  *             - \ref SC_IER_TERR_IE_Msk
N  *             - \ref SC_IER_TBE_IE_Msk
N  *             - \ref SC_IER_RDA_IE_Msk
N  * @return None
N  * @details The macro is used to enable Auto-convention error interrupt, Receiver buffer time-out interrupt, Initial end interrupt,
N  *          Card detect interrupt, Block guard time interrupt, Timer2 interrupt, Timer1 interrupt, Timer0 interrupt,
N  *          Transfer error interrupt, Transmit buffer empty interrupt or Receive data reach trigger level interrupt.
N  * \hideinitializer
N  */
N#define SC_ENABLE_INT(sc, u32Mask) ((sc)->IER |= (u32Mask))
N
N/**
N  * @brief Disable smartcard interrupt.
N  * @param[in] sc Base address of smartcard module.
N  * @param[in] u32Mask Interrupt mask to be disabled. A combination of
N  *             - \ref SC_IER_ACON_ERR_IE_Msk
N  *             - \ref SC_IER_RTMR_IE_Msk
N  *             - \ref SC_IER_INIT_IE_Msk
N  *             - \ref SC_IER_CD_IE_Msk
N  *             - \ref SC_IER_BGT_IE_Msk
N  *             - \ref SC_IER_TMR2_IE_Msk
N  *             - \ref SC_IER_TMR1_IE_Msk
N  *             - \ref SC_IER_TMR0_IE_Msk
N  *             - \ref SC_IER_TERR_IE_Msk
N  *             - \ref SC_IER_TBE_IE_Msk
N  *             - \ref SC_IER_RDA_IE_Msk
N  * @return None
N  * @details The macro is used to disable Auto-convention error interrupt, Receiver buffer time-out interrupt, Initial end interrupt,
N  *          Card detect interrupt, Block guard time interrupt, Timer2 interrupt, Timer1 interrupt, Timer0 interrupt,
N  *          Transfer error interrupt, Transmit buffer empty interrupt or Receive data reach trigger level interrupt.
N  * \hideinitializer
N  */
N#define SC_DISABLE_INT(sc, u32Mask) ((sc)->IER &= ~(u32Mask))
N
N/**
N  * @brief This macro set VCC pin state of smartcard interface.
N  * @param[in] sc Base address of smartcard module.
N  * @param[in] u32State Pin state of VCC pin, valid parameters are:
N  *                 \ref SC_PIN_STATE_HIGH    :Smartcard pin status high.
N  *                 \ref SC_PIN_STATE_LOW     :Smartcard pin status low.
N  * @return None
N  * @details User can set POW_EN (SC_PINCSR[0]) and POW_INV (SC_PINCSR[11])to decide SC_PWR pin is in high or low level.
N  * \hideinitializer
N  */
N#define SC_SET_VCC_PIN(sc, u32State) \
N    do {\
N            while((sc)->PINCSR & SC_PINCSR_SYNC_Msk);\
N            if(u32State)\
N                (sc)->PINCSR |= SC_PINCSR_POW_EN_Msk;\
N            else\
N                (sc)->PINCSR &= ~SC_PINCSR_POW_EN_Msk;\
N    }while(0)
X#define SC_SET_VCC_PIN(sc, u32State)     do {            while((sc)->PINCSR & SC_PINCSR_SYNC_Msk);            if(u32State)                (sc)->PINCSR |= SC_PINCSR_POW_EN_Msk;            else                (sc)->PINCSR &= ~SC_PINCSR_POW_EN_Msk;    }while(0)
N
N
N/**
N  * @brief Set CLK output status.
N  * @param[in] sc Base address of smartcard module.
N  * @param[in] u32OnOff Clock on or off for selected smartcard module, valid values are:
N  *                 \ref SC_CLK_ON    :Smartcard clock on.
N  *                 \ref SC_CLK_OFF   :Smartcard clock off.
N  * @return None
N  * @details User can set CLK_KEEP (SC_PINCSR[6]) to decide SC_CLK pin always keeps free running or not.
N  * \hideinitializer
N  */
N#define SC_SET_CLK_PIN(sc, u32OnOff)\
N    do {\
N            while((sc)->PINCSR & SC_PINCSR_SYNC_Msk);\
N            if((u32OnOff))\
N                (sc)->PINCSR |= SC_PINCSR_CLK_KEEP_Msk;\
N            else\
N                (sc)->PINCSR &= ~(SC_PINCSR_CLK_KEEP_Msk);\
N    }while(0)
X#define SC_SET_CLK_PIN(sc, u32OnOff)    do {            while((sc)->PINCSR & SC_PINCSR_SYNC_Msk);            if((u32OnOff))                (sc)->PINCSR |= SC_PINCSR_CLK_KEEP_Msk;            else                (sc)->PINCSR &= ~(SC_PINCSR_CLK_KEEP_Msk);    }while(0)
N
N/**
N  * @brief Set I/O pin state.
N  * @param[in] sc Base address of smartcard module.
N  * @param[in] u32State Pin state of I/O pin, valid parameters are:
N  *                 \ref SC_PIN_STATE_HIGH    :Smartcard pin status high.
N  *                 \ref SC_PIN_STATE_LOW     :Smartcard pin status low.
N  * @return None
N  * @details User can set SC_DATA_O(SC_PINCSR[9]) to decide SC_DATA_O pin to high or low.
N  * \hideinitializer
N  */
N#define SC_SET_IO_PIN(sc, u32State)\
N    do {\
N            while((sc)->PINCSR & SC_PINCSR_SYNC_Msk);\
N            if((u32State))\
N                (sc)->PINCSR |= SC_PINCSR_SC_DATA_O_Msk;\
N            else\
N                (sc)->PINCSR &= ~SC_PINCSR_SC_DATA_O_Msk;\
N    }while(0)
X#define SC_SET_IO_PIN(sc, u32State)    do {            while((sc)->PINCSR & SC_PINCSR_SYNC_Msk);            if((u32State))                (sc)->PINCSR |= SC_PINCSR_SC_DATA_O_Msk;            else                (sc)->PINCSR &= ~SC_PINCSR_SC_DATA_O_Msk;    }while(0)
N
N/**
N  * @brief Set RST pin state.
N  * @param[in] sc Base address of smartcard module.
N  * @param[in] u32State Pin state of RST pin, valid parameters are:
N  *                 \ref SC_PIN_STATE_HIGH    :Smartcard pin status high.
N  *                 \ref SC_PIN_STATE_LOW     :Smartcard pin status low.
N  * @return None
N  * @details User can set SC_RST(SC_PINCSR[1]) to decide SC_RST pin to high or low.
N  * \hideinitializer
N  */
N#define SC_SET_RST_PIN(sc, u32State)\
N    do {\
N            while((sc)->PINCSR & SC_PINCSR_SYNC_Msk);\
N            if((u32State))\
N                (sc)->PINCSR |= SC_PINCSR_SC_RST_Msk;\
N            else\
N                (sc)->PINCSR &= ~SC_PINCSR_SC_RST_Msk;\
N    }while(0)
X#define SC_SET_RST_PIN(sc, u32State)    do {            while((sc)->PINCSR & SC_PINCSR_SYNC_Msk);            if((u32State))                (sc)->PINCSR |= SC_PINCSR_SC_RST_Msk;            else                (sc)->PINCSR &= ~SC_PINCSR_SC_RST_Msk;    }while(0)
N
N/**
N  * @brief Read one byte from smartcard module receive FIFO.
N  * @param[in] sc Base address of smartcard module.
N  * @return One byte read from receive FIFO.
N  * @details By reading RBR register, the SC will return an 8-bit received data.
N  * \hideinitializer
N  */
N#define SC_READ(sc) ((char)((sc)->RBR))
N
N/**
N  * @brief Write one byte to smartcard module transmit FIFO.
N  * @param[in] sc Base address of smartcard module.
N  * @param[in] u8Data Data to write to transmit FIFO.
N  * @return None
N  * @details By writing data to THR register, the SC will send out an 8-bit data.
N  * \hideinitializer
N  */
N#define SC_WRITE(sc, u8Data) ((sc)->THR = (u8Data))
N
N/**
N  * @brief This macro set smartcard stop bit length.
N  * @param[in] sc Base address of smartcard module.
N  * @param[in] u32Len Stop bit length, ether 1 or 2.
N  * @return None
N  * @details Stop bit length must be 1 for T = 1 protocol and 2 for T = 0 protocol.
N  * \hideinitializer
N  */
N#define SC_SET_STOP_BIT_LEN(sc, u32Len) ((sc)->CTL = ((sc)->CTL & ~SC_CTL_SLEN_Msk) | ((u32Len) == 1 ? SC_CTL_SLEN_Msk : 0))
N
N/**
N  * @brief Enable/Disable Tx error retry, and set Tx error retry count.
N  * @param[in] sc Base address of smartcard module.
N  * @param[in] u32Count The number of times of Tx error retry count, between 0~8. 0 means disable Tx error retry.
N  * @return None
N  * @details This macro enable/disable transmitter retry function when parity error has occurred, and set error retry count.
N  */
N__STATIC_INLINE void SC_SetTxRetry(SC_T *sc, uint32_t u32Count)
Xstatic __inline void SC_SetTxRetry(SC_T *sc, uint32_t u32Count)
N{
N    while((sc)->CTL & SC_CTL_SYNC_Msk);
X    while((sc)->CTL & (1ul << 30));
N    if((u32Count) == 0)         // disable Tx error retry
N    {
N        (sc)->CTL &= ~(SC_CTL_TX_ERETRY_Msk | SC_CTL_TX_ERETRY_EN_Msk);
X        (sc)->CTL &= ~((7ul << 20) | (1ul << 23));
N    }
N    else
N    {
N        (sc)->CTL = ((sc)->CTL & ~SC_CTL_TX_ERETRY_Msk) | (((u32Count) - 1) << SC_CTL_TX_ERETRY_Pos) | SC_CTL_TX_ERETRY_EN_Msk;
X        (sc)->CTL = ((sc)->CTL & ~(7ul << 20)) | (((u32Count) - 1) << 20) | (1ul << 23);
N    }
N}
N
N/**
N  * @brief Enable/Disable Rx error retry, and set Rx error retry count.
N  * @param[in] sc Base address of smartcard module.
N  * @param[in] u32Count The number of times of Rx error retry count, between 0~8. 0 means disable Rx error retry.
N  * @return None
N  * @details This macro enable/disable receiver retry function when parity error has occurred, and set error retry count.
N  */
N__STATIC_INLINE void  SC_SetRxRetry(SC_T *sc, uint32_t u32Count)
Xstatic __inline void  SC_SetRxRetry(SC_T *sc, uint32_t u32Count)
N{
N    while((sc)->CTL & SC_CTL_SYNC_Msk);
X    while((sc)->CTL & (1ul << 30));
N    if((u32Count) == 0)         // disable Rx error retry
N    {
N        (sc)->CTL &= ~(SC_CTL_RX_ERETRY_Msk | SC_CTL_RX_ERETRY_EN_Msk);
X        (sc)->CTL &= ~((7ul << 16) | (1ul << 19));
N    }
N    else
N    {
N        (sc)->CTL = ((sc)->CTL & ~SC_CTL_RX_ERETRY_Msk) | (((u32Count) - 1) << SC_CTL_RX_ERETRY_Pos) | SC_CTL_RX_ERETRY_EN_Msk;
X        (sc)->CTL = ((sc)->CTL & ~(7ul << 16)) | (((u32Count) - 1) << 16) | (1ul << 19);
N    }
N}
N
N
Nuint32_t SC_IsCardInserted(SC_T *sc);
Nvoid SC_ClearFIFO(SC_T *sc);
Nvoid SC_Close(SC_T *sc);
Nvoid SC_Open(SC_T *sc, uint32_t u32CardDet, uint32_t u32PWR);
Nvoid SC_ResetReader(SC_T *sc);
Nvoid SC_SetBlockGuardTime(SC_T *sc, uint32_t u32BGT);
Nvoid SC_SetCharGuardTime(SC_T *sc, uint32_t u32CGT);
Nvoid SC_StopAllTimer(SC_T *sc);
Nvoid SC_StartTimer(SC_T *sc, uint32_t u32TimerNum, uint32_t u32Mode, uint32_t u32ETUCount);
Nvoid SC_StopTimer(SC_T *sc, uint32_t u32TimerNum);
N
N
N/*@}*/ /* end of group SC_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group SC_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__SC_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 12460 ".\Libraries\Device\Nuvoton\NUC230_240\Include\NUC230_240.h" 2
N#include "SCUART.h"
L 1 ".\Libraries\StdDriver\inc\SCUART.h" 1
N/**************************************************************************//**
N * @file     sc.h
N * @version  V3.00
N * $Revision: 5 $
N * $Date: 15/05/12 1:52p $
N * @brief    NUC230_240 series Smartcard UART mode (SCUART) driver header file
N *
N * @note
N * Copyright (C) 2013 Nuvoton Technology Corp. All rights reserved.
N *****************************************************************************/
N#ifndef __SCUART_H__
N#define __SCUART_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup SCUART_Driver SCUART Driver
N  @{
N*/
N
N/** @addtogroup SCUART_EXPORTED_CONSTANTS SCUART Exported Constants
N  @{
N*/
N#define SCUART_CHAR_LEN_5     (0x3ul << SC_UACTL_DATA_LEN_Pos)  /*!< Set SCUART word length to 5 bits */
N#define SCUART_CHAR_LEN_6     (0x2ul << SC_UACTL_DATA_LEN_Pos)  /*!< Set SCUART word length to 6 bits */
N#define SCUART_CHAR_LEN_7     (0x1ul << SC_UACTL_DATA_LEN_Pos)  /*!< Set SCUART word length to 7 bits */
N#define SCUART_CHAR_LEN_8     (0)                               /*!< Set SCUART word length to 8 bits */
N
N#define SCUART_PARITY_NONE    (SC_UACTL_PBDIS_Msk)              /*!< Set SCUART transfer with no parity   */
N#define SCUART_PARITY_ODD     (SC_UACTL_OPE_Msk)                /*!< Set SCUART transfer with odd parity  */
N#define SCUART_PARITY_EVEN    (0)                               /*!< Set SCUART transfer with even parity */
N
N#define SCUART_STOP_BIT_1     (SC_CTL_SLEN_Msk)                 /*!< Set SCUART transfer with one stop bit  */
N#define SCUART_STOP_BIT_2     (0)                               /*!< Set SCUART transfer with two stop bits */
N
N
N/*@}*/ /* end of group SCUART_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup SCUART_EXPORTED_FUNCTIONS SCUART Exported Functions
N  @{
N*/
N
N/* TX Macros */
N/**
N  * @brief Write Data to Tx data register.
N  * @param[in] sc The base address of smartcard module.
N  * @param[in] u8Data Data byte to transmit.
N  * @return None
N  * @details By writing data to THR register, the SC will send out an 8-bit data.
N  * \hideinitializer
N  */
N#define SCUART_WRITE(sc, u8Data) ((sc)->THR = (u8Data))
N
N/**
N  * @brief Get TX FIFO empty flag status from register.
N  * @param[in] sc The base address of smartcard module.
N  * @return Transmit FIFO empty status.
N  * @retval 0 Transmit FIFO is not empty.
N  * @retval SC_TRSR_TX_EMPTY_F_Msk Transmit FIFO is empty.
N  * @details When the last byte of TX buffer has been transferred to Transmitter Shift Register, hardware sets TX_EMPTY_F bit (SC_TRSR[9]) high.
N  *          It will be cleared when writing data into THR(SC_THR[7:0]).
N  * \hideinitializer
N  */
N#define SCUART_GET_TX_EMPTY(sc) ((sc)->TRSR & SC_TRSR_TX_EMPTY_F_Msk)
N
N/**
N  * @brief Get TX FIFO full flag status from register.
N  * @param[in] sc The base address of smartcard module.
N  * @retval 0 Transmit FIFO is not full.
N  * @retval SC_TRSR_TX_FULL_F_Msk Transmit FIFO is full.
N  * @details TX_FULL_F(SC_TRSR[10]) is set when TX pointer is equal to 4, otherwise is cleared by hardware.
N  * \hideinitializer
N  */
N#define SCUART_GET_TX_FULL(sc) ((sc)->TRSR & SC_TRSR_TX_FULL_F_Msk)
N
N/**
N  * @brief Wait specified smartcard port transmission complete.
N  * @param[in] sc The base address of smartcard module.
N  * @return None
N  * @details TX_ATV (SC_TRSR[31]) is cleared automatically when TX transfer is finished or the last byte transmission has completed.
N  * @note This macro blocks until transmit complete.
N  * \hideinitializer
N  */
N#define SCUART_WAIT_TX_EMPTY(sc) while((sc)->TRSR & SC_TRSR_TX_ATV_Msk)
N
N/**
N  * @brief Check specified smartcard port transmit FIFO is full or not.
N  * @param[in] sc The base address of smartcard module.
N  * @retval 0 Transmit FIFO is not full.
N  * @retval 1 Transmit FIFO is full.
N  * @details TX_FULL_F(SC_TRSR[10]) indicates TX buffer full or not.
N  *          This is set when TX pointer is equal to 4, otherwise is cleared by hardware.
N  * \hideinitializer
N  */
N#define SCUART_IS_TX_FULL(sc) ((sc)->TRSR & SC_TRSR_TX_FULL_F_Msk ? 1 : 0)
N
N/**
N  * @brief Check specified smartcard port transmission is over.
N  * @param[in] sc The base address of smartcard module.
N  * @retval 0 Transmit is not complete.
N  * @retval 1 Transmit complete.
N  * @details TX_ATV (SC_TRSR[31]) is set by hardware when TX transfer is in active and the STOP bit of the last byte has been transmitted.
N  * \hideinitializer
N  */
N#define SCUART_IS_TX_EMPTY(sc) ((sc)->TRSR & SC_TRSR_TX_ATV_Msk ? 0 : 1)
N
N
N/* RX Macros */
N
N/**
N  * @brief Read Rx data register.
N  * @param[in] sc The base address of smartcard module.
N  * @return The oldest data byte in RX FIFO.
N  * @details By reading RBR register, the SC will return an 8-bit received data.
N  * \hideinitializer
N  */
N#define SCUART_READ(sc) ((sc)->RBR)
N
N/**
N  * @brief Get RX FIFO empty flag status from register.
N  * @param[in] sc The base address of smartcard module.
N  * @retval 0 Receive FIFO is not empty.
N  * @retval SC_TRSR_RX_EMPTY_F_Msk Receive FIFO is empty.
N  * @details When the last byte of Rx buffer has been read by CPU, hardware sets RX_EMPTY_F(SC_TRSR[1]) high.
N  *          It will be cleared when SC receives any new data.
N  * \hideinitializer
N  */
N#define SCUART_GET_RX_EMPTY(sc) ((sc)->TRSR & SC_TRSR_RX_EMPTY_F_Msk)
N
N
N/**
N  * @brief Get RX FIFO full flag status from register.
N  * @param[in] sc The base address of smartcard module.
N  * @retval 0 Receive FIFO is not full.
N  * @retval SC_TRSR_TX_FULL_F_Msk Receive FIFO is full.
N  * @details RX_FULL_F(SC_TRSR[2]) is set when RX pointer is equal to 4, otherwise it is cleared by hardware.
N  * \hideinitializer
N  */
N#define SCUART_GET_RX_FULL(sc) ((sc)->TRSR & SC_TRSR_RX_FULL_F_Msk)
N
N/**
N  * @brief Check if receive data number in FIFO reach FIFO trigger level or not.
N  * @param[in] sc The base address of smartcard module.
N  * @retval 0 The number of bytes in receive FIFO is less than trigger level.
N  * @retval 1 The number of bytes in receive FIFO equals or larger than trigger level.
N  * @details RDA_IS(SC_ISR[0]) is used for received data reaching trigger level RX_FTRI_LEV (SC_CTL[7:6]) interrupt status flag.
N  * @note If receive trigger level is \b not 1 byte, this macro return 0 does not necessary indicates there is no data in FIFO.
N  * \hideinitializer
N  */
N#define SCUART_IS_RX_READY(sc) ((sc)->ISR & SC_ISR_RDA_IS_Msk ? 1 : 0)
N
N/**
N  * @brief Check specified smartcard port receive FIFO is full or not.
N  * @param[in] sc The base address of smartcard module.
N  * @retval 0 Receive FIFO is not full.
N  * @retval 1 Receive FIFO is full.
N  * @details RX_FULL_F(SC_TRSR[2]) is set when RX pointer is equal to 4, otherwise it is cleared by hardware.
N  * \hideinitializer
N  */
N#define SCUART_IS_RX_FULL(sc) ((sc)->TRSR & SC_TRSR_RX_FULL_F_Msk ? 1 : 0)
N
N/* Interrupt Macros */
N
N/**
N  * @brief Enable specified interrupts.
N  * @param[in] sc The base address of smartcard module.
N  * @param[in] u32Mask Interrupt masks to enable, a combination of following bits.
N  *             - \ref SC_IER_RTMR_IE_Msk
N  *             - \ref SC_IER_TERR_IE_Msk
N  *             - \ref SC_IER_TBE_IE_Msk
N  *             - \ref SC_IER_RDA_IE_Msk
N  * @return None
N  * @details The macro is used to enable receiver buffer time-out interrupt, transfer error interrupt,
N  *          transmit buffer empty interrupt or receive data reach trigger level interrupt.
N  * \hideinitializer
N  */
N#define SCUART_ENABLE_INT(sc, u32Mask) ((sc)->IER |= (u32Mask))
N
N/**
N  * @brief Disable specified interrupts.
N  * @param[in] sc The base address of smartcard module.
N  * @param[in] u32Mask Interrupt masks to disable, a combination of following bits.
N  *             - \ref SC_IER_RTMR_IE_Msk
N  *             - \ref SC_IER_TERR_IE_Msk
N  *             - \ref SC_IER_TBE_IE_Msk
N  *             - \ref SC_IER_RDA_IE_Msk
N  * @return None
N  * @details The macro is used to disable receiver buffer time-out interrupt, transfer error interrupt,
N  *          transmit buffer empty interrupt or receive data reach trigger level interrupt.
N  * \hideinitializer
N  */
N#define SCUART_DISABLE_INT(sc, u32Mask) ((sc)->IER &= ~(u32Mask))
N
N/**
N  * @brief Get specified interrupt flag/status.
N  * @param[in] sc The base address of smartcard module.
N  * @param[in] u32Type Interrupt flag/status to check, could be one of following value:
N  *             - \ref SC_ISR_RTMR_IS_Msk
N  *             - \ref SC_ISR_TERR_IS_Msk
N  *             - \ref SC_ISR_TBE_IS_Msk
N  *             - \ref SC_ISR_RDA_IS_Msk
N  * @return The status of specified interrupt.
N  * @retval 0 Specified interrupt does not happened.
N  * @retval 1 Specified interrupt happened.
N  * @details The macro is used to get receiver buffer time-out interrupt status, transfer error interrupt status,
N  *          transmit buffer empty interrupt status or receive data reach interrupt status.
N  * \hideinitializer
N  */
N#define SCUART_GET_INT_FLAG(sc, u32Type) ((sc)->ISR & (u32Type) ? 1 : 0)
N
N/**
N  * @brief Clear specified interrupt flag/status.
N  * @param[in] sc The base address of smartcard module.
N  * @param[in] u32Type Interrupt flag/status to clear, could be the combination of following values:
N  *             - \ref SC_ISR_RTMR_IS_Msk
N  *             - \ref SC_ISR_TERR_IS_Msk
N  *             - \ref SC_ISR_TBE_IS_Msk
N  * @return None
N  * @details The macro is used to clear receiver buffer time-out interrupt flag, transfer error interrupt flag or
N  *          transmit buffer empty interrupt flag.
N  * \hideinitializer
N  */
N#define SCUART_CLR_INT_FLAG(sc, u32Type) ((sc)->ISR = (u32Type))
N
N/**
N  * @brief Get receive error flag/status.
N  * @param[in] sc The base address of smartcard module.
N  * @return Current receive error status, could one of following errors:
N  * @retval SC_TRSR_RX_EPA_F_Msk Parity error.
N  * @retval SC_TRSR_RX_EFR_F_Msk Frame error.
N  * @retval SC_TRSR_RX_EBR_F_Msk Break error.
N  * @details The macro is used to get receiver parity error status, receiver frame error status or
N  *          receiver break error status.
N  * \hideinitializer
N  */
N#define SCUART_GET_ERR_FLAG(sc) ((sc)->TRSR & (SC_TRSR_RX_EPA_F_Msk | SC_TRSR_RX_EFR_F_Msk | SC_TRSR_RX_EBR_F_Msk))
N
N/**
N  * @brief Clear specified receive error flag/status.
N  * @param[in] sc The base address of smartcard module.
N  * @param[in] u32Mask Receive error flag/status to clear, combination following values:
N  *             - \ref SC_TRSR_RX_EPA_F_Msk
N  *             - \ref SC_TRSR_RX_EFR_F_Msk
N  *             - \ref SC_TRSR_RX_EBR_F_Msk
N  * @return None
N  * @details The macro is used to clear receiver parity error flag, receiver frame error flag or
N  *          receiver break error flag.
N  * \hideinitializer
N  */
N#define SCUART_CLR_ERR_FLAG(sc, u32Mask) ((sc)->TRSR = (u32Mask))
N
Nvoid SCUART_Close(SC_T* sc);
Nuint32_t SCUART_Open(SC_T* sc, uint32_t u32baudrate);
Nuint32_t SCUART_Read(SC_T* sc, uint8_t *pu8RxBuf, uint32_t u32ReadBytes);
Nuint32_t SCUART_SetLineConfig(SC_T* sc, uint32_t u32Baudrate, uint32_t u32DataWidth, uint32_t u32Parity, uint32_t  u32StopBits);
Nvoid SCUART_SetTimeoutCnt(SC_T* sc, uint32_t u32TOC);
Nvoid SCUART_Write(SC_T* sc, uint8_t *pu8TxBuf, uint32_t u32WriteBytes);
N
N/*@}*/ /* end of group SCUART_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group SCUART_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__SCUART_H__
N
N/*** (C) COPYRIGHT 2013 Nuvoton Technology Corp. ***/
L 12461 ".\Libraries\Device\Nuvoton\NUC230_240\Include\NUC230_240.h" 2
N#include "PS2.h"
L 1 ".\Libraries\StdDriver\inc\PS2.h" 1
N/**************************************************************************//**
N * @file     PS2.h
N * @version  V3.00
N * $Revision: 4 $
N * $Date: 15/05/19 8:58p $
N * @brief    NUC230_240 Series PS/2 Driver Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N ******************************************************************************/
N#ifndef __PS2_H__
N#define __PS2_H__
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Include related headers                                                                                 */
N/*---------------------------------------------------------------------------------------------------------*/
N#include "NUC230_240.h"
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup PS2_Driver PS2 Driver
N  @{
N*/
N
N
N/** @addtogroup PS2_EXPORTED_FUNCTIONS PS2 Exported Functions
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Define Macros and functions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/**
N *  @brief     To Set PS/2 Tx FIFO length
N *
N *  @param[in] u32Count    Tx FIFO length
N *
N *  @return    None
N *
N *  @details   Before PS/2 data transmit, program needs to set the FIFO depth.
N * \hideinitializer
N */
N#define PS2_SET_TX_BYTE_CNT(u32Count) (PS2->PS2CON = (PS2->PS2CON & ~PS2_PS2CON_TXFIFO_DEPTH_Msk) \
N                                      | (((u32Count)-1) << PS2_PS2CON_TXFIFO_DEPTH_Pos))
X#define PS2_SET_TX_BYTE_CNT(u32Count) (PS2->PS2CON = (PS2->PS2CON & ~PS2_PS2CON_TXFIFO_DEPTH_Msk)                                       | (((u32Count)-1) << PS2_PS2CON_TXFIFO_DEPTH_Pos))
N
N/**
N *  @brief     This function use to Get PS/2 Status
N *
N *  @param     None
N *
N *  @return    PS/2 bus status
N *
N *  @details   To get PS/2 bus status which are about Byte index, Tx/Rx status, Error status and PS/2 line status.
N */
N#define PS2_GET_STATUS() (PS2->PS2STATUS)
N
N/**
N *  @brief     This function is used to Clear PS/2 Status
N *
N *  @param[in] u32Mask    Clear the specified status of PS/2 module:
N *                        1. PS2D_PS2STATUS_FRAMERR_Msk 2. PS2D_PS2STATUS_RXOVF_Msk
N *
N *  @return    None
N *
N *  @details   To clear PS/2 bus status which are about Byte index, TX/RX status, Error status, PS/2 line status.
N */
N#define PS2_CLR_STATUS(u32Mask) (PS2->PS2STATUS = (u32Mask))
N
N/**
N *  @brief     This function is used to Clear PS/2 Tx FIFO
N *
N *  @param     None
N *
N *  @return    None
N *
N *  @details   Write 1 to terminate PS/2 device to host transmission.
N *
N *  @note      Write 1 is always clear Tx FIFO, and need write 0 to STOP the clear action.
N */
N__STATIC_INLINE void PS2_CLEAR_TX_FIFO(void)
Xstatic __inline void PS2_CLEAR_TX_FIFO(void)
N{
N    PS2->PS2CON |= PS2_PS2CON_CLRFIFO_Msk;
X    ((PS2_T *) ((( uint32_t)0x40100000) + 0x00000))->PS2CON |= (1ul << 8);
N    PS2->PS2CON &= ~PS2_PS2CON_CLRFIFO_Msk;
X    ((PS2_T *) ((( uint32_t)0x40100000) + 0x00000))->PS2CON &= ~(1ul << 8);
N}
N
N/**
N *  @brief    This function is used to Clear PS2 Rx interrupt
N *
N *  @param    None
N *
N *  @return   None
N *
N *  @details  To disable PS/2 receive interrupt occurs.
N */
N#define PS2_CLR_RX_INT_FLAG() (PS2->PS2INTID = PS2_PS2INTID_RXINT_Msk)
N
N/**
N *  @brief    This function is used to Clear PS/2 Tx Interrupt
N *
N *  @param    None
N *
N *  @return   None
N *
N *  @details  To disable PS/2 transmit interrupt occurs.
N */
N#define PS2_CLR_TX_INT_FLAG() (PS2->PS2INTID = PS2_PS2INTID_TXINT_Msk)
N
N/**
N *  @brief     This function is used to Get PS/2 Interrupt
N *
N *  @param[in] u32IntFlag  Interrupt flag of PS2_PS2INTID_TXINT_Msk, PS2_PS2INTID_RXINT_Msk
N *
N *  @retval    1 Interrupt occurs
N *  @retval    0 Interrupt not occurs
N *
N *  @details   To check PS/2 bus interrupt occur from TX or RX
N */
N#define PS2_GET_INT_FLAG(u32IntFlag) ((PS2->PS2INTID & (u32IntFlag))?1:0)
N
N/**
N *  @brief    Disable PS2CLK and PS2DATA pins override.
N *
N *  @param    None
N *
N *  @return   None
N *
N *  @details  To disable the override control of PS2CLK and PS2DATA pins.
N */
N#define PS2_DISABLE_OVERRIDE() (PS2->PS2CON &= ~PS2_PS2CON_OVERRIDE_Msk)
N
N/**
N *  @brief    Enable PS2CLK and PS2DATA pins Override.
N *
N *  @param    None
N *
N *  @return   None
N *
N *  @details  TO enable the override control of PS2CLK and PS2DATA pins.
N */
N#define PS2_ENABLE_OVERRIDE() (PS2->PS2CON |= PS2_PS2CON_OVERRIDE_Msk)
N
N/**
N *  @brief    This function is used to Get Indicates which data byte in transmit data shift register
N *
N *  @param    None
N *
N *  @return   The indicates which data byte in transmit data shift register.
N *
N *  @details  To get a indication which a data byte in the data shift register.
N */
N#define PS2_GET_TX_BYTE_INDEX() ((PS2->PS2STATUS & PS2_PS2STATUS_BYTEIDX_Msk) >> PS2_PS2STATUS_BYTEIDX_Pos)
N
N/**
N *  @brief    This function is used to set PS2DATA Pin low.
N *
N *  @param    None
N *
N *  @return   None
N *
N *  @details  To control the PS2DATA pin state to low.
N */
N#define PS2_SET_DATA_LOW() (PS2->PS2CON &= ~PS2_PS2CON_FPS2DAT_Msk)
N
N/**
N *  @brief    This function is used to set PS2DATA Pin high
N *
N *  @param    None
N *
N *  @return   None
N *
N *  @details  To control the PS2DATA pin state to high.
N */
N#define PS2_SET_DATA_HIGH() (PS2->PS2CON |= PS2_PS2CON_FPS2DAT_Msk)
N
N/**
N *  @brief    This function is used to set PS2CLK Pin low.
N *
N *  @param    None
N *
N *  @return   None
N *
N *  @details  To control the PS2CLK pin state to low.
N */
N#define PS2_SET_CLK_LOW() (PS2->PS2CON &= ~PS2_PS2CON_FPS2CLK_Msk)
N
N/**
N *  @brief    This function is used to set PS2CLK Pin high.
N *
N *  @param    None
N *
N *  @return   None
N *
N *  @details  To control the PS2CLK pin state to high.
N */
N#define PS2_SET_CLK_HIGH() (PS2->PS2CON |= PS2_PS2CON_FPS2CLK_Msk)
N
N/**
N *  @brief    Disable always sends acknowledge
N *
N *  @param    None
N *
N *  @return   None
N *
N *  @details  If parity error or Stop bit is not received correctly, acknowledge will not be sent to host at 12th clock.
N */
N#define PS2_DISABLE_ACK_ALWAYS() (PS2->PS2CON |= PS2_PS2CON_ACK_Msk)
N
N/**
N *  @brief    Always sends acknowledge
N *
N *  @param    None
N *
N *  @return   None
N *
N *  @details  Always send acknowledge to host at 12th clock for host to device communication.
N */
N#define PS2_ENABLE_ACK_ALWAYS() (PS2->PS2CON &= ~PS2_PS2CON_ACK_Msk)
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Define Function Prototypes                                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N
Nvoid PS2_Open(void);
Nvoid PS2_Close(void);
Nuint8_t PS2_Read(void);
Nint32_t PS2_Write(uint32_t *pu32Buf, uint32_t u32ByteCount);
Nvoid PS2_EnableInt(uint32_t u32Mask);
Nvoid PS2_DisableInt(uint32_t u32Mask);
N
N
N/*@}*/ /* end of group PS2_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group PS2_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__PS2_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
N
L 12462 ".\Libraries\Device\Nuvoton\NUC230_240\Include\NUC230_240.h" 2
N#include "CLK.h"
L 1 ".\Libraries\StdDriver\inc\CLK.h" 1
N/**************************************************************************//**
N * @file     clk.h
N * @version  V3.0
N * $Revision: 13 $
N * $Date: 15/06/04 5:31p $
N * @brief    NUC230_240 Series Clock Control Driver Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __CLK_H__
N#define __CLK_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup CLK_Driver CLK Driver
N  @{
N*/
N
N/** @addtogroup CLK_EXPORTED_CONSTANTS CLK Exported Constants
N  @{
N*/
N
N#define FREQ_25MHZ         25000000
N#define FREQ_50MHZ         50000000
N#define FREQ_72MHZ         72000000
N#define FREQ_100MHZ       100000000
N#define FREQ_200MHZ       200000000
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKSEL0 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKSEL0_HCLK_S_HXT          (0x0UL<<CLK_CLKSEL0_HCLK_S_Pos)   /*!< Setting HCLK clock source as external X'tal */
N#define CLK_CLKSEL0_HCLK_S_LXT          (0x1UL<<CLK_CLKSEL0_HCLK_S_Pos)   /*!< Setting HCLK clock source as external X'tal 32.768KHz*/
N#define CLK_CLKSEL0_HCLK_S_PLL          (0x2UL<<CLK_CLKSEL0_HCLK_S_Pos)   /*!< Setting HCLK clock source as PLL output */
N#define CLK_CLKSEL0_HCLK_S_LIRC         (0x3UL<<CLK_CLKSEL0_HCLK_S_Pos)   /*!< Setting HCLK clock source as internal 10KHz RC clock */
N#define CLK_CLKSEL0_HCLK_S_HIRC         (0x7UL<<CLK_CLKSEL0_HCLK_S_Pos)   /*!< Setting HCLK clock source as internal 22.1184MHz RC clock */
N
N#define CLK_CLKSEL0_STCLK_S_HXT         (0x0UL<<CLK_CLKSEL0_STCLK_S_Pos)  /*!< Setting STCLK clock source as external X'tal */
N#define CLK_CLKSEL0_STCLK_S_LXT         (0x1UL<<CLK_CLKSEL0_STCLK_S_Pos)  /*!< Setting STCLK clock source as external X'tal 32.768KHz*/
N#define CLK_CLKSEL0_STCLK_S_HXT_DIV2    (0x2UL<<CLK_CLKSEL0_STCLK_S_Pos)  /*!< Setting STCLK clock source as external X'tal/2 */
N#define CLK_CLKSEL0_STCLK_S_HCLK_DIV2   (0x3UL<<CLK_CLKSEL0_STCLK_S_Pos)  /*!< Setting STCLK clock source as HCLK/2 */
N#define CLK_CLKSEL0_STCLK_S_HIRC_DIV2   (0x7UL<<CLK_CLKSEL0_STCLK_S_Pos)  /*!< Setting STCLK clock source as internal 22.1184MHz RC clock/2 */
N#define CLK_CLKSEL0_STCLK_S_HCLK        (0x1UL<<SysTick_CTRL_CLKSOURCE_Pos)  /*!< Setting STCLK clock source as HCLK */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKSEL1 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKSEL1_WDT_S_LXT           (0x1UL<<CLK_CLKSEL1_WDT_S_Pos)    /*!< Setting WDT clock source as external X'tal 32.768KHz*/
N#define CLK_CLKSEL1_WDT_S_HCLK_DIV2048  (0x2UL<<CLK_CLKSEL1_WDT_S_Pos)    /*!< Setting WDT clock source as HCLK/2048 */
N#define CLK_CLKSEL1_WDT_S_LIRC          (0x3UL<<CLK_CLKSEL1_WDT_S_Pos)    /*!< Setting WDT clock source as internal 10KHz RC clock */
N
N#define CLK_CLKSEL1_ADC_S_HXT           (0x0UL<<CLK_CLKSEL1_ADC_S_Pos)    /*!< Setting ADC clock source as external X'tal */
N#define CLK_CLKSEL1_ADC_S_PLL           (0x1UL<<CLK_CLKSEL1_ADC_S_Pos)    /*!< Setting ADC clock source as PLL */
N#define CLK_CLKSEL1_ADC_S_HCLK          (0x2UL<<CLK_CLKSEL1_ADC_S_Pos)    /*!< Setting ADC clock source as HCLK */
N#define CLK_CLKSEL1_ADC_S_HIRC          (0x3UL<<CLK_CLKSEL1_ADC_S_Pos)    /*!< Setting ADC clock source as internal 22.1184MHz RC clock */
N
N#define CLK_CLKSEL1_SPI0_S_PLL          (0x0UL<<CLK_CLKSEL1_SPI0_S_Pos)   /*!< Setting SPI0 clock source as PLL */
N#define CLK_CLKSEL1_SPI0_S_HCLK         (0x1UL<<CLK_CLKSEL1_SPI0_S_Pos)   /*!< Setting SPI0 clock source as HCLK */
N#define CLK_CLKSEL1_SPI1_S_PLL          (0x0UL<<CLK_CLKSEL1_SPI1_S_Pos)   /*!< Setting SPI1 clock source as PLL */
N#define CLK_CLKSEL1_SPI1_S_HCLK         (0x1UL<<CLK_CLKSEL1_SPI1_S_Pos)   /*!< Setting SPI1 clock source as HCLK */
N#define CLK_CLKSEL1_SPI2_S_PLL          (0x0UL<<CLK_CLKSEL1_SPI2_S_Pos)   /*!< Setting SPI2 clock source as PLL */
N#define CLK_CLKSEL1_SPI2_S_HCLK         (0x1UL<<CLK_CLKSEL1_SPI2_S_Pos)   /*!< Setting SPI2 clock source as HCLK */
N#define CLK_CLKSEL1_SPI3_S_PLL          (0x0UL<<CLK_CLKSEL1_SPI3_S_Pos)   /*!< Setting SPI3 clock source as PLL */
N#define CLK_CLKSEL1_SPI3_S_HCLK         (0x1UL<<CLK_CLKSEL1_SPI3_S_Pos)   /*!< Setting SPI3 clock source as HCLK */
N
N#define CLK_CLKSEL1_TMR0_S_HXT          (0x0UL<<CLK_CLKSEL1_TMR0_S_Pos)   /*!< Setting TMR0 clock source as external X'tal */
N#define CLK_CLKSEL1_TMR0_S_LXT          (0x1UL<<CLK_CLKSEL1_TMR0_S_Pos)   /*!< Setting TMR0 clock source as external X'tal 32.768KHz */
N#define CLK_CLKSEL1_TMR0_S_HCLK         (0x2UL<<CLK_CLKSEL1_TMR0_S_Pos)   /*!< Setting TMR0 clock source as HCLK */
N#define CLK_CLKSEL1_TMR0_S_EXT_TRG      (0x3UL<<CLK_CLKSEL1_TMR0_S_Pos)   /*!< Setting TMR0 clock source as external trigger */
N#define CLK_CLKSEL1_TMR0_S_LIRC         (0x5UL<<CLK_CLKSEL1_TMR0_S_Pos)   /*!< Setting TMR0 clock source as internal 10KHz RC clock */
N#define CLK_CLKSEL1_TMR0_S_HIRC         (0x7UL<<CLK_CLKSEL1_TMR0_S_Pos)   /*!< Setting TMR0 clock source as internal 22.1184MHz RC clock */
N#define CLK_CLKSEL1_TMR1_S_HXT          (0x0UL<<CLK_CLKSEL1_TMR1_S_Pos)   /*!< Setting TMR1 clock source as external X'tal */
N#define CLK_CLKSEL1_TMR1_S_LXT          (0x1UL<<CLK_CLKSEL1_TMR1_S_Pos)   /*!< Setting TMR1 clock source as external X'tal 32.768KHz */
N#define CLK_CLKSEL1_TMR1_S_HCLK         (0x2UL<<CLK_CLKSEL1_TMR1_S_Pos)   /*!< Setting TMR1 clock source as HCLK */
N#define CLK_CLKSEL1_TMR1_S_EXT_TRG      (0x3UL<<CLK_CLKSEL1_TMR1_S_Pos)   /*!< Setting TMR1 clock source as external trigger */
N#define CLK_CLKSEL1_TMR1_S_LIRC         (0x5UL<<CLK_CLKSEL1_TMR1_S_Pos)   /*!< Setting TMR1 clock source as internal 10KHz RC clock */
N#define CLK_CLKSEL1_TMR1_S_HIRC         (0x7UL<<CLK_CLKSEL1_TMR1_S_Pos)   /*!< Setting TMR1 clock source as internal 22.1184MHz RC clock */
N#define CLK_CLKSEL1_TMR2_S_HXT          (0x0UL<<CLK_CLKSEL1_TMR2_S_Pos)   /*!< Setting TMR2 clock source as external X'tal */
N#define CLK_CLKSEL1_TMR2_S_LXT          (0x1UL<<CLK_CLKSEL1_TMR2_S_Pos)   /*!< Setting TMR2 clock source as external X'tal 32.768KHz */
N#define CLK_CLKSEL1_TMR2_S_HCLK         (0x2UL<<CLK_CLKSEL1_TMR2_S_Pos)   /*!< Setting TMR2 clock source as HCLK */
N#define CLK_CLKSEL1_TMR2_S_EXT_TRG      (0x3UL<<CLK_CLKSEL1_TMR2_S_Pos)   /*!< Setting TMR2 clock source as external trigger */
N#define CLK_CLKSEL1_TMR2_S_LIRC         (0x5UL<<CLK_CLKSEL1_TMR2_S_Pos)   /*!< Setting TMR2 clock source as internal 10KHz RC clock */
N#define CLK_CLKSEL1_TMR2_S_HIRC         (0x7UL<<CLK_CLKSEL1_TMR2_S_Pos)   /*!< Setting TMR2 clock source as internal 22.1184MHz RC clock */
N#define CLK_CLKSEL1_TMR3_S_HXT          (0x0UL<<CLK_CLKSEL1_TMR3_S_Pos)   /*!< Setting TMR3 clock source as external X'tal */
N#define CLK_CLKSEL1_TMR3_S_LXT          (0x1UL<<CLK_CLKSEL1_TMR3_S_Pos)   /*!< Setting TMR3 clock source as external X'tal 32.768KHz */
N#define CLK_CLKSEL1_TMR3_S_HCLK         (0x2UL<<CLK_CLKSEL1_TMR3_S_Pos)   /*!< Setting TMR3 clock source as HCLK */
N#define CLK_CLKSEL1_TMR3_S_EXT_TRG      (0x3UL<<CLK_CLKSEL1_TMR3_S_Pos)   /*!< Setting TMR3 clock source as external trigger */
N#define CLK_CLKSEL1_TMR3_S_LIRC         (0x5UL<<CLK_CLKSEL1_TMR3_S_Pos)   /*!< Setting TMR3 clock source as internal 10KHz RC clock */
N#define CLK_CLKSEL1_TMR3_S_HIRC         (0x7UL<<CLK_CLKSEL1_TMR3_S_Pos)   /*!< Setting TMR3 clock source as internal 22.1184MHz RC clock */
N
N#define CLK_CLKSEL1_UART_S_HXT          (0x0UL<<CLK_CLKSEL1_UART_S_Pos)   /*!< Setting UART clock source as external X'tal */
N#define CLK_CLKSEL1_UART_S_PLL          (0x1UL<<CLK_CLKSEL1_UART_S_Pos)   /*!< Setting UART clock source as external PLL */
N#define CLK_CLKSEL1_UART_S_HIRC         (0x3UL<<CLK_CLKSEL1_UART_S_Pos)   /*!< Setting UART clock source as external internal 22.1184MHz RC clock */
N
N#define CLK_CLKSEL1_PWM01_S_HXT         (0x0UL<<CLK_CLKSEL1_PWM01_S_Pos)  /*!< Setting PWM01 clock source as external X'tal, 
N                                                                               user must set CLK_CLKSEL2_PWM01_EXT_HXT concurrently to complete clock source as external X'tal setting*/
N#define CLK_CLKSEL1_PWM01_S_LXT         (0x1UL<<CLK_CLKSEL1_PWM01_S_Pos)  /*!< Setting PWM01 clock source as external X'tal 32.768KHz,
N                                                                               user must set CLK_CLKSEL2_PWM01_EXT_LXT concurrently to complete clock source as external X'tal 32.768KHz setting*/
N#define CLK_CLKSEL1_PWM01_S_HCLK        (0x2UL<<CLK_CLKSEL1_PWM01_S_Pos)  /*!< Setting PWM01 clock source as HCLK 
N                                                                               user must set CLK_CLKSEL2_PWM01_EXT_HCLK concurrently to complete clock source as HCLK setting*/
N#define CLK_CLKSEL1_PWM01_S_HIRC        (0x3UL<<CLK_CLKSEL1_PWM01_S_Pos)  /*!< Setting PWM01 clock source as internal 22.1184MHz RC clock,
N                                                                               user must set CLK_CLKSEL2_PWM01_EXT_HIRC concurrently to complete clock source as internal 22.1184MHz RC clock setting*/
N#define CLK_CLKSEL1_PWM01_S_LIRC        (0x3UL<<CLK_CLKSEL1_PWM01_S_Pos)  /*!< Setting PWM01 clock source as internal 10KHz RC clock,
N                                                                               user must set CLK_CLKSEL2_PWM01_EXT_LIRC concurrently to complete clock source as internal 10KHz RC clock setting*/
N
N#define CLK_CLKSEL1_PWM23_S_HXT         (0x0UL<<CLK_CLKSEL1_PWM23_S_Pos)  /*!< Setting PWM23 clock source as external X'tal,
N                                                                               user must set CLK_CLKSEL2_PWM23_EXT_HXT concurrently to complete clock source as external X'tal setting*/
N#define CLK_CLKSEL1_PWM23_S_LXT         (0x1UL<<CLK_CLKSEL1_PWM23_S_Pos)  /*!< Setting PWM23 clock source as external X'tal 32.768KHz,
N                                                                               user must set CLK_CLKSEL2_PWM23_EXT_LXT concurrently to complete clock source as external X'tal 32.768KHz setting*/
N#define CLK_CLKSEL1_PWM23_S_HCLK        (0x2UL<<CLK_CLKSEL1_PWM23_S_Pos)  /*!< Setting PWM23 clock source as HCLK,
N                                                                               user must set CLK_CLKSEL2_PWM23_EXT_HCLK concurrently to complete clock source as HCLK setting*/
N#define CLK_CLKSEL1_PWM23_S_HIRC        (0x3UL<<CLK_CLKSEL1_PWM23_S_Pos)  /*!< Setting PWM23 clock source as internal 22.1184MHz RC clock,
N                                                                               user must set CLK_CLKSEL2_PWM23_EXT_HIRC concurrently to complete clock source as internal 22.1184MHz RC clock setting*/
N#define CLK_CLKSEL1_PWM23_S_LIRC        (0x3UL<<CLK_CLKSEL1_PWM23_S_Pos)  /*!< Setting PWM23 clock source as internal 10KHz RC clock,
N                                                                               user must set CLK_CLKSEL2_PWM23_EXT_LIRC concurrently to complete clock source as internal 10KHz RC clock setting*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKSEL2 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKSEL2_I2S_S_HXT           (0x0UL<<CLK_CLKSEL2_I2S_S_Pos)    /*!< Setting I2S clock source as external X'tal */
N#define CLK_CLKSEL2_I2S_S_PLL           (0x1UL<<CLK_CLKSEL2_I2S_S_Pos)    /*!< Setting I2S clock source as PLL */
N#define CLK_CLKSEL2_I2S_S_HCLK          (0x2UL<<CLK_CLKSEL2_I2S_S_Pos)    /*!< Setting I2S clock source as HCLK */
N#define CLK_CLKSEL2_I2S_S_HIRC          (0x3UL<<CLK_CLKSEL2_I2S_S_Pos)    /*!< Setting I2S clock source as internal 22.1184MHz RC clock */
N
N#define CLK_CLKSEL2_FRQDIV_S_HXT        (0x0UL<<CLK_CLKSEL2_FRQDIV_S_Pos) /*!< Setting FRQDIV clock source as external X'tal */
N#define CLK_CLKSEL2_FRQDIV_S_LXT        (0x1UL<<CLK_CLKSEL2_FRQDIV_S_Pos) /*!< Setting FRQDIV clock source as external X'tal 32.768KHz */
N#define CLK_CLKSEL2_FRQDIV_S_HCLK       (0x2UL<<CLK_CLKSEL2_FRQDIV_S_Pos) /*!< Setting FRQDIV clock source as HCLK */
N#define CLK_CLKSEL2_FRQDIV_S_HIRC       (0x3UL<<CLK_CLKSEL2_FRQDIV_S_Pos) /*!< Setting FRQDIV clock source as internal 22.1184MHz RC clock */
N
N#define CLK_CLKSEL2_PWM45_S_HXT         (0x0UL<<CLK_CLKSEL2_PWM45_S_Pos)  /*!< Setting PWM45 clock source as external X'tal,
N                                                                               user must set CLK_CLKSEL2_PWM45_EXT_HXT concurrently to complete clock source as external X'tal setting*/
N#define CLK_CLKSEL2_PWM45_S_LXT         (0x1UL<<CLK_CLKSEL2_PWM45_S_Pos)  /*!< Setting PWM45 clock source as external X'tal 32.768KHz,
N                                                                               user must set CLK_CLKSEL2_PWM45_EXT_LXT concurrently to complete clock source as external X'tal 32.768KHz setting*/
N#define CLK_CLKSEL2_PWM45_S_HCLK        (0x2UL<<CLK_CLKSEL2_PWM45_S_Pos)  /*!< Setting PWM45 clock source as HCLK,
N                                                                               user must set CLK_CLKSEL2_PWM45_EXT_HCLK concurrently to complete clock source as HCLK setting*/
N#define CLK_CLKSEL2_PWM45_S_HIRC        (0x3UL<<CLK_CLKSEL2_PWM45_S_Pos)  /*!< Setting PWM45 clock source as internal 22.1184MHz RC clock,
N                                                                               user must set CLK_CLKSEL2_PWM45_EXT_HIRC concurrently to complete clock source as internal 22.1184MHz RC clock setting*/
N#define CLK_CLKSEL2_PWM45_S_LIRC        (0x3UL<<CLK_CLKSEL2_PWM45_S_Pos)  /*!< Setting PWM45 clock source as internal 10KHz RC clock,
N                                                                               user must set CLK_CLKSEL2_PWM45_EXT_LIRC concurrently to complete clock source as internal 10KHz RC clock setting*/
N#define CLK_CLKSEL2_PWM67_S_HXT         (0x0UL<<CLK_CLKSEL2_PWM67_S_Pos)  /*!< Setting PWM67 clock source as external X'tal,
N                                                                               user must set CLK_CLKSEL2_PWM67_EXT_HXT concurrently to complete clock source as external X'tal setting*/
N#define CLK_CLKSEL2_PWM67_S_LXT         (0x1UL<<CLK_CLKSEL2_PWM67_S_Pos)  /*!< Setting PWM67 clock source as external X'tal 32.768KHz,
N                                                                               user must set CLK_CLKSEL2_PWM67_EXT_LXT concurrently to complete clock source as external X'tal 32.768KHz setting*/
N#define CLK_CLKSEL2_PWM67_S_HCLK        (0x2UL<<CLK_CLKSEL2_PWM67_S_Pos)  /*!< Setting PWM67 clock source as HCLK,
N                                                                               user must set CLK_CLKSEL2_PWM67_EXT_HCLK concurrently to complete clock source as HCLK setting*/
N#define CLK_CLKSEL2_PWM67_S_HIRC        (0x3UL<<CLK_CLKSEL2_PWM67_S_Pos)  /*!< Setting PWM67 clock source as internal 22.1184MHz RC clock,
N                                                                               user must set CLK_CLKSEL2_PWM67_EXT_HIRC concurrently to complete clock source as internal 22.1184MHz RC clock setting*/
N#define CLK_CLKSEL2_PWM67_S_LIRC        (0x3UL<<CLK_CLKSEL2_PWM67_S_Pos)  /*!< Setting PWM67 clock source as internal 10KHz RC clock,
N                                                                               user must set CLK_CLKSEL2_PWM67_EXT_LIRC concurrently to complete clock source as internal 10KHz RC clock setting*/
N
N#define CLK_CLKSEL2_PWM01_EXT_HXT       (0x0UL<<CLK_CLKSEL2_PWM01_S_E_Pos)/*!< Setting PWM01 clock source as external X'tal,
N                                                                               user must set CLK_CLKSEL1_PWM01_HXT concurrently to complete clock source as external X'tal setting*/
N#define CLK_CLKSEL2_PWM01_EXT_LXT       (0x0UL<<CLK_CLKSEL2_PWM01_S_E_Pos)/*!< Setting PWM01 clock source as external X'tal  32.768KHz,
N                                                                               user must set CLK_CLKSEL1_PWM01_LXT concurrently to complete clock source as external X'tal 32.768KHz setting*/
N#define CLK_CLKSEL2_PWM01_EXT_HCLK      (0x0UL<<CLK_CLKSEL2_PWM01_S_E_Pos)/*!< Setting PWM01 clock source as HCLK,
N                                                                               user must set CLK_CLKSEL1_PWM01_HCLK concurrently to complete clock source as HCLK setting*/
N#define CLK_CLKSEL2_PWM01_EXT_HIRC      (0x0UL<<CLK_CLKSEL2_PWM01_S_E_Pos)/*!< Setting PWM01 clock source as internal 22.1184MHz RC clock,
N                                                                               user must set CLK_CLKSEL1_PWM01_HIRC concurrently to complete clock source as internal 22.1184MHz RC clock setting*/
N#define CLK_CLKSEL2_PWM01_EXT_LIRC      (0x1UL<<CLK_CLKSEL2_PWM01_S_E_Pos)/*!< Setting PWM01 clock source as internal 10KHz RC clock,
N                                                                               user must set CLK_CLKSEL1_PWM01_LIRC concurrently to complete clock source as internal 10KHz RC clock setting*/
N
N#define CLK_CLKSEL2_PWM23_EXT_HXT       (0x0UL<<CLK_CLKSEL2_PWM23_S_E_Pos)/*!< Setting PWM23 clock source as external X'tal,
N                                                                               user must set CLK_CLKSEL1_PWM23_HXT concurrently to complete clock source as external X'tal setting*/
N#define CLK_CLKSEL2_PWM23_EXT_LXT       (0x0UL<<CLK_CLKSEL2_PWM23_S_E_Pos)/*!< Setting PWM23 clock source as external X'tal  32.768KHz,
N                                                                               user must set CLK_CLKSEL1_PWM23_LXT concurrently to complete clock source as external X'tal 32.768KHz setting*/
N#define CLK_CLKSEL2_PWM23_EXT_HCLK      (0x0UL<<CLK_CLKSEL2_PWM23_S_E_Pos)/*!< Setting PWM23 clock source as HCLK,
N                                                                               user must set CLK_CLKSEL1_PWM23_HCLK concurrently to complete clock source as HCLK setting*/
N#define CLK_CLKSEL2_PWM23_EXT_HIRC      (0x0UL<<CLK_CLKSEL2_PWM23_S_E_Pos)/*!< Setting PWM23 clock source as internal 22.1184MHz RC clock,
N                                                                               user must set CLK_CLKSEL1_PWM23_HIRC concurrently to complete clock source as internal 22.1184MHz RC clock setting*/
N#define CLK_CLKSEL2_PWM23_EXT_LIRC      (0x1UL<<CLK_CLKSEL2_PWM23_S_E_Pos)/*!< Setting PWM23 clock source as internal 10KHz RC clock,
N                                                                               user must set CLK_CLKSEL1_PWM23_LIRC concurrently to complete clock source as internal 10KHz RC clock setting*/
N
N#define CLK_CLKSEL2_PWM45_EXT_HXT       (0x0UL<<CLK_CLKSEL2_PWM45_S_E_Pos)/*!< Setting PWM45 clock source as external X'tal,
N                                                                               user must set CLK_CLKSEL1_PWM45_HXT concurrently to complete clock source as external X'tal setting*/
N#define CLK_CLKSEL2_PWM45_EXT_LXT       (0x0UL<<CLK_CLKSEL2_PWM45_S_E_Pos)/*!< Setting PWM45 clock source as external X'tal  32.768KHz,
N                                                                               user must set CLK_CLKSEL1_PWM45_LXT concurrently to complete clock source as external X'tal 32.768KHz setting*/
N#define CLK_CLKSEL2_PWM45_EXT_HCLK      (0x0UL<<CLK_CLKSEL2_PWM45_S_E_Pos)/*!< Setting PWM45 clock source as HCLK,
N                                                                               user must set CLK_CLKSEL1_PWM45_HCLK concurrently to complete clock source as HCLK setting*/
N#define CLK_CLKSEL2_PWM45_EXT_HIRC      (0x0UL<<CLK_CLKSEL2_PWM45_S_E_Pos)/*!< Setting PWM45 clock source as internal 22.1184MHz RC clock,
N                                                                               user must set CLK_CLKSEL1_PWM45_HIRC concurrently to complete clock source as internal 22.1184MHz RC clock setting*/
N#define CLK_CLKSEL2_PWM45_EXT_LIRC      (0x1UL<<CLK_CLKSEL2_PWM45_S_E_Pos)/*!< Setting PWM45 clock source as internal 10KHz RC clock,
N                                                                               user must set CLK_CLKSEL1_PWM45_LIRC concurrently to complete clock source as internal 10KHz RC clock setting*/
N
N#define CLK_CLKSEL2_PWM67_EXT_HXT       (0x0UL<<CLK_CLKSEL2_PWM67_S_E_Pos)/*!< Setting PWM67 clock source as external X'tal,
N                                                                               user must set CLK_CLKSEL1_PWM67_HXT concurrently to complete clock source as external X'tal setting*/
N#define CLK_CLKSEL2_PWM67_EXT_LXT       (0x0UL<<CLK_CLKSEL2_PWM67_S_E_Pos)/*!< Setting PWM67 clock source as external X'tal  32.768KHz,
N                                                                               user must set CLK_CLKSEL1_PWM67_LXT concurrently to complete clock source as external X'tal 32.768KHz setting*/
N#define CLK_CLKSEL2_PWM67_EXT_HCLK      (0x0UL<<CLK_CLKSEL2_PWM67_S_E_Pos)/*!< Setting PWM67 clock source as HCLK,
N                                                                               user must set CLK_CLKSEL1_PWM67_HCLK concurrently to complete clock source as HCLK setting*/
N#define CLK_CLKSEL2_PWM67_EXT_HIRC      (0x0UL<<CLK_CLKSEL2_PWM67_S_E_Pos)/*!< Setting PWM67 clock source as internal 22.1184MHz RC clock,
N                                                                               user must set CLK_CLKSEL1_PWM67_HIRC concurrently to complete clock source as internal 22.1184MHz RC clock setting*/
N#define CLK_CLKSEL2_PWM67_EXT_LIRC      (0x1UL<<CLK_CLKSEL2_PWM67_S_E_Pos)/*!< Setting PWM67 clock source as internal 10KHz RC clock,
N                                                                               user must set CLK_CLKSEL1_PWM67_LIRC concurrently to complete clock source as internal 10KHz RC clock setting*/
N
N#define CLK_CLKSEL2_WWDT_S_HCLK_DIV2048 (0x2UL<<CLK_CLKSEL2_WWDT_S_Pos)   /*!< Setting WWDT clock source as HCLK/2048 */
N#define CLK_CLKSEL2_WWDT_S_LIRC         (0x3UL<<CLK_CLKSEL2_WWDT_S_Pos)   /*!< Setting WWDT clock source as internal 10KHz RC clock */
N
N#define CLK_CLKSEL2_RTC_SEL_10K_LXT     (0x0UL<<CLK_CLKSEL2_RTC_SEL_10K_Pos)   /*!< Setting WWDT clock source as external X'tal 32.768KHz */
N#define CLK_CLKSEL2_RTC_SEL_10K_LIRC    (0x1UL<<CLK_CLKSEL2_RTC_SEL_10K_Pos)   /*!< Setting WWDT clock source as internal 10KHz RC clock */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKSEL3 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKSEL3_SC0_S_HXT           (0x0UL<<CLK_CLKSEL3_SC0_S_Pos)    /*!< Setting SC0 clock source as external X'tal */
N#define CLK_CLKSEL3_SC0_S_PLL           (0x1UL<<CLK_CLKSEL3_SC0_S_Pos)    /*!< Setting SC0 clock source as PLL */
N#define CLK_CLKSEL3_SC0_S_HCLK          (0x2UL<<CLK_CLKSEL3_SC0_S_Pos)    /*!< Setting SC0 clock source as HCLK */
N#define CLK_CLKSEL3_SC0_S_HIRC          (0x3UL<<CLK_CLKSEL3_SC0_S_Pos)    /*!< Setting SC0 clock source as internal 22.1184MHz RC clock */
N#define CLK_CLKSEL3_SC1_S_HXT           (0x0UL<<CLK_CLKSEL3_SC1_S_Pos)    /*!< Setting SC1 clock source as external X'tal */
N#define CLK_CLKSEL3_SC1_S_PLL           (0x1UL<<CLK_CLKSEL3_SC1_S_Pos)    /*!< Setting SC1 clock source as PLL */
N#define CLK_CLKSEL3_SC1_S_HCLK          (0x2UL<<CLK_CLKSEL3_SC1_S_Pos)    /*!< Setting SC1 clock source as HCLK */
N#define CLK_CLKSEL3_SC1_S_HIRC          (0x3UL<<CLK_CLKSEL3_SC1_S_Pos)    /*!< Setting SC1 clock source as internal 22.1184MHz RC clock */
N#define CLK_CLKSEL3_SC2_S_HXT           (0x0UL<<CLK_CLKSEL3_SC2_S_Pos)    /*!< Setting SC2 clock source as external X'tal */
N#define CLK_CLKSEL3_SC2_S_PLL           (0x1UL<<CLK_CLKSEL3_SC2_S_Pos)    /*!< Setting SC2 clock source as PLL */
N#define CLK_CLKSEL3_SC2_S_HCLK          (0x2UL<<CLK_CLKSEL3_SC2_S_Pos)    /*!< Setting SC2 clock source as HCLK */
N#define CLK_CLKSEL3_SC2_S_HIRC          (0x3UL<<CLK_CLKSEL3_SC2_S_Pos)    /*!< Setting SC2 clock source as internal 22.1184MHz RC clock */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKDIV constant definitions.                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKDIV_HCLK(x)  ((x)-1)                             /*!< CLKDIV Setting for HCLK clock divider. It could be 1~16 */
N#define CLK_CLKDIV_USB(x)  (((x)-1) << CLK_CLKDIV_USB_N_Pos)    /*!< CLKDIV Setting for USB clock divider. It could be 1~16  */
N#define CLK_CLKDIV_UART(x) (((x)-1) << CLK_CLKDIV_UART_N_Pos)   /*!< CLKDIV Setting for UART clock divider. It could be 1~16 */
N#define CLK_CLKDIV_ADC(x)  (((x)-1) << CLK_CLKDIV_ADC_N_Pos)    /*!< CLKDIV Setting for ADC clock divider. It could be 1~256 */
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  CLKDIV1 constant definitions.                                                                          */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_CLKDIV1_SC0(x)  (((x)-1) << CLK_CLKDIV1_SC0_N_Pos)  /*!< CLKDIV1 Setting for SC0 clock divider. It could be 1~256*/
N#define CLK_CLKDIV1_SC1(x)  (((x)-1) << CLK_CLKDIV1_SC1_N_Pos)  /*!< CLKDIV1 Setting for SC1 clock divider. It could be 1~256*/
N#define CLK_CLKDIV1_SC2(x)  (((x)-1) << CLK_CLKDIV1_SC2_N_Pos)  /*!< CLKDIV1 Setting for SC2 clock divider. It could be 1~256*/
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  PLLCON constant definitions. PLL = FIN * NF / NR / NO                                                  */
N/*---------------------------------------------------------------------------------------------------------*/
N#define CLK_PLLCON_PLL_SRC_HXT   0x00000000UL    /*!< For PLL clock source is HXT. 4MHz < FIN < 24MHz */
N#define CLK_PLLCON_PLL_SRC_HIRC  0x00080000UL    /*!< For PLL clock source is HIRC.4MHz < FIN < 24MHz */
N
N#define CLK_PLLCON_NR(x)         (((x)-2)<<9)    /*!< x must be constant and 2 <= x <= 33.  1.6MHz < FIN/NR < 15MHz */
N#define CLK_PLLCON_NF(x)          ((x)-2)        /*!< x must be constant and 2 <= x <= 513. 100MHz < FIN*NF/NR < 200MHz. (120MHz < FIN*NF/NR < 200MHz is preferred.) */
N
N#define CLK_PLLCON_NO_1          0x0000UL        /*!< For output divider is 1 */
N#define CLK_PLLCON_NO_2          0x4000UL        /*!< For output divider is 2 */
N#define CLK_PLLCON_NO_4          0xC000UL        /*!< For output divider is 4 */
N
N#if (__HXT == 12000000)
X#if ((12000000UL) == 12000000)
N#define CLK_PLLCON_FOR_I2S     (0xA54)                                                                            /*!< Predefined PLLCON setting for 147428571.428571Hz PLL output with 12MHz X'tal */
N#define CLK_PLLCON_72MHz_HXT   (CLK_PLLCON_PLL_SRC_HXT | CLK_PLLCON_NR(2) | CLK_PLLCON_NF( 24) | CLK_PLLCON_NO_2) /*!< Predefined PLLCON setting for 72MHz PLL output with 12MHz X'tal */
N#define CLK_PLLCON_50MHz_HXT   (CLK_PLLCON_PLL_SRC_HXT | CLK_PLLCON_NR(3) | CLK_PLLCON_NF( 25) | CLK_PLLCON_NO_2) /*!< Predefined PLLCON setting for 50MHz PLL output with 12MHz X'tal */
N#define CLK_PLLCON_48MHz_HXT   (CLK_PLLCON_PLL_SRC_HXT | CLK_PLLCON_NR(7) | CLK_PLLCON_NF(112) | CLK_PLLCON_NO_4) /*!< Predefined PLLCON setting for 48MHz PLL output with 12MHz X'tal */
N#define CLK_PLLCON_36MHz_HXT   (CLK_PLLCON_PLL_SRC_HXT | CLK_PLLCON_NR(7) | CLK_PLLCON_NF( 84) | CLK_PLLCON_NO_4) /*!< Predefined PLLCON setting for 36MHz PLL output with 12MHz X'tal */
N#define CLK_PLLCON_32MHz_HXT   (CLK_PLLCON_PLL_SRC_HXT | CLK_PLLCON_NR(6) | CLK_PLLCON_NF( 64) | CLK_PLLCON_NO_4) /*!< Predefined PLLCON setting for 32MHz PLL output with 12MHz X'tal */
N#define CLK_PLLCON_25MHz_HXT   (CLK_PLLCON_PLL_SRC_HXT | CLK_PLLCON_NR(3) | CLK_PLLCON_NF( 25) | CLK_PLLCON_NO_4) /*!< Predefined PLLCON setting for 25MHz PLL output with 12MHz X'tal */
N#else
S# error "The PLL pre-definitions are only valid when external crystal is 12MHz"
N#endif
N
N#define CLK_PLLCON_72MHz_HIRC (CLK_PLLCON_PLL_SRC_HIRC | CLK_PLLCON_NR( 4) | CLK_PLLCON_NF( 26) | CLK_PLLCON_NO_2) /*!< Predefined PLLCON setting for 71.88488MHz PLL output with 22.1184MHz IRC */
N#define CLK_PLLCON_50MHz_HIRC (CLK_PLLCON_PLL_SRC_HIRC | CLK_PLLCON_NR(13) | CLK_PLLCON_NF( 59) | CLK_PLLCON_NO_2) /*!< Predefined PLLCON setting for 50.1918MHz PLL output with 22.1184MHz IRC */
N#define CLK_PLLCON_48MHz_HIRC (CLK_PLLCON_PLL_SRC_HIRC | CLK_PLLCON_NR(13) | CLK_PLLCON_NF(113) | CLK_PLLCON_NO_4) /*!< Predefined PLLCON setting for 48.064985MHz PLL output with 22.1184MHz IRC*/
N#define CLK_PLLCON_36MHz_HIRC (CLK_PLLCON_PLL_SRC_HIRC | CLK_PLLCON_NR(12) | CLK_PLLCON_NF( 78) | CLK_PLLCON_NO_4) /*!< Predefined PLLCON setting for 35.9424MHz PLL output with 22.1184MHz IRC */
N#define CLK_PLLCON_32MHz_HIRC (CLK_PLLCON_PLL_SRC_HIRC | CLK_PLLCON_NR( 9) | CLK_PLLCON_NF( 52) | CLK_PLLCON_NO_4) /*!< Predefined PLLCON setting for 31.9488MHz PLL output with 22.1184MHz IRC*/
N#define CLK_PLLCON_25MHz_HIRC (CLK_PLLCON_PLL_SRC_HIRC | CLK_PLLCON_NR(13) | CLK_PLLCON_NF( 59) | CLK_PLLCON_NO_4) /*!< Predefined PLLCON setting for 25.0959MHz PLL output with 22.1184MHz IRC*/
N
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  MODULE constant definitions.                                                                           */
N/*---------------------------------------------------------------------------------------------------------*/
N
N/* APBCLK(31:30)|CLKSEL(29:28)|CLKSEL_Msk(27:25) |CLKSEL_Pos(24:20)|CLKDIV(19:18)|CLKDIV_Msk(17:10)|CLKDIV_Pos(9:5)|IP_EN_Pos(4:0) */
N
N#define MODULE_APBCLK(x)        (((x) >>30) & 0x3)    /*!< Calculate APBCLK offset on MODULE index, 0x0:AHBCLK, 0x1:APBCLK, 0x2:APBCLK1 */
N#define MODULE_CLKSEL(x)        (((x) >>28) & 0x3)    /*!< Calculate CLKSEL offset on MODULE index, 0x0:CLKSEL0, 0x1:CLKSEL1, 0x2:CLKSEL2, 0x3:CLKSEL3 */
N#define MODULE_CLKSEL_Msk(x)    (((x) >>25) & 0x7)    /*!< Calculate CLKSEL mask offset on MODULE index */
N#define MODULE_CLKSEL_Pos(x)    (((x) >>20) & 0x1f)   /*!< Calculate CLKSEL position offset on MODULE index */
N#define MODULE_CLKDIV(x)        (((x) >>18) & 0x3)    /*!< Calculate APBCLK CLKDIV on MODULE index, 0x0:CLKDIV, 0x1:CLKDIV1 */
N#define MODULE_CLKDIV_Msk(x)    (((x) >>10) & 0xff)   /*!< Calculate CLKDIV mask offset on MODULE index */
N#define MODULE_CLKDIV_Pos(x)    (((x) >>5 ) & 0x1f)   /*!< Calculate CLKDIV position offset on MODULE index */
N#define MODULE_IP_EN_Pos(x)     (((x) >>0 ) & 0x1f)   /*!< Calculate APBCLK offset on MODULE index */
N#define MODULE_NoMsk            0x0                   /*!< Not mask on MODULE index */
N#define NA                      MODULE_NoMsk          /*!< Not Available */
N
N#define MODULE_APBCLK_ENC(x)        (((x) & 0x03) << 30)   /*!< MODULE index, 0x0:AHBCLK, 0x1:APBCLK, 0x2:APBCLK1 */
N#define MODULE_CLKSEL_ENC(x)        (((x) & 0x03) << 28)   /*!< CLKSEL offset on MODULE index, 0x0:CLKSEL0, 0x1:CLKSEL1, 0x2:CLKSEL2, 0x3:CLKSEL3 */
N#define MODULE_CLKSEL_Msk_ENC(x)    (((x) & 0x07) << 25)   /*!< CLKSEL mask offset on MODULE index */
N#define MODULE_CLKSEL_Pos_ENC(x)    (((x) & 0x1f) << 20)   /*!< CLKSEL position offset on MODULE index */
N#define MODULE_CLKDIV_ENC(x)        (((x) & 0x03) << 18)   /*!< APBCLK CLKDIV on MODULE index, 0x0:CLKDIV, 0x1:CLKDIV1 */
N#define MODULE_CLKDIV_Msk_ENC(x)    (((x) & 0xff) << 10)   /*!< CLKDIV mask offset on MODULE index */
N#define MODULE_CLKDIV_Pos_ENC(x)    (((x) & 0x1f) <<  5)   /*!< CLKDIV position offset on MODULE index */
N#define MODULE_IP_EN_Pos_ENC(x)     (((x) & 0x1f) <<  0)   /*!< APBCLK offset on MODULE index */
N
N
N#define EBI_MODULE     (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_EBI_EN_Pos)  |\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< EBI Module */
X#define EBI_MODULE     (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_EBI_EN_Pos)  |                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define PDMA_MODULE    (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_PDMA_EN_Pos)  |\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< PDMA Module */
X#define PDMA_MODULE    (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_PDMA_EN_Pos)  |                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define ISP_MODULE     (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_ISP_EN_Pos)  |\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< ISP Module */
X#define ISP_MODULE     (MODULE_APBCLK_ENC( 0)|MODULE_IP_EN_Pos_ENC(CLK_AHBCLK_ISP_EN_Pos)  |                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define WDT_MODULE     (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_WDT_EN_Pos)  |\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 0)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< WDT Module */
X#define WDT_MODULE     (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_WDT_EN_Pos)  |                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 0)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define TMR0_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_TMR0_EN_Pos) |\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 7)|MODULE_CLKSEL_Pos_ENC( 8)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< TMR0 Module */
X#define TMR0_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_TMR0_EN_Pos) |                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 7)|MODULE_CLKSEL_Pos_ENC( 8)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define TMR1_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_TMR1_EN_Pos) |\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 7)|MODULE_CLKSEL_Pos_ENC(12)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< TMR1 Module */
X#define TMR1_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_TMR1_EN_Pos) |                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 7)|MODULE_CLKSEL_Pos_ENC(12)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define TMR2_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_TMR2_EN_Pos) |\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 7)|MODULE_CLKSEL_Pos_ENC(16)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< TMR2 Module */
X#define TMR2_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_TMR2_EN_Pos) |                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 7)|MODULE_CLKSEL_Pos_ENC(16)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define TMR3_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_TMR3_EN_Pos) |\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 7)|MODULE_CLKSEL_Pos_ENC(20)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< TMR3 Module */
X#define TMR3_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_TMR3_EN_Pos) |                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 7)|MODULE_CLKSEL_Pos_ENC(20)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define FDIV_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_FDIV_EN_Pos) |\
N                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 2)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< FDIV Module */
X#define FDIV_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_FDIV_EN_Pos) |                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 2)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define I2C0_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_I2C0_EN_Pos) |\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< I2C0 Module */
X#define I2C0_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_I2C0_EN_Pos) |                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define I2C1_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_I2C1_EN_Pos) |\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< I2C1 Module */
X#define I2C1_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_I2C1_EN_Pos) |                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define SPI0_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_SPI0_EN_Pos) |\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC( 4)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< SPI0 Module */
X#define SPI0_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_SPI0_EN_Pos) |                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC( 4)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define SPI1_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_SPI1_EN_Pos) |\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC( 5)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< SPI1 Module */
X#define SPI1_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_SPI1_EN_Pos) |                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC( 5)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define SPI2_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_SPI2_EN_Pos) |\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC( 6)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< SPI2 Module */
X#define SPI2_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_SPI2_EN_Pos) |                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC( 6)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define SPI3_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_SPI3_EN_Pos) |\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC( 7)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< SPI3 Module */
X#define SPI3_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_SPI3_EN_Pos) |                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC( 7)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define UART0_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_UART0_EN_Pos)|\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(24)|\
N                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC( 8))    /*!< UART0 Module */
X#define UART0_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_UART0_EN_Pos)|                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(24)|                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC( 8))     
N#define UART1_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_UART1_EN_Pos)|\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(24)|\
N                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC( 8))    /*!< UART1 Module */
X#define UART1_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_UART1_EN_Pos)|                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(24)|                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC( 8))     
N#define UART2_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_UART2_EN_Pos)|\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(24)|\
N                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC( 8))    /*!< UART2 Module */
X#define UART2_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_UART2_EN_Pos)|                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(24)|                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC( 8))     
N#define PWM01_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_PWM01_EN_Pos)|\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(28)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< PWM01 Module */
X#define PWM01_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_PWM01_EN_Pos)|                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(28)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define PWM23_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_PWM23_EN_Pos)|\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(30)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< PWM23 Module */
X#define PWM23_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_PWM23_EN_Pos)|                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(30)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define PWM45_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_PWM45_EN_Pos)|\
N                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 4)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< PWM45 Module */
X#define PWM45_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_PWM45_EN_Pos)|                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 4)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define PWM67_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_PWM67_EN_Pos)|\
N                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 6)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< PWM67 Module */
X#define PWM67_MODULE   (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_PWM67_EN_Pos)|                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 6)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define CAN0_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_CAN0_EN_Pos) |\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< CAN0 Module */
X#define CAN0_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_CAN0_EN_Pos) |                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define CAN1_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_CAN1_EN_Pos) |\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< CAN1 Module */
X#define CAN1_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_CAN1_EN_Pos) |                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define USBD_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_USBD_EN_Pos) |\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC(4))    /*!< USBD Module */
X#define USBD_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_USBD_EN_Pos) |                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0x0F)|MODULE_CLKDIV_Pos_ENC(4))     
N#define ADC_MODULE     (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_ADC_EN_Pos)  |\
N                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 2)|\
N                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0xFF)|MODULE_CLKDIV_Pos_ENC(16))    /*!< ADC Module */
X#define ADC_MODULE     (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_ADC_EN_Pos)  |                        MODULE_CLKSEL_ENC( 1)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 2)|                        MODULE_CLKDIV_ENC( 0)|MODULE_CLKDIV_Msk_ENC(0xFF)|MODULE_CLKDIV_Pos_ENC(16))     
N#define I2S_MODULE     (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_I2S_EN_Pos)  |\
N                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 0)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< I2S Module */
X#define I2S_MODULE     (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_I2S_EN_Pos)  |                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 0)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define ACMP_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_ACMP_EN_Pos) |\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< ACMP Module */
X#define ACMP_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_ACMP_EN_Pos) |                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define PS2_MODULE     (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_PS2_EN_Pos)  |\
N                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< PS2 Module */
X#define PS2_MODULE     (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_PS2_EN_Pos)  |                        MODULE_CLKSEL_ENC(NA)|MODULE_CLKSEL_Msk_ENC(NA)|MODULE_CLKSEL_Pos_ENC(NA)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define SC0_MODULE     (MODULE_APBCLK_ENC( 2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_SC0_EN_Pos)  |\
N                        MODULE_CLKSEL_ENC( 3)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 0)|\
N                        MODULE_CLKDIV_ENC( 1)|MODULE_CLKDIV_Msk_ENC(0xFF)|MODULE_CLKDIV_Pos_ENC( 0))    /*!< SC0 Module */
X#define SC0_MODULE     (MODULE_APBCLK_ENC( 2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_SC0_EN_Pos)  |                        MODULE_CLKSEL_ENC( 3)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 0)|                        MODULE_CLKDIV_ENC( 1)|MODULE_CLKDIV_Msk_ENC(0xFF)|MODULE_CLKDIV_Pos_ENC( 0))     
N#define SC1_MODULE     (MODULE_APBCLK_ENC( 2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_SC1_EN_Pos)  |\
N                        MODULE_CLKSEL_ENC( 3)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 2)|\
N                        MODULE_CLKDIV_ENC( 1)|MODULE_CLKDIV_Msk_ENC(0xFF)|MODULE_CLKDIV_Pos_ENC( 8))    /*!< SC1 Module */
X#define SC1_MODULE     (MODULE_APBCLK_ENC( 2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_SC1_EN_Pos)  |                        MODULE_CLKSEL_ENC( 3)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 2)|                        MODULE_CLKDIV_ENC( 1)|MODULE_CLKDIV_Msk_ENC(0xFF)|MODULE_CLKDIV_Pos_ENC( 8))     
N#define SC2_MODULE     (MODULE_APBCLK_ENC( 2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_SC2_EN_Pos)  |\
N                        MODULE_CLKSEL_ENC( 3)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 4)|\
N                        MODULE_CLKDIV_ENC( 1)|MODULE_CLKDIV_Msk_ENC(0xFF)|MODULE_CLKDIV_Pos_ENC(16))    /*!< SC2 Module */
X#define SC2_MODULE     (MODULE_APBCLK_ENC( 2UL)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK1_SC2_EN_Pos)  |                        MODULE_CLKSEL_ENC( 3)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC( 4)|                        MODULE_CLKDIV_ENC( 1)|MODULE_CLKDIV_Msk_ENC(0xFF)|MODULE_CLKDIV_Pos_ENC(16))     
N#define RTC_MODULE     (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_RTC_EN_Pos)  |\
N                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC(18)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< RTC Module */
X#define RTC_MODULE     (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_RTC_EN_Pos)  |                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 1)|MODULE_CLKSEL_Pos_ENC(18)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N#define WWDT_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_WDT_EN_Pos) |\
N                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(16)|\
N                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))      /*!< WWDT Module */
X#define WWDT_MODULE    (MODULE_APBCLK_ENC( 1)|MODULE_IP_EN_Pos_ENC(CLK_APBCLK_WDT_EN_Pos) |                        MODULE_CLKSEL_ENC( 2)|MODULE_CLKSEL_Msk_ENC( 3)|MODULE_CLKSEL_Pos_ENC(16)|                        MODULE_CLKDIV_ENC(NA)|MODULE_CLKDIV_Msk_ENC(NA)|MODULE_CLKDIV_Pos_ENC(NA))       
N
N
N#define CLK_CLKSEL_PWM01_HXT  (CLK_CLKSEL1_PWM01_S_HXT |CLK_CLKSEL2_PWM01_EXT_HXT)  /*!< HXT Clock selection setting for PWM01 */
N#define CLK_CLKSEL_PWM01_LXT  (CLK_CLKSEL1_PWM01_S_LXT |CLK_CLKSEL2_PWM01_EXT_LXT)  /*!< LXT Clock selection setting for PWM01 */
N#define CLK_CLKSEL_PWM01_HCLK (CLK_CLKSEL1_PWM01_S_HCLK|CLK_CLKSEL2_PWM01_EXT_HCLK) /*!< HCLK Clock selection setting for PWM01 */
N#define CLK_CLKSEL_PWM01_HIRC (CLK_CLKSEL1_PWM01_S_HIRC|CLK_CLKSEL2_PWM01_EXT_HIRC) /*!< HIRC Clock selection setting for PWM01 */
N#define CLK_CLKSEL_PWM01_LIRC (CLK_CLKSEL1_PWM01_S_LIRC|CLK_CLKSEL2_PWM01_EXT_LIRC) /*!< LIRC Clock selection setting for PWM01 */
N#define CLK_CLKSEL_PWM23_HXT  (CLK_CLKSEL1_PWM23_S_HXT |CLK_CLKSEL2_PWM23_EXT_HXT)  /*!< HXT Clock selection setting for PWM23 */
N#define CLK_CLKSEL_PWM23_LXT  (CLK_CLKSEL1_PWM23_S_LXT |CLK_CLKSEL2_PWM23_EXT_LXT)  /*!< LXT Clock selection setting for PWM23 */
N#define CLK_CLKSEL_PWM23_HCLK (CLK_CLKSEL1_PWM23_S_HCLK|CLK_CLKSEL2_PWM23_EXT_HCLK) /*!< HCLK Clock selection setting for PWM23 */
N#define CLK_CLKSEL_PWM23_HIRC (CLK_CLKSEL1_PWM23_S_HIRC|CLK_CLKSEL2_PWM23_EXT_HIRC) /*!< HIRC Clock selection setting for PWM23 */
N#define CLK_CLKSEL_PWM23_LIRC (CLK_CLKSEL1_PWM23_S_LIRC|CLK_CLKSEL2_PWM23_EXT_LIRC) /*!< LIRC Clock selection setting for PWM23 */
N#define CLK_CLKSEL_PWM45_HXT  (CLK_CLKSEL2_PWM45_S_HXT |CLK_CLKSEL2_PWM45_EXT_HXT)  /*!< HXT Clock selection setting for PWM45 */
N#define CLK_CLKSEL_PWM45_LXT  (CLK_CLKSEL2_PWM45_S_LXT |CLK_CLKSEL2_PWM45_EXT_LXT)  /*!< LXT Clock selection setting for PWM45 */
N#define CLK_CLKSEL_PWM45_HCLK (CLK_CLKSEL2_PWM45_S_HCLK|CLK_CLKSEL2_PWM45_EXT_HCLK) /*!< HCLK Clock selection setting for PWM45 */
N#define CLK_CLKSEL_PWM45_HIRC (CLK_CLKSEL2_PWM45_S_HIRC|CLK_CLKSEL2_PWM45_EXT_HIRC) /*!< HIRC Clock selection setting for PWM45 */
N#define CLK_CLKSEL_PWM45_LIRC (CLK_CLKSEL2_PWM45_S_LIRC|CLK_CLKSEL2_PWM45_EXT_LIRC) /*!< LIRC Clock selection setting for PWM45 */
N#define CLK_CLKSEL_PWM67_HXT  (CLK_CLKSEL2_PWM67_S_HXT |CLK_CLKSEL2_PWM67_EXT_HXT)  /*!< HXT Clock selection setting for PWM67 */
N#define CLK_CLKSEL_PWM67_LXT  (CLK_CLKSEL2_PWM67_S_LXT |CLK_CLKSEL2_PWM67_EXT_LXT)  /*!< LXT Clock selection setting for PWM67 */
N#define CLK_CLKSEL_PWM67_HCLK (CLK_CLKSEL2_PWM67_S_HCLK|CLK_CLKSEL2_PWM67_EXT_HCLK) /*!< HCLK Clock selection setting for PWM6 */
N#define CLK_CLKSEL_PWM67_HIRC (CLK_CLKSEL2_PWM67_S_HIRC|CLK_CLKSEL2_PWM67_EXT_HIRC) /*!< HIRC Clock selection setting for PWM6 */
N#define CLK_CLKSEL_PWM67_LIRC (CLK_CLKSEL2_PWM67_S_LIRC|CLK_CLKSEL2_PWM67_EXT_LIRC) /*!< LIRC Clock selection setting for PWM6 */
N
N
N/*@}*/ /* end of group CLK_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup CLK_EXPORTED_FUNCTIONS CLK Exported Functions
N  @{
N*/
N
N
N/**
N  * @brief      Get PLL clock frequency
N  * @param      None
N  * @return     PLL frequency
N  * @details    This function get PLL frequency. The frequency unit is Hz.
N  */
N__STATIC_INLINE uint32_t CLK_GetPLLClockFreq(void)
Xstatic __inline uint32_t CLK_GetPLLClockFreq(void)
N{
N    uint32_t u32PllFreq = 0, u32PllReg;
N    uint32_t u32FIN, u32NF, u32NR, u32NO;
N    uint8_t au8NoTbl[4] = {1, 2, 2, 4};
N
N    u32PllReg = CLK->PLLCON;
X    u32PllReg = ((CLK_T *) ((( uint32_t)0x50000000) + 0x00200))->PLLCON;
N
N    if(u32PllReg & (CLK_PLLCON_PD_Msk | CLK_PLLCON_OE_Msk))
X    if(u32PllReg & ((1ul << 16) | (1ul << 18)))
N        return 0;           /* PLL is in power down mode or fix low */
N
N    if(u32PllReg & CLK_PLLCON_PLL_SRC_HIRC)
X    if(u32PllReg & 0x00080000UL)
N        u32FIN = __HIRC;    /* PLL source clock from HIRC */
X        u32FIN = (22118400UL);     
N    else
N        u32FIN = __HXT;     /* PLL source clock from HXT */
X        u32FIN = (12000000UL);      
N
N    if(u32PllReg & CLK_PLLCON_BP_Msk)
X    if(u32PllReg & (1ul << 17))
N        return u32FIN;      /* PLL is in bypass mode */
N
N    /* PLL is output enabled in normal work mode */
N    u32NO = au8NoTbl[((u32PllReg & CLK_PLLCON_OUT_DV_Msk) >> CLK_PLLCON_OUT_DV_Pos)];
X    u32NO = au8NoTbl[((u32PllReg & (3ul << 14)) >> 14)];
N    u32NF = ((u32PllReg & CLK_PLLCON_FB_DV_Msk) >> CLK_PLLCON_FB_DV_Pos) + 2;
X    u32NF = ((u32PllReg & (0x1FFul << 0)) >> 0) + 2;
N    u32NR = ((u32PllReg & CLK_PLLCON_IN_DV_Msk) >> CLK_PLLCON_IN_DV_Pos) + 2;
X    u32NR = ((u32PllReg & (0x1Ful << 9)) >> 9) + 2;
N
N    /* u32FIN is shifted 2 bits to avoid overflow */
N    u32PllFreq = (((u32FIN >> 2) * u32NF) / (u32NR * u32NO) << 2);
N
N    return u32PllFreq;
N}
N
N/**
N  * @brief      This function execute delay function.
N  * @param[in]  us  Delay time. The Max value is 2^24 / CPU Clock(MHz). Ex:
N  *                             50MHz => 335544us, 48MHz => 349525us, 28MHz => 699050us ...
N  * @return     None
N  * @details    Use the SysTick to generate the delay time and the UNIT is in us.
N  *             The SysTick clock source is from HCLK, i.e the same as system core clock.
N  */
N__STATIC_INLINE void CLK_SysTickDelay(uint32_t us)
Xstatic __inline void CLK_SysTickDelay(uint32_t us)
N{
N    SysTick->LOAD = us * CyclesPerUs;
X    ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->LOAD = us * CyclesPerUs;
N    SysTick->VAL  = (0x00);
X    ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->VAL  = (0x00);
N    SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
X    ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = (1UL << 2) | (1UL << 0);
N
N    /* Waiting for down-count to zero */
N    while((SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk) == 0);
X    while((((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL & (1UL << 16)) == 0);
N
N    /* Disable SysTick counter */
N    SysTick->CTRL = 0;
X    ((SysTick_Type *) ((0xE000E000UL) + 0x0010UL) )->CTRL = 0;
N	
N	
N}
N
N
Nvoid CLK_DisableCKO(void);
Nvoid CLK_EnableCKO(uint32_t u32ClkSrc, uint32_t u32ClkDiv, uint32_t u32ClkDivBy1En);
Nvoid CLK_PowerDown(void);
Nvoid CLK_Idle(void);
Nuint32_t CLK_GetHXTFreq(void);
Nuint32_t CLK_GetLXTFreq(void);
Nuint32_t CLK_GetHCLKFreq(void);
Nuint32_t CLK_GetPCLKFreq(void);
Nuint32_t CLK_GetCPUFreq(void);
Nuint32_t CLK_SetCoreClock(uint32_t u32Hclk);
Nvoid CLK_SetHCLK(uint32_t u32ClkSrc, uint32_t u32ClkDiv);
Nvoid CLK_SetModuleClock(uint32_t u32ModuleIdx, uint32_t u32ClkSrc, uint32_t u32ClkDiv);
Nvoid CLK_SetSysTickClockSrc(uint32_t u32ClkSrc);
Nvoid CLK_EnableXtalRC(uint32_t u32ClkMask);
Nvoid CLK_DisableXtalRC(uint32_t u32ClkMask);
Nvoid CLK_EnableModuleClock(uint32_t u32ModuleIdx);
Nvoid CLK_DisableModuleClock(uint32_t u32ModuleIdx);
Nuint32_t CLK_EnablePLL(uint32_t u32PllClkSrc, uint32_t u32PllFreq);
Nvoid CLK_DisablePLL(void);
Nuint32_t CLK_WaitClockReady(uint32_t u32ClkMask);
Nvoid CLK_EnableSysTick(uint32_t u32ClkSrc, uint32_t u32Count);
Nvoid CLK_DisableSysTick(void);
N
N
N/*@}*/ /* end of group CLK_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group CLK_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N
N
N#endif //__CLK_H__
N
N
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 12463 ".\Libraries\Device\Nuvoton\NUC230_240\Include\NUC230_240.h" 2
N#include "ACMP.h"
L 1 ".\Libraries\StdDriver\inc\ACMP.h" 1
N/**************************************************************************//**
N * @file     acmp.h
N * @version  V3.00
N * $Revision: 2 $
N * $Date: 15/05/06 10:18a $
N * @brief    NUC230_240 series Analog Comparator (ACMP) driver header file
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N*****************************************************************************/
N#ifndef __ACMP_H__
N#define __ACMP_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup ACMP_Driver ACMP Driver
N  @{
N*/
N
N/** @addtogroup ACMP_EXPORTED_CONSTANTS ACMP Exported Constants
N  @{
N*/
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* CMPCR constant definitions                                                                            */
N/*---------------------------------------------------------------------------------------------------------*/
N#define ACMP_CR_OUTPUT_INV           (1UL << ACMP_CMPCR_CMPINV_Pos)     /*!< CMPCR setting for ACMP output inverse function. */
N#define ACMP_CR_VNEG_BANDGAP         (1UL << ACMP_CMPCR_CMPCN_Pos)      /*!< CMPCR setting for selecting band-gap voltage as the source of ACMP V-. */
N#define ACMP_CR_VNEG_PIN             (0UL << ACMP_CMPCR_CMPCN_Pos)      /*!< CMPCR setting for selecting the voltage of ACMP negative input pin as the source of ACMP V-. */
N#define ACMP_CR_HYSTERESIS_ENABLE    (1UL << ACMP_CMPCR_CMP_HYSEN_Pos)  /*!< CMPCR setting for enabling the hysteresis function. */
N#define ACMP_CR_HYSTERESIS_DISABLE   (0UL << ACMP_CMPCR_CMP_HYSEN_Pos)  /*!< CMPCR setting for disabling the hysteresis function. */
N#define ACMP_CR_INT_ENABLE           (1UL << ACMP_CMPCR_CMPIE_Pos)      /*!< CMPCR setting for enabling the interrupt function. */
N#define ACMP_CR_INT_DISABLE          (0UL << ACMP_CMPCR_CMPIE_Pos)      /*!< CMPCR setting for disabling the interrupt function. */
N#define ACMP_CR_ACMP_ENABLE          (1UL << ACMP_CMPCR_CMPEN_Pos)      /*!< CMPCR setting for enabling the ACMP analog circuit. */
N#define ACMP_CR_ACMP_DISABLE         (0UL << ACMP_CMPCR_CMPEN_Pos)      /*!< CMPCR setting for disabling the ACMP analog circuit. */
N
N/*@}*/ /* end of group ACMP_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup ACMP_EXPORTED_FUNCTIONS ACMP Exported Functions
N  @{
N*/
N
N/**
N  * @brief This macro is used to enable output inverse
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will set CMPINV bit of CMPCR register to enable output inverse function.
N  */
N#define ACMP_ENABLE_OUTPUT_INVERSE(acmp, u32ChNum) ((acmp)->CMPCR[(u32ChNum)%2] |= ACMP_CMPCR_CMPINV_Msk)
N
N/**
N  * @brief This macro is used to disable output inverse function
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will clear CMPINV bit of CMPCR register to disable output inverse function.
N  */
N#define ACMP_DISABLE_OUTPUT_INVERSE(acmp, u32ChNum) ((acmp)->CMPCR[(u32ChNum)%2] &= ~ACMP_CMPCR_CMPINV_Msk)
N
N/**
N  * @brief This macro is used to select ACMP negative input source
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @param[in] u32Src Comparator 0 negative input selection.  Including:
N  *                  - \ref ACMP_CR_VNEG_PIN
N  *                  - \ref ACMP_CR_VNEG_BANDGAP
N  * @return None
N  * @details This macro will set CMPCN bit of CMPCR register to determine the source of negative input.
N  */
N#define ACMP_SET_NEG_SRC(acmp, u32ChNum, u32Src) ((acmp)->CMPCR[(u32ChNum)%2] = ((acmp)->CMPCR[(u32ChNum)%2] & ~ACMP_CMPCR_CMPCN_Msk) | (u32Src))
N
N/**
N  * @brief This macro is used to enable hysteresis function
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will set HYSEN bit of CMPCR register to enable hysteresis function.
N  */
N#define ACMP_ENABLE_HYSTERESIS(acmp, u32ChNum) ((acmp)->CMPCR[(u32ChNum)%2] |= ACMP_CMPCR_CMP_HYSEN_Msk)
N
N/**
N  * @brief This macro is used to disable hysteresis function
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will clear HYSEN bit of CMPCR register to disable hysteresis function.
N  */
N#define ACMP_DISABLE_HYSTERESIS(acmp, u32ChNum) ((acmp)->CMPCR[(u32ChNum)%2] &= ~ACMP_CMPCR_CMP_HYSEN_Msk)
N
N/**
N  * @brief This macro is used to enable interrupt
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will set CMPIE bit of CMPCR register to enable interrupt function.
N  */
N#define ACMP_ENABLE_INT(acmp, u32ChNum) ((acmp)->CMPCR[(u32ChNum)%2] |= ACMP_CMPCR_CMPIE_Msk)
N
N/**
N  * @brief This macro is used to disable interrupt
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will clear CMPIE bit of CMPCR register to disable interrupt function.
N  */
N#define ACMP_DISABLE_INT(acmp, u32ChNum) ((acmp)->CMPCR[(u32ChNum)%2] &= ~ACMP_CMPCR_CMPIE_Msk)
N
N
N/**
N  * @brief This macro is used to enable ACMP
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will set CMPEN bit of CMPCR register to enable analog comparator.
N  */
N#define ACMP_ENABLE(acmp, u32ChNum) ((acmp)->CMPCR[(u32ChNum)%2] |= ACMP_CMPCR_CMPEN_Msk)
N
N/**
N  * @brief This macro is used to disable ACMP
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return None
N  * @details This macro will clear CMPEN bit of CMPCR register to disable analog comparator.
N  */
N#define ACMP_DISABLE(acmp, u32ChNum) ((acmp)->CMPCR[(u32ChNum)%2] &= ~ACMP_CMPCR_CMPEN_Msk)
N
N/**
N  * @brief This macro is used to get ACMP output value
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return  ACMP output value
N  * @details This macro will return the ACMP output value.
N  */
N#define ACMP_GET_OUTPUT(acmp, u32ChNum) (((acmp)->CMPSR & (ACMP_CMPSR_CO0_Msk<<(u32ChNum)))?1:0)
N
N/**
N  * @brief This macro is used to get ACMP interrupt flag
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return   ACMP interrupt occurred or not
N  * @details This macro will return the ACMP interrupt flag.
N  */
N#define ACMP_GET_INT_FLAG(acmp, u32ChNum) (((acmp)->CMPSR & (ACMP_CMPSR_CMPF0_Msk<<(u32ChNum)))?1:0)
N
N/**
N  * @brief This macro is used to clear ACMP interrupt flag
N  * @param[in] acmp The base address of ACMP module
N  * @param[in] u32ChNum The ACMP number
N  * @return   None
N  * @details This macro will write 1 to CMPFn bit of CMPSR register to clear interrupt flag.
N  */
N#define ACMP_CLR_INT_FLAG(acmp, u32ChNum) ((acmp)->CMPSR = (ACMP_CMPSR_CMPF0_Msk<<(u32ChNum)))
N
N
N/* Function prototype declaration */
Nvoid ACMP_Open(ACMP_T *, uint32_t u32ChNum, uint32_t u32NegSrc, uint32_t u32HysteresisEn);
Nvoid ACMP_Close(ACMP_T *, uint32_t u32ChNum);
N
N/*@}*/ /* end of group ACMP_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group ACMP_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__ACMP_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 12464 ".\Libraries\Device\Nuvoton\NUC230_240\Include\NUC230_240.h" 2
N#include "EBI.h"
L 1 ".\Libraries\StdDriver\inc\EBI.h" 1
N/**************************************************************************//**
N * @file     GPIO.h
N * @version  V3.00
N * $Revision: 2 $
N * $Date: 15/05/06 10:18a $
N * @brief    NUC230_240 Series EBI Driver Header File
N *
N * @note
N * Copyright (C) 2014 Nuvoton Technology Corp. All rights reserved.
N *
N ******************************************************************************/
N#ifndef __EBI_H__
N#define __EBI_H__
N
N#ifdef __cplusplus
Sextern "C"
S{
N#endif
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup EBI_Driver EBI Driver
N  @{
N*/
N
N/** @addtogroup EBI_EXPORTED_CONSTANTS EBI Exported Constants
N  @{
N*/
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Miscellaneous Constant Definitions                                                                     */
N/*---------------------------------------------------------------------------------------------------------*/
N#define EBI_BASE_ADDR           0x60000000UL /*!< EBI base address */
N#define EBI_MAX_SIZE            0x00020000UL /*!< Maximum EBI size */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Constants for EBI data bus width                                                                       */
N/*---------------------------------------------------------------------------------------------------------*/
N#define EBI_BUSWIDTH_8BIT       8     /*!< EBI bus width is 8-bit */
N#define EBI_BUSWIDTH_16BIT      16    /*!< EBI bus width is 16-bit */
N
N/*---------------------------------------------------------------------------------------------------------*/
N/*  Constants for EBI MCLK divider and Timing                                                              */
N/*---------------------------------------------------------------------------------------------------------*/
N#define EBI_MCLKDIV_1           0x0UL /*!< EBI output clock(MCLK) is HCLK/1 */
N#define EBI_MCLKDIV_2           0x1UL /*!< EBI output clock(MCLK) is HCLK/2 */
N#define EBI_MCLKDIV_4           0x2UL /*!< EBI output clock(MCLK) is HCLK/4 */
N#define EBI_MCLKDIV_8           0x3UL /*!< EBI output clock(MCLK) is HCLK/8 */
N#define EBI_MCLKDIV_16          0x4UL /*!< EBI output clock(MCLK) is HCLK/16 */
N#define EBI_MCLKDIV_32          0x5UL /*!< EBI output clock(MCLK) is HCLK/32 */
N
N#define EBI_TIMING_FASTEST      0x0UL /*!< EBI timing is the fastest */
N#define EBI_TIMING_VERYFAST     0x1UL /*!< EBI timing is very fast */
N#define EBI_TIMING_FAST         0x2UL /*!< EBI timing is fast */
N#define EBI_TIMING_NORMAL       0x3UL /*!< EBI timing is normal  */
N#define EBI_TIMING_SLOW         0x4UL /*!< EBI timing is slow */
N#define EBI_TIMING_VERYSLOW     0x5UL /*!< EBI timing is very slow */
N#define EBI_TIMING_SLOWEST      0x6UL /*!< EBI timing is the slowest */
N
N/*@}*/ /* end of group EBI_EXPORTED_CONSTANTS */
N
N
N/** @addtogroup EBI_EXPORTED_FUNCTIONS EBI Exported Functions
N  @{
N*/
N
N/**
N  * @brief      Read 8-bit data
N  *
N  * @param[in]  u32Addr     The data address on EBI bus.
N  *
N  * @return     8-bit Data
N  *
N  * @details    This macro read 8-bit data from specify EBI address.
N  */
N#define EBI_READ_DATA8(u32Addr)             (*((volatile unsigned char *)(EBI_BASE_ADDR+(u32Addr))))
N
N/**
N  * @brief      Write 8-bit data
N  *
N  * @param[in]  u32Addr     The data address on EBI bus.
N  * @param[in]  u32Data     Specify data to be written.
N  *
N  * @return     None
N  *
N  * @details    This macro write 8-bit data to specify EBI address.
N  */
N#define EBI_WRITE_DATA8(u32Addr, u32Data)   (*((volatile unsigned char *)(EBI_BASE_ADDR+(u32Addr))) = (u32Data))
N
N/**
N  * @brief      Read 16-bit data
N  *
N  * @param[in]  u32Addr     The data address on EBI bus.
N  *
N  * @return     16-bit Data
N  *
N  * @details    This macro read 16-bit data from specify EBI address.
N  */
N#define EBI_READ_DATA16(u32Addr)            (*((volatile unsigned short *)(EBI_BASE_ADDR+(u32Addr))))
N
N/**
N  * @brief      Write 16-bit data
N  *
N  * @param[in]  u32Addr     The data address on EBI bus.
N  * @param[in]  u32Data     Specify data to be written.
N  *
N  * @return     None
N  *
N  * @details    This macro write 16-bit data to specify EBI address.
N  */
N#define EBI_WRITE_DATA16(u32Addr, u32Data)  (*((volatile unsigned short *)(EBI_BASE_ADDR+(u32Addr))) = (u32Data))
N
N/**
N  * @brief      Read 32-bit data
N  *
N  * @param[in]  u32Addr     The data address on EBI bus.
N  *
N  * @return     32-bit Data
N  *
N  * @details    This macro read 32-bit data from specify EBI address.
N  */
N#define EBI_READ_DATA32(u32Addr)            (*((volatile unsigned int *)(EBI_BASE_ADDR+(u32Addr))))
N
N/**
N  * @brief      Write 32-bit data
N  *
N  * @param[in]  u32Addr     The data address on EBI bus.
N  * @param[in]  u32Data     Specify data to be written.
N  *
N  * @return     None
N  *
N  * @details    This macro write 32-bit data to specify EBI address.
N  */
N#define EBI_WRITE_DATA32(u32Addr, u32Data)  (*((volatile unsigned int *)(EBI_BASE_ADDR+(u32Addr))) = (u32Data))
N
Nvoid EBI_Open(uint32_t u32Bank, uint32_t u32DataWidth, uint32_t u32TimingClass, uint32_t u32BusMode, uint32_t u32CSActiveLevel);
Nvoid EBI_Close(uint32_t u32Bank);
Nvoid EBI_SetBusTiming(uint32_t u32Bank, uint32_t u32TimingConfig, uint32_t u32MclkDiv);
N
N/*@}*/ /* end of group EBI_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group EBI_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif //__EBI_H__
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
L 12465 ".\Libraries\Device\Nuvoton\NUC230_240\Include\NUC230_240.h" 2
N#endif
N
N/*@}*/ /* end of REGISTER group Definitions */
N
N
L 14 "Libraries\StdDriver\src\ps2.c" 2
N
N/*---------------------------------------------------------------------------------------------------------*/
N/* Includes of local headers                                                                               */
N/*---------------------------------------------------------------------------------------------------------*/
N#include "ps2.h"
N
N
N/** @addtogroup Standard_Driver Standard Driver
N  @{
N*/
N
N/** @addtogroup PS2_Driver PS2 Driver
N  @{
N*/
N
N
N/** @addtogroup PS2_EXPORTED_FUNCTIONS PS2 Exported Functions
N  @{
N*/
N
N
N/**
N *  @brief     Enable PS/2 Interrupt
N *
N *  @param[in] u32Mask    The specified interrupt of PS/2 module:
N *                               - PS2D_PS2CON_TXINTEN_Msk: PS/2 Tx interrupt
N *                               - PS2D_PS2CON_RXINTEN_Msk: PS/2 Rx interrupt
N *
N *  @return    None
N *
N *  @details   The function is used to enable PS/2 specified Tx or Rx interrupt.
N */
Nvoid PS2_EnableInt(uint32_t u32Mask)
N{
N    PS2->PS2CON |= u32Mask;
X    ((PS2_T *) ((( uint32_t)0x40100000) + 0x00000))->PS2CON |= u32Mask;
N}
N
N/**
N *  @brief      Disable PS/2 Interrupt.
N *
N *  @param[in]  u32Mask    The specified interrupt of PS2 module:
N *                               - PS2D_PS2CON_TXINTEN_Msk: PS2 Tx interrupt
N *                               - PS2D_PS2CON_RXINTEN_Msk: PS2 Rx interrupt
N *
N *  @return     None
N *
N *  @details    The function is used to disable PS/2 specified Tx or Rx interrupt.
N */
Nvoid PS2_DisableInt(uint32_t u32Mask)
N{
N    PS2->PS2CON &= ~u32Mask;
X    ((PS2_T *) ((( uint32_t)0x40100000) + 0x00000))->PS2CON &= ~u32Mask;
N}
N
N/**
N *  @brief    Enable PS/2 function and Set Parameter
N *
N *  @param    None
N *
N *  @return   None
N *
N *  @details  This function is used to enable PS/2 function and set one byte per transfer.
N */
Nvoid PS2_Open(void)
N{
N    /* Reset PS2 device */
N    SYS->IPRSTC2 |=  SYS_IPRSTC2_PS2_RST_Msk;
X    ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->IPRSTC2 |=  (1ul << 23);
N    SYS->IPRSTC2 &= ~SYS_IPRSTC2_PS2_RST_Msk;
X    ((GCR_T *) ((( uint32_t)0x50000000) + 0x00000))->IPRSTC2 &= ~(1ul << 23);
N
N    /* Enable PS2 module */
N    PS2->PS2CON |= PS2_PS2CON_PS2EN_Msk;
X    ((PS2_T *) ((( uint32_t)0x40100000) + 0x00000))->PS2CON |= (1ul << 0);
N
N    /* Set One byte per transfer */
N    PS2->PS2CON &= ~PS2_PS2CON_TXFIFO_DEPTH_Msk;
X    ((PS2_T *) ((( uint32_t)0x40100000) + 0x00000))->PS2CON &= ~(0xFul << 3);
N
N    /* Clear Tx FIFO */
N    PS2->PS2CON |= PS2_PS2CON_CLRFIFO_Msk;
X    ((PS2_T *) ((( uint32_t)0x40100000) + 0x00000))->PS2CON |= (1ul << 8);
N    PS2->PS2CON &= (~PS2_PS2CON_CLRFIFO_Msk);
X    ((PS2_T *) ((( uint32_t)0x40100000) + 0x00000))->PS2CON &= (~(1ul << 8));
N}
N
N/**
N *  @brief    Disable PS/2 function
N *
N *  @param    None
N *
N *  @return   None
N *
N *  @details  This function use to disable PS/2 function.
N */
Nvoid PS2_Close(void)
N{
N    /* Enable PS2 module */
N    PS2->PS2CON &= ~PS2_PS2CON_PS2EN_Msk;
X    ((PS2_T *) ((( uint32_t)0x40100000) + 0x00000))->PS2CON &= ~(1ul << 0);
N}
N
N/**
N *  @brief    This function use to read PS/2 Rx data.
N *
N *  @param    None
N *
N *  @return   Rx data
N *
N *  @details  To get PS/2 receive 8 bits data from PS2RXDATA register.
N */
Nuint8_t PS2_Read(void)
N{
N    return (uint8_t)(PS2->PS2RXDATA & PS2_PS2RXDATA_RXDATA_Msk);
X    return (uint8_t)(((PS2_T *) ((( uint32_t)0x40100000) + 0x00000))->PS2RXDATA & (0xFFul << 0));
N}
N
N/**
N *  @brief        This function use to transmit PS/2 data.
N *
N *  @param[in]    pu32Buf        The buffer to send the data to PS/2 transmission FIFO.
N *  @param[in]    u32ByteCount   The byte number of data.
N *
N *  @retval       0 transmit data time-out
N *  @retval       1 transmit data successful
N *
N *  @details      Write data to PS/2 transmit FIFO and set the depth of Tx transmit bytes, then check every data transmission success or time-out.
N */
Nint32_t PS2_Write(uint32_t *pu32Buf, uint32_t u32ByteCount)
N{
N    uint32_t u32TxFIFO_Depth = 16;
N    uint32_t u32delayno, txcnt, remainder;
N    uint8_t i = 0;
N
N    txcnt = u32ByteCount / u32TxFIFO_Depth;
N
N    remainder = u32ByteCount % u32TxFIFO_Depth;
N    if(remainder) txcnt++;
N
N    u32delayno = 0;
N    while(!(PS2->PS2STATUS & PS2_PS2STATUS_TXEMPTY_Msk))
X    while(!(((PS2_T *) ((( uint32_t)0x40100000) + 0x00000))->PS2STATUS & (1ul << 7)))
N    {
N        u32delayno++;
N        if(u32delayno >= 0xF00000)
N            return FALSE; // Time Out
X            return 0; 
N    }
N
N    if(u32ByteCount >= u32TxFIFO_Depth)//Tx FIFO is 16 bytes
N        PS2_SET_TX_BYTE_CNT(u32TxFIFO_Depth);
X        (((PS2_T *) ((( uint32_t)0x40100000) + 0x00000))->PS2CON = (((PS2_T *) ((( uint32_t)0x40100000) + 0x00000))->PS2CON & ~(0xFul << 3)) | (((u32TxFIFO_Depth)-1) << 3));
N
N    do
N    {
N        u32delayno = 0;
N        while(!(PS2->PS2STATUS & PS2_PS2STATUS_TXEMPTY_Msk))
X        while(!(((PS2_T *) ((( uint32_t)0x40100000) + 0x00000))->PS2STATUS & (1ul << 7)))
N        {
N            u32delayno++;
N            if(u32delayno >= 0xF00000)
N                return FALSE; // Time Out
X                return 0; 
N        }
N
N        if((txcnt == 1) && (remainder != 0))
N            PS2_SET_TX_BYTE_CNT(u32ByteCount);
X            (((PS2_T *) ((( uint32_t)0x40100000) + 0x00000))->PS2CON = (((PS2_T *) ((( uint32_t)0x40100000) + 0x00000))->PS2CON & ~(0xFul << 3)) | (((u32ByteCount)-1) << 3));
N
N        PS2->PS2TXDATA0 = pu32Buf[i];
X        ((PS2_T *) ((( uint32_t)0x40100000) + 0x00000))->PS2TXDATA0 = pu32Buf[i];
N        PS2->PS2TXDATA1 = pu32Buf[i + 1];
X        ((PS2_T *) ((( uint32_t)0x40100000) + 0x00000))->PS2TXDATA1 = pu32Buf[i + 1];
N        PS2->PS2TXDATA2 = pu32Buf[i + 2];
X        ((PS2_T *) ((( uint32_t)0x40100000) + 0x00000))->PS2TXDATA2 = pu32Buf[i + 2];
N        PS2->PS2TXDATA3 = pu32Buf[i + 3];
X        ((PS2_T *) ((( uint32_t)0x40100000) + 0x00000))->PS2TXDATA3 = pu32Buf[i + 3];
N
N        i = i + 4;
N
N    }
N    while(--txcnt);
N
N    u32delayno = 0;
N    while(!(PS2->PS2STATUS & PS2_PS2STATUS_TXEMPTY_Msk))
X    while(!(((PS2_T *) ((( uint32_t)0x40100000) + 0x00000))->PS2STATUS & (1ul << 7)))
N    {
N        u32delayno++;
N        if(u32delayno >= 0xF00000)
N            return FALSE; // Time Out
X            return 0; 
N    }
N
N    return TRUE;
X    return 1;
N
N}
N
N
N/*@}*/ /* end of group PS2_EXPORTED_FUNCTIONS */
N
N/*@}*/ /* end of group PS2_Driver */
N
N/*@}*/ /* end of group Standard_Driver */
N
N/*** (C) COPYRIGHT 2014 Nuvoton Technology Corp. ***/
N
N
N
