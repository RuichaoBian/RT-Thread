; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\thread.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\thread.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I.\Libraries\Device\Nuvoton -I..\..\components\finsh -I.\Libraries\CMSIS\Include -I.\Libraries\StdDriver\inc -I..\..\include -I.\APP -I.\Drivers -I..\..\components\drivers\include -I..\..\components\drivers\include\drivers -I..\nuvoton_nuc240 -I.\Libraries\Device\Nuvoton\NUC230_240\Include -I..\..\include -I..\..\components\drivers\usb\usbdevice\class -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=521 -DRT_DEBUG --omf_browse=.\objects\thread.crf ..\..\src\thread.c]
                          THUMB

                          AREA ||i._rt_thread_init||, CODE, READONLY, ALIGN=2

                  _rt_thread_init PROC
;;;131    
;;;132    static rt_err_t _rt_thread_init(struct rt_thread *thread,
000000  b5fe              PUSH     {r1-r7,lr}
;;;133                                    const char       *name,
;;;134                                    void (*entry)(void *parameter),
;;;135                                    void             *parameter,
;;;136                                    void             *stack_start,
;;;137                                    rt_uint32_t       stack_size,
;;;138                                    rt_uint8_t        priority,
;;;139                                    rt_uint32_t       tick)
;;;140    {
000002  4619              MOV      r1,r3
000004  4604              MOV      r4,r0
;;;141        /* init thread list */
;;;142        rt_list_init(&(thread->tlist));
000006  3014              ADDS     r0,r0,#0x14
000008  9f09              LDR      r7,[sp,#0x24]
00000a  9e0b              LDR      r6,[sp,#0x2c]
00000c  9d0a              LDR      r5,[sp,#0x28]
00000e  9b08              LDR      r3,[sp,#0x20]
000010  6040              STR      r0,[r0,#4]
000012  6000              STR      r0,[r0,#0]
;;;143    
;;;144        thread->entry = (void *)entry;
000014  4620              MOV      r0,r4
000016  6222              STR      r2,[r4,#0x20]
000018  3024              ADDS     r0,r0,#0x24
00001a  c08a              STM      r0!,{r1,r3,r7}
;;;145        thread->parameter = parameter;
;;;146    
;;;147        /* stack init */
;;;148        thread->stack_addr = stack_start;
;;;149        thread->stack_size = stack_size;
;;;150    
;;;151        /* init thread stack */
;;;152        rt_memset(thread->stack_addr, '#', thread->stack_size);
00001c  463a              MOV      r2,r7
00001e  4618              MOV      r0,r3
000020  2123              MOVS     r1,#0x23
000022  f7fffffe          BL       rt_memset
;;;153        thread->sp = (void *)rt_hw_stack_init(thread->entry, thread->parameter,
000026  6ae1              LDR      r1,[r4,#0x2c]
000028  6aa0              LDR      r0,[r4,#0x28]
00002a  4b15              LDR      r3,|L1.128|
00002c  1842              ADDS     r2,r0,r1
00002e  1f12              SUBS     r2,r2,#4
000030  6a61              LDR      r1,[r4,#0x24]
000032  6a20              LDR      r0,[r4,#0x20]
000034  f7fffffe          BL       rt_hw_stack_init
;;;154            (void *)((char *)thread->stack_addr + thread->stack_size - 4),
;;;155            (void *)rt_thread_exit);
;;;156    
;;;157        /* priority init */
;;;158        RT_ASSERT(priority < RT_THREAD_PRIORITY_MAX);
000038  61e0              STR      r0,[r4,#0x1c]
00003a  2d20              CMP      r5,#0x20
00003c  d304              BCC      |L1.72|
00003e  229e              MOVS     r2,#0x9e
000040  4910              LDR      r1,|L1.132|
000042  a011              ADR      r0,|L1.136|
000044  f7fffffe          BL       rt_assert_handler
                  |L1.72|
;;;159        thread->init_priority    = priority;
000048  4620              MOV      r0,r4
00004a  3020              ADDS     r0,r0,#0x20
00004c  7585              STRB     r5,[r0,#0x16]
;;;160        thread->current_priority = priority;
00004e  7545              STRB     r5,[r0,#0x15]
;;;161    
;;;162        /* tick init */
;;;163        thread->init_tick      = tick;
;;;164        thread->remaining_tick = tick;
000050  6466              STR      r6,[r4,#0x44]
;;;165    
;;;166        /* error and flags */
;;;167        thread->error = RT_EOK;
;;;168        thread->stat  = RT_THREAD_INIT;
000052  64a6              STR      r6,[r4,#0x48]
000054  2500              MOVS     r5,#0                 ;167
000056  6325              STR      r5,[r4,#0x30]
000058  7505              STRB     r5,[r0,#0x14]
;;;169    
;;;170        /* initialize cleanup function and user data */
;;;171        thread->cleanup   = 0;
;;;172        thread->user_data = 0;
;;;173    		rt_kprintf("&(thread->thread_timer) = %d",&(thread->thread_timer));
00005a  4621              MOV      r1,r4
00005c  67a5              STR      r5,[r4,#0x78]         ;172
00005e  314c              ADDS     r1,r1,#0x4c
000060  460e              MOV      r6,r1
000062  a012              ADR      r0,|L1.172|
000064  67e5              STR      r5,[r4,#0x7c]
000066  f7fffffe          BL       rt_kprintf
;;;174        /* init thread timer */
;;;175        rt_timer_init(&(thread->thread_timer),
00006a  4623              MOV      r3,r4
00006c  9500              STR      r5,[sp,#0]
00006e  4a17              LDR      r2,|L1.204|
000070  4619              MOV      r1,r3
000072  4630              MOV      r0,r6
000074  9501              STR      r5,[sp,#4]
000076  f7fffffe          BL       rt_timer_init
;;;176                      thread->name,
;;;177                      rt_thread_timeout,
;;;178                      thread,
;;;179                      0,
;;;180                      RT_TIMER_FLAG_ONE_SHOT);
;;;181    
;;;182        RT_OBJECT_HOOK_CALL(rt_thread_inited_hook,(thread));
;;;183    
;;;184        return RT_EOK;
00007a  2000              MOVS     r0,#0
;;;185    }
00007c  bdfe              POP      {r1-r7,pc}
;;;186    
                          ENDP

00007e  0000              DCW      0x0000
                  |L1.128|
                          DCD      rt_thread_exit
                  |L1.132|
                          DCD      ||.constdata||
                  |L1.136|
000088  7072696f          DCB      "priority < RT_THREAD_PRIORITY_MAX",0
00008c  72697479
000090  203c2052
000094  545f5448
000098  52454144
00009c  5f505249
0000a0  4f524954
0000a4  595f4d41
0000a8  5800    
0000aa  00                DCB      0
0000ab  00                DCB      0
                  |L1.172|
0000ac  26287468          DCB      "&(thread->thread_timer) = %d",0
0000b0  72656164
0000b4  2d3e7468
0000b8  72656164
0000bc  5f74696d
0000c0  65722920
0000c4  3d202564
0000c8  00      
0000c9  00                DCB      0
0000ca  00                DCB      0
0000cb  00                DCB      0
                  |L1.204|
                          DCD      rt_thread_timeout

                          AREA ||i.rt_list_insert_after||, CODE, READONLY, ALIGN=1

                  rt_list_insert_after PROC
;;;61      */
;;;62     rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
000000  6802              LDR      r2,[r0,#0]
;;;63     {
;;;64         l->next->prev = n;
;;;65         n->next = l->next;
000002  6051              STR      r1,[r2,#4]
000004  6802              LDR      r2,[r0,#0]
;;;66     
;;;67         l->next = n;
000006  600a              STR      r2,[r1,#0]
;;;68         n->prev = l;
000008  6001              STR      r1,[r0,#0]
00000a  6048              STR      r0,[r1,#4]
;;;69     }
00000c  4770              BX       lr
;;;70     
                          ENDP


                          AREA ||i.rt_list_remove||, CODE, READONLY, ALIGN=1

                  rt_list_remove PROC
;;;90      */
;;;91     rt_inline void rt_list_remove(rt_list_t *n)
000000  c806              LDM      r0!,{r1,r2}
;;;92     {
;;;93         n->next->prev = n->prev;
000002  3808              SUBS     r0,r0,#8
000004  604a              STR      r2,[r1,#4]
000006  c806              LDM      r0!,{r1,r2}
;;;94         n->prev->next = n->next;
000008  3808              SUBS     r0,r0,#8
;;;95     
;;;96         n->next = n->prev = n;
00000a  6011              STR      r1,[r2,#0]
00000c  6040              STR      r0,[r0,#4]
00000e  6000              STR      r0,[r0,#0]
;;;97     }
000010  4770              BX       lr
;;;98     
                          ENDP


                          AREA ||i.rt_thread_control||, CODE, READONLY, ALIGN=2

                  rt_thread_control PROC
;;;531     */
;;;532    rt_err_t rt_thread_control(rt_thread_t thread, rt_uint8_t cmd, void *arg)
000000  b5f8              PUSH     {r3-r7,lr}
;;;533    {
000002  4616              MOV      r6,r2
000004  460d              MOV      r5,r1
000006  0004              MOVS     r4,r0
000008  d104              BNE      |L4.20|
;;;534        register rt_base_t temp;
;;;535    
;;;536        /* thread check */
;;;537        RT_ASSERT(thread != RT_NULL);
00000a  4a18              LDR      r2,|L4.108|
00000c  4918              LDR      r1,|L4.112|
00000e  a019              ADR      r0,|L4.116|
000010  f7fffffe          BL       rt_assert_handler
                  |L4.20|
;;;538    
;;;539        switch (cmd)
000014  2d00              CMP      r5,#0
000016  d020              BEQ      |L4.90|
000018  2d01              CMP      r5,#1
00001a  d022              BEQ      |L4.98|
00001c  2d02              CMP      r5,#2
00001e  d10f              BNE      |L4.64|
;;;540        {
;;;541        case RT_THREAD_CTRL_CHANGE_PRIORITY:
;;;542            /* disable interrupt */
;;;543            temp = rt_hw_interrupt_disable();
000020  f7fffffe          BL       rt_hw_interrupt_disable
;;;544    
;;;545            /* for ready thread, change queue */
;;;546            if (thread->stat == RT_THREAD_READY)
000024  4625              MOV      r5,r4
000026  3520              ADDS     r5,r5,#0x20
000028  9000              STR      r0,[sp,#0]
00002a  7d28              LDRB     r0,[r5,#0x14]
00002c  2701              MOVS     r7,#1                 ;533
00002e  2801              CMP      r0,#1
000030  d008              BEQ      |L4.68|
;;;547            {
;;;548                /* remove thread from schedule queue first */
;;;549                rt_schedule_remove_thread(thread);
;;;550    
;;;551                /* change thread priority */
;;;552                thread->current_priority = *(rt_uint8_t *)arg;
;;;553    
;;;554                /* recalculate priority attribute */
;;;555    #if RT_THREAD_PRIORITY_MAX > 32
;;;556                thread->number      = thread->current_priority >> 3;            /* 5bit */
;;;557                thread->number_mask = 1 << thread->number;
;;;558                thread->high_mask   = 1 << (thread->current_priority & 0x07);   /* 3bit */
;;;559    #else
;;;560                thread->number_mask = 1 << thread->current_priority;
;;;561    #endif
;;;562    
;;;563                /* insert thread to schedule queue again */
;;;564                rt_schedule_insert_thread(thread);
;;;565            }
;;;566            else
;;;567            {
;;;568                thread->current_priority = *(rt_uint8_t *)arg;
000032  7830              LDRB     r0,[r6,#0]
000034  7568              STRB     r0,[r5,#0x15]
;;;569    
;;;570                /* recalculate priority attribute */
;;;571    #if RT_THREAD_PRIORITY_MAX > 32
;;;572                thread->number      = thread->current_priority >> 3;            /* 5bit */
;;;573                thread->number_mask = 1 << thread->number;
;;;574                thread->high_mask   = 1 << (thread->current_priority & 0x07);   /* 3bit */
;;;575    #else
;;;576                thread->number_mask = 1 << thread->current_priority;
000036  4087              LSLS     r7,r7,r0
000038  63a7              STR      r7,[r4,#0x38]
                  |L4.58|
;;;577    #endif
;;;578            }
;;;579    
;;;580            /* enable interrupt */
;;;581            rt_hw_interrupt_enable(temp);
00003a  9800              LDR      r0,[sp,#0]
00003c  f7fffffe          BL       rt_hw_interrupt_enable
                  |L4.64|
;;;582            break;
;;;583    
;;;584        case RT_THREAD_CTRL_STARTUP:
;;;585            return rt_thread_startup(thread);
;;;586    
;;;587    #ifdef RT_USING_HEAP
;;;588        case RT_THREAD_CTRL_CLOSE:
;;;589            return rt_thread_delete(thread);
;;;590    #endif
;;;591    
;;;592        default:
;;;593            break;
;;;594        }
;;;595    
;;;596        return RT_EOK;
000040  2000              MOVS     r0,#0
;;;597    }
000042  bdf8              POP      {r3-r7,pc}
                  |L4.68|
000044  4620              MOV      r0,r4                 ;549
000046  f7fffffe          BL       rt_schedule_remove_thread
00004a  7830              LDRB     r0,[r6,#0]            ;552
00004c  7568              STRB     r0,[r5,#0x15]         ;552
00004e  4087              LSLS     r7,r7,r0              ;560
000050  4620              MOV      r0,r4                 ;564
000052  63a7              STR      r7,[r4,#0x38]         ;564
000054  f7fffffe          BL       rt_schedule_insert_thread
000058  e7ef              B        |L4.58|
                  |L4.90|
00005a  4620              MOV      r0,r4                 ;585
00005c  f7fffffe          BL       rt_thread_startup
000060  bdf8              POP      {r3-r7,pc}
                  |L4.98|
000062  4620              MOV      r0,r4                 ;589
000064  f7fffffe          BL       rt_thread_delete
000068  bdf8              POP      {r3-r7,pc}
;;;598    RTM_EXPORT(rt_thread_control);
                          ENDP

00006a  0000              DCW      0x0000
                  |L4.108|
                          DCD      0x00000219
                  |L4.112|
                          DCD      ||.constdata||+0x63
                  |L4.116|
000074  74687265          DCB      "thread != RT_NULL",0
000078  61642021
00007c  3d205254
000080  5f4e554c
000084  4c00    
000086  00                DCB      0
000087  00                DCB      0

                          AREA ||i.rt_thread_create||, CODE, READONLY, ALIGN=1

                  rt_thread_create PROC
;;;347     */
;;;348    rt_thread_t rt_thread_create(const char *name,
000000  b5ff              PUSH     {r0-r7,lr}
;;;349                                 void (*entry)(void *parameter),
;;;350                                 void       *parameter,
;;;351                                 rt_uint32_t stack_size,
;;;352                                 rt_uint8_t  priority,
;;;353                                 rt_uint32_t tick)
;;;354    {
000002  b085              SUB      sp,sp,#0x14
000004  461d              MOV      r5,r3
;;;355        struct rt_thread *thread;
;;;356        void *stack_start;
;;;357    
;;;358        thread = (struct rt_thread *)rt_object_allocate(RT_Object_Class_Thread,
000006  2000              MOVS     r0,#0
000008  9f0e              LDR      r7,[sp,#0x38]
00000a  9e0f              LDR      r6,[sp,#0x3c]
00000c  9905              LDR      r1,[sp,#0x14]
00000e  f7fffffe          BL       rt_object_allocate
000012  1e04              SUBS     r4,r0,#0
;;;359                                                        name);
;;;360        if (thread == RT_NULL)
000014  d00d              BEQ      |L5.50|
;;;361            return RT_NULL;
;;;362    
;;;363        stack_start = (void *)RT_KERNEL_MALLOC(stack_size);
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       rt_malloc
;;;364        if (stack_start == RT_NULL)
00001c  2800              CMP      r0,#0
00001e  d00a              BEQ      |L5.54|
;;;365        {
;;;366            /* allocate stack failure */
;;;367            rt_object_delete((rt_object_t)thread);
;;;368    
;;;369            return RT_NULL;
;;;370        }
;;;371    
;;;372        _rt_thread_init(thread,
000020  4669              MOV      r1,sp
000022  9603              STR      r6,[sp,#0xc]
000024  c1a1              STM      r1!,{r0,r5,r7}
000026  a905              ADD      r1,sp,#0x14
000028  c90e              LDM      r1,{r1-r3}
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       _rt_thread_init
;;;373                        name,
;;;374                        entry,
;;;375                        parameter,
;;;376                        stack_start,
;;;377                        stack_size,
;;;378                        priority,
;;;379                        tick);
;;;380    
;;;381        return thread;
000030  4620              MOV      r0,r4
                  |L5.50|
;;;382    }
000032  b009              ADD      sp,sp,#0x24
000034  bdf0              POP      {r4-r7,pc}
                  |L5.54|
000036  4620              MOV      r0,r4                 ;367
000038  f7fffffe          BL       rt_object_delete
00003c  2000              MOVS     r0,#0                 ;369
00003e  e7f8              B        |L5.50|
;;;383    RTM_EXPORT(rt_thread_create);
                          ENDP


                          AREA ||i.rt_thread_delay||, CODE, READONLY, ALIGN=1

                  rt_thread_delay PROC
;;;513     */
;;;514    rt_err_t rt_thread_delay(rt_tick_t tick)
000000  b510              PUSH     {r4,lr}
;;;515    {
;;;516        return rt_thread_sleep(tick);
000002  f7fffffe          BL       rt_thread_sleep
;;;517    }
000006  bd10              POP      {r4,pc}
;;;518    RTM_EXPORT(rt_thread_delay);
                          ENDP


                          AREA ||i.rt_thread_delete||, CODE, READONLY, ALIGN=2

                  rt_thread_delete PROC
;;;392     */
;;;393    rt_err_t rt_thread_delete(rt_thread_t thread)
000000  b570              PUSH     {r4-r6,lr}
;;;394    {
000002  0004              MOVS     r4,r0
000004  d105              BNE      |L7.18|
;;;395        rt_base_t lock;
;;;396    
;;;397        /* thread check */
;;;398        RT_ASSERT(thread != RT_NULL);
000006  22ff              MOVS     r2,#0xff
000008  328f              ADDS     r2,r2,#0x8f
00000a  490f              LDR      r1,|L7.72|
00000c  a00f              ADR      r0,|L7.76|
00000e  f7fffffe          BL       rt_assert_handler
                  |L7.18|
;;;399    
;;;400        if (thread->stat != RT_THREAD_INIT)
000012  4625              MOV      r5,r4
000014  3520              ADDS     r5,r5,#0x20
000016  7d28              LDRB     r0,[r5,#0x14]
000018  2800              CMP      r0,#0
00001a  d002              BEQ      |L7.34|
;;;401        {
;;;402            /* remove from schedule */
;;;403            rt_schedule_remove_thread(thread);
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       rt_schedule_remove_thread
                  |L7.34|
;;;404        }
;;;405    
;;;406        /* release thread timer */
;;;407        rt_timer_detach(&(thread->thread_timer));
000022  4620              MOV      r0,r4
000024  304c              ADDS     r0,r0,#0x4c
000026  f7fffffe          BL       rt_timer_detach
;;;408    
;;;409        /* change stat */
;;;410        thread->stat = RT_THREAD_CLOSE;
00002a  2004              MOVS     r0,#4
00002c  7528              STRB     r0,[r5,#0x14]
;;;411    
;;;412        /* disable interrupt */
;;;413        lock = rt_hw_interrupt_disable();
00002e  f7fffffe          BL       rt_hw_interrupt_disable
000032  4605              MOV      r5,r0
;;;414    
;;;415        /* insert to defunct thread list */
;;;416        rt_list_insert_after(&rt_thread_defunct, &(thread->tlist));
000034  4621              MOV      r1,r4
000036  3114              ADDS     r1,r1,#0x14
000038  4809              LDR      r0,|L7.96|
00003a  f7fffffe          BL       rt_list_insert_after
;;;417    
;;;418        /* enable interrupt */
;;;419        rt_hw_interrupt_enable(lock);
00003e  4628              MOV      r0,r5
000040  f7fffffe          BL       rt_hw_interrupt_enable
;;;420    
;;;421        return RT_EOK;
000044  2000              MOVS     r0,#0
;;;422    }
000046  bd70              POP      {r4-r6,pc}
;;;423    RTM_EXPORT(rt_thread_delete);
                          ENDP

                  |L7.72|
                          DCD      ||.constdata||+0x42
                  |L7.76|
00004c  74687265          DCB      "thread != RT_NULL",0
000050  61642021
000054  3d205254
000058  5f4e554c
00005c  4c00    
00005e  00                DCB      0
00005f  00                DCB      0
                  |L7.96|
                          DCD      rt_thread_defunct

                          AREA ||i.rt_thread_detach||, CODE, READONLY, ALIGN=2

                  rt_thread_detach PROC
;;;294     */
;;;295    rt_err_t rt_thread_detach(rt_thread_t thread)
000000  b570              PUSH     {r4-r6,lr}
;;;296    {
000002  0004              MOVS     r4,r0
000004  d105              BNE      |L8.18|
;;;297        rt_base_t lock;
;;;298    
;;;299        /* thread check */
;;;300        RT_ASSERT(thread != RT_NULL);
000006  22ff              MOVS     r2,#0xff
000008  322d              ADDS     r2,r2,#0x2d
00000a  4912              LDR      r1,|L8.84|
00000c  a012              ADR      r0,|L8.88|
00000e  f7fffffe          BL       rt_assert_handler
                  |L8.18|
;;;301    
;;;302        if (thread->stat != RT_THREAD_INIT)
000012  4625              MOV      r5,r4
000014  3520              ADDS     r5,r5,#0x20
000016  7d28              LDRB     r0,[r5,#0x14]
000018  2800              CMP      r0,#0
00001a  d002              BEQ      |L8.34|
;;;303        {
;;;304            /* remove from schedule */
;;;305            rt_schedule_remove_thread(thread);
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       rt_schedule_remove_thread
                  |L8.34|
;;;306        }
;;;307    
;;;308        /* release thread timer */
;;;309        rt_timer_detach(&(thread->thread_timer));
000022  4620              MOV      r0,r4
000024  304c              ADDS     r0,r0,#0x4c
000026  f7fffffe          BL       rt_timer_detach
;;;310    
;;;311        /* change stat */
;;;312        thread->stat = RT_THREAD_CLOSE;
00002a  2004              MOVS     r0,#4
00002c  7528              STRB     r0,[r5,#0x14]
;;;313    
;;;314        /* detach object */
;;;315        rt_object_detach((rt_object_t)thread);
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       rt_object_detach
;;;316    
;;;317        if (thread->cleanup != RT_NULL)
000034  6fa0              LDR      r0,[r4,#0x78]
000036  2800              CMP      r0,#0
000038  d00a              BEQ      |L8.80|
;;;318        {
;;;319            /* disable interrupt */
;;;320            lock = rt_hw_interrupt_disable();
00003a  f7fffffe          BL       rt_hw_interrupt_disable
00003e  4605              MOV      r5,r0
;;;321    
;;;322            /* insert to defunct thread list */
;;;323            rt_list_insert_after(&rt_thread_defunct, &(thread->tlist));
000040  4621              MOV      r1,r4
000042  3114              ADDS     r1,r1,#0x14
000044  4809              LDR      r0,|L8.108|
000046  f7fffffe          BL       rt_list_insert_after
;;;324    
;;;325            /* enable interrupt */
;;;326            rt_hw_interrupt_enable(lock);
00004a  4628              MOV      r0,r5
00004c  f7fffffe          BL       rt_hw_interrupt_enable
                  |L8.80|
;;;327        }
;;;328    
;;;329        return RT_EOK;
000050  2000              MOVS     r0,#0
;;;330    }
000052  bd70              POP      {r4-r6,pc}
;;;331    RTM_EXPORT(rt_thread_detach);
                          ENDP

                  |L8.84|
                          DCD      ||.constdata||+0x31
                  |L8.88|
000058  74687265          DCB      "thread != RT_NULL",0
00005c  61642021
000060  3d205254
000064  5f4e554c
000068  4c00    
00006a  00                DCB      0
00006b  00                DCB      0
                  |L8.108|
                          DCD      rt_thread_defunct

                          AREA ||i.rt_thread_exit||, CODE, READONLY, ALIGN=2

                  rt_thread_exit PROC
;;;94     
;;;95     void rt_thread_exit(void)
000000  b570              PUSH     {r4-r6,lr}
;;;96     {
;;;97         struct rt_thread *thread;
;;;98         register rt_base_t level;
;;;99     
;;;100        /* get current thread */
;;;101        thread = rt_current_thread;
000002  4813              LDR      r0,|L9.80|
;;;102    
;;;103        /* disable interrupt */
;;;104        level = rt_hw_interrupt_disable();
000004  6804              LDR      r4,[r0,#0]  ; rt_current_thread
000006  f7fffffe          BL       rt_hw_interrupt_disable
00000a  4605              MOV      r5,r0
;;;105    
;;;106        /* remove from schedule */
;;;107        rt_schedule_remove_thread(thread);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       rt_schedule_remove_thread
;;;108        /* change stat */
;;;109        thread->stat = RT_THREAD_CLOSE;
000012  2104              MOVS     r1,#4
000014  2034              MOVS     r0,#0x34
000016  5501              STRB     r1,[r0,r4]
;;;110    
;;;111        /* remove it from timer list */
;;;112        rt_timer_detach(&thread->thread_timer);
000018  4620              MOV      r0,r4
00001a  304c              ADDS     r0,r0,#0x4c
00001c  f7fffffe          BL       rt_timer_detach
;;;113    
;;;114        if ((rt_object_is_systemobject((rt_object_t)thread) == RT_TRUE) &&
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       rt_object_is_systemobject
000026  2801              CMP      r0,#1
000028  d102              BNE      |L9.48|
;;;115            thread->cleanup == RT_NULL)
00002a  6fa0              LDR      r0,[r4,#0x78]
00002c  2800              CMP      r0,#0
00002e  d00a              BEQ      |L9.70|
                  |L9.48|
;;;116        {
;;;117            rt_object_detach((rt_object_t)thread);
;;;118        }
;;;119        else
;;;120        {
;;;121            /* insert to defunct thread list */
;;;122            rt_list_insert_after(&rt_thread_defunct, &(thread->tlist));
000030  4621              MOV      r1,r4
000032  3114              ADDS     r1,r1,#0x14
000034  4807              LDR      r0,|L9.84|
000036  f7fffffe          BL       rt_list_insert_after
                  |L9.58|
;;;123        }
;;;124    
;;;125        /* enable interrupt */
;;;126        rt_hw_interrupt_enable(level);
00003a  4628              MOV      r0,r5
00003c  f7fffffe          BL       rt_hw_interrupt_enable
;;;127    
;;;128        /* switch to next task */
;;;129        rt_schedule();
000040  f7fffffe          BL       rt_schedule
;;;130    }
000044  bd70              POP      {r4-r6,pc}
                  |L9.70|
000046  4620              MOV      r0,r4                 ;117
000048  f7fffffe          BL       rt_object_detach
00004c  e7f5              B        |L9.58|
;;;131    
                          ENDP

00004e  0000              DCW      0x0000
                  |L9.80|
                          DCD      rt_current_thread
                  |L9.84|
                          DCD      rt_thread_defunct

                          AREA ||i.rt_thread_find||, CODE, READONLY, ALIGN=2

                  rt_thread_find PROC
;;;726     */
;;;727    rt_thread_t rt_thread_find(char *name)
000000  b5f1              PUSH     {r0,r4-r7,lr}
000002  4f12              LDR      r7,|L10.76|
;;;728    {
;;;729        struct rt_object_information *information;
;;;730        struct rt_object *object;
;;;731        struct rt_list_node *node;
;;;732    
;;;733        extern struct rt_object_information rt_object_container[];
;;;734    
;;;735        /* enter critical */
;;;736        if (rt_thread_self() != RT_NULL)
000004  6838              LDR      r0,[r7,#0]  ; rt_current_thread
000006  2800              CMP      r0,#0
000008  d001              BEQ      |L10.14|
;;;737            rt_enter_critical();
00000a  f7fffffe          BL       rt_enter_critical
                  |L10.14|
;;;738    
;;;739        /* try to find device object */
;;;740        information = &rt_object_container[RT_Object_Class_Thread];
00000e  4e10              LDR      r6,|L10.80|
;;;741        for (node  = information->object_list.next;
000010  6874              LDR      r4,[r6,#4]
000012  1d36              ADDS     r6,r6,#4
000014  e009              B        |L10.42|
                  |L10.22|
;;;742             node != &(information->object_list);
;;;743             node  = node->next)
;;;744        {
;;;745            object = rt_list_entry(node, struct rt_object, list);
000016  4625              MOV      r5,r4
000018  3d0c              SUBS     r5,r5,#0xc
;;;746            if (rt_strncmp(object->name, name, RT_NAME_MAX) == 0)
00001a  2208              MOVS     r2,#8
00001c  4628              MOV      r0,r5
00001e  9900              LDR      r1,[sp,#0]
000020  f7fffffe          BL       rt_strncmp
000024  2800              CMP      r0,#0
000026  d009              BEQ      |L10.60|
000028  6824              LDR      r4,[r4,#0]            ;743
                  |L10.42|
00002a  42b4              CMP      r4,r6                 ;742
00002c  d1f3              BNE      |L10.22|
;;;747            {
;;;748                /* leave critical */
;;;749                if (rt_thread_self() != RT_NULL)
;;;750                    rt_exit_critical();
;;;751    
;;;752                return (rt_thread_t)object;
;;;753            }
;;;754        }
;;;755    
;;;756        /* leave critical */
;;;757        if (rt_thread_self() != RT_NULL)
00002e  6838              LDR      r0,[r7,#0]  ; rt_current_thread
000030  2800              CMP      r0,#0
000032  d001              BEQ      |L10.56|
;;;758            rt_exit_critical();
000034  f7fffffe          BL       rt_exit_critical
                  |L10.56|
;;;759    
;;;760        /* not found */
;;;761        return RT_NULL;
000038  2000              MOVS     r0,#0
;;;762    }
00003a  bdf8              POP      {r3-r7,pc}
                  |L10.60|
00003c  6838              LDR      r0,[r7,#0]            ;749  ; rt_current_thread
00003e  2800              CMP      r0,#0                 ;749
000040  d001              BEQ      |L10.70|
000042  f7fffffe          BL       rt_exit_critical
                  |L10.70|
000046  4628              MOV      r0,r5                 ;752
000048  bdf8              POP      {r3-r7,pc}
;;;763    RTM_EXPORT(rt_thread_find);
                          ENDP

00004a  0000              DCW      0x0000
                  |L10.76|
                          DCD      rt_current_thread
                  |L10.80|
                          DCD      rt_object_container

                          AREA ||i.rt_thread_init||, CODE, READONLY, ALIGN=2

                  rt_thread_init PROC
;;;207     */
;;;208    rt_err_t rt_thread_init(struct rt_thread *thread,
000000  b5ff              PUSH     {r0-r7,lr}
;;;209                            const char       *name,
;;;210                            void (*entry)(void *parameter),
;;;211                            void             *parameter,
;;;212                            void             *stack_start,
;;;213                            rt_uint32_t       stack_size,
;;;214                            rt_uint8_t        priority,
;;;215                            rt_uint32_t       tick)
;;;216    {
000002  b085              SUB      sp,sp,#0x14
000004  9e10              LDR      r6,[sp,#0x40]
000006  9d11              LDR      r5,[sp,#0x44]
000008  9c0e              LDR      r4,[sp,#0x38]
00000a  0007              MOVS     r7,r0
00000c  d104              BNE      |L11.24|
;;;217        /* thread check */
;;;218        RT_ASSERT(thread != RT_NULL);
00000e  22da              MOVS     r2,#0xda
000010  490d              LDR      r1,|L11.72|
000012  a00e              ADR      r0,|L11.76|
000014  f7fffffe          BL       rt_assert_handler
                  |L11.24|
;;;219        RT_ASSERT(stack_start != RT_NULL);
000018  2c00              CMP      r4,#0
00001a  d104              BNE      |L11.38|
00001c  22db              MOVS     r2,#0xdb
00001e  490a              LDR      r1,|L11.72|
000020  a00f              ADR      r0,|L11.96|
000022  f7fffffe          BL       rt_assert_handler
                  |L11.38|
;;;220    
;;;221        /* init thread object */
;;;222        rt_object_init((rt_object_t)thread, RT_Object_Class_Thread, name);
000026  2100              MOVS     r1,#0
000028  4638              MOV      r0,r7
00002a  9a06              LDR      r2,[sp,#0x18]
00002c  f7fffffe          BL       rt_object_init
;;;223    
;;;224        return _rt_thread_init(thread,
000030  980f              LDR      r0,[sp,#0x3c]
000032  9001              STR      r0,[sp,#4]
000034  9602              STR      r6,[sp,#8]
000036  9503              STR      r5,[sp,#0xc]
000038  9400              STR      r4,[sp,#0]
00003a  a906              ADD      r1,sp,#0x18
00003c  c90e              LDM      r1,{r1-r3}
00003e  4638              MOV      r0,r7
000040  f7fffffe          BL       _rt_thread_init
;;;225                               name,
;;;226                               entry,
;;;227                               parameter,
;;;228                               stack_start,
;;;229                               stack_size,
;;;230                               priority,
;;;231                               tick);
;;;232    }
000044  b009              ADD      sp,sp,#0x24
000046  bdf0              POP      {r4-r7,pc}
;;;233    RTM_EXPORT(rt_thread_init);
                          ENDP

                  |L11.72|
                          DCD      ||.constdata||+0x10
                  |L11.76|
00004c  74687265          DCB      "thread != RT_NULL",0
000050  61642021
000054  3d205254
000058  5f4e554c
00005c  4c00    
00005e  00                DCB      0
00005f  00                DCB      0
                  |L11.96|
000060  73746163          DCB      "stack_start != RT_NULL",0
000064  6b5f7374
000068  61727420
00006c  213d2052
000070  545f4e55
000074  4c4c00  
000077  00                DCB      0

                          AREA ||i.rt_thread_resume||, CODE, READONLY, ALIGN=2

                  rt_thread_resume PROC
;;;651     */
;;;652    rt_err_t rt_thread_resume(rt_thread_t thread)
000000  b570              PUSH     {r4-r6,lr}
;;;653    {
000002  0004              MOVS     r4,r0
000004  d104              BNE      |L12.16|
;;;654        register rt_base_t temp;
;;;655    
;;;656        /* thread check */
;;;657        RT_ASSERT(thread != RT_NULL);
000006  4a0f              LDR      r2,|L12.68|
000008  490f              LDR      r1,|L12.72|
00000a  a010              ADR      r0,|L12.76|
00000c  f7fffffe          BL       rt_assert_handler
                  |L12.16|
;;;658    
;;;659        RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread resume:  %s\n", thread->name));
;;;660    
;;;661        if (thread->stat != RT_THREAD_SUSPEND)
000010  2034              MOVS     r0,#0x34
000012  5d00              LDRB     r0,[r0,r4]
000014  2802              CMP      r0,#2
000016  d002              BEQ      |L12.30|
;;;662        {
;;;663            RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread resume: thread disorder, %d\n",
;;;664                                           thread->stat));
;;;665    
;;;666            return -RT_ERROR;
000018  2000              MOVS     r0,#0
00001a  43c0              MVNS     r0,r0
;;;667        }
;;;668    
;;;669        /* disable interrupt */
;;;670        temp = rt_hw_interrupt_disable();
;;;671    
;;;672        /* remove from suspend list */
;;;673        rt_list_remove(&(thread->tlist));
;;;674    
;;;675        rt_timer_stop(&thread->thread_timer);
;;;676    
;;;677        /* enable interrupt */
;;;678        rt_hw_interrupt_enable(temp);
;;;679    
;;;680        /* insert to schedule ready list */
;;;681        rt_schedule_insert_thread(thread);
;;;682    
;;;683        RT_OBJECT_HOOK_CALL(rt_thread_resume_hook,(thread));
;;;684        return RT_EOK;
;;;685    }
00001c  bd70              POP      {r4-r6,pc}
                  |L12.30|
00001e  f7fffffe          BL       rt_hw_interrupt_disable
000022  4605              MOV      r5,r0                 ;670
000024  4620              MOV      r0,r4                 ;673
000026  3014              ADDS     r0,r0,#0x14           ;673
000028  f7fffffe          BL       rt_list_remove
00002c  4620              MOV      r0,r4                 ;675
00002e  304c              ADDS     r0,r0,#0x4c           ;675
000030  f7fffffe          BL       rt_timer_stop
000034  4628              MOV      r0,r5                 ;678
000036  f7fffffe          BL       rt_hw_interrupt_enable
00003a  4620              MOV      r0,r4                 ;681
00003c  f7fffffe          BL       rt_schedule_insert_thread
000040  2000              MOVS     r0,#0                 ;684
000042  bd70              POP      {r4-r6,pc}
;;;686    RTM_EXPORT(rt_thread_resume);
                          ENDP

                  |L12.68|
                          DCD      0x00000291
                  |L12.72|
                          DCD      ||.constdata||+0x87
                  |L12.76|
00004c  74687265          DCB      "thread != RT_NULL",0
000050  61642021
000054  3d205254
000058  5f4e554c
00005c  4c00    
00005e  00                DCB      0
00005f  00                DCB      0

                          AREA ||i.rt_thread_self||, CODE, READONLY, ALIGN=2

                  rt_thread_self PROC
;;;239     */
;;;240    rt_thread_t rt_thread_self(void)
000000  4801              LDR      r0,|L13.8|
;;;241    {
;;;242        return rt_current_thread;
000002  6800              LDR      r0,[r0,#0]  ; rt_current_thread
;;;243    }
000004  4770              BX       lr
;;;244    RTM_EXPORT(rt_thread_self);
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      rt_current_thread

                          AREA ||i.rt_thread_sleep||, CODE, READONLY, ALIGN=2

                  rt_thread_sleep PROC
;;;476     */
;;;477    rt_err_t rt_thread_sleep(rt_tick_t tick)
000000  b5f1              PUSH     {r0,r4-r7,lr}
;;;478    {
;;;479        register rt_base_t temp;
;;;480        struct rt_thread *thread;
;;;481    
;;;482        /* disable interrupt */
;;;483        temp = rt_hw_interrupt_disable();
000002  f7fffffe          BL       rt_hw_interrupt_disable
000006  4605              MOV      r5,r0
;;;484        /* set to current thread */
;;;485        thread = rt_current_thread;
000008  4810              LDR      r0,|L14.76|
;;;486        RT_ASSERT(thread != RT_NULL);
00000a  6804              LDR      r4,[r0,#0]  ; rt_current_thread
00000c  2c00              CMP      r4,#0
00000e  d105              BNE      |L14.28|
000010  22ff              MOVS     r2,#0xff
000012  32e7              ADDS     r2,r2,#0xe7
000014  490e              LDR      r1,|L14.80|
000016  a00f              ADR      r0,|L14.84|
000018  f7fffffe          BL       rt_assert_handler
                  |L14.28|
;;;487    
;;;488        /* suspend thread */
;;;489        rt_thread_suspend(thread);
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       rt_thread_suspend
;;;490    
;;;491        /* reset the timeout of thread timer and start it */
;;;492        rt_timer_control(&(thread->thread_timer), RT_TIMER_CTRL_SET_TIME, &tick);
000022  4620              MOV      r0,r4
000024  304c              ADDS     r0,r0,#0x4c
000026  466a              MOV      r2,sp
000028  2100              MOVS     r1,#0
00002a  4606              MOV      r6,r0
00002c  f7fffffe          BL       rt_timer_control
000030  4630              MOV      r0,r6
;;;493        rt_timer_start(&(thread->thread_timer));
000032  f7fffffe          BL       rt_timer_start
;;;494    
;;;495        /* enable interrupt */
;;;496        rt_hw_interrupt_enable(temp);
000036  4628              MOV      r0,r5
000038  f7fffffe          BL       rt_hw_interrupt_enable
;;;497    
;;;498        rt_schedule();
00003c  f7fffffe          BL       rt_schedule
;;;499    
;;;500        /* clear error number of this thread to RT_EOK */
;;;501        if (thread->error == -RT_ETIMEOUT)
000040  6b20              LDR      r0,[r4,#0x30]
000042  1c80              ADDS     r0,r0,#2
000044  d100              BNE      |L14.72|
;;;502            thread->error = RT_EOK;
000046  6320              STR      r0,[r4,#0x30]
                  |L14.72|
;;;503    
;;;504        return RT_EOK;
000048  2000              MOVS     r0,#0
;;;505    }
00004a  bdf8              POP      {r3-r7,pc}
;;;506    
                          ENDP

                  |L14.76|
                          DCD      rt_current_thread
                  |L14.80|
                          DCD      ||.constdata||+0x53
                  |L14.84|
000054  74687265          DCB      "thread != RT_NULL",0
000058  61642021
00005c  3d205254
000060  5f4e554c
000064  4c00    
000066  00                DCB      0
000067  00                DCB      0

                          AREA ||i.rt_thread_startup||, CODE, READONLY, ALIGN=2

                  rt_thread_startup PROC
;;;252     */
;;;253    rt_err_t rt_thread_startup(rt_thread_t thread)
000000  b570              PUSH     {r4-r6,lr}
;;;254    {
000002  0005              MOVS     r5,r0
000004  d105              BNE      |L15.18|
;;;255        /* thread check */
;;;256        RT_ASSERT(thread != RT_NULL);
000006  22ff              MOVS     r2,#0xff
000008  3201              ADDS     r2,#1
00000a  4910              LDR      r1,|L15.76|
00000c  a010              ADR      r0,|L15.80|
00000e  f7fffffe          BL       rt_assert_handler
                  |L15.18|
;;;257        RT_ASSERT(thread->stat == RT_THREAD_INIT);
000012  462c              MOV      r4,r5
000014  3420              ADDS     r4,r4,#0x20
000016  7d20              LDRB     r0,[r4,#0x14]
000018  2800              CMP      r0,#0
00001a  d005              BEQ      |L15.40|
00001c  22ff              MOVS     r2,#0xff
00001e  3202              ADDS     r2,#2
000020  490a              LDR      r1,|L15.76|
000022  a010              ADR      r0,|L15.100|
000024  f7fffffe          BL       rt_assert_handler
                  |L15.40|
;;;258    
;;;259        /* set current priority to init priority */
;;;260        thread->current_priority = thread->init_priority;
000028  7da0              LDRB     r0,[r4,#0x16]
;;;261    
;;;262        /* calculate priority attribute */
;;;263    #if RT_THREAD_PRIORITY_MAX > 32
;;;264        thread->number      = thread->current_priority >> 3;            /* 5bit */
;;;265        thread->number_mask = 1L << thread->number;
;;;266        thread->high_mask   = 1L << (thread->current_priority & 0x07);  /* 3bit */
;;;267    #else
;;;268        thread->number_mask = 1L << thread->current_priority;
00002a  2101              MOVS     r1,#1
00002c  7560              STRB     r0,[r4,#0x15]         ;260
00002e  4081              LSLS     r1,r1,r0
;;;269    #endif
;;;270    
;;;271        RT_DEBUG_LOG(RT_DEBUG_THREAD, ("startup a thread:%s with priority:%d\n",
;;;272                                       thread->name, thread->init_priority));
;;;273        /* change thread stat */
;;;274        thread->stat = RT_THREAD_SUSPEND;
000030  2002              MOVS     r0,#2
000032  63a9              STR      r1,[r5,#0x38]
000034  7520              STRB     r0,[r4,#0x14]
;;;275        /* then resume it */
;;;276        rt_thread_resume(thread);
000036  4628              MOV      r0,r5
000038  f7fffffe          BL       rt_thread_resume
00003c  4811              LDR      r0,|L15.132|
00003e  6800              LDR      r0,[r0,#0]  ; rt_current_thread
;;;277        if (rt_thread_self() != RT_NULL)
000040  2800              CMP      r0,#0
000042  d001              BEQ      |L15.72|
;;;278        {
;;;279            /* do a scheduling */
;;;280            rt_schedule();
000044  f7fffffe          BL       rt_schedule
                  |L15.72|
;;;281        }
;;;282    
;;;283        return RT_EOK;
000048  2000              MOVS     r0,#0
;;;284    }
00004a  bd70              POP      {r4-r6,pc}
;;;285    RTM_EXPORT(rt_thread_startup);
                          ENDP

                  |L15.76|
                          DCD      ||.constdata||+0x1f
                  |L15.80|
000050  74687265          DCB      "thread != RT_NULL",0
000054  61642021
000058  3d205254
00005c  5f4e554c
000060  4c00    
000062  00                DCB      0
000063  00                DCB      0
                  |L15.100|
000064  74687265          DCB      "thread->stat == RT_THREAD_INIT",0
000068  61642d3e
00006c  73746174
000070  203d3d20
000074  52545f54
000078  48524541
00007c  445f494e
000080  495400  
000083  00                DCB      0
                  |L15.132|
                          DCD      rt_current_thread

                          AREA ||i.rt_thread_suspend||, CODE, READONLY, ALIGN=2

                  rt_thread_suspend PROC
;;;609     */
;;;610    rt_err_t rt_thread_suspend(rt_thread_t thread)
000000  b570              PUSH     {r4-r6,lr}
;;;611    {
000002  0004              MOVS     r4,r0
000004  d104              BNE      |L16.16|
;;;612        register rt_base_t temp;
;;;613    
;;;614        /* thread check */
;;;615        RT_ASSERT(thread != RT_NULL);
000006  4a0f              LDR      r2,|L16.68|
000008  490f              LDR      r1,|L16.72|
00000a  a010              ADR      r0,|L16.76|
00000c  f7fffffe          BL       rt_assert_handler
                  |L16.16|
;;;616    
;;;617        RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread suspend:  %s\n", thread->name));
;;;618    
;;;619        if (thread->stat != RT_THREAD_READY)
000010  4625              MOV      r5,r4
000012  3520              ADDS     r5,r5,#0x20
000014  7d28              LDRB     r0,[r5,#0x14]
000016  2801              CMP      r0,#1
000018  d002              BEQ      |L16.32|
;;;620        {
;;;621            RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread suspend: thread disorder, %d\n",
;;;622                                           thread->stat));
;;;623    
;;;624            return -RT_ERROR;
00001a  2000              MOVS     r0,#0
00001c  43c0              MVNS     r0,r0
;;;625        }
;;;626    
;;;627        /* disable interrupt */
;;;628        temp = rt_hw_interrupt_disable();
;;;629    
;;;630        /* change thread stat */
;;;631        thread->stat = RT_THREAD_SUSPEND;
;;;632        rt_schedule_remove_thread(thread);
;;;633    
;;;634        /* stop thread timer anyway */
;;;635        rt_timer_stop(&(thread->thread_timer));
;;;636    
;;;637        /* enable interrupt */
;;;638        rt_hw_interrupt_enable(temp);
;;;639    
;;;640        RT_OBJECT_HOOK_CALL(rt_thread_suspend_hook,(thread));
;;;641        return RT_EOK;
;;;642    }
00001e  bd70              POP      {r4-r6,pc}
                  |L16.32|
000020  f7fffffe          BL       rt_hw_interrupt_disable
000024  4606              MOV      r6,r0                 ;628
000026  2002              MOVS     r0,#2                 ;631
000028  7528              STRB     r0,[r5,#0x14]         ;631
00002a  4620              MOV      r0,r4                 ;632
00002c  f7fffffe          BL       rt_schedule_remove_thread
000030  4620              MOV      r0,r4                 ;635
000032  304c              ADDS     r0,r0,#0x4c           ;635
000034  f7fffffe          BL       rt_timer_stop
000038  4630              MOV      r0,r6                 ;638
00003a  f7fffffe          BL       rt_hw_interrupt_enable
00003e  2000              MOVS     r0,#0                 ;641
000040  bd70              POP      {r4-r6,pc}
;;;643    RTM_EXPORT(rt_thread_suspend);
                          ENDP

000042  0000              DCW      0x0000
                  |L16.68|
                          DCD      0x00000267
                  |L16.72|
                          DCD      ||.constdata||+0x75
                  |L16.76|
00004c  74687265          DCB      "thread != RT_NULL",0
000050  61642021
000054  3d205254
000058  5f4e554c
00005c  4c00    
00005e  00                DCB      0
00005f  00                DCB      0

                          AREA ||i.rt_thread_timeout||, CODE, READONLY, ALIGN=2

                  rt_thread_timeout PROC
;;;693     */
;;;694    void rt_thread_timeout(void *parameter)
000000  b510              PUSH     {r4,lr}
;;;695    {
000002  0004              MOVS     r4,r0
000004  d104              BNE      |L17.16|
;;;696        struct rt_thread *thread;
;;;697    
;;;698        thread = (struct rt_thread *)parameter;
;;;699    
;;;700        /* thread check */
;;;701        RT_ASSERT(thread != RT_NULL);
000006  4a0e              LDR      r2,|L17.64|
000008  490e              LDR      r1,|L17.68|
00000a  a00f              ADR      r0,|L17.72|
00000c  f7fffffe          BL       rt_assert_handler
                  |L17.16|
;;;702        RT_ASSERT(thread->stat == RT_THREAD_SUSPEND);
000010  2034              MOVS     r0,#0x34
000012  5d00              LDRB     r0,[r0,r4]
000014  2802              CMP      r0,#2
000016  d005              BEQ      |L17.36|
000018  4a09              LDR      r2,|L17.64|
00001a  490a              LDR      r1,|L17.68|
00001c  1c52              ADDS     r2,r2,#1
00001e  a00f              ADR      r0,|L17.92|
000020  f7fffffe          BL       rt_assert_handler
                  |L17.36|
;;;703    
;;;704        /* set error number */
;;;705        thread->error = -RT_ETIMEOUT;
000024  2001              MOVS     r0,#1
000026  43c0              MVNS     r0,r0
;;;706    
;;;707        /* remove from suspend list */
;;;708        rt_list_remove(&(thread->tlist));
000028  6320              STR      r0,[r4,#0x30]
00002a  4620              MOV      r0,r4
00002c  3014              ADDS     r0,r0,#0x14
00002e  f7fffffe          BL       rt_list_remove
;;;709    
;;;710        /* insert to schedule ready list */
;;;711        rt_schedule_insert_thread(thread);
000032  4620              MOV      r0,r4
000034  f7fffffe          BL       rt_schedule_insert_thread
;;;712    
;;;713        /* do schedule */
;;;714        rt_schedule();
000038  f7fffffe          BL       rt_schedule
;;;715    }
00003c  bd10              POP      {r4,pc}
;;;716    RTM_EXPORT(rt_thread_timeout);
                          ENDP

00003e  0000              DCW      0x0000
                  |L17.64|
                          DCD      0x000002bd
                  |L17.68|
                          DCD      ||.constdata||+0x98
                  |L17.72|
000048  74687265          DCB      "thread != RT_NULL",0
00004c  61642021
000050  3d205254
000054  5f4e554c
000058  4c00    
00005a  00                DCB      0
00005b  00                DCB      0
                  |L17.92|
00005c  74687265          DCB      "thread->stat == RT_THREAD_SUSPEND",0
000060  61642d3e
000064  73746174
000068  203d3d20
00006c  52545f54
000070  48524541
000074  445f5355
000078  5350454e
00007c  4400    
00007e  00                DCB      0
00007f  00                DCB      0

                          AREA ||i.rt_thread_yield||, CODE, READONLY, ALIGN=2

                  rt_thread_yield PROC
;;;432     */
;;;433    rt_err_t rt_thread_yield(void)
000000  b570              PUSH     {r4-r6,lr}
;;;434    {
;;;435        register rt_base_t level;
;;;436        struct rt_thread *thread;
;;;437    
;;;438        /* disable interrupt */
;;;439        level = rt_hw_interrupt_disable();
000002  f7fffffe          BL       rt_hw_interrupt_disable
000006  4605              MOV      r5,r0
;;;440    
;;;441        /* set to current thread */
;;;442        thread = rt_current_thread;
000008  4812              LDR      r0,|L18.84|
00000a  6800              LDR      r0,[r0,#0]  ; rt_current_thread
;;;443    
;;;444        /* if the thread stat is READY and on ready queue list */
;;;445        if (thread->stat == RT_THREAD_READY &&
00000c  4601              MOV      r1,r0
00000e  3120              ADDS     r1,r1,#0x20
000010  460e              MOV      r6,r1
000012  7d09              LDRB     r1,[r1,#0x14]
000014  2901              CMP      r1,#1
000016  d117              BNE      |L18.72|
;;;446            thread->tlist.next != thread->tlist.prev)
000018  6982              LDR      r2,[r0,#0x18]
00001a  6941              LDR      r1,[r0,#0x14]
00001c  4291              CMP      r1,r2
00001e  d013              BEQ      |L18.72|
000020  3014              ADDS     r0,r0,#0x14
;;;447        {
;;;448            /* remove thread from thread list */
;;;449            rt_list_remove(&(thread->tlist));
000022  4604              MOV      r4,r0
000024  f7fffffe          BL       rt_list_remove
;;;450    
;;;451            /* put thread to end of ready queue */
;;;452            rt_list_insert_before(&(rt_thread_priority_table[thread->current_priority]),
000028  7d70              LDRB     r0,[r6,#0x15]
00002a  490b              LDR      r1,|L18.88|
00002c  00c0              LSLS     r0,r0,#3
00002e  1840              ADDS     r0,r0,r1
000030  6841              LDR      r1,[r0,#4]
000032  600c              STR      r4,[r1,#0]
000034  6841              LDR      r1,[r0,#4]
000036  6061              STR      r1,[r4,#4]
000038  6044              STR      r4,[r0,#4]
;;;453                                  &(thread->tlist));
;;;454    
;;;455            /* enable interrupt */
;;;456            rt_hw_interrupt_enable(level);
00003a  6020              STR      r0,[r4,#0]
00003c  4628              MOV      r0,r5
00003e  f7fffffe          BL       rt_hw_interrupt_enable
;;;457    
;;;458            rt_schedule();
000042  f7fffffe          BL       rt_schedule
;;;459    
;;;460            return RT_EOK;
000046  e002              B        |L18.78|
                  |L18.72|
;;;461        }
;;;462    
;;;463        /* enable interrupt */
;;;464        rt_hw_interrupt_enable(level);
000048  4628              MOV      r0,r5
00004a  f7fffffe          BL       rt_hw_interrupt_enable
                  |L18.78|
;;;465    
;;;466        return RT_EOK;
00004e  2000              MOVS     r0,#0
;;;467    }
000050  bd70              POP      {r4-r6,pc}
;;;468    RTM_EXPORT(rt_thread_yield);
                          ENDP

000052  0000              DCW      0x0000
                  |L18.84|
                          DCD      rt_current_thread
                  |L18.88|
                          DCD      rt_thread_priority_table

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __FUNCTION__
000000  5f72745f          DCB      0x5f,0x72,0x74,0x5f
000004  74687265          DCB      0x74,0x68,0x72,0x65
000008  61645f69          DCB      0x61,0x64,0x5f,0x69
00000c  6e697400          DCB      0x6e,0x69,0x74,0x00
                  |symbol_number.55|
000010  72745f74          DCB      0x72,0x74,0x5f,0x74
000014  68726561          DCB      0x68,0x72,0x65,0x61
000018  645f696e          DCB      0x64,0x5f,0x69,0x6e
00001c  697400            DCB      0x69,0x74,0x00
                  |symbol_number.56|
00001f  72                DCB      0x72
000020  745f7468          DCB      0x74,0x5f,0x74,0x68
000024  72656164          DCB      0x72,0x65,0x61,0x64
000028  5f737461          DCB      0x5f,0x73,0x74,0x61
00002c  72747570          DCB      0x72,0x74,0x75,0x70
000030  00                DCB      0x00
                  |symbol_number.57|
000031  72745f            DCB      0x72,0x74,0x5f
000034  74687265          DCB      0x74,0x68,0x72,0x65
000038  61645f64          DCB      0x61,0x64,0x5f,0x64
00003c  65746163          DCB      0x65,0x74,0x61,0x63
000040  6800              DCB      0x68,0x00
                  |symbol_number.58|
000042  7274              DCB      0x72,0x74
000044  5f746872          DCB      0x5f,0x74,0x68,0x72
000048  6561645f          DCB      0x65,0x61,0x64,0x5f
00004c  64656c65          DCB      0x64,0x65,0x6c,0x65
000050  746500            DCB      0x74,0x65,0x00
                  |symbol_number.59|
000053  72                DCB      0x72
000054  745f7468          DCB      0x74,0x5f,0x74,0x68
000058  72656164          DCB      0x72,0x65,0x61,0x64
00005c  5f736c65          DCB      0x5f,0x73,0x6c,0x65
000060  657000            DCB      0x65,0x70,0x00
                  |symbol_number.60|
000063  72                DCB      0x72
000064  745f7468          DCB      0x74,0x5f,0x74,0x68
000068  72656164          DCB      0x72,0x65,0x61,0x64
00006c  5f636f6e          DCB      0x5f,0x63,0x6f,0x6e
000070  74726f6c          DCB      0x74,0x72,0x6f,0x6c
000074  00                DCB      0x00
                  |symbol_number.61|
000075  72745f            DCB      0x72,0x74,0x5f
000078  74687265          DCB      0x74,0x68,0x72,0x65
00007c  61645f73          DCB      0x61,0x64,0x5f,0x73
000080  75737065          DCB      0x75,0x73,0x70,0x65
000084  6e6400            DCB      0x6e,0x64,0x00
                  |symbol_number.62|
000087  72                DCB      0x72
000088  745f7468          DCB      0x74,0x5f,0x74,0x68
00008c  72656164          DCB      0x72,0x65,0x61,0x64
000090  5f726573          DCB      0x5f,0x72,0x65,0x73
000094  756d6500          DCB      0x75,0x6d,0x65,0x00
                  |symbol_number.63|
000098  72745f74          DCB      0x72,0x74,0x5f,0x74
00009c  68726561          DCB      0x68,0x72,0x65,0x61
0000a0  645f7469          DCB      0x64,0x5f,0x74,0x69
0000a4  6d656f75          DCB      0x6d,0x65,0x6f,0x75
0000a8  7400              DCB      0x74,0x00
