; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\spi.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\spi.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I.\Libraries\Device\Nuvoton -I..\..\components\finsh -I.\Libraries\CMSIS\Include -I.\Libraries\StdDriver\inc -I..\..\include -I.\APP -I.\Drivers -I..\..\components\drivers\include -I..\..\components\drivers\include\drivers -I..\nuvoton_nuc240 -I.\Libraries\Device\Nuvoton\NUC230_240\Include -I..\..\include -I..\..\components\drivers\usb\usbdevice\class -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=521 -DRT_DEBUG --omf_browse=.\objects\spi.crf Libraries\StdDriver\src\spi.c]
                          THUMB

                          AREA ||i.CLK_GetPLLClockFreq||, CODE, READONLY, ALIGN=2

                  CLK_GetPLLClockFreq PROC
;;;446      */
;;;447    __STATIC_INLINE uint32_t CLK_GetPLLClockFreq(void)
000000  b508              PUSH     {r3,lr}
;;;448    {
;;;449        uint32_t u32PllFreq = 0, u32PllReg;
;;;450        uint32_t u32FIN, u32NF, u32NR, u32NO;
;;;451        uint8_t au8NoTbl[4] = {1, 2, 2, 4};
000002  a011              ADR      r0,|L1.72|
000004  6800              LDR      r0,[r0,#0]
;;;452    
;;;453        u32PllReg = CLK->PLLCON;
000006  9000              STR      r0,[sp,#0]
000008  4810              LDR      r0,|L1.76|
00000a  6a01              LDR      r1,[r0,#0x20]
;;;454    
;;;455        if(u32PllReg & (CLK_PLLCON_PD_Msk | CLK_PLLCON_OE_Msk))
00000c  1300              ASRS     r0,r0,#12
00000e  4201              TST      r1,r0
000010  d001              BEQ      |L1.22|
;;;456            return 0;           /* PLL is in power down mode or fix low */
000012  2000              MOVS     r0,#0
                  |L1.20|
;;;457    
;;;458        if(u32PllReg & CLK_PLLCON_PLL_SRC_HIRC)
;;;459            u32FIN = __HIRC;    /* PLL source clock from HIRC */
;;;460        else
;;;461            u32FIN = __HXT;     /* PLL source clock from HXT */
;;;462    
;;;463        if(u32PllReg & CLK_PLLCON_BP_Msk)
;;;464            return u32FIN;      /* PLL is in bypass mode */
;;;465    
;;;466        /* PLL is output enabled in normal work mode */
;;;467        u32NO = au8NoTbl[((u32PllReg & CLK_PLLCON_OUT_DV_Msk) >> CLK_PLLCON_OUT_DV_Pos)];
;;;468        u32NF = ((u32PllReg & CLK_PLLCON_FB_DV_Msk) >> CLK_PLLCON_FB_DV_Pos) + 2;
;;;469        u32NR = ((u32PllReg & CLK_PLLCON_IN_DV_Msk) >> CLK_PLLCON_IN_DV_Pos) + 2;
;;;470    
;;;471        /* u32FIN is shifted 2 bits to avoid overflow */
;;;472        u32PllFreq = (((u32FIN >> 2) * u32NF) / (u32NR * u32NO) << 2);
;;;473    
;;;474        return u32PllFreq;
;;;475    }
000014  bd08              POP      {r3,pc}
                  |L1.22|
000016  0308              LSLS     r0,r1,#12             ;458
000018  d501              BPL      |L1.30|
00001a  480d              LDR      r0,|L1.80|
00001c  e000              B        |L1.32|
                  |L1.30|
00001e  480d              LDR      r0,|L1.84|
                  |L1.32|
000020  038a              LSLS     r2,r1,#14             ;463
000022  d4f7              BMI      |L1.20|
000024  040a              LSLS     r2,r1,#16             ;467
000026  0f92              LSRS     r2,r2,#30             ;467
000028  466b              MOV      r3,sp                 ;467
00002a  5c9b              LDRB     r3,[r3,r2]            ;467
00002c  05ca              LSLS     r2,r1,#23             ;468
00002e  0489              LSLS     r1,r1,#18             ;469
000030  0dd2              LSRS     r2,r2,#23             ;468
000032  0ec9              LSRS     r1,r1,#27             ;469
000034  1c89              ADDS     r1,r1,#2              ;469
000036  0880              LSRS     r0,r0,#2              ;472
000038  1c92              ADDS     r2,r2,#2              ;472
00003a  4359              MULS     r1,r3,r1              ;472
00003c  4350              MULS     r0,r2,r0              ;472
00003e  f7fffffe          BL       __aeabi_uidivmod
000042  0080              LSLS     r0,r0,#2              ;472
000044  bd08              POP      {r3,pc}
;;;476    
                          ENDP

000046  0000              DCW      0x0000
                  |L1.72|
000048  01020204          DCB      1,2,2,4
                  |L1.76|
                          DCD      0x50000200
                  |L1.80|
                          DCD      0x01518000
                  |L1.84|
                          DCD      0x00b71b00

                          AREA ||i.SPI_ClearIntFlag||, CODE, READONLY, ALIGN=1

                  SPI_ClearIntFlag PROC
;;;575      */
;;;576    void SPI_ClearIntFlag(SPI_T *spi, uint32_t u32Mask)
000000  07ca              LSLS     r2,r1,#31
;;;577    {
000002  d004              BEQ      |L2.14|
;;;578        if(u32Mask & SPI_UNIT_INT_MASK)
;;;579            spi->CNTRL |= SPI_CNTRL_IF_Msk; /* Clear unit transfer interrupt flag */
000004  6802              LDR      r2,[r0,#0]
000006  2301              MOVS     r3,#1
000008  041b              LSLS     r3,r3,#16
00000a  431a              ORRS     r2,r2,r3
00000c  6002              STR      r2,[r0,#0]
                  |L2.14|
;;;580    
;;;581        if(u32Mask & SPI_SSTA_INT_MASK)
00000e  078a              LSLS     r2,r1,#30
000010  d504              BPL      |L2.28|
;;;582            spi->CNTRL2 |= SPI_CNTRL2_SLV_START_INTSTS_Msk; /* Clear slave 3-wire mode start interrupt flag */
000012  6bc2              LDR      r2,[r0,#0x3c]
000014  2301              MOVS     r3,#1
000016  02db              LSLS     r3,r3,#11
000018  431a              ORRS     r2,r2,r3
00001a  63c2              STR      r2,[r0,#0x3c]
                  |L2.28|
;;;583    
;;;584        if(u32Mask & SPI_FIFO_RXOV_INT_MASK)
00001c  06ca              LSLS     r2,r1,#27
00001e  d501              BPL      |L2.36|
;;;585            spi->STATUS = SPI_STATUS_RX_OVERRUN_Msk; /* Clear RX overrun interrupt flag */
000020  2204              MOVS     r2,#4
000022  6442              STR      r2,[r0,#0x44]
                  |L2.36|
;;;586    
;;;587        if(u32Mask & SPI_FIFO_TIMEOUT_INT_MASK)
000024  0689              LSLS     r1,r1,#26
000026  d502              BPL      |L2.46|
;;;588            spi->STATUS = SPI_STATUS_TIMEOUT_Msk; /* Clear RX time-out interrupt flag */
000028  2101              MOVS     r1,#1
00002a  0509              LSLS     r1,r1,#20
00002c  6441              STR      r1,[r0,#0x44]
                  |L2.46|
;;;589    }
00002e  4770              BX       lr
;;;590    
                          ENDP


                          AREA ||i.SPI_ClearRxFIFO||, CODE, READONLY, ALIGN=1

                  SPI_ClearRxFIFO PROC
;;;214      */
;;;215    void SPI_ClearRxFIFO(SPI_T *spi)
000000  6c01              LDR      r1,[r0,#0x40]
;;;216    {
;;;217        spi->FIFO_CTL |= SPI_FIFO_CTL_RX_CLR_Msk;
000002  2201              MOVS     r2,#1
000004  4311              ORRS     r1,r1,r2
000006  6401              STR      r1,[r0,#0x40]
;;;218    }
000008  4770              BX       lr
;;;219    
                          ENDP


                          AREA ||i.SPI_ClearTxFIFO||, CODE, READONLY, ALIGN=1

                  SPI_ClearTxFIFO PROC
;;;225      */
;;;226    void SPI_ClearTxFIFO(SPI_T *spi)
000000  6c01              LDR      r1,[r0,#0x40]
;;;227    {
;;;228        spi->FIFO_CTL |= SPI_FIFO_CTL_TX_CLR_Msk;
000002  2202              MOVS     r2,#2
000004  4311              ORRS     r1,r1,r2
000006  6401              STR      r1,[r0,#0x40]
;;;229    }
000008  4770              BX       lr
;;;230    
                          ENDP


                          AREA ||i.SPI_Close||, CODE, READONLY, ALIGN=2

                  SPI_Close PROC
;;;180      */
;;;181    void SPI_Close(SPI_T *spi)
000000  4a0e              LDR      r2,|L5.60|
;;;182    {
;;;183        if(spi == SPI0)
;;;184        {
;;;185            /* Reset SPI */
;;;186            SYS->IPRSTC2 |= SYS_IPRSTC2_SPI0_RST_Msk;
000002  2105              MOVS     r1,#5
000004  0709              LSLS     r1,r1,#28
000006  4290              CMP      r0,r2                 ;183
000008  d102              BNE      |L5.16|
00000a  68ca              LDR      r2,[r1,#0xc]
00000c  1480              ASRS     r0,r0,#18
;;;187            SYS->IPRSTC2 &= ~SYS_IPRSTC2_SPI0_RST_Msk;
00000e  e005              B        |L5.28|
                  |L5.16|
;;;188        }
;;;189        else if(spi == SPI1)
000010  4a0b              LDR      r2,|L5.64|
000012  4290              CMP      r0,r2
000014  d108              BNE      |L5.40|
;;;190        {
;;;191            /* Reset SPI */
;;;192            SYS->IPRSTC2 |= SYS_IPRSTC2_SPI1_RST_Msk;
000016  68ca              LDR      r2,[r1,#0xc]
000018  2001              MOVS     r0,#1
00001a  0340              LSLS     r0,r0,#13
                  |L5.28|
00001c  4302              ORRS     r2,r2,r0              ;186
00001e  60ca              STR      r2,[r1,#0xc]          ;186
000020  68ca              LDR      r2,[r1,#0xc]          ;187
000022  4382              BICS     r2,r2,r0              ;187
000024  60ca              STR      r2,[r1,#0xc]          ;187
;;;193            SYS->IPRSTC2 &= ~SYS_IPRSTC2_SPI1_RST_Msk;
;;;194        }
;;;195        else if(spi == SPI2)
;;;196        {
;;;197            /* Reset SPI */
;;;198            SYS->IPRSTC2 |= SYS_IPRSTC2_SPI2_RST_Msk;
;;;199            SYS->IPRSTC2 &= ~SYS_IPRSTC2_SPI2_RST_Msk;
;;;200        }
;;;201        else
;;;202        {
;;;203            /* Reset SPI */
;;;204            SYS->IPRSTC2 |= SYS_IPRSTC2_SPI3_RST_Msk;
;;;205            SYS->IPRSTC2 &= ~SYS_IPRSTC2_SPI3_RST_Msk;
;;;206        }
;;;207    }
000026  4770              BX       lr
                  |L5.40|
000028  4a06              LDR      r2,|L5.68|
00002a  4290              CMP      r0,r2                 ;195
00002c  68ca              LDR      r2,[r1,#0xc]          ;204
00002e  d102              BNE      |L5.54|
000030  2001              MOVS     r0,#1                 ;198
000032  0380              LSLS     r0,r0,#14             ;198
000034  e7f2              B        |L5.28|
                  |L5.54|
000036  2001              MOVS     r0,#1                 ;204
000038  03c0              LSLS     r0,r0,#15             ;204
00003a  e7ef              B        |L5.28|
;;;208    
                          ENDP

                  |L5.60|
                          DCD      0x40030000
                  |L5.64|
                          DCD      0x40034000
                  |L5.68|
                          DCD      0x40130000

                          AREA ||i.SPI_DisableAutoSS||, CODE, READONLY, ALIGN=1

                  SPI_DisableAutoSS PROC
;;;236      */
;;;237    void SPI_DisableAutoSS(SPI_T *spi)
000000  6881              LDR      r1,[r0,#8]
;;;238    {
;;;239        spi->SSR &= ~(SPI_SSR_AUTOSS_Msk | SPI_SSR_SSR_Msk);
000002  220b              MOVS     r2,#0xb
000004  4391              BICS     r1,r1,r2
000006  6081              STR      r1,[r0,#8]
;;;240    }
000008  4770              BX       lr
;;;241    
                          ENDP


                          AREA ||i.SPI_DisableFIFO||, CODE, READONLY, ALIGN=1

                  SPI_DisableFIFO PROC
;;;385      */
;;;386    void SPI_DisableFIFO(SPI_T *spi)
000000  6801              LDR      r1,[r0,#0]
;;;387    {
;;;388        spi->CNTRL &= ~SPI_CNTRL_FIFO_Msk;
000002  2201              MOVS     r2,#1
000004  0552              LSLS     r2,r2,#21
000006  4391              BICS     r1,r1,r2
000008  6001              STR      r1,[r0,#0]
;;;389    }
00000a  4770              BX       lr
;;;390    
                          ENDP


                          AREA ||i.SPI_DisableInt||, CODE, READONLY, ALIGN=1

                  SPI_DisableInt PROC
;;;495      */
;;;496    void SPI_DisableInt(SPI_T *spi, uint32_t u32Mask)
000000  07ca              LSLS     r2,r1,#31
;;;497    {
000002  d004              BEQ      |L8.14|
;;;498        /* Disable unit transfer interrupt flag */
;;;499        if((u32Mask & SPI_UNIT_INT_MASK) == SPI_UNIT_INT_MASK)
;;;500            spi->CNTRL &= ~SPI_CNTRL_IE_Msk;
000004  6802              LDR      r2,[r0,#0]
000006  2301              MOVS     r3,#1
000008  045b              LSLS     r3,r3,#17
00000a  439a              BICS     r2,r2,r3
00000c  6002              STR      r2,[r0,#0]
                  |L8.14|
;;;501    
;;;502        /* Disable slave 3-wire mode start interrupt flag */
;;;503        if((u32Mask & SPI_SSTA_INT_MASK) == SPI_SSTA_INT_MASK)
00000e  078a              LSLS     r2,r1,#30
000010  d504              BPL      |L8.28|
;;;504            spi->CNTRL2 &= ~SPI_CNTRL2_SSTA_INTEN_Msk;
000012  6bc2              LDR      r2,[r0,#0x3c]
000014  2301              MOVS     r3,#1
000016  029b              LSLS     r3,r3,#10
000018  439a              BICS     r2,r2,r3
00001a  63c2              STR      r2,[r0,#0x3c]
                  |L8.28|
;;;505    
;;;506        /* Disable TX threshold interrupt flag */
;;;507        if((u32Mask & SPI_FIFO_TX_INT_MASK) == SPI_FIFO_TX_INT_MASK)
00001c  074a              LSLS     r2,r1,#29
00001e  d503              BPL      |L8.40|
;;;508            spi->FIFO_CTL &= ~SPI_FIFO_CTL_TX_INTEN_Msk;
000020  6c02              LDR      r2,[r0,#0x40]
000022  2308              MOVS     r3,#8
000024  439a              BICS     r2,r2,r3
000026  6402              STR      r2,[r0,#0x40]
                  |L8.40|
;;;509    
;;;510        /* Disable RX threshold interrupt flag */
;;;511        if((u32Mask & SPI_FIFO_RX_INT_MASK) == SPI_FIFO_RX_INT_MASK)
000028  070a              LSLS     r2,r1,#28
00002a  d503              BPL      |L8.52|
;;;512            spi->FIFO_CTL &= ~SPI_FIFO_CTL_RX_INTEN_Msk;
00002c  6c02              LDR      r2,[r0,#0x40]
00002e  2304              MOVS     r3,#4
000030  439a              BICS     r2,r2,r3
000032  6402              STR      r2,[r0,#0x40]
                  |L8.52|
;;;513    
;;;514        /* Disable RX overrun interrupt flag */
;;;515        if((u32Mask & SPI_FIFO_RXOV_INT_MASK) == SPI_FIFO_RXOV_INT_MASK)
000034  06ca              LSLS     r2,r1,#27
000036  d503              BPL      |L8.64|
;;;516            spi->FIFO_CTL &= ~SPI_FIFO_CTL_RXOV_INTEN_Msk;
000038  6c02              LDR      r2,[r0,#0x40]
00003a  2340              MOVS     r3,#0x40
00003c  439a              BICS     r2,r2,r3
00003e  6402              STR      r2,[r0,#0x40]
                  |L8.64|
;;;517    
;;;518        /* Disable RX time-out interrupt flag */
;;;519        if((u32Mask & SPI_FIFO_TIMEOUT_INT_MASK) == SPI_FIFO_TIMEOUT_INT_MASK)
000040  0689              LSLS     r1,r1,#26
000042  d504              BPL      |L8.78|
;;;520            spi->FIFO_CTL &= ~SPI_FIFO_CTL_TIMEOUT_INTEN_Msk;
000044  6c01              LDR      r1,[r0,#0x40]
000046  2201              MOVS     r2,#1
000048  0552              LSLS     r2,r2,#21
00004a  4391              BICS     r1,r1,r2
00004c  6401              STR      r1,[r0,#0x40]
                  |L8.78|
;;;521    }
00004e  4770              BX       lr
;;;522    
                          ENDP


                          AREA ||i.SPI_EnableAutoSS||, CODE, READONLY, ALIGN=1

                  SPI_EnableAutoSS PROC
;;;250      */
;;;251    void SPI_EnableAutoSS(SPI_T *spi, uint32_t u32SSPinMask, uint32_t u32ActiveLevel)
000000  6883              LDR      r3,[r0,#8]
;;;252    {
;;;253        spi->SSR = (spi->SSR & (~(SPI_SSR_AUTOSS_Msk | SPI_SSR_SS_LVL_Msk | SPI_SSR_SSR_Msk))) | (u32SSPinMask | u32ActiveLevel | SPI_SSR_AUTOSS_Msk);
000002  4311              ORRS     r1,r1,r2
000004  091b              LSRS     r3,r3,#4
000006  011b              LSLS     r3,r3,#4
000008  430b              ORRS     r3,r3,r1
00000a  2108              MOVS     r1,#8
00000c  430b              ORRS     r3,r3,r1
00000e  6083              STR      r3,[r0,#8]
;;;254    }
000010  4770              BX       lr
;;;255    
                          ENDP


                          AREA ||i.SPI_EnableFIFO||, CODE, READONLY, ALIGN=1

                  SPI_EnableFIFO PROC
;;;370      */
;;;371    void SPI_EnableFIFO(SPI_T *spi, uint32_t u32TxThreshold, uint32_t u32RxThreshold)
000000  0709              LSLS     r1,r1,#28
;;;372    {
;;;373        spi->FIFO_CTL = (spi->FIFO_CTL & ~(SPI_FIFO_CTL_TX_THRESHOLD_Msk | SPI_FIFO_CTL_RX_THRESHOLD_Msk)) |
000002  0612              LSLS     r2,r2,#24
000004  4311              ORRS     r1,r1,r2
000006  6c02              LDR      r2,[r0,#0x40]
000008  2377              MOVS     r3,#0x77
00000a  061b              LSLS     r3,r3,#24
00000c  439a              BICS     r2,r2,r3
00000e  4311              ORRS     r1,r1,r2
000010  6401              STR      r1,[r0,#0x40]
;;;374                        ((u32TxThreshold << SPI_FIFO_CTL_TX_THRESHOLD_Pos) |
;;;375                         (u32RxThreshold << SPI_FIFO_CTL_RX_THRESHOLD_Pos));
;;;376    
;;;377        spi->CNTRL |= SPI_CNTRL_FIFO_Msk;
000012  6801              LDR      r1,[r0,#0]
000014  2201              MOVS     r2,#1
000016  0552              LSLS     r2,r2,#21
000018  4311              ORRS     r1,r1,r2
00001a  6001              STR      r1,[r0,#0]
;;;378    }
00001c  4770              BX       lr
;;;379    
                          ENDP


                          AREA ||i.SPI_EnableInt||, CODE, READONLY, ALIGN=1

                  SPI_EnableInt PROC
;;;457      */
;;;458    void SPI_EnableInt(SPI_T *spi, uint32_t u32Mask)
000000  07ca              LSLS     r2,r1,#31
;;;459    {
000002  d004              BEQ      |L11.14|
;;;460        /* Enable unit transfer interrupt flag */
;;;461        if((u32Mask & SPI_UNIT_INT_MASK) == SPI_UNIT_INT_MASK)
;;;462            spi->CNTRL |= SPI_CNTRL_IE_Msk;
000004  6802              LDR      r2,[r0,#0]
000006  2301              MOVS     r3,#1
000008  045b              LSLS     r3,r3,#17
00000a  431a              ORRS     r2,r2,r3
00000c  6002              STR      r2,[r0,#0]
                  |L11.14|
;;;463    
;;;464        /* Enable slave 3-wire mode start interrupt flag */
;;;465        if((u32Mask & SPI_SSTA_INT_MASK) == SPI_SSTA_INT_MASK)
00000e  078a              LSLS     r2,r1,#30
000010  d504              BPL      |L11.28|
;;;466            spi->CNTRL2 |= SPI_CNTRL2_SSTA_INTEN_Msk;
000012  6bc2              LDR      r2,[r0,#0x3c]
000014  2301              MOVS     r3,#1
000016  029b              LSLS     r3,r3,#10
000018  431a              ORRS     r2,r2,r3
00001a  63c2              STR      r2,[r0,#0x3c]
                  |L11.28|
;;;467    
;;;468        /* Enable TX threshold interrupt flag */
;;;469        if((u32Mask & SPI_FIFO_TX_INT_MASK) == SPI_FIFO_TX_INT_MASK)
00001c  074a              LSLS     r2,r1,#29
00001e  d503              BPL      |L11.40|
;;;470            spi->FIFO_CTL |= SPI_FIFO_CTL_TX_INTEN_Msk;
000020  6c02              LDR      r2,[r0,#0x40]
000022  2308              MOVS     r3,#8
000024  431a              ORRS     r2,r2,r3
000026  6402              STR      r2,[r0,#0x40]
                  |L11.40|
;;;471    
;;;472        /* Enable RX threshold interrupt flag */
;;;473        if((u32Mask & SPI_FIFO_RX_INT_MASK) == SPI_FIFO_RX_INT_MASK)
000028  070a              LSLS     r2,r1,#28
00002a  d503              BPL      |L11.52|
;;;474            spi->FIFO_CTL |= SPI_FIFO_CTL_RX_INTEN_Msk;
00002c  6c02              LDR      r2,[r0,#0x40]
00002e  2304              MOVS     r3,#4
000030  431a              ORRS     r2,r2,r3
000032  6402              STR      r2,[r0,#0x40]
                  |L11.52|
;;;475    
;;;476        /* Enable RX overrun interrupt flag */
;;;477        if((u32Mask & SPI_FIFO_RXOV_INT_MASK) == SPI_FIFO_RXOV_INT_MASK)
000034  06ca              LSLS     r2,r1,#27
000036  d503              BPL      |L11.64|
;;;478            spi->FIFO_CTL |= SPI_FIFO_CTL_RXOV_INTEN_Msk;
000038  6c02              LDR      r2,[r0,#0x40]
00003a  2340              MOVS     r3,#0x40
00003c  431a              ORRS     r2,r2,r3
00003e  6402              STR      r2,[r0,#0x40]
                  |L11.64|
;;;479    
;;;480        /* Enable RX time-out interrupt flag */
;;;481        if((u32Mask & SPI_FIFO_TIMEOUT_INT_MASK) == SPI_FIFO_TIMEOUT_INT_MASK)
000040  0689              LSLS     r1,r1,#26
000042  d504              BPL      |L11.78|
;;;482            spi->FIFO_CTL |= SPI_FIFO_CTL_TIMEOUT_INTEN_Msk;
000044  6c01              LDR      r1,[r0,#0x40]
000046  2201              MOVS     r2,#1
000048  0552              LSLS     r2,r2,#21
00004a  4311              ORRS     r1,r1,r2
00004c  6401              STR      r1,[r0,#0x40]
                  |L11.78|
;;;483    }
00004e  4770              BX       lr
;;;484    
                          ENDP


                          AREA ||i.SPI_GetBusClock||, CODE, READONLY, ALIGN=2

                  SPI_GetBusClock PROC
;;;396      */
;;;397    uint32_t SPI_GetBusClock(SPI_T *spi)
000000  b570              PUSH     {r4-r6,lr}
;;;398    {
000002  4604              MOV      r4,r0
;;;399        uint32_t u32Div;
;;;400        uint32_t u32ClkSrc;
;;;401    
;;;402        /* Get DIVIDER setting */
;;;403        u32Div = (spi->DIVIDER & SPI_DIVIDER_DIVIDER_Msk) >> SPI_DIVIDER_DIVIDER_Pos;
000004  6840              LDR      r0,[r0,#4]
;;;404    
;;;405        /* Check clock source of SPI */
;;;406        if(spi == SPI0)
000006  4913              LDR      r1,|L12.84|
000008  b2c5              UXTB     r5,r0                 ;403
;;;407        {
;;;408            if((CLK->CLKSEL1 & CLK_CLKSEL1_SPI0_S_Msk) == CLK_CLKSEL1_SPI0_S_HCLK)
00000a  4813              LDR      r0,|L12.88|
00000c  428c              CMP      r4,r1                 ;406
00000e  d102              BNE      |L12.22|
000010  6940              LDR      r0,[r0,#0x14]
000012  06c0              LSLS     r0,r0,#27
000014  e004              B        |L12.32|
                  |L12.22|
;;;409                u32ClkSrc = CLK_GetHCLKFreq();
;;;410            else
;;;411                u32ClkSrc = CLK_GetPLLClockFreq();
;;;412        }
;;;413        else if(spi == SPI1)
000016  4911              LDR      r1,|L12.92|
000018  428c              CMP      r4,r1
00001a  d106              BNE      |L12.42|
;;;414        {
;;;415            if((CLK->CLKSEL1 & CLK_CLKSEL1_SPI1_S_Msk) == CLK_CLKSEL1_SPI1_S_HCLK)
00001c  6940              LDR      r0,[r0,#0x14]
00001e  0680              LSLS     r0,r0,#26
                  |L12.32|
000020  2800              CMP      r0,#0                 ;408
000022  da0a              BGE      |L12.58|
;;;416                u32ClkSrc = CLK_GetHCLKFreq();
;;;417            else
;;;418                u32ClkSrc = CLK_GetPLLClockFreq();
;;;419        }
;;;420        else if(spi == SPI2)
;;;421        {
;;;422            if((CLK->CLKSEL1 & CLK_CLKSEL1_SPI2_S_Msk) == CLK_CLKSEL1_SPI2_S_HCLK)
;;;423                u32ClkSrc = CLK_GetHCLKFreq();
;;;424            else
;;;425                u32ClkSrc = CLK_GetPLLClockFreq();
;;;426        }
;;;427        else
;;;428        {
;;;429            if((CLK->CLKSEL1 & CLK_CLKSEL1_SPI3_S_Msk) == CLK_CLKSEL1_SPI3_S_HCLK)
;;;430                u32ClkSrc = CLK_GetHCLKFreq();
000024  f7fffffe          BL       CLK_GetHCLKFreq
000028  e009              B        |L12.62|
                  |L12.42|
00002a  490d              LDR      r1,|L12.96|
00002c  6940              LDR      r0,[r0,#0x14]         ;429
00002e  428c              CMP      r4,r1                 ;420
000030  d101              BNE      |L12.54|
000032  0640              LSLS     r0,r0,#25             ;422
000034  e7f4              B        |L12.32|
                  |L12.54|
000036  0600              LSLS     r0,r0,#24             ;429
000038  e7f2              B        |L12.32|
                  |L12.58|
;;;431            else
;;;432                u32ClkSrc = CLK_GetPLLClockFreq();
00003a  f7fffffe          BL       CLK_GetPLLClockFreq
                  |L12.62|
;;;433        }
;;;434    
;;;435        if(spi->CNTRL2 & SPI_CNTRL2_BCn_Msk)   /* BCn = 1: f_spi = f_spi_clk_src / (DIVIDER + 1) */
00003e  6be1              LDR      r1,[r4,#0x3c]
000040  2900              CMP      r1,#0
000042  da01              BGE      |L12.72|
;;;436        {
;;;437            /* Return SPI bus clock rate */
;;;438            return (u32ClkSrc / (u32Div + 1));
000044  1c69              ADDS     r1,r5,#1
000046  e001              B        |L12.76|
                  |L12.72|
;;;439        }
;;;440        else     /* BCn = 0: f_spi = f_spi_clk_src / ((DIVIDER + 1) * 2) */
;;;441        {
;;;442            /* Return SPI bus clock rate */
;;;443            return (u32ClkSrc / ((u32Div + 1) * 2));
000048  0069              LSLS     r1,r5,#1
00004a  1c89              ADDS     r1,r1,#2
                  |L12.76|
00004c  f7fffffe          BL       __aeabi_uidivmod
;;;444        }
;;;445    }
000050  bd70              POP      {r4-r6,pc}
;;;446    
                          ENDP

000052  0000              DCW      0x0000
                  |L12.84|
                          DCD      0x40030000
                  |L12.88|
                          DCD      0x50000200
                  |L12.92|
                          DCD      0x40034000
                  |L12.96|
                          DCD      0x40130000

                          AREA ||i.SPI_GetIntFlag||, CODE, READONLY, ALIGN=1

                  SPI_GetIntFlag PROC
;;;533      */
;;;534    uint32_t SPI_GetIntFlag(SPI_T *spi, uint32_t u32Mask)
000000  4602              MOV      r2,r0
;;;535    {
;;;536        uint32_t u32IntFlag = 0;
000002  2000              MOVS     r0,#0
;;;537    
;;;538        /* Check unit transfer interrupt flag */
;;;539        if((u32Mask & SPI_UNIT_INT_MASK) && (spi->CNTRL & SPI_CNTRL_IF_Msk))
000004  07cb              LSLS     r3,r1,#31
000006  d003              BEQ      |L13.16|
000008  6813              LDR      r3,[r2,#0]
00000a  03db              LSLS     r3,r3,#15
00000c  d500              BPL      |L13.16|
;;;540            u32IntFlag |= SPI_UNIT_INT_MASK;
00000e  2001              MOVS     r0,#1
                  |L13.16|
;;;541    
;;;542        /* Check slave 3-wire mode start interrupt flag */
;;;543        if((u32Mask & SPI_SSTA_INT_MASK) && (spi->CNTRL2 & SPI_CNTRL2_SLV_START_INTSTS_Msk))
000010  078b              LSLS     r3,r1,#30
000012  d504              BPL      |L13.30|
000014  6bd3              LDR      r3,[r2,#0x3c]
000016  051b              LSLS     r3,r3,#20
000018  d501              BPL      |L13.30|
;;;544            u32IntFlag |= SPI_SSTA_INT_MASK;
00001a  2302              MOVS     r3,#2
00001c  4318              ORRS     r0,r0,r3
                  |L13.30|
;;;545    
;;;546        /* Check TX threshold interrupt flag */
;;;547        if((u32Mask & SPI_FIFO_TX_INT_MASK) && (spi->STATUS & SPI_STATUS_TX_INTSTS_Msk))
00001e  074b              LSLS     r3,r1,#29
000020  d504              BPL      |L13.44|
000022  6c53              LDR      r3,[r2,#0x44]
000024  06db              LSLS     r3,r3,#27
000026  d501              BPL      |L13.44|
;;;548            u32IntFlag |= SPI_FIFO_TX_INT_MASK;
000028  2304              MOVS     r3,#4
00002a  4318              ORRS     r0,r0,r3
                  |L13.44|
;;;549    
;;;550        /* Check RX threshold interrupt flag */
;;;551        if((u32Mask & SPI_FIFO_RX_INT_MASK) && (spi->STATUS & SPI_STATUS_RX_INTSTS_Msk))
00002c  070b              LSLS     r3,r1,#28
00002e  d504              BPL      |L13.58|
000030  6c53              LDR      r3,[r2,#0x44]
000032  07db              LSLS     r3,r3,#31
000034  d001              BEQ      |L13.58|
;;;552            u32IntFlag |= SPI_FIFO_RX_INT_MASK;
000036  2308              MOVS     r3,#8
000038  4318              ORRS     r0,r0,r3
                  |L13.58|
;;;553    
;;;554        /* Check RX overrun interrupt flag */
;;;555        if((u32Mask & SPI_FIFO_RXOV_INT_MASK) && (spi->STATUS & SPI_STATUS_RX_OVERRUN_Msk))
00003a  06cb              LSLS     r3,r1,#27
00003c  d504              BPL      |L13.72|
00003e  6c53              LDR      r3,[r2,#0x44]
000040  075b              LSLS     r3,r3,#29
000042  d501              BPL      |L13.72|
;;;556            u32IntFlag |= SPI_FIFO_RXOV_INT_MASK;
000044  2310              MOVS     r3,#0x10
000046  4318              ORRS     r0,r0,r3
                  |L13.72|
;;;557    
;;;558        /* Check RX time-out interrupt flag */
;;;559        if((u32Mask & SPI_FIFO_TIMEOUT_INT_MASK) && (spi->STATUS & SPI_STATUS_TIMEOUT_Msk))
000048  0689              LSLS     r1,r1,#26
00004a  d504              BPL      |L13.86|
00004c  6c51              LDR      r1,[r2,#0x44]
00004e  02c9              LSLS     r1,r1,#11
000050  d501              BPL      |L13.86|
;;;560            u32IntFlag |= SPI_FIFO_TIMEOUT_INT_MASK;
000052  2120              MOVS     r1,#0x20
000054  4308              ORRS     r0,r0,r1
                  |L13.86|
;;;561    
;;;562        return u32IntFlag;
;;;563    }
000056  4770              BX       lr
;;;564    
                          ENDP


                          AREA ||i.SPI_GetStatus||, CODE, READONLY, ALIGN=1

                  SPI_GetStatus PROC
;;;601      */
;;;602    uint32_t SPI_GetStatus(SPI_T *spi, uint32_t u32Mask)
000000  4602              MOV      r2,r0
;;;603    {
;;;604        uint32_t u32Flag = 0;
000002  2000              MOVS     r0,#0
;;;605    
;;;606        /* Check busy status */
;;;607        if((u32Mask & SPI_BUSY_MASK) && (spi->CNTRL & SPI_CNTRL_GO_BUSY_Msk))
000004  07cb              LSLS     r3,r1,#31
000006  d003              BEQ      |L14.16|
000008  6813              LDR      r3,[r2,#0]
00000a  07db              LSLS     r3,r3,#31
00000c  d000              BEQ      |L14.16|
;;;608            u32Flag |= SPI_BUSY_MASK;
00000e  2001              MOVS     r0,#1
                  |L14.16|
;;;609    
;;;610        /* Check RX empty flag */
;;;611        if((u32Mask & SPI_RX_EMPTY_MASK) && (spi->CNTRL & SPI_CNTRL_RX_EMPTY_Msk))
000010  078b              LSLS     r3,r1,#30
000012  d504              BPL      |L14.30|
000014  6813              LDR      r3,[r2,#0]
000016  01db              LSLS     r3,r3,#7
000018  d501              BPL      |L14.30|
;;;612            u32Flag |= SPI_RX_EMPTY_MASK;
00001a  2302              MOVS     r3,#2
00001c  4318              ORRS     r0,r0,r3
                  |L14.30|
;;;613    
;;;614        /* Check RX full flag */
;;;615        if((u32Mask & SPI_RX_FULL_MASK) && (spi->CNTRL & SPI_CNTRL_RX_FULL_Msk))
00001e  074b              LSLS     r3,r1,#29
000020  d504              BPL      |L14.44|
000022  6813              LDR      r3,[r2,#0]
000024  019b              LSLS     r3,r3,#6
000026  d501              BPL      |L14.44|
;;;616            u32Flag |= SPI_RX_FULL_MASK;
000028  2304              MOVS     r3,#4
00002a  4318              ORRS     r0,r0,r3
                  |L14.44|
;;;617    
;;;618        /* Check TX empty flag */
;;;619        if((u32Mask & SPI_TX_EMPTY_MASK) && (spi->CNTRL & SPI_CNTRL_TX_EMPTY_Msk))
00002c  070b              LSLS     r3,r1,#28
00002e  d504              BPL      |L14.58|
000030  6813              LDR      r3,[r2,#0]
000032  015b              LSLS     r3,r3,#5
000034  d501              BPL      |L14.58|
;;;620            u32Flag |= SPI_TX_EMPTY_MASK;
000036  2308              MOVS     r3,#8
000038  4318              ORRS     r0,r0,r3
                  |L14.58|
;;;621    
;;;622        /* Check TX full flag */
;;;623        if((u32Mask & SPI_TX_FULL_MASK) && (spi->CNTRL & SPI_CNTRL_TX_FULL_Msk))
00003a  06c9              LSLS     r1,r1,#27
00003c  d504              BPL      |L14.72|
00003e  6811              LDR      r1,[r2,#0]
000040  0109              LSLS     r1,r1,#4
000042  d501              BPL      |L14.72|
;;;624            u32Flag |= SPI_TX_FULL_MASK;
000044  2110              MOVS     r1,#0x10
000046  4308              ORRS     r0,r0,r1
                  |L14.72|
;;;625    
;;;626        return u32Flag;
;;;627    }
000048  4770              BX       lr
;;;628    
                          ENDP


                          AREA ||i.SPI_Open||, CODE, READONLY, ALIGN=2

                  SPI_Open PROC
;;;41       */
;;;42     uint32_t SPI_Open(SPI_T *spi,
000000  b5f8              PUSH     {r3-r7,lr}
;;;43                       uint32_t u32MasterSlave,
;;;44                       uint32_t u32SPIMode,
;;;45                       uint32_t u32DataWidth,
;;;46                       uint32_t u32BusClock)
;;;47     {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;48         uint32_t u32ClkSrc = 0, u32Div, u32HCLKFreq;
;;;49     
;;;50         if(u32DataWidth == 32)
000006  2b20              CMP      r3,#0x20
000008  d100              BNE      |L15.12|
;;;51             u32DataWidth = 0;
00000a  2300              MOVS     r3,#0
                  |L15.12|
;;;52     
;;;53         /* Default setting: MSB first, disable unit transfer interrupt, SP_CYCLE = 0. */
;;;54         spi->CNTRL = u32MasterSlave | (u32DataWidth << SPI_CNTRL_TX_BIT_LEN_Pos) | (u32SPIMode);
00000c  00d8              LSLS     r0,r3,#3
00000e  4328              ORRS     r0,r0,r5
000010  4310              ORRS     r0,r0,r2
000012  6020              STR      r0,[r4,#0]
;;;55     
;;;56         /* Set BCn = 1: f_spi = f_spi_clk_src / (DIVIDER + 1) */
;;;57         spi->CNTRL2 |= SPI_CNTRL2_BCn_Msk;
000014  6be0              LDR      r0,[r4,#0x3c]
000016  2101              MOVS     r1,#1
000018  07c9              LSLS     r1,r1,#31
00001a  4308              ORRS     r0,r0,r1
00001c  63e0              STR      r0,[r4,#0x3c]
;;;58         /* Get system clock frequency */
;;;59         u32HCLKFreq = CLK_GetHCLKFreq();
00001e  f7fffffe          BL       CLK_GetHCLKFreq
000022  2100              MOVS     r1,#0
;;;60     
;;;61         if(u32MasterSlave == SPI_MASTER)
;;;62         {
;;;63             /* Default setting: slave select signal is active low; disable automatic slave select function. */
;;;64             spi->SSR = SPI_SS_ACTIVE_LOW;
;;;65     
;;;66             /* Check clock source of SPI */
;;;67             if(spi == SPI0)
000024  4a4d              LDR      r2,|L15.348|
;;;68             {
;;;69                 if((CLK->CLKSEL1 & CLK_CLKSEL1_SPI0_S_Msk) == CLK_CLKSEL1_SPI0_S_HCLK)
000026  4e4e              LDR      r6,|L15.352|
000028  4607              MOV      r7,r0                 ;59
00002a  2d00              CMP      r5,#0                 ;61
00002c  d005              BEQ      |L15.58|
;;;70                     u32ClkSrc = u32HCLKFreq;
;;;71                 else
;;;72                     u32ClkSrc = CLK_GetPLLClockFreq();
;;;73             }
;;;74             else if(spi == SPI1)
;;;75             {
;;;76                 if((CLK->CLKSEL1 & CLK_CLKSEL1_SPI1_S_Msk) == CLK_CLKSEL1_SPI1_S_HCLK)
;;;77                     u32ClkSrc = u32HCLKFreq;
;;;78                 else
;;;79                     u32ClkSrc = CLK_GetPLLClockFreq();
;;;80             }
;;;81             else if(spi == SPI2)
;;;82             {
;;;83                 if((CLK->CLKSEL1 & CLK_CLKSEL1_SPI2_S_Msk) == CLK_CLKSEL1_SPI2_S_HCLK)
;;;84                     u32ClkSrc = u32HCLKFreq;
;;;85                 else
;;;86                     u32ClkSrc = CLK_GetPLLClockFreq();
;;;87             }
;;;88             else
;;;89             {
;;;90                 if((CLK->CLKSEL1 & CLK_CLKSEL1_SPI3_S_Msk) == CLK_CLKSEL1_SPI3_S_HCLK)
;;;91                     u32ClkSrc = u32HCLKFreq;
;;;92                 else
;;;93                     u32ClkSrc = CLK_GetPLLClockFreq();
;;;94             }
;;;95     
;;;96             if(u32BusClock >= u32HCLKFreq)
;;;97             {
;;;98                 /* Select HCLK as the clock source of SPI */
;;;99                 if(spi == SPI0)
;;;100                    CLK->CLKSEL1 = (CLK->CLKSEL1 & (~CLK_CLKSEL1_SPI0_S_Msk)) | CLK_CLKSEL1_SPI0_S_HCLK;
;;;101                else if(spi == SPI1)
;;;102                    CLK->CLKSEL1 = (CLK->CLKSEL1 & (~CLK_CLKSEL1_SPI1_S_Msk)) | CLK_CLKSEL1_SPI1_S_HCLK;
;;;103                else if(spi == SPI2)
;;;104                    CLK->CLKSEL1 = (CLK->CLKSEL1 & (~CLK_CLKSEL1_SPI2_S_Msk)) | CLK_CLKSEL1_SPI2_S_HCLK;
;;;105                else
;;;106                    CLK->CLKSEL1 = (CLK->CLKSEL1 & (~CLK_CLKSEL1_SPI3_S_Msk)) | CLK_CLKSEL1_SPI3_S_HCLK;
;;;107    
;;;108                /* Set DIVIDER = 0 */
;;;109                spi->DIVIDER = 0;
;;;110                /* Return slave peripheral clock rate */
;;;111                return u32HCLKFreq;
;;;112            }
;;;113            else if(u32BusClock >= u32ClkSrc)
;;;114            {
;;;115                /* Set DIVIDER = 0 */
;;;116                spi->DIVIDER = 0;
;;;117                /* Return master peripheral clock rate */
;;;118                return u32ClkSrc;
;;;119            }
;;;120            else if(u32BusClock == 0)
;;;121            {
;;;122                /* Set BCn = 0: f_spi = f_spi_clk_src / ((DIVIDER + 1) * 2) */
;;;123                spi->CNTRL2 &= (~SPI_CNTRL2_BCn_Msk);
;;;124                /* Set DIVIDER to the maximum value 0xFF */
;;;125                spi->DIVIDER = (spi->DIVIDER & (~SPI_DIVIDER_DIVIDER_Msk)) | (0xFF << SPI_DIVIDER_DIVIDER_Pos);
;;;126                /* Return master peripheral clock rate */
;;;127                return (u32ClkSrc / ((0xFF + 1) * 2));
;;;128            }
;;;129            else
;;;130            {
;;;131                u32Div = (((u32ClkSrc * 10) / u32BusClock + 5) / 10) - 1; /* Round to the nearest integer */
;;;132                if(u32Div > 0xFF)
;;;133                {
;;;134                    /* Set BCn = 0: f_spi = f_spi_clk_src / ((DIVIDER + 1) * 2) */
;;;135                    spi->CNTRL2 &= (~SPI_CNTRL2_BCn_Msk);
;;;136                    u32Div = (((u32ClkSrc * 10) / (u32BusClock * 2) + 5) / 10) - 1; /* Round to the nearest integer */
;;;137                    if(u32Div > 0xFF)
;;;138                        u32Div = 0xFF;
;;;139                    spi->DIVIDER = (spi->DIVIDER & (~SPI_DIVIDER_DIVIDER_Msk)) | (u32Div << SPI_DIVIDER_DIVIDER_Pos);
;;;140                    /* Return master peripheral clock rate */
;;;141                    return (u32ClkSrc / ((u32Div + 1) * 2));
;;;142                }
;;;143                else
;;;144                {
;;;145                    spi->DIVIDER = (spi->DIVIDER & (~SPI_DIVIDER_DIVIDER_Msk)) | (u32Div << SPI_DIVIDER_DIVIDER_Pos);
;;;146                    /* Return master peripheral clock rate */
;;;147                    return (u32ClkSrc / (u32Div + 1));
;;;148                }
;;;149            }
;;;150    
;;;151        }
;;;152        else     /* For slave mode, force the SPI peripheral clock rate to system clock rate. */
;;;153        {
;;;154            /* Default setting: slave select signal is low level active. */
;;;155            spi->SSR = SPI_SSR_SS_LTRIG_Msk;
00002e  2010              MOVS     r0,#0x10
000030  60a0              STR      r0,[r4,#8]
;;;156    
;;;157            /* Select HCLK as the clock source of SPI */
;;;158            if(spi == SPI0)
000032  4294              CMP      r4,r2
000034  d17d              BNE      |L15.306|
;;;159                CLK->CLKSEL1 = (CLK->CLKSEL1 & (~CLK_CLKSEL1_SPI0_S_Msk)) | CLK_CLKSEL1_SPI0_S_HCLK;
000036  6972              LDR      r2,[r6,#0x14]
000038  e08b              B        |L15.338|
                  |L15.58|
00003a  2000              MOVS     r0,#0                 ;64
00003c  60a0              STR      r0,[r4,#8]            ;64
00003e  4847              LDR      r0,|L15.348|
000040  4284              CMP      r4,r0                 ;67
000042  d102              BNE      |L15.74|
000044  6970              LDR      r0,[r6,#0x14]         ;69
000046  06c0              LSLS     r0,r0,#27             ;69
000048  e004              B        |L15.84|
                  |L15.74|
00004a  4846              LDR      r0,|L15.356|
00004c  4284              CMP      r4,r0                 ;74
00004e  d105              BNE      |L15.92|
000050  6970              LDR      r0,[r6,#0x14]         ;76
000052  0680              LSLS     r0,r0,#26             ;76
                  |L15.84|
000054  2800              CMP      r0,#0                 ;69
000056  da09              BGE      |L15.108|
000058  463d              MOV      r5,r7                 ;91
00005a  e00a              B        |L15.114|
                  |L15.92|
00005c  4842              LDR      r0,|L15.360|
00005e  4284              CMP      r4,r0                 ;81
000060  6970              LDR      r0,[r6,#0x14]         ;90
000062  d101              BNE      |L15.104|
000064  0640              LSLS     r0,r0,#25             ;83
000066  e7f5              B        |L15.84|
                  |L15.104|
000068  0600              LSLS     r0,r0,#24             ;90
00006a  e7f3              B        |L15.84|
                  |L15.108|
00006c  f7fffffe          BL       CLK_GetPLLClockFreq
000070  4605              MOV      r5,r0                 ;93
                  |L15.114|
000072  9806              LDR      r0,[sp,#0x18]         ;96
000074  42b8              CMP      r0,r7                 ;96
000076  d317              BCC      |L15.168|
000078  4838              LDR      r0,|L15.348|
00007a  4284              CMP      r4,r0                 ;99
00007c  d102              BNE      |L15.132|
00007e  6970              LDR      r0,[r6,#0x14]         ;100
000080  2110              MOVS     r1,#0x10              ;100
000082  e00c              B        |L15.158|
                  |L15.132|
000084  4837              LDR      r0,|L15.356|
000086  4284              CMP      r4,r0                 ;101
000088  d102              BNE      |L15.144|
00008a  6970              LDR      r0,[r6,#0x14]         ;102
00008c  2120              MOVS     r1,#0x20              ;102
00008e  e006              B        |L15.158|
                  |L15.144|
000090  4835              LDR      r0,|L15.360|
000092  4284              CMP      r4,r0                 ;103
000094  6970              LDR      r0,[r6,#0x14]         ;106
000096  d101              BNE      |L15.156|
000098  2140              MOVS     r1,#0x40              ;104
00009a  e000              B        |L15.158|
                  |L15.156|
00009c  2180              MOVS     r1,#0x80              ;106
                  |L15.158|
00009e  4308              ORRS     r0,r0,r1              ;104
0000a0  6170              STR      r0,[r6,#0x14]         ;104
0000a2  2000              MOVS     r0,#0                 ;109
0000a4  6060              STR      r0,[r4,#4]            ;109
0000a6  e057              B        |L15.344|
                  |L15.168|
0000a8  42a8              CMP      r0,r5                 ;113
0000aa  d303              BCC      |L15.180|
0000ac  2000              MOVS     r0,#0                 ;116
0000ae  6060              STR      r0,[r4,#4]            ;116
0000b0  4628              MOV      r0,r5                 ;118
;;;160            else if(spi == SPI1)
;;;161                CLK->CLKSEL1 = (CLK->CLKSEL1 & (~CLK_CLKSEL1_SPI1_S_Msk)) | CLK_CLKSEL1_SPI1_S_HCLK;
;;;162            else if(spi == SPI2)
;;;163                CLK->CLKSEL1 = (CLK->CLKSEL1 & (~CLK_CLKSEL1_SPI2_S_Msk)) | CLK_CLKSEL1_SPI2_S_HCLK;
;;;164            else
;;;165                CLK->CLKSEL1 = (CLK->CLKSEL1 & (~CLK_CLKSEL1_SPI3_S_Msk)) | CLK_CLKSEL1_SPI3_S_HCLK;
;;;166    
;;;167            /* Set DIVIDER = 0 */
;;;168            spi->DIVIDER = 0;
;;;169            /* Return slave peripheral clock rate */
;;;170            return u32HCLKFreq;
;;;171        }
;;;172    
;;;173    }
0000b2  bdf8              POP      {r3-r7,pc}
                  |L15.180|
0000b4  2800              CMP      r0,#0                 ;120
0000b6  d029              BEQ      |L15.268|
0000b8  4628              MOV      r0,r5                 ;131
0000ba  210a              MOVS     r1,#0xa               ;131
0000bc  4348              MULS     r0,r1,r0              ;131
0000be  4606              MOV      r6,r0                 ;131
0000c0  9906              LDR      r1,[sp,#0x18]         ;131
0000c2  f7fffffe          BL       __aeabi_uidivmod
0000c6  210a              MOVS     r1,#0xa               ;131
0000c8  1d40              ADDS     r0,r0,#5              ;131
0000ca  f7fffffe          BL       __aeabi_uidivmod
0000ce  1e40              SUBS     r0,r0,#1              ;131
0000d0  28ff              CMP      r0,#0xff              ;132
0000d2  d926              BLS      |L15.290|
0000d4  6be0              LDR      r0,[r4,#0x3c]         ;135
0000d6  0040              LSLS     r0,r0,#1              ;135
0000d8  0840              LSRS     r0,r0,#1              ;135
0000da  63e0              STR      r0,[r4,#0x3c]         ;135
0000dc  9806              LDR      r0,[sp,#0x18]         ;136
0000de  0041              LSLS     r1,r0,#1              ;136
0000e0  4630              MOV      r0,r6                 ;136
0000e2  f7fffffe          BL       __aeabi_uidivmod
0000e6  210a              MOVS     r1,#0xa               ;136
0000e8  1d40              ADDS     r0,r0,#5              ;136
0000ea  f7fffffe          BL       __aeabi_uidivmod
0000ee  1e40              SUBS     r0,r0,#1              ;136
0000f0  28ff              CMP      r0,#0xff              ;137
0000f2  d900              BLS      |L15.246|
0000f4  20ff              MOVS     r0,#0xff              ;138
                  |L15.246|
0000f6  6861              LDR      r1,[r4,#4]            ;139
0000f8  0a09              LSRS     r1,r1,#8              ;139
0000fa  0209              LSLS     r1,r1,#8              ;139
0000fc  4301              ORRS     r1,r1,r0              ;139
0000fe  6061              STR      r1,[r4,#4]            ;139
000100  0041              LSLS     r1,r0,#1              ;141
000102  4628              MOV      r0,r5                 ;141
000104  1c89              ADDS     r1,r1,#2              ;141
                  |L15.262|
000106  f7fffffe          BL       __aeabi_uidivmod
00010a  bdf8              POP      {r3-r7,pc}
                  |L15.268|
00010c  6be0              LDR      r0,[r4,#0x3c]         ;123
00010e  0040              LSLS     r0,r0,#1              ;123
000110  0840              LSRS     r0,r0,#1              ;123
000112  63e0              STR      r0,[r4,#0x3c]         ;123
000114  6860              LDR      r0,[r4,#4]            ;125
000116  21ff              MOVS     r1,#0xff              ;125
000118  4308              ORRS     r0,r0,r1              ;125
00011a  6060              STR      r0,[r4,#4]            ;125
00011c  0a68              LSRS     r0,r5,#9              ;127
                  |L15.286|
00011e  bdf8              POP      {r3-r7,pc}
000120  e007              B        |L15.306|
                  |L15.290|
000122  6861              LDR      r1,[r4,#4]            ;145
000124  0a09              LSRS     r1,r1,#8              ;145
000126  0209              LSLS     r1,r1,#8              ;145
000128  4301              ORRS     r1,r1,r0              ;145
00012a  6061              STR      r1,[r4,#4]            ;145
00012c  1c41              ADDS     r1,r0,#1              ;147
00012e  4628              MOV      r0,r5                 ;147
000130  e7e9              B        |L15.262|
                  |L15.306|
000132  480c              LDR      r0,|L15.356|
000134  4284              CMP      r4,r0                 ;160
000136  d102              BNE      |L15.318|
000138  6970              LDR      r0,[r6,#0x14]         ;161
00013a  2220              MOVS     r2,#0x20              ;161
00013c  e004              B        |L15.328|
                  |L15.318|
00013e  480a              LDR      r0,|L15.360|
000140  4284              CMP      r4,r0                 ;162
000142  d104              BNE      |L15.334|
000144  6970              LDR      r0,[r6,#0x14]         ;163
000146  2240              MOVS     r2,#0x40              ;163
                  |L15.328|
000148  4310              ORRS     r0,r0,r2              ;163
00014a  6170              STR      r0,[r6,#0x14]         ;163
00014c  e003              B        |L15.342|
                  |L15.334|
00014e  6972              LDR      r2,[r6,#0x14]         ;165
000150  2080              MOVS     r0,#0x80              ;165
                  |L15.338|
000152  4302              ORRS     r2,r2,r0              ;165
000154  6172              STR      r2,[r6,#0x14]         ;165
                  |L15.342|
000156  6061              STR      r1,[r4,#4]            ;168
                  |L15.344|
000158  4638              MOV      r0,r7                 ;170
00015a  e7e0              B        |L15.286|
;;;174    
                          ENDP

                  |L15.348|
                          DCD      0x40030000
                  |L15.352|
                          DCD      0x50000200
                  |L15.356|
                          DCD      0x40034000
                  |L15.360|
                          DCD      0x40130000

                          AREA ||i.SPI_SetBusClock||, CODE, READONLY, ALIGN=2

                  SPI_SetBusClock PROC
;;;266      */
;;;267    uint32_t SPI_SetBusClock(SPI_T *spi, uint32_t u32BusClock)
000000  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;268    {
000002  4604              MOV      r4,r0
;;;269        uint32_t u32ClkSrc, u32HCLKFreq;
;;;270        uint32_t u32Div;
;;;271    
;;;272        /* Set BCn = 1: f_spi = f_spi_clk_src / (DIVIDER + 1) */
;;;273        spi->CNTRL2 |= SPI_CNTRL2_BCn_Msk;
000004  6bc0              LDR      r0,[r0,#0x3c]
000006  b081              SUB      sp,sp,#4              ;268
000008  2101              MOVS     r1,#1
00000a  07c9              LSLS     r1,r1,#31
00000c  4308              ORRS     r0,r0,r1
00000e  63e0              STR      r0,[r4,#0x3c]
;;;274        /* Get system clock frequency */
;;;275        u32HCLKFreq = CLK_GetHCLKFreq();
000010  f7fffffe          BL       CLK_GetHCLKFreq
000014  4606              MOV      r6,r0
;;;276    
;;;277        /* Check clock source of SPI */
;;;278        if(spi == SPI0)
000016  483d              LDR      r0,|L16.268|
;;;279        {
;;;280            if((CLK->CLKSEL1 & CLK_CLKSEL1_SPI0_S_Msk) == CLK_CLKSEL1_SPI0_S_HCLK)
000018  4f3d              LDR      r7,|L16.272|
00001a  4284              CMP      r4,r0                 ;278
00001c  d102              BNE      |L16.36|
00001e  6978              LDR      r0,[r7,#0x14]
000020  06c0              LSLS     r0,r0,#27
000022  e004              B        |L16.46|
                  |L16.36|
;;;281                u32ClkSrc = u32HCLKFreq;
;;;282            else
;;;283                u32ClkSrc = CLK_GetPLLClockFreq();
;;;284        }
;;;285        else if(spi == SPI1)
000024  483b              LDR      r0,|L16.276|
000026  4284              CMP      r4,r0
000028  d105              BNE      |L16.54|
;;;286        {
;;;287            if((CLK->CLKSEL1 & CLK_CLKSEL1_SPI1_S_Msk) == CLK_CLKSEL1_SPI1_S_HCLK)
00002a  6978              LDR      r0,[r7,#0x14]
00002c  0680              LSLS     r0,r0,#26
                  |L16.46|
00002e  2800              CMP      r0,#0                 ;280
000030  da09              BGE      |L16.70|
;;;288                u32ClkSrc = u32HCLKFreq;
;;;289            else
;;;290                u32ClkSrc = CLK_GetPLLClockFreq();
;;;291        }
;;;292        else if(spi == SPI2)
;;;293        {
;;;294            if((CLK->CLKSEL1 & CLK_CLKSEL1_SPI2_S_Msk) == CLK_CLKSEL1_SPI2_S_HCLK)
;;;295                u32ClkSrc = u32HCLKFreq;
;;;296            else
;;;297                u32ClkSrc = CLK_GetPLLClockFreq();
;;;298        }
;;;299        else
;;;300        {
;;;301            if((CLK->CLKSEL1 & CLK_CLKSEL1_SPI3_S_Msk) == CLK_CLKSEL1_SPI3_S_HCLK)
;;;302                u32ClkSrc = u32HCLKFreq;
000032  4635              MOV      r5,r6
000034  e00a              B        |L16.76|
                  |L16.54|
000036  4838              LDR      r0,|L16.280|
000038  4284              CMP      r4,r0                 ;292
00003a  6978              LDR      r0,[r7,#0x14]         ;301
00003c  d101              BNE      |L16.66|
00003e  0640              LSLS     r0,r0,#25             ;294
000040  e7f5              B        |L16.46|
                  |L16.66|
000042  0600              LSLS     r0,r0,#24             ;301
000044  e7f3              B        |L16.46|
                  |L16.70|
;;;303            else
;;;304                u32ClkSrc = CLK_GetPLLClockFreq();
000046  f7fffffe          BL       CLK_GetPLLClockFreq
00004a  4605              MOV      r5,r0
                  |L16.76|
;;;305        }
;;;306    
;;;307        if(u32BusClock >= u32HCLKFreq)
00004c  9902              LDR      r1,[sp,#8]
00004e  2000              MOVS     r0,#0
000050  42b1              CMP      r1,r6
000052  d317              BCC      |L16.132|
;;;308        {
;;;309            /* Select HCLK as the clock source of SPI */
;;;310            if(spi == SPI0)
000054  492d              LDR      r1,|L16.268|
000056  428c              CMP      r4,r1
000058  d102              BNE      |L16.96|
;;;311                CLK->CLKSEL1 = (CLK->CLKSEL1 & (~CLK_CLKSEL1_SPI0_S_Msk)) | CLK_CLKSEL1_SPI0_S_HCLK;
00005a  6979              LDR      r1,[r7,#0x14]
00005c  2210              MOVS     r2,#0x10
00005e  e00c              B        |L16.122|
                  |L16.96|
;;;312            else if(spi == SPI1)
000060  492c              LDR      r1,|L16.276|
000062  428c              CMP      r4,r1
000064  d102              BNE      |L16.108|
;;;313                CLK->CLKSEL1 = (CLK->CLKSEL1 & (~CLK_CLKSEL1_SPI1_S_Msk)) | CLK_CLKSEL1_SPI1_S_HCLK;
000066  6979              LDR      r1,[r7,#0x14]
000068  2220              MOVS     r2,#0x20
00006a  e006              B        |L16.122|
                  |L16.108|
;;;314            else if(spi == SPI2)
00006c  492a              LDR      r1,|L16.280|
00006e  428c              CMP      r4,r1
;;;315                CLK->CLKSEL1 = (CLK->CLKSEL1 & (~CLK_CLKSEL1_SPI2_S_Msk)) | CLK_CLKSEL1_SPI2_S_HCLK;
;;;316            else
;;;317                CLK->CLKSEL1 = (CLK->CLKSEL1 & (~CLK_CLKSEL1_SPI3_S_Msk)) | CLK_CLKSEL1_SPI3_S_HCLK;
000070  6979              LDR      r1,[r7,#0x14]
000072  d101              BNE      |L16.120|
000074  2240              MOVS     r2,#0x40              ;315
000076  e000              B        |L16.122|
                  |L16.120|
000078  2280              MOVS     r2,#0x80
                  |L16.122|
00007a  4311              ORRS     r1,r1,r2              ;315
00007c  6179              STR      r1,[r7,#0x14]         ;315
;;;318    
;;;319            /* Set DIVIDER = 0 */
;;;320            spi->DIVIDER = 0;
00007e  6060              STR      r0,[r4,#4]
;;;321            /* Return slave peripheral clock rate */
;;;322            return u32HCLKFreq;
000080  4630              MOV      r0,r6
;;;323        }
;;;324        else if(u32BusClock >= u32ClkSrc)
;;;325        {
;;;326            /* Set DIVIDER = 0 */
;;;327            spi->DIVIDER = 0;
;;;328            /* Return master peripheral clock rate */
;;;329            return u32ClkSrc;
;;;330        }
;;;331        else if(u32BusClock == 0)
;;;332        {
;;;333            /* Set BCn = 0: f_spi = f_spi_clk_src / ((DIVIDER + 1) * 2) */
;;;334            spi->CNTRL2 &= (~SPI_CNTRL2_BCn_Msk);
;;;335            /* Set DIVIDER to the maximum value 0xFF */
;;;336            spi->DIVIDER = (spi->DIVIDER & (~SPI_DIVIDER_DIVIDER_Msk)) | (0xFF << SPI_DIVIDER_DIVIDER_Pos);
;;;337            /* Return master peripheral clock rate */
;;;338            return (u32ClkSrc / ((0xFF + 1) * 2));
;;;339        }
;;;340        else
;;;341        {
;;;342            u32Div = (((u32ClkSrc * 10) / u32BusClock + 5) / 10) - 1; /* Round to the nearest integer */
;;;343            if(u32Div > 0xFF)
;;;344            {
;;;345                /* Set BCn = 0: f_spi = f_spi_clk_src / ((DIVIDER + 1) * 2) */
;;;346                spi->CNTRL2 &= (~SPI_CNTRL2_BCn_Msk);
;;;347                u32Div = (((u32ClkSrc * 10) / (u32BusClock * 2) + 5) / 10) - 1; /* Round to the nearest integer */
;;;348                if(u32Div > 0xFF)
;;;349                    u32Div = 0xFF;
;;;350                spi->DIVIDER = (spi->DIVIDER & (~SPI_DIVIDER_DIVIDER_Msk)) | (u32Div << SPI_DIVIDER_DIVIDER_Pos);
;;;351                /* Return master peripheral clock rate */
;;;352                return (u32ClkSrc / ((u32Div + 1) * 2));
;;;353            }
;;;354            else
;;;355            {
;;;356                spi->DIVIDER = (spi->DIVIDER & (~SPI_DIVIDER_DIVIDER_Msk)) | (u32Div << SPI_DIVIDER_DIVIDER_Pos);
;;;357                /* Return master peripheral clock rate */
;;;358                return (u32ClkSrc / (u32Div + 1));
;;;359            }
;;;360        }
;;;361    }
000082  bdfe              POP      {r1-r7,pc}
                  |L16.132|
000084  42a9              CMP      r1,r5                 ;324
000086  d302              BCC      |L16.142|
000088  6060              STR      r0,[r4,#4]            ;327
00008a  4628              MOV      r0,r5                 ;329
00008c  bdfe              POP      {r1-r7,pc}
                  |L16.142|
00008e  2900              CMP      r1,#0                 ;331
000090  d029              BEQ      |L16.230|
000092  4628              MOV      r0,r5                 ;342
000094  210a              MOVS     r1,#0xa               ;342
000096  4348              MULS     r0,r1,r0              ;342
000098  4606              MOV      r6,r0                 ;342
00009a  9902              LDR      r1,[sp,#8]            ;342
00009c  f7fffffe          BL       __aeabi_uidivmod
0000a0  210a              MOVS     r1,#0xa               ;342
0000a2  1d40              ADDS     r0,r0,#5              ;342
0000a4  f7fffffe          BL       __aeabi_uidivmod
0000a8  1e40              SUBS     r0,r0,#1              ;342
0000aa  28ff              CMP      r0,#0xff              ;343
0000ac  d925              BLS      |L16.250|
0000ae  6be0              LDR      r0,[r4,#0x3c]         ;346
0000b0  0040              LSLS     r0,r0,#1              ;346
0000b2  0840              LSRS     r0,r0,#1              ;346
0000b4  63e0              STR      r0,[r4,#0x3c]         ;346
0000b6  9802              LDR      r0,[sp,#8]            ;347
0000b8  0041              LSLS     r1,r0,#1              ;347
0000ba  4630              MOV      r0,r6                 ;347
0000bc  f7fffffe          BL       __aeabi_uidivmod
0000c0  210a              MOVS     r1,#0xa               ;347
0000c2  1d40              ADDS     r0,r0,#5              ;347
0000c4  f7fffffe          BL       __aeabi_uidivmod
0000c8  1e40              SUBS     r0,r0,#1              ;347
0000ca  28ff              CMP      r0,#0xff              ;348
0000cc  d900              BLS      |L16.208|
0000ce  20ff              MOVS     r0,#0xff              ;349
                  |L16.208|
0000d0  6861              LDR      r1,[r4,#4]            ;350
0000d2  0a09              LSRS     r1,r1,#8              ;350
0000d4  0209              LSLS     r1,r1,#8              ;350
0000d6  4301              ORRS     r1,r1,r0              ;350
0000d8  6061              STR      r1,[r4,#4]            ;350
0000da  0041              LSLS     r1,r0,#1              ;352
0000dc  4628              MOV      r0,r5                 ;352
0000de  1c89              ADDS     r1,r1,#2              ;352
                  |L16.224|
0000e0  f7fffffe          BL       __aeabi_uidivmod
0000e4  bdfe              POP      {r1-r7,pc}
                  |L16.230|
0000e6  6be0              LDR      r0,[r4,#0x3c]         ;334
0000e8  0040              LSLS     r0,r0,#1              ;334
0000ea  0840              LSRS     r0,r0,#1              ;334
0000ec  63e0              STR      r0,[r4,#0x3c]         ;334
0000ee  6860              LDR      r0,[r4,#4]            ;336
0000f0  21ff              MOVS     r1,#0xff              ;336
0000f2  4308              ORRS     r0,r0,r1              ;336
0000f4  6060              STR      r0,[r4,#4]            ;336
0000f6  0a68              LSRS     r0,r5,#9              ;338
0000f8  bdfe              POP      {r1-r7,pc}
                  |L16.250|
0000fa  6861              LDR      r1,[r4,#4]            ;356
0000fc  0a09              LSRS     r1,r1,#8              ;356
0000fe  0209              LSLS     r1,r1,#8              ;356
000100  4301              ORRS     r1,r1,r0              ;356
000102  6061              STR      r1,[r4,#4]            ;356
000104  1c41              ADDS     r1,r0,#1              ;358
000106  4628              MOV      r0,r5                 ;358
000108  e7ea              B        |L16.224|
;;;362    
                          ENDP

00010a  0000              DCW      0x0000
                  |L16.268|
                          DCD      0x40030000
                  |L16.272|
                          DCD      0x50000200
                  |L16.276|
                          DCD      0x40034000
                  |L16.280|
                          DCD      0x40130000

;*** Start embedded assembler ***

#line 1 "Libraries\\StdDriver\\src\\spi.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_spi_c_SPI_Open____REV16|
#line 118 ".\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___5_spi_c_SPI_Open____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_spi_c_SPI_Open____REVSH|
#line 132
|__asm___5_spi_c_SPI_Open____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
