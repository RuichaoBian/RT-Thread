; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\kservice.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\kservice.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I.\Libraries\Device\Nuvoton -I..\..\components\finsh -I.\Libraries\CMSIS\Include -I.\Libraries\StdDriver\inc -I..\..\include -I.\APP -I.\Drivers -I..\..\components\drivers\include -I..\..\components\drivers\include\drivers -I..\nuvoton_nuc240 -I.\Libraries\Device\Nuvoton\NUC230_240\Include -I..\..\include -I..\..\components\drivers\usb\usbdevice\class -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=521 -DRT_DEBUG --omf_browse=.\objects\kservice.crf ..\..\src\kservice.c]
                          THUMB

                          AREA ||i.__rt_ffs||, CODE, READONLY, ALIGN=2

                  __rt_ffs PROC
;;;1268    */
;;;1269   rt_ubase_t __rt_ffs(rt_ubase_t value)
000000  2800              CMP      r0,#0
;;;1270   {
000002  d006              BEQ      |L1.18|
;;;1271       if (value == 0) return 0;
;;;1272   
;;;1273       if (value & 0xff)
000004  0602              LSLS     r2,r0,#24
;;;1274           return __lowest_bit_bitmap[value & 0xff] + 1;
000006  490d              LDR      r1,|L1.60|
000008  0e12              LSRS     r2,r2,#24             ;1273
00000a  d003              BEQ      |L1.20|
00000c  b2c0              UXTB     r0,r0
00000e  5c08              LDRB     r0,[r1,r0]
000010  1c40              ADDS     r0,r0,#1
                  |L1.18|
;;;1275   
;;;1276       if (value & 0xff00)
;;;1277           return __lowest_bit_bitmap[(value & 0xff00) >> 8] + 9;
;;;1278   
;;;1279       if (value & 0xff0000)
;;;1280           return __lowest_bit_bitmap[(value & 0xff0000) >> 16] + 17;
;;;1281   
;;;1282       return __lowest_bit_bitmap[(value & 0xff000000) >> 24] + 25;
;;;1283   }
000012  4770              BX       lr
                  |L1.20|
000014  0402              LSLS     r2,r0,#16             ;1276
000016  0e12              LSRS     r2,r2,#24             ;1276
000018  d004              BEQ      |L1.36|
00001a  0400              LSLS     r0,r0,#16             ;1277
00001c  0e00              LSRS     r0,r0,#24             ;1277
00001e  5c08              LDRB     r0,[r1,r0]            ;1277
000020  3009              ADDS     r0,r0,#9              ;1277
000022  4770              BX       lr
                  |L1.36|
000024  0202              LSLS     r2,r0,#8              ;1279
000026  0e12              LSRS     r2,r2,#24             ;1279
000028  d004              BEQ      |L1.52|
00002a  0200              LSLS     r0,r0,#8              ;1280
00002c  0e00              LSRS     r0,r0,#24             ;1280
00002e  5c08              LDRB     r0,[r1,r0]            ;1280
000030  3011              ADDS     r0,r0,#0x11           ;1280
000032  4770              BX       lr
                  |L1.52|
000034  0e00              LSRS     r0,r0,#24             ;1282
000036  5c08              LDRB     r0,[r1,r0]            ;1282
000038  3019              ADDS     r0,r0,#0x19           ;1282
00003a  4770              BX       lr
;;;1284   #endif
                          ENDP

                  |L1.60|
                          DCD      ||.constdata||

                          AREA ||i._rt_errno||, CODE, READONLY, ALIGN=2

                  _rt_errno PROC
;;;111     */
;;;112    int *_rt_errno(void)
000000  b510              PUSH     {r4,lr}
;;;113    {
;;;114        rt_thread_t tid;
;;;115    
;;;116        if (rt_interrupt_get_nest() != 0)
000002  f7fffffe          BL       rt_interrupt_get_nest
000006  2800              CMP      r0,#0
000008  d105              BNE      |L2.22|
;;;117            return (int *)&_errno;
;;;118    
;;;119        tid = rt_thread_self();
00000a  f7fffffe          BL       rt_thread_self
;;;120        if (tid != RT_NULL)
00000e  2800              CMP      r0,#0
000010  d001              BEQ      |L2.22|
000012  3030              ADDS     r0,r0,#0x30
;;;121            return (int *)&(tid->error);
;;;122    
;;;123        return (int *)&_errno;
;;;124    }
000014  bd10              POP      {r4,pc}
                  |L2.22|
000016  4801              LDR      r0,|L2.28|
000018  bd10              POP      {r4,pc}
;;;125    RTM_EXPORT(_rt_errno);
                          ENDP

00001a  0000              DCW      0x0000
                  |L2.28|
                          DCD      ||.data||+0x4

                          AREA ||i.print_number||, CODE, READONLY, ALIGN=2

                  print_number PROC
;;;580    #ifdef RT_PRINTF_PRECISION
;;;581    static char *print_number(char *buf,
000000  b5ff              PUSH     {r0-r7,lr}
;;;582                              char *end,
;;;583                              long  num,
;;;584                              int   base,
;;;585                              int   s,
;;;586                              int   precision,
;;;587                              int   type)
;;;588    #else
;;;589    static char *print_number(char *buf,
;;;590                              char *end,
;;;591                              long  num,
;;;592                              int   base,
;;;593                              int   s,
;;;594                              int   type)
;;;595    #endif
;;;596    {
000002  b089              SUB      sp,sp,#0x24
000004  4604              MOV      r4,r0
;;;597        char c, sign;
;;;598    #ifdef RT_PRINTF_LONGLONG
;;;599        char tmp[32];
;;;600    #else
;;;601        char tmp[16];
;;;602    #endif
;;;603        const char *digits;
;;;604        static const char small_digits[] = "0123456789abcdef";
;;;605        static const char large_digits[] = "0123456789ABCDEF";
;;;606        register int i;
;;;607        register int size;
;;;608    
;;;609        size = s;
000006  9f14              LDR      r7,[sp,#0x50]
000008  9812              LDR      r0,[sp,#0x48]
;;;610    
;;;611        digits = (type & LARGE) ? large_digits : small_digits;
00000a  9005              STR      r0,[sp,#0x14]
00000c  460e              MOV      r6,r1                 ;596
00000e  0678              LSLS     r0,r7,#25
000010  d501              BPL      |L3.22|
000012  4847              LDR      r0,|L3.304|
000014  e001              B        |L3.26|
                  |L3.22|
000016  4846              LDR      r0,|L3.304|
000018  3811              SUBS     r0,r0,#0x11
                  |L3.26|
;;;612        if (type & LEFT)
00001a  9007              STR      r0,[sp,#0x1c]
00001c  06f8              LSLS     r0,r7,#27
00001e  d501              BPL      |L3.36|
;;;613            type &= ~ZEROPAD;
000020  087f              LSRS     r7,r7,#1
000022  007f              LSLS     r7,r7,#1
                  |L3.36|
;;;614    
;;;615        c = (type & ZEROPAD) ? '0' : ' ';
000024  07f8              LSLS     r0,r7,#31
000026  d001              BEQ      |L3.44|
000028  2030              MOVS     r0,#0x30
00002a  e000              B        |L3.46|
                  |L3.44|
00002c  2020              MOVS     r0,#0x20
                  |L3.46|
;;;616    
;;;617        /* get sign */
;;;618        sign = 0;
00002e  9006              STR      r0,[sp,#0x18]
000030  2000              MOVS     r0,#0
;;;619        if (type & SIGN)
000032  9000              STR      r0,[sp,#0]
000034  07b8              LSLS     r0,r7,#30
000036  d50d              BPL      |L3.84|
;;;620        {
;;;621            if (num < 0)
000038  2a00              CMP      r2,#0
00003a  da03              BGE      |L3.68|
;;;622            {
;;;623                sign = '-';
00003c  202d              MOVS     r0,#0x2d
;;;624                num = -num;
00003e  4252              RSBS     r2,r2,#0
000040  9000              STR      r0,[sp,#0]
000042  e007              B        |L3.84|
                  |L3.68|
;;;625            }
;;;626            else if (type & PLUS)
000044  0778              LSLS     r0,r7,#29
000046  d501              BPL      |L3.76|
;;;627                sign = '+';
000048  202b              MOVS     r0,#0x2b
00004a  e002              B        |L3.82|
                  |L3.76|
;;;628            else if (type & SPACE)
00004c  0738              LSLS     r0,r7,#28
00004e  d501              BPL      |L3.84|
;;;629                sign = ' ';
000050  2020              MOVS     r0,#0x20
                  |L3.82|
000052  9000              STR      r0,[sp,#0]
                  |L3.84|
;;;630        }
;;;631    
;;;632    #ifdef RT_PRINTF_SPECIAL
;;;633        if (type & SPECIAL)
;;;634        {
;;;635            if (base == 16)
;;;636                size -= 2;
;;;637            else if (base == 8)
;;;638                size--;
;;;639        }
;;;640    #endif
;;;641    
;;;642        i = 0;
000054  2500              MOVS     r5,#0
;;;643        if (num == 0)
000056  2a00              CMP      r2,#0
000058  d104              BNE      |L3.100|
;;;644            tmp[i++]='0';
00005a  2030              MOVS     r0,#0x30
00005c  4669              MOV      r1,sp
00005e  7108              STRB     r0,[r1,#4]
000060  2501              MOVS     r5,#1
000062  e00c              B        |L3.126|
                  |L3.100|
000064  980c              LDR      r0,[sp,#0x30]
000066  280a              CMP      r0,#0xa
000068  d016              BEQ      |L3.152|
00006a  0711              LSLS     r1,r2,#28
00006c  0f09              LSRS     r1,r1,#28
00006e  0912              LSRS     r2,r2,#4
                  |L3.112|
;;;645        else
;;;646        {
;;;647            while (num != 0)
;;;648                tmp[i++] = digits[divide(&num, base)];
000070  9807              LDR      r0,[sp,#0x1c]
000072  5c41              LDRB     r1,[r0,r1]
000074  a801              ADD      r0,sp,#4
000076  5541              STRB     r1,[r0,r5]
000078  1c6d              ADDS     r5,r5,#1
00007a  2a00              CMP      r2,#0                 ;647
00007c  d1f2              BNE      |L3.100|
                  |L3.126|
;;;649        }
;;;650    
;;;651    #ifdef RT_PRINTF_PRECISION
;;;652        if (i > precision)
00007e  9813              LDR      r0,[sp,#0x4c]
000080  4285              CMP      r5,r0
000082  dd00              BLE      |L3.134|
;;;653            precision = i;
000084  9513              STR      r5,[sp,#0x4c]
                  |L3.134|
;;;654        size -= precision;
000086  9913              LDR      r1,[sp,#0x4c]
000088  9805              LDR      r0,[sp,#0x14]
00008a  2220              MOVS     r2,#0x20              ;615
00008c  1a40              SUBS     r0,r0,r1
;;;655    #else
;;;656        size -= i;
;;;657    #endif
;;;658    
;;;659        if (!(type&(ZEROPAD | LEFT)))
00008e  2111              MOVS     r1,#0x11
000090  4039              ANDS     r1,r1,r7
000092  2900              CMP      r1,#0
000094  d006              BEQ      |L3.164|
000096  e014              B        |L3.194|
                  |L3.152|
000098  4610              MOV      r0,r2
00009a  210a              MOVS     r1,#0xa
00009c  f7fffffe          BL       __aeabi_uidivmod
0000a0  4602              MOV      r2,r0
0000a2  e7e5              B        |L3.112|
                  |L3.164|
;;;660        {
;;;661            if ((sign)&&(size>0))
0000a4  9900              LDR      r1,[sp,#0]
0000a6  2900              CMP      r1,#0
0000a8  d007              BEQ      |L3.186|
0000aa  2800              CMP      r0,#0
0000ac  dd05              BLE      |L3.186|
0000ae  1e40              SUBS     r0,r0,#1
;;;662                size--;
0000b0  e003              B        |L3.186|
                  |L3.178|
;;;663    
;;;664            while (size-->0)
;;;665            {
;;;666                if (buf <= end)
0000b2  42b4              CMP      r4,r6
0000b4  d800              BHI      |L3.184|
;;;667                    *buf = ' ';
0000b6  7022              STRB     r2,[r4,#0]
                  |L3.184|
0000b8  1c64              ADDS     r4,r4,#1
                  |L3.186|
0000ba  4601              MOV      r1,r0                 ;664
0000bc  1e40              SUBS     r0,r0,#1              ;664
0000be  2900              CMP      r1,#0                 ;664
0000c0  dcf7              BGT      |L3.178|
                  |L3.194|
;;;668                ++ buf;
;;;669            }
;;;670        }
;;;671    
;;;672        if (sign)
0000c2  9900              LDR      r1,[sp,#0]
0000c4  2900              CMP      r1,#0
0000c6  d004              BEQ      |L3.210|
;;;673        {
;;;674            if (buf <= end)
0000c8  42b4              CMP      r4,r6
0000ca  d801              BHI      |L3.208|
;;;675            {
;;;676                *buf = sign;
0000cc  7021              STRB     r1,[r4,#0]
0000ce  1e40              SUBS     r0,r0,#1
                  |L3.208|
0000d0  1c64              ADDS     r4,r4,#1
                  |L3.210|
;;;677                -- size;
;;;678            }
;;;679            ++ buf;
;;;680        }
;;;681    
;;;682    #ifdef RT_PRINTF_SPECIAL
;;;683        if (type & SPECIAL)
;;;684        {
;;;685            if (base==8)
;;;686            {
;;;687                if (buf <= end)
;;;688                    *buf = '0';
;;;689                ++ buf;
;;;690            }
;;;691            else if (base == 16)
;;;692            {
;;;693                if (buf <= end)
;;;694                    *buf = '0';
;;;695                ++ buf;
;;;696                if (buf <= end)
;;;697                {
;;;698                    *buf = type & LARGE? 'X' : 'x';
;;;699                }
;;;700                ++ buf;
;;;701            }
;;;702        }
;;;703    #endif
;;;704    
;;;705        /* no align to the left */
;;;706        if (!(type & LEFT))
0000d2  06f9              LSLS     r1,r7,#27
0000d4  d505              BPL      |L3.226|
0000d6  e008              B        |L3.234|
                  |L3.216|
;;;707        {
;;;708            while (size-- > 0)
;;;709            {
;;;710                if (buf <= end)
0000d8  42b4              CMP      r4,r6
0000da  d801              BHI      |L3.224|
;;;711                    *buf = c;
0000dc  9906              LDR      r1,[sp,#0x18]
0000de  7021              STRB     r1,[r4,#0]
                  |L3.224|
0000e0  1c64              ADDS     r4,r4,#1
                  |L3.226|
0000e2  4601              MOV      r1,r0                 ;708
0000e4  1e40              SUBS     r0,r0,#1              ;708
0000e6  2900              CMP      r1,#0                 ;708
0000e8  dcf6              BGT      |L3.216|
                  |L3.234|
0000ea  2330              MOVS     r3,#0x30              ;615
                  |L3.236|
;;;712                ++ buf;
;;;713            }
;;;714        }
;;;715    
;;;716    #ifdef RT_PRINTF_PRECISION
;;;717        while (i < precision--)
0000ec  9f13              LDR      r7,[sp,#0x4c]
0000ee  1e79              SUBS     r1,r7,#1
0000f0  9113              STR      r1,[sp,#0x4c]
0000f2  42af              CMP      r7,r5
0000f4  dd0a              BLE      |L3.268|
;;;718        {
;;;719            if (buf <= end)
0000f6  42b4              CMP      r4,r6
0000f8  d800              BHI      |L3.252|
;;;720                *buf = '0';
0000fa  7023              STRB     r3,[r4,#0]
                  |L3.252|
0000fc  1c64              ADDS     r4,r4,#1
;;;721            ++ buf;
0000fe  e7f5              B        |L3.236|
                  |L3.256|
;;;722        }
;;;723    #endif
;;;724    
;;;725        /* put number in the temporary buffer */
;;;726        while (i-- > 0)
;;;727        {
;;;728            if (buf <= end)
000100  42b4              CMP      r4,r6
000102  d801              BHI      |L3.264|
;;;729                *buf = tmp[i];
000104  5d4b              LDRB     r3,[r1,r5]
000106  7023              STRB     r3,[r4,#0]
                  |L3.264|
000108  1c64              ADDS     r4,r4,#1
;;;730            ++ buf;
00010a  e000              B        |L3.270|
                  |L3.268|
00010c  a901              ADD      r1,sp,#4              ;601
                  |L3.270|
00010e  462b              MOV      r3,r5                 ;726
000110  1e6d              SUBS     r5,r5,#1              ;726
000112  2b00              CMP      r3,#0                 ;726
000114  dcf4              BGT      |L3.256|
000116  e003              B        |L3.288|
                  |L3.280|
;;;731        }
;;;732    
;;;733        while (size-- > 0)
;;;734        {
;;;735            if (buf <= end)
000118  42b4              CMP      r4,r6
00011a  d800              BHI      |L3.286|
;;;736                *buf = ' ';
00011c  7022              STRB     r2,[r4,#0]
                  |L3.286|
00011e  1c64              ADDS     r4,r4,#1
                  |L3.288|
000120  4601              MOV      r1,r0                 ;733
000122  1e40              SUBS     r0,r0,#1              ;733
000124  2900              CMP      r1,#0                 ;733
000126  dcf7              BGT      |L3.280|
;;;737            ++ buf;
;;;738        }
;;;739    
;;;740        return buf;
000128  4620              MOV      r0,r4
;;;741    }
00012a  b00d              ADD      sp,sp,#0x34
00012c  bdf0              POP      {r4-r7,pc}
;;;742    
                          ENDP

00012e  0000              DCW      0x0000
                  |L3.304|
                          DCD      ||.constdata||+0x111

                          AREA ||i.rt_assert_handler||, CODE, READONLY, ALIGN=2

                  rt_assert_handler PROC
;;;1304    */
;;;1305   void rt_assert_handler(const char* ex_string, const char* func, rt_size_t line)
000000  b538              PUSH     {r3-r5,lr}
;;;1306   {
;;;1307       volatile char dummy = 0;
000002  2300              MOVS     r3,#0
000004  466c              MOV      r4,sp
000006  7023              STRB     r3,[r4,#0]
;;;1308   
;;;1309       if (rt_assert_hook == RT_NULL)
000008  4b08              LDR      r3,|L4.44|
00000a  689c              LDR      r4,[r3,#8]  ; rt_assert_hook
00000c  2c00              CMP      r4,#0
00000e  d001              BEQ      |L4.20|
;;;1310       {
;;;1311   #ifdef RT_USING_MODULE
;;;1312   		if (rt_module_self() != RT_NULL)
;;;1313   		{
;;;1314   			/* unload assertion module */
;;;1315   			rt_module_unload(rt_module_self());
;;;1316   
;;;1317   			/* re-schedule */
;;;1318   			rt_schedule();
;;;1319   		}
;;;1320   		else
;;;1321   #endif
;;;1322   		{
;;;1323   	        rt_kprintf("(%s) assertion failed at function:%s, line number:%d \n", ex_string, func, line);
;;;1324   	        while (dummy == 0);
;;;1325   		}
;;;1326       }
;;;1327   	else
;;;1328   	{
;;;1329           rt_assert_hook(ex_string, func, line);
000010  47a0              BLX      r4
;;;1330       }
;;;1331   }
000012  bd38              POP      {r3-r5,pc}
                  |L4.20|
000014  4613              MOV      r3,r2                 ;1323
000016  460a              MOV      r2,r1                 ;1323
000018  4601              MOV      r1,r0                 ;1323
00001a  a005              ADR      r0,|L4.48|
00001c  f7fffffe          BL       rt_kprintf
                  |L4.32|
000020  4668              MOV      r0,sp                 ;1324
000022  7800              LDRB     r0,[r0,#0]            ;1324
000024  2800              CMP      r0,#0                 ;1324
000026  d0fb              BEQ      |L4.32|
000028  bd38              POP      {r3-r5,pc}
;;;1332   RTM_EXPORT(rt_assert_handler);
                          ENDP

00002a  0000              DCW      0x0000
                  |L4.44|
                          DCD      ||.data||
                  |L4.48|
000030  28257329          DCB      "(%s) assertion failed at function:%s, line number:%d \n"
000034  20617373
000038  65727469
00003c  6f6e2066
000040  61696c65
000044  64206174
000048  2066756e
00004c  6374696f
000050  6e3a2573
000054  2c206c69
000058  6e65206e
00005c  756d6265
000060  723a2564
000064  200a    
000066  00                DCB      0
000067  00                DCB      0

                          AREA ||i.rt_assert_set_hook||, CODE, READONLY, ALIGN=2

                  rt_assert_set_hook PROC
;;;1293    */
;;;1294   void rt_assert_set_hook(void (*hook)(const char* ex, const char* func, rt_size_t line)) {
000000  4901              LDR      r1,|L5.8|
;;;1295       rt_assert_hook = hook;
000002  6088              STR      r0,[r1,#8]  ; rt_assert_hook
;;;1296   }
000004  4770              BX       lr
;;;1297   
                          ENDP

000006  0000              DCW      0x0000
                  |L5.8|
                          DCD      ||.data||

                          AREA ||i.rt_console_get_device||, CODE, READONLY, ALIGN=2

                  rt_console_get_device PROC
;;;1062    */
;;;1063   rt_device_t rt_console_get_device(void)
000000  4801              LDR      r0,|L6.8|
;;;1064   {
;;;1065       return _console_device;
000002  6800              LDR      r0,[r0,#0]  ; _console_device
;;;1066   }
000004  4770              BX       lr
;;;1067   RTM_EXPORT(rt_console_get_device);
                          ENDP

000006  0000              DCW      0x0000
                  |L6.8|
                          DCD      ||.data||

                          AREA ||i.rt_console_set_device||, CODE, READONLY, ALIGN=2

                  rt_console_set_device PROC
;;;1077    */
;;;1078   rt_device_t rt_console_set_device(const char *name)
000000  b570              PUSH     {r4-r6,lr}
;;;1079   {
;;;1080       rt_device_t new, old;
;;;1081   
;;;1082       /* save old device */
;;;1083       old = _console_device;
000002  4d09              LDR      r5,|L7.40|
;;;1084   
;;;1085       /* find new console device */
;;;1086       new = rt_device_find(name);
000004  682e              LDR      r6,[r5,#0]  ; _console_device
000006  f7fffffe          BL       rt_device_find
00000a  0004              MOVS     r4,r0
;;;1087       if (new != RT_NULL)
00000c  d009              BEQ      |L7.34|
;;;1088       {
;;;1089           if (_console_device != RT_NULL)
00000e  6828              LDR      r0,[r5,#0]  ; _console_device
000010  2800              CMP      r0,#0
000012  d001              BEQ      |L7.24|
;;;1090           {
;;;1091               /* close old console device */
;;;1092               rt_device_close(_console_device);
000014  f7fffffe          BL       rt_device_close
                  |L7.24|
;;;1093           }
;;;1094   
;;;1095           /* set new console device */
;;;1096           rt_device_open(new, RT_DEVICE_OFLAG_RDWR | RT_DEVICE_FLAG_STREAM);
000018  2143              MOVS     r1,#0x43
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       rt_device_open
;;;1097           _console_device = new;
000020  602c              STR      r4,[r5,#0]  ; _console_device
                  |L7.34|
;;;1098       }
;;;1099   
;;;1100       return old;
000022  4630              MOV      r0,r6
;;;1101   }
000024  bd70              POP      {r4-r6,pc}
;;;1102   RTM_EXPORT(rt_console_set_device);
                          ENDP

000026  0000              DCW      0x0000
                  |L7.40|
                          DCD      ||.data||

                          AREA ||i.rt_free_align||, CODE, READONLY, ALIGN=1

                  rt_free_align PROC
;;;1227    */
;;;1228   void rt_free_align(void *ptr)
000000  b510              PUSH     {r4,lr}
;;;1229   {
000002  3880              SUBS     r0,r0,#0x80
;;;1230       void *real_ptr;
;;;1231   
;;;1232       real_ptr = (void *)*(rt_uint32_t *)((rt_uint32_t)ptr - sizeof(void *));
000004  6fc0              LDR      r0,[r0,#0x7c]
;;;1233       rt_free(real_ptr);
000006  f7fffffe          BL       rt_free
;;;1234   }
00000a  bd10              POP      {r4,pc}
;;;1235   RTM_EXPORT(rt_free_align);
                          ENDP


                          AREA ||i.rt_get_errno||, CODE, READONLY, ALIGN=2

                  rt_get_errno PROC
;;;59      */
;;;60     rt_err_t rt_get_errno(void)
000000  b510              PUSH     {r4,lr}
;;;61     {
;;;62         rt_thread_t tid;
;;;63     
;;;64         if (rt_interrupt_get_nest() != 0)
000002  f7fffffe          BL       rt_interrupt_get_nest
;;;65         {
;;;66             /* it's in interrupt context */
;;;67             return _errno;
000006  4c05              LDR      r4,|L9.28|
000008  2800              CMP      r0,#0                 ;64
00000a  d105              BNE      |L9.24|
;;;68         }
;;;69     
;;;70         tid = rt_thread_self();
00000c  f7fffffe          BL       rt_thread_self
;;;71         if (tid == RT_NULL)
000010  2800              CMP      r0,#0
000012  d001              BEQ      |L9.24|
;;;72             return _errno;
;;;73     
;;;74         return tid->error;
000014  6b00              LDR      r0,[r0,#0x30]
;;;75     }
000016  bd10              POP      {r4,pc}
                  |L9.24|
000018  6860              LDR      r0,[r4,#4]            ;72  ; _errno
00001a  bd10              POP      {r4,pc}
;;;76     RTM_EXPORT(rt_get_errno);
                          ENDP

                  |L9.28|
                          DCD      ||.data||

                          AREA ||i.rt_hw_console_output||, CODE, READONLY, ALIGN=1

                  rt_hw_console_output PROC
;;;1104   
;;;1105   WEAK void rt_hw_console_output(const char *str)
000000  4770              BX       lr
;;;1106   {
;;;1107       /* empty console output */
;;;1108   }
;;;1109   RTM_EXPORT(rt_hw_console_output);
                          ENDP


                          AREA ||i.rt_kprintf||, CODE, READONLY, ALIGN=2

                  rt_kprintf PROC
;;;1140    */
;;;1141   void rt_kprintf(const char *fmt, ...)
000000  b40f              PUSH     {r0-r3}
;;;1142   {
000002  b570              PUSH     {r4-r6,lr}
;;;1143       va_list args;
;;;1144       rt_size_t length;
;;;1145       static char rt_log_buf[RT_CONSOLEBUF_SIZE];
;;;1146   
;;;1147       va_start(args, fmt);
000004  ab05              ADD      r3,sp,#0x14
;;;1148       /* the return value of vsnprintf is the number of bytes that would be
;;;1149        * written to buffer had if the size of the buffer been sufficiently
;;;1150        * large excluding the terminating null byte. If the output string
;;;1151        * would be larger than the rt_log_buf, we have to adjust the output
;;;1152        * length. */
;;;1153       length = rt_vsnprintf(rt_log_buf, sizeof(rt_log_buf) - 1, fmt, args);
000006  213f              MOVS     r1,#0x3f
000008  480e              LDR      r0,|L11.68|
00000a  9a04              LDR      r2,[sp,#0x10]
00000c  f7fffffe          BL       rt_vsnprintf
000010  4603              MOV      r3,r0
;;;1154       if (length > RT_CONSOLEBUF_SIZE - 1)
000012  283f              CMP      r0,#0x3f
000014  d900              BLS      |L11.24|
;;;1155           length = RT_CONSOLEBUF_SIZE - 1;
000016  233f              MOVS     r3,#0x3f
                  |L11.24|
;;;1156   #ifdef RT_USING_DEVICE
;;;1157       if (_console_device == RT_NULL)
000018  4d0b              LDR      r5,|L11.72|
00001a  6828              LDR      r0,[r5,#0]  ; _console_device
00001c  2800              CMP      r0,#0
00001e  d00d              BEQ      |L11.60|
;;;1158       {
;;;1159           rt_hw_console_output(rt_log_buf);
;;;1160       }
;;;1161       else
;;;1162       {
;;;1163           rt_uint16_t old_flag = _console_device->open_flag;
000020  8b04              LDRH     r4,[r0,#0x18]
;;;1164   
;;;1165           _console_device->open_flag |= RT_DEVICE_FLAG_STREAM;
000022  2140              MOVS     r1,#0x40
000024  4321              ORRS     r1,r1,r4
000026  8301              STRH     r1,[r0,#0x18]
;;;1166           rt_device_write(_console_device, 0, rt_log_buf, length);
000028  4a06              LDR      r2,|L11.68|
00002a  2100              MOVS     r1,#0
00002c  f7fffffe          BL       rt_device_write
;;;1167           _console_device->open_flag = old_flag;
000030  6828              LDR      r0,[r5,#0]  ; _console_device
000032  8304              STRH     r4,[r0,#0x18]
                  |L11.52|
;;;1168       }
;;;1169   #else
;;;1170       rt_hw_console_output(rt_log_buf);
;;;1171   #endif
;;;1172       va_end(args);
;;;1173   }
000034  bc70              POP      {r4-r6}
000036  bc08              POP      {r3}
000038  b004              ADD      sp,sp,#0x10
00003a  4718              BX       r3
                  |L11.60|
00003c  4801              LDR      r0,|L11.68|
00003e  f7fffffe          BL       rt_hw_console_output
000042  e7f7              B        |L11.52|
;;;1174   RTM_EXPORT(rt_kprintf);
                          ENDP

                  |L11.68|
                          DCD      ||.bss||
                  |L11.72|
                          DCD      ||.data||

                          AREA ||i.rt_kputs||, CODE, READONLY, ALIGN=2

                  rt_kputs PROC
;;;1115    */
;;;1116   void rt_kputs(const char *str)
000000  b570              PUSH     {r4-r6,lr}
;;;1117   {
;;;1118   #ifdef RT_USING_DEVICE
;;;1119       if (_console_device == RT_NULL)
000002  4e0c              LDR      r6,|L12.52|
000004  4605              MOV      r5,r0                 ;1117
000006  6830              LDR      r0,[r6,#0]  ; _console_device
000008  2800              CMP      r0,#0
00000a  d00f              BEQ      |L12.44|
;;;1120       {
;;;1121           rt_hw_console_output(str);
;;;1122       }
;;;1123       else
;;;1124       {
;;;1125           rt_uint16_t old_flag = _console_device->open_flag;
00000c  8b04              LDRH     r4,[r0,#0x18]
;;;1126   
;;;1127           _console_device->open_flag |= RT_DEVICE_FLAG_STREAM;
00000e  2140              MOVS     r1,#0x40
000010  4321              ORRS     r1,r1,r4
000012  8301              STRH     r1,[r0,#0x18]
;;;1128           rt_device_write(_console_device, 0, str, rt_strlen(str));
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       rt_strlen
00001a  4603              MOV      r3,r0
00001c  462a              MOV      r2,r5
00001e  2100              MOVS     r1,#0
000020  6830              LDR      r0,[r6,#0]  ; _console_device
000022  f7fffffe          BL       rt_device_write
;;;1129           _console_device->open_flag = old_flag;
000026  6830              LDR      r0,[r6,#0]  ; _console_device
000028  8304              STRH     r4,[r0,#0x18]
;;;1130       }
;;;1131   #else
;;;1132       rt_hw_console_output(str);
;;;1133   #endif
;;;1134   }
00002a  bd70              POP      {r4-r6,pc}
                  |L12.44|
00002c  4628              MOV      r0,r5                 ;1121
00002e  f7fffffe          BL       rt_hw_console_output
000032  bd70              POP      {r4-r6,pc}
;;;1135   
                          ENDP

                  |L12.52|
                          DCD      ||.data||

                          AREA ||i.rt_malloc_align||, CODE, READONLY, ALIGN=1

                  rt_malloc_align PROC
;;;1186    */
;;;1187   void* rt_malloc_align(rt_size_t size, rt_size_t align)
000000  b510              PUSH     {r4,lr}
;;;1188   {
000002  1cc9              ADDS     r1,r1,#3
;;;1189       void *align_ptr;
;;;1190       void *ptr;
;;;1191       rt_size_t align_size;
;;;1192   
;;;1193       /* align the alignment size to 4 byte */
;;;1194       align = ((align + 0x03) & ~0x03);
000004  1cc0              ADDS     r0,r0,#3
000006  088c              LSRS     r4,r1,#2
;;;1195   
;;;1196       /* get total aligned size */
;;;1197       align_size = ((size + 0x03) & ~0x03) + align;
000008  0880              LSRS     r0,r0,#2
00000a  00a4              LSLS     r4,r4,#2              ;1194
00000c  0080              LSLS     r0,r0,#2
00000e  1900              ADDS     r0,r0,r4
;;;1198       /* allocate memory block from heap */
;;;1199       ptr = rt_malloc(align_size);
000010  f7fffffe          BL       rt_malloc
;;;1200       if (ptr != RT_NULL)
000014  2800              CMP      r0,#0
000016  d00c              BEQ      |L13.50|
;;;1201       {
;;;1202            /* the allocated memory block is aligned */
;;;1203           if (((rt_uint32_t)ptr & (align - 1)) == 0)
000018  1e61              SUBS     r1,r4,#1
00001a  4208              TST      r0,r1
00001c  d101              BNE      |L13.34|
;;;1204           {
;;;1205               align_ptr = (void *)((rt_uint32_t)ptr + align);
00001e  1901              ADDS     r1,r0,r4
000020  e003              B        |L13.42|
                  |L13.34|
;;;1206           }
;;;1207           else
;;;1208           {
;;;1209               align_ptr = (void *)(((rt_uint32_t)ptr + (align - 1)) & ~(align - 1));
000022  1902              ADDS     r2,r0,r4
000024  1e52              SUBS     r2,r2,#1
000026  438a              BICS     r2,r2,r1
000028  4611              MOV      r1,r2
                  |L13.42|
;;;1210           }
;;;1211   
;;;1212           /* set the pointer before alignment pointer to the real pointer */
;;;1213           *((rt_uint32_t *)((rt_uint32_t)align_ptr - sizeof(void *))) = (rt_uint32_t)ptr;
00002a  460a              MOV      r2,r1
00002c  3a80              SUBS     r2,r2,#0x80
;;;1214   
;;;1215           ptr = align_ptr;
00002e  67d0              STR      r0,[r2,#0x7c]
000030  4608              MOV      r0,r1
                  |L13.50|
;;;1216       }
;;;1217   
;;;1218       return ptr;
;;;1219   }
000032  bd10              POP      {r4,pc}
;;;1220   RTM_EXPORT(rt_malloc_align);
                          ENDP


                          AREA ||i.rt_memcmp||, CODE, READONLY, ALIGN=1

                  rt_memcmp PROC
;;;324     */
;;;325    rt_int32_t rt_memcmp(const void *cs, const void *ct, rt_ubase_t count)
000000  b510              PUSH     {r4,lr}
;;;326    {
;;;327        const unsigned char *su1, *su2;
;;;328        int res = 0;
000002  2300              MOVS     r3,#0
000004  e006              B        |L14.20|
                  |L14.6|
;;;329    
;;;330        for (su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
;;;331            if ((res = *su1 - *su2) != 0)
000006  7803              LDRB     r3,[r0,#0]
000008  780c              LDRB     r4,[r1,#0]
00000a  1b1b              SUBS     r3,r3,r4
00000c  d104              BNE      |L14.24|
00000e  1c40              ADDS     r0,r0,#1
000010  1c49              ADDS     r1,r1,#1
000012  1e52              SUBS     r2,r2,#1
                  |L14.20|
000014  2a00              CMP      r2,#0                 ;330
000016  d1f6              BNE      |L14.6|
                  |L14.24|
;;;332                break;
;;;333    
;;;334        return res;
000018  4618              MOV      r0,r3
;;;335    }
00001a  bd10              POP      {r4,pc}
;;;336    RTM_EXPORT(rt_memcmp);
                          ENDP


                          AREA ||i.rt_memcpy||, CODE, READONLY, ALIGN=1

                  rt_memcpy PROC
;;;218     */
;;;219    void *rt_memcpy(void *dst, const void *src, rt_ubase_t count)
000000  b510              PUSH     {r4,lr}
;;;220    {
;;;221    #ifdef RT_TINY_SIZE
;;;222        char *tmp = (char *)dst, *s = (char *)src;
;;;223    
;;;224        while (count--)
;;;225            *tmp++ = *s++;
;;;226    
;;;227        return dst;
;;;228    #else
;;;229    
;;;230    #define UNALIGNED(X, Y)                                               \
;;;231                            (((rt_int32_t)X & (sizeof(rt_int32_t) - 1)) | \
;;;232                             ((rt_int32_t)Y & (sizeof(rt_int32_t) - 1)))
;;;233    #define BIGBLOCKSIZE    (sizeof(rt_int32_t) << 2)
;;;234    #define LITTLEBLOCKSIZE (sizeof(rt_int32_t))
;;;235    #define TOO_SMALL(LEN)  ((LEN) < BIGBLOCKSIZE)
;;;236    
;;;237        char *dst_ptr = (char *)dst;
000002  4603              MOV      r3,r0
;;;238        char *src_ptr = (char *)src;
;;;239        rt_int32_t *aligned_dst;
;;;240        rt_int32_t *aligned_src;
;;;241        int len = count;
;;;242    
;;;243        /* If the size is small, or either SRC or DST is unaligned,
;;;244        then punt into the byte copy loop.  This should be rare. */
;;;245        if (!TOO_SMALL(len) && !UNALIGNED(src_ptr, dst_ptr))
000004  2a10              CMP      r2,#0x10
000006  d31b              BCC      |L15.64|
000008  460c              MOV      r4,r1                 ;220
00000a  431c              ORRS     r4,r4,r3
00000c  07a4              LSLS     r4,r4,#30
00000e  d117              BNE      |L15.64|
                  |L15.16|
;;;246        {
;;;247            aligned_dst = (rt_int32_t *)dst_ptr;
;;;248            aligned_src = (rt_int32_t *)src_ptr;
;;;249    
;;;250            /* Copy 4X long words at a time if possible. */
;;;251            while (len >= BIGBLOCKSIZE)
;;;252            {
;;;253                *aligned_dst++ = *aligned_src++;
000010  680c              LDR      r4,[r1,#0]
;;;254                *aligned_dst++ = *aligned_src++;
000012  601c              STR      r4,[r3,#0]
000014  684c              LDR      r4,[r1,#4]
;;;255                *aligned_dst++ = *aligned_src++;
000016  605c              STR      r4,[r3,#4]
000018  688c              LDR      r4,[r1,#8]
;;;256                *aligned_dst++ = *aligned_src++;
00001a  609c              STR      r4,[r3,#8]
00001c  68cc              LDR      r4,[r1,#0xc]
00001e  60dc              STR      r4,[r3,#0xc]
000020  3110              ADDS     r1,r1,#0x10
000022  3a10              SUBS     r2,r2,#0x10
000024  3310              ADDS     r3,r3,#0x10
000026  2a10              CMP      r2,#0x10              ;251
;;;257                len -= BIGBLOCKSIZE;
000028  d2f2              BCS      |L15.16|
00002a  e002              B        |L15.50|
                  |L15.44|
;;;258            }
;;;259    
;;;260            /* Copy one long word at a time if possible. */
;;;261            while (len >= LITTLEBLOCKSIZE)
;;;262            {
;;;263                *aligned_dst++ = *aligned_src++;
00002c  c910              LDM      r1!,{r4}
00002e  1f12              SUBS     r2,r2,#4
000030  c310              STM      r3!,{r4}
                  |L15.50|
000032  2a04              CMP      r2,#4                 ;261
000034  d2fa              BCS      |L15.44|
000036  e003              B        |L15.64|
                  |L15.56|
;;;264                len -= LITTLEBLOCKSIZE;
;;;265            }
;;;266    
;;;267            /* Pick up any residual with a byte copier. */
;;;268            dst_ptr = (char *)aligned_dst;
;;;269            src_ptr = (char *)aligned_src;
;;;270        }
;;;271    
;;;272        while (len--)
;;;273            *dst_ptr++ = *src_ptr++;
000038  780c              LDRB     r4,[r1,#0]
00003a  701c              STRB     r4,[r3,#0]
00003c  1c49              ADDS     r1,r1,#1
00003e  1c5b              ADDS     r3,r3,#1
                  |L15.64|
000040  1e52              SUBS     r2,r2,#1
000042  d2f9              BCS      |L15.56|
;;;274    
;;;275        return dst;
;;;276    #undef UNALIGNED
;;;277    #undef BIGBLOCKSIZE
;;;278    #undef LITTLEBLOCKSIZE
;;;279    #undef TOO_SMALL
;;;280    #endif
;;;281    }
000044  bd10              POP      {r4,pc}
;;;282    RTM_EXPORT(rt_memcpy);
                          ENDP


                          AREA ||i.rt_memmove||, CODE, READONLY, ALIGN=1

                  rt_memmove PROC
;;;293     */
;;;294    void *rt_memmove(void *dest, const void *src, rt_ubase_t n)
000000  b510              PUSH     {r4,lr}
;;;295    {
;;;296        char *tmp = (char *)dest, *s = (char *)src;
000002  4603              MOV      r3,r0
;;;297    
;;;298        if (s < tmp && tmp < s + n)
000004  4281              CMP      r1,r0
000006  d20f              BCS      |L16.40|
000008  188c              ADDS     r4,r1,r2
00000a  429c              CMP      r4,r3
00000c  d90c              BLS      |L16.40|
;;;299        {
;;;300            tmp += n;
00000e  1881              ADDS     r1,r0,r2
;;;301            s += n;
;;;302    
;;;303            while (n--)
000010  e003              B        |L16.26|
                  |L16.18|
000012  1e64              SUBS     r4,r4,#1
;;;304                *(--tmp) = *(--s);
000014  7823              LDRB     r3,[r4,#0]
000016  1e49              SUBS     r1,r1,#1
000018  700b              STRB     r3,[r1,#0]
                  |L16.26|
00001a  1e52              SUBS     r2,r2,#1
00001c  d2f9              BCS      |L16.18|
;;;305        }
;;;306        else
;;;307        {
;;;308            while (n--)
;;;309                *tmp++ = *s++;
;;;310        }
;;;311    
;;;312        return dest;
;;;313    }
00001e  bd10              POP      {r4,pc}
                  |L16.32|
000020  780c              LDRB     r4,[r1,#0]            ;309
000022  701c              STRB     r4,[r3,#0]            ;309
000024  1c49              ADDS     r1,r1,#1              ;309
000026  1c5b              ADDS     r3,r3,#1              ;309
                  |L16.40|
000028  1e52              SUBS     r2,r2,#1              ;309
00002a  d2f9              BCS      |L16.32|
00002c  bd10              POP      {r4,pc}
;;;314    RTM_EXPORT(rt_memmove);
                          ENDP


                          AREA ||i.rt_memset||, CODE, READONLY, ALIGN=1

                  rt_memset PROC
;;;135     */
;;;136    void *rt_memset(void *s, int c, rt_ubase_t count)
000000  b530              PUSH     {r4,r5,lr}
;;;137    {
;;;138    #ifdef RT_TINY_SIZE
;;;139        char *xs = (char *)s;
;;;140    
;;;141        while (count--)
;;;142            *xs++ = c;
;;;143    
;;;144        return s;
;;;145    #else
;;;146    #define LBLOCKSIZE      (sizeof(rt_int32_t))
;;;147    #define UNALIGNED(X)    ((rt_int32_t)X & (LBLOCKSIZE - 1))
;;;148    #define TOO_SMALL(LEN)  ((LEN) < LBLOCKSIZE)
;;;149    
;;;150        int i;
;;;151        char *m = (char *)s;
000002  4603              MOV      r3,r0
;;;152        rt_uint32_t buffer;
;;;153        rt_uint32_t *aligned_addr;
;;;154        rt_uint32_t d = c & 0xff;
000004  b2cc              UXTB     r4,r1
;;;155    
;;;156        if (!TOO_SMALL(count) && !UNALIGNED(s))
000006  2a04              CMP      r2,#4
000008  d318              BCC      |L17.60|
00000a  0781              LSLS     r1,r0,#30
00000c  d116              BNE      |L17.60|
;;;157        {
;;;158            /* If we get this far, we know that n is large and m is word-aligned. */
;;;159            aligned_addr = (rt_uint32_t *)s;
;;;160    
;;;161            /* Store D into each char sized location in BUFFER so that
;;;162             * we can set large blocks quickly.
;;;163             */
;;;164            if (LBLOCKSIZE == 4)
;;;165            {
;;;166                buffer = (d << 8) | d;
00000e  0225              LSLS     r5,r4,#8
000010  4619              MOV      r1,r3                 ;159
000012  4325              ORRS     r5,r5,r4
;;;167                buffer |= (buffer << 16);
000014  042b              LSLS     r3,r5,#16
000016  432b              ORRS     r3,r3,r5
;;;168            }
;;;169            else
;;;170            {
;;;171                buffer = 0;
;;;172                for (i = 0; i < LBLOCKSIZE; i ++)
;;;173                    buffer = (buffer << 8) | d;
;;;174            }
;;;175    
;;;176            while (count >= LBLOCKSIZE * 4)
000018  e005              B        |L17.38|
                  |L17.26|
;;;177            {
;;;178                *aligned_addr++ = buffer;
;;;179                *aligned_addr++ = buffer;
00001a  600b              STR      r3,[r1,#0]
;;;180                *aligned_addr++ = buffer;
00001c  604b              STR      r3,[r1,#4]
;;;181                *aligned_addr++ = buffer;
00001e  608b              STR      r3,[r1,#8]
000020  60cb              STR      r3,[r1,#0xc]
000022  3110              ADDS     r1,r1,#0x10
000024  3a10              SUBS     r2,r2,#0x10
                  |L17.38|
000026  2a10              CMP      r2,#0x10              ;176
000028  d2f7              BCS      |L17.26|
00002a  e001              B        |L17.48|
                  |L17.44|
;;;182                count -= 4 * LBLOCKSIZE;
;;;183            }
;;;184    
;;;185            while (count >= LBLOCKSIZE)
;;;186            {
;;;187                *aligned_addr++ = buffer;
00002c  c108              STM      r1!,{r3}
00002e  1f12              SUBS     r2,r2,#4
                  |L17.48|
000030  2a04              CMP      r2,#4                 ;185
000032  d2fb              BCS      |L17.44|
;;;188                count -= LBLOCKSIZE;
;;;189            }
;;;190    
;;;191            /* Pick up the remainder with a bytewise loop. */
;;;192            m = (char *)aligned_addr;
000034  460b              MOV      r3,r1
000036  e001              B        |L17.60|
                  |L17.56|
;;;193        }
;;;194    
;;;195        while (count--)
;;;196        {
;;;197            *m++ = (char)d;
000038  701c              STRB     r4,[r3,#0]
00003a  1c5b              ADDS     r3,r3,#1
                  |L17.60|
00003c  1e52              SUBS     r2,r2,#1
00003e  d2fb              BCS      |L17.56|
;;;198        }
;;;199    
;;;200        return s;
;;;201    
;;;202    #undef LBLOCKSIZE
;;;203    #undef UNALIGNED
;;;204    #undef TOO_SMALL
;;;205    #endif
;;;206    }
000040  bd30              POP      {r4,r5,pc}
;;;207    RTM_EXPORT(rt_memset);
                          ENDP


                          AREA ||i.rt_set_errno||, CODE, READONLY, ALIGN=2

                  rt_set_errno PROC
;;;82      */
;;;83     void rt_set_errno(rt_err_t error)
000000  b570              PUSH     {r4-r6,lr}
;;;84     {
000002  4604              MOV      r4,r0
;;;85         rt_thread_t tid;
;;;86     
;;;87         if (rt_interrupt_get_nest() != 0)
000004  f7fffffe          BL       rt_interrupt_get_nest
;;;88         {
;;;89             /* it's in interrupt context */
;;;90             _errno = error;
000008  4d05              LDR      r5,|L18.32|
00000a  2800              CMP      r0,#0                 ;87
00000c  d105              BNE      |L18.26|
;;;91     
;;;92             return;
;;;93         }
;;;94     
;;;95         tid = rt_thread_self();
00000e  f7fffffe          BL       rt_thread_self
;;;96         if (tid == RT_NULL)
000012  2800              CMP      r0,#0
000014  d001              BEQ      |L18.26|
;;;97         {
;;;98             _errno = error;
;;;99     
;;;100            return;
;;;101        }
;;;102    
;;;103        tid->error = error;
;;;104    }
000016  6304              STR      r4,[r0,#0x30]
000018  bd70              POP      {r4-r6,pc}
                  |L18.26|
00001a  606c              STR      r4,[r5,#4]            ;98  ; _errno
00001c  bd70              POP      {r4-r6,pc}
;;;105    RTM_EXPORT(rt_set_errno);
                          ENDP

00001e  0000              DCW      0x0000
                  |L18.32|
                          DCD      ||.data||

                          AREA ||i.rt_show_version||, CODE, READONLY, ALIGN=2

                  rt_show_version PROC
;;;529     */
;;;530    void rt_show_version(void)
000000  b508              PUSH     {r3,lr}
;;;531    {
;;;532        rt_kprintf("\n \\ | /\n");
000002  a009              ADR      r0,|L19.40|
000004  f7fffffe          BL       rt_kprintf
;;;533        rt_kprintf("- RT -     Thread Operating System\n");
000008  a00a              ADR      r0,|L19.52|
00000a  f7fffffe          BL       rt_kprintf
;;;534        rt_kprintf(" / | \\     %d.%d.%d build %s\n",
00000e  a012              ADR      r0,|L19.88|
000010  9000              STR      r0,[sp,#0]
000012  2300              MOVS     r3,#0
000014  2201              MOVS     r2,#1
000016  2102              MOVS     r1,#2
000018  a012              ADR      r0,|L19.100|
00001a  f7fffffe          BL       rt_kprintf
;;;535                   RT_VERSION, RT_SUBVERSION, RT_REVISION, __DATE__);
;;;536        rt_kprintf(" 2006 - 2017 Copyright by rt-thread team\n");
00001e  a019              ADR      r0,|L19.132|
000020  f7fffffe          BL       rt_kprintf
;;;537    	 
;;;538    }
000024  bd08              POP      {r3,pc}
;;;539    RTM_EXPORT(rt_show_version);
                          ENDP

000026  0000              DCW      0x0000
                  |L19.40|
000028  0a205c20          DCB      "\n \\ | /\n",0
00002c  7c202f0a
000030  00      
000031  00                DCB      0
000032  00                DCB      0
000033  00                DCB      0
                  |L19.52|
000034  2d205254          DCB      "- RT -     Thread Operating System\n",0
000038  202d2020
00003c  20202054
000040  68726561
000044  64204f70
000048  65726174
00004c  696e6720
000050  53797374
000054  656d0a00
                  |L19.88|
000058  41756720          DCB      "Aug 24 2017",0
00005c  32342032
000060  30313700
                  |L19.100|
000064  202f207c          DCB      " / | \\     %d.%d.%d build %s\n",0
000068  205c2020
00006c  20202025
000070  642e2564
000074  2e256420
000078  6275696c
00007c  64202573
000080  0a00    
000082  00                DCB      0
000083  00                DCB      0
                  |L19.132|
000084  20323030          DCB      " 2006 - 2017 Copyright by rt-thread team\n",0
000088  36202d20
00008c  32303137
000090  20436f70
000094  79726967
000098  68742062
00009c  79207274
0000a0  2d746872
0000a4  65616420
0000a8  7465616d
0000ac  0a00    
0000ae  00                DCB      0
0000af  00                DCB      0

                          AREA ||i.rt_snprintf||, CODE, READONLY, ALIGN=1

                  rt_snprintf PROC
;;;1009    */
;;;1010   rt_int32_t rt_snprintf(char *buf, rt_size_t size, const char *fmt, ...)
000000  b40f              PUSH     {r0-r3}
;;;1011   {
000002  b510              PUSH     {r4,lr}
;;;1012       rt_int32_t n;
;;;1013       va_list args;
;;;1014   
;;;1015       va_start(args, fmt);
000004  ab05              ADD      r3,sp,#0x14
;;;1016       n = rt_vsnprintf(buf, size, fmt, args);
000006  9a04              LDR      r2,[sp,#0x10]
000008  f7fffffe          BL       rt_vsnprintf
;;;1017       va_end(args);
;;;1018   
;;;1019       return n;
;;;1020   }
00000c  bc10              POP      {r4}
00000e  bc08              POP      {r3}
000010  b004              ADD      sp,sp,#0x10
000012  4718              BX       r3
;;;1021   RTM_EXPORT(rt_snprintf);
                          ENDP


                          AREA ||i.rt_sprintf||, CODE, READONLY, ALIGN=1

                  rt_sprintf PROC
;;;1041    */
;;;1042   rt_int32_t rt_sprintf(char *buf, const char *format, ...)
000000  b40f              PUSH     {r0-r3}
;;;1043   {
000002  b510              PUSH     {r4,lr}
;;;1044       rt_int32_t n;
;;;1045       va_list arg_ptr;
;;;1046   
;;;1047       va_start(arg_ptr, format);
000004  aa04              ADD      r2,sp,#0x10
;;;1048       n = rt_vsprintf(buf ,format, arg_ptr);
000006  9903              LDR      r1,[sp,#0xc]
000008  f7fffffe          BL       rt_vsprintf
;;;1049       va_end(arg_ptr);
;;;1050   
;;;1051       return n;
;;;1052   }
00000c  bc10              POP      {r4}
00000e  bc08              POP      {r3}
000010  b004              ADD      sp,sp,#0x10
000012  4718              BX       r3
;;;1053   RTM_EXPORT(rt_sprintf);
                          ENDP


                          AREA ||i.rt_strcasecmp||, CODE, READONLY, ALIGN=1

                  rt_strcasecmp PROC
;;;373     */
;;;374    rt_uint32_t rt_strcasecmp(const char *a, const char *b)
000000  b510              PUSH     {r4,lr}
                  |L22.2|
;;;375    {
;;;376        int ca, cb;
;;;377    
;;;378        do
;;;379        {
;;;380            ca = *a++ & 0xff;
000002  7802              LDRB     r2,[r0,#0]
;;;381            cb = *b++ & 0xff;
000004  780b              LDRB     r3,[r1,#0]
;;;382            if (ca >= 'A' && ca <= 'Z')
000006  4614              MOV      r4,r2
000008  3c41              SUBS     r4,r4,#0x41
00000a  1c40              ADDS     r0,r0,#1
00000c  1c49              ADDS     r1,r1,#1
00000e  2c19              CMP      r4,#0x19
000010  d800              BHI      |L22.20|
000012  3220              ADDS     r2,r2,#0x20
                  |L22.20|
;;;383                ca += 'a' - 'A';
;;;384            if (cb >= 'A' && cb <= 'Z')
000014  461c              MOV      r4,r3
000016  3c41              SUBS     r4,r4,#0x41
000018  2c19              CMP      r4,#0x19
00001a  d800              BHI      |L22.30|
00001c  3320              ADDS     r3,r3,#0x20
                  |L22.30|
;;;385                cb += 'a' - 'A';
;;;386        }
;;;387        while (ca == cb && ca != '\0');
00001e  429a              CMP      r2,r3
000020  d101              BNE      |L22.38|
000022  2a00              CMP      r2,#0
000024  d1ed              BNE      |L22.2|
                  |L22.38|
;;;388    
;;;389        return ca - cb;
000026  1ad0              SUBS     r0,r2,r3
;;;390    }
000028  bd10              POP      {r4,pc}
;;;391    RTM_EXPORT(rt_strcasecmp);
                          ENDP


                          AREA ||i.rt_strcmp||, CODE, READONLY, ALIGN=1

                  rt_strcmp PROC
;;;456     */
;;;457    rt_int32_t rt_strcmp(const char *cs, const char *ct)
000000  e001              B        |L23.6|
                  |L23.2|
;;;458    {
;;;459        while (*cs && *cs == *ct)
;;;460            cs++, ct++;
000002  1c40              ADDS     r0,r0,#1
000004  1c49              ADDS     r1,r1,#1
                  |L23.6|
000006  7802              LDRB     r2,[r0,#0]            ;459
000008  2a00              CMP      r2,#0                 ;459
00000a  d002              BEQ      |L23.18|
00000c  780b              LDRB     r3,[r1,#0]            ;459
00000e  429a              CMP      r2,r3                 ;459
000010  d0f7              BEQ      |L23.2|
                  |L23.18|
;;;461    
;;;462        return (*cs - *ct);
000012  7809              LDRB     r1,[r1,#0]
000014  b2d0              UXTB     r0,r2
000016  1a40              SUBS     r0,r0,r1
;;;463    }
000018  4770              BX       lr
;;;464    RTM_EXPORT(rt_strcmp);
                          ENDP


                          AREA ||i.rt_strdup||, CODE, READONLY, ALIGN=1

                  rt_strdup PROC
;;;511     */
;;;512    char *rt_strdup(const char *s)
000000  b570              PUSH     {r4-r6,lr}
;;;513    {
000002  4606              MOV      r6,r0
;;;514        rt_size_t len = rt_strlen(s) + 1;
000004  f7fffffe          BL       rt_strlen
000008  1c40              ADDS     r0,r0,#1
00000a  4605              MOV      r5,r0
;;;515        char *tmp = (char *)rt_malloc(len);
00000c  f7fffffe          BL       rt_malloc
000010  0004              MOVS     r4,r0
;;;516    
;;;517        if (!tmp)
000012  d005              BEQ      |L24.32|
;;;518            return RT_NULL;
;;;519    
;;;520        rt_memcpy(tmp, s, len);
000014  462a              MOV      r2,r5
000016  4631              MOV      r1,r6
000018  f7fffffe          BL       rt_memcpy
;;;521    
;;;522        return tmp;
00001c  4620              MOV      r0,r4
;;;523    }
00001e  bd70              POP      {r4-r6,pc}
                  |L24.32|
000020  2000              MOVS     r0,#0                 ;518
000022  bd70              POP      {r4-r6,pc}
;;;524    RTM_EXPORT(rt_strdup);
                          ENDP


                          AREA ||i.rt_strlen||, CODE, READONLY, ALIGN=1

                  rt_strlen PROC
;;;492     */
;;;493    rt_size_t rt_strlen(const char *s)
000000  4601              MOV      r1,r0
;;;494    {
000002  e000              B        |L25.6|
                  |L25.4|
000004  1c49              ADDS     r1,r1,#1
                  |L25.6|
;;;495        const char *sc;
;;;496    
;;;497        for (sc = s; *sc != '\0'; ++sc) /* nothing */
000006  780a              LDRB     r2,[r1,#0]
000008  2a00              CMP      r2,#0
00000a  d1fb              BNE      |L25.4|
;;;498            ;
;;;499    
;;;500        return sc - s;
00000c  1a08              SUBS     r0,r1,r0
;;;501    }
00000e  4770              BX       lr
;;;502    RTM_EXPORT(rt_strlen);
                          ENDP


                          AREA ||i.rt_strncmp||, CODE, READONLY, ALIGN=1

                  rt_strncmp PROC
;;;433     */
;;;434    rt_int32_t rt_strncmp(const char *cs, const char *ct, rt_ubase_t count)
000000  b510              PUSH     {r4,lr}
;;;435    {
;;;436        register signed char __res = 0;
000002  2400              MOVS     r4,#0
000004  e00a              B        |L26.28|
                  |L26.6|
;;;437    
;;;438        while (count)
;;;439        {
;;;440            if ((__res = *cs - *ct++) != 0 || !*cs++)
000006  780c              LDRB     r4,[r1,#0]
000008  7803              LDRB     r3,[r0,#0]
00000a  1c49              ADDS     r1,r1,#1
00000c  1b1c              SUBS     r4,r3,r4
00000e  b264              SXTB     r4,r4
000010  2c00              CMP      r4,#0
000012  d105              BNE      |L26.32|
000014  1c40              ADDS     r0,r0,#1
000016  2b00              CMP      r3,#0
000018  d002              BEQ      |L26.32|
00001a  1e52              SUBS     r2,r2,#1
                  |L26.28|
00001c  2a00              CMP      r2,#0                 ;438
00001e  d1f2              BNE      |L26.6|
                  |L26.32|
;;;441                break;
;;;442            count --;
;;;443        }
;;;444    
;;;445        return __res;
000020  4620              MOV      r0,r4
;;;446    }
000022  bd10              POP      {r4,pc}
;;;447    RTM_EXPORT(rt_strncmp);
                          ENDP


                          AREA ||i.rt_strncpy||, CODE, READONLY, ALIGN=1

                  rt_strncpy PROC
;;;401     */
;;;402    char *rt_strncpy(char *dst, const char *src, rt_ubase_t n)
000000  b510              PUSH     {r4,lr}
;;;403    {
;;;404        if (n != 0)
000002  2a00              CMP      r2,#0
000004  d008              BEQ      |L27.24|
;;;405        {
;;;406            char *d = dst;
000006  4603              MOV      r3,r0
                  |L27.8|
;;;407            const char *s = src;
;;;408    
;;;409            do
;;;410            {
;;;411                if ((*d++ = *s++) == 0)
000008  780c              LDRB     r4,[r1,#0]
00000a  701c              STRB     r4,[r3,#0]
00000c  1c49              ADDS     r1,r1,#1
00000e  1c5b              ADDS     r3,r3,#1
000010  2c00              CMP      r4,#0
000012  d005              BEQ      |L27.32|
000014  1e52              SUBS     r2,r2,#1
;;;412                {
;;;413                    /* NUL pad the remaining n-1 bytes */
;;;414                    while (--n != 0)
;;;415                        *d++ = 0;
;;;416                    break;
;;;417                }
;;;418            } while (--n != 0);
000016  d1f7              BNE      |L27.8|
                  |L27.24|
;;;419        }
;;;420    
;;;421        return (dst);
;;;422    }
000018  bd10              POP      {r4,pc}
                  |L27.26|
00001a  7019              STRB     r1,[r3,#0]            ;415
00001c  1c5b              ADDS     r3,r3,#1              ;415
00001e  e000              B        |L27.34|
                  |L27.32|
000020  2100              MOVS     r1,#0                 ;415
                  |L27.34|
000022  1e52              SUBS     r2,r2,#1              ;415
000024  d1f9              BNE      |L27.26|
000026  bd10              POP      {r4,pc}
;;;423    RTM_EXPORT(rt_strncpy);
                          ENDP


                          AREA ||i.rt_strnlen||, CODE, READONLY, ALIGN=1

                  rt_strnlen PROC
;;;475     */
;;;476    rt_size_t rt_strnlen(const char *s, rt_ubase_t maxlen)
000000  4602              MOV      r2,r0
;;;477    {
000002  e000              B        |L28.6|
                  |L28.4|
000004  1c52              ADDS     r2,r2,#1
                  |L28.6|
;;;478        const char *sc;
;;;479    
;;;480        for (sc = s; *sc != '\0' && sc - s < maxlen; ++sc) /* nothing */
000006  7813              LDRB     r3,[r2,#0]
000008  2b00              CMP      r3,#0
00000a  d002              BEQ      |L28.18|
00000c  1a13              SUBS     r3,r2,r0
00000e  428b              CMP      r3,r1
000010  d3f8              BCC      |L28.4|
                  |L28.18|
;;;481            ;
;;;482    
;;;483        return sc - s;
000012  1a10              SUBS     r0,r2,r0
;;;484    }
000014  4770              BX       lr
;;;485    /**
                          ENDP


                          AREA ||i.rt_strstr||, CODE, READONLY, ALIGN=1

                  rt_strstr PROC
;;;345     */
;;;346    char *rt_strstr(const char *s1, const char *s2)
000000  b5f0              PUSH     {r4-r7,lr}
;;;347    {
000002  4606              MOV      r6,r0
000004  460f              MOV      r7,r1
;;;348        int l1, l2;
;;;349    
;;;350        l2 = rt_strlen(s2);
000006  4608              MOV      r0,r1
000008  f7fffffe          BL       rt_strlen
00000c  0005              MOVS     r5,r0
;;;351        if (!l2)
00000e  d011              BEQ      |L29.52|
;;;352            return (char *)s1;
;;;353        l1 = rt_strlen(s1);
000010  4630              MOV      r0,r6
000012  f7fffffe          BL       rt_strlen
000016  4604              MOV      r4,r0
;;;354        while (l1 >= l2)
000018  e008              B        |L29.44|
                  |L29.26|
;;;355        {
;;;356            l1 --;
;;;357            if (!rt_memcmp(s1, s2, l2))
00001a  462a              MOV      r2,r5
00001c  4639              MOV      r1,r7
00001e  4630              MOV      r0,r6
000020  1e64              SUBS     r4,r4,#1
000022  f7fffffe          BL       rt_memcmp
000026  2800              CMP      r0,#0
000028  d004              BEQ      |L29.52|
00002a  1c76              ADDS     r6,r6,#1
                  |L29.44|
00002c  42ac              CMP      r4,r5                 ;354
00002e  daf4              BGE      |L29.26|
;;;358                return (char *)s1;
;;;359            s1 ++;
;;;360        }
;;;361    
;;;362        return RT_NULL;
000030  2000              MOVS     r0,#0
;;;363    }
000032  bdf0              POP      {r4-r7,pc}
                  |L29.52|
000034  4630              MOV      r0,r6                 ;358
000036  bdf0              POP      {r4-r7,pc}
;;;364    RTM_EXPORT(rt_strstr);
                          ENDP


                          AREA ||i.rt_vsnprintf||, CODE, READONLY, ALIGN=2

                  rt_vsnprintf PROC
;;;742    
;;;743    rt_int32_t rt_vsnprintf(char       *buf,
000000  b5ff              PUSH     {r0-r7,lr}
;;;744                            rt_size_t   size,
;;;745                            const char *fmt,
;;;746                            va_list     args)
;;;747    {
000002  b085              SUB      sp,sp,#0x14
;;;748    #ifdef RT_PRINTF_LONGLONG
;;;749        unsigned long long num;
;;;750    #else
;;;751        rt_uint32_t num;
;;;752    #endif
;;;753        int i, len;
;;;754        char *str, *end, c;
;;;755        const char *s;
;;;756    
;;;757        rt_uint8_t base;            /* the base of number */
;;;758        rt_uint8_t flags;           /* flags to print number */
;;;759        rt_uint8_t qualifier;       /* 'h', 'l', or 'L' for integer fields */
;;;760        rt_int32_t field_width;     /* width of output field */
;;;761    
;;;762    #ifdef RT_PRINTF_PRECISION
;;;763        int precision;      /* min. # of digits for integers and max for a string */
;;;764    #endif
;;;765    
;;;766        str = buf;
;;;767        end = buf + size - 1;
000004  9c05              LDR      r4,[sp,#0x14]
000006  461f              MOV      r7,r3                 ;747
000008  1860              ADDS     r0,r4,r1
00000a  1e40              SUBS     r0,r0,#1
;;;768    
;;;769        /* Make sure end is always >= buf */
;;;770        if (end < buf)
00000c  9003              STR      r0,[sp,#0xc]
00000e  42a0              CMP      r0,r4
000010  d202              BCS      |L30.24|
;;;771        {
;;;772            end  = ((char *)-1);
000012  2000              MOVS     r0,#0
000014  43c0              MVNS     r0,r0
;;;773            size = end - buf;
000016  9003              STR      r0,[sp,#0xc]
                  |L30.24|
000018  e108              B        |L30.556|
                  |L30.26|
;;;774        }
;;;775    
;;;776        for (; *fmt ; ++fmt)
;;;777        {
;;;778            if (*fmt != '%')
00001a  2825              CMP      r0,#0x25
00001c  d004              BEQ      |L30.40|
;;;779            {
;;;780                if (str <= end)
00001e  9903              LDR      r1,[sp,#0xc]
000020  428c              CMP      r4,r1
000022  d87f              BHI      |L30.292|
                  |L30.36|
;;;781                    *str = *fmt;
000024  7020              STRB     r0,[r4,#0]
000026  e07d              B        |L30.292|
                  |L30.40|
;;;782                ++ str;
;;;783                continue;
;;;784            }
;;;785    
;;;786            /* process flags */
;;;787            flags = 0;
000028  2500              MOVS     r5,#0
;;;788    
;;;789            while (1)
;;;790            {
;;;791                /* skips the first '%' also */
;;;792                ++ fmt;
;;;793                if (*fmt == '-') flags |= LEFT;
;;;794                else if (*fmt == '+') flags |= PLUS;
00002a  2304              MOVS     r3,#4
;;;795                else if (*fmt == ' ') flags |= SPACE;
00002c  2608              MOVS     r6,#8
00002e  2210              MOVS     r2,#0x10              ;793
                  |L30.48|
000030  9907              LDR      r1,[sp,#0x1c]         ;792
000032  1c49              ADDS     r1,r1,#1              ;792
000034  9107              STR      r1,[sp,#0x1c]         ;793
000036  7808              LDRB     r0,[r1,#0]            ;793
000038  282d              CMP      r0,#0x2d              ;793
00003a  d012              BEQ      |L30.98|
00003c  282b              CMP      r0,#0x2b              ;794
00003e  d012              BEQ      |L30.102|
000040  2820              CMP      r0,#0x20
000042  d012              BEQ      |L30.106|
;;;796                else if (*fmt == '#') flags |= SPECIAL;
000044  2823              CMP      r0,#0x23
000046  d012              BEQ      |L30.110|
;;;797                else if (*fmt == '0') flags |= ZEROPAD;
000048  2830              CMP      r0,#0x30
00004a  d012              BEQ      |L30.114|
;;;798                else break;
;;;799            }
;;;800    
;;;801            /* get field width */
;;;802            field_width = -1;
;;;803            if (isdigit(*fmt)) field_width = skip_atoi(&fmt);
00004c  780b              LDRB     r3,[r1,#0]
00004e  2600              MOVS     r6,#0                 ;802
000050  43f6              MVNS     r6,r6                 ;802
000052  3b30              SUBS     r3,r3,#0x30
000054  2b0a              CMP      r3,#0xa
000056  d20f              BCS      |L30.120|
000058  a807              ADD      r0,sp,#0x1c
00005a  f7fffffe          BL       skip_atoi
00005e  4606              MOV      r6,r0
000060  e013              B        |L30.138|
                  |L30.98|
000062  4315              ORRS     r5,r5,r2              ;793
000064  e7e4              B        |L30.48|
                  |L30.102|
000066  431d              ORRS     r5,r5,r3              ;794
000068  e7e2              B        |L30.48|
                  |L30.106|
00006a  4335              ORRS     r5,r5,r6              ;795
00006c  e7e0              B        |L30.48|
                  |L30.110|
00006e  2020              MOVS     r0,#0x20              ;796
000070  e000              B        |L30.116|
                  |L30.114|
000072  2001              MOVS     r0,#1                 ;797
                  |L30.116|
000074  4305              ORRS     r5,r5,r0              ;797
000076  e7db              B        |L30.48|
                  |L30.120|
;;;804            else if (*fmt == '*')
000078  282a              CMP      r0,#0x2a
00007a  d106              BNE      |L30.138|
00007c  1c49              ADDS     r1,r1,#1
;;;805            {
;;;806                ++ fmt;
;;;807                /* it's the next argument */
;;;808                field_width = va_arg(args, int);
00007e  9107              STR      r1,[sp,#0x1c]
000080  cf40              LDM      r7!,{r6}
;;;809                if (field_width < 0)
000082  2e00              CMP      r6,#0
000084  da01              BGE      |L30.138|
;;;810                {
;;;811                    field_width = -field_width;
000086  4276              RSBS     r6,r6,#0
;;;812                    flags |= LEFT;
000088  4315              ORRS     r5,r5,r2
                  |L30.138|
;;;813                }
;;;814            }
;;;815    
;;;816    #ifdef RT_PRINTF_PRECISION
;;;817            /* get the precision */
;;;818            precision = -1;
;;;819            if (*fmt == '.')
00008a  9807              LDR      r0,[sp,#0x1c]
00008c  2300              MOVS     r3,#0                 ;818
00008e  7801              LDRB     r1,[r0,#0]
000090  43db              MVNS     r3,r3                 ;818
000092  292e              CMP      r1,#0x2e
000094  d113              BNE      |L30.190|
000096  1c40              ADDS     r0,r0,#1
;;;820            {
;;;821                ++ fmt;
;;;822                if (isdigit(*fmt)) precision = skip_atoi(&fmt);
000098  9007              STR      r0,[sp,#0x1c]
00009a  7801              LDRB     r1,[r0,#0]
00009c  460a              MOV      r2,r1
00009e  3a30              SUBS     r2,r2,#0x30
0000a0  2a0a              CMP      r2,#0xa
0000a2  d204              BCS      |L30.174|
0000a4  a807              ADD      r0,sp,#0x1c
0000a6  f7fffffe          BL       skip_atoi
0000aa  4603              MOV      r3,r0
0000ac  e004              B        |L30.184|
                  |L30.174|
;;;823                else if (*fmt == '*')
0000ae  292a              CMP      r1,#0x2a
0000b0  d104              BNE      |L30.188|
0000b2  1c40              ADDS     r0,r0,#1
;;;824                {
;;;825                    ++ fmt;
;;;826                    /* it's the next argument */
;;;827                    precision = va_arg(args, int);
0000b4  9007              STR      r0,[sp,#0x1c]
0000b6  cf08              LDM      r7!,{r3}
                  |L30.184|
;;;828                }
;;;829                if (precision < 0) precision = 0;
0000b8  2b00              CMP      r3,#0
0000ba  da00              BGE      |L30.190|
                  |L30.188|
0000bc  2300              MOVS     r3,#0
                  |L30.190|
;;;830            }
;;;831    #endif
;;;832            /* get the conversion qualifier */
;;;833            qualifier = 0;
;;;834    #ifdef RT_PRINTF_LONGLONG
;;;835            if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L')
;;;836    #else
;;;837            if (*fmt == 'h' || *fmt == 'l')
0000be  9907              LDR      r1,[sp,#0x1c]
0000c0  2200              MOVS     r2,#0                 ;833
0000c2  7808              LDRB     r0,[r1,#0]
0000c4  2868              CMP      r0,#0x68
0000c6  d001              BEQ      |L30.204|
0000c8  286c              CMP      r0,#0x6c
0000ca  d102              BNE      |L30.210|
                  |L30.204|
;;;838    #endif
;;;839            {
;;;840                qualifier = *fmt;
0000cc  1c49              ADDS     r1,r1,#1
0000ce  4602              MOV      r2,r0
;;;841                ++ fmt;
0000d0  9107              STR      r1,[sp,#0x1c]
                  |L30.210|
;;;842    #ifdef RT_PRINTF_LONGLONG
;;;843                if (qualifier == 'l' && *fmt == 'l')
;;;844                {
;;;845                    qualifier = 'L';
;;;846                    ++ fmt;
;;;847                }
;;;848    #endif
;;;849            }
;;;850    
;;;851            /* the default base */
;;;852            base = 10;
;;;853    
;;;854            switch (*fmt)
0000d2  9807              LDR      r0,[sp,#0x1c]
0000d4  210a              MOVS     r1,#0xa               ;852
0000d6  7800              LDRB     r0,[r0,#0]
0000d8  286f              CMP      r0,#0x6f
0000da  d076              BEQ      |L30.458|
0000dc  dc0c              BGT      |L30.248|
0000de  2863              CMP      r0,#0x63
0000e0  d022              BEQ      |L30.296|
0000e2  dc04              BGT      |L30.238|
0000e4  2825              CMP      r0,#0x25
0000e6  d071              BEQ      |L30.460|
0000e8  2858              CMP      r0,#0x58
0000ea  d10d              BNE      |L30.264|
0000ec  e087              B        |L30.510|
                  |L30.238|
0000ee  2864              CMP      r0,#0x64
0000f0  d001              BEQ      |L30.246|
0000f2  2869              CMP      r0,#0x69
0000f4  d108              BNE      |L30.264|
                  |L30.246|
0000f6  e086              B        |L30.518|
                  |L30.248|
0000f8  2870              CMP      r0,#0x70
0000fa  d069              BEQ      |L30.464|
0000fc  2873              CMP      r0,#0x73
0000fe  d030              BEQ      |L30.354|
000100  2875              CMP      r0,#0x75
000102  d072              BEQ      |L30.490|
000104  2878              CMP      r0,#0x78
000106  d07c              BEQ      |L30.514|
                  |L30.264|
;;;855            {
;;;856            case 'c':
;;;857                if (!(flags & LEFT))
;;;858                {
;;;859                    while (--field_width > 0)
;;;860                    {
;;;861                        if (str <= end) *str = ' ';
;;;862                        ++ str;
;;;863                    }
;;;864                }
;;;865    
;;;866                /* get character */
;;;867                c = (rt_uint8_t)va_arg(args, int);
;;;868                if (str <= end) *str = c;
;;;869                ++ str;
;;;870    
;;;871                /* put width */
;;;872                while (--field_width > 0)
;;;873                {
;;;874                    if (str <= end) *str = ' ';
;;;875                    ++ str;
;;;876                }
;;;877                continue;
;;;878    
;;;879            case 's':
;;;880                s = va_arg(args, char *);
;;;881                if (!s) s = "(NULL)";
;;;882    
;;;883                len = rt_strlen(s);
;;;884    #ifdef RT_PRINTF_PRECISION
;;;885                if (precision > 0 && len > precision) len = precision;
;;;886    #endif
;;;887    
;;;888                if (!(flags & LEFT))
;;;889                {
;;;890                    while (len < field_width--)
;;;891                    {
;;;892                        if (str <= end) *str = ' ';
;;;893                        ++ str;
;;;894                    }
;;;895                }
;;;896    
;;;897                for (i = 0; i < len; ++i)
;;;898                {
;;;899                    if (str <= end) *str = *s;
;;;900                    ++ str;
;;;901                    ++ s;
;;;902                }
;;;903    
;;;904                while (len < field_width--)
;;;905                {
;;;906                    if (str <= end) *str = ' ';
;;;907                    ++ str;
;;;908                }
;;;909                continue;
;;;910    
;;;911            case 'p':
;;;912                if (field_width == -1)
;;;913                {
;;;914                    field_width = sizeof(void *) << 1;
;;;915                    flags |= ZEROPAD;
;;;916                }
;;;917    #ifdef RT_PRINTF_PRECISION
;;;918                str = print_number(str, end,
;;;919                                   (long)va_arg(args, void *),
;;;920                                   16, field_width, precision, flags);
;;;921    #else
;;;922                str = print_number(str, end,
;;;923                                   (long)va_arg(args, void *),
;;;924                                   16, field_width, flags);
;;;925    #endif
;;;926                continue;
;;;927    
;;;928            case '%':
;;;929                if (str <= end) *str = '%';
;;;930                ++ str;
;;;931                continue;
;;;932    
;;;933                /* integer number formats - set up the flags and "break" */
;;;934            case 'o':
;;;935                base = 8;
;;;936                break;
;;;937    
;;;938            case 'X':
;;;939                flags |= LARGE;
;;;940            case 'x':
;;;941                base = 16;
;;;942                break;
;;;943    
;;;944            case 'd':
;;;945            case 'i':
;;;946                flags |= SIGN;
;;;947            case 'u':
;;;948                break;
;;;949    
;;;950            default:
;;;951                if (str <= end) *str = '%';
000108  9803              LDR      r0,[sp,#0xc]
00010a  4284              CMP      r4,r0
00010c  d801              BHI      |L30.274|
00010e  2025              MOVS     r0,#0x25
000110  7020              STRB     r0,[r4,#0]
                  |L30.274|
;;;952                ++ str;
;;;953    
;;;954                if (*fmt)
000112  9807              LDR      r0,[sp,#0x1c]
000114  1c64              ADDS     r4,r4,#1
000116  7801              LDRB     r1,[r0,#0]
000118  2900              CMP      r1,#0
00011a  d068              BEQ      |L30.494|
;;;955                {
;;;956                    if (str <= end) *str = *fmt;
00011c  9803              LDR      r0,[sp,#0xc]
00011e  4284              CMP      r4,r0
000120  d800              BHI      |L30.292|
000122  7021              STRB     r1,[r4,#0]
                  |L30.292|
000124  1c64              ADDS     r4,r4,#1
;;;957                    ++ str;
000126  e07e              B        |L30.550|
                  |L30.296|
000128  06e8              LSLS     r0,r5,#27             ;857
00012a  d409              BMI      |L30.320|
00012c  2020              MOVS     r0,#0x20              ;778
                  |L30.302|
00012e  1e76              SUBS     r6,r6,#1              ;778
000130  2e00              CMP      r6,#0                 ;859
000132  dd05              BLE      |L30.320|
000134  9903              LDR      r1,[sp,#0xc]          ;861
000136  428c              CMP      r4,r1                 ;861
000138  d800              BHI      |L30.316|
00013a  7020              STRB     r0,[r4,#0]            ;861
                  |L30.316|
00013c  1c64              ADDS     r4,r4,#1              ;861
00013e  e7f6              B        |L30.302|
                  |L30.320|
000140  7838              LDRB     r0,[r7,#0]            ;867
000142  9903              LDR      r1,[sp,#0xc]          ;868
000144  1d3f              ADDS     r7,r7,#4              ;868
000146  428c              CMP      r4,r1                 ;868
000148  d800              BHI      |L30.332|
00014a  7020              STRB     r0,[r4,#0]            ;868
                  |L30.332|
00014c  2020              MOVS     r0,#0x20              ;778
00014e  e003              B        |L30.344|
                  |L30.336|
000150  9903              LDR      r1,[sp,#0xc]          ;874
000152  428c              CMP      r4,r1                 ;874
000154  d800              BHI      |L30.344|
000156  7020              STRB     r0,[r4,#0]            ;874
                  |L30.344|
000158  1c64              ADDS     r4,r4,#1              ;874
00015a  1e76              SUBS     r6,r6,#1              ;874
00015c  2e00              CMP      r6,#0                 ;872
00015e  dcf7              BGT      |L30.336|
000160  e061              B        |L30.550|
                  |L30.354|
000162  cf01              LDM      r7!,{r0}              ;880
000164  9000              STR      r0,[sp,#0]            ;881
000166  2800              CMP      r0,#0                 ;881
000168  d101              BNE      |L30.366|
00016a  a03d              ADR      r0,|L30.608|
00016c  9000              STR      r0,[sp,#0]            ;881
                  |L30.366|
00016e  f7fffffe          BL       rt_strlen
000172  2b00              CMP      r3,#0                 ;885
000174  dd02              BLE      |L30.380|
000176  4298              CMP      r0,r3                 ;885
000178  dd00              BLE      |L30.380|
00017a  4618              MOV      r0,r3                 ;885
                  |L30.380|
00017c  06e9              LSLS     r1,r5,#27             ;888
00017e  d40a              BMI      |L30.406|
000180  2120              MOVS     r1,#0x20              ;778
                  |L30.386|
000182  4632              MOV      r2,r6                 ;890
000184  1e76              SUBS     r6,r6,#1              ;890
000186  4282              CMP      r2,r0                 ;890
000188  dd05              BLE      |L30.406|
00018a  9a03              LDR      r2,[sp,#0xc]          ;892
00018c  4294              CMP      r4,r2                 ;892
00018e  d800              BHI      |L30.402|
000190  7021              STRB     r1,[r4,#0]            ;892
                  |L30.402|
000192  1c64              ADDS     r4,r4,#1              ;892
000194  e7f5              B        |L30.386|
                  |L30.406|
000196  2100              MOVS     r1,#0                 ;897
000198  e00a              B        |L30.432|
                  |L30.410|
00019a  9a03              LDR      r2,[sp,#0xc]          ;899
00019c  4294              CMP      r4,r2                 ;899
00019e  d802              BHI      |L30.422|
0001a0  9a00              LDR      r2,[sp,#0]            ;899
0001a2  7812              LDRB     r2,[r2,#0]            ;899
0001a4  7022              STRB     r2,[r4,#0]            ;899
                  |L30.422|
0001a6  9a00              LDR      r2,[sp,#0]            ;901
0001a8  1c49              ADDS     r1,r1,#1              ;901
0001aa  1c52              ADDS     r2,r2,#1              ;901
0001ac  1c64              ADDS     r4,r4,#1              ;901
0001ae  9200              STR      r2,[sp,#0]            ;901
                  |L30.432|
0001b0  4281              CMP      r1,r0                 ;897
0001b2  dbf2              BLT      |L30.410|
0001b4  2120              MOVS     r1,#0x20              ;778
                  |L30.438|
0001b6  4632              MOV      r2,r6                 ;904
0001b8  1e76              SUBS     r6,r6,#1              ;904
0001ba  4282              CMP      r2,r0                 ;904
0001bc  dd33              BLE      |L30.550|
0001be  9a03              LDR      r2,[sp,#0xc]          ;906
0001c0  4294              CMP      r4,r2                 ;906
0001c2  d800              BHI      |L30.454|
0001c4  7021              STRB     r1,[r4,#0]            ;906
                  |L30.454|
0001c6  1c64              ADDS     r4,r4,#1              ;906
0001c8  e7f5              B        |L30.438|
                  |L30.458|
0001ca  e016              B        |L30.506|
                  |L30.460|
0001cc  e010              B        |L30.496|
0001ce  e7ff              B        |L30.464|
                  |L30.464|
0001d0  1c70              ADDS     r0,r6,#1              ;912
0001d2  d102              BNE      |L30.474|
0001d4  2608              MOVS     r6,#8                 ;914
0001d6  2001              MOVS     r0,#1                 ;915
0001d8  4305              ORRS     r5,r5,r0              ;915
                  |L30.474|
0001da  9301              STR      r3,[sp,#4]            ;918
0001dc  9600              STR      r6,[sp,#0]            ;918
0001de  9502              STR      r5,[sp,#8]            ;918
0001e0  cf04              LDM      r7!,{r2}              ;918
0001e2  2310              MOVS     r3,#0x10              ;918
0001e4  4620              MOV      r0,r4                 ;918
0001e6  9903              LDR      r1,[sp,#0xc]          ;926
0001e8  e01a              B        |L30.544|
                  |L30.490|
0001ea  e00e              B        |L30.522|
0001ec  e009              B        |L30.514|
                  |L30.494|
0001ee  e027              B        |L30.576|
                  |L30.496|
0001f0  9803              LDR      r0,[sp,#0xc]          ;929
0001f2  4284              CMP      r4,r0                 ;929
0001f4  d896              BHI      |L30.292|
0001f6  2025              MOVS     r0,#0x25              ;929
0001f8  e714              B        |L30.36|
                  |L30.506|
0001fa  2108              MOVS     r1,#8                 ;935
0001fc  e005              B        |L30.522|
                  |L30.510|
0001fe  2040              MOVS     r0,#0x40              ;939
000200  4305              ORRS     r5,r5,r0              ;939
                  |L30.514|
000202  2110              MOVS     r1,#0x10              ;941
000204  e001              B        |L30.522|
                  |L30.518|
000206  2002              MOVS     r0,#2                 ;946
000208  4305              ORRS     r5,r5,r0              ;946
                  |L30.522|
;;;958                }
;;;959                else
;;;960                {
;;;961                    -- fmt;
;;;962                }
;;;963                continue;
;;;964            }
;;;965    
;;;966    #ifdef RT_PRINTF_LONGLONG
;;;967            if (qualifier == 'L') num = va_arg(args, long long);
;;;968            else if (qualifier == 'l')
;;;969    #else
;;;970            if (qualifier == 'l')
00020a  2a6c              CMP      r2,#0x6c
00020c  d001              BEQ      |L30.530|
;;;971    #endif
;;;972            {
;;;973                num = va_arg(args, rt_uint32_t);
;;;974                if (flags & SIGN) num = (rt_int32_t)num;
;;;975            }
;;;976            else if (qualifier == 'h')
00020e  2a68              CMP      r2,#0x68
000210  d019              BEQ      |L30.582|
                  |L30.530|
;;;977            {
;;;978                num = (rt_uint16_t)va_arg(args, rt_int32_t);
;;;979                if (flags & SIGN) num = (rt_int16_t)num;
;;;980            }
;;;981            else
;;;982            {
;;;983                num = va_arg(args, rt_uint32_t);
000212  cf04              LDM      r7!,{r2}
                  |L30.532|
;;;984                if (flags & SIGN) num = (rt_int32_t)num;
;;;985            }
;;;986    #ifdef RT_PRINTF_PRECISION
;;;987            str = print_number(str, end, num, base, field_width, precision, flags);
000214  9301              STR      r3,[sp,#4]
000216  460b              MOV      r3,r1
000218  9600              STR      r6,[sp,#0]
00021a  9502              STR      r5,[sp,#8]
00021c  4620              MOV      r0,r4
00021e  9903              LDR      r1,[sp,#0xc]
                  |L30.544|
000220  f7fffffe          BL       print_number
000224  4604              MOV      r4,r0
                  |L30.550|
000226  9807              LDR      r0,[sp,#0x1c]         ;776
000228  1c40              ADDS     r0,r0,#1              ;776
00022a  9007              STR      r0,[sp,#0x1c]         ;776
                  |L30.556|
00022c  9807              LDR      r0,[sp,#0x1c]         ;776
00022e  7800              LDRB     r0,[r0,#0]            ;776
000230  2800              CMP      r0,#0                 ;776
000232  d000              BEQ      |L30.566|
000234  e6f1              B        |L30.26|
                  |L30.566|
;;;988    #else
;;;989            str = print_number(str, end, num, base, field_width, flags);
;;;990    #endif
;;;991        }
;;;992    
;;;993        if (str <= end) *str = '\0';
000236  9903              LDR      r1,[sp,#0xc]
000238  428c              CMP      r4,r1
00023a  d80b              BHI      |L30.596|
00023c  7020              STRB     r0,[r4,#0]
00023e  e00a              B        |L30.598|
                  |L30.576|
000240  1e40              SUBS     r0,r0,#1
000242  9007              STR      r0,[sp,#0x1c]         ;961
000244  e7ef              B        |L30.550|
                  |L30.582|
000246  8838              LDRH     r0,[r7,#0]            ;978
000248  1d3f              ADDS     r7,r7,#4              ;978
00024a  b282              UXTH     r2,r0                 ;978
00024c  07a8              LSLS     r0,r5,#30             ;979
00024e  d5e1              BPL      |L30.532|
000250  b212              SXTH     r2,r2                 ;979
000252  e7df              B        |L30.532|
                  |L30.596|
;;;994        else *end = '\0';
000254  7008              STRB     r0,[r1,#0]
                  |L30.598|
;;;995    
;;;996        /* the trailing null byte doesn't count towards the total
;;;997        * ++str;
;;;998        */
;;;999        return str - buf;
000256  9805              LDR      r0,[sp,#0x14]
;;;1000   }
000258  b009              ADD      sp,sp,#0x24
00025a  1a20              SUBS     r0,r4,r0              ;999
00025c  bdf0              POP      {r4-r7,pc}
;;;1001   RTM_EXPORT(rt_vsnprintf);
                          ENDP

00025e  0000              DCW      0x0000
                  |L30.608|
000260  284e554c          DCB      "(NULL)",0
000264  4c2900  
000267  00                DCB      0

                          AREA ||i.rt_vsprintf||, CODE, READONLY, ALIGN=1

                  rt_vsprintf PROC
;;;1029    */
;;;1030   rt_int32_t rt_vsprintf(char *buf, const char *format, va_list arg_ptr)
000000  4613              MOV      r3,r2
;;;1031   {
;;;1032       return rt_vsnprintf(buf, (rt_size_t) -1, format, arg_ptr);
000002  460a              MOV      r2,r1
000004  b510              PUSH     {r4,lr}               ;1031
000006  2100              MOVS     r1,#0
000008  43c9              MVNS     r1,r1
00000a  f7fffffe          BL       rt_vsnprintf
;;;1033   }
00000e  bd10              POP      {r4,pc}
;;;1034   RTM_EXPORT(rt_vsprintf);
                          ENDP


                          AREA ||i.skip_atoi||, CODE, READONLY, ALIGN=1

                  skip_atoi PROC
;;;562    
;;;563    rt_inline int skip_atoi(const char **s)
000000  4602              MOV      r2,r0
;;;564    {
;;;565        register int i=0;
000002  2000              MOVS     r0,#0
000004  e006              B        |L32.20|
                  |L32.6|
;;;566        while (isdigit(**s))
;;;567            i = i * 10 + *((*s)++) - '0';
000006  1c4b              ADDS     r3,r1,#1
000008  6013              STR      r3,[r2,#0]
00000a  230a              MOVS     r3,#0xa
00000c  7809              LDRB     r1,[r1,#0]
00000e  4358              MULS     r0,r3,r0
000010  3830              SUBS     r0,r0,#0x30
000012  1808              ADDS     r0,r1,r0
                  |L32.20|
000014  6811              LDR      r1,[r2,#0]            ;566
000016  780b              LDRB     r3,[r1,#0]            ;566
000018  3b30              SUBS     r3,r3,#0x30           ;566
00001a  2b0a              CMP      r3,#0xa               ;566
00001c  d3f3              BCC      |L32.6|
;;;568    
;;;569        return i;
;;;570    }
00001e  4770              BX       lr
;;;571    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  rt_log_buf
                          %        64

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  __lowest_bit_bitmap
000000  00000100          DCB      0x00,0x00,0x01,0x00
000004  02000100          DCB      0x02,0x00,0x01,0x00
000008  03000100          DCB      0x03,0x00,0x01,0x00
00000c  02000100          DCB      0x02,0x00,0x01,0x00
000010  04000100          DCB      0x04,0x00,0x01,0x00
000014  02000100          DCB      0x02,0x00,0x01,0x00
000018  03000100          DCB      0x03,0x00,0x01,0x00
00001c  02000100          DCB      0x02,0x00,0x01,0x00
000020  05000100          DCB      0x05,0x00,0x01,0x00
000024  02000100          DCB      0x02,0x00,0x01,0x00
000028  03000100          DCB      0x03,0x00,0x01,0x00
00002c  02000100          DCB      0x02,0x00,0x01,0x00
000030  04000100          DCB      0x04,0x00,0x01,0x00
000034  02000100          DCB      0x02,0x00,0x01,0x00
000038  03000100          DCB      0x03,0x00,0x01,0x00
00003c  02000100          DCB      0x02,0x00,0x01,0x00
000040  06000100          DCB      0x06,0x00,0x01,0x00
000044  02000100          DCB      0x02,0x00,0x01,0x00
000048  03000100          DCB      0x03,0x00,0x01,0x00
00004c  02000100          DCB      0x02,0x00,0x01,0x00
000050  04000100          DCB      0x04,0x00,0x01,0x00
000054  02000100          DCB      0x02,0x00,0x01,0x00
000058  03000100          DCB      0x03,0x00,0x01,0x00
00005c  02000100          DCB      0x02,0x00,0x01,0x00
000060  05000100          DCB      0x05,0x00,0x01,0x00
000064  02000100          DCB      0x02,0x00,0x01,0x00
000068  03000100          DCB      0x03,0x00,0x01,0x00
00006c  02000100          DCB      0x02,0x00,0x01,0x00
000070  04000100          DCB      0x04,0x00,0x01,0x00
000074  02000100          DCB      0x02,0x00,0x01,0x00
000078  03000100          DCB      0x03,0x00,0x01,0x00
00007c  02000100          DCB      0x02,0x00,0x01,0x00
000080  07000100          DCB      0x07,0x00,0x01,0x00
000084  02000100          DCB      0x02,0x00,0x01,0x00
000088  03000100          DCB      0x03,0x00,0x01,0x00
00008c  02000100          DCB      0x02,0x00,0x01,0x00
000090  04000100          DCB      0x04,0x00,0x01,0x00
000094  02000100          DCB      0x02,0x00,0x01,0x00
000098  03000100          DCB      0x03,0x00,0x01,0x00
00009c  02000100          DCB      0x02,0x00,0x01,0x00
0000a0  05000100          DCB      0x05,0x00,0x01,0x00
0000a4  02000100          DCB      0x02,0x00,0x01,0x00
0000a8  03000100          DCB      0x03,0x00,0x01,0x00
0000ac  02000100          DCB      0x02,0x00,0x01,0x00
0000b0  04000100          DCB      0x04,0x00,0x01,0x00
0000b4  02000100          DCB      0x02,0x00,0x01,0x00
0000b8  03000100          DCB      0x03,0x00,0x01,0x00
0000bc  02000100          DCB      0x02,0x00,0x01,0x00
0000c0  06000100          DCB      0x06,0x00,0x01,0x00
0000c4  02000100          DCB      0x02,0x00,0x01,0x00
0000c8  03000100          DCB      0x03,0x00,0x01,0x00
0000cc  02000100          DCB      0x02,0x00,0x01,0x00
0000d0  04000100          DCB      0x04,0x00,0x01,0x00
0000d4  02000100          DCB      0x02,0x00,0x01,0x00
0000d8  03000100          DCB      0x03,0x00,0x01,0x00
0000dc  02000100          DCB      0x02,0x00,0x01,0x00
0000e0  05000100          DCB      0x05,0x00,0x01,0x00
0000e4  02000100          DCB      0x02,0x00,0x01,0x00
0000e8  03000100          DCB      0x03,0x00,0x01,0x00
0000ec  02000100          DCB      0x02,0x00,0x01,0x00
0000f0  04000100          DCB      0x04,0x00,0x01,0x00
0000f4  02000100          DCB      0x02,0x00,0x01,0x00
0000f8  03000100          DCB      0x03,0x00,0x01,0x00
0000fc  02000100          DCB      0x02,0x00,0x01,0x00
                  small_digits
000100  30313233          DCB      0x30,0x31,0x32,0x33
000104  34353637          DCB      0x34,0x35,0x36,0x37
000108  38396162          DCB      0x38,0x39,0x61,0x62
00010c  63646566          DCB      0x63,0x64,0x65,0x66
000110  00                DCB      0x00
                  large_digits
000111  303132            DCB      0x30,0x31,0x32
000114  33343536          DCB      0x33,0x34,0x35,0x36
000118  37383941          DCB      0x37,0x38,0x39,0x41
00011c  42434445          DCB      0x42,0x43,0x44,0x45
000120  4600              DCB      0x46,0x00

                          AREA ||.data||, DATA, ALIGN=2

                  _console_device
                          DCD      0x00000000
                  _errno
                          DCD      0x00000000
                  rt_assert_hook
                          DCD      0x00000000
