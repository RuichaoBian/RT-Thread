; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\scuart.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\scuart.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I.\Libraries\Device\Nuvoton -I..\..\components\finsh -I.\Libraries\CMSIS\Include -I.\Libraries\StdDriver\inc -I..\..\include -I.\APP -I.\Drivers -I..\..\components\drivers\include -I..\..\components\drivers\include\drivers -I..\nuvoton_nuc240 -I.\Libraries\Device\Nuvoton\NUC230_240\Include -I..\..\include -I..\..\components\drivers\usb\usbdevice\class -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=521 -DRT_DEBUG --omf_browse=.\objects\scuart.crf Libraries\StdDriver\src\scuart.c]
                          THUMB

                          AREA ||i.SCUART_Close||, CODE, READONLY, ALIGN=1

                  SCUART_Close PROC
;;;31       */
;;;32     void SCUART_Close(SC_T* sc)
000000  2100              MOVS     r1,#0
;;;33     {
;;;34         sc->IER = 0;
000002  6181              STR      r1,[r0,#0x18]
;;;35         sc->UACTL = 0;
000004  6341              STR      r1,[r0,#0x34]
;;;36         sc->CTL = 0;
000006  6041              STR      r1,[r0,#4]
;;;37     
;;;38     }
000008  4770              BX       lr
;;;39     
                          ENDP


                          AREA ||i.SCUART_GetClock||, CODE, READONLY, ALIGN=2

                  SCUART_GetClock PROC
;;;45       */
;;;46     static uint32_t SCUART_GetClock(SC_T *sc)
000000  b538              PUSH     {r3-r5,lr}
;;;47     {
;;;48         uint32_t u32ClkSrc, u32Num, u32Clk;
;;;49     
;;;50         if(sc == SC0)
000002  4922              LDR      r1,|L2.140|
000004  4288              CMP      r0,r1
000006  d101              BNE      |L2.12|
;;;51             u32Num = 0;
000008  2400              MOVS     r4,#0
00000a  e005              B        |L2.24|
                  |L2.12|
;;;52         else if(sc == SC1)
00000c  4920              LDR      r1,|L2.144|
00000e  4288              CMP      r0,r1
000010  d101              BNE      |L2.22|
;;;53             u32Num = 1;
000012  2401              MOVS     r4,#1
000014  e000              B        |L2.24|
                  |L2.22|
;;;54         else // SC2
;;;55             u32Num = 2;
000016  2402              MOVS     r4,#2
                  |L2.24|
;;;56     
;;;57         u32ClkSrc = (CLK->CLKSEL3 >> (2 * u32Num)) & CLK_CLKSEL3_SC0_S_Msk;
000018  4d1e              LDR      r5,|L2.148|
00001a  6b68              LDR      r0,[r5,#0x34]
00001c  0061              LSLS     r1,r4,#1
00001e  40c8              LSRS     r0,r0,r1
000020  0781              LSLS     r1,r0,#30
;;;58     
;;;59         // Get smartcard module clock
;;;60         if(u32ClkSrc == 0)
;;;61             u32Clk = __HXT;
000022  4a1d              LDR      r2,|L2.152|
000024  0f89              LSRS     r1,r1,#30             ;57
000026  d005              BEQ      |L2.52|
000028  481c              LDR      r0,|L2.156|
;;;62         else if(u32ClkSrc == 1)
00002a  2901              CMP      r1,#1
00002c  d004              BEQ      |L2.56|
;;;63             u32Clk = CLK_GetPLLClockFreq();
;;;64         else if(u32ClkSrc == 2)
00002e  2902              CMP      r1,#2
000030  d022              BEQ      |L2.120|
000032  e023              B        |L2.124|
                  |L2.52|
000034  4610              MOV      r0,r2                 ;61
000036  e021              B        |L2.124|
                  |L2.56|
000038  a119              ADR      r1,|L2.160|
00003a  6809              LDR      r1,[r1,#0]            ;61
00003c  9100              STR      r1,[sp,#0]            ;61
00003e  6a29              LDR      r1,[r5,#0x20]         ;61
000040  2305              MOVS     r3,#5                 ;61
000042  041b              LSLS     r3,r3,#16             ;61
000044  4219              TST      r1,r3                 ;61
000046  d001              BEQ      |L2.76|
000048  2000              MOVS     r0,#0                 ;61
00004a  e017              B        |L2.124|
                  |L2.76|
00004c  030b              LSLS     r3,r1,#12             ;61
00004e  d400              BMI      |L2.82|
000050  4610              MOV      r0,r2                 ;61
                  |L2.82|
000052  038a              LSLS     r2,r1,#14             ;61
000054  d412              BMI      |L2.124|
000056  040a              LSLS     r2,r1,#16             ;61
000058  0f92              LSRS     r2,r2,#30             ;61
00005a  466b              MOV      r3,sp                 ;61
00005c  5c9b              LDRB     r3,[r3,r2]            ;61
00005e  05ca              LSLS     r2,r1,#23             ;61
000060  0489              LSLS     r1,r1,#18             ;61
000062  0dd2              LSRS     r2,r2,#23             ;61
000064  0ec9              LSRS     r1,r1,#27             ;61
000066  1c89              ADDS     r1,r1,#2              ;61
000068  0880              LSRS     r0,r0,#2              ;61
00006a  1c92              ADDS     r2,r2,#2              ;61
00006c  4359              MULS     r1,r3,r1              ;61
00006e  4350              MULS     r0,r2,r0              ;61
000070  f7fffffe          BL       __aeabi_uidivmod
000074  0080              LSLS     r0,r0,#2              ;61
000076  e001              B        |L2.124|
                  |L2.120|
;;;65             u32Clk = SystemCoreClock;
000078  480a              LDR      r0,|L2.164|
00007a  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
                  |L2.124|
;;;66         else
;;;67             u32Clk = __HIRC;
;;;68     
;;;69         u32Clk /= (((CLK->CLKDIV1 >> (8 * u32Num)) & CLK_CLKDIV1_SC0_N_Msk) + 1);
00007c  6ba9              LDR      r1,[r5,#0x38]
00007e  00e2              LSLS     r2,r4,#3
000080  40d1              LSRS     r1,r1,r2
000082  b2c9              UXTB     r1,r1
000084  1c49              ADDS     r1,r1,#1
000086  f7fffffe          BL       __aeabi_uidivmod
;;;70     
;;;71         return u32Clk;
;;;72     }
00008a  bd38              POP      {r3-r5,pc}
;;;73     /// @endcond HIDDEN_SYMBOLS
                          ENDP

                  |L2.140|
                          DCD      0x40190000
                  |L2.144|
                          DCD      0x40194000
                  |L2.148|
                          DCD      0x50000200
                  |L2.152|
                          DCD      0x00b71b00
                  |L2.156|
                          DCD      0x01518000
                  |L2.160|
0000a0  01020204          DCB      1,2,2,4
                  |L2.164|
                          DCD      SystemCoreClock

                          AREA ||i.SCUART_Open||, CODE, READONLY, ALIGN=2

                  SCUART_Open PROC
;;;83       */
;;;84     uint32_t SCUART_Open(SC_T* sc, uint32_t u32baudrate)
000000  b570              PUSH     {r4-r6,lr}
;;;85     {
000002  460e              MOV      r6,r1
000004  4604              MOV      r4,r0
;;;86         uint32_t u32Clk = SCUART_GetClock(sc), u32Div;
000006  f7fffffe          BL       SCUART_GetClock
00000a  4605              MOV      r5,r0
;;;87     
;;;88         // Calculate divider for target baudrate
;;;89         u32Div = (u32Clk + (u32baudrate >> 1) - 1) / u32baudrate - 1;
00000c  0870              LSRS     r0,r6,#1
00000e  1940              ADDS     r0,r0,r5
000010  4631              MOV      r1,r6
000012  1e40              SUBS     r0,r0,#1
000014  f7fffffe          BL       __aeabi_uidivmod
;;;90     
;;;91         sc->CTL = SC_CTL_SC_CEN_Msk | SC_CTL_SLEN_Msk;  // Enable smartcard interface and stop bit = 1
000018  4905              LDR      r1,|L3.48|
00001a  6061              STR      r1,[r4,#4]
;;;92         sc->UACTL = SCUART_CHAR_LEN_8 | SCUART_PARITY_NONE | SC_UACTL_UA_MODE_EN_Msk; // Enable UART mode, disable parity and 8 bit per character
00001c  2141              MOVS     r1,#0x41
00001e  6361              STR      r1,[r4,#0x34]
000020  1e40              SUBS     r0,r0,#1
;;;93         sc->ETUCR = u32Div;
000022  6160              STR      r0,[r4,#0x14]
;;;94     
;;;95         return(u32Clk / (u32Div+1));
000024  1c41              ADDS     r1,r0,#1
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       __aeabi_uidivmod
;;;96     }
00002c  bd70              POP      {r4-r6,pc}
;;;97     
                          ENDP

00002e  0000              DCW      0x0000
                  |L3.48|
                          DCD      0x00008001

                          AREA ||i.SCUART_Read||, CODE, READONLY, ALIGN=1

                  SCUART_Read PROC
;;;106      */
;;;107    uint32_t SCUART_Read(SC_T* sc, uint8_t *pu8RxBuf, uint32_t u32ReadBytes)
000000  b510              PUSH     {r4,lr}
;;;108    {
000002  4603              MOV      r3,r0
;;;109        uint32_t u32Count;
;;;110    
;;;111        for(u32Count = 0; u32Count < u32ReadBytes; u32Count++)
000004  2000              MOVS     r0,#0
000006  e005              B        |L4.20|
                  |L4.8|
;;;112        {
;;;113            if(SCUART_GET_RX_EMPTY(sc))   // no data available
000008  6a1c              LDR      r4,[r3,#0x20]
00000a  07a4              LSLS     r4,r4,#30
00000c  d404              BMI      |L4.24|
;;;114            {
;;;115                break;
;;;116            }
;;;117            pu8RxBuf[u32Count] = SCUART_READ(sc);    // get data from FIFO
00000e  681c              LDR      r4,[r3,#0]
000010  540c              STRB     r4,[r1,r0]
000012  1c40              ADDS     r0,r0,#1
                  |L4.20|
000014  4290              CMP      r0,r2                 ;111
000016  d3f7              BCC      |L4.8|
                  |L4.24|
;;;118        }
;;;119    
;;;120        return u32Count;
;;;121    }
000018  bd10              POP      {r4,pc}
;;;122    
                          ENDP


                          AREA ||i.SCUART_SetLineConfig||, CODE, READONLY, ALIGN=1

                  SCUART_SetLineConfig PROC
;;;141      */
;;;142    uint32_t SCUART_SetLineConfig(SC_T* sc, uint32_t u32Baudrate, uint32_t u32DataWidth, uint32_t u32Parity, uint32_t  u32StopBits)
000000  b5ff              PUSH     {r0-r7,lr}
;;;143    {
000002  b081              SUB      sp,sp,#4
000004  461e              MOV      r6,r3
000006  460f              MOV      r7,r1
000008  4604              MOV      r4,r0
;;;144        uint32_t u32Clk = SCUART_GetClock(sc), u32Div;
00000a  f7fffffe          BL       SCUART_GetClock
00000e  4605              MOV      r5,r0
;;;145    
;;;146        if(u32Baudrate == 0)    // keep original baudrate setting
000010  2f00              CMP      r7,#0
000012  d015              BEQ      |L5.64|
;;;147        {
;;;148            u32Div = sc->ETUCR & SC_ETUCR_ETU_RDIV_Msk;
;;;149        }
;;;150        else
;;;151        {
;;;152            // Calculate divider for target baudrate
;;;153            u32Div = (u32Clk + (u32Baudrate >> 1) - 1) / u32Baudrate - 1;
000014  0878              LSRS     r0,r7,#1
000016  1940              ADDS     r0,r0,r5
000018  4639              MOV      r1,r7
00001a  1e40              SUBS     r0,r0,#1
00001c  f7fffffe          BL       __aeabi_uidivmod
000020  1e40              SUBS     r0,r0,#1
;;;154            sc->ETUCR = u32Div;
000022  6160              STR      r0,[r4,#0x14]
                  |L5.36|
;;;155        }
;;;156    
;;;157        sc->CTL = u32StopBits | SC_CTL_SC_CEN_Msk;  // Set stop bit
000024  990a              LDR      r1,[sp,#0x28]
000026  2201              MOVS     r2,#1
000028  4311              ORRS     r1,r1,r2
00002a  6061              STR      r1,[r4,#4]
;;;158        sc->UACTL = u32Parity | u32DataWidth | SC_UACTL_UA_MODE_EN_Msk;  // Set character width and parity
00002c  9903              LDR      r1,[sp,#0xc]
00002e  430e              ORRS     r6,r6,r1
000030  4316              ORRS     r6,r6,r2
000032  6366              STR      r6,[r4,#0x34]
;;;159    
;;;160        return(u32Clk / (u32Div+1));
000034  1c41              ADDS     r1,r0,#1
000036  4628              MOV      r0,r5
000038  f7fffffe          BL       __aeabi_uidivmod
;;;161    }
00003c  b005              ADD      sp,sp,#0x14
00003e  bdf0              POP      {r4-r7,pc}
                  |L5.64|
000040  6960              LDR      r0,[r4,#0x14]         ;148
000042  0500              LSLS     r0,r0,#20             ;148
000044  0d00              LSRS     r0,r0,#20             ;148
000046  e7ed              B        |L5.36|
;;;162    
                          ENDP


                          AREA ||i.SCUART_SetTimeoutCnt||, CODE, READONLY, ALIGN=1

                  SCUART_SetTimeoutCnt PROC
;;;172      */
;;;173    void SCUART_SetTimeoutCnt(SC_T* sc, uint32_t u32TOC)
000000  6101              STR      r1,[r0,#0x10]
;;;174    {
;;;175        sc->RFTMR = u32TOC;
;;;176    }
000002  4770              BX       lr
;;;177    
                          ENDP


                          AREA ||i.SCUART_Write||, CODE, READONLY, ALIGN=1

                  SCUART_Write PROC
;;;187      */
;;;188    void SCUART_Write(SC_T* sc, uint8_t *pu8TxBuf, uint32_t u32WriteBytes)
000000  b510              PUSH     {r4,lr}
;;;189    {
;;;190        uint32_t u32Count;
;;;191    
;;;192        for(u32Count = 0; u32Count != u32WriteBytes; u32Count++)
000002  2300              MOVS     r3,#0
000004  e005              B        |L7.18|
                  |L7.6|
;;;193        {
;;;194            while(SCUART_GET_TX_FULL(sc));  // Wait 'til FIFO not full
000006  6a04              LDR      r4,[r0,#0x20]
000008  0564              LSLS     r4,r4,#21
00000a  d4fc              BMI      |L7.6|
;;;195            sc->THR = pu8TxBuf[u32Count];    // Write 1 byte to FIFO
00000c  5ccc              LDRB     r4,[r1,r3]
00000e  6004              STR      r4,[r0,#0]
000010  1c5b              ADDS     r3,r3,#1
                  |L7.18|
000012  4293              CMP      r3,r2                 ;192
000014  d1f7              BNE      |L7.6|
;;;196        }
;;;197    }
000016  bd10              POP      {r4,pc}
;;;198    
                          ENDP


;*** Start embedded assembler ***

#line 1 "Libraries\\StdDriver\\src\\scuart.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_scuart_c_c0edb1d5____REV16|
#line 118 ".\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_scuart_c_c0edb1d5____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_scuart_c_c0edb1d5____REVSH|
#line 132
|__asm___8_scuart_c_c0edb1d5____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
