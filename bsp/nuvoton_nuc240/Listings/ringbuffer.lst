L 1 "..\..\components\drivers\src\ringbuffer.c"
N/*
N * File      : ringbuffer.c
N * This file is part of RT-Thread RTOS
N * COPYRIGHT (C) 2012, RT-Thread Development Team
N *
N *  This program is free software; you can redistribute it and/or modify
N *  it under the terms of the GNU General Public License as published by
N *  the Free Software Foundation; either version 2 of the License, or
N *  (at your option) any later version.
N *
N *  This program is distributed in the hope that it will be useful,
N *  but WITHOUT ANY WARRANTY; without even the implied warranty of
N *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
N *  GNU General Public License for more details.
N *
N *  You should have received a copy of the GNU General Public License along
N *  with this program; if not, write to the Free Software Foundation, Inc.,
N *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
N *
N * Change Logs:
N * Date           Author       Notes
N * 2012-09-30     Bernard      first version.
N * 2013-05-08     Grissiom     reimplement
N */
N
N#include <rtthread.h>
L 1 "..\..\include\rtthread.h" 1
N/*
N * File      : rtthread.h
N * This file is part of RT-Thread RTOS
N * COPYRIGHT (C) 2006 - 2012, RT-Thread Development Team
N *
N *  This program is free software; you can redistribute it and/or modify
N *  it under the terms of the GNU General Public License as published by
N *  the Free Software Foundation; either version 2 of the License, or
N *  (at your option) any later version.
N *
N *  This program is distributed in the hope that it will be useful,
N *  but WITHOUT ANY WARRANTY; without even the implied warranty of
N *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
N *  GNU General Public License for more details.
N *
N *  You should have received a copy of the GNU General Public License along
N *  with this program; if not, write to the Free Software Foundation, Inc.,
N *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
N *
N * Change Logs:
N * Date           Author       Notes
N * 2006-03-18     Bernard      the first version
N * 2006-04-26     Bernard      add semaphore APIs
N * 2006-08-10     Bernard      add version information
N * 2007-01-28     Bernard      rename RT_OBJECT_Class_Static to RT_Object_Class_Static
N * 2007-03-03     Bernard      clean up the definitions to rtdef.h
N * 2010-04-11     yi.qiu       add module feature
N * 2013-06-24     Bernard      add rt_kprintf re-define when not use RT_USING_CONSOLE.
N * 2016-08-09     ArdaFu       add new thread and interrupt hook.
N */
N
N#ifndef __RT_THREAD_H__
N#define __RT_THREAD_H__
N
N#include <rtconfig.h>
L 1 "..\nuvoton_nuc240\rtconfig.h" 1
N/* RT-Thread config file */
N#ifndef __RTTHREAD_CFG_H__
N#define __RTTHREAD_CFG_H__
N
N/* RT_NAME_MAX*/
N#define RT_NAME_MAX	   8
N
N/* RT_ALIGN_SIZE*/
N#define RT_ALIGN_SIZE	4
N
N/* PRIORITY_MAX */
N#define RT_THREAD_PRIORITY_MAX	32
N#define IDLE_THREAD_STACK_SIZE 128
N/* Tick per Second 10msÒ»¸öµÎ´ð*/
N#define RT_TICK_PER_SECOND	100
N
N
N#define RT_USING_USB_HOST
N#define RT_USING_USB_DEVICE
N#define RT_USB_DEVICE_COMPOSITE
N/* SECTION: RT_DEBUG */
N/* Thread Debug */
N//#define RT_DEBUG
N//#define RT_DEBUG_INIT 1
N//#define RT_USING_OVERFLOW_CHECK
N
N/* Using Hook */
N/* #define RT_USING_HOOK */
N
N/* Using Software Timer */
N #define RT_USING_TIMER_SOFT 
N#define RT_TIMER_THREAD_PRIO		4
N#define RT_TIMER_THREAD_STACK_SIZE	512
N#define RT_TIMER_TICK_PER_SECOND	10
N
N/* SECTION: IPC */
N/* Using Semaphore*/
N#define RT_USING_SEMAPHORE
N
N/* Using Mutex */
N #define RT_USING_MUTEX 
N
N/* Using Event */
N #define RT_USING_EVENT
N
N/* Using MailBox */
N #define RT_USING_MAILBOX 
N
N/* Using Message Queue */
N #define RT_USING_MESSAGEQUEUE 
N
N/* SECTION: Memory Management */
N/* Using Memory Pool Management*/
N #define RT_USING_MEMPOOL 
N
N/* Using Dynamic Heap Management */
N#define RT_USING_HEAP
N
N/* Using Small MM */
N#define RT_USING_SMALL_MEM
N
N// <bool name="RT_USING_COMPONENTS_INIT" description="Using RT-Thread components initialization" default="true" />
N#define RT_USING_COMPONENTS_INIT
N
N/* SECTION: Device System */
N/* Using Device System */
N#define RT_USING_DEVICE
N// <bool name="RT_USING_DEVICE_IPC" description="Using device communication" default="true" />
N#define RT_USING_DEVICE_IPC
N// <bool name="RT_USING_SERIAL" description="Using Serial" default="true" />
N#define RT_USING_SERIAL
N
N/* SECTION: Console options */
N#define RT_USING_CONSOLE
N/* the buffer size of console*/
N#define RT_CONSOLEBUF_SIZE	64
N// <string name="RT_CONSOLE_DEVICE_NAME" description="The device name for console" default="uart1" />
N#define RT_CONSOLE_DEVICE_NAME	    "uart0"
N
N
N
N/* SECTION: finsh, a C-Express shell */
N#define RT_USING_FINSH
N/* configure finsh parameters */
N#define FINSH_THREAD_PRIORITY 25
N#define FINSH_THREAD_STACK_SIZE	512
N#define FINSH_USING_HISTORY 0
N#define FINSH_HISTORY_LINES	1
N/* Using symbol table */
N#define FINSH_USING_SYMTAB
N#define FINSH_USING_DESCRIPTION
N
N/* SECTION: libc management */
N//#define RT_USING_LIBC
N
N/* SECTION: device filesystem */
N/* #define RT_USING_DFS */
N//#define RT_USING_DFS_ELMFAT
N#define RT_DFS_ELM_WORD_ACCESS
N/* Reentrancy (thread safe) of the FatFs module.  */
N#define RT_DFS_ELM_REENTRANT
N/* Number of volumes (logical drives) to be used. */
N#define RT_DFS_ELM_DRIVES			2
N/* #define RT_DFS_ELM_USE_LFN			1 */
N#define RT_DFS_ELM_MAX_LFN			255
N/* Maximum sector size to be handled. */
N#define RT_DFS_ELM_MAX_SECTOR_SIZE  512
N
N#define RT_USING_DFS_ROMFS
N
N/* the max number of mounted filesystem */
N#define DFS_FILESYSTEMS_MAX			2
N/* the max number of opened files 		*/
N#define DFS_FD_MAX					4
N
N#endif
L 36 "..\..\include\rtthread.h" 2
N#include <rtdebug.h>
L 1 "..\..\include\rtdebug.h" 1
N/*
N * File      : rtdebug.h
N * This file is part of RT-Thread RTOS
N * COPYRIGHT (C) 2006 - 2012, RT-Thread Development Team
N *
N *  This program is free software; you can redistribute it and/or modify
N *  it under the terms of the GNU General Public License as published by
N *  the Free Software Foundation; either version 2 of the License, or
N *  (at your option) any later version.
N *
N *  This program is distributed in the hope that it will be useful,
N *  but WITHOUT ANY WARRANTY; without even the implied warranty of
N *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
N *  GNU General Public License for more details.
N *
N *  You should have received a copy of the GNU General Public License along
N *  with this program; if not, write to the Free Software Foundation, Inc.,
N *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
N */
N
N#ifndef __RTDEBUG_H__
N#define __RTDEBUG_H__
N
N#include <rtconfig.h>
N
N/* Using this macro to control all kernel debug features. */
N#ifdef RT_DEBUG
S
S/* Turn on some of these (set to non-zero) to debug kernel */
S#ifndef RT_DEBUG_MEM
S#define RT_DEBUG_MEM                   0
S#endif
S
S#ifndef RT_DEBUG_MEMHEAP
S#define RT_DEBUG_MEMHEAP               0
S#endif
S
S#ifndef RT_DEBUG_MODULE
S#define RT_DEBUG_MODULE                0
S#endif
S
S#ifndef RT_DEBUG_SCHEDULER
S#define RT_DEBUG_SCHEDULER             0
S#endif
S
S#ifndef RT_DEBUG_SLAB
S#define RT_DEBUG_SLAB                  0
S#endif
S
S#ifndef RT_DEBUG_THREAD
S#define RT_DEBUG_THREAD                0
S#endif
S
S#ifndef RT_DEBUG_TIMER
S#define RT_DEBUG_TIMER                 0
S#endif
S
S#ifndef RT_DEBUG_IRQ
S#define RT_DEBUG_IRQ                   0
S#endif
S
S#ifndef RT_DEBUG_IPC
S#define RT_DEBUG_IPC                   0
S#endif
S
S#ifndef RT_DEBUG_INIT
S#define RT_DEBUG_INIT                  0
S#endif
S
S/* Turn on this to enable context check */
S#ifndef RT_DEBUG_CONTEXT_CHECK
S#define RT_DEBUG_CONTEXT_CHECK         1
S#endif
S
S#define RT_DEBUG_LOG(type, message)                                           \
Sdo                                                                            \
S{                                                                             \
S    if (type)                                                                 \
S        rt_kprintf message;                                                   \
S}                                                                             \
Swhile (0)
X#define RT_DEBUG_LOG(type, message)                                           do                                                                            {                                                                                 if (type)                                                                         rt_kprintf message;                                                   }                                                                             while (0)
S
S#define RT_ASSERT(EX)                                                         \
Sif (!(EX))                                                                    \
S{                                                                             \
S    rt_assert_handler(#EX, __FUNCTION__, __LINE__);                           \
S}
X#define RT_ASSERT(EX)                                                         if (!(EX))                                                                    {                                                                                 rt_assert_handler(#EX, __FUNCTION__, __LINE__);                           }
S
S/* Macro to check current context */
S#if RT_DEBUG_CONTEXT_CHECK
S#define RT_DEBUG_NOT_IN_INTERRUPT                                             \
Sdo                                                                            \
S{                                                                             \
S    rt_base_t level;                                                          \
S    level = rt_hw_interrupt_disable();                                        \
S    if (rt_interrupt_get_nest() != 0)                                         \
S    {                                                                         \
S        rt_kprintf("Function[%s] shall not used in ISR\n", __FUNCTION__);     \
S        RT_ASSERT(0)                                                          \
S    }                                                                         \
S    rt_hw_interrupt_enable(level);                                            \
S}                                                                             \
Swhile (0)
X#define RT_DEBUG_NOT_IN_INTERRUPT                                             do                                                                            {                                                                                 rt_base_t level;                                                              level = rt_hw_interrupt_disable();                                            if (rt_interrupt_get_nest() != 0)                                             {                                                                                 rt_kprintf("Function[%s] shall not used in ISR\n", __FUNCTION__);             RT_ASSERT(0)                                                              }                                                                             rt_hw_interrupt_enable(level);                                            }                                                                             while (0)
S
S/* "In thread context" means:
S *     1) the scheduler has been started
S *     2) not in interrupt context.
S */
S#define RT_DEBUG_IN_THREAD_CONTEXT                                            \
Sdo                                                                            \
S{                                                                             \
S    rt_base_t level;                                                          \
S    level = rt_hw_interrupt_disable();                                        \
S    if (rt_thread_self() == RT_NULL)                                          \
S    {                                                                         \
S        rt_kprintf("Function[%s] shall not be used before scheduler start\n", \
S                   __FUNCTION__);                                             \
S        RT_ASSERT(0)                                                          \
S    }                                                                         \
S    RT_DEBUG_NOT_IN_INTERRUPT;                                                \
S    rt_hw_interrupt_enable(level);                                            \
S}                                                                             \
Swhile (0)
X#define RT_DEBUG_IN_THREAD_CONTEXT                                            do                                                                            {                                                                                 rt_base_t level;                                                              level = rt_hw_interrupt_disable();                                            if (rt_thread_self() == RT_NULL)                                              {                                                                                 rt_kprintf("Function[%s] shall not be used before scheduler start\n",                    __FUNCTION__);                                                     RT_ASSERT(0)                                                              }                                                                             RT_DEBUG_NOT_IN_INTERRUPT;                                                    rt_hw_interrupt_enable(level);                                            }                                                                             while (0)
S#else
S#define RT_DEBUG_NOT_IN_INTERRUPT
S#define RT_DEBUG_IN_THREAD_CONTEXT
S#endif
S
N#else /* RT_DEBUG */
N
N#define RT_ASSERT(EX)
N#define RT_DEBUG_LOG(type, message)
N#define RT_DEBUG_NOT_IN_INTERRUPT
N#define RT_DEBUG_IN_THREAD_CONTEXT
N
N#endif /* RT_DEBUG */
N
N#endif /* __RTDEBUG_H__ */
L 37 "..\..\include\rtthread.h" 2
N#include <rtdef.h>
L 1 "..\..\include\rtdef.h" 1
N/*
N * File      : rtdef.h
N * This file is part of RT-Thread RTOS
N * COPYRIGHT (C) 2006 - 2015, RT-Thread Development Team
N *
N *  This program is free software; you can redistribute it and/or modify
N *  it under the terms of the GNU General Public License as published by
N *  the Free Software Foundation; either version 2 of the License, or
N *  (at your option) any later version.
N *
N *  This program is distributed in the hope that it will be useful,
N *  but WITHOUT ANY WARRANTY; without even the implied warranty of
N *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
N *  GNU General Public License for more details.
N *
N *  You should have received a copy of the GNU General Public License along
N *  with this program; if not, write to the Free Software Foundation, Inc.,
N *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
N *
N * Change Logs:
N * Date           Author       Notes
N * 2007-01-10     Bernard      the first version
N * 2008-07-12     Bernard      remove all rt_int8, rt_uint32_t etc typedef
N * 2010-10-26     yi.qiu       add module support
N * 2010-11-10     Bernard      add cleanup callback function in thread exit.
N * 2011-05-09     Bernard      use builtin va_arg in GCC 4.x
N * 2012-11-16     Bernard      change RT_NULL from ((void*)0) to 0.
N * 2012-12-29     Bernard      change the RT_USING_MEMPOOL location and add
N *                             RT_USING_MEMHEAP condition.
N * 2012-12-30     Bernard      add more control command for graphic.
N * 2013-01-09     Bernard      change version number.
N * 2015-02-01     Bernard      change version number to v2.1.0
N */
N
N#ifndef __RT_DEF_H__
N#define __RT_DEF_H__
N
N/* include rtconfig header to import configuration */
N#include <rtconfig.h>
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/**
N * @addtogroup BasicDef
N */
N
N/*@{*/
N
N/* RT-Thread version information */
N#define RT_VERSION                      2L              /**< major version number */
N#define RT_SUBVERSION                   1L              /**< minor version number */
N#define RT_REVISION                     0L              /**< revise version number */
N
N/* RT-Thread version */
N#define RTTHREAD_VERSION                ((RT_VERSION * 10000) + \
N                                         (RT_SUBVERSION * 100) + RT_REVISION)
X#define RTTHREAD_VERSION                ((RT_VERSION * 10000) +                                          (RT_SUBVERSION * 100) + RT_REVISION)
N
N/* RT-Thread basic data type definitions */
Ntypedef signed   char                   rt_int8_t;      /**<  8bit integer type */
Ntypedef signed   short                  rt_int16_t;     /**< 16bit integer type */
Ntypedef signed   long                   rt_int32_t;     /**< 32bit integer type */
Ntypedef unsigned char                   rt_uint8_t;     /**<  8bit unsigned integer type */
Ntypedef unsigned short                  rt_uint16_t;    /**< 16bit unsigned integer type */
Ntypedef unsigned long                   rt_uint32_t;    /**< 32bit unsigned integer type */
Ntypedef int                             rt_bool_t;      /**< boolean type */
N
N/* 32bit CPU */
Ntypedef long                            rt_base_t;      /**< Nbit CPU related date type */
Ntypedef unsigned long                   rt_ubase_t;     /**< Nbit unsigned CPU related data type */
N
Ntypedef rt_base_t                       rt_err_t;       /**< Type for error number */
Ntypedef rt_uint32_t                     rt_time_t;      /**< Type for time stamp */
Ntypedef rt_uint32_t                     rt_tick_t;      /**< Type for tick count */
Ntypedef rt_base_t                       rt_flag_t;      /**< Type for flags */
Ntypedef rt_ubase_t                      rt_size_t;      /**< Type for size number */
Ntypedef rt_ubase_t                      rt_dev_t;       /**< Type for device */
Ntypedef rt_base_t                       rt_off_t;       /**< Type for offset */
N
N/* boolean type definitions */
N#define RT_TRUE                         1               /**< boolean true  */
N#define RT_FALSE                        0               /**< boolean fails */
N
N/*@}*/
N
N/* maximum value of base type */
N#define RT_UINT8_MAX                    0xff            /**< Maxium number of UINT8 */
N#define RT_UINT16_MAX                   0xffff          /**< Maxium number of UINT16 */
N#define RT_UINT32_MAX                   0xffffffff      /**< Maxium number of UINT32 */
N#define RT_TICK_MAX                     RT_UINT32_MAX   /**< Maxium number of tick */
N
N/* Compiler Related Definitions */
N#ifdef __CC_ARM                         /* ARM Compiler */
N    #include <stdarg.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdarg.h" 1
N/* stdarg.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.8 */
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright (C) ARM Ltd., 1991-1999. All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdarg_h
N#define __stdarg_h
N#define __ARMCLIB_VERSION 5060016
N
N  #ifndef __STDARG_DECLS
N  #define __STDARG_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N/*
N * stdarg.h declares a type and defines macros for advancing through a
N * list of arguments whose number and types are not known to the called
N * function when it is translated. A function may be called with a variable
N * number of arguments of differing types. Its parameter list contains one or
N * more parameters. The rightmost parameter plays a special role in the access
N * mechanism, and will be called parmN in this description.
N */
N
N/* N.B. <stdio.h> is required to declare vfprintf() without defining      */
N/* va_list.  Clearly the type __va_list there must keep in step.          */
N#ifdef __clang__
S  typedef __builtin_va_list va_list;
S  #define va_start(ap, param) __builtin_va_start(ap, param)
S  #define va_end(ap)          __builtin_va_end(ap)
S  #define va_arg(ap, type)    __builtin_va_arg(ap, type)
S  #if __STDC_VERSION__ >= 199900L || __cplusplus >= 201103L || !defined(__STRICT_ANSI__)
S  #define va_copy(dest, src)  __builtin_va_copy(dest, src)
S  #endif
N#else
N  #ifdef __TARGET_ARCH_AARCH64
S    typedef struct __va_list {
S      void *__stack;
S      void *__gr_top;
S      void *__vr_top;
S      int __gr_offs;
S      int __vr_offs;
S    } va_list;
N  #else
N    typedef struct __va_list { void *__ap; } va_list;
N  #endif
N   /*
N    * an array type suitable for holding information needed by the macro va_arg
N    * and the function va_end. The called function shall declare a variable
N    * (referred to as ap) having type va_list. The variable ap may be passed as
N    * an argument to another function.
N    * Note: va_list is an array type so that when an object of that type
N    * is passed as an argument it gets passed by reference.
N    */
N  #define va_start(ap, parmN) __va_start(ap, parmN)
N
N   /*
N    * The va_start macro shall be executed before any access to the unnamed
N    * arguments. The parameter ap points to an object that has type va_list.
N    * The va_start macro initialises ap for subsequent use by va_arg and
N    * va_end. The parameter parmN is the identifier of the rightmost parameter
N    * in the variable parameter list in the function definition (the one just
N    * before the '...'). If the parameter parmN is declared with the register
N    * storage class an error is given.
N    * If parmN is a narrow type (char, short, float) an error is given in
N    * strict ANSI mode, or a warning otherwise.
N    * Returns: no value.
N    */
N  #define va_arg(ap, type) __va_arg(ap, type)
N
N   /*
N    * The va_arg macro expands to an expression that has the type and value of
N    * the next argument in the call. The parameter ap shall be the same as the
N    * va_list ap initialised by va_start. Each invocation of va_arg modifies
N    * ap so that successive arguments are returned in turn. The parameter
N    * 'type' is a type name such that the type of a pointer to an object that
N    * has the specified type can be obtained simply by postfixing a * to
N    * 'type'. If type is a narrow type, an error is given in strict ANSI
N    * mode, or a warning otherwise. If the type is an array or function type,
N    * an error is given.
N    * In non-strict ANSI mode, 'type' is allowed to be any expression.
N    * Returns: The first invocation of the va_arg macro after that of the
N    *          va_start macro returns the value of the argument after that
N    *          specified by parmN. Successive invocations return the values of
N    *          the remaining arguments in succession.
N    *          The result is cast to 'type', even if 'type' is narrow.
N    */
N
N#define __va_copy(dest, src) ((void)((dest) = (src)))
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
N   /* va_copy is in C99 and non-strict C90 and non-strict C++
N    * __va_copy is always present.
N    */
N  #define va_copy(dest, src) ((void)((dest) = (src)))
N
N   /* The va_copy macro makes the va_list dest be a copy of
N    * the va_list src, as if the va_start macro had been applied
N    * to it followed by the same sequence of uses of the va_arg
N    * macro as had previously been used to reach the present state
N    * of src.
N    */
N#endif
N
N#define va_end(ap) __va_end(ap)
N   /*
N    * The va_end macro facilitates a normal return from the function whose
N    * variable argument list was referenced by the expansion of va_start that
N    * initialised the va_list ap. If the va_end macro is not invoked before
N    * the return, the behaviour is undefined.
N    * Returns: no value.
N    */
N#endif /* __clang__ */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N
N    #ifdef __GNUC__
S     /* be cooperative with glibc */
S     typedef __CLIBNS va_list __gnuc_va_list;
S     #define __GNUC_VA_LIST
S     #undef __need___va_list
N    #endif
N
N  #endif /* __STDARG_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDARG_NO_EXPORTS
S      using ::std::va_list;
S    #endif
N  #endif /* __cplusplus */
N#endif
N
N/* end of stdarg.h */
N
L 96 "..\..\include\rtdef.h" 2
N    #define SECTION(x)                  __attribute__((section(x)))
N    #define RT_UNUSED                   __attribute__((unused))
N    #define RT_USED                     __attribute__((used))
N    #define ALIGN(n)                    __attribute__((aligned(n)))
N    #define WEAK						__weak
N    #define rt_inline                   static __inline
N    /* module compiling */
N    #ifdef RT_USING_MODULE
S        #define RTT_API                 __declspec(dllimport)
N    #else
N        #define RTT_API                 __declspec(dllexport)
N    #endif
N
N#elif defined (__IAR_SYSTEMS_ICC__)     /* for IAR Compiler */
S    #include <stdarg.h>
S    #define SECTION(x)                  @ x
S    #define RT_UNUSED
S    #define RT_USED
S    #define PRAGMA(x)                   _Pragma(#x)
S    #define ALIGN(n)                    PRAGMA(data_alignment=n)
S    #define WEAK                        __weak
S    #define rt_inline                   static inline
S    #define RTT_API
S
S#elif defined (__GNUC__)                /* GNU GCC Compiler */
S    #ifdef RT_USING_NEWLIB
S        #include <stdarg.h>
S    #else
S		/* the version of GNU GCC must be greater than 4.x */
S        typedef __builtin_va_list   __gnuc_va_list;
S        typedef __gnuc_va_list      va_list;
S        #define va_start(v,l)       __builtin_va_start(v,l)
S        #define va_end(v)           __builtin_va_end(v)
S        #define va_arg(v,l)         __builtin_va_arg(v,l)
S    #endif
S
S    #define SECTION(x)                  __attribute__((section(x)))
S    #define RT_UNUSED                   __attribute__((unused))
S    #define RT_USED                     __attribute__((used))
S    #define ALIGN(n)                    __attribute__((aligned(n)))
S    #define WEAK                        __attribute__((weak))
S    #define rt_inline                   static __inline
S    #define RTT_API
S#elif defined (__ADSPBLACKFIN__)        /* for VisualDSP++ Compiler */
S    #include <stdarg.h>
S    #define SECTION(x)                  __attribute__((section(x)))
S    #define RT_UNUSED                   __attribute__((unused))
S    #define RT_USED                     __attribute__((used))
S    #define ALIGN(n)                    __attribute__((aligned(n)))
S	#define WEAK                        __attribute__((weak))
S    #define rt_inline                   static inline
S    #define RTT_API
S#elif defined (_MSC_VER)
S    #include <stdarg.h>
S    #define SECTION(x)
S    #define RT_UNUSED
S    #define RT_USED
S    #define ALIGN(n)                    __declspec(align(n))
S	#define WEAK
S    #define rt_inline                   static __inline
S    #define RTT_API
S#elif defined (__TI_COMPILER_VERSION__)
S    #include <stdarg.h>
S    /* The way that TI compiler set section is different from other(at least
S     * GCC and MDK) compilers. See ARM Optimizing C/C++ Compiler 5.9.3 for more
S     * details. */
S    #define SECTION(x)
S    #define RT_UNUSED
S    #define RT_USED
S    #define PRAGMA(x)                   _Pragma(#x)
S    #define ALIGN(n)
S    #define WEAK
S    #define rt_inline                   static inline
S    #define RTT_API
S#else
S    #error not supported tool chain
N#endif
N
N/* initialization export */
N#ifdef RT_USING_COMPONENTS_INIT
Ntypedef int (*init_fn_t)(void);
N#ifdef _MSC_VER /* we do not support MS VC++ compiler */
S    #define INIT_EXPORT(fn, level)
N#else
N	#if RT_DEBUG_INIT
S		struct rt_init_desc
S		{
S			const char* fn_name;
S			const init_fn_t fn;
S		};
S		#define INIT_EXPORT(fn, level)  		\
S			const char __rti_##fn##_name[] = #fn; \
S			const struct rt_init_desc __rt_init_desc_##fn SECTION(".rti_fn."level) = \
S			{ __rti_##fn##_name, fn};
X		#define INIT_EXPORT(fn, level)  					const char __rti_##fn##_name[] = #fn; 			const struct rt_init_desc __rt_init_desc_##fn SECTION(".rti_fn."level) = 			{ __rti_##fn##_name, fn};
N	#else
N    	#define INIT_EXPORT(fn, level)  \
N        	const init_fn_t __rt_init_##fn SECTION(".rti_fn."level) = fn
X    	#define INIT_EXPORT(fn, level)          	const init_fn_t __rt_init_##fn SECTION(".rti_fn."level) = fn
N	#endif
N#endif
N#else
S#define INIT_EXPORT(fn, level)
N#endif
N
N/* board init routines will be called in board_init() function */
N#define INIT_BOARD_EXPORT(fn)           INIT_EXPORT(fn, "1")
N/* device/component/fs/app init routines will be called in init_thread */
N/* device initialization */
N#define INIT_DEVICE_EXPORT(fn)          INIT_EXPORT(fn, "2")
N/* components initialization (dfs, lwip, ...) */
N#define INIT_COMPONENT_EXPORT(fn)       INIT_EXPORT(fn, "3")
N/* file system initialization (dfs-elm, dfs-rom, ...) */
N#define INIT_FS_EXPORT(fn)              INIT_EXPORT(fn, "4")
N/* environment initialization (mount disk, ...) */
N#define INIT_ENV_EXPORT(fn)				INIT_EXPORT(fn, "5")
N/* appliation initialization (rtgui application etc ...) */
N#define INIT_APP_EXPORT(fn)             INIT_EXPORT(fn, "6")
N
N#if !defined(RT_USING_FINSH)
X#if !1L
S/* define these to empty, even if not include finsh.h file */
S#define FINSH_FUNCTION_EXPORT(name, desc)
S#define FINSH_FUNCTION_EXPORT_ALIAS(name, alias, desc)
S#define FINSH_VAR_EXPORT(name, type, desc)
S
S#define MSH_CMD_EXPORT(command, desc)
S#define MSH_CMD_EXPORT_ALIAS(command, alias, desc)
S#elif !defined(FINSH_USING_SYMTAB)
X#elif !1L
S#define FINSH_FUNCTION_EXPORT_CMD(name, cmd, desc)
N#endif
N
N/* event length */
N#define RT_EVENT_LENGTH                 32
N
N/* memory management option */
N#define RT_MM_PAGE_SIZE                 4096
N#define RT_MM_PAGE_MASK                 (RT_MM_PAGE_SIZE - 1)
N#define RT_MM_PAGE_BITS                 12
N
N/* kernel malloc definitions */
N#ifndef RT_KERNEL_MALLOC
N#define RT_KERNEL_MALLOC(sz)            rt_malloc(sz)
N#endif
N
N#ifndef RT_KERNEL_FREE
N#define RT_KERNEL_FREE(ptr)             rt_free(ptr)
N#endif
N
N#ifndef RT_KERNEL_REALLOC
N#define RT_KERNEL_REALLOC(ptr, size)    rt_realloc(ptr, size)
N#endif
N
N/**
N * @addtogroup Error
N */
N
N/*@{*/
N
N/* RT-Thread error code definitions */
N#define RT_EOK                          0               /**< There is no error */
N#define RT_ERROR                        1               /**< A generic error happens */
N#define RT_ETIMEOUT                     2               /**< Timed out */
N#define RT_EFULL                        3               /**< The resource is full */
N#define RT_EEMPTY                       4               /**< The resource is empty */
N#define RT_ENOMEM                       5               /**< No memory */
N#define RT_ENOSYS                       6               /**< No system */
N#define RT_EBUSY                        7               /**< Busy */
N#define RT_EIO                          8               /**< IO error */
N
N/*@}*/
N
N/**
N * @ingroup BasicDef
N *
N * @def RT_ALIGN(size, align)
N * Return the most contiguous size aligned at specified width. RT_ALIGN(13, 4)
N * would return 16.
N */
N#define RT_ALIGN(size, align)           (((size) + (align) - 1) & ~((align) - 1))
N
N/**
N * @ingroup BasicDef
N *
N * @def RT_ALIGN_DOWN(size, align)
N * Return the down number of aligned at specified width. RT_ALIGN_DOWN(13, 4)
N * would return 12.
N */
N#define RT_ALIGN_DOWN(size, align)      ((size) & ~((align) - 1))
N
N/**
N * @ingroup BasicDef
N *
N * @def RT_NULL
N * Similar as the \c NULL in C library.
N */
N#define RT_NULL                         (0)
N
Nstruct rt_list_node
N{
N    struct rt_list_node *next;                          /**< point to next node. */
N    struct rt_list_node *prev;                          /**< point to prev node. */
N};
Ntypedef struct rt_list_node rt_list_t;                  /**< Type for lists. */
N
N/**
N * @addtogroup KernelObject
N */
N
N/*@{*/
N
N/*
N * kernel object macros
N */
N#define RT_OBJECT_FLAG_MODULE           0x80            /**< is module object. */
N
N/**
N * Base structure of Kernel object
N */
Nstruct rt_object
N{
N    char       name[RT_NAME_MAX];                       /**< name of kernel object */
X    char       name[8];                        
N    rt_uint8_t type;                                    /**< type of kernel object */
N    rt_uint8_t flag;                                    /**< flag of kernel object */
N
N#ifdef RT_USING_MODULE
S    void      *module_id;                               /**< id of application module */
N#endif
N    rt_list_t  list;                                    /**< list node of kernel object */
N};
Ntypedef struct rt_object *rt_object_t;                  /**< Type for kernel objects. */
N
N/**
N *  The object type can be one of the follows with specific
N *  macros enabled:
N *  - Thread
N *  - Semaphore
N *  - Mutex
N *  - Event
N *  - MailBox
N *  - MessageQueue
N *  - MemHeap
N *  - MemPool
N *  - Device
N *  - Timer
N *  - Module
N *  - Unknown
N *  - Static
N */
Nenum rt_object_class_type
N{
N    RT_Object_Class_Thread = 0,                         /**< The object is a thread. */
N#ifdef RT_USING_SEMAPHORE
N    RT_Object_Class_Semaphore,                          /**< The object is a semaphore. */
N#endif
N#ifdef RT_USING_MUTEX
N    RT_Object_Class_Mutex,                              /**< The object is a mutex. */
N#endif
N#ifdef RT_USING_EVENT
N    RT_Object_Class_Event,                              /**< The object is a event. */
N#endif
N#ifdef RT_USING_MAILBOX
N    RT_Object_Class_MailBox,                            /**< The object is a mail box. */
N#endif
N#ifdef RT_USING_MESSAGEQUEUE
N    RT_Object_Class_MessageQueue,                       /**< The object is a message queue. */
N#endif
N#ifdef RT_USING_MEMHEAP
S    RT_Object_Class_MemHeap,                            /**< The object is a memory heap */
N#endif
N#ifdef RT_USING_MEMPOOL
N    RT_Object_Class_MemPool,                            /**< The object is a memory pool. */
N#endif
N#ifdef RT_USING_DEVICE
N    RT_Object_Class_Device,                             /**< The object is a device */
N#endif
N    RT_Object_Class_Timer,                              /**< The object is a timer. */
N#ifdef RT_USING_MODULE
S    RT_Object_Class_Module,                             /**< The object is a module. */
N#endif
N    RT_Object_Class_Unknown,                            /**< The object is unknown. */
N    RT_Object_Class_Static = 0x80                       /**< The object is a static object. */
N};
N
N/**
N * The information of the kernel object
N */
Nstruct rt_object_information
N{
N    enum rt_object_class_type type;                     /**< object class type */
N    rt_list_t                 object_list;              /**< object list */
N    rt_size_t                 object_size;              /**< object size */
N};
N
N/**
N * The hook function call macro
N */
N#ifdef RT_USING_HOOK
S#define RT_OBJECT_HOOK_CALL(func, argv) \
S    do { if ((func) != RT_NULL) func argv; } while (0)
X#define RT_OBJECT_HOOK_CALL(func, argv)     do { if ((func) != RT_NULL) func argv; } while (0)
N#else
N#define RT_OBJECT_HOOK_CALL(func, argv)
N#endif
N
N/*@}*/
N
N/**
N * @addtogroup Clock
N */
N
N/*@{*/
N
N/**
N * clock & timer macros
N */
N#define RT_TIMER_FLAG_DEACTIVATED       0x0             /**< timer is deactive */
N#define RT_TIMER_FLAG_ACTIVATED         0x1             /**< timer is active */
N#define RT_TIMER_FLAG_ONE_SHOT          0x0             /**< one shot timer */
N#define RT_TIMER_FLAG_PERIODIC          0x2             /**< periodic timer */
N
N#define RT_TIMER_FLAG_HARD_TIMER        0x0             /**< hard timer,the timer's callback function will be called in tick isr. */
N#define RT_TIMER_FLAG_SOFT_TIMER        0x4             /**< soft timer,the timer's callback function will be called in timer thread. */
N
N#define RT_TIMER_CTRL_SET_TIME          0x0             /**< set timer control command */
N#define RT_TIMER_CTRL_GET_TIME          0x1             /**< get timer control command */
N#define RT_TIMER_CTRL_SET_ONESHOT       0x2             /**< change timer to one shot */
N#define RT_TIMER_CTRL_SET_PERIODIC      0x3             /**< change timer to periodic */
N
N#ifndef RT_TIMER_SKIP_LIST_LEVEL
N#define RT_TIMER_SKIP_LIST_LEVEL          1
N#endif
N
N/* 1 or 3 */
N#ifndef RT_TIMER_SKIP_LIST_MASK
N#define RT_TIMER_SKIP_LIST_MASK         0x3
N#endif
N
N/**
N * timer structure
N */
Nstruct rt_timer
N{
N    struct rt_object parent;                            /**< inherit from rt_object */
N
N    rt_list_t        row[RT_TIMER_SKIP_LIST_LEVEL];
X    rt_list_t        row[1];
N
N    void (*timeout_func)(void *parameter);              /**< timeout function */
N    void            *parameter;                         /**< timeout function's parameter */
N
N    rt_tick_t        init_tick;                         /**< timer timeout tick */
N    rt_tick_t        timeout_tick;                      /**< timeout tick */
N};
Ntypedef struct rt_timer *rt_timer_t;
N
N/*@}*/
N
N/**
N * @addtogroup Thread
N */
N
N/*@{*/
N
N/*
N * Thread
N */
N
N/*
N * thread state definitions
N */
N#define RT_THREAD_INIT                  0x00                /**< Initialized status */
N#define RT_THREAD_READY                 0x01                /**< Ready status */
N#define RT_THREAD_SUSPEND               0x02                /**< Suspend status */
N#define RT_THREAD_RUNNING               0x03                /**< Running status */
N#define RT_THREAD_BLOCK                 RT_THREAD_SUSPEND   /**< Blocked status */
N#define RT_THREAD_CLOSE                 0x04                /**< Closed status */
N
N/**
N * thread control command definitions
N */
N#define RT_THREAD_CTRL_STARTUP          0x00                /**< Startup thread. */
N#define RT_THREAD_CTRL_CLOSE            0x01                /**< Close thread. */
N#define RT_THREAD_CTRL_CHANGE_PRIORITY  0x02                /**< Change thread priority. */
N#define RT_THREAD_CTRL_INFO             0x03                /**< Get thread information. */
N
N/**
N * Thread structure
N */
Nstruct rt_thread
N{
N    /* rt object */
N    char        name[RT_NAME_MAX];                      /**< the name of thread */
X    char        name[8];                       
N    rt_uint8_t  type;                                   /**< type of object */
N    rt_uint8_t  flags;                                  /**< thread's flags */
N
N#ifdef RT_USING_MODULE
S    void       *module_id;                              /**< id of application module */
N#endif
N
N    rt_list_t   list;                                   /**< the object list */
N    rt_list_t   tlist;                                  /**< the thread list */
N
N    /* stack point and entry */
N    void       *sp;                                     /**< stack point */
N    void       *entry;                                  /**< entry */
N    void       *parameter;                              /**< parameter */
N    void       *stack_addr;                             /**< stack address */
N    rt_uint32_t stack_size;                             /**< stack size */
N
N    /* error code */
N    rt_err_t    error;                                  /**< error code */
N
N    rt_uint8_t  stat;                                   /**< thread stat */
N
N    /* priority */
N    rt_uint8_t  current_priority;                       /**< current priority */
N    rt_uint8_t  init_priority;                          /**< initialized priority */
N#if RT_THREAD_PRIORITY_MAX > 32
X#if 32 > 32
S    rt_uint8_t  number;
S    rt_uint8_t  high_mask;
N#endif
N    rt_uint32_t number_mask;
N
N#if defined(RT_USING_EVENT)
X#if 1L
N    /* thread event */
N    rt_uint32_t event_set;
N    rt_uint8_t  event_info;
N#endif
N
N    rt_ubase_t  init_tick;                              /**< thread's initialized tick */
N    rt_ubase_t  remaining_tick;                         /**< remaining tick */
N
N    struct rt_timer thread_timer;                       /**< built-in thread timer */
N
N    void (*cleanup)(struct rt_thread *tid);             /**< cleanup function when thread exit */
N
N    rt_uint32_t user_data;                              /**< private user data beyond this thread */
N};
Ntypedef struct rt_thread *rt_thread_t;
N
N/*@}*/
N
N/**
N * @addtogroup IPC
N */
N
N/*@{*/
N
N/**
N * IPC flags and control command definitions
N */
N#define RT_IPC_FLAG_FIFO                0x00            /**< FIFOed IPC. @ref IPC. */
N#define RT_IPC_FLAG_PRIO                0x01            /**< PRIOed IPC. @ref IPC. */
N
N#define RT_IPC_CMD_UNKNOWN              0x00            /**< unknown IPC command */
N#define RT_IPC_CMD_RESET                0x01            /**< reset IPC object */
N
N#define RT_WAITING_FOREVER              -1              /**< Block forever until get resource. */
N#define RT_WAITING_NO                   0               /**< Non-block. */
N
N/**
N * Base structure of IPC object
N */
Nstruct rt_ipc_object
N{
N    struct rt_object parent;                            /**< inherit from rt_object */
N
N    rt_list_t        suspend_thread;                    /**< threads pended on this resource */
N};
N
N#ifdef RT_USING_SEMAPHORE
N/**
N * Semaphore structure
N */
Nstruct rt_semaphore
N{
N    struct rt_ipc_object parent;                        /**< inherit from ipc_object */
N
N    rt_uint16_t          value;                         /**< value of semaphore. */
N};
Ntypedef struct rt_semaphore *rt_sem_t;
N#endif
N
N#ifdef RT_USING_MUTEX
N/**
N * Mutual exclusion (mutex) structure
N */
Nstruct rt_mutex
N{
N    struct rt_ipc_object parent;                        /**< inherit from ipc_object */
N
N    rt_uint16_t          value;                         /**< value of mutex */
N
N    rt_uint8_t           original_priority;             /**< priority of last thread hold the mutex */
N    rt_uint8_t           hold;                          /**< numbers of thread hold the mutex */
N
N    struct rt_thread    *owner;                         /**< current owner of mutex */
N};
Ntypedef struct rt_mutex *rt_mutex_t;
N#endif
N
N#ifdef RT_USING_EVENT
N/**
N * flag defintions in event
N */
N#define RT_EVENT_FLAG_AND               0x01            /**< logic and */
N#define RT_EVENT_FLAG_OR                0x02            /**< logic or */
N#define RT_EVENT_FLAG_CLEAR             0x04            /**< clear flag */
N
N/*
N * event structure
N */
Nstruct rt_event
N{
N    struct rt_ipc_object parent;                        /**< inherit from ipc_object */
N
N    rt_uint32_t          set;                           /**< event set */
N};
Ntypedef struct rt_event *rt_event_t;
N#endif
N
N#ifdef RT_USING_MAILBOX
N/**
N * mailbox structure
N */
Nstruct rt_mailbox
N{
N    struct rt_ipc_object parent;                        /**< inherit from ipc_object */
N
N    rt_uint32_t         *msg_pool;                      /**< start address of message buffer */
N
N    rt_uint16_t          size;                          /**< size of message pool */
N
N    rt_uint16_t          entry;                         /**< index of messages in msg_pool */
N    rt_uint16_t          in_offset;                     /**< input offset of the message buffer */
N    rt_uint16_t          out_offset;                    /**< output offset of the message buffer */
N
N    rt_list_t            suspend_sender_thread;         /**< sender thread suspended on this mailbox */
N};
Ntypedef struct rt_mailbox *rt_mailbox_t;
N#endif
N
N#ifdef RT_USING_MESSAGEQUEUE
N/**
N * message queue structure
N */
Nstruct rt_messagequeue
N{
N    struct rt_ipc_object parent;                        /**< inherit from ipc_object */
N
N    void                *msg_pool;                      /**< start address of message queue */
N
N    rt_uint16_t          msg_size;                      /**< message size of each message */
N    rt_uint16_t          max_msgs;                      /**< max number of messages */
N
N    rt_uint16_t          entry;                         /**< index of messages in the queue */
N
N    void                *msg_queue_head;                /**< list head */
N    void                *msg_queue_tail;                /**< list tail */
N    void                *msg_queue_free;                /**< pointer indicated the free node of queue */
N};
Ntypedef struct rt_messagequeue *rt_mq_t;
N#endif
N
N/*@}*/
N
N/**
N * @addtogroup MM
N */
N
N/*@{*/
N
N/*
N * memory management
N * heap & partition
N */
N
N#ifdef RT_USING_MEMHEAP
S/**
S * memory item on the heap
S */
Sstruct rt_memheap_item
S{
S    rt_uint32_t             magic;                      /**< magic number for memheap */
S    struct rt_memheap      *pool_ptr;                   /**< point of pool */
S
S    struct rt_memheap_item *next;                       /**< next memheap item */
S    struct rt_memheap_item *prev;                       /**< prev memheap item */
S
S    struct rt_memheap_item *next_free;                  /**< next free memheap item */
S    struct rt_memheap_item *prev_free;                  /**< prev free memheap item */
S};
S
S/**
S * Base structure of memory heap object
S */
Sstruct rt_memheap
S{
S    struct rt_object        parent;                     /**< inherit from rt_object */
S
S    void                   *start_addr;                 /**< pool start address and size */
S
S    rt_uint32_t             pool_size;                  /**< pool size */
S    rt_uint32_t             available_size;             /**< available size */
S    rt_uint32_t             max_used_size;              /**< maximum allocated size */
S
S    struct rt_memheap_item *block_list;                 /**< used block list */
S
S    struct rt_memheap_item *free_list;                  /**< free block list */
S    struct rt_memheap_item  free_header;                /**< free block list header */
S
S    struct rt_semaphore     lock;                       /**< semaphore lock */
S};
N#endif
N
N#ifdef RT_USING_MEMPOOL
N/**
N * Base structure of Memory pool object
N */
Nstruct rt_mempool
N{
N    struct rt_object parent;                            /**< inherit from rt_object */
N
N    void            *start_address;                     /**< memory pool start */
N    rt_size_t        size;                              /**< size of memory pool */
N
N    rt_size_t        block_size;                        /**< size of memory blocks */
N    rt_uint8_t      *block_list;                        /**< memory blocks list */
N
N    rt_size_t        block_total_count;                 /**< numbers of memory block */
N    rt_size_t        block_free_count;                  /**< numbers of free memory block */
N
N    rt_list_t        suspend_thread;                    /**< threads pended on this resource */
N    rt_size_t        suspend_thread_count;              /**< numbers of thread pended on this resource */
N};
Ntypedef struct rt_mempool *rt_mp_t;
N#endif
N
N/*@}*/
N
N#ifdef RT_USING_DEVICE
N/**
N * @addtogroup Device
N */
N
N/*@{*/
N
N/**
N * device (I/O) class type
N */
Nenum rt_device_class_type
N{
N    RT_Device_Class_Char = 0,                           /**< character device */
N    RT_Device_Class_Block,                              /**< block device */
N    RT_Device_Class_NetIf,                              /**< net interface */
N    RT_Device_Class_MTD,                                /**< memory device */
N    RT_Device_Class_CAN,                                /**< CAN device */
N    RT_Device_Class_RTC,                                /**< RTC device */
N    RT_Device_Class_Sound,                              /**< Sound device */
N    RT_Device_Class_Graphic,                            /**< Graphic device */
N    RT_Device_Class_I2CBUS,                             /**< I2C bus device */
N    RT_Device_Class_USBDevice,                          /**< USB slave device */
N    RT_Device_Class_USBHost,                            /**< USB host bus */
N    RT_Device_Class_SPIBUS,                             /**< SPI bus device */
N    RT_Device_Class_SPIDevice,                          /**< SPI device */
N    RT_Device_Class_SDIO,                               /**< SDIO bus device */
N    RT_Device_Class_PM,                                 /**< PM pseudo device */
N    RT_Device_Class_Pipe,                               /**< Pipe device */
N    RT_Device_Class_Portal,                             /**< Portal device */
N    RT_Device_Class_Timer,                              /**< Timer device */
N	RT_Device_Class_Miscellaneous,                      /**< Miscellaneous device */
N	RT_Device_Class_Unknown                             /**< unknown device */
N};
N
N/**
N * device flags defitions
N */
N#define RT_DEVICE_FLAG_DEACTIVATE       0x000           /**< device is not not initialized */
N
N#define RT_DEVICE_FLAG_RDONLY           0x001           /**< read only */
N#define RT_DEVICE_FLAG_WRONLY           0x002           /**< write only */
N#define RT_DEVICE_FLAG_RDWR             0x003           /**< read and write */
N
N#define RT_DEVICE_FLAG_REMOVABLE        0x004           /**< removable device */
N#define RT_DEVICE_FLAG_STANDALONE       0x008           /**< standalone device */
N#define RT_DEVICE_FLAG_ACTIVATED        0x010           /**< device is activated */
N#define RT_DEVICE_FLAG_SUSPENDED        0x020           /**< device is suspended */
N#define RT_DEVICE_FLAG_STREAM           0x040           /**< stream mode */
N
N#define RT_DEVICE_CTRL_CONFIG           0x03    	/* configure device */
N#define RT_DEVICE_CTRL_SET_INT          0x10    	/* enable receive irq */
N#define RT_DEVICE_CTRL_CLR_INT          0x11    	/* disable receive irq */
N#define RT_DEVICE_CTRL_GET_INT          0x12
N
N#define RT_DEVICE_FLAG_INT_RX           0x100           /**< INT mode on Rx */
N#define RT_DEVICE_FLAG_DMA_RX           0x200           /**< DMA mode on Rx */
N#define RT_DEVICE_FLAG_INT_TX           0x400           /**< INT mode on Tx */
N#define RT_DEVICE_FLAG_DMA_TX           0x800           /**< DMA mode on Tx */
N
N#define RT_DEVICE_OFLAG_CLOSE           0x000           /**< device is closed */
N#define RT_DEVICE_OFLAG_RDONLY          0x001           /**< read only access */
N#define RT_DEVICE_OFLAG_WRONLY          0x002           /**< write only access */
N#define RT_DEVICE_OFLAG_RDWR            0x003           /**< read and write */
N#define RT_DEVICE_OFLAG_OPEN            0x008           /**< device is opened */
N
N/**
N * general device commands
N */
N#define RT_DEVICE_CTRL_RESUME           0x01            /**< resume device */
N#define RT_DEVICE_CTRL_SUSPEND          0x02            /**< suspend device */
N
N/**
N * special device commands
N */
N#define RT_DEVICE_CTRL_CHAR_STREAM      0x10            /**< stream mode on char device */
N#define RT_DEVICE_CTRL_BLK_GETGEOME     0x10            /**< get geometry information   */
N#define RT_DEVICE_CTRL_BLK_SYNC         0x11            /**< flush data to block device */
N#define RT_DEVICE_CTRL_BLK_ERASE        0x12            /**< erase block on block device */
N#define RT_DEVICE_CTRL_BLK_AUTOREFRESH  0x13            /**< block device : enter/exit auto refresh mode */
N#define RT_DEVICE_CTRL_NETIF_GETMAC     0x10            /**< get mac address */
N#define RT_DEVICE_CTRL_MTD_FORMAT       0x10            /**< format a MTD device */
N#define RT_DEVICE_CTRL_RTC_GET_TIME     0x10            /**< get time */
N#define RT_DEVICE_CTRL_RTC_SET_TIME     0x11            /**< set time */
N#define RT_DEVICE_CTRL_RTC_GET_ALARM    0x12            /**< get alarm */
N#define RT_DEVICE_CTRL_RTC_SET_ALARM    0x13            /**< set alarm */
N
Ntypedef struct rt_device *rt_device_t;
N/**
N * Device structure
N */
Nstruct rt_device
N{
N    struct rt_object          parent;                   /**< inherit from rt_object */
N
N    enum rt_device_class_type type;                     /**< device type */
N    rt_uint16_t               flag;                     /**< device flag */
N    rt_uint16_t               open_flag;                /**< device open flag */
N
N    rt_uint8_t                ref_count;                /**< reference count */
N    rt_uint8_t                device_id;                /**< 0 - 255 */
N
N    /* device call back */
N    rt_err_t (*rx_indicate)(rt_device_t dev, rt_size_t size);
N    rt_err_t (*tx_complete)(rt_device_t dev, void *buffer);
N
N    /* common device interface */
N    rt_err_t  (*init)   (rt_device_t dev);
N    rt_err_t  (*open)   (rt_device_t dev, rt_uint16_t oflag);
N    rt_err_t  (*close)  (rt_device_t dev);
N    rt_size_t (*read)   (rt_device_t dev, rt_off_t pos, void *buffer, rt_size_t size);
N    rt_size_t (*write)  (rt_device_t dev, rt_off_t pos, const void *buffer, rt_size_t size);
N    rt_err_t  (*control)(rt_device_t dev, rt_uint8_t cmd, void *args);
N
N    void                     *user_data;                /**< device private data */
N};
N
N/**
N * block device geometry structure
N */
Nstruct rt_device_blk_geometry
N{
N    rt_uint32_t sector_count;                           /**< count of sectors */
N    rt_uint32_t bytes_per_sector;                       /**< number of bytes per sector */
N    rt_uint32_t block_size;                             /**< number of bytes to erase one block */
N};
N
N/**
N * sector arrange struct on block device
N */
Nstruct rt_device_blk_sectors
N{
N    rt_uint32_t sector_begin;                           /**< begin sector */
N    rt_uint32_t sector_end;                             /**< end sector   */
N};
N
N/**
N * cursor control command
N */
N#define RT_DEVICE_CTRL_CURSOR_SET_POSITION  0x10
N#define RT_DEVICE_CTRL_CURSOR_SET_TYPE      0x11
N
N/**
N * graphic device control command
N */
N#define RTGRAPHIC_CTRL_RECT_UPDATE      0
N#define RTGRAPHIC_CTRL_POWERON          1
N#define RTGRAPHIC_CTRL_POWEROFF         2
N#define RTGRAPHIC_CTRL_GET_INFO         3
N#define RTGRAPHIC_CTRL_SET_MODE         4
N#define RTGRAPHIC_CTRL_GET_EXT          5
N
N/* graphic deice */
Nenum
N{
N    RTGRAPHIC_PIXEL_FORMAT_MONO = 0,
N    RTGRAPHIC_PIXEL_FORMAT_GRAY4,
N    RTGRAPHIC_PIXEL_FORMAT_GRAY16,
N    RTGRAPHIC_PIXEL_FORMAT_RGB332,
N    RTGRAPHIC_PIXEL_FORMAT_RGB444,
N    RTGRAPHIC_PIXEL_FORMAT_RGB565,
N    RTGRAPHIC_PIXEL_FORMAT_RGB565P,
N    RTGRAPHIC_PIXEL_FORMAT_BGR565 = RTGRAPHIC_PIXEL_FORMAT_RGB565P,
N    RTGRAPHIC_PIXEL_FORMAT_RGB666,
N    RTGRAPHIC_PIXEL_FORMAT_RGB888,
N    RTGRAPHIC_PIXEL_FORMAT_ARGB888,
N    RTGRAPHIC_PIXEL_FORMAT_ABGR888,
N    RTGRAPHIC_PIXEL_FORMAT_ARGB565,
N    RTGRAPHIC_PIXEL_FORMAT_ALPHA,
N};
N
N/**
N * build a pixel position according to (x, y) coordinates.
N */
N#define RTGRAPHIC_PIXEL_POSITION(x, y)  ((x << 16) | y)
N
N/**
N * graphic device information structure
N */
Nstruct rt_device_graphic_info
N{
N    rt_uint8_t  pixel_format;                           /**< graphic format */
N    rt_uint8_t  bits_per_pixel;                         /**< bits per pixel */
N    rt_uint16_t reserved;                               /**< reserved field */
N
N    rt_uint16_t width;                                  /**< width of graphic device */
N    rt_uint16_t height;                                 /**< height of graphic device */
N
N    rt_uint8_t *framebuffer;                            /**< frame buffer */
N};
N
N/**
N * rectangle information structure
N */
Nstruct rt_device_rect_info
N{
N    rt_uint16_t x;                                      /**< x coordinate */
N    rt_uint16_t y;                                      /**< y coordinate */
N    rt_uint16_t width;                                  /**< width */
N    rt_uint16_t height;                                 /**< height */
N};
N
N/**
N * graphic operations
N */
Nstruct rt_device_graphic_ops
N{
N    void (*set_pixel) (const char *pixel, int x, int y);
N    void (*get_pixel) (char *pixel, int x, int y);
N
N    void (*draw_hline)(const char *pixel, int x1, int x2, int y);
N    void (*draw_vline)(const char *pixel, int x, int y1, int y2);
N
N    void (*blit_line) (const char *pixel, int x, int y, rt_size_t size);
N};
N#define rt_graphix_ops(device)          ((struct rt_device_graphic_ops *)(device->user_data))
N
N/*@}*/
N#endif
N
N#ifdef RT_USING_MODULE
S/**
S * @addtogroup Module
S */
S
S/*@{*/
S
S/*
S * module system
S */
S
S#define RT_MODULE_FLAG_WITHENTRY        0x00            /**< with entry point */
S#define RT_MODULE_FLAG_WITHOUTENTRY     0x01            /**< without entry point */
S
S/**
S * Application Module structure
S */
Sstruct rt_module
S{
S    struct rt_object             parent;                /**< inherit from object */
S
S    rt_uint32_t                  vstart_addr;            /**< VMA base address for the
S                                                          first LOAD segment. */
S    rt_uint8_t                  *module_space;          /**< module memory space */
S
S    void                        *module_entry;          /**< the entry address of module */
S    rt_thread_t                  module_thread;         /**< the main thread of module */
S
S	rt_uint8_t*                  module_cmd_line;		/**< module command line */
S	rt_uint32_t                  module_cmd_size;		/**< the size of module command line */
S
S#ifdef RT_USING_SLAB
S    /* module memory allocator */
S    void                        *mem_list;              /**< module's free memory list */
S    void                        *page_array;            /**< module's using pages */
S    rt_uint32_t                  page_cnt;              /**< module's using pages count */
S#endif
S
S    rt_uint16_t                  nref;                  /**< reference count */
S
S    rt_uint16_t                  nsym;                  /**< number of symbol in the module */
S    struct rt_module_symtab     *symtab;                /**< module symbol table */
S
S    /* object in this module, module object is the last basic object type */
S    struct rt_object_information module_object[RT_Object_Class_Unknown];
S};
Stypedef struct rt_module *rt_module_t;
S
S/*@}*/
N#endif
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 38 "..\..\include\rtthread.h" 2
N#include <rtservice.h>
L 1 "..\..\include\rtservice.h" 1
N/*
N * File      : rtservice.h
N * This file is part of RT-Thread RTOS
N * COPYRIGHT (C) 2006 - 2012, RT-Thread Development Team
N *
N *  This program is free software; you can redistribute it and/or modify
N *  it under the terms of the GNU General Public License as published by
N *  the Free Software Foundation; either version 2 of the License, or
N *  (at your option) any later version.
N *
N *  This program is distributed in the hope that it will be useful,
N *  but WITHOUT ANY WARRANTY; without even the implied warranty of
N *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
N *  GNU General Public License for more details.
N *
N *  You should have received a copy of the GNU General Public License along
N *  with this program; if not, write to the Free Software Foundation, Inc.,
N *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
N *
N * Change Logs:
N * Date           Author       Notes
N * 2006-03-16     Bernard      the first version
N * 2006-09-07     Bernard      move the kservice APIs to rtthread.h
N * 2007-06-27     Bernard      fix the rt_list_remove bug
N * 2012-03-22     Bernard      rename kservice.h to rtservice.h
N */
N
N#ifndef __RT_SERVICE_H__
N#define __RT_SERVICE_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/**
N * @addtogroup KernelService
N */
N
N/*@{*/
N
N/**
N * @brief initialize a list object
N */
N#define RT_LIST_OBJECT_INIT(object) { &(object), &(object) }
N
N/**
N * @brief initialize a list
N *
N * @param l list to be initialized
N */
Nrt_inline void rt_list_init(rt_list_t *l)
Xstatic __inline void rt_list_init(rt_list_t *l)
N{
N    l->next = l->prev = l;
N}
N
N/**
N * @brief insert a node after a list
N *
N * @param l list to insert it
N * @param n new node to be inserted
N */
Nrt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
Xstatic __inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
N{
N    l->next->prev = n;
N    n->next = l->next;
N
N    l->next = n;
N    n->prev = l;
N}
N
N/**
N * @brief insert a node before a list
N *
N * @param n new node to be inserted
N * @param l list to insert it
N */
Nrt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
Xstatic __inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
N{
N    l->prev->next = n;
N    n->prev = l->prev;
N
N    l->prev = n;
N    n->next = l;
N}
N
N/**
N * @brief remove node from list.
N * @param n the node to remove from the list.
N */
Nrt_inline void rt_list_remove(rt_list_t *n)
Xstatic __inline void rt_list_remove(rt_list_t *n)
N{
N    n->next->prev = n->prev;
N    n->prev->next = n->next;
N
N    n->next = n->prev = n;
N}
N
N/**
N * @brief tests whether a list is empty
N * @param l the list to test.
N */
Nrt_inline int rt_list_isempty(const rt_list_t *l)
Xstatic __inline int rt_list_isempty(const rt_list_t *l)
N{
N    return l->next == l;
N}
N
N/**
N * @brief get the struct for this entry
N * @param node the entry point
N * @param type the type of structure
N * @param member the name of list in structure
N */
N#define rt_list_entry(node, type, member) \
N    ((type *)((char *)(node) - (unsigned long)(&((type *)0)->member)))
X#define rt_list_entry(node, type, member)     ((type *)((char *)(node) - (unsigned long)(&((type *)0)->member)))
N
N/**
N * rt_list_for_each_entry  -   iterate over list of given type
N * @pos:    the type * to use as a loop cursor.
N * @head:   the head for your list.
N * @member: the name of the list_struct within the struct.
N */
N#define rt_list_for_each_entry(pos, head, member)              \
N    for (pos = rt_list_entry((head)->next, typeof(*pos), member);  \
N         &pos->member != (head);    \
N         pos = rt_list_entry(pos->member.next, typeof(*pos), member))
X#define rt_list_for_each_entry(pos, head, member)                  for (pos = rt_list_entry((head)->next, typeof(*pos), member);           &pos->member != (head);             pos = rt_list_entry(pos->member.next, typeof(*pos), member))
N
N/**
N * rt_list_first_entry - get the first element from a list
N * @ptr:    the list head to take the element from.
N * @type:   the type of the struct this is embedded in.
N * @member: the name of the list_struct within the struct.
N *
N * Note, that list is expected to be not empty.
N */
N#define rt_list_first_entry(ptr, type, member) \
N    rt_list_entry((ptr)->next, type, member)
X#define rt_list_first_entry(ptr, type, member)     rt_list_entry((ptr)->next, type, member)
N/*@}*/
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 39 "..\..\include\rtthread.h" 2
N#include <rtm.h>
L 1 "..\..\include\rtm.h" 1
N/*
N * File      : rtm.h
N * This file is part of RT-Thread RTOS
N * COPYRIGHT (C) 2006 - 2012, RT-Thread Development Team
N *
N *  This program is free software; you can redistribute it and/or modify
N *  it under the terms of the GNU General Public License as published by
N *  the Free Software Foundation; either version 2 of the License, or
N *  (at your option) any later version.
N *
N *  This program is distributed in the hope that it will be useful,
N *  but WITHOUT ANY WARRANTY; without even the implied warranty of
N *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
N *  GNU General Public License for more details.
N *
N *  You should have received a copy of the GNU General Public License along
N *  with this program; if not, write to the Free Software Foundation, Inc.,
N *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
N */
N
N#ifndef __RTM_H__
N#define __RTM_H__
N
N#include <rtdef.h>
N#include <rtthread.h>
L 1 "..\..\include\rtthread.h" 1
N/*
N * File      : rtthread.h
N * This file is part of RT-Thread RTOS
N * COPYRIGHT (C) 2006 - 2012, RT-Thread Development Team
N *
N *  This program is free software; you can redistribute it and/or modify
N *  it under the terms of the GNU General Public License as published by
N *  the Free Software Foundation; either version 2 of the License, or
N *  (at your option) any later version.
N *
N *  This program is distributed in the hope that it will be useful,
N *  but WITHOUT ANY WARRANTY; without even the implied warranty of
N *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
N *  GNU General Public License for more details.
N *
N *  You should have received a copy of the GNU General Public License along
N *  with this program; if not, write to the Free Software Foundation, Inc.,
N *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
N *
N * Change Logs:
N * Date           Author       Notes
N * 2006-03-18     Bernard      the first version
N * 2006-04-26     Bernard      add semaphore APIs
N * 2006-08-10     Bernard      add version information
N * 2007-01-28     Bernard      rename RT_OBJECT_Class_Static to RT_Object_Class_Static
N * 2007-03-03     Bernard      clean up the definitions to rtdef.h
N * 2010-04-11     yi.qiu       add module feature
N * 2013-06-24     Bernard      add rt_kprintf re-define when not use RT_USING_CONSOLE.
N * 2016-08-09     ArdaFu       add new thread and interrupt hook.
N */
N
N#ifndef __RT_THREAD_H__
S#define __RT_THREAD_H__
S
S#include <rtconfig.h>
S#include <rtdebug.h>
S#include <rtdef.h>
S#include <rtservice.h>
S#include <rtm.h>
S
S#ifdef __cplusplus
Sextern "C" {
S#endif
S
S/**
S * @addtogroup KernelObject
S */
S
S/**@{*/
S
S/*
S * kernel object interface
S */
Svoid rt_system_object_init(void);
Sstruct rt_object_information *
Srt_object_get_information(enum rt_object_class_type type);
Svoid rt_object_init(struct rt_object         *object,
S                    enum rt_object_class_type type,
S                    const char               *name);
Svoid rt_object_detach(rt_object_t object);
Srt_object_t rt_object_allocate(enum rt_object_class_type type,
S                               const char               *name);
Svoid rt_object_delete(rt_object_t object);
Srt_bool_t rt_object_is_systemobject(rt_object_t object);
Srt_object_t rt_object_find(const char *name, rt_uint8_t type);
S
S#ifdef RT_USING_HOOK
Svoid rt_object_attach_sethook(void (*hook)(struct rt_object *object));
Svoid rt_object_detach_sethook(void (*hook)(struct rt_object *object));
Svoid rt_object_trytake_sethook(void (*hook)(struct rt_object *object));
Svoid rt_object_take_sethook(void (*hook)(struct rt_object *object));
Svoid rt_object_put_sethook(void (*hook)(struct rt_object *object));
S#endif
S
S/**@}*/
S
S/**
S * @addtogroup Clock
S */
S
S/**@{*/
S
S/*
S * clock & timer interface
S */
Svoid rt_system_tick_init(void);
Srt_tick_t rt_tick_get(void);
Svoid rt_tick_set(rt_tick_t tick);
Svoid rt_tick_increase(void);
Srt_tick_t rt_tick_from_millisecond(rt_uint32_t ms);
S
Svoid rt_system_timer_init(void);
Svoid rt_system_timer_thread_init(void);
S
Svoid rt_timer_init(rt_timer_t  timer,
S                   const char *name,
S                   void (*timeout)(void *parameter),
S                   void       *parameter,
S                   rt_tick_t   time,
S                   rt_uint8_t  flag);
Srt_err_t rt_timer_detach(rt_timer_t timer);
Srt_timer_t rt_timer_create(const char *name,
S                           void (*timeout)(void *parameter),
S                           void       *parameter,
S                           rt_tick_t   time,
S                           rt_uint8_t  flag);
Srt_err_t rt_timer_delete(rt_timer_t timer);
Srt_err_t rt_timer_start(rt_timer_t timer);
Srt_err_t rt_timer_stop(rt_timer_t timer);
Srt_err_t rt_timer_control(rt_timer_t timer, rt_uint8_t cmd, void *arg);
S
Srt_tick_t rt_timer_next_timeout_tick(void);
Svoid rt_timer_check(void);
S
S#ifdef RT_USING_HOOK
Svoid rt_timer_timeout_sethook(void (*hook)(struct rt_timer *timer));
S#endif
S
S/**@}*/
S
S/**
S * @addtogroup Thread
S */
S
S/**@{*/
S
S/*
S * thread interface
S */
Srt_err_t rt_thread_init(struct rt_thread *thread,
S                        const char       *name,
S                        void (*entry)(void *parameter),
S                        void             *parameter,
S                        void             *stack_start,
S                        rt_uint32_t       stack_size,
S                        rt_uint8_t        priority,
S                        rt_uint32_t       tick);
Srt_err_t rt_thread_detach(rt_thread_t thread);
Srt_thread_t rt_thread_create(const char *name,
S                             void (*entry)(void *parameter),
S                             void       *parameter,
S                             rt_uint32_t stack_size,
S                             rt_uint8_t  priority,
S                             rt_uint32_t tick);
Srt_thread_t rt_thread_self(void);
Srt_thread_t rt_thread_find(char *name);
Srt_err_t rt_thread_startup(rt_thread_t thread);
Srt_err_t rt_thread_delete(rt_thread_t thread);
S
Srt_err_t rt_thread_yield(void);
Srt_err_t rt_thread_delay(rt_tick_t tick);
Srt_err_t rt_thread_control(rt_thread_t thread, rt_uint8_t cmd, void *arg);
Srt_err_t rt_thread_suspend(rt_thread_t thread);
Srt_err_t rt_thread_resume(rt_thread_t thread);
Svoid rt_thread_timeout(void *parameter);
S
S#ifdef RT_USING_HOOK
Svoid rt_thread_suspend_sethook(void (*hook)(rt_thread_t thread));
Svoid rt_thread_resume_sethook (void (*hook)(rt_thread_t thread));
Svoid rt_thread_inited_sethook (void (*hook)(rt_thread_t thread));
S#endif
S
S/*
S * idle thread interface
S */
Svoid rt_thread_idle_init(void);
S#if defined(RT_USING_HOOK) || defined(RT_USING_IDLE_HOOK)
Svoid rt_thread_idle_sethook(void (*hook)(void));
S#endif
Svoid rt_thread_idle_excute(void);
Srt_thread_t rt_thread_idle_gethandler(void);
S
S/*
S * schedule service
S */
Svoid rt_system_scheduler_init(void);
Svoid rt_system_scheduler_start(void);
S
Svoid rt_schedule(void);
Svoid rt_schedule_insert_thread(struct rt_thread *thread);
Svoid rt_schedule_remove_thread(struct rt_thread *thread);
S
Svoid rt_enter_critical(void);
Svoid rt_exit_critical(void);
Srt_uint16_t rt_critical_level(void);
S
S#ifdef RT_USING_HOOK
Svoid rt_scheduler_sethook(void (*hook)(rt_thread_t from, rt_thread_t to));
S#endif
S
S/**@}*/
S
S/**
S * @addtogroup MM
S */
S
S/**@{*/
S
S/*
S * memory management interface
S */
S#ifdef RT_USING_MEMPOOL
S/*
S * memory pool interface
S */
Srt_err_t rt_mp_init(struct rt_mempool *mp,
S                    const char        *name,
S                    void              *start,
S                    rt_size_t          size,
S                    rt_size_t          block_size);
Srt_err_t rt_mp_detach(struct rt_mempool *mp);
Srt_mp_t rt_mp_create(const char *name,
S                     rt_size_t   block_count,
S                     rt_size_t   block_size);
Srt_err_t rt_mp_delete(rt_mp_t mp);
S
Svoid *rt_mp_alloc(rt_mp_t mp, rt_int32_t time);
Svoid rt_mp_free(void *block);
S
S#ifdef RT_USING_HOOK
Svoid rt_mp_alloc_sethook(void (*hook)(struct rt_mempool *mp, void *block));
Svoid rt_mp_free_sethook(void (*hook)(struct rt_mempool *mp, void *block));
S#endif
S
S#endif
S
S#ifdef RT_USING_HEAP
S/*
S * heap memory interface
S */
Svoid rt_system_heap_init(void *begin_addr, void *end_addr);
S
Svoid *rt_malloc(rt_size_t nbytes);
Svoid rt_free(void *ptr);
Svoid *rt_realloc(void *ptr, rt_size_t nbytes);
Svoid *rt_calloc(rt_size_t count, rt_size_t size);
Svoid *rt_malloc_align(rt_size_t size, rt_size_t align);
Svoid rt_free_align(void *ptr);
S
Svoid rt_memory_info(rt_uint32_t *total,
S                    rt_uint32_t *used,
S                    rt_uint32_t *max_used);
S
S#ifdef RT_USING_SLAB
Svoid *rt_page_alloc(rt_size_t npages);
Svoid rt_page_free(void *addr, rt_size_t npages);
S#endif
S
S#ifdef RT_USING_HOOK
Svoid rt_malloc_sethook(void (*hook)(void *ptr, rt_uint32_t size));
Svoid rt_free_sethook(void (*hook)(void *ptr));
S#endif
S
S#endif
S
S#ifdef RT_USING_MEMHEAP
S/**
S * memory heap object interface
S */
Srt_err_t rt_memheap_init(struct rt_memheap *memheap,
S                         const char        *name,
S                         void              *start_addr,
S                         rt_uint32_t        size);
Srt_err_t rt_memheap_detach(struct rt_memheap *heap);
Svoid* rt_memheap_alloc(struct rt_memheap *heap, rt_uint32_t size);
Svoid *rt_memheap_realloc(struct rt_memheap* heap, void* ptr, rt_size_t newsize);
Svoid rt_memheap_free(void *ptr);
S#endif
S
S/**@}*/
S
S/**
S * @addtogroup IPC
S */
S
S/**@{*/
S
S#ifdef RT_USING_SEMAPHORE
S/*
S * semaphore interface
S */
Srt_err_t rt_sem_init(rt_sem_t    sem,
S                     const char *name,
S                     rt_uint32_t value,
S                     rt_uint8_t  flag);
Srt_err_t rt_sem_detach(rt_sem_t sem);
Srt_sem_t rt_sem_create(const char *name, rt_uint32_t value, rt_uint8_t flag);
Srt_err_t rt_sem_delete(rt_sem_t sem);
S
Srt_err_t rt_sem_take(rt_sem_t sem, rt_int32_t time);
Srt_err_t rt_sem_trytake(rt_sem_t sem);
Srt_err_t rt_sem_release(rt_sem_t sem);
Srt_err_t rt_sem_control(rt_sem_t sem, rt_uint8_t cmd, void *arg);
S#endif
S
S#ifdef RT_USING_MUTEX
S/*
S * mutex interface
S */
Srt_err_t rt_mutex_init(rt_mutex_t mutex, const char *name, rt_uint8_t flag);
Srt_err_t rt_mutex_detach(rt_mutex_t mutex);
Srt_mutex_t rt_mutex_create(const char *name, rt_uint8_t flag);
Srt_err_t rt_mutex_delete(rt_mutex_t mutex);
S
Srt_err_t rt_mutex_take(rt_mutex_t mutex, rt_int32_t time);
Srt_err_t rt_mutex_release(rt_mutex_t mutex);
Srt_err_t rt_mutex_control(rt_mutex_t mutex, rt_uint8_t cmd, void *arg);
S#endif
S
S#ifdef RT_USING_EVENT
S/*
S * event interface
S */
Srt_err_t rt_event_init(rt_event_t event, const char *name, rt_uint8_t flag);
Srt_err_t rt_event_detach(rt_event_t event);
Srt_event_t rt_event_create(const char *name, rt_uint8_t flag);
Srt_err_t rt_event_delete(rt_event_t event);
S
Srt_err_t rt_event_send(rt_event_t event, rt_uint32_t set);
Srt_err_t rt_event_recv(rt_event_t   event,
S                       rt_uint32_t  set,
S                       rt_uint8_t   opt,
S                       rt_int32_t   timeout,
S                       rt_uint32_t *recved);
Srt_err_t rt_event_control(rt_event_t event, rt_uint8_t cmd, void *arg);
S#endif
S
S#ifdef RT_USING_MAILBOX
S/*
S * mailbox interface
S */
Srt_err_t rt_mb_init(rt_mailbox_t mb,
S                    const char  *name,
S                    void        *msgpool,
S                    rt_size_t    size,
S                    rt_uint8_t   flag);
Srt_err_t rt_mb_detach(rt_mailbox_t mb);
Srt_mailbox_t rt_mb_create(const char *name, rt_size_t size, rt_uint8_t flag);
Srt_err_t rt_mb_delete(rt_mailbox_t mb);
S
Srt_err_t rt_mb_send(rt_mailbox_t mb, rt_uint32_t value);
Srt_err_t rt_mb_send_wait(rt_mailbox_t mb,
S                         rt_uint32_t  value,
S                         rt_int32_t   timeout);
Srt_err_t rt_mb_recv(rt_mailbox_t mb, rt_uint32_t *value, rt_int32_t timeout);
Srt_err_t rt_mb_control(rt_mailbox_t mb, rt_uint8_t cmd, void *arg);
S#endif
S
S#ifdef RT_USING_MESSAGEQUEUE
S/*
S * message queue interface
S */
Srt_err_t rt_mq_init(rt_mq_t     mq,
S                    const char *name,
S                    void       *msgpool,
S                    rt_size_t   msg_size,
S                    rt_size_t   pool_size,
S                    rt_uint8_t  flag);
Srt_err_t rt_mq_detach(rt_mq_t mq);
Srt_mq_t rt_mq_create(const char *name,
S                     rt_size_t   msg_size,
S                     rt_size_t   max_msgs,
S                     rt_uint8_t  flag);
Srt_err_t rt_mq_delete(rt_mq_t mq);
S
Srt_err_t rt_mq_send(rt_mq_t mq, void *buffer, rt_size_t size);
Srt_err_t rt_mq_urgent(rt_mq_t mq, void *buffer, rt_size_t size);
Srt_err_t rt_mq_recv(rt_mq_t    mq,
S                    void      *buffer,
S                    rt_size_t  size,
S                    rt_int32_t timeout);
Srt_err_t rt_mq_control(rt_mq_t mq, rt_uint8_t cmd, void *arg);
S#endif
S
S/**@}*/
S
S#ifdef RT_USING_DEVICE
S/**
S * @addtogroup Device
S */
S
S/**@{*/
S
S/*
S * device (I/O) system interface
S */
Srt_device_t rt_device_find(const char *name);
S
Srt_err_t rt_device_register(rt_device_t dev,
S                            const char *name,
S                            rt_uint16_t flags);
Srt_err_t rt_device_unregister(rt_device_t dev);
Srt_err_t rt_device_init_all(void);
S
Srt_err_t
Srt_device_set_rx_indicate(rt_device_t dev,
S                          rt_err_t (*rx_ind)(rt_device_t dev, rt_size_t size));
Srt_err_t
Srt_device_set_tx_complete(rt_device_t dev,
S                          rt_err_t (*tx_done)(rt_device_t dev, void *buffer));
S
Srt_err_t  rt_device_init (rt_device_t dev);
Srt_err_t  rt_device_open (rt_device_t dev, rt_uint16_t oflag);
Srt_err_t  rt_device_close(rt_device_t dev);
Srt_size_t rt_device_read (rt_device_t dev,
S                          rt_off_t    pos,
S                          void       *buffer,
S                          rt_size_t   size);
Srt_size_t rt_device_write(rt_device_t dev,
S                          rt_off_t    pos,
S                          const void *buffer,
S                          rt_size_t   size);
Srt_err_t  rt_device_control(rt_device_t dev, rt_uint8_t cmd, void *arg);
S
S/**@}*/
S#endif
S
S#ifdef RT_USING_MODULE
S/**
S * @addtogroup Module
S */
S
S/**@{*/
S
S/*
S * module interface
S */
Srt_module_t rt_module_load(const char *name, void *module_ptr);
Srt_err_t rt_module_unload(rt_module_t module);
S#ifdef RT_USING_DFS
Srt_module_t rt_module_open(const char *filename);
Srt_module_t rt_module_exec_cmd(const char *path, const char* cmd_line, int size);
S#endif
Svoid *rt_module_malloc(rt_size_t size);
Svoid *rt_module_realloc(void *ptr, rt_size_t size);
Svoid rt_module_free(rt_module_t module, void *addr);
Srt_module_t rt_module_self(void);
Srt_module_t rt_module_find(const char *name);
S
S#ifdef RT_USING_HOOK
Svoid rt_module_load_sethook(void (*hook)(rt_module_t module));
Svoid rt_module_unload_sethook(void (*hook)(rt_module_t module));
S#endif
S
Svoid rt_module_init_object_container(struct rt_module *module);
Srt_err_t rt_module_destroy(rt_module_t module);
S
S/*
S * application module system initialization
S */
Sint rt_system_module_init(void);
S
S/**@}*/
S#endif
S
S/*
S * interrupt service
S */
S
S/*
S * rt_interrupt_enter and rt_interrupt_leave only can be called by BSP
S */
Svoid rt_interrupt_enter(void);
Svoid rt_interrupt_leave(void);
S
S/*
S * the number of nested interrupts.
S */
Srt_uint8_t rt_interrupt_get_nest(void);
S
S#ifdef RT_USING_HOOK
Svoid rt_interrupt_enter_sethook(void (*hook)(void));
Svoid rt_interrupt_leave_sethook(void (*hook)(void));
S#endif
S
S#ifdef RT_USING_COMPONENTS_INIT
Svoid rt_components_init(void);
Svoid rt_components_board_init(void);
S#endif
S
S/**
S * @addtogroup KernelService
S */
S
S/**@{*/
S
S/*
S * general kernel service
S */
S#ifndef RT_USING_CONSOLE
S#define rt_kprintf(...)
S#define rt_kputs(str)
S#else
Svoid rt_kprintf(const char *fmt, ...);
Svoid rt_kputs(const char *str);
S#endif
Srt_int32_t rt_vsprintf(char *dest, const char *format, va_list arg_ptr);
Srt_int32_t rt_vsnprintf(char *buf, rt_size_t size, const char *fmt, va_list args);
Srt_int32_t rt_sprintf(char *buf ,const char *format, ...);
Srt_int32_t rt_snprintf(char *buf, rt_size_t size, const char *format, ...);
S
S#if defined(RT_USING_DEVICE) && defined(RT_USING_CONSOLE)
Srt_device_t rt_console_set_device(const char *name);
Srt_device_t rt_console_get_device(void);
S#endif
S
Srt_err_t rt_get_errno(void);
Svoid rt_set_errno(rt_err_t no);
Sint *_rt_errno(void);
S#if !defined(RT_USING_NEWLIB) && !defined(_WIN32)
S#ifndef errno
S#define errno    *_rt_errno()
S#endif
S#endif
S
Svoid *rt_memset(void *src, int c, rt_ubase_t n);
Svoid *rt_memcpy(void *dest, const void *src, rt_ubase_t n);
S
Srt_int32_t rt_strncmp(const char *cs, const char *ct, rt_ubase_t count);
Srt_int32_t rt_strcmp (const char *cs, const char *ct);
Srt_size_t rt_strlen (const char *src);
Schar *rt_strdup(const char *s);
S
Schar *rt_strstr(const char *str1, const char *str2);
Srt_int32_t rt_sscanf(const char *buf, const char *fmt, ...);
Schar *rt_strncpy(char *dest, const char *src, rt_ubase_t n);
Svoid *rt_memmove(void *dest, const void *src, rt_ubase_t n);
Srt_int32_t rt_memcmp(const void *cs, const void *ct, rt_ubase_t count);
Srt_uint32_t rt_strcasecmp(const char *a, const char *b);
S
Svoid rt_show_version(void);
S
S#ifdef RT_DEBUG
Sextern void (*rt_assert_hook)(const char* ex, const char* func, rt_size_t line);
Svoid rt_assert_set_hook(void (*hook)(const char* ex, const char* func, rt_size_t line));
S
Svoid rt_assert_handler(const char* ex, const char* func, rt_size_t line);
S#endif /* RT_DEBUG */
S
S/**@}*/
S
S#ifdef __cplusplus
S}
S#endif
S
N#endif
L 26 "..\..\include\rtm.h" 2
N
N#ifdef RT_USING_MODULE
Sstruct rt_module_symtab
S{
S    void       *addr;
S    const char *name;
S};
S
S#if defined(_MSC_VER)
S#pragma section("RTMSymTab$f",read)
S#define RTM_EXPORT(symbol)                                            \
S__declspec(allocate("RTMSymTab$f"))const char __rtmsym_##symbol##_name[] = "__vs_rtm_"#symbol;
X#define RTM_EXPORT(symbol)                                            __declspec(allocate("RTMSymTab$f"))const char __rtmsym_##symbol##_name[] = "__vs_rtm_"#symbol;
S#pragma comment(linker, "/merge:RTMSymTab=mytext")
S
S#elif defined(__MINGW32__)
S#define RTM_EXPORT(symbol)
S
S#else
S#define RTM_EXPORT(symbol)                                            \
Sconst char __rtmsym_##symbol##_name[] SECTION(".rodata.name") = #symbol;     \
Sconst struct rt_module_symtab __rtmsym_##symbol SECTION("RTMSymTab")= \
S{                                                                     \
S    (void *)&symbol,                                                  \
S    __rtmsym_##symbol##_name                                          \
S};
X#define RTM_EXPORT(symbol)                                            const char __rtmsym_##symbol##_name[] SECTION(".rodata.name") = #symbol;     const struct rt_module_symtab __rtmsym_##symbol SECTION("RTMSymTab")= {                                                                         (void *)&symbol,                                                      __rtmsym_##symbol##_name                                          };
S#endif
S
N#else
N#define RTM_EXPORT(symbol)
N#endif
N
N#endif
L 40 "..\..\include\rtthread.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/**
N * @addtogroup KernelObject
N */
N
N/**@{*/
N
N/*
N * kernel object interface
N */
Nvoid rt_system_object_init(void);
Nstruct rt_object_information *
Nrt_object_get_information(enum rt_object_class_type type);
Nvoid rt_object_init(struct rt_object         *object,
N                    enum rt_object_class_type type,
N                    const char               *name);
Nvoid rt_object_detach(rt_object_t object);
Nrt_object_t rt_object_allocate(enum rt_object_class_type type,
N                               const char               *name);
Nvoid rt_object_delete(rt_object_t object);
Nrt_bool_t rt_object_is_systemobject(rt_object_t object);
Nrt_object_t rt_object_find(const char *name, rt_uint8_t type);
N
N#ifdef RT_USING_HOOK
Svoid rt_object_attach_sethook(void (*hook)(struct rt_object *object));
Svoid rt_object_detach_sethook(void (*hook)(struct rt_object *object));
Svoid rt_object_trytake_sethook(void (*hook)(struct rt_object *object));
Svoid rt_object_take_sethook(void (*hook)(struct rt_object *object));
Svoid rt_object_put_sethook(void (*hook)(struct rt_object *object));
N#endif
N
N/**@}*/
N
N/**
N * @addtogroup Clock
N */
N
N/**@{*/
N
N/*
N * clock & timer interface
N */
Nvoid rt_system_tick_init(void);
Nrt_tick_t rt_tick_get(void);
Nvoid rt_tick_set(rt_tick_t tick);
Nvoid rt_tick_increase(void);
Nrt_tick_t rt_tick_from_millisecond(rt_uint32_t ms);
N
Nvoid rt_system_timer_init(void);
Nvoid rt_system_timer_thread_init(void);
N
Nvoid rt_timer_init(rt_timer_t  timer,
N                   const char *name,
N                   void (*timeout)(void *parameter),
N                   void       *parameter,
N                   rt_tick_t   time,
N                   rt_uint8_t  flag);
Nrt_err_t rt_timer_detach(rt_timer_t timer);
Nrt_timer_t rt_timer_create(const char *name,
N                           void (*timeout)(void *parameter),
N                           void       *parameter,
N                           rt_tick_t   time,
N                           rt_uint8_t  flag);
Nrt_err_t rt_timer_delete(rt_timer_t timer);
Nrt_err_t rt_timer_start(rt_timer_t timer);
Nrt_err_t rt_timer_stop(rt_timer_t timer);
Nrt_err_t rt_timer_control(rt_timer_t timer, rt_uint8_t cmd, void *arg);
N
Nrt_tick_t rt_timer_next_timeout_tick(void);
Nvoid rt_timer_check(void);
N
N#ifdef RT_USING_HOOK
Svoid rt_timer_timeout_sethook(void (*hook)(struct rt_timer *timer));
N#endif
N
N/**@}*/
N
N/**
N * @addtogroup Thread
N */
N
N/**@{*/
N
N/*
N * thread interface
N */
Nrt_err_t rt_thread_init(struct rt_thread *thread,
N                        const char       *name,
N                        void (*entry)(void *parameter),
N                        void             *parameter,
N                        void             *stack_start,
N                        rt_uint32_t       stack_size,
N                        rt_uint8_t        priority,
N                        rt_uint32_t       tick);
Nrt_err_t rt_thread_detach(rt_thread_t thread);
Nrt_thread_t rt_thread_create(const char *name,
N                             void (*entry)(void *parameter),
N                             void       *parameter,
N                             rt_uint32_t stack_size,
N                             rt_uint8_t  priority,
N                             rt_uint32_t tick);
Nrt_thread_t rt_thread_self(void);
Nrt_thread_t rt_thread_find(char *name);
Nrt_err_t rt_thread_startup(rt_thread_t thread);
Nrt_err_t rt_thread_delete(rt_thread_t thread);
N
Nrt_err_t rt_thread_yield(void);
Nrt_err_t rt_thread_delay(rt_tick_t tick);
Nrt_err_t rt_thread_control(rt_thread_t thread, rt_uint8_t cmd, void *arg);
Nrt_err_t rt_thread_suspend(rt_thread_t thread);
Nrt_err_t rt_thread_resume(rt_thread_t thread);
Nvoid rt_thread_timeout(void *parameter);
N
N#ifdef RT_USING_HOOK
Svoid rt_thread_suspend_sethook(void (*hook)(rt_thread_t thread));
Svoid rt_thread_resume_sethook (void (*hook)(rt_thread_t thread));
Svoid rt_thread_inited_sethook (void (*hook)(rt_thread_t thread));
N#endif
N
N/*
N * idle thread interface
N */
Nvoid rt_thread_idle_init(void);
N#if defined(RT_USING_HOOK) || defined(RT_USING_IDLE_HOOK)
X#if 0L || 0L
Svoid rt_thread_idle_sethook(void (*hook)(void));
N#endif
Nvoid rt_thread_idle_excute(void);
Nrt_thread_t rt_thread_idle_gethandler(void);
N
N/*
N * schedule service
N */
Nvoid rt_system_scheduler_init(void);
Nvoid rt_system_scheduler_start(void);
N
Nvoid rt_schedule(void);
Nvoid rt_schedule_insert_thread(struct rt_thread *thread);
Nvoid rt_schedule_remove_thread(struct rt_thread *thread);
N
Nvoid rt_enter_critical(void);
Nvoid rt_exit_critical(void);
Nrt_uint16_t rt_critical_level(void);
N
N#ifdef RT_USING_HOOK
Svoid rt_scheduler_sethook(void (*hook)(rt_thread_t from, rt_thread_t to));
N#endif
N
N/**@}*/
N
N/**
N * @addtogroup MM
N */
N
N/**@{*/
N
N/*
N * memory management interface
N */
N#ifdef RT_USING_MEMPOOL
N/*
N * memory pool interface
N */
Nrt_err_t rt_mp_init(struct rt_mempool *mp,
N                    const char        *name,
N                    void              *start,
N                    rt_size_t          size,
N                    rt_size_t          block_size);
Nrt_err_t rt_mp_detach(struct rt_mempool *mp);
Nrt_mp_t rt_mp_create(const char *name,
N                     rt_size_t   block_count,
N                     rt_size_t   block_size);
Nrt_err_t rt_mp_delete(rt_mp_t mp);
N
Nvoid *rt_mp_alloc(rt_mp_t mp, rt_int32_t time);
Nvoid rt_mp_free(void *block);
N
N#ifdef RT_USING_HOOK
Svoid rt_mp_alloc_sethook(void (*hook)(struct rt_mempool *mp, void *block));
Svoid rt_mp_free_sethook(void (*hook)(struct rt_mempool *mp, void *block));
N#endif
N
N#endif
N
N#ifdef RT_USING_HEAP
N/*
N * heap memory interface
N */
Nvoid rt_system_heap_init(void *begin_addr, void *end_addr);
N
Nvoid *rt_malloc(rt_size_t nbytes);
Nvoid rt_free(void *ptr);
Nvoid *rt_realloc(void *ptr, rt_size_t nbytes);
Nvoid *rt_calloc(rt_size_t count, rt_size_t size);
Nvoid *rt_malloc_align(rt_size_t size, rt_size_t align);
Nvoid rt_free_align(void *ptr);
N
Nvoid rt_memory_info(rt_uint32_t *total,
N                    rt_uint32_t *used,
N                    rt_uint32_t *max_used);
N
N#ifdef RT_USING_SLAB
Svoid *rt_page_alloc(rt_size_t npages);
Svoid rt_page_free(void *addr, rt_size_t npages);
N#endif
N
N#ifdef RT_USING_HOOK
Svoid rt_malloc_sethook(void (*hook)(void *ptr, rt_uint32_t size));
Svoid rt_free_sethook(void (*hook)(void *ptr));
N#endif
N
N#endif
N
N#ifdef RT_USING_MEMHEAP
S/**
S * memory heap object interface
S */
Srt_err_t rt_memheap_init(struct rt_memheap *memheap,
S                         const char        *name,
S                         void              *start_addr,
S                         rt_uint32_t        size);
Srt_err_t rt_memheap_detach(struct rt_memheap *heap);
Svoid* rt_memheap_alloc(struct rt_memheap *heap, rt_uint32_t size);
Svoid *rt_memheap_realloc(struct rt_memheap* heap, void* ptr, rt_size_t newsize);
Svoid rt_memheap_free(void *ptr);
N#endif
N
N/**@}*/
N
N/**
N * @addtogroup IPC
N */
N
N/**@{*/
N
N#ifdef RT_USING_SEMAPHORE
N/*
N * semaphore interface
N */
Nrt_err_t rt_sem_init(rt_sem_t    sem,
N                     const char *name,
N                     rt_uint32_t value,
N                     rt_uint8_t  flag);
Nrt_err_t rt_sem_detach(rt_sem_t sem);
Nrt_sem_t rt_sem_create(const char *name, rt_uint32_t value, rt_uint8_t flag);
Nrt_err_t rt_sem_delete(rt_sem_t sem);
N
Nrt_err_t rt_sem_take(rt_sem_t sem, rt_int32_t time);
Nrt_err_t rt_sem_trytake(rt_sem_t sem);
Nrt_err_t rt_sem_release(rt_sem_t sem);
Nrt_err_t rt_sem_control(rt_sem_t sem, rt_uint8_t cmd, void *arg);
N#endif
N
N#ifdef RT_USING_MUTEX
N/*
N * mutex interface
N */
Nrt_err_t rt_mutex_init(rt_mutex_t mutex, const char *name, rt_uint8_t flag);
Nrt_err_t rt_mutex_detach(rt_mutex_t mutex);
Nrt_mutex_t rt_mutex_create(const char *name, rt_uint8_t flag);
Nrt_err_t rt_mutex_delete(rt_mutex_t mutex);
N
Nrt_err_t rt_mutex_take(rt_mutex_t mutex, rt_int32_t time);
Nrt_err_t rt_mutex_release(rt_mutex_t mutex);
Nrt_err_t rt_mutex_control(rt_mutex_t mutex, rt_uint8_t cmd, void *arg);
N#endif
N
N#ifdef RT_USING_EVENT
N/*
N * event interface
N */
Nrt_err_t rt_event_init(rt_event_t event, const char *name, rt_uint8_t flag);
Nrt_err_t rt_event_detach(rt_event_t event);
Nrt_event_t rt_event_create(const char *name, rt_uint8_t flag);
Nrt_err_t rt_event_delete(rt_event_t event);
N
Nrt_err_t rt_event_send(rt_event_t event, rt_uint32_t set);
Nrt_err_t rt_event_recv(rt_event_t   event,
N                       rt_uint32_t  set,
N                       rt_uint8_t   opt,
N                       rt_int32_t   timeout,
N                       rt_uint32_t *recved);
Nrt_err_t rt_event_control(rt_event_t event, rt_uint8_t cmd, void *arg);
N#endif
N
N#ifdef RT_USING_MAILBOX
N/*
N * mailbox interface
N */
Nrt_err_t rt_mb_init(rt_mailbox_t mb,
N                    const char  *name,
N                    void        *msgpool,
N                    rt_size_t    size,
N                    rt_uint8_t   flag);
Nrt_err_t rt_mb_detach(rt_mailbox_t mb);
Nrt_mailbox_t rt_mb_create(const char *name, rt_size_t size, rt_uint8_t flag);
Nrt_err_t rt_mb_delete(rt_mailbox_t mb);
N
Nrt_err_t rt_mb_send(rt_mailbox_t mb, rt_uint32_t value);
Nrt_err_t rt_mb_send_wait(rt_mailbox_t mb,
N                         rt_uint32_t  value,
N                         rt_int32_t   timeout);
Nrt_err_t rt_mb_recv(rt_mailbox_t mb, rt_uint32_t *value, rt_int32_t timeout);
Nrt_err_t rt_mb_control(rt_mailbox_t mb, rt_uint8_t cmd, void *arg);
N#endif
N
N#ifdef RT_USING_MESSAGEQUEUE
N/*
N * message queue interface
N */
Nrt_err_t rt_mq_init(rt_mq_t     mq,
N                    const char *name,
N                    void       *msgpool,
N                    rt_size_t   msg_size,
N                    rt_size_t   pool_size,
N                    rt_uint8_t  flag);
Nrt_err_t rt_mq_detach(rt_mq_t mq);
Nrt_mq_t rt_mq_create(const char *name,
N                     rt_size_t   msg_size,
N                     rt_size_t   max_msgs,
N                     rt_uint8_t  flag);
Nrt_err_t rt_mq_delete(rt_mq_t mq);
N
Nrt_err_t rt_mq_send(rt_mq_t mq, void *buffer, rt_size_t size);
Nrt_err_t rt_mq_urgent(rt_mq_t mq, void *buffer, rt_size_t size);
Nrt_err_t rt_mq_recv(rt_mq_t    mq,
N                    void      *buffer,
N                    rt_size_t  size,
N                    rt_int32_t timeout);
Nrt_err_t rt_mq_control(rt_mq_t mq, rt_uint8_t cmd, void *arg);
N#endif
N
N/**@}*/
N
N#ifdef RT_USING_DEVICE
N/**
N * @addtogroup Device
N */
N
N/**@{*/
N
N/*
N * device (I/O) system interface
N */
Nrt_device_t rt_device_find(const char *name);
N
Nrt_err_t rt_device_register(rt_device_t dev,
N                            const char *name,
N                            rt_uint16_t flags);
Nrt_err_t rt_device_unregister(rt_device_t dev);
Nrt_err_t rt_device_init_all(void);
N
Nrt_err_t
Nrt_device_set_rx_indicate(rt_device_t dev,
N                          rt_err_t (*rx_ind)(rt_device_t dev, rt_size_t size));
Nrt_err_t
Nrt_device_set_tx_complete(rt_device_t dev,
N                          rt_err_t (*tx_done)(rt_device_t dev, void *buffer));
N
Nrt_err_t  rt_device_init (rt_device_t dev);
Nrt_err_t  rt_device_open (rt_device_t dev, rt_uint16_t oflag);
Nrt_err_t  rt_device_close(rt_device_t dev);
Nrt_size_t rt_device_read (rt_device_t dev,
N                          rt_off_t    pos,
N                          void       *buffer,
N                          rt_size_t   size);
Nrt_size_t rt_device_write(rt_device_t dev,
N                          rt_off_t    pos,
N                          const void *buffer,
N                          rt_size_t   size);
Nrt_err_t  rt_device_control(rt_device_t dev, rt_uint8_t cmd, void *arg);
N
N/**@}*/
N#endif
N
N#ifdef RT_USING_MODULE
S/**
S * @addtogroup Module
S */
S
S/**@{*/
S
S/*
S * module interface
S */
Srt_module_t rt_module_load(const char *name, void *module_ptr);
Srt_err_t rt_module_unload(rt_module_t module);
S#ifdef RT_USING_DFS
Srt_module_t rt_module_open(const char *filename);
Srt_module_t rt_module_exec_cmd(const char *path, const char* cmd_line, int size);
S#endif
Svoid *rt_module_malloc(rt_size_t size);
Svoid *rt_module_realloc(void *ptr, rt_size_t size);
Svoid rt_module_free(rt_module_t module, void *addr);
Srt_module_t rt_module_self(void);
Srt_module_t rt_module_find(const char *name);
S
S#ifdef RT_USING_HOOK
Svoid rt_module_load_sethook(void (*hook)(rt_module_t module));
Svoid rt_module_unload_sethook(void (*hook)(rt_module_t module));
S#endif
S
Svoid rt_module_init_object_container(struct rt_module *module);
Srt_err_t rt_module_destroy(rt_module_t module);
S
S/*
S * application module system initialization
S */
Sint rt_system_module_init(void);
S
S/**@}*/
N#endif
N
N/*
N * interrupt service
N */
N
N/*
N * rt_interrupt_enter and rt_interrupt_leave only can be called by BSP
N */
Nvoid rt_interrupt_enter(void);
Nvoid rt_interrupt_leave(void);
N
N/*
N * the number of nested interrupts.
N */
Nrt_uint8_t rt_interrupt_get_nest(void);
N
N#ifdef RT_USING_HOOK
Svoid rt_interrupt_enter_sethook(void (*hook)(void));
Svoid rt_interrupt_leave_sethook(void (*hook)(void));
N#endif
N
N#ifdef RT_USING_COMPONENTS_INIT
Nvoid rt_components_init(void);
Nvoid rt_components_board_init(void);
N#endif
N
N/**
N * @addtogroup KernelService
N */
N
N/**@{*/
N
N/*
N * general kernel service
N */
N#ifndef RT_USING_CONSOLE
S#define rt_kprintf(...)
S#define rt_kputs(str)
N#else
Nvoid rt_kprintf(const char *fmt, ...);
Nvoid rt_kputs(const char *str);
N#endif
Nrt_int32_t rt_vsprintf(char *dest, const char *format, va_list arg_ptr);
Nrt_int32_t rt_vsnprintf(char *buf, rt_size_t size, const char *fmt, va_list args);
Nrt_int32_t rt_sprintf(char *buf ,const char *format, ...);
Nrt_int32_t rt_snprintf(char *buf, rt_size_t size, const char *format, ...);
N
N#if defined(RT_USING_DEVICE) && defined(RT_USING_CONSOLE)
X#if 1L && 1L
Nrt_device_t rt_console_set_device(const char *name);
Nrt_device_t rt_console_get_device(void);
N#endif
N
Nrt_err_t rt_get_errno(void);
Nvoid rt_set_errno(rt_err_t no);
Nint *_rt_errno(void);
N#if !defined(RT_USING_NEWLIB) && !defined(_WIN32)
X#if !0L && !0L
N#ifndef errno
N#define errno    *_rt_errno()
N#endif
N#endif
N
Nvoid *rt_memset(void *src, int c, rt_ubase_t n);
Nvoid *rt_memcpy(void *dest, const void *src, rt_ubase_t n);
N
Nrt_int32_t rt_strncmp(const char *cs, const char *ct, rt_ubase_t count);
Nrt_int32_t rt_strcmp (const char *cs, const char *ct);
Nrt_size_t rt_strlen (const char *src);
Nchar *rt_strdup(const char *s);
N
Nchar *rt_strstr(const char *str1, const char *str2);
Nrt_int32_t rt_sscanf(const char *buf, const char *fmt, ...);
Nchar *rt_strncpy(char *dest, const char *src, rt_ubase_t n);
Nvoid *rt_memmove(void *dest, const void *src, rt_ubase_t n);
Nrt_int32_t rt_memcmp(const void *cs, const void *ct, rt_ubase_t count);
Nrt_uint32_t rt_strcasecmp(const char *a, const char *b);
N
Nvoid rt_show_version(void);
N
N#ifdef RT_DEBUG
Sextern void (*rt_assert_hook)(const char* ex, const char* func, rt_size_t line);
Svoid rt_assert_set_hook(void (*hook)(const char* ex, const char* func, rt_size_t line));
S
Svoid rt_assert_handler(const char* ex, const char* func, rt_size_t line);
N#endif /* RT_DEBUG */
N
N/**@}*/
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 27 "..\..\components\drivers\src\ringbuffer.c" 2
N#include <rtdevice.h>
L 1 "..\..\components\drivers\include\rtdevice.h" 1
N/*
N * File      : rtdevice.h
N * This file is part of RT-Thread RTOS
N * COPYRIGHT (C) 2006 - 2012, RT-Thread Development Team
N *
N *  This program is free software; you can redistribute it and/or modify
N *  it under the terms of the GNU General Public License as published by
N *  the Free Software Foundation; either version 2 of the License, or
N *  (at your option) any later version.
N *
N *  This program is distributed in the hope that it will be useful,
N *  but WITHOUT ANY WARRANTY; without even the implied warranty of
N *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
N *  GNU General Public License for more details.
N *
N *  You should have received a copy of the GNU General Public License along
N *  with this program; if not, write to the Free Software Foundation, Inc.,
N *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
N *
N * Change Logs:
N * Date           Author       Notes
N * 2012-01-08     bernard      first version.
N * 2014-07-12     bernard      Add workqueue implementation.
N */
N
N#ifndef __RT_DEVICE_H__
N#define __RT_DEVICE_H__
N
N#include <rtthread.h>
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#define RT_DEVICE(device)            ((rt_device_t)device)
N
N/* completion flag */
Nstruct rt_completion
N{
N    rt_uint32_t flag;
N
N    /* suspended list */
N    rt_list_t suspended_list;
N};
N
N/* ring buffer */
Nstruct rt_ringbuffer
N{
N    rt_uint8_t *buffer_ptr;
N    /* use the msb of the {read,write}_index as mirror bit. You can see this as
N     * if the buffer adds a virtual mirror and the pointers point either to the
N     * normal or to the mirrored buffer. If the write_index has the same value
N     * with the read_index, but in a different mirror, the buffer is full.
N     * While if the write_index and the read_index are the same and within the
N     * same mirror, the buffer is empty. The ASCII art of the ringbuffer is:
N     *
N     *          mirror = 0                    mirror = 1
N     * +---+---+---+---+---+---+---+|+~~~+~~~+~~~+~~~+~~~+~~~+~~~+
N     * | 0 | 1 | 2 | 3 | 4 | 5 | 6 ||| 0 | 1 | 2 | 3 | 4 | 5 | 6 | Full
N     * +---+---+---+---+---+---+---+|+~~~+~~~+~~~+~~~+~~~+~~~+~~~+
N     *  read_idx-^                   write_idx-^
N     *
N     * +---+---+---+---+---+---+---+|+~~~+~~~+~~~+~~~+~~~+~~~+~~~+
N     * | 0 | 1 | 2 | 3 | 4 | 5 | 6 ||| 0 | 1 | 2 | 3 | 4 | 5 | 6 | Empty
N     * +---+---+---+---+---+---+---+|+~~~+~~~+~~~+~~~+~~~+~~~+~~~+
N     * read_idx-^ ^-write_idx
N     *
N     * The tradeoff is we could only use 32KiB of buffer for 16 bit of index.
N     * But it should be enough for most of the cases.
N     *
N     * Ref: http://en.wikipedia.org/wiki/Circular_buffer#Mirroring */
N    rt_uint16_t read_mirror : 1;
N    rt_uint16_t read_index : 15;
N    rt_uint16_t write_mirror : 1;
N    rt_uint16_t write_index : 15;
N    /* as we use msb of index as mirror bit, the size should be signed and
N     * could only be positive. */
N    rt_int16_t buffer_size;
N};
N
N/* portal device */
Nstruct rt_portal_device
N{
N    struct rt_device parent;
N    struct rt_device *write_dev;
N    struct rt_device *read_dev;
N};
N
N/* pipe device */
N#define PIPE_DEVICE(device)          ((struct rt_pipe_device*)(device))
Nenum rt_pipe_flag
N{
N    /* both read and write won't block */
N    RT_PIPE_FLAG_NONBLOCK_RDWR = 0x00,
N    /* read would block */
N    RT_PIPE_FLAG_BLOCK_RD = 0x01,
N    /* write would block */
N    RT_PIPE_FLAG_BLOCK_WR = 0x02,
N    /* write to this pipe will discard some data when the pipe is full.
N     * When this flag is set, RT_PIPE_FLAG_BLOCK_WR will be ignored since write
N     * operation will always be success. */
N    RT_PIPE_FLAG_FORCE_WR = 0x04,
N};
N
Nstruct rt_pipe_device
N{
N    struct rt_device parent;
N
N    /* ring buffer in pipe device */
N    struct rt_ringbuffer ringbuffer;
N
N    enum rt_pipe_flag flag;
N
N    /* suspended list */
N    rt_list_t suspended_read_list;
N    rt_list_t suspended_write_list;
N
N    struct rt_portal_device *write_portal;
N    struct rt_portal_device *read_portal;
N};
N
N#define PIPE_CTRL_GET_SPACE          0x14            /**< get the remaining size of a pipe device */
N
N#define RT_DATAQUEUE_EVENT_UNKNOWN   0x00
N#define RT_DATAQUEUE_EVENT_POP       0x01
N#define RT_DATAQUEUE_EVENT_PUSH      0x02
N#define RT_DATAQUEUE_EVENT_LWM       0x03
N
Nstruct rt_data_item;
N#define RT_DATAQUEUE_SIZE(dq)        ((dq)->put_index - (dq)->get_index)
N#define RT_DATAQUEUE_EMPTY(dq)       ((dq)->size - RT_DATAQUEUE_SIZE(dq))
N/* data queue implementation */
Nstruct rt_data_queue
N{
N    rt_uint16_t size;
N    rt_uint16_t lwm;
N
N    rt_uint16_t get_index;
N    rt_uint16_t put_index;
N
N    struct rt_data_item *queue;
N
N    rt_list_t suspended_push_list;
N    rt_list_t suspended_pop_list;
N
N    /* event notify */
N    void (*evt_notify)(struct rt_data_queue *queue, rt_uint32_t event);
N};
N
N/* workqueue implementation */
Nstruct rt_workqueue
N{
N	rt_list_t      work_list;
N	struct rt_work *work_current; /* current work */
N	rt_thread_t    work_thread;
N};
N
Nstruct rt_work
N{
N	rt_list_t list;
N
N	void (*work_func)(struct rt_work* work, void* work_data);
N	void *work_data;
N};
N
N/**
N * Completion
N */
Nvoid rt_completion_init(struct rt_completion *completion);
Nrt_err_t rt_completion_wait(struct rt_completion *completion,
N                            rt_int32_t            timeout);
Nvoid rt_completion_done(struct rt_completion *completion);
N
N/**
N * RingBuffer for DeviceDriver
N *
N * Please note that the ring buffer implementation of RT-Thread
N * has no thread wait or resume feature.
N */
Nvoid rt_ringbuffer_init(struct rt_ringbuffer *rb,
N                        rt_uint8_t           *pool,
N                        rt_int16_t            size);
Nrt_size_t rt_ringbuffer_put(struct rt_ringbuffer *rb,
N                            const rt_uint8_t     *ptr,
N                            rt_uint16_t           length);
Nrt_size_t rt_ringbuffer_put_force(struct rt_ringbuffer *rb,
N                                  const rt_uint8_t     *ptr,
N                                  rt_uint16_t           length);
Nrt_size_t rt_ringbuffer_putchar(struct rt_ringbuffer *rb,
N                                const rt_uint8_t      ch);
Nrt_size_t rt_ringbuffer_putchar_force(struct rt_ringbuffer *rb,
N                                      const rt_uint8_t      ch);
Nrt_size_t rt_ringbuffer_get(struct rt_ringbuffer *rb,
N                            rt_uint8_t           *ptr,
N                            rt_uint16_t           length);
Nrt_size_t rt_ringbuffer_getchar(struct rt_ringbuffer *rb, rt_uint8_t *ch);
N
Nenum rt_ringbuffer_state
N{
N    RT_RINGBUFFER_EMPTY,
N    RT_RINGBUFFER_FULL,
N    /* half full is neither full nor empty */
N    RT_RINGBUFFER_HALFFULL,
N};
N
Nrt_inline rt_uint16_t rt_ringbuffer_get_size(struct rt_ringbuffer *rb)
Xstatic __inline rt_uint16_t rt_ringbuffer_get_size(struct rt_ringbuffer *rb)
N{
N    RT_ASSERT(rb != RT_NULL);
X    ;
N    return rb->buffer_size;
N}
N
Nrt_inline enum rt_ringbuffer_state
Xstatic __inline enum rt_ringbuffer_state
Nrt_ringbuffer_status(struct rt_ringbuffer *rb)
N{
N    if (rb->read_index == rb->write_index)
N    {
N        if (rb->read_mirror == rb->write_mirror)
N            return RT_RINGBUFFER_EMPTY;
N        else
N            return RT_RINGBUFFER_FULL;
N    }
N    return RT_RINGBUFFER_HALFFULL;
N}
N
N/** return the size of data in rb */
Nrt_inline rt_uint16_t rt_ringbuffer_data_len(struct rt_ringbuffer *rb)
Xstatic __inline rt_uint16_t rt_ringbuffer_data_len(struct rt_ringbuffer *rb)
N{
N    switch (rt_ringbuffer_status(rb))
N    {
N    case RT_RINGBUFFER_EMPTY:
N        return 0;
N    case RT_RINGBUFFER_FULL:
N        return rb->buffer_size;
N    case RT_RINGBUFFER_HALFFULL:
N    default:
N        if (rb->write_index > rb->read_index)
N            return rb->write_index - rb->read_index;
N        else
N            return rb->buffer_size - (rb->read_index - rb->write_index);
N    };
N}
N
N/** return the size of empty space in rb */
N#define rt_ringbuffer_space_len(rb) ((rb)->buffer_size - rt_ringbuffer_data_len(rb))
N
N/**
N * Pipe Device
N */
Nrt_err_t rt_pipe_init(struct rt_pipe_device *pipe,
N                      const char *name,
N                      enum rt_pipe_flag flag,
N                      rt_uint8_t *buf,
N                      rt_size_t size);
Nrt_err_t rt_pipe_detach(struct rt_pipe_device *pipe);
N#ifdef RT_USING_HEAP
Nrt_err_t rt_pipe_create(const char *name, enum rt_pipe_flag flag, rt_size_t size);
Nvoid rt_pipe_destroy(struct rt_pipe_device *pipe);
N#endif
N
N/**
N * Portal for DeviceDriver
N */
N
Nrt_err_t rt_portal_init(struct rt_portal_device *portal,
N                        const char *portal_name,
N                        const char *write_dev,
N                        const char *read_dev);
Nrt_err_t rt_portal_detach(struct rt_portal_device *portal);
N
N#ifdef RT_USING_HEAP
Nrt_err_t rt_portal_create(const char *name,
N                          const char *write_dev,
N                          const char *read_dev);
Nvoid rt_portal_destroy(struct rt_portal_device *portal);
N#endif
N
N/**
N * DataQueue for DeviceDriver
N */
Nrt_err_t rt_data_queue_init(struct rt_data_queue *queue,
N                            rt_uint16_t           size,
N                            rt_uint16_t           lwm,
N                            void (*evt_notify)(struct rt_data_queue *queue, rt_uint32_t event));
Nrt_err_t rt_data_queue_push(struct rt_data_queue *queue,
N                            const void           *data_ptr,
N                            rt_size_t             data_size,
N                            rt_int32_t            timeout);
Nrt_err_t rt_data_queue_pop(struct rt_data_queue *queue,
N                           const void          **data_ptr,
N                           rt_size_t            *size,
N                           rt_int32_t            timeout);
Nrt_err_t rt_data_queue_peak(struct rt_data_queue *queue,
N                            const void          **data_ptr,
N                            rt_size_t            *size);
Nvoid rt_data_queue_reset(struct rt_data_queue *queue);
N
N#ifdef RT_USING_HEAP
N/**
N * WorkQueue for DeviceDriver
N */
Nstruct rt_workqueue *rt_workqueue_create(const char* name, rt_uint16_t stack_size, rt_uint8_t priority);
Nrt_err_t rt_workqueue_destroy(struct rt_workqueue* queue);
Nrt_err_t rt_workqueue_dowork(struct rt_workqueue* queue, struct rt_work* work);
Nrt_err_t rt_workqueue_cancel_work(struct rt_workqueue* queue, struct rt_work* work);
N
Nrt_inline void rt_work_init(struct rt_work* work, void (*work_func)(struct rt_work* work, void* work_data),
Xstatic __inline void rt_work_init(struct rt_work* work, void (*work_func)(struct rt_work* work, void* work_data),
N    void* work_data)
N{
N    rt_list_init(&(work->list));
N    work->work_func = work_func;
N    work->work_data = work_data;
N}
N#endif
N
N#ifdef RT_USING_RTC
S#include "drivers/rtc.h"
S#ifdef RT_USING_ALARM
S#include "drivers/alarm.h"
S#endif
N#endif /* RT_USING_RTC */
N
N#ifdef RT_USING_SPI
S#include "drivers/spi.h"
N#endif /* RT_USING_SPI */
N
N#ifdef RT_USING_MTD_NOR
S#include "drivers/mtd_nor.h"
N#endif /* RT_USING_MTD_NOR */
N
N#ifdef RT_USING_MTD_NAND
S#include "drivers/mtd_nand.h"
N#endif /* RT_USING_MTD_NAND */
N
N#ifdef RT_USING_USB_DEVICE
N#include "drivers/usb_device.h"
L 1 "..\..\components\drivers\include\drivers/usb_device.h" 1
N/*
N * File      : usb_device.h
N * This file is part of RT-Thread RTOS
N * COPYRIGHT (C) 2012, RT-Thread Development Team
N *
N *  This program is free software; you can redistribute it and/or modify
N *  it under the terms of the GNU General Public License as published by
N *  the Free Software Foundation; either version 2 of the License, or
N *  (at your option) any later version.
N *
N *  This program is distributed in the hope that it will be useful,
N *  but WITHOUT ANY WARRANTY; without even the implied warranty of
N *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
N *  GNU General Public License for more details.
N *
N *  You should have received a copy of the GNU General Public License along
N *  with this program; if not, write to the Free Software Foundation, Inc.,
N *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
N *
N * Change Logs:
N * Date           Author       Notes
N * 2012-10-01     Yi Qiu       first version
N * 2012-12-12     heyuanjie87  change endpoint and function handler
N * 2013-04-26     aozima       add DEVICEQUALIFIER support.
N */
N
N#ifndef  __USB_DEVICE_H__
N#define  __USB_DEVICE_H__
N
N#include <rtthread.h>
N#include "usb_common.h"
L 1 "..\..\components\drivers\include\drivers/usb_common.h" 1
N/*
N * File      : usb_common.h
N * This file is part of RT-Thread RTOS
N * COPYRIGHT (C) 2012, RT-Thread Development Team
N *
N *  This program is free software; you can redistribute it and/or modify
N *  it under the terms of the GNU General Public License as published by
N *  the Free Software Foundation; either version 2 of the License, or
N *  (at your option) any later version.
N *
N *  This program is distributed in the hope that it will be useful,
N *  but WITHOUT ANY WARRANTY; without even the implied warranty of
N *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
N *  GNU General Public License for more details.
N *
N *  You should have received a copy of the GNU General Public License along
N *  with this program; if not, write to the Free Software Foundation, Inc.,
N *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
N *
N * Change Logs:
N * Date           Author       Notes
N * 2012-10-01     Yi Qiu       first version
N * 2013-04-26     aozima       add DEVICEQUALIFIER support.
N */
N
N#ifndef __USB_COMMON_H__
N#define __USB_COMMON_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include <rtthread.h>
N
N#define RT_DEBUG_USB                    0x00
N#define USB_DYNAMIC                     0x00
N
N#define USB_CLASS_DEVICE                0x00
N#define USB_CLASS_AUDIO                 0x01
N#define USB_CLASS_CDC                   0x02
N#define USB_CLASS_HID                   0x03
N#define USB_CLASS_PHYSICAL              0x05
N#define USB_CLASS_IMAGE                 0x06
N#define USB_CLASS_PRINTER               0x07
N#define USB_CLASS_MASS_STORAGE          0x08
N#define USB_CLASS_HUB                   0x09
N#define USB_CLASS_CDC_DATA              0x0a
N#define USB_CLASS_SMART_CARD            0x0b
N#define USB_CLASS_SECURITY              0x0d
N#define USB_CLASS_VIDEO                 0x0e
N#define USB_CLASS_HEALTHCARE            0x0f
N#define USB_CLASS_DIAG_DEVICE           0xdc
N#define USB_CLASS_WIRELESS              0xe0
N#define USB_CLASS_MISC                  0xef
N#define USB_CLASS_APP_SPECIFIC          0xfe
N#define USB_CLASS_VEND_SPECIFIC         0xff
N
N#define USB_DESC_TYPE_DEVICE            0x01
N#define USB_DESC_TYPE_CONFIGURATION     0x02
N#define USB_DESC_TYPE_STRING            0x03
N#define USB_DESC_TYPE_INTERFACE         0x04
N#define USB_DESC_TYPE_ENDPOINT          0x05
N#define USB_DESC_TYPE_DEVICEQUALIFIER   0x06
N#define USB_DESC_TYPE_OTHERSPEED        0x07
N#define USB_DESC_TYPE_IAD               0x0b
N#define USB_DESC_TYPE_HID               0x21
N#define USB_DESC_TYPE_REPORT            0x22
N#define USB_DESC_TYPE_PHYSICAL          0x23
N#define USB_DESC_TYPE_HUB               0x29
N
N#define USB_DESC_LENGTH_DEVICE          0x12
N#define USB_DESC_LENGTH_CONFIG          0x9
N#define USB_DESC_LENGTH_IAD             0x8
N#define USB_DESC_LENGTH_STRING          0x4
N#define USB_DESC_LENGTH_INTERFACE       0x9
N#define USB_DESC_LENGTH_ENDPOINT        0x7
N
N#define USB_REQ_TYPE_STANDARD           0x00
N#define USB_REQ_TYPE_CLASS              0x20
N#define USB_REQ_TYPE_VENDOR             0x40
N#define USB_REQ_TYPE_MASK               0x60
N
N#define USB_REQ_TYPE_DIR_OUT            0x00
N#define USB_REQ_TYPE_DIR_IN             0x80
N
N#define USB_REQ_TYPE_DEVICE             0x00
N#define USB_REQ_TYPE_INTERFACE          0x01
N#define USB_REQ_TYPE_ENDPOINT           0x02
N#define USB_REQ_TYPE_OTHER              0x03
N#define USB_REQ_TYPE_RECIPIENT_MASK     0x1f
N
N#define USB_FEATURE_ENDPOINT_HALT       0x00
N#define USB_FEATURE_DEV_REMOTE_WAKEUP   0x01
N#define USB_FEATURE_TEST_MODE           0x02
N
N#define USB_REQ_GET_STATUS              0x00
N#define USB_REQ_CLEAR_FEATURE           0x01
N#define USB_REQ_SET_FEATURE             0x03
N#define USB_REQ_SET_ADDRESS             0x05
N#define USB_REQ_GET_DESCRIPTOR          0x06
N#define USB_REQ_SET_DESCRIPTOR          0x07
N#define USB_REQ_GET_CONFIGURATION       0x08
N#define USB_REQ_SET_CONFIGURATION       0x09
N#define USB_REQ_GET_INTERFACE           0x0A
N#define USB_REQ_SET_INTERFACE           0x0B
N#define USB_REQ_SYNCH_FRAME             0x0C
N#define USB_REQ_SET_ENCRYPTION          0x0D
N#define USB_REQ_GET_ENCRYPTION          0x0E
N#define USB_REQ_RPIPE_ABORT             0x0E
N#define USB_REQ_SET_HANDSHAKE           0x0F
N#define USB_REQ_RPIPE_RESET             0x0F
N#define USB_REQ_GET_HANDSHAKE           0x10
N#define USB_REQ_SET_CONNECTION          0x11
N#define USB_REQ_SET_SECURITY_DATA       0x12
N#define USB_REQ_GET_SECURITY_DATA       0x13
N#define USB_REQ_SET_WUSB_DATA           0x14
N#define USB_REQ_LOOPBACK_DATA_WRITE     0x15
N#define USB_REQ_LOOPBACK_DATA_READ      0x16
N#define USB_REQ_SET_INTERFACE_DS        0x17
N
N#define USB_STRING_LANGID_INDEX         0x00
N#define USB_STRING_MANU_INDEX           0x01
N#define USB_STRING_PRODUCT_INDEX        0x02
N#define USB_STRING_SERIAL_INDEX         0x03
N#define USB_STRING_CONFIG_INDEX         0x04
N#define USB_STRING_INTERFACE_INDEX      0x05
N
N#define USB_PID_OUT                     0x01
N#define USB_PID_ACK                     0x02
N#define USB_PID_DATA0                   0x03
N#define USB_PID_SOF                     0x05
N#define USB_PID_IN                      0x09
N#define USB_PID_NACK                    0x0A
N#define USB_PID_DATA1                   0x0B
N#define USB_PID_PRE                     0x0C
N#define USB_PID_SETUP                   0x0D
N#define USB_PID_STALL                   0x0E
N
N#define USB_EP_DESC_OUT                 0x00
N#define USB_EP_DESC_IN                  0x80
N#define USB_EP_DESC_NUM_MASK            0x0f
N
N#define USB_EP_ATTR_CONTROL             0x00
N#define USB_EP_ATTR_ISOC                0x01
N#define USB_EP_ATTR_BULK                0x02
N#define USB_EP_ATTR_INT                 0x03
N#define USB_EP_ATTR_TYPE_MASK           0x03
N
N#define USB_EPNO_MASK                   0x7f
N#define USB_DIR_OUT                     0x00
N#define USB_DIR_IN                      0x80
N#define USB_DIR_INOUT                   0x40
N#define USB_DIR_MASK                    0x80
N
N#define ID_UNASSIGNED                   0
N#define ID_ASSIGNED                     1
N
N#define RH_GET_PORT_STATUS              0
N#define RH_SET_PORT_STATUS              1
N#define RH_CLEAR_PORT_FEATURE           2
N#define RH_SET_PORT_FEATURE             3
N
N#define USB_BUS_POWERED                 0
N#define USB_SELF_POWERED                1
N#define USB_REMOTE_WAKEUP               1
N#define USB_EP_HALT                     0
N
N/*
N * Port feature numbers
N */
N#define PORT_FEAT_CONNECTION            0
N#define PORT_FEAT_ENABLE                1
N#define PORT_FEAT_SUSPEND               2
N#define PORT_FEAT_OVER_CURRENT          3
N#define PORT_FEAT_RESET                 4
N#define PORT_FEAT_POWER                 8
N#define PORT_FEAT_LOWSPEED              9
N#define PORT_FEAT_HIGHSPEED             10
N#define PORT_FEAT_C_CONNECTION          16
N#define PORT_FEAT_C_ENABLE              17
N#define PORT_FEAT_C_SUSPEND             18
N#define PORT_FEAT_C_OVER_CURRENT        19
N#define PORT_FEAT_C_RESET               20
N
N/*
N    The HcRhPortStatus[1:NDP] register is used to control and report port events on a per-port
N    basis. NumberDownstreamPorts represents the number of HcRhPortStatus registers that are
N    implemented in hardware.  The lower word is used to reflect the port status, whereas the upper
N    word reflects the status change bits.  Some status bits are implemented with special write behavior
N    (see below).  If a transaction (token through handshake) is in progress when a write to change
N    port status occurs, the resulting port status change must be postponed until the transaction
N    completes.  Reserved bits should always be written '0'.
N*/
N#define PORT_CCS                        0x00000001UL    /* R:CurrentConnectStatus - W:ClearPortEnable    */
N#define PORT_PES                        0x00000002UL    /* R:PortEnableStatus - W:SetPortEnable             */
N#define PORT_PSS                        0x00000004UL    /* R:PortSuspendStatus - W:SetPortSuspend        */
N#define PORT_POCI                       0x00000008UL    /* R:PortOverCurrentIndicator - W:ClearSuspendStatus    */
N#define PORT_PRS                        0x00000010UL    /* R:PortResetStatus - W: SetPortReset            */
N#define PORT_PPS                        0x00000100UL    /* R:PortPowerStatus - W: SetPortPower            */
N#define PORT_LSDA                       0x00000200UL    /* R:LowSpeedDeviceAttached - W:ClearPortPower    */
N#define PORT_CCSC                       0x00010000UL
N#define PORT_PESC                       0x00020000UL
N#define PORT_PSSC                       0x00040000UL
N#define PORT_POCIC                      0x00080000UL
N#define PORT_PRSC                       0x00100000UL
N
N/*
N *Hub Status & Hub Change bit masks
N */
N#define HUB_STATUS_LOCAL_POWER          0x0001
N#define HUB_STATUS_OVERCURRENT          0x0002
N
N#define HUB_CHANGE_LOCAL_POWER          0x0001
N#define HUB_CHANGE_OVERCURRENT          0x0002
N
N#define USB_EP_ATTR(attr)               (attr & USB_EP_ATTR_TYPE_MASK)
N#define USB_EP_DESC_NUM(addr)           (addr & USB_EP_DESC_NUM_MASK)
N#define USB_EP_DIR(addr)                ((addr & USB_DIR_MASK)>>7)
N
N#define uswap_32(x) \
N    ((((x) & 0xff000000) >> 24) | \
N     (((x) & 0x00ff0000) >>  8) | \
N     (((x) & 0x0000ff00) <<  8) | \
N     (((x) & 0x000000ff) << 24))
X#define uswap_32(x)     ((((x) & 0xff000000) >> 24) |      (((x) & 0x00ff0000) >>  8) |      (((x) & 0x0000ff00) <<  8) |      (((x) & 0x000000ff) << 24))
N
N#define  uswap_8(x) \
N    (((rt_uint16_t)(*((rt_uint8_t *)(x)))) + \
N    (((rt_uint16_t)(*(((rt_uint8_t *)(x)) + 1))) << 8))
X#define  uswap_8(x)     (((rt_uint16_t)(*((rt_uint8_t *)(x)))) +     (((rt_uint16_t)(*(((rt_uint8_t *)(x)) + 1))) << 8))
N
Ntypedef void (*func_callback)(void *context);
Ntypedef enum
N{
N    USB_STATE_NOTATTACHED = 0,
N    USB_STATE_ATTACHED,
N    USB_STATE_POWERED,
N    USB_STATE_RECONNECTING,
N    USB_STATE_UNAUTHENTICATED,
N    USB_STATE_DEFAULT,
N    USB_STATE_ADDRESS,
N    USB_STATE_CONFIGURED,
N    USB_STATE_SUSPENDED
N}udevice_state_t;
N
N#pragma pack(1)
N
Nstruct usb_descriptor
N{
N    rt_uint8_t bLength;
N    rt_uint8_t type;
N};
Ntypedef struct usb_descriptor* udesc_t;
N
Nstruct udevice_descriptor
N{
N    rt_uint8_t bLength;
N    rt_uint8_t type;
N    rt_uint16_t bcdUSB;
N    rt_uint8_t bDeviceClass;
N    rt_uint8_t bDeviceSubClass;
N    rt_uint8_t bDeviceProtocol;
N    rt_uint8_t bMaxPacketSize0;
N    rt_uint16_t idVendor;
N    rt_uint16_t idProduct;
N    rt_uint16_t bcdDevice;
N    rt_uint8_t iManufacturer;
N    rt_uint8_t iProduct;
N    rt_uint8_t iSerialNumber;
N    rt_uint8_t bNumConfigurations;
N};
Ntypedef struct udevice_descriptor* udev_desc_t;
N
Nstruct uconfig_descriptor
N{
N    rt_uint8_t bLength;
N    rt_uint8_t type;
N    rt_uint16_t wTotalLength;
N    rt_uint8_t bNumInterfaces;
N    rt_uint8_t bConfigurationValue;
N    rt_uint8_t iConfiguration;
N    rt_uint8_t bmAttributes;
N    rt_uint8_t MaxPower;
N    rt_uint8_t data[256];
N};
Ntypedef struct uconfig_descriptor* ucfg_desc_t;
N
Nstruct uinterface_descriptor
N{
N    rt_uint8_t bLength;
N    rt_uint8_t type;
N    rt_uint8_t bInterfaceNumber;
N    rt_uint8_t bAlternateSetting;
N    rt_uint8_t bNumEndpoints;
N    rt_uint8_t bInterfaceClass;
N    rt_uint8_t bInterfaceSubClass;
N    rt_uint8_t bInterfaceProtocol;
N    rt_uint8_t iInterface;
N};
Ntypedef struct uinterface_descriptor* uintf_desc_t;
N
N/* Interface Association Descriptor (IAD) */
Nstruct uiad_descriptor
N{
N    rt_uint8_t bLength;
N    rt_uint8_t bDescriptorType;
N    rt_uint8_t bFirstInterface;
N    rt_uint8_t bInterfaceCount;
N    rt_uint8_t bFunctionClass;
N    rt_uint8_t bFunctionSubClass;
N    rt_uint8_t bFunctionProtocol;
N    rt_uint8_t iFunction;
N};
Ntypedef struct uiad_descriptor* uiad_desc_t;
N
Nstruct uendpoint_descriptor
N{
N    rt_uint8_t bLength;
N    rt_uint8_t type;
N    rt_uint8_t bEndpointAddress;
N    rt_uint8_t bmAttributes;
N    rt_uint16_t wMaxPacketSize;
N    rt_uint8_t bInterval;
N};
Ntypedef struct uendpoint_descriptor* uep_desc_t;
N
Nstruct ustring_descriptor
N{
N    rt_uint8_t bLength;
N    rt_uint8_t type;
N    rt_uint8_t String[64];
N};
Ntypedef struct ustring_descriptor* ustr_desc_t;
N
Nstruct uhub_descriptor
N{
N    rt_uint8_t length;
N    rt_uint8_t type;
N    rt_uint8_t num_ports;
N    rt_uint16_t characteristics;
N    rt_uint8_t pwron_to_good;        /* power on to power good */
N    rt_uint8_t current;
N    rt_uint8_t removable[8];
N    rt_uint8_t pwr_ctl[8];
N};
Ntypedef struct uhub_descriptor* uhub_desc_t;
N
N/* USB_DESC_TYPE_DEVICEQUALIFIER: Device Qualifier descriptor */
Nstruct usb_qualifier_descriptor
N{
N    rt_uint8_t  bLength;
N    rt_uint8_t  bDescriptorType;
N
N    rt_uint16_t bcdUSB; // TODO: big-endian.
N    rt_uint8_t  bDeviceClass;
N    rt_uint8_t  bDeviceSubClass;
N    rt_uint8_t  bDeviceProtocol;
N    rt_uint8_t  bMaxPacketSize0;
N    rt_uint8_t  bNumConfigurations;
N    rt_uint8_t  bRESERVED;
N} __attribute__ ((packed));
N
Nstruct uhid_descriptor
N{
N    rt_uint8_t bLength;
N    rt_uint8_t type;
N    rt_uint16_t bcdHID;
N    rt_uint8_t bCountryCode;
N    rt_uint8_t bNumDescriptors;
N    struct hid_descriptor_list
N    {
N        rt_uint8_t type;
N        rt_uint16_t wLength;
N    }Descriptor[1];
N};
Ntypedef struct uhid_descriptor* uhid_desc_t;
N
Nstruct urequest
N{
N    rt_uint8_t request_type;
N    rt_uint8_t request;
N    rt_uint16_t value;
N    rt_uint16_t index;
N    rt_uint16_t length;
N};
Ntypedef struct urequest* ureq_t;
N
N#ifndef MIN
N#define MIN(a, b) (a < b ? a : b)
N#define MAX(a, b) (a > b ? a : b)
N#endif
N
N/*
N * the define related to mass storage
N */
N#define USBREQ_GET_MAX_LUN              0xfe
N#define USBREQ_MASS_STORAGE_RESET       0xff
N
N#define SIZEOF_CSW                      0x0d
N#define SIZEOF_CBW                      0x1f
N#define SIZEOF_INQUIRY_CMD              0x24
N#define SIZEOF_MODE_SENSE_6             0x4
N#define SIZEOF_READ_CAPACITIES          0xc
N#define SIZEOF_READ_CAPACITY            0x8
N#define SIZEOF_REQUEST_SENSE            0x12
N
N#define CBWFLAGS_DIR_M                  0x80
N#define CBWFLAGS_DIR_IN                 0x80
N#define CBWFLAGS_DIR_OUT                0x00
N
N#define SCSI_TEST_UNIT_READY            0x00
N#define SCSI_REQUEST_SENSE              0x03
N#define SCSI_INQUIRY_CMD                0x12
N#define SCSI_ALLOW_REMOVAL              0x1e
N#define SCSI_MODE_SENSE_6               0x1a
N#define SCSI_START_STOP                 0x1b
N#define SCSI_READ_CAPACITIES            0x23
N#define SCSI_READ_CAPACITY              0x25
N#define SCSI_READ_10                    0x28
N#define SCSI_WRITE_10                   0x2a
N#define SCSI_VERIFY_10                  0x2f
N
N#define CBW_SIGNATURE                   0x43425355
N#define CSW_SIGNATURE                   0x53425355
N#define CBW_TAG_VALUE                   0x12345678
N
Nstruct ustorage_cbw
N{
N    rt_uint32_t signature;
N    rt_uint32_t tag;
N    rt_uint32_t xfer_len;
N    rt_uint8_t dflags;
N    rt_uint8_t lun;
N    rt_uint8_t cb_len;
N    rt_uint8_t cb[16];
N};
Ntypedef struct ustorage_cbw* ustorage_cbw_t;
N
Nstruct ustorage_csw
N{
N    rt_uint32_t signature;
N    rt_uint32_t tag;
N    rt_int32_t data_reside;
N    rt_uint8_t  status;
N};
Ntypedef struct ustorage_csw* ustorage_csw_t;
N
N#pragma pack()
N
N/*
N * USB device event loop thread configurations
N */
N/* the stack size of USB thread */
N#ifndef RT_USBD_THREAD_STACK_SZ
N#define RT_USBD_THREAD_STACK_SZ 2048
N#endif
N
N/* the priority of USB thread */
N#ifndef RT_USBD_THREAD_PRIO
N#define RT_USBD_THREAD_PRIO 8
N#endif
N
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 32 "..\..\components\drivers\include\drivers/usb_device.h" 2
N#define USB_VENDOR_ID        0x0416
N#define USB_PRODUCT_ID        0xC145
N/* Vendor ID */
N#ifdef USB_VENDOR_ID
N#define _VENDOR_ID              USB_VENDOR_ID
N#else
S#define _VENDOR_ID              0x0EFF
N#endif
N/* Product ID */
N#ifdef USB_PRODUCT_ID
N#define _PRODUCT_ID                 USB_PRODUCT_ID
N#else
S#define _PRODUCT_ID                 0x0001
N#endif
N
N#define USB_BCD_DEVICE              0x0200   /* USB Specification Release Number in Binary-Coded Decimal */
N#define USB_BCD_VERSION             0x0200   /* USB 2.0 */
N#define EP0_IN_ADDR                 0x80
N#define EP0_OUT_ADDR                0x00
N#define EP_HANDLER(ep, func, size)  RT_ASSERT(ep != RT_NULL); ep->handler(func, size)
N#define EP_ADDRESS(ep)              ep->ep_desc->bEndpointAddress
N#define EP_MAXPACKET(ep)            ep->ep_desc->wMaxPacketSize
N#define FUNC_ENABLE(func)           do{                                             \
N                                        if(func->ops->enable != RT_NULL &&          \
N                                            func->enabled == RT_FALSE)              \
N                                        {                                           \
N                                            if(func->ops->enable(func) == RT_EOK)   \
N                                                func->enabled = RT_TRUE;            \
N                                        }                                           \
N                                    }while(0)
X#define FUNC_ENABLE(func)           do{                                                                                     if(func->ops->enable != RT_NULL &&                                                      func->enabled == RT_FALSE)                                                      {                                                                                       if(func->ops->enable(func) == RT_EOK)                                                   func->enabled = RT_TRUE;                                                    }                                                                               }while(0)
N#define FUNC_DISABLE(func)          do{                                             \
N                                        if(func->ops->disable != RT_NULL &&         \
N                                            func->enabled == RT_TRUE)               \
N                                        {                                           \
N                                                func->enabled = RT_FALSE;           \
N                                                func->ops->disable(func);           \
N                                        }                                           \
N                                    }while(0)
X#define FUNC_DISABLE(func)          do{                                                                                     if(func->ops->disable != RT_NULL &&                                                     func->enabled == RT_TRUE)                                                       {                                                                                           func->enabled = RT_FALSE;                                                           func->ops->disable(func);                                                   }                                                                               }while(0)
N
Nstruct ufunction;
Nstruct udevice;
Nstruct uendpoint;
N
Ntypedef enum 
N{
N    /* request to read full count */
N    UIO_REQUEST_READ_FULL,
N    /* request to read any count */
N    UIO_REQUEST_READ_MOST,  
N    /* request to write full count */
N    UIO_REQUEST_WRITE,
N}UIO_REQUEST_TYPE;
N
Nstruct udcd_ops
N{
N    rt_err_t (*set_address)(rt_uint8_t address);
N    rt_err_t (*set_config)(rt_uint8_t address);
N    rt_err_t (*ep_set_stall)(rt_uint8_t address);
N    rt_err_t (*ep_clear_stall)(rt_uint8_t address);
N    rt_err_t (*ep_enable)(struct uendpoint* ep);
N    rt_err_t (*ep_disable)(struct uendpoint* ep);
N    rt_size_t (*ep_read_prepare)(rt_uint8_t address, void *buffer, rt_size_t size);
N    rt_size_t (*ep_read)(rt_uint8_t address, void *buffer);
N    rt_size_t (*ep_write)(rt_uint8_t address, void *buffer, rt_size_t size);
N    rt_err_t (*ep0_send_status)(void);
N    rt_err_t (*suspend)(void);
N    rt_err_t (*wakeup)(void);    
N};
N
Nstruct ep_id
N{
N    rt_uint8_t addr;
N    rt_uint8_t type;
N    rt_uint8_t dir;
N    rt_uint8_t maxpacket;
N    rt_uint8_t status;
N};
N
Ntypedef rt_err_t (*udep_handler_t)(struct ufunction* func, rt_size_t size);
N
Nstruct uio_request
N{
N    rt_list_t list;
N    UIO_REQUEST_TYPE req_type;
N    rt_uint8_t* buffer;
N    rt_size_t size;
N    rt_size_t remain_size;
N};
Ntypedef struct uio_request* uio_request_t;
N
Nstruct uendpoint
N{
N    rt_list_t list;
N    uep_desc_t ep_desc;
N    rt_list_t request_list;
N    struct uio_request request;
N    rt_uint8_t* buffer;
N    rt_bool_t stalled;
N    struct ep_id* id;
N    udep_handler_t handler;
N    rt_err_t (*rx_indicate)(struct udevice* dev, rt_size_t size);
N};
Ntypedef struct uendpoint* uep_t;
N
Nstruct udcd
N{
N    struct rt_device parent;
N    const struct udcd_ops* ops;
N    struct uendpoint ep0;
N    struct ep_id* ep_pool;
N};
Ntypedef struct udcd* udcd_t;
N
Nstruct ualtsetting
N{
N    rt_list_t list;
N    uintf_desc_t intf_desc;
N    void* desc;
N    rt_size_t desc_size;
N    rt_list_t ep_list;
N};
Ntypedef struct ualtsetting* ualtsetting_t;
N
Ntypedef rt_err_t (*uintf_handler_t)(struct ufunction* func, ureq_t setup);
N
Nstruct uinterface
N{
N    rt_list_t list;
N    rt_uint8_t intf_num;
N    ualtsetting_t curr_setting;
N    rt_list_t setting_list;
N    uintf_handler_t handler;
N};
Ntypedef struct uinterface* uintf_t;
N
Nstruct ufunction_ops
N{
N    rt_err_t (*enable)(struct ufunction* func);
N    rt_err_t (*disable)(struct ufunction* func);
N    rt_err_t (*sof_handler)(struct ufunction* func);
N};
Ntypedef struct ufunction_ops* ufunction_ops_t;
N
Nstruct ufunction
N{
N    rt_list_t list;
N    ufunction_ops_t ops;
N    struct udevice* device;
N    udev_desc_t dev_desc;
N    void* user_data;
N    rt_bool_t enabled;
N
N    rt_list_t intf_list;
N};
Ntypedef struct ufunction* ufunction_t;
N
Nstruct uconfig
N{
N    rt_list_t list;
N    struct uconfig_descriptor cfg_desc;
N    rt_list_t func_list;
N};
Ntypedef struct uconfig* uconfig_t;
N
Nstruct udevice
N{
N    rt_list_t list;
N    struct udevice_descriptor dev_desc;
N
N    struct usb_qualifier_descriptor * dev_qualifier;
N    const char** str;
N
N    udevice_state_t state;
N    rt_list_t cfg_list;
N    uconfig_t curr_cfg;
N    rt_uint8_t nr_intf;
N
N    udcd_t dcd;
N};
Ntypedef struct udevice* udevice_t;
N
Nenum udev_msg_type
N{
N    USB_MSG_SETUP_NOTIFY,
N    USB_MSG_DATA_NOTIFY,
N    USB_MSG_EP0_OUT,
N    USB_MSG_EP_CLEAR_FEATURE,        
N    USB_MSG_SOF,
N    USB_MSG_RESET,
N    USB_MSG_PLUG_IN,    
N    /* we don't need to add a "PLUG_IN" event because after the cable is
N     * plugged in(before any SETUP) the classed have nothing to do. If the host
N     * is ready, it will send RESET and we will have USB_MSG_RESET. So, a RESET
N     * should reset and run the class while plug_in is not. */
N    USB_MSG_PLUG_OUT,
N};
Ntypedef enum udev_msg_type udev_msg_type;
N
Nstruct ep_msg
N{
N    rt_size_t size;
N    rt_uint8_t ep_addr;
N};
N
Nstruct udev_msg
N{
N    udev_msg_type type;
N    udcd_t dcd;
N    union
N    {
N        struct ep_msg ep_msg;
N        struct urequest setup;
N    } content;
N};
Ntypedef struct udev_msg* udev_msg_t;
N
Nudevice_t rt_usbd_device_new(void);
Nuconfig_t rt_usbd_config_new(void);
Nufunction_t rt_usbd_function_new(udevice_t device, udev_desc_t dev_desc,
N                              ufunction_ops_t ops);
Nuintf_t rt_usbd_interface_new(udevice_t device, uintf_handler_t handler);
Nuep_t rt_usbd_endpoint_new(uep_desc_t ep_desc, udep_handler_t handler);
Nualtsetting_t rt_usbd_altsetting_new(rt_size_t desc_size);
N
Nrt_err_t rt_usbd_core_init(void);
Nrt_err_t rt_usb_device_init(void);
Nrt_err_t rt_usbd_event_signal(struct udev_msg* msg);
Nrt_err_t rt_usbd_device_set_controller(udevice_t device, udcd_t dcd);
Nrt_err_t rt_usbd_device_set_descriptor(udevice_t device, udev_desc_t dev_desc);
Nrt_err_t rt_usbd_device_set_string(udevice_t device, const char** ustring);
Nrt_err_t rt_usbd_device_set_qualifier(udevice_t device, struct usb_qualifier_descriptor* qualifier);
Nrt_err_t rt_usbd_device_add_config(udevice_t device, uconfig_t cfg);
Nrt_err_t rt_usbd_config_add_function(uconfig_t cfg, ufunction_t func);
Nrt_err_t rt_usbd_function_add_interface(ufunction_t func, uintf_t intf);
Nrt_err_t rt_usbd_interface_add_altsetting(uintf_t intf, ualtsetting_t setting);
Nrt_err_t rt_usbd_altsetting_add_endpoint(ualtsetting_t setting, uep_t ep);
Nrt_err_t rt_usbd_altsetting_config_descriptor(ualtsetting_t setting, const void* desc, rt_off_t intf_pos);
Nrt_err_t rt_usbd_set_config(udevice_t device, rt_uint8_t value);
Nrt_err_t rt_usbd_set_altsetting(uintf_t intf, rt_uint8_t value);
N
Nudevice_t rt_usbd_find_device(udcd_t dcd);
Nuconfig_t rt_usbd_find_config(udevice_t device, rt_uint8_t value);
Nuintf_t rt_usbd_find_interface(udevice_t device, rt_uint8_t value, ufunction_t *pfunc);
Nuep_t rt_usbd_find_endpoint(udevice_t device, ufunction_t* pfunc, rt_uint8_t ep_addr);
Nrt_size_t rt_usbd_io_request(udevice_t device, uep_t ep, uio_request_t req);
Nrt_size_t rt_usbd_ep0_write(udevice_t device, void *buffer, rt_size_t size);
Nrt_size_t rt_usbd_ep0_read(udevice_t device, void *buffer, rt_size_t size, 
N    rt_err_t (*rx_ind)(udevice_t device, rt_size_t size));
N
Nufunction_t rt_usbd_function_mstorage_create(udevice_t device);
Nufunction_t rt_usbd_function_cdc_create(udevice_t device);
Nufunction_t rt_usbd_function_rndis_create(udevice_t device);
Nufunction_t rt_usbd_function_dap_create(udevice_t device);
N
N#ifdef RT_USB_DEVICE_COMPOSITE
Nrt_err_t rt_usbd_function_set_iad(ufunction_t func, uiad_desc_t iad_desc);
N#endif
N
Nrt_err_t rt_usbd_set_feature(udevice_t device, rt_uint16_t value, rt_uint16_t index);
Nrt_err_t rt_usbd_clear_feature(udevice_t device, rt_uint16_t value, rt_uint16_t index);
Nrt_err_t rt_usbd_ep_set_stall(udevice_t device, uep_t ep);
Nrt_err_t rt_usbd_ep_clear_stall(udevice_t device, uep_t ep);
Nrt_err_t rt_usbd_ep0_set_stall(udevice_t device);
Nrt_err_t rt_usbd_ep0_clear_stall(udevice_t device);
Nrt_err_t rt_usbd_ep0_setup_handler(udcd_t dcd, struct urequest* setup);
Nrt_err_t rt_usbd_ep0_in_handler(udcd_t dcd);
Nrt_err_t rt_usbd_ep0_out_handler(udcd_t dcd, rt_size_t size);
Nrt_err_t rt_usbd_ep_in_handler(udcd_t dcd, rt_uint8_t address);
Nrt_err_t rt_usbd_ep_out_handler(udcd_t dcd, rt_uint8_t address, rt_size_t size);
Nrt_err_t rt_usbd_reset_handler(udcd_t dcd);
Nrt_err_t rt_usbd_connect_handler(udcd_t dcd);
Nrt_err_t rt_usbd_disconnect_handler(udcd_t dcd);
Nrt_err_t rt_usbd_sof_handler(udcd_t dcd);
N
Nrt_inline rt_err_t dcd_set_address(udcd_t dcd, rt_uint8_t address)
Xstatic __inline rt_err_t dcd_set_address(udcd_t dcd, rt_uint8_t address)
N{
N    RT_ASSERT(dcd != RT_NULL);
X    ;
N    RT_ASSERT(dcd->ops != RT_NULL);
X    ;
N    RT_ASSERT(dcd->ops->set_address != RT_NULL);
X    ;
N
N    return dcd->ops->set_address(address);
N}
N
Nrt_inline rt_err_t dcd_set_config(udcd_t dcd, rt_uint8_t address)
Xstatic __inline rt_err_t dcd_set_config(udcd_t dcd, rt_uint8_t address)
N{
N    RT_ASSERT(dcd != RT_NULL);
X    ;
N    RT_ASSERT(dcd->ops != RT_NULL);
X    ;
N    RT_ASSERT(dcd->ops->set_config != RT_NULL);
X    ;
N
N    return dcd->ops->set_config(address);
N}
N
Nrt_inline rt_err_t dcd_ep_enable(udcd_t dcd, uep_t ep)
Xstatic __inline rt_err_t dcd_ep_enable(udcd_t dcd, uep_t ep)
N{
N    RT_ASSERT(dcd != RT_NULL);
X    ;
N    RT_ASSERT(dcd->ops != RT_NULL);
X    ;
N    RT_ASSERT(dcd->ops->ep_enable != RT_NULL);
X    ;
N
N    return dcd->ops->ep_enable(ep);
N}
N
Nrt_inline rt_err_t dcd_ep_disable(udcd_t dcd, uep_t ep)
Xstatic __inline rt_err_t dcd_ep_disable(udcd_t dcd, uep_t ep)
N{
N    RT_ASSERT(dcd != RT_NULL);
X    ;
N    RT_ASSERT(dcd->ops != RT_NULL);
X    ;
N    RT_ASSERT(dcd->ops->ep_disable != RT_NULL);
X    ;
N
N    return dcd->ops->ep_disable(ep);
N}
N
Nrt_inline rt_size_t dcd_ep_read_prepare(udcd_t dcd, rt_uint8_t address, void *buffer,
Xstatic __inline rt_size_t dcd_ep_read_prepare(udcd_t dcd, rt_uint8_t address, void *buffer,
N                               rt_size_t size)
N{
N    RT_ASSERT(dcd != RT_NULL);
X    ;
N    RT_ASSERT(dcd->ops != RT_NULL);
X    ;
N
N    if(dcd->ops->ep_read_prepare != RT_NULL)
X    if(dcd->ops->ep_read_prepare != (0))
N    {
N        return dcd->ops->ep_read_prepare(address, buffer, size);
N    }
N    else
N    {
N        return 0;
N    }
N}
N
Nrt_inline rt_size_t dcd_ep_read(udcd_t dcd, rt_uint8_t address, void *buffer)
Xstatic __inline rt_size_t dcd_ep_read(udcd_t dcd, rt_uint8_t address, void *buffer)
N{
N    RT_ASSERT(dcd != RT_NULL);
X    ;
N    RT_ASSERT(dcd->ops != RT_NULL);
X    ;
N
N    if(dcd->ops->ep_read != RT_NULL)
X    if(dcd->ops->ep_read != (0))
N    {
N        return dcd->ops->ep_read(address, buffer);
N    }
N    else
N    {
N        return 0;
N    }
N}
N
Nrt_inline rt_size_t dcd_ep_write(udcd_t dcd, rt_uint8_t address, void *buffer,
Xstatic __inline rt_size_t dcd_ep_write(udcd_t dcd, rt_uint8_t address, void *buffer,
N                                 rt_size_t size)
N{
N    RT_ASSERT(dcd != RT_NULL);
X    ;
N    RT_ASSERT(dcd->ops != RT_NULL);
X    ;
N    RT_ASSERT(dcd->ops->ep_write != RT_NULL);
X    ;
N
N    return dcd->ops->ep_write(address, buffer, size);
N}
N
Nrt_inline rt_err_t dcd_ep0_send_status(udcd_t dcd)
Xstatic __inline rt_err_t dcd_ep0_send_status(udcd_t dcd)
N{
N    RT_ASSERT(dcd != RT_NULL);
X    ;
N    RT_ASSERT(dcd->ops != RT_NULL);
X    ;
N    RT_ASSERT(dcd->ops->ep0_send_status != RT_NULL);
X    ;
N
N    return dcd->ops->ep0_send_status();
N}
N
Nrt_inline rt_err_t dcd_ep_set_stall(udcd_t dcd, rt_uint8_t address)
Xstatic __inline rt_err_t dcd_ep_set_stall(udcd_t dcd, rt_uint8_t address)
N{    
N    RT_ASSERT(dcd != RT_NULL);
X    ;
N    RT_ASSERT(dcd->ops != RT_NULL);
X    ;
N    RT_ASSERT(dcd->ops->ep_set_stall != RT_NULL);
X    ;
N
N    return dcd->ops->ep_set_stall(address);
N}
N
Nrt_inline rt_err_t dcd_ep_clear_stall(udcd_t dcd, rt_uint8_t address)
Xstatic __inline rt_err_t dcd_ep_clear_stall(udcd_t dcd, rt_uint8_t address)
N{
N    RT_ASSERT(dcd != RT_NULL);
X    ;
N    RT_ASSERT(dcd->ops != RT_NULL);
X    ;
N    RT_ASSERT(dcd->ops->ep_clear_stall != RT_NULL);
X    ;
N
N    return dcd->ops->ep_clear_stall(address);
N}
N
N#endif
L 336 "..\..\components\drivers\include\rtdevice.h" 2
N#endif /* RT_USING_USB_DEVICE */
N
N#ifdef RT_USING_USB_HOST
N#include "drivers/usb_host.h"
L 1 "..\..\components\drivers\include\drivers/usb_host.h" 1
N/*
N * File      : usb_host.h
N * This file is part of RT-Thread RTOS
N * COPYRIGHT (C) 2011, RT-Thread Development Team
N *
N *  This program is free software; you can redistribute it and/or modify
N *  it under the terms of the GNU General Public License as published by
N *  the Free Software Foundation; either version 2 of the License, or
N *  (at your option) any later version.
N *
N *  This program is distributed in the hope that it will be useful,
N *  but WITHOUT ANY WARRANTY; without even the implied warranty of
N *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
N *  GNU General Public License for more details.
N *
N *  You should have received a copy of the GNU General Public License along
N *  with this program; if not, write to the Free Software Foundation, Inc.,
N *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
N *
N * Change Logs:
N * Date           Author       Notes
N * 2011-3-12     Yi Qiu      first version
N */
N
N#ifndef __RT_USB_HOST_H__
N#define __RT_USB_HOST_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N#include <rtthread.h>
N#include "usb_common.h"
N
N#define USB_MAX_DEVICE                  0x20
N#define USB_MAX_INTERFACE               0x08
N#define USB_HUB_PORT_NUM                0x04
N#define SIZEOF_USB_REQUEST              0x08
N
N#define DEV_STATUS_IDLE               0x00
N#define DEV_STATUS_BUSY               0x01
N#define DEV_STATUS_ERROR              0x02
N
N#define UPIPE_STATUS_OK                 0x00
N#define UPIPE_STATUS_STALL              0x01
N#define UPIPE_STATUS_ERROR              0x02
N
Nstruct uhcd;
Nstruct uintf;
Nstruct uhub;
N
Nstruct uclass_driver
N{
N    rt_list_t list;
N    int class_code;
N    int subclass_code;
N    
N    rt_err_t (*enable)(void* arg);
N    rt_err_t (*disable)(void* arg);
N    
N    void* user_data;
N};
Ntypedef struct uclass_driver* ucd_t;
N
Nstruct uprotocal
N{
N    rt_list_t list;
N    int pro_id;
N    
N    rt_err_t (*init)(void* arg);
N    rt_err_t (*callback)(void* arg);    
N};
Ntypedef struct uprotocal* uprotocal_t;
N
Nstruct uinstance
N{
N    struct udevice_descriptor dev_desc;
N    ucfg_desc_t cfg_desc;
N    struct uhcd *hcd;
N
N    rt_uint8_t status;
N    rt_uint8_t type;
N    rt_uint8_t index;
N    rt_uint8_t address;    
N    rt_uint8_t speed;
N    rt_uint8_t max_packet_size;    
N    rt_uint8_t port;
N
N    struct uhub* parent;
N    struct uintf* intf[USB_MAX_INTERFACE];        
X    struct uintf* intf[0x08];        
N};
Ntypedef struct uinstance* uinst_t;
N
Nstruct uintf
N{
N    struct uinstance* device;
N    uintf_desc_t intf_desc;
N
N    ucd_t drv;
N    void *user_data;
N};
N
Nstruct upipe
N{
N    rt_uint32_t status;
N    struct uendpoint_descriptor ep;
N    struct uintf* intf;
N    func_callback callback;
N    void* user_data;
N};
Ntypedef struct upipe* upipe_t;
N
Nstruct uhub
N{
N    struct uhub_descriptor hub_desc;
N    rt_uint8_t num_ports;
N    rt_uint32_t port_status[USB_HUB_PORT_NUM];
X    rt_uint32_t port_status[0x04];
N    struct uinstance* child[USB_HUB_PORT_NUM];        
X    struct uinstance* child[0x04];        
N
N    rt_bool_t is_roothub;
N    upipe_t pipe_in;
N    rt_uint8_t buffer[8];    
N    struct uinstance* self;
N    struct uhcd *hcd;
N};    
Ntypedef struct uhub* uhub_t;
N
Nstruct uhcd_ops
N{
N    int (*ctl_xfer)(struct uinstance* inst, ureq_t setup, void* buffer, int nbytes, 
N        int timeout);
N    int (*bulk_xfer)(upipe_t pipe, void* buffer, int nbytes, int timeout);
N    int (*int_xfer)(upipe_t pipe, void* buffer, int nbytes, int timeout);
N    int (*iso_xfer)(upipe_t pipe, void* buffer, int nbytes, int timeout);
N    
N    rt_err_t (*alloc_pipe)(struct upipe** pipe, struct uintf* intf, uep_desc_t ep, 
N        func_callback callback);
N    rt_err_t (*free_pipe)(upipe_t pipe);    
N    rt_err_t (*hub_ctrl)(rt_uint16_t port, rt_uint8_t cmd, void *args);    
N};
N
Nstruct uhcd
N{
N    struct rt_device parent;
N    struct uhcd_ops* ops;
N    struct uhub* roothub; 
N};
Ntypedef struct uhcd* uhcd_t;
N
Nenum uhost_msg_type
N{
N    USB_MSG_CONNECT_CHANGE,
N    USB_MSG_CALLBACK,
N};
Ntypedef enum uhost_msg_type uhost_msg_type;
N
Nstruct uhost_msg
N{
N    uhost_msg_type type; 
N    union
N    {
N        struct uhub* hub;
N        struct 
N        {
N            func_callback function;
N            void *context;
N        }cb;
N    }content;
N};
Ntypedef struct uhost_msg* uhost_msg_t;
N
N/* usb host system interface */
Nrt_err_t rt_usb_host_init(void);
Nvoid rt_usbh_hub_init(void);
N
N/* usb host core interface */
Nstruct uinstance* rt_usbh_alloc_instance(void);
Nrt_err_t rt_usbh_attatch_instance(struct uinstance* device);
Nrt_err_t rt_usbh_detach_instance(struct uinstance* device);
Nrt_err_t rt_usbh_get_descriptor(struct uinstance* device, rt_uint8_t type, void* buffer, 
N    int nbytes);
Nrt_err_t rt_usbh_set_configure(struct uinstance* device, int config);
Nrt_err_t rt_usbh_set_address(struct uinstance* device);
Nrt_err_t rt_usbh_set_interface(struct uinstance* device, int intf);
Nrt_err_t rt_usbh_clear_feature(struct uinstance* device, int endpoint, int feature);
Nrt_err_t rt_usbh_get_interface_descriptor(ucfg_desc_t cfg_desc, int num, 
N    uintf_desc_t* intf_desc);
Nrt_err_t rt_usbh_get_endpoint_descriptor(uintf_desc_t intf_desc, int num, 
N    uep_desc_t* ep_desc);
N
N/* usb class driver interface */
Nrt_err_t rt_usbh_class_driver_init(void);
Nrt_err_t rt_usbh_class_driver_register(ucd_t drv);
Nrt_err_t rt_usbh_class_driver_unregister(ucd_t drv);
Nrt_err_t rt_usbh_class_driver_enable(ucd_t drv, void* args);
Nrt_err_t rt_usbh_class_driver_disable(ucd_t drv, void* args);
Nucd_t rt_usbh_class_driver_find(int class_code, int subclass_code);
N
N/* usb class driver implement */
Nucd_t rt_usbh_class_driver_hid(void);
Nucd_t rt_usbh_class_driver_hub(void);
Nucd_t rt_usbh_class_driver_storage(void);
Nucd_t rt_usbh_class_driver_adk(void);
N
N/* usb hid protocal implement */
Nuprotocal_t rt_usbh_hid_protocal_kbd(void);
Nuprotocal_t rt_usbh_hid_protocal_mouse(void);
N
N/* usb adk class driver interface */
Nrt_err_t rt_usbh_adk_set_string(const char* manufacturer, const char* model,
N    const char* description, const char* version, const char* uri, 
N    const char* serial);
N
N/* usb hub interface */
Nrt_err_t rt_usbh_hub_get_descriptor(struct uinstance* device, rt_uint8_t *buffer, 
N    rt_size_t size);
Nrt_err_t rt_usbh_hub_get_status(struct uinstance* device, rt_uint8_t* buffer);
Nrt_err_t rt_usbh_hub_get_port_status(uhub_t uhub, rt_uint16_t port, 
N    rt_uint8_t* buffer);
Nrt_err_t rt_usbh_hub_clear_port_feature(uhub_t uhub, rt_uint16_t port, 
N    rt_uint16_t feature);
Nrt_err_t rt_usbh_hub_set_port_feature(uhub_t uhub, rt_uint16_t port, 
N    rt_uint16_t feature);
Nrt_err_t rt_usbh_hub_reset_port(uhub_t uhub, rt_uint16_t port);
Nrt_err_t rt_usbh_event_signal(struct uhost_msg* msg);
N
N/* usb host controller driver interface */
Nrt_inline rt_err_t rt_usb_hcd_alloc_pipe(uhcd_t hcd, upipe_t* pipe, 
Xstatic __inline rt_err_t rt_usb_hcd_alloc_pipe(uhcd_t hcd, upipe_t* pipe, 
N    struct uintf* intf, uep_desc_t ep, func_callback callback)
N{
N    if(intf == RT_NULL) return -RT_EIO;
X    if(intf == (0)) return -8;
N
N    return hcd->ops->alloc_pipe(pipe, intf, ep, callback);
N}
N
Nrt_inline rt_err_t rt_usb_hcd_free_pipe(uhcd_t hcd, upipe_t pipe)
Xstatic __inline rt_err_t rt_usb_hcd_free_pipe(uhcd_t hcd, upipe_t pipe)
N{
N    RT_ASSERT(pipe != RT_NULL);
X    ;
N    
N    return hcd->ops->free_pipe(pipe);
N}
N
Nrt_inline int rt_usb_hcd_bulk_xfer(uhcd_t hcd, upipe_t pipe, void* buffer, 
Xstatic __inline int rt_usb_hcd_bulk_xfer(uhcd_t hcd, upipe_t pipe, void* buffer, 
N    int nbytes, int timeout)
N{
N    if(pipe == RT_NULL) return -1;
X    if(pipe == (0)) return -1;
N    if(pipe->intf == RT_NULL) return -1;
X    if(pipe->intf == (0)) return -1;
N    if(pipe->intf->device == RT_NULL) return -1;    
X    if(pipe->intf->device == (0)) return -1;    
N    if(pipe->intf->device->status == DEV_STATUS_IDLE) 
X    if(pipe->intf->device->status == 0x00) 
N        return -1;
N
N    return hcd->ops->bulk_xfer(pipe, buffer, nbytes, timeout);
N}
N
Nrt_inline int rt_usb_hcd_control_xfer(uhcd_t hcd, struct uinstance* device, ureq_t setup, 
Xstatic __inline int rt_usb_hcd_control_xfer(uhcd_t hcd, struct uinstance* device, ureq_t setup, 
N    void* buffer, int nbytes, int timeout)
N{
N    if(device->status == DEV_STATUS_IDLE) return -1;
X    if(device->status == 0x00) return -1;
N
N    return hcd->ops->ctl_xfer(device, setup, buffer, nbytes, timeout);
N}
N
Nrt_inline int rt_usb_hcd_int_xfer(uhcd_t hcd, upipe_t pipe, void* buffer, 
Xstatic __inline int rt_usb_hcd_int_xfer(uhcd_t hcd, upipe_t pipe, void* buffer, 
N    int nbytes, int timeout)
N{    
N    if(pipe == RT_NULL) return -1;
X    if(pipe == (0)) return -1;
N    if(pipe->intf == RT_NULL) return -1;
X    if(pipe->intf == (0)) return -1;
N    if(pipe->intf->device == RT_NULL) return -1;    
X    if(pipe->intf->device == (0)) return -1;    
N    if(pipe->intf->device->status == DEV_STATUS_IDLE) 
X    if(pipe->intf->device->status == 0x00) 
N        return -1;
N
N    return hcd->ops->int_xfer(pipe, buffer, nbytes, timeout);
N}
N
Nrt_inline rt_err_t rt_usb_hcd_hub_control(uhcd_t hcd, rt_uint16_t port, 
Xstatic __inline rt_err_t rt_usb_hcd_hub_control(uhcd_t hcd, rt_uint16_t port, 
N    rt_uint8_t cmd, void *args)
N{    
N    return hcd->ops->hub_ctrl(port, cmd, args);
N}
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
N
L 340 "..\..\components\drivers\include\rtdevice.h" 2
N#endif /* RT_USING_USB_HOST */
N
N#ifdef RT_USING_SERIAL
N#include "drivers/serial.h"
L 1 "..\..\components\drivers\include\drivers/serial.h" 1
N/*
N * File      : serial.h
N * This file is part of RT-Thread RTOS
N * COPYRIGHT (C) 2006 - 2012, RT-Thread Development Team
N *
N *  This program is free software; you can redistribute it and/or modify
N *  it under the terms of the GNU General Public License as published by
N *  the Free Software Foundation; either version 2 of the License, or
N *  (at your option) any later version.
N *
N *  This program is distributed in the hope that it will be useful,
N *  but WITHOUT ANY WARRANTY; without even the implied warranty of
N *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
N *  GNU General Public License for more details.
N *
N *  You should have received a copy of the GNU General Public License along
N *  with this program; if not, write to the Free Software Foundation, Inc.,
N *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
N *
N * Change Logs:
N * Date           Author       Notes
N * 2012-05-15     lgnq         first version.
N * 2012-05-28     bernard      change interfaces
N * 2013-02-20     bernard      use RT_SERIAL_RB_BUFSZ to define
N *                             the size of ring buffer.
N */
N
N#ifndef __SERIAL_H__
N#define __SERIAL_H__
N
N#include <rtthread.h>
N
N#define BAUD_RATE_2400                  2400
N#define BAUD_RATE_4800                  4800
N#define BAUD_RATE_9600                  9600
N#define BAUD_RATE_19200                 19200
N#define BAUD_RATE_38400                 38400
N#define BAUD_RATE_57600                 57600
N#define BAUD_RATE_115200                115200
N#define BAUD_RATE_230400                230400
N#define BAUD_RATE_460800                460800
N#define BAUD_RATE_921600                921600
N#define BAUD_RATE_2000000               2000000
N#define BAUD_RATE_3000000               3000000
N
N#define DATA_BITS_5                     5
N#define DATA_BITS_6                     6
N#define DATA_BITS_7                     7
N#define DATA_BITS_8                     8
N#define DATA_BITS_9                     9
N
N#define STOP_BITS_1                     0
N#define STOP_BITS_2                     1
N#define STOP_BITS_3                     2
N#define STOP_BITS_4                     3
N
N#ifdef _WIN32
S#include <windows.h>
N#else
N#define PARITY_NONE                     0
N#define PARITY_ODD                      1
N#define PARITY_EVEN                     2
N#endif
N
N#define BIT_ORDER_LSB                   0
N#define BIT_ORDER_MSB                   1
N
N#define NRZ_NORMAL                      0       /* Non Return to Zero : normal mode */
N#define NRZ_INVERTED                    1       /* Non Return to Zero : inverted mode */
N
N#ifndef RT_SERIAL_RB_BUFSZ
N#define RT_SERIAL_RB_BUFSZ              64
N#endif
N
N#define RT_SERIAL_EVENT_RX_IND          0x01    /* Rx indication */
N#define RT_SERIAL_EVENT_TX_DONE         0x02    /* Tx complete   */
N#define RT_SERIAL_EVENT_RX_DMADONE      0x03    /* Rx DMA transfer done */
N#define RT_SERIAL_EVENT_TX_DMADONE      0x04    /* Tx DMA transfer done */
N#define RT_SERIAL_EVENT_RX_TIMEOUT      0x05    /* Rx timeout    */
N
N#define RT_SERIAL_DMA_RX                0x01
N#define RT_SERIAL_DMA_TX                0x02
N
N#define RT_SERIAL_RX_INT                0x01
N#define RT_SERIAL_TX_INT                0x02
N
N#define RT_SERIAL_ERR_OVERRUN           0x01
N#define RT_SERIAL_ERR_FRAMING           0x02
N#define RT_SERIAL_ERR_PARITY            0x03
N
N#define RT_SERIAL_TX_DATAQUEUE_SIZE     2048
N#define RT_SERIAL_TX_DATAQUEUE_LWM      30
N
N/* Default config for serial_configure structure */
N#define RT_SERIAL_CONFIG_DEFAULT           \
N{                                          \
N    BAUD_RATE_115200, /* 115200 bits/s */  \
N    DATA_BITS_8,      /* 8 databits */     \
N    STOP_BITS_1,      /* 1 stopbit */      \
N    PARITY_NONE,      /* No parity  */     \
N    BIT_ORDER_LSB,    /* LSB first sent */ \
N    NRZ_NORMAL,       /* Normal mode */    \
N    RT_SERIAL_RB_BUFSZ, /* Buffer size */  \
N    0                                      \
N}
X#define RT_SERIAL_CONFIG_DEFAULT           {                                              BAUD_RATE_115200,        DATA_BITS_8,                STOP_BITS_1,                 PARITY_NONE,                BIT_ORDER_LSB,          NRZ_NORMAL,                RT_SERIAL_RB_BUFSZ,        0                                      }
N
Nstruct serial_configure
N{
N    rt_uint32_t baud_rate;
N
N    rt_uint32_t data_bits               :4;
N    rt_uint32_t stop_bits               :2;
N    rt_uint32_t parity                  :2;
N    rt_uint32_t bit_order               :1;
N    rt_uint32_t invert                  :1;
N    rt_uint32_t bufsz                   :16;
N    rt_uint32_t reserved                :4;
N};
N
N/*
N * Serial FIFO mode 
N */
Nstruct rt_serial_rx_fifo
N{
N    /* software fifo */
N    rt_uint8_t *buffer;
N
N    rt_uint16_t put_index, get_index;
N
N    rt_bool_t is_full;
N};
N
Nstruct rt_serial_tx_fifo
N{
N    struct rt_completion completion;
N};
N
N/* 
N * Serial DMA mode
N */
Nstruct rt_serial_rx_dma
N{
N    rt_bool_t activated;
N};
N
Nstruct rt_serial_tx_dma
N{
N    rt_bool_t activated;
N    struct rt_data_queue data_queue;
N};
N
Nstruct rt_serial_device
N{
N    struct rt_device          parent;
N
N    const struct rt_uart_ops *ops;
N    struct serial_configure   config;
N
N    void *serial_rx;
N    void *serial_tx;
N};
Ntypedef struct rt_serial_device rt_serial_t;
N
N/**
N * uart operators
N */
Nstruct rt_uart_ops
N{
N    rt_err_t (*configure)(struct rt_serial_device *serial, struct serial_configure *cfg);
N    rt_err_t (*control)(struct rt_serial_device *serial, int cmd, void *arg);
N
N    int (*putc)(struct rt_serial_device *serial, char c);
N    int (*getc)(struct rt_serial_device *serial);
N
N    rt_size_t (*dma_transmit)(struct rt_serial_device *serial, rt_uint8_t *buf, rt_size_t size, int direction);
N};
N
Nvoid rt_hw_serial_isr(struct rt_serial_device *serial, int event);
N
Nrt_err_t rt_hw_serial_register(struct rt_serial_device *serial,
N                               const char              *name,
N                               rt_uint32_t              flag,
N                               void                    *data);
N
N#endif
L 344 "..\..\components\drivers\include\rtdevice.h" 2
N#endif /* RT_USING_SERIAL */
N
N#ifdef RT_USING_I2C
S#include "drivers/i2c.h"
S#include "drivers/i2c_dev.h"
S
S#ifdef RT_USING_I2C_BITOPS
S#include "drivers/i2c-bit-ops.h"
S#endif /* RT_USING_I2C_BITOPS */
N#endif /* RT_USING_I2C */
N
N#ifdef RT_USING_SDIO
S#include "drivers/mmcsd_core.h"
S#include "drivers/sd.h"
S#include "drivers/sdio.h"
N#endif
N
N#ifdef RT_USING_WDT
S#include "drivers/watchdog.h"
N#endif
N
N#ifdef RT_USING_PIN
S#include "drivers/pin.h"
N#endif
N
N#ifdef RT_USING_CAN
S#include "drivers/can.h"
N#endif
N
N#ifdef RT_USING_HWTIMER
S#include "drivers/hwtimer.h"
N#endif
N
N#ifdef RT_USING_AUDIO
S#include "drivers/audio.h"
N#endif
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif /* __RT_DEVICE_H__ */
N
L 28 "..\..\components\drivers\src\ringbuffer.c" 2
N#include <string.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060016
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 29 "..\..\components\drivers\src\ringbuffer.c" 2
N
Nvoid rt_ringbuffer_init(struct rt_ringbuffer *rb,
N                        rt_uint8_t           *pool,
N                        rt_int16_t            size)
N{
N    RT_ASSERT(rb != RT_NULL);
X    ;
N    RT_ASSERT(size > 0)
X    
N
N    /* initialize read and write index */
N    rb->read_mirror = rb->read_index = 0;
N    rb->write_mirror = rb->write_index = 0;
N
N    /* set buffer pool and size */
N    rb->buffer_ptr = pool;
N    rb->buffer_size = RT_ALIGN_DOWN(size, RT_ALIGN_SIZE);
X    rb->buffer_size = ((size) & ~((4) - 1));
N}
NRTM_EXPORT(rt_ringbuffer_init);
X;
N
N/**
N * put a block of data into ring buffer
N */
Nrt_size_t rt_ringbuffer_put(struct rt_ringbuffer *rb,
N                            const rt_uint8_t     *ptr,
N                            rt_uint16_t           length)
N{
N    rt_uint16_t size;
N
N    RT_ASSERT(rb != RT_NULL);
X    ;
N
N    /* whether has enough space */
N    size = rt_ringbuffer_space_len(rb);
X    size = ((rb)->buffer_size - rt_ringbuffer_data_len(rb));
N
N    /* no space */
N    if (size == 0)
N        return 0;
N
N    /* drop some data */
N    if (size < length)
N        length = size;
N
N    if (rb->buffer_size - rb->write_index > length)
N    {
N        /* read_index - write_index = empty space */
N        memcpy(&rb->buffer_ptr[rb->write_index], ptr, length);
N        /* this should not cause overflow because there is enough space for
N         * length of data in current mirror */
N        rb->write_index += length;
N        return length;
N    }
N
N    memcpy(&rb->buffer_ptr[rb->write_index],
N           &ptr[0],
N           rb->buffer_size - rb->write_index);
N    memcpy(&rb->buffer_ptr[0],
N           &ptr[rb->buffer_size - rb->write_index],
N           length - (rb->buffer_size - rb->write_index));
N
N    /* we are going into the other side of the mirror */
N    rb->write_mirror = ~rb->write_mirror;
N    rb->write_index = length - (rb->buffer_size - rb->write_index);
N
N    return length;
N}
NRTM_EXPORT(rt_ringbuffer_put);
X;
N
N/**
N * put a block of data into ring buffer
N *
N * When the buffer is full, it will discard the old data.
N */
Nrt_size_t rt_ringbuffer_put_force(struct rt_ringbuffer *rb,
N                            const rt_uint8_t     *ptr,
N                            rt_uint16_t           length)
N{
N    rt_uint16_t space_length;
N
N    RT_ASSERT(rb != RT_NULL);
X    ;
N
N    space_length = rt_ringbuffer_space_len(rb);
X    space_length = ((rb)->buffer_size - rt_ringbuffer_data_len(rb));
N
N    if (length > space_length)
N        length = rb->buffer_size;
N
N    if (rb->buffer_size - rb->write_index > length)
N    {
N        /* read_index - write_index = empty space */
N        memcpy(&rb->buffer_ptr[rb->write_index], ptr, length);
N        /* this should not cause overflow because there is enough space for
N         * length of data in current mirror */
N        rb->write_index += length;
N
N        if (length > space_length)
N            rb->read_index = rb->write_index;
N
N        return length;
N    }
N
N    memcpy(&rb->buffer_ptr[rb->write_index],
N           &ptr[0],
N           rb->buffer_size - rb->write_index);
N    memcpy(&rb->buffer_ptr[0],
N           &ptr[rb->buffer_size - rb->write_index],
N           length - (rb->buffer_size - rb->write_index));
N
N    /* we are going into the other side of the mirror */
N    rb->write_mirror = ~rb->write_mirror;
N    rb->write_index = length - (rb->buffer_size - rb->write_index);
N
N    if (length > space_length)
N    {
N        rb->read_mirror = ~rb->read_mirror;
N        rb->read_index = rb->write_index;
N    }
N
N    return length;
N}
NRTM_EXPORT(rt_ringbuffer_put_force);
X;
N
N/**
N *  get data from ring buffer
N */
Nrt_size_t rt_ringbuffer_get(struct rt_ringbuffer *rb,
N                            rt_uint8_t           *ptr,
N                            rt_uint16_t           length)
N{
N    rt_size_t size;
N
N    RT_ASSERT(rb != RT_NULL);
X    ;
N
N    /* whether has enough data  */
N    size = rt_ringbuffer_data_len(rb);
N
N    /* no data */
N    if (size == 0)
N        return 0;
N
N    /* less data */
N    if (size < length)
N        length = size;
N
N    if (rb->buffer_size - rb->read_index > length)
N    {
N        /* copy all of data */
N        memcpy(ptr, &rb->buffer_ptr[rb->read_index], length);
N        /* this should not cause overflow because there is enough space for
N         * length of data in current mirror */
N        rb->read_index += length;
N        return length;
N    }
N
N    memcpy(&ptr[0],
N           &rb->buffer_ptr[rb->read_index],
N           rb->buffer_size - rb->read_index);
N    memcpy(&ptr[rb->buffer_size - rb->read_index],
N           &rb->buffer_ptr[0],
N           length - (rb->buffer_size - rb->read_index));
N
N    /* we are going into the other side of the mirror */
N    rb->read_mirror = ~rb->read_mirror;
N    rb->read_index = length - (rb->buffer_size - rb->read_index);
N
N    return length;
N}
NRTM_EXPORT(rt_ringbuffer_get);
X;
N
N/**
N * put a character into ring buffer
N */
Nrt_size_t rt_ringbuffer_putchar(struct rt_ringbuffer *rb, const rt_uint8_t ch)
N{
N    RT_ASSERT(rb != RT_NULL);
X    ;
N
N    /* whether has enough space */
N    if (!rt_ringbuffer_space_len(rb))
X    if (!((rb)->buffer_size - rt_ringbuffer_data_len(rb)))
N        return 0;
N
N    rb->buffer_ptr[rb->write_index] = ch;
N
N    /* flip mirror */
N    if (rb->write_index == rb->buffer_size-1)
N    {
N        rb->write_mirror = ~rb->write_mirror;
N        rb->write_index = 0;
N    }
N    else
N    {
N        rb->write_index++;
N    }
N
N    return 1;
N}
NRTM_EXPORT(rt_ringbuffer_putchar);
X;
N
N/**
N * put a character into ring buffer
N *
N * When the buffer is full, it will discard one old data.
N */
Nrt_size_t rt_ringbuffer_putchar_force(struct rt_ringbuffer *rb, const rt_uint8_t ch)
N{
N    enum rt_ringbuffer_state old_state;
N
N    RT_ASSERT(rb != RT_NULL);
X    ;
N
N    old_state = rt_ringbuffer_status(rb);
N
N    rb->buffer_ptr[rb->write_index] = ch;
N
N    /* flip mirror */
N    if (rb->write_index == rb->buffer_size-1)
N    {
N        rb->write_mirror = ~rb->write_mirror;
N        rb->write_index = 0;
N        if (old_state == RT_RINGBUFFER_FULL)
N        {
N            rb->read_mirror = ~rb->read_mirror;
N            rb->read_index = rb->write_index;
N        }
N    }
N    else
N    {
N        rb->write_index++;
N        if (old_state == RT_RINGBUFFER_FULL)
N            rb->read_index = rb->write_index;
N    }
N
N    return 1;
N}
NRTM_EXPORT(rt_ringbuffer_putchar_force);
X;
N
N/**
N * get a character from a ringbuffer
N */
Nrt_size_t rt_ringbuffer_getchar(struct rt_ringbuffer *rb, rt_uint8_t *ch)
N{
N    RT_ASSERT(rb != RT_NULL);
X    ;
N
N    /* ringbuffer is empty */
N    if (!rt_ringbuffer_data_len(rb))
N        return 0;
N
N    /* put character */
N    *ch = rb->buffer_ptr[rb->read_index];
N
N    if (rb->read_index == rb->buffer_size-1)
N    {
N        rb->read_mirror = ~rb->read_mirror;
N        rb->read_index = 0;
N    }
N    else
N    {
N        rb->read_index++;
N    }
N
N    return 1;
N}
NRTM_EXPORT(rt_ringbuffer_getchar);
X;
N
