; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\thread.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\thread.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I.\Libraries\Device\Nuvoton -I..\..\components\finsh -I.\Libraries\CMSIS\Include -I.\Libraries\StdDriver\inc -I..\..\include -I.\APP -I.\Drivers -I..\..\components\drivers\include -I..\..\components\drivers\include\drivers -I..\nuvoton_nuc240 -I.\Libraries\Device\Nuvoton\NUC230_240\Include -I..\..\include -I..\..\components\drivers\usb\usbdevice\class -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=521 --omf_browse=.\objects\thread.crf ..\..\src\thread.c]
                          THUMB

                          AREA ||i._rt_thread_init||, CODE, READONLY, ALIGN=2

                  _rt_thread_init PROC
;;;131    
;;;132    static rt_err_t _rt_thread_init(struct rt_thread *thread,
000000  b5fe              PUSH     {r1-r7,lr}
;;;133                                    const char       *name,
;;;134                                    void (*entry)(void *parameter),
;;;135                                    void             *parameter,
;;;136                                    void             *stack_start,
;;;137                                    rt_uint32_t       stack_size,
;;;138                                    rt_uint8_t        priority,
;;;139                                    rt_uint32_t       tick)
;;;140    {
000002  4604              MOV      r4,r0
000004  a809              ADD      r0,sp,#0x24
000006  c8e0              LDM      r0!,{r5-r7}
000008  4619              MOV      r1,r3
;;;141        /* init thread list */
;;;142        rt_list_init(&(thread->tlist));
00000a  4620              MOV      r0,r4
00000c  3014              ADDS     r0,r0,#0x14
00000e  9b08              LDR      r3,[sp,#0x20]
000010  61a0              STR      r0,[r4,#0x18]
;;;143    
;;;144        thread->entry = (void *)entry;
000012  6222              STR      r2,[r4,#0x20]
000014  6160              STR      r0,[r4,#0x14]
000016  3010              ADDS     r0,r0,#0x10
000018  c02a              STM      r0!,{r1,r3,r5}
;;;145        thread->parameter = parameter;
;;;146    
;;;147        /* stack init */
;;;148        thread->stack_addr = stack_start;
;;;149        thread->stack_size = stack_size;
;;;150    
;;;151        /* init thread stack */
;;;152        rt_memset(thread->stack_addr, '#', thread->stack_size);
00001a  462a              MOV      r2,r5
00001c  4618              MOV      r0,r3
00001e  2123              MOVS     r1,#0x23
000020  f7fffffe          BL       rt_memset
;;;153        thread->sp = (void *)rt_hw_stack_init(thread->entry, thread->parameter,
000024  6ae1              LDR      r1,[r4,#0x2c]
000026  6aa0              LDR      r0,[r4,#0x28]
000028  4b0e              LDR      r3,|L1.100|
00002a  1842              ADDS     r2,r0,r1
00002c  1f12              SUBS     r2,r2,#4
00002e  6a61              LDR      r1,[r4,#0x24]
000030  6a20              LDR      r0,[r4,#0x20]
000032  f7fffffe          BL       rt_hw_stack_init
;;;154            (void *)((char *)thread->stack_addr + thread->stack_size - 4),
;;;155            (void *)rt_thread_exit);
;;;156    
;;;157        /* priority init */
;;;158        RT_ASSERT(priority < RT_THREAD_PRIORITY_MAX);
;;;159        thread->init_priority    = priority;
000036  4621              MOV      r1,r4
000038  61e0              STR      r0,[r4,#0x1c]
00003a  3120              ADDS     r1,r1,#0x20
00003c  758e              STRB     r6,[r1,#0x16]
;;;160        thread->current_priority = priority;
00003e  754e              STRB     r6,[r1,#0x15]
;;;161    
;;;162        /* tick init */
;;;163        thread->init_tick      = tick;
;;;164        thread->remaining_tick = tick;
000040  6467              STR      r7,[r4,#0x44]
;;;165    
;;;166        /* error and flags */
;;;167        thread->error = RT_EOK;
000042  2000              MOVS     r0,#0
;;;168        thread->stat  = RT_THREAD_INIT;
000044  64a7              STR      r7,[r4,#0x48]
000046  6320              STR      r0,[r4,#0x30]
000048  7508              STRB     r0,[r1,#0x14]
;;;169    
;;;170        /* initialize cleanup function and user data */
;;;171        thread->cleanup   = 0;
;;;172        thread->user_data = 0;
00004a  67a0              STR      r0,[r4,#0x78]
;;;173    
;;;174        /* init thread timer */
;;;175        rt_timer_init(&(thread->thread_timer),
00004c  67e0              STR      r0,[r4,#0x7c]
00004e  9000              STR      r0,[sp,#0]
000050  9001              STR      r0,[sp,#4]
000052  4623              MOV      r3,r4
000054  4620              MOV      r0,r4
000056  4a04              LDR      r2,|L1.104|
000058  4619              MOV      r1,r3
00005a  304c              ADDS     r0,r0,#0x4c
00005c  f7fffffe          BL       rt_timer_init
;;;176                      thread->name,
;;;177                      rt_thread_timeout,
;;;178                      thread,
;;;179                      0,
;;;180                      RT_TIMER_FLAG_ONE_SHOT);
;;;181    
;;;182        RT_OBJECT_HOOK_CALL(rt_thread_inited_hook,(thread));
;;;183    
;;;184        return RT_EOK;
000060  2000              MOVS     r0,#0
;;;185    }
000062  bdfe              POP      {r1-r7,pc}
;;;186    
                          ENDP

                  |L1.100|
                          DCD      rt_thread_exit
                  |L1.104|
                          DCD      rt_thread_timeout

                          AREA ||i.rt_list_insert_after||, CODE, READONLY, ALIGN=1

                  rt_list_insert_after PROC
;;;61      */
;;;62     rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
000000  6802              LDR      r2,[r0,#0]
;;;63     {
;;;64         l->next->prev = n;
;;;65         n->next = l->next;
000002  6051              STR      r1,[r2,#4]
000004  6802              LDR      r2,[r0,#0]
;;;66     
;;;67         l->next = n;
000006  600a              STR      r2,[r1,#0]
;;;68         n->prev = l;
000008  6001              STR      r1,[r0,#0]
00000a  6048              STR      r0,[r1,#4]
;;;69     }
00000c  4770              BX       lr
;;;70     
                          ENDP


                          AREA ||i.rt_list_remove||, CODE, READONLY, ALIGN=1

                  rt_list_remove PROC
;;;89      */
;;;90     rt_inline void rt_list_remove(rt_list_t *n)
000000  c806              LDM      r0!,{r1,r2}
;;;91     {
;;;92         n->next->prev = n->prev;
000002  3808              SUBS     r0,r0,#8
000004  604a              STR      r2,[r1,#4]
000006  c806              LDM      r0!,{r1,r2}
;;;93         n->prev->next = n->next;
000008  3808              SUBS     r0,r0,#8
;;;94     
;;;95         n->next = n->prev = n;
00000a  6011              STR      r1,[r2,#0]
00000c  6040              STR      r0,[r0,#4]
00000e  6000              STR      r0,[r0,#0]
;;;96     }
000010  4770              BX       lr
;;;97     
                          ENDP


                          AREA ||i.rt_thread_control||, CODE, READONLY, ALIGN=1

                  rt_thread_control PROC
;;;531     */
;;;532    rt_err_t rt_thread_control(rt_thread_t thread, rt_uint8_t cmd, void *arg)
000000  b5f8              PUSH     {r3-r7,lr}
;;;533    {
000002  4616              MOV      r6,r2
000004  4604              MOV      r4,r0
;;;534        register rt_base_t temp;
;;;535    
;;;536        /* thread check */
;;;537        RT_ASSERT(thread != RT_NULL);
;;;538    
;;;539        switch (cmd)
000006  2900              CMP      r1,#0
000008  d020              BEQ      |L4.76|
00000a  2901              CMP      r1,#1
00000c  d021              BEQ      |L4.82|
00000e  2902              CMP      r1,#2
000010  d10f              BNE      |L4.50|
;;;540        {
;;;541        case RT_THREAD_CTRL_CHANGE_PRIORITY:
;;;542            /* disable interrupt */
;;;543            temp = rt_hw_interrupt_disable();
000012  f7fffffe          BL       rt_hw_interrupt_disable
;;;544    
;;;545            /* for ready thread, change queue */
;;;546            if (thread->stat == RT_THREAD_READY)
000016  4625              MOV      r5,r4
000018  3520              ADDS     r5,r5,#0x20
00001a  9000              STR      r0,[sp,#0]
00001c  7d28              LDRB     r0,[r5,#0x14]
00001e  2701              MOVS     r7,#1                 ;533
000020  2801              CMP      r0,#1
000022  d008              BEQ      |L4.54|
;;;547            {
;;;548                /* remove thread from schedule queue first */
;;;549                rt_schedule_remove_thread(thread);
;;;550    
;;;551                /* change thread priority */
;;;552                thread->current_priority = *(rt_uint8_t *)arg;
;;;553    
;;;554                /* recalculate priority attribute */
;;;555    #if RT_THREAD_PRIORITY_MAX > 32
;;;556                thread->number      = thread->current_priority >> 3;            /* 5bit */
;;;557                thread->number_mask = 1 << thread->number;
;;;558                thread->high_mask   = 1 << (thread->current_priority & 0x07);   /* 3bit */
;;;559    #else
;;;560                thread->number_mask = 1 << thread->current_priority;
;;;561    #endif
;;;562    
;;;563                /* insert thread to schedule queue again */
;;;564                rt_schedule_insert_thread(thread);
;;;565            }
;;;566            else
;;;567            {
;;;568                thread->current_priority = *(rt_uint8_t *)arg;
000024  7830              LDRB     r0,[r6,#0]
000026  7568              STRB     r0,[r5,#0x15]
;;;569    
;;;570                /* recalculate priority attribute */
;;;571    #if RT_THREAD_PRIORITY_MAX > 32
;;;572                thread->number      = thread->current_priority >> 3;            /* 5bit */
;;;573                thread->number_mask = 1 << thread->number;
;;;574                thread->high_mask   = 1 << (thread->current_priority & 0x07);   /* 3bit */
;;;575    #else
;;;576                thread->number_mask = 1 << thread->current_priority;
000028  4087              LSLS     r7,r7,r0
00002a  63a7              STR      r7,[r4,#0x38]
                  |L4.44|
;;;577    #endif
;;;578            }
;;;579    
;;;580            /* enable interrupt */
;;;581            rt_hw_interrupt_enable(temp);
00002c  9800              LDR      r0,[sp,#0]
00002e  f7fffffe          BL       rt_hw_interrupt_enable
                  |L4.50|
;;;582            break;
;;;583    
;;;584        case RT_THREAD_CTRL_STARTUP:
;;;585            return rt_thread_startup(thread);
;;;586    
;;;587    #ifdef RT_USING_HEAP
;;;588        case RT_THREAD_CTRL_CLOSE:
;;;589            return rt_thread_delete(thread);
;;;590    #endif
;;;591    
;;;592        default:
;;;593            break;
;;;594        }
;;;595    
;;;596        return RT_EOK;
000032  2000              MOVS     r0,#0
;;;597    }
000034  bdf8              POP      {r3-r7,pc}
                  |L4.54|
000036  4620              MOV      r0,r4                 ;549
000038  f7fffffe          BL       rt_schedule_remove_thread
00003c  7830              LDRB     r0,[r6,#0]            ;552
00003e  7568              STRB     r0,[r5,#0x15]         ;552
000040  4087              LSLS     r7,r7,r0              ;560
000042  4620              MOV      r0,r4                 ;564
000044  63a7              STR      r7,[r4,#0x38]         ;564
000046  f7fffffe          BL       rt_schedule_insert_thread
00004a  e7ef              B        |L4.44|
                  |L4.76|
00004c  f7fffffe          BL       rt_thread_startup
000050  bdf8              POP      {r3-r7,pc}
                  |L4.82|
000052  f7fffffe          BL       rt_thread_delete
000056  bdf8              POP      {r3-r7,pc}
;;;598    RTM_EXPORT(rt_thread_control);
                          ENDP


                          AREA ||i.rt_thread_create||, CODE, READONLY, ALIGN=1

                  rt_thread_create PROC
;;;347     */
;;;348    rt_thread_t rt_thread_create(const char *name,
000000  b5ff              PUSH     {r0-r7,lr}
;;;349                                 void (*entry)(void *parameter),
;;;350                                 void       *parameter,
;;;351                                 rt_uint32_t stack_size,
;;;352                                 rt_uint8_t  priority,
;;;353                                 rt_uint32_t tick)
;;;354    {
000002  b085              SUB      sp,sp,#0x14
000004  461d              MOV      r5,r3
;;;355        struct rt_thread *thread;
;;;356        void *stack_start;
;;;357    
;;;358        thread = (struct rt_thread *)rt_object_allocate(RT_Object_Class_Thread,
000006  2000              MOVS     r0,#0
000008  9f0e              LDR      r7,[sp,#0x38]
00000a  9e0f              LDR      r6,[sp,#0x3c]
00000c  9905              LDR      r1,[sp,#0x14]
00000e  f7fffffe          BL       rt_object_allocate
000012  1e04              SUBS     r4,r0,#0
;;;359                                                        name);
;;;360        if (thread == RT_NULL)
000014  d00d              BEQ      |L5.50|
;;;361            return RT_NULL;
;;;362    
;;;363        stack_start = (void *)RT_KERNEL_MALLOC(stack_size);
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       rt_malloc
;;;364        if (stack_start == RT_NULL)
00001c  2800              CMP      r0,#0
00001e  d00a              BEQ      |L5.54|
;;;365        {
;;;366            /* allocate stack failure */
;;;367            rt_object_delete((rt_object_t)thread);
;;;368    
;;;369            return RT_NULL;
;;;370        }
;;;371    
;;;372        _rt_thread_init(thread,
000020  4669              MOV      r1,sp
000022  9603              STR      r6,[sp,#0xc]
000024  c1a1              STM      r1!,{r0,r5,r7}
000026  a905              ADD      r1,sp,#0x14
000028  c90e              LDM      r1,{r1-r3}
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       _rt_thread_init
;;;373                        name,
;;;374                        entry,
;;;375                        parameter,
;;;376                        stack_start,
;;;377                        stack_size,
;;;378                        priority,
;;;379                        tick);
;;;380    
;;;381        return thread;
000030  4620              MOV      r0,r4
                  |L5.50|
;;;382    }
000032  b009              ADD      sp,sp,#0x24
000034  bdf0              POP      {r4-r7,pc}
                  |L5.54|
000036  4620              MOV      r0,r4                 ;367
000038  f7fffffe          BL       rt_object_delete
00003c  2000              MOVS     r0,#0                 ;369
00003e  e7f8              B        |L5.50|
;;;383    RTM_EXPORT(rt_thread_create);
                          ENDP


                          AREA ||i.rt_thread_delay||, CODE, READONLY, ALIGN=1

                  rt_thread_delay PROC
;;;513     */
;;;514    rt_err_t rt_thread_delay(rt_tick_t tick)
000000  b510              PUSH     {r4,lr}
;;;515    {
;;;516        return rt_thread_sleep(tick);
000002  f7fffffe          BL       rt_thread_sleep
;;;517    }
000006  bd10              POP      {r4,pc}
;;;518    RTM_EXPORT(rt_thread_delay);
                          ENDP


                          AREA ||i.rt_thread_delete||, CODE, READONLY, ALIGN=2

                  rt_thread_delete PROC
;;;392     */
;;;393    rt_err_t rt_thread_delete(rt_thread_t thread)
000000  b570              PUSH     {r4-r6,lr}
;;;394    {
;;;395        rt_base_t lock;
;;;396    
;;;397        /* thread check */
;;;398        RT_ASSERT(thread != RT_NULL);
;;;399    
;;;400        if (thread->stat != RT_THREAD_INIT)
000002  4605              MOV      r5,r0
000004  4604              MOV      r4,r0                 ;394
000006  3520              ADDS     r5,r5,#0x20
000008  7d28              LDRB     r0,[r5,#0x14]
00000a  2800              CMP      r0,#0
00000c  d002              BEQ      |L7.20|
;;;401        {
;;;402            /* remove from schedule */
;;;403            rt_schedule_remove_thread(thread);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       rt_schedule_remove_thread
                  |L7.20|
;;;404        }
;;;405    
;;;406        /* release thread timer */
;;;407        rt_timer_detach(&(thread->thread_timer));
000014  4620              MOV      r0,r4
000016  304c              ADDS     r0,r0,#0x4c
000018  f7fffffe          BL       rt_timer_detach
;;;408    
;;;409        /* change stat */
;;;410        thread->stat = RT_THREAD_CLOSE;
00001c  2004              MOVS     r0,#4
00001e  7528              STRB     r0,[r5,#0x14]
;;;411    
;;;412        /* disable interrupt */
;;;413        lock = rt_hw_interrupt_disable();
000020  f7fffffe          BL       rt_hw_interrupt_disable
000024  4605              MOV      r5,r0
;;;414    
;;;415        /* insert to defunct thread list */
;;;416        rt_list_insert_after(&rt_thread_defunct, &(thread->tlist));
000026  4621              MOV      r1,r4
000028  3114              ADDS     r1,r1,#0x14
00002a  4804              LDR      r0,|L7.60|
00002c  f7fffffe          BL       rt_list_insert_after
;;;417    
;;;418        /* enable interrupt */
;;;419        rt_hw_interrupt_enable(lock);
000030  4628              MOV      r0,r5
000032  f7fffffe          BL       rt_hw_interrupt_enable
;;;420    
;;;421        return RT_EOK;
000036  2000              MOVS     r0,#0
;;;422    }
000038  bd70              POP      {r4-r6,pc}
;;;423    RTM_EXPORT(rt_thread_delete);
                          ENDP

00003a  0000              DCW      0x0000
                  |L7.60|
                          DCD      rt_thread_defunct

                          AREA ||i.rt_thread_detach||, CODE, READONLY, ALIGN=2

                  rt_thread_detach PROC
;;;294     */
;;;295    rt_err_t rt_thread_detach(rt_thread_t thread)
000000  b570              PUSH     {r4-r6,lr}
;;;296    {
;;;297        rt_base_t lock;
;;;298    
;;;299        /* thread check */
;;;300        RT_ASSERT(thread != RT_NULL);
;;;301    
;;;302        if (thread->stat != RT_THREAD_INIT)
000002  4605              MOV      r5,r0
000004  4604              MOV      r4,r0                 ;296
000006  3520              ADDS     r5,r5,#0x20
000008  7d28              LDRB     r0,[r5,#0x14]
00000a  2800              CMP      r0,#0
00000c  d002              BEQ      |L8.20|
;;;303        {
;;;304            /* remove from schedule */
;;;305            rt_schedule_remove_thread(thread);
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       rt_schedule_remove_thread
                  |L8.20|
;;;306        }
;;;307    
;;;308        /* release thread timer */
;;;309        rt_timer_detach(&(thread->thread_timer));
000014  4620              MOV      r0,r4
000016  304c              ADDS     r0,r0,#0x4c
000018  f7fffffe          BL       rt_timer_detach
;;;310    
;;;311        /* change stat */
;;;312        thread->stat = RT_THREAD_CLOSE;
00001c  2004              MOVS     r0,#4
00001e  7528              STRB     r0,[r5,#0x14]
;;;313    
;;;314        /* detach object */
;;;315        rt_object_detach((rt_object_t)thread);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       rt_object_detach
;;;316    
;;;317        if (thread->cleanup != RT_NULL)
000026  6fa0              LDR      r0,[r4,#0x78]
000028  2800              CMP      r0,#0
00002a  d00a              BEQ      |L8.66|
;;;318        {
;;;319            /* disable interrupt */
;;;320            lock = rt_hw_interrupt_disable();
00002c  f7fffffe          BL       rt_hw_interrupt_disable
000030  4605              MOV      r5,r0
;;;321    
;;;322            /* insert to defunct thread list */
;;;323            rt_list_insert_after(&rt_thread_defunct, &(thread->tlist));
000032  4621              MOV      r1,r4
000034  3114              ADDS     r1,r1,#0x14
000036  4804              LDR      r0,|L8.72|
000038  f7fffffe          BL       rt_list_insert_after
;;;324    
;;;325            /* enable interrupt */
;;;326            rt_hw_interrupt_enable(lock);
00003c  4628              MOV      r0,r5
00003e  f7fffffe          BL       rt_hw_interrupt_enable
                  |L8.66|
;;;327        }
;;;328    
;;;329        return RT_EOK;
000042  2000              MOVS     r0,#0
;;;330    }
000044  bd70              POP      {r4-r6,pc}
;;;331    RTM_EXPORT(rt_thread_detach);
                          ENDP

000046  0000              DCW      0x0000
                  |L8.72|
                          DCD      rt_thread_defunct

                          AREA ||i.rt_thread_exit||, CODE, READONLY, ALIGN=2

                  rt_thread_exit PROC
;;;94     
;;;95     void rt_thread_exit(void)
000000  b570              PUSH     {r4-r6,lr}
;;;96     {
;;;97         struct rt_thread *thread;
;;;98         register rt_base_t level;
;;;99     
;;;100        /* get current thread */
;;;101        thread = rt_current_thread;
000002  4813              LDR      r0,|L9.80|
;;;102    
;;;103        /* disable interrupt */
;;;104        level = rt_hw_interrupt_disable();
000004  6804              LDR      r4,[r0,#0]  ; rt_current_thread
000006  f7fffffe          BL       rt_hw_interrupt_disable
00000a  4605              MOV      r5,r0
;;;105    
;;;106        /* remove from schedule */
;;;107        rt_schedule_remove_thread(thread);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       rt_schedule_remove_thread
;;;108        /* change stat */
;;;109        thread->stat = RT_THREAD_CLOSE;
000012  2104              MOVS     r1,#4
000014  2034              MOVS     r0,#0x34
000016  5501              STRB     r1,[r0,r4]
;;;110    
;;;111        /* remove it from timer list */
;;;112        rt_timer_detach(&thread->thread_timer);
000018  4620              MOV      r0,r4
00001a  304c              ADDS     r0,r0,#0x4c
00001c  f7fffffe          BL       rt_timer_detach
;;;113    
;;;114        if ((rt_object_is_systemobject((rt_object_t)thread) == RT_TRUE) &&
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       rt_object_is_systemobject
000026  2801              CMP      r0,#1
000028  d102              BNE      |L9.48|
;;;115            thread->cleanup == RT_NULL)
00002a  6fa0              LDR      r0,[r4,#0x78]
00002c  2800              CMP      r0,#0
00002e  d00a              BEQ      |L9.70|
                  |L9.48|
;;;116        {
;;;117            rt_object_detach((rt_object_t)thread);
;;;118        }
;;;119        else
;;;120        {
;;;121            /* insert to defunct thread list */
;;;122            rt_list_insert_after(&rt_thread_defunct, &(thread->tlist));
000030  4621              MOV      r1,r4
000032  3114              ADDS     r1,r1,#0x14
000034  4807              LDR      r0,|L9.84|
000036  f7fffffe          BL       rt_list_insert_after
                  |L9.58|
;;;123        }
;;;124    
;;;125        /* enable interrupt */
;;;126        rt_hw_interrupt_enable(level);
00003a  4628              MOV      r0,r5
00003c  f7fffffe          BL       rt_hw_interrupt_enable
;;;127    
;;;128        /* switch to next task */
;;;129        rt_schedule();
000040  f7fffffe          BL       rt_schedule
;;;130    }
000044  bd70              POP      {r4-r6,pc}
                  |L9.70|
000046  4620              MOV      r0,r4                 ;117
000048  f7fffffe          BL       rt_object_detach
00004c  e7f5              B        |L9.58|
;;;131    
                          ENDP

00004e  0000              DCW      0x0000
                  |L9.80|
                          DCD      rt_current_thread
                  |L9.84|
                          DCD      rt_thread_defunct

                          AREA ||i.rt_thread_find||, CODE, READONLY, ALIGN=2

                  rt_thread_find PROC
;;;726     */
;;;727    rt_thread_t rt_thread_find(char *name)
000000  b5f1              PUSH     {r0,r4-r7,lr}
000002  4f12              LDR      r7,|L10.76|
;;;728    {
;;;729        struct rt_object_information *information;
;;;730        struct rt_object *object;
;;;731        struct rt_list_node *node;
;;;732    
;;;733        extern struct rt_object_information rt_object_container[];
;;;734    
;;;735        /* enter critical */
;;;736        if (rt_thread_self() != RT_NULL)
000004  6838              LDR      r0,[r7,#0]  ; rt_current_thread
000006  2800              CMP      r0,#0
000008  d001              BEQ      |L10.14|
;;;737            rt_enter_critical();
00000a  f7fffffe          BL       rt_enter_critical
                  |L10.14|
;;;738    
;;;739        /* try to find device object */
;;;740        information = &rt_object_container[RT_Object_Class_Thread];
00000e  4e10              LDR      r6,|L10.80|
;;;741        for (node  = information->object_list.next;
000010  6874              LDR      r4,[r6,#4]
000012  1d36              ADDS     r6,r6,#4
000014  e009              B        |L10.42|
                  |L10.22|
;;;742             node != &(information->object_list);
;;;743             node  = node->next)
;;;744        {
;;;745            object = rt_list_entry(node, struct rt_object, list);
000016  4625              MOV      r5,r4
000018  3d0c              SUBS     r5,r5,#0xc
;;;746            if (rt_strncmp(object->name, name, RT_NAME_MAX) == 0)
00001a  2208              MOVS     r2,#8
00001c  4628              MOV      r0,r5
00001e  9900              LDR      r1,[sp,#0]
000020  f7fffffe          BL       rt_strncmp
000024  2800              CMP      r0,#0
000026  d009              BEQ      |L10.60|
000028  6824              LDR      r4,[r4,#0]            ;743
                  |L10.42|
00002a  42b4              CMP      r4,r6                 ;742
00002c  d1f3              BNE      |L10.22|
;;;747            {
;;;748                /* leave critical */
;;;749                if (rt_thread_self() != RT_NULL)
;;;750                    rt_exit_critical();
;;;751    
;;;752                return (rt_thread_t)object;
;;;753            }
;;;754        }
;;;755    
;;;756        /* leave critical */
;;;757        if (rt_thread_self() != RT_NULL)
00002e  6838              LDR      r0,[r7,#0]  ; rt_current_thread
000030  2800              CMP      r0,#0
000032  d001              BEQ      |L10.56|
;;;758            rt_exit_critical();
000034  f7fffffe          BL       rt_exit_critical
                  |L10.56|
;;;759    
;;;760        /* not found */
;;;761        return RT_NULL;
000038  2000              MOVS     r0,#0
;;;762    }
00003a  bdf8              POP      {r3-r7,pc}
                  |L10.60|
00003c  6838              LDR      r0,[r7,#0]            ;749  ; rt_current_thread
00003e  2800              CMP      r0,#0                 ;749
000040  d001              BEQ      |L10.70|
000042  f7fffffe          BL       rt_exit_critical
                  |L10.70|
000046  4628              MOV      r0,r5                 ;752
000048  bdf8              POP      {r3-r7,pc}
;;;763    RTM_EXPORT(rt_thread_find);
                          ENDP

00004a  0000              DCW      0x0000
                  |L10.76|
                          DCD      rt_current_thread
                  |L10.80|
                          DCD      rt_object_container

                          AREA ||i.rt_thread_init||, CODE, READONLY, ALIGN=1

                  rt_thread_init PROC
;;;207     */
;;;208    rt_err_t rt_thread_init(struct rt_thread *thread,
000000  b5ff              PUSH     {r0-r7,lr}
;;;209                            const char       *name,
;;;210                            void (*entry)(void *parameter),
;;;211                            void             *parameter,
;;;212                            void             *stack_start,
;;;213                            rt_uint32_t       stack_size,
;;;214                            rt_uint8_t        priority,
;;;215                            rt_uint32_t       tick)
;;;216    {
000002  b085              SUB      sp,sp,#0x14
;;;217        /* thread check */
;;;218        RT_ASSERT(thread != RT_NULL);
;;;219        RT_ASSERT(stack_start != RT_NULL);
;;;220    
;;;221        /* init thread object */
;;;222        rt_object_init((rt_object_t)thread, RT_Object_Class_Thread, name);
000004  ac0f              ADD      r4,sp,#0x3c
000006  cc70              LDM      r4,{r4-r6}
000008  460f              MOV      r7,r1                 ;216
00000a  460a              MOV      r2,r1
00000c  2100              MOVS     r1,#0
00000e  9805              LDR      r0,[sp,#0x14]
000010  f7fffffe          BL       rt_object_init
;;;223    
;;;224        return _rt_thread_init(thread,
000014  980e              LDR      r0,[sp,#0x38]
000016  466a              MOV      r2,sp
000018  c271              STM      r2!,{r0,r4-r6}
00001a  4639              MOV      r1,r7
00001c  9b08              LDR      r3,[sp,#0x20]
00001e  9a07              LDR      r2,[sp,#0x1c]
000020  9805              LDR      r0,[sp,#0x14]
000022  f7fffffe          BL       _rt_thread_init
;;;225                               name,
;;;226                               entry,
;;;227                               parameter,
;;;228                               stack_start,
;;;229                               stack_size,
;;;230                               priority,
;;;231                               tick);
;;;232    }
000026  b009              ADD      sp,sp,#0x24
000028  bdf0              POP      {r4-r7,pc}
;;;233    RTM_EXPORT(rt_thread_init);
                          ENDP


                          AREA ||i.rt_thread_resume||, CODE, READONLY, ALIGN=1

                  rt_thread_resume PROC
;;;651     */
;;;652    rt_err_t rt_thread_resume(rt_thread_t thread)
000000  b570              PUSH     {r4-r6,lr}
;;;653    {
000002  4604              MOV      r4,r0
;;;654        register rt_base_t temp;
;;;655    
;;;656        /* thread check */
;;;657        RT_ASSERT(thread != RT_NULL);
;;;658    
;;;659        RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread resume:  %s\n", thread->name));
;;;660    
;;;661        if (thread->stat != RT_THREAD_SUSPEND)
000004  3020              ADDS     r0,r0,#0x20
000006  7d00              LDRB     r0,[r0,#0x14]
000008  2802              CMP      r0,#2
00000a  d002              BEQ      |L12.18|
;;;662        {
;;;663            RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread resume: thread disorder, %d\n",
;;;664                                           thread->stat));
;;;665    
;;;666            return -RT_ERROR;
00000c  2000              MOVS     r0,#0
00000e  43c0              MVNS     r0,r0
;;;667        }
;;;668    
;;;669        /* disable interrupt */
;;;670        temp = rt_hw_interrupt_disable();
;;;671    
;;;672        /* remove from suspend list */
;;;673        rt_list_remove(&(thread->tlist));
;;;674    
;;;675        rt_timer_stop(&thread->thread_timer);
;;;676    
;;;677        /* enable interrupt */
;;;678        rt_hw_interrupt_enable(temp);
;;;679    
;;;680        /* insert to schedule ready list */
;;;681        rt_schedule_insert_thread(thread);
;;;682    
;;;683        RT_OBJECT_HOOK_CALL(rt_thread_resume_hook,(thread));
;;;684        return RT_EOK;
;;;685    }
000010  bd70              POP      {r4-r6,pc}
                  |L12.18|
000012  f7fffffe          BL       rt_hw_interrupt_disable
000016  4605              MOV      r5,r0                 ;670
000018  4620              MOV      r0,r4                 ;673
00001a  3014              ADDS     r0,r0,#0x14           ;673
00001c  f7fffffe          BL       rt_list_remove
000020  4620              MOV      r0,r4                 ;675
000022  304c              ADDS     r0,r0,#0x4c           ;675
000024  f7fffffe          BL       rt_timer_stop
000028  4628              MOV      r0,r5                 ;678
00002a  f7fffffe          BL       rt_hw_interrupt_enable
00002e  4620              MOV      r0,r4                 ;681
000030  f7fffffe          BL       rt_schedule_insert_thread
000034  2000              MOVS     r0,#0                 ;684
000036  bd70              POP      {r4-r6,pc}
;;;686    RTM_EXPORT(rt_thread_resume);
                          ENDP


                          AREA ||i.rt_thread_self||, CODE, READONLY, ALIGN=2

                  rt_thread_self PROC
;;;239     */
;;;240    rt_thread_t rt_thread_self(void)
000000  4801              LDR      r0,|L13.8|
;;;241    {
;;;242        return rt_current_thread;
000002  6800              LDR      r0,[r0,#0]  ; rt_current_thread
;;;243    }
000004  4770              BX       lr
;;;244    RTM_EXPORT(rt_thread_self);
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      rt_current_thread

                          AREA ||i.rt_thread_sleep||, CODE, READONLY, ALIGN=2

                  rt_thread_sleep PROC
;;;476     */
;;;477    rt_err_t rt_thread_sleep(rt_tick_t tick)
000000  b5f1              PUSH     {r0,r4-r7,lr}
;;;478    {
;;;479        register rt_base_t temp;
;;;480        struct rt_thread *thread;
;;;481    
;;;482        /* disable interrupt */
;;;483        temp = rt_hw_interrupt_disable();
000002  f7fffffe          BL       rt_hw_interrupt_disable
000006  4605              MOV      r5,r0
;;;484        /* set to current thread */
;;;485        thread = rt_current_thread;
000008  480c              LDR      r0,|L14.60|
;;;486        RT_ASSERT(thread != RT_NULL);
;;;487    
;;;488        /* suspend thread */
;;;489        rt_thread_suspend(thread);
00000a  6804              LDR      r4,[r0,#0]  ; rt_current_thread
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       rt_thread_suspend
;;;490    
;;;491        /* reset the timeout of thread timer and start it */
;;;492        rt_timer_control(&(thread->thread_timer), RT_TIMER_CTRL_SET_TIME, &tick);
000012  4620              MOV      r0,r4
000014  304c              ADDS     r0,r0,#0x4c
000016  466a              MOV      r2,sp
000018  2100              MOVS     r1,#0
00001a  4606              MOV      r6,r0
00001c  f7fffffe          BL       rt_timer_control
000020  4630              MOV      r0,r6
;;;493        rt_timer_start(&(thread->thread_timer));
000022  f7fffffe          BL       rt_timer_start
;;;494    
;;;495        /* enable interrupt */
;;;496        rt_hw_interrupt_enable(temp);
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       rt_hw_interrupt_enable
;;;497    
;;;498        rt_schedule();
00002c  f7fffffe          BL       rt_schedule
;;;499    
;;;500        /* clear error number of this thread to RT_EOK */
;;;501        if (thread->error == -RT_ETIMEOUT)
000030  6b20              LDR      r0,[r4,#0x30]
000032  1c80              ADDS     r0,r0,#2
000034  d100              BNE      |L14.56|
;;;502            thread->error = RT_EOK;
000036  6320              STR      r0,[r4,#0x30]
                  |L14.56|
;;;503    
;;;504        return RT_EOK;
000038  2000              MOVS     r0,#0
;;;505    }
00003a  bdf8              POP      {r3-r7,pc}
;;;506    
                          ENDP

                  |L14.60|
                          DCD      rt_current_thread

                          AREA ||i.rt_thread_startup||, CODE, READONLY, ALIGN=2

                  rt_thread_startup PROC
;;;252     */
;;;253    rt_err_t rt_thread_startup(rt_thread_t thread)
000000  b510              PUSH     {r4,lr}
;;;254    {
;;;255        /* thread check */
;;;256        RT_ASSERT(thread != RT_NULL);
;;;257        RT_ASSERT(thread->stat == RT_THREAD_INIT);
;;;258    
;;;259        /* set current priority to init priority */
;;;260        thread->current_priority = thread->init_priority;
000002  4601              MOV      r1,r0
000004  3120              ADDS     r1,r1,#0x20
000006  7d8a              LDRB     r2,[r1,#0x16]
;;;261    
;;;262        /* calculate priority attribute */
;;;263    #if RT_THREAD_PRIORITY_MAX > 32
;;;264        thread->number      = thread->current_priority >> 3;            /* 5bit */
;;;265        thread->number_mask = 1L << thread->number;
;;;266        thread->high_mask   = 1L << (thread->current_priority & 0x07);  /* 3bit */
;;;267    #else
;;;268        thread->number_mask = 1L << thread->current_priority;
000008  2301              MOVS     r3,#1
00000a  754a              STRB     r2,[r1,#0x15]         ;260
00000c  4093              LSLS     r3,r3,r2
;;;269    #endif
;;;270    
;;;271        RT_DEBUG_LOG(RT_DEBUG_THREAD, ("startup a thread:%s with priority:%d\n",
;;;272                                       thread->name, thread->init_priority));
;;;273        /* change thread stat */
;;;274        thread->stat = RT_THREAD_SUSPEND;
00000e  2202              MOVS     r2,#2
000010  6383              STR      r3,[r0,#0x38]
000012  750a              STRB     r2,[r1,#0x14]
;;;275        /* then resume it */
;;;276        rt_thread_resume(thread);
000014  f7fffffe          BL       rt_thread_resume
000018  4803              LDR      r0,|L15.40|
00001a  6800              LDR      r0,[r0,#0]  ; rt_current_thread
;;;277        if (rt_thread_self() != RT_NULL)
00001c  2800              CMP      r0,#0
00001e  d001              BEQ      |L15.36|
;;;278        {
;;;279            /* do a scheduling */
;;;280            rt_schedule();
000020  f7fffffe          BL       rt_schedule
                  |L15.36|
;;;281        }
;;;282    
;;;283        return RT_EOK;
000024  2000              MOVS     r0,#0
;;;284    }
000026  bd10              POP      {r4,pc}
;;;285    RTM_EXPORT(rt_thread_startup);
                          ENDP

                  |L15.40|
                          DCD      rt_current_thread

                          AREA ||i.rt_thread_suspend||, CODE, READONLY, ALIGN=1

                  rt_thread_suspend PROC
;;;609     */
;;;610    rt_err_t rt_thread_suspend(rt_thread_t thread)
000000  b570              PUSH     {r4-r6,lr}
;;;611    {
;;;612        register rt_base_t temp;
;;;613    
;;;614        /* thread check */
;;;615        RT_ASSERT(thread != RT_NULL);
;;;616    
;;;617        RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread suspend:  %s\n", thread->name));
;;;618    
;;;619        if (thread->stat != RT_THREAD_READY)
000002  4604              MOV      r4,r0
000004  4605              MOV      r5,r0                 ;611
000006  3420              ADDS     r4,r4,#0x20
000008  7d20              LDRB     r0,[r4,#0x14]
00000a  2801              CMP      r0,#1
00000c  d002              BEQ      |L16.20|
;;;620        {
;;;621            RT_DEBUG_LOG(RT_DEBUG_THREAD, ("thread suspend: thread disorder, %d\n",
;;;622                                           thread->stat));
;;;623    
;;;624            return -RT_ERROR;
00000e  2000              MOVS     r0,#0
000010  43c0              MVNS     r0,r0
;;;625        }
;;;626    
;;;627        /* disable interrupt */
;;;628        temp = rt_hw_interrupt_disable();
;;;629    
;;;630        /* change thread stat */
;;;631        thread->stat = RT_THREAD_SUSPEND;
;;;632        rt_schedule_remove_thread(thread);
;;;633    
;;;634        /* stop thread timer anyway */
;;;635        rt_timer_stop(&(thread->thread_timer));
;;;636    
;;;637        /* enable interrupt */
;;;638        rt_hw_interrupt_enable(temp);
;;;639    
;;;640        RT_OBJECT_HOOK_CALL(rt_thread_suspend_hook,(thread));
;;;641        return RT_EOK;
;;;642    }
000012  bd70              POP      {r4-r6,pc}
                  |L16.20|
000014  f7fffffe          BL       rt_hw_interrupt_disable
000018  4606              MOV      r6,r0                 ;628
00001a  2002              MOVS     r0,#2                 ;631
00001c  7520              STRB     r0,[r4,#0x14]         ;631
00001e  4628              MOV      r0,r5                 ;632
000020  f7fffffe          BL       rt_schedule_remove_thread
000024  4628              MOV      r0,r5                 ;635
000026  304c              ADDS     r0,r0,#0x4c           ;635
000028  f7fffffe          BL       rt_timer_stop
00002c  4630              MOV      r0,r6                 ;638
00002e  f7fffffe          BL       rt_hw_interrupt_enable
000032  2000              MOVS     r0,#0                 ;641
000034  bd70              POP      {r4-r6,pc}
;;;643    RTM_EXPORT(rt_thread_suspend);
                          ENDP


                          AREA ||i.rt_thread_timeout||, CODE, READONLY, ALIGN=1

                  rt_thread_timeout PROC
;;;693     */
;;;694    void rt_thread_timeout(void *parameter)
000000  b510              PUSH     {r4,lr}
;;;695    {
000002  4604              MOV      r4,r0
;;;696        struct rt_thread *thread;
;;;697    
;;;698        thread = (struct rt_thread *)parameter;
;;;699    
;;;700        /* thread check */
;;;701        RT_ASSERT(thread != RT_NULL);
;;;702        RT_ASSERT(thread->stat == RT_THREAD_SUSPEND);
;;;703    
;;;704        /* set error number */
;;;705        thread->error = -RT_ETIMEOUT;
000004  2001              MOVS     r0,#1
000006  43c0              MVNS     r0,r0
;;;706    
;;;707        /* remove from suspend list */
;;;708        rt_list_remove(&(thread->tlist));
000008  6320              STR      r0,[r4,#0x30]
00000a  4620              MOV      r0,r4
00000c  3014              ADDS     r0,r0,#0x14
00000e  f7fffffe          BL       rt_list_remove
;;;709    
;;;710        /* insert to schedule ready list */
;;;711        rt_schedule_insert_thread(thread);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       rt_schedule_insert_thread
;;;712    
;;;713        /* do schedule */
;;;714        rt_schedule();
000018  f7fffffe          BL       rt_schedule
;;;715    }
00001c  bd10              POP      {r4,pc}
;;;716    RTM_EXPORT(rt_thread_timeout);
                          ENDP


                          AREA ||i.rt_thread_yield||, CODE, READONLY, ALIGN=2

                  rt_thread_yield PROC
;;;432     */
;;;433    rt_err_t rt_thread_yield(void)
000000  b570              PUSH     {r4-r6,lr}
;;;434    {
;;;435        register rt_base_t level;
;;;436        struct rt_thread *thread;
;;;437    
;;;438        /* disable interrupt */
;;;439        level = rt_hw_interrupt_disable();
000002  f7fffffe          BL       rt_hw_interrupt_disable
000006  4605              MOV      r5,r0
;;;440    
;;;441        /* set to current thread */
;;;442        thread = rt_current_thread;
000008  4812              LDR      r0,|L18.84|
00000a  6800              LDR      r0,[r0,#0]  ; rt_current_thread
;;;443    
;;;444        /* if the thread stat is READY and on ready queue list */
;;;445        if (thread->stat == RT_THREAD_READY &&
00000c  4601              MOV      r1,r0
00000e  3120              ADDS     r1,r1,#0x20
000010  460e              MOV      r6,r1
000012  7d09              LDRB     r1,[r1,#0x14]
000014  2901              CMP      r1,#1
000016  d117              BNE      |L18.72|
;;;446            thread->tlist.next != thread->tlist.prev)
000018  6982              LDR      r2,[r0,#0x18]
00001a  6941              LDR      r1,[r0,#0x14]
00001c  4291              CMP      r1,r2
00001e  d013              BEQ      |L18.72|
000020  3014              ADDS     r0,r0,#0x14
;;;447        {
;;;448            /* remove thread from thread list */
;;;449            rt_list_remove(&(thread->tlist));
000022  4604              MOV      r4,r0
000024  f7fffffe          BL       rt_list_remove
;;;450    
;;;451            /* put thread to end of ready queue */
;;;452            rt_list_insert_before(&(rt_thread_priority_table[thread->current_priority]),
000028  7d70              LDRB     r0,[r6,#0x15]
00002a  490b              LDR      r1,|L18.88|
00002c  00c0              LSLS     r0,r0,#3
00002e  1840              ADDS     r0,r0,r1
000030  6841              LDR      r1,[r0,#4]
000032  600c              STR      r4,[r1,#0]
000034  6841              LDR      r1,[r0,#4]
000036  6061              STR      r1,[r4,#4]
000038  6044              STR      r4,[r0,#4]
;;;453                                  &(thread->tlist));
;;;454    
;;;455            /* enable interrupt */
;;;456            rt_hw_interrupt_enable(level);
00003a  6020              STR      r0,[r4,#0]
00003c  4628              MOV      r0,r5
00003e  f7fffffe          BL       rt_hw_interrupt_enable
;;;457    
;;;458            rt_schedule();
000042  f7fffffe          BL       rt_schedule
;;;459    
;;;460            return RT_EOK;
000046  e002              B        |L18.78|
                  |L18.72|
;;;461        }
;;;462    
;;;463        /* enable interrupt */
;;;464        rt_hw_interrupt_enable(level);
000048  4628              MOV      r0,r5
00004a  f7fffffe          BL       rt_hw_interrupt_enable
                  |L18.78|
;;;465    
;;;466        return RT_EOK;
00004e  2000              MOVS     r0,#0
;;;467    }
000050  bd70              POP      {r4-r6,pc}
;;;468    RTM_EXPORT(rt_thread_yield);
                          ENDP

000052  0000              DCW      0x0000
                  |L18.84|
                          DCD      rt_current_thread
                  |L18.88|
                          DCD      rt_thread_priority_table
