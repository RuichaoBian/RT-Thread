; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\workqueue.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\workqueue.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I.\Libraries\Device\Nuvoton -I..\..\components\finsh -I.\Libraries\CMSIS\Include -I.\Libraries\StdDriver\inc -I..\..\include -I.\APP -I.\Drivers -I..\..\components\drivers\include -I..\..\components\drivers\include\drivers -I..\nuvoton_nuc240 -I.\Libraries\Device\Nuvoton\NUC230_240\Include -I..\..\include -I..\..\components\drivers\usb\usbdevice\class -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=521 --omf_browse=.\objects\workqueue.crf ..\..\components\drivers\src\workqueue.c]
                          THUMB

                          AREA ||i._workqueue_thread_entry||, CODE, READONLY, ALIGN=1

                  _workqueue_thread_entry PROC
;;;29     #ifdef RT_USING_HEAP
;;;30     static void _workqueue_thread_entry(void* parameter)
000000  4605              MOV      r5,r0
;;;31     {
000002  2600              MOVS     r6,#0
                  |L1.4|
000004  6828              LDR      r0,[r5,#0]
000006  42a8              CMP      r0,r5
000008  d105              BNE      |L1.22|
;;;32         rt_base_t level;
;;;33         struct rt_work* work;
;;;34         struct rt_workqueue* queue;
;;;35     
;;;36         queue = (struct rt_workqueue*) parameter;
;;;37         RT_ASSERT(queue != RT_NULL);
;;;38     
;;;39         while (1)
;;;40         {
;;;41             if (rt_list_isempty(&(queue->work_list)))
;;;42             {
;;;43                 /* no software timer exist, suspend self. */
;;;44                 rt_thread_suspend(rt_thread_self());
00000a  f7fffffe          BL       rt_thread_self
00000e  f7fffffe          BL       rt_thread_suspend
;;;45                 rt_schedule();
000012  f7fffffe          BL       rt_schedule
                  |L1.22|
;;;46             }
;;;47     
;;;48             /* we have work to do with. */
;;;49             level = rt_hw_interrupt_disable();
000016  f7fffffe          BL       rt_hw_interrupt_disable
;;;50             work = rt_list_entry(queue->work_list.next, struct rt_work, list);
;;;51             rt_list_remove(&(work->list));
00001a  682c              LDR      r4,[r5,#0]
00001c  4607              MOV      r7,r0                 ;49
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       rt_list_remove
;;;52             queue->work_current = work;
;;;53             rt_hw_interrupt_enable(level);
000024  4638              MOV      r0,r7
000026  60ac              STR      r4,[r5,#8]
000028  f7fffffe          BL       rt_hw_interrupt_enable
;;;54     
;;;55             /* do work */
;;;56             work->work_func(work, work->work_data);
00002c  68a2              LDR      r2,[r4,#8]
00002e  4620              MOV      r0,r4
000030  68e1              LDR      r1,[r4,#0xc]
000032  4790              BLX      r2
;;;57             level = rt_hw_interrupt_disable();
000034  f7fffffe          BL       rt_hw_interrupt_disable
;;;58             /* clean current work */
;;;59             queue->work_current = RT_NULL;
;;;60             rt_hw_interrupt_enable(level);
000038  60ae              STR      r6,[r5,#8]
00003a  f7fffffe          BL       rt_hw_interrupt_enable
00003e  e7e1              B        |L1.4|
;;;61         }
;;;62     }
;;;63     
                          ENDP


                          AREA ||i.rt_list_insert_after||, CODE, READONLY, ALIGN=1

                  rt_list_insert_after PROC
;;;61      */
;;;62     rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
000000  6802              LDR      r2,[r0,#0]
;;;63     {
;;;64         l->next->prev = n;
;;;65         n->next = l->next;
000002  6051              STR      r1,[r2,#4]
000004  6802              LDR      r2,[r0,#0]
;;;66     
;;;67         l->next = n;
000006  600a              STR      r2,[r1,#0]
;;;68         n->prev = l;
000008  6001              STR      r1,[r0,#0]
00000a  6048              STR      r0,[r1,#4]
;;;69     }
00000c  4770              BX       lr
;;;70     
                          ENDP


                          AREA ||i.rt_list_remove||, CODE, READONLY, ALIGN=1

                  rt_list_remove PROC
;;;89      */
;;;90     rt_inline void rt_list_remove(rt_list_t *n)
000000  c806              LDM      r0!,{r1,r2}
;;;91     {
;;;92         n->next->prev = n->prev;
000002  3808              SUBS     r0,r0,#8
000004  604a              STR      r2,[r1,#4]
000006  c806              LDM      r0!,{r1,r2}
;;;93         n->prev->next = n->next;
000008  3808              SUBS     r0,r0,#8
;;;94     
;;;95         n->next = n->prev = n;
00000a  6011              STR      r1,[r2,#0]
00000c  6040              STR      r0,[r0,#4]
00000e  6000              STR      r0,[r0,#0]
;;;96     }
000010  4770              BX       lr
;;;97     
                          ENDP


                          AREA ||i.rt_workqueue_cancel_all_work||, CODE, READONLY, ALIGN=1

                  rt_workqueue_cancel_all_work PROC
;;;176    
;;;177    rt_err_t rt_workqueue_cancel_all_work(struct rt_workqueue* queue)
000000  b570              PUSH     {r4-r6,lr}
;;;178    {
000002  4605              MOV      r5,r0
;;;179        struct rt_list_node *node, *next;
;;;180        RT_ASSERT(queue != RT_NULL);
;;;181    
;;;182        rt_enter_critical();
000004  f7fffffe          BL       rt_enter_critical
;;;183        for (node = queue->work_list.next; node != &(queue->work_list); node = next)
000008  6828              LDR      r0,[r5,#0]
00000a  e003              B        |L4.20|
                  |L4.12|
;;;184        {
;;;185            next = node->next;
;;;186            rt_list_remove(node);
00000c  6804              LDR      r4,[r0,#0]
00000e  f7fffffe          BL       rt_list_remove
000012  4620              MOV      r0,r4                 ;183
                  |L4.20|
000014  42a8              CMP      r0,r5                 ;183
000016  d1f9              BNE      |L4.12|
;;;187        }
;;;188        rt_exit_critical();
000018  f7fffffe          BL       rt_exit_critical
;;;189    
;;;190        return RT_EOK;
00001c  2000              MOVS     r0,#0
;;;191    }
00001e  bd70              POP      {r4-r6,pc}
;;;192    
                          ENDP


                          AREA ||i.rt_workqueue_cancel_work||, CODE, READONLY, ALIGN=1

                  rt_workqueue_cancel_work PROC
;;;157    
;;;158    rt_err_t rt_workqueue_cancel_work(struct rt_workqueue* queue, struct rt_work* work)
000000  b570              PUSH     {r4-r6,lr}
;;;159    {
000002  460e              MOV      r6,r1
000004  4605              MOV      r5,r0
;;;160        rt_base_t level;
;;;161    
;;;162        RT_ASSERT(queue != RT_NULL);
;;;163        RT_ASSERT(work != RT_NULL);
;;;164    
;;;165        level = rt_hw_interrupt_disable();
000006  f7fffffe          BL       rt_hw_interrupt_disable
00000a  4604              MOV      r4,r0
;;;166        if (queue->work_current == work)
00000c  68a8              LDR      r0,[r5,#8]
00000e  42b0              CMP      r0,r6
000010  d105              BNE      |L5.30|
;;;167        {
;;;168            rt_hw_interrupt_enable(level);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       rt_hw_interrupt_enable
;;;169            return -RT_EBUSY;
000018  2006              MOVS     r0,#6
00001a  43c0              MVNS     r0,r0
;;;170        }
;;;171        rt_list_remove(&(work->list));
;;;172        rt_hw_interrupt_enable(level);
;;;173    
;;;174        return RT_EOK;
;;;175    }
00001c  bd70              POP      {r4-r6,pc}
                  |L5.30|
00001e  4630              MOV      r0,r6                 ;171
000020  f7fffffe          BL       rt_list_remove
000024  4620              MOV      r0,r4                 ;172
000026  f7fffffe          BL       rt_hw_interrupt_enable
00002a  2000              MOVS     r0,#0                 ;174
00002c  bd70              POP      {r4-r6,pc}
;;;176    
                          ENDP


                          AREA ||i.rt_workqueue_create||, CODE, READONLY, ALIGN=2

                  rt_workqueue_create PROC
;;;63     
;;;64     struct rt_workqueue *rt_workqueue_create(const char* name, rt_uint16_t stack_size, rt_uint8_t priority)
000000  b5fe              PUSH     {r1-r7,lr}
;;;65     {
000002  4607              MOV      r7,r0
000004  4615              MOV      r5,r2
000006  460e              MOV      r6,r1
;;;66         struct rt_workqueue *queue = RT_NULL;
;;;67     
;;;68         queue = (struct rt_workqueue*)RT_KERNEL_MALLOC(sizeof(struct rt_workqueue));
000008  2010              MOVS     r0,#0x10
00000a  f7fffffe          BL       rt_malloc
00000e  0004              MOVS     r4,r0
;;;69         if (queue != RT_NULL)
000010  d011              BEQ      |L6.54|
000012  6064              STR      r4,[r4,#4]
000014  6024              STR      r4,[r4,#0]
;;;70         {
;;;71             /* initialize work list */
;;;72             rt_list_init(&(queue->work_list));
;;;73             queue->work_current = RT_NULL;
000016  2000              MOVS     r0,#0
;;;74     
;;;75             /* create the work thread */
;;;76             queue->work_thread = rt_thread_create(name, _workqueue_thread_entry, queue, stack_size, priority, 10);
000018  60a0              STR      r0,[r4,#8]
00001a  200a              MOVS     r0,#0xa
00001c  9001              STR      r0,[sp,#4]
00001e  4633              MOV      r3,r6
000020  4622              MOV      r2,r4
000022  4908              LDR      r1,|L6.68|
000024  9500              STR      r5,[sp,#0]
000026  4638              MOV      r0,r7
000028  f7fffffe          BL       rt_thread_create
;;;77             if (queue->work_thread == RT_NULL)
00002c  60e0              STR      r0,[r4,#0xc]
00002e  2800              CMP      r0,#0
000030  d003              BEQ      |L6.58|
;;;78             {
;;;79                 RT_KERNEL_FREE(queue);
;;;80                 return RT_NULL;
;;;81             }
;;;82     
;;;83             rt_thread_startup(queue->work_thread);
000032  f7fffffe          BL       rt_thread_startup
                  |L6.54|
;;;84         }
;;;85     
;;;86         return queue;
000036  4620              MOV      r0,r4
;;;87     }
000038  bdfe              POP      {r1-r7,pc}
                  |L6.58|
00003a  4620              MOV      r0,r4                 ;79
00003c  f7fffffe          BL       rt_free
000040  2000              MOVS     r0,#0                 ;80
000042  bdfe              POP      {r1-r7,pc}
;;;88     
                          ENDP

                  |L6.68|
                          DCD      _workqueue_thread_entry

                          AREA ||i.rt_workqueue_critical_work||, CODE, READONLY, ALIGN=1

                  rt_workqueue_critical_work PROC
;;;128    
;;;129    rt_err_t rt_workqueue_critical_work(struct rt_workqueue* queue, struct rt_work* work)
000000  b570              PUSH     {r4-r6,lr}
;;;130    {
000002  460e              MOV      r6,r1
000004  4604              MOV      r4,r0
;;;131        rt_base_t level;
;;;132        RT_ASSERT(queue != RT_NULL);
;;;133        RT_ASSERT(work != RT_NULL);
;;;134    
;;;135        level = rt_hw_interrupt_disable();
000006  f7fffffe          BL       rt_hw_interrupt_disable
00000a  4605              MOV      r5,r0
;;;136        if (queue->work_current == work)
00000c  68a0              LDR      r0,[r4,#8]
00000e  42b0              CMP      r0,r6
000010  d105              BNE      |L7.30|
;;;137        {
;;;138            rt_hw_interrupt_enable(level);
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       rt_hw_interrupt_enable
;;;139            return -RT_EBUSY;
000018  2006              MOVS     r0,#6
00001a  43c0              MVNS     r0,r0
;;;140        }
;;;141    
;;;142        /* NOTE: the work MUST be initialized firstly */
;;;143        rt_list_remove(&(work->list));
;;;144    
;;;145        rt_list_insert_after(queue->work_list.prev, &(work->list));
;;;146        if (queue->work_current == RT_NULL)
;;;147        {
;;;148            rt_hw_interrupt_enable(level);
;;;149            /* resume work thread */
;;;150            rt_thread_resume(queue->work_thread);
;;;151            rt_schedule();
;;;152        }
;;;153        else rt_hw_interrupt_enable(level);
;;;154    
;;;155        return RT_EOK;
;;;156    }
00001c  bd70              POP      {r4-r6,pc}
                  |L7.30|
00001e  4630              MOV      r0,r6                 ;143
000020  f7fffffe          BL       rt_list_remove
000024  4631              MOV      r1,r6                 ;145
000026  6860              LDR      r0,[r4,#4]            ;145
000028  f7fffffe          BL       rt_list_insert_after
00002c  68a0              LDR      r0,[r4,#8]            ;146
00002e  2800              CMP      r0,#0                 ;146
000030  4628              MOV      r0,r5                 ;153
000032  d003              BEQ      |L7.60|
000034  f7fffffe          BL       rt_hw_interrupt_enable
                  |L7.56|
000038  2000              MOVS     r0,#0                 ;155
00003a  bd70              POP      {r4-r6,pc}
                  |L7.60|
00003c  f7fffffe          BL       rt_hw_interrupt_enable
000040  68e0              LDR      r0,[r4,#0xc]          ;150
000042  f7fffffe          BL       rt_thread_resume
000046  f7fffffe          BL       rt_schedule
00004a  e7f5              B        |L7.56|
;;;157    
                          ENDP


                          AREA ||i.rt_workqueue_destroy||, CODE, READONLY, ALIGN=1

                  rt_workqueue_destroy PROC
;;;88     
;;;89     rt_err_t rt_workqueue_destroy(struct rt_workqueue* queue)
000000  b510              PUSH     {r4,lr}
;;;90     {
000002  4604              MOV      r4,r0
;;;91         RT_ASSERT(queue != RT_NULL);
;;;92     
;;;93         rt_thread_delete(queue->work_thread);
000004  68c0              LDR      r0,[r0,#0xc]
000006  f7fffffe          BL       rt_thread_delete
;;;94         RT_KERNEL_FREE(queue);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       rt_free
;;;95     
;;;96         return RT_EOK;
000010  2000              MOVS     r0,#0
;;;97     }
000012  bd10              POP      {r4,pc}
;;;98     
                          ENDP


                          AREA ||i.rt_workqueue_dowork||, CODE, READONLY, ALIGN=1

                  rt_workqueue_dowork PROC
;;;98     
;;;99     rt_err_t rt_workqueue_dowork(struct rt_workqueue* queue, struct rt_work* work)
000000  b570              PUSH     {r4-r6,lr}
;;;100    {
000002  460e              MOV      r6,r1
000004  4604              MOV      r4,r0
;;;101        rt_base_t level;
;;;102        RT_ASSERT(queue != RT_NULL);
;;;103        RT_ASSERT(work != RT_NULL);
;;;104    
;;;105        level = rt_hw_interrupt_disable();
000006  f7fffffe          BL       rt_hw_interrupt_disable
00000a  4605              MOV      r5,r0
;;;106        if (queue->work_current == work)
00000c  68a0              LDR      r0,[r4,#8]
00000e  42b0              CMP      r0,r6
000010  d105              BNE      |L9.30|
;;;107        {
;;;108            rt_hw_interrupt_enable(level);
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       rt_hw_interrupt_enable
;;;109            return -RT_EBUSY;
000018  2006              MOVS     r0,#6
00001a  43c0              MVNS     r0,r0
;;;110        }
;;;111    
;;;112        /* NOTE: the work MUST be initialized firstly */
;;;113        rt_list_remove(&(work->list));
;;;114    
;;;115        rt_list_insert_after(queue->work_list.prev, &(work->list));
;;;116        /* whether the workqueue is doing work */
;;;117        if (queue->work_current == RT_NULL)
;;;118        {
;;;119            rt_hw_interrupt_enable(level);
;;;120            /* resume work thread */
;;;121            rt_thread_resume(queue->work_thread);
;;;122            rt_schedule();
;;;123        }
;;;124        else rt_hw_interrupt_enable(level);
;;;125    
;;;126        return RT_EOK;
;;;127    }
00001c  bd70              POP      {r4-r6,pc}
                  |L9.30|
00001e  4630              MOV      r0,r6                 ;113
000020  f7fffffe          BL       rt_list_remove
000024  4631              MOV      r1,r6                 ;115
000026  6860              LDR      r0,[r4,#4]            ;115
000028  f7fffffe          BL       rt_list_insert_after
00002c  68a0              LDR      r0,[r4,#8]            ;117
00002e  2800              CMP      r0,#0                 ;117
000030  4628              MOV      r0,r5                 ;124
000032  d003              BEQ      |L9.60|
000034  f7fffffe          BL       rt_hw_interrupt_enable
                  |L9.56|
000038  2000              MOVS     r0,#0                 ;126
00003a  bd70              POP      {r4-r6,pc}
                  |L9.60|
00003c  f7fffffe          BL       rt_hw_interrupt_enable
000040  68e0              LDR      r0,[r4,#0xc]          ;121
000042  f7fffffe          BL       rt_thread_resume
000046  f7fffffe          BL       rt_schedule
00004a  e7f5              B        |L9.56|
;;;128    
                          ENDP

