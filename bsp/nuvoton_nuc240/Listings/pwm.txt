; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\pwm.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\pwm.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I.\Libraries\Device\Nuvoton -I..\..\components\finsh -I.\Libraries\CMSIS\Include -I.\Libraries\StdDriver\inc -I..\..\include -I.\APP -I.\Drivers -I..\..\components\drivers\include -I..\..\components\drivers\include\drivers -I..\nuvoton_nuc240 -I.\Libraries\Device\Nuvoton\NUC230_240\Include -I..\..\include -I..\..\components\drivers\usb\usbdevice\class -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=521 --omf_browse=.\objects\pwm.crf Libraries\StdDriver\src\pwm.c]
                          THUMB

                          AREA ||i.PWM_ClearADCTriggerFlag||, CODE, READONLY, ALIGN=1

                  PWM_ClearADCTriggerFlag PROC
;;;320     */
;;;321    void PWM_ClearADCTriggerFlag(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition)
000000  2201              MOVS     r2,#1
;;;322    {
;;;323        (pwm)->TSTATUS = (PWM_TSTATUS_PWM0TF_Msk << u32ChannelNum);
000002  408a              LSLS     r2,r2,r1
000004  3080              ADDS     r0,r0,#0x80
000006  6042              STR      r2,[r0,#4]
;;;324    }
000008  4770              BX       lr
;;;325    
                          ENDP


                          AREA ||i.PWM_ClearCaptureIntFlag||, CODE, READONLY, ALIGN=2

                  PWM_ClearCaptureIntFlag PROC
;;;520     */
;;;521    void PWM_ClearCaptureIntFlag(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge)
000000  b530              PUSH     {r4,r5,lr}
;;;522    {
;;;523        //clear capture interrupt flag, and clear CRLR or CFLR latched indicator
;;;524        if(u32ChannelNum < 2)
;;;525            (pwm)->CCR0 = ((pwm)->CCR0 & PWM_CCR_MASK) | (PWM_CCR0_CAPIF0_Msk << (u32ChannelNum * 16)) | (u32Edge << (u32ChannelNum * 16 + 5));
000002  4d0c              LDR      r5,|L2.52|
000004  2410              MOVS     r4,#0x10
000006  010b              LSLS     r3,r1,#4
000008  2902              CMP      r1,#2                 ;524
00000a  d208              BCS      |L2.30|
00000c  6d01              LDR      r1,[r0,#0x50]
00000e  409c              LSLS     r4,r4,r3
000010  4029              ANDS     r1,r1,r5
000012  1d5b              ADDS     r3,r3,#5
000014  4321              ORRS     r1,r1,r4
000016  409a              LSLS     r2,r2,r3
000018  4311              ORRS     r1,r1,r2
00001a  6501              STR      r1,[r0,#0x50]
;;;526        else
;;;527            (pwm)->CCR2 = ((pwm)->CCR2 & PWM_CCR_MASK) | (PWM_CCR2_CAPIF2_Msk << ((u32ChannelNum - 2) * 16)) | (u32Edge << ((u32ChannelNum - 2) * 16 + 5));
;;;528    }
00001c  bd30              POP      {r4,r5,pc}
                  |L2.30|
00001e  4619              MOV      r1,r3                 ;527
000020  3920              SUBS     r1,r1,#0x20           ;527
000022  408c              LSLS     r4,r4,r1              ;527
000024  6d41              LDR      r1,[r0,#0x54]         ;527
000026  3b1b              SUBS     r3,r3,#0x1b           ;527
000028  4029              ANDS     r1,r1,r5              ;527
00002a  430c              ORRS     r4,r4,r1              ;527
00002c  409a              LSLS     r2,r2,r3              ;527
00002e  4314              ORRS     r4,r4,r2              ;527
000030  6544              STR      r4,[r0,#0x54]         ;527
000032  bd30              POP      {r4,r5,pc}
;;;529    
                          ENDP

                  |L2.52|
                          DCD      0x000f000f

                          AREA ||i.PWM_ClearDutyIntFlag||, CODE, READONLY, ALIGN=1

                  PWM_ClearDutyIntFlag PROC
;;;590     */
;;;591    void PWM_ClearDutyIntFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  22ff              MOVS     r2,#0xff
;;;592    {
;;;593        (pwm)->PIIR = PWM_PIIR_PWMDIF0_Msk << u32ChannelNum;
000002  3201              ADDS     r2,#1
000004  408a              LSLS     r2,r2,r1
000006  6442              STR      r2,[r0,#0x44]
;;;594    }
000008  4770              BX       lr
;;;595    
                          ENDP


                          AREA ||i.PWM_ClearPeriodIntFlag||, CODE, READONLY, ALIGN=1

                  PWM_ClearPeriodIntFlag PROC
;;;644     */
;;;645    void PWM_ClearPeriodIntFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  2201              MOVS     r2,#1
;;;646    {
;;;647        (pwm)->PIIR = (PWM_PIIR_PWMIF0_Msk << u32ChannelNum);
000002  408a              LSLS     r2,r2,r1
000004  6442              STR      r2,[r0,#0x44]
;;;648    }
000006  4770              BX       lr
;;;649    
                          ENDP


                          AREA ||i.PWM_ConfigCaptureChannel||, CODE, READONLY, ALIGN=2

                  PWM_ConfigCaptureChannel PROC
;;;34      */
;;;35     uint32_t PWM_ConfigCaptureChannel(PWM_T *pwm,
000000  b5ff              PUSH     {r0-r7,lr}
;;;36                                       uint32_t u32ChannelNum,
;;;37                                       uint32_t u32UnitTimeNsec,
;;;38                                       uint32_t u32CaptureEdge)
;;;39     {
000002  b09d              SUB      sp,sp,#0x74
000004  460f              MOV      r7,r1
000006  4605              MOV      r5,r0
;;;40         uint32_t u32Src;
;;;41         uint32_t u32PWMClockSrc;
;;;42         uint32_t u32PWMClkTbl[8] = {__HXT, __LXT, NULL, __HIRC, NULL, NULL, NULL, __LIRC};
000008  2220              MOVS     r2,#0x20
00000a  4946              LDR      r1,|L5.292|
00000c  a811              ADD      r0,sp,#0x44
00000e  f7fffffe          BL       __aeabi_memcpy4
;;;43         uint32_t u32NearestUnitTimeNsec;
;;;44         uint8_t  u8Divider = 1;
;;;45         /* this table is mapping divider value to register configuration */
;;;46         uint32_t u32PWMDividerToRegTbl[17] = {NULL, 4, 0, NULL, 1, NULL, NULL, NULL, 2, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 3};
000012  4944              LDR      r1,|L5.292|
000014  2601              MOVS     r6,#1                 ;44
000016  2244              MOVS     r2,#0x44
000018  3120              ADDS     r1,r1,#0x20
00001a  4668              MOV      r0,sp
00001c  f7fffffe          BL       __aeabi_memcpy4
;;;47         uint16_t u16Prescale = 2;
;;;48         uint16_t u16CNR = 0xFFFF;
000020  4841              LDR      r0,|L5.296|
;;;49     
;;;50         if(pwm == PWMA)
000022  901b              STR      r0,[sp,#0x6c]
000024  4841              LDR      r0,|L5.300|
000026  2402              MOVS     r4,#2                 ;47
;;;51         {
;;;52             if(u32ChannelNum < 2)/* channel 0 and channel 1 */
;;;53                 u32Src = ((CLK->CLKSEL2 & (CLK_CLKSEL2_PWM01_S_EXT_Msk)) >> (CLK_CLKSEL2_PWM01_S_EXT_Pos - 2)) | (CLK->CLKSEL1 & (CLK_CLKSEL1_PWM01_S_Msk)) >> (CLK_CLKSEL1_PWM01_S_Pos);
000028  4941              LDR      r1,|L5.304|
00002a  2204              MOVS     r2,#4
00002c  4285              CMP      r5,r0                 ;50
00002e  d10c              BNE      |L5.74|
;;;54             else /* channel 2 and channel 3 */
;;;55                 u32Src = ((CLK->CLKSEL2 & (CLK_CLKSEL2_PWM23_S_EXT_Msk)) >> (CLK_CLKSEL2_PWM23_S_EXT_Pos - 2)) | (CLK->CLKSEL1 & (CLK_CLKSEL1_PWM23_S_Msk)) >> (CLK_CLKSEL1_PWM23_S_Pos);
000030  69c8              LDR      r0,[r1,#0x1c]
000032  2f02              CMP      r7,#2                 ;52
000034  d204              BCS      |L5.64|
000036  0980              LSRS     r0,r0,#6              ;53
000038  6949              LDR      r1,[r1,#0x14]         ;53
00003a  4010              ANDS     r0,r0,r2              ;53
;;;56         }
;;;57         else /*pwm == PWMB*/
;;;58         {
;;;59             if(u32ChannelNum < 2)/* channel 0 and channel 1 */
;;;60                 u32Src = ((CLK->CLKSEL2 & (CLK_CLKSEL2_PWM45_S_EXT_Msk)) >> (CLK_CLKSEL2_PWM45_S_EXT_Pos - 2)) | (CLK->CLKSEL2 & (CLK_CLKSEL2_PWM45_S_Msk)) >> (CLK_CLKSEL2_PWM45_S_Pos);
;;;61             else /* channel 2 and channel 3 */
;;;62                 u32Src = ((CLK->CLKSEL2 & (CLK_CLKSEL2_PWM67_S_EXT_Msk)) >> (CLK_CLKSEL2_PWM67_S_EXT_Pos - 2)) | (CLK->CLKSEL2 & (CLK_CLKSEL2_PWM67_S_Msk)) >> (CLK_CLKSEL2_PWM67_S_Pos);
;;;63         }
;;;64     
;;;65         if(u32Src == 2)
;;;66         {
;;;67             SystemCoreClockUpdate();
;;;68             u32PWMClockSrc = SystemCoreClock;
;;;69         }
;;;70         else
;;;71         {
;;;72             u32PWMClockSrc = u32PWMClkTbl[u32Src];
;;;73         }
;;;74     
;;;75         u32PWMClockSrc /= 1000;
;;;76         for(; u16Prescale <= 0x100; u16Prescale++)
;;;77         {
;;;78             u32NearestUnitTimeNsec = (1000000 * u16Prescale * u8Divider) / u32PWMClockSrc;
;;;79             if(u32NearestUnitTimeNsec < u32UnitTimeNsec)
;;;80             {
;;;81                 if((u16Prescale == 0x100) && (u8Divider == 16))  //limit to the maximum unit time(nano second)
;;;82                     break;
;;;83                 if(u16Prescale == 0x100)
;;;84                 {
;;;85                     u16Prescale = 2;
;;;86                     u8Divider <<= 1; // clk divider could only be 1, 2, 4, 8, 16
;;;87                     continue;
;;;88                 }
;;;89                 if(!((1000000  * ((u16Prescale * u8Divider) + 1)) > (u32NearestUnitTimeNsec * u32PWMClockSrc)))
;;;90                     break;
;;;91                 continue;
;;;92             }
;;;93             break;
;;;94         }
;;;95     
;;;96         // Store return value here 'cos we're gonna change u8Divider & u16Prescale & u16CNR to the real value to fill into register
;;;97         u16Prescale -= 1;
;;;98     
;;;99         // convert to real register value
;;;100        u8Divider = u32PWMDividerToRegTbl[u8Divider];
;;;101    
;;;102        // every two channels share a prescaler
;;;103        (pwm)->PPR = ((pwm)->PPR & ~(PWM_PPR_CP01_Msk << ((u32ChannelNum >> 1) * 8))) | (u16Prescale << ((u32ChannelNum >> 1) * 8));
;;;104        (pwm)->CSR = ((pwm)->CSR & ~(PWM_CSR_CSR0_Msk << (4 * u32ChannelNum))) | (u8Divider << (4 * u32ChannelNum));
;;;105        // set PWM to edge aligned type
;;;106        (pwm)->PCR &= ~(PWM_PCR_PWM01TYPE_Msk << (u32ChannelNum >> 1));
;;;107        (pwm)->PCR |= PWM_PCR_CH0MOD_Msk << (8 * u32ChannelNum);
;;;108        *((__IO uint32_t *)((((uint32_t) & ((pwm)->CNR0)) + (u32ChannelNum) * 12))) = u16CNR;
;;;109    
;;;110        return (u32NearestUnitTimeNsec);
;;;111    }
00003c  0f09              LSRS     r1,r1,#28
00003e  e00b              B        |L5.88|
                  |L5.64|
000040  09c0              LSRS     r0,r0,#7              ;55
000042  6949              LDR      r1,[r1,#0x14]         ;55
000044  4010              ANDS     r0,r0,r2              ;55
000046  0f89              LSRS     r1,r1,#30             ;55
000048  e00e              B        |L5.104|
                  |L5.74|
00004a  69c8              LDR      r0,[r1,#0x1c]         ;62
00004c  2f02              CMP      r7,#2                 ;59
00004e  d206              BCS      |L5.94|
000050  0a00              LSRS     r0,r0,#8              ;60
000052  69c9              LDR      r1,[r1,#0x1c]         ;60
000054  4010              ANDS     r0,r0,r2              ;60
000056  0909              LSRS     r1,r1,#4
                  |L5.88|
000058  0789              LSLS     r1,r1,#30
00005a  0f89              LSRS     r1,r1,#30
00005c  e004              B        |L5.104|
                  |L5.94|
00005e  0a40              LSRS     r0,r0,#9              ;62
000060  69c9              LDR      r1,[r1,#0x1c]         ;62
000062  4010              ANDS     r0,r0,r2              ;62
000064  0609              LSLS     r1,r1,#24             ;62
000066  0f89              LSRS     r1,r1,#30             ;62
                  |L5.104|
000068  4308              ORRS     r0,r0,r1              ;60
00006a  2802              CMP      r0,#2                 ;65
00006c  d01e              BEQ      |L5.172|
00006e  0080              LSLS     r0,r0,#2              ;72
000070  a911              ADD      r1,sp,#0x44           ;72
000072  5808              LDR      r0,[r1,r0]            ;72
                  |L5.116|
000074  217d              MOVS     r1,#0x7d              ;75
000076  00c9              LSLS     r1,r1,#3              ;75
000078  f7fffffe          BL       __aeabi_uidivmod
00007c  9019              STR      r0,[sp,#0x64]         ;75
                  |L5.126|
00007e  4620              MOV      r0,r4                 ;78
000080  4370              MULS     r0,r6,r0              ;78
000082  492c              LDR      r1,|L5.308|
000084  901a              STR      r0,[sp,#0x68]         ;78
000086  4348              MULS     r0,r1,r0              ;78
000088  9919              LDR      r1,[sp,#0x64]         ;78
00008a  f7fffffe          BL       __aeabi_uidivmod
00008e  991f              LDR      r1,[sp,#0x7c]         ;79
000090  4288              CMP      r0,r1                 ;79
000092  d21c              BCS      |L5.206|
000094  21ff              MOVS     r1,#0xff              ;81
000096  3101              ADDS     r1,#1                 ;81
000098  428c              CMP      r4,r1                 ;81
00009a  d101              BNE      |L5.160|
00009c  2e10              CMP      r6,#0x10              ;81
00009e  d016              BEQ      |L5.206|
                  |L5.160|
0000a0  428c              CMP      r4,r1                 ;83
0000a2  d108              BNE      |L5.182|
0000a4  2402              MOVS     r4,#2                 ;85
0000a6  0672              LSLS     r2,r6,#25             ;86
0000a8  0e16              LSRS     r6,r2,#24             ;86
0000aa  e00c              B        |L5.198|
                  |L5.172|
0000ac  f7fffffe          BL       SystemCoreClockUpdate
0000b0  4821              LDR      r0,|L5.312|
0000b2  6800              LDR      r0,[r0,#0]            ;68  ; SystemCoreClock
0000b4  e7de              B        |L5.116|
                  |L5.182|
0000b6  9a1a              LDR      r2,[sp,#0x68]         ;89
0000b8  4b1e              LDR      r3,|L5.308|
0000ba  1c52              ADDS     r2,r2,#1              ;89
0000bc  435a              MULS     r2,r3,r2              ;89
0000be  9b19              LDR      r3,[sp,#0x64]         ;89
0000c0  4343              MULS     r3,r0,r3              ;89
0000c2  429a              CMP      r2,r3                 ;89
0000c4  d903              BLS      |L5.206|
                  |L5.198|
0000c6  1c64              ADDS     r4,r4,#1              ;89
0000c8  b2a4              UXTH     r4,r4                 ;76
0000ca  428c              CMP      r4,r1                 ;76
0000cc  d9d7              BLS      |L5.126|
                  |L5.206|
0000ce  1e64              SUBS     r4,r4,#1              ;76
0000d0  00b1              LSLS     r1,r6,#2              ;100
0000d2  466b              MOV      r3,sp                 ;100
0000d4  5c5b              LDRB     r3,[r3,r1]            ;100
0000d6  b2a2              UXTH     r2,r4                 ;97
0000d8  469c              MOV      r12,r3                ;100
0000da  682b              LDR      r3,[r5,#0]            ;103
0000dc  087e              LSRS     r6,r7,#1              ;103
0000de  00f1              LSLS     r1,r6,#3              ;103
0000e0  24ff              MOVS     r4,#0xff              ;103
0000e2  408c              LSLS     r4,r4,r1              ;103
0000e4  43a3              BICS     r3,r3,r4              ;103
0000e6  408a              LSLS     r2,r2,r1              ;103
0000e8  4313              ORRS     r3,r3,r2              ;103
0000ea  602b              STR      r3,[r5,#0]            ;103
0000ec  686a              LDR      r2,[r5,#4]            ;104
0000ee  00b9              LSLS     r1,r7,#2              ;104
0000f0  2307              MOVS     r3,#7                 ;104
0000f2  408b              LSLS     r3,r3,r1              ;104
0000f4  439a              BICS     r2,r2,r3              ;104
0000f6  4663              MOV      r3,r12                ;104
0000f8  408b              LSLS     r3,r3,r1              ;104
0000fa  431a              ORRS     r2,r2,r3              ;104
0000fc  606a              STR      r2,[r5,#4]            ;104
0000fe  68a9              LDR      r1,[r5,#8]            ;106
000100  2201              MOVS     r2,#1                 ;106
000102  0792              LSLS     r2,r2,#30             ;106
000104  40b2              LSLS     r2,r2,r6              ;106
000106  4391              BICS     r1,r1,r2              ;106
000108  60a9              STR      r1,[r5,#8]            ;106
00010a  68a9              LDR      r1,[r5,#8]            ;107
00010c  00fb              LSLS     r3,r7,#3              ;107
00010e  2208              MOVS     r2,#8                 ;107
000110  409a              LSLS     r2,r2,r3              ;107
000112  4311              ORRS     r1,r1,r2              ;107
000114  60a9              STR      r1,[r5,#8]            ;107
000116  220c              MOVS     r2,#0xc               ;108
000118  4357              MULS     r7,r2,r7              ;108
00011a  197a              ADDS     r2,r7,r5              ;108
00011c  991b              LDR      r1,[sp,#0x6c]         ;108
00011e  60d1              STR      r1,[r2,#0xc]          ;108
000120  b021              ADD      sp,sp,#0x84
000122  bdf0              POP      {r4-r7,pc}
;;;112    
                          ENDP

                  |L5.292|
                          DCD      ||.constdata||
                  |L5.296|
                          DCD      0x0000ffff
                  |L5.300|
                          DCD      0x40040000
                  |L5.304|
                          DCD      0x50000200
                  |L5.308|
                          DCD      0x000f4240
                  |L5.312|
                          DCD      SystemCoreClock

                          AREA ||i.PWM_ConfigOutputChannel||, CODE, READONLY, ALIGN=2

                  PWM_ConfigOutputChannel PROC
;;;123     */
;;;124    uint32_t PWM_ConfigOutputChannel(PWM_T *pwm,
000000  b5ff              PUSH     {r0-r7,lr}
;;;125                                     uint32_t u32ChannelNum,
;;;126                                     uint32_t u32Frequency,
;;;127                                     uint32_t u32DutyCycle)
;;;128    {
000002  b09d              SUB      sp,sp,#0x74
000004  460e              MOV      r6,r1
000006  4604              MOV      r4,r0
;;;129        uint32_t u32Src;
;;;130        uint32_t u32PWMClockSrc;
;;;131        uint32_t u32PWMClkTbl[8] = {__HXT, __LXT, NULL, __HIRC, NULL, NULL, NULL, __LIRC};
000008  2220              MOVS     r2,#0x20
00000a  494f              LDR      r1,|L6.328|
00000c  a811              ADD      r0,sp,#0x44
00000e  f7fffffe          BL       __aeabi_memcpy4
;;;132        uint32_t i;
;;;133        uint8_t  u8Divider = 1, u8Prescale = 0xFF;
;;;134        /* this table is mapping divider value to register configuration */
;;;135        uint32_t u32PWMDividerToRegTbl[17] = {NULL, 4, 0, NULL, 1, NULL, NULL, NULL, 2, NULL, NULL, NULL, NULL, NULL, NULL, NULL, 3};
000012  494d              LDR      r1,|L6.328|
000014  2501              MOVS     r5,#1                 ;133
000016  27ff              MOVS     r7,#0xff              ;133
000018  2244              MOVS     r2,#0x44
00001a  3120              ADDS     r1,r1,#0x20
00001c  4668              MOV      r0,sp
00001e  f7fffffe          BL       __aeabi_memcpy4
;;;136        uint16_t u16CNR = 0xFFFF;
000022  484a              LDR      r0,|L6.332|
;;;137    
;;;138        if(pwm == PWMA)
000024  9019              STR      r0,[sp,#0x64]
000026  484a              LDR      r0,|L6.336|
;;;139        {
;;;140            if(u32ChannelNum < 2)/* channel 0 and channel 1 */
;;;141                u32Src = ((CLK->CLKSEL2 & (CLK_CLKSEL2_PWM01_S_EXT_Msk)) >> (CLK_CLKSEL2_PWM01_S_EXT_Pos - 2)) | (CLK->CLKSEL1 & (CLK_CLKSEL1_PWM01_S_Msk)) >> (CLK_CLKSEL1_PWM01_S_Pos);
000028  494a              LDR      r1,|L6.340|
00002a  2204              MOVS     r2,#4
00002c  4284              CMP      r4,r0                 ;138
00002e  d10c              BNE      |L6.74|
;;;142            else /* channel 2 and channel 3 */
;;;143                u32Src = ((CLK->CLKSEL2 & (CLK_CLKSEL2_PWM23_S_EXT_Msk)) >> (CLK_CLKSEL2_PWM23_S_EXT_Pos - 2)) | (CLK->CLKSEL1 & (CLK_CLKSEL1_PWM23_S_Msk)) >> (CLK_CLKSEL1_PWM23_S_Pos);
000030  69c8              LDR      r0,[r1,#0x1c]
000032  2e02              CMP      r6,#2                 ;140
000034  d204              BCS      |L6.64|
000036  0980              LSRS     r0,r0,#6              ;141
000038  6949              LDR      r1,[r1,#0x14]         ;141
00003a  4010              ANDS     r0,r0,r2              ;141
;;;144        }
;;;145        else /*pwm == PWMB*/
;;;146        {
;;;147            if(u32ChannelNum < 2)/* channel 0 and channel 1 */
;;;148                u32Src = ((CLK->CLKSEL2 & (CLK_CLKSEL2_PWM45_S_EXT_Msk)) >> (CLK_CLKSEL2_PWM45_S_EXT_Pos - 2)) | (CLK->CLKSEL2 & (CLK_CLKSEL2_PWM45_S_Msk)) >> (CLK_CLKSEL2_PWM45_S_Pos);
;;;149            else /* channel 2 and channel 3 */
;;;150                u32Src = ((CLK->CLKSEL2 & (CLK_CLKSEL2_PWM67_S_EXT_Msk)) >> (CLK_CLKSEL2_PWM67_S_EXT_Pos - 2)) | (CLK->CLKSEL2 & (CLK_CLKSEL2_PWM67_S_Msk)) >> (CLK_CLKSEL2_PWM67_S_Pos);
;;;151        }
;;;152    
;;;153        if(u32Src == 2)
;;;154        {
;;;155            SystemCoreClockUpdate();
;;;156            u32PWMClockSrc = SystemCoreClock;
;;;157        }
;;;158        else
;;;159        {
;;;160            u32PWMClockSrc = u32PWMClkTbl[u32Src];
;;;161        }
;;;162    
;;;163        for(; u8Divider < 17; u8Divider <<= 1)    // clk divider could only be 1, 2, 4, 8, 16
;;;164        {
;;;165            i = (u32PWMClockSrc / u32Frequency) / u8Divider;
;;;166            // If target value is larger than CNR * prescale, need to use a larger divider
;;;167            if(i > (0x10000 * 0x100))
;;;168                continue;
;;;169    
;;;170            // CNR = 0xFFFF + 1, get a prescaler that CNR value is below 0xFFFF
;;;171            u8Prescale = (i + 0xFFFF) / 0x10000;
;;;172    
;;;173            // u8Prescale must at least be 2, otherwise the output stop
;;;174            if(u8Prescale < 3)
;;;175                u8Prescale = 2;
;;;176    
;;;177            i /= u8Prescale;
;;;178    
;;;179            if(i <= 0x10000)
;;;180            {
;;;181                if(i == 1)
;;;182                    u16CNR = 1;     // Too fast, and PWM cannot generate expected frequency...
;;;183                else
;;;184                    u16CNR = i;
;;;185                break;
;;;186            }
;;;187        }
;;;188        // Store return value here 'cos we're gonna change u8Divider & u8Prescale & u16CNR to the real value to fill into register
;;;189        i = u32PWMClockSrc / (u8Prescale * u8Divider * u16CNR);
;;;190    
;;;191        u8Prescale -= 1;
;;;192        u16CNR -= 1;
;;;193        // convert to real register value
;;;194        u8Divider = u32PWMDividerToRegTbl[u8Divider];
;;;195    
;;;196        // every two channels share a prescaler
;;;197        (pwm)->PPR = ((pwm)->PPR & ~(PWM_PPR_CP01_Msk << ((u32ChannelNum >> 1) * 8))) | (u8Prescale << ((u32ChannelNum >> 1) * 8));
;;;198        (pwm)->CSR = ((pwm)->CSR & ~(PWM_CSR_CSR0_Msk << (4 * u32ChannelNum))) | (u8Divider << (4 * u32ChannelNum));
;;;199        // set PWM to edge aligned type
;;;200        (pwm)->PCR &= ~(PWM_PCR_PWM01TYPE_Msk << (u32ChannelNum >> 1));
;;;201        (pwm)->PCR |= PWM_PCR_CH0MOD_Msk << (8 * u32ChannelNum);
;;;202    
;;;203        if(u32DutyCycle)
;;;204        {
;;;205            *((__IO uint32_t *)((((uint32_t) & ((pwm)->CMR0)) + u32ChannelNum * 12))) = u32DutyCycle * (u16CNR + 1) / 100 - 1;
;;;206        }
;;;207        else
;;;208        {
;;;209            *((__IO uint32_t *)((((uint32_t) & ((pwm)->CMR0)) + u32ChannelNum * 12))) = 0;
;;;210        }
;;;211        *((__IO uint32_t *)((((uint32_t) & ((pwm)->CNR0)) + (u32ChannelNum) * 12))) = u16CNR;
;;;212    
;;;213        return(i);
;;;214    }
00003c  0f09              LSRS     r1,r1,#28
00003e  e00b              B        |L6.88|
                  |L6.64|
000040  09c0              LSRS     r0,r0,#7              ;143
000042  6949              LDR      r1,[r1,#0x14]         ;143
000044  4010              ANDS     r0,r0,r2              ;143
000046  0f89              LSRS     r1,r1,#30             ;143
000048  e00e              B        |L6.104|
                  |L6.74|
00004a  69c8              LDR      r0,[r1,#0x1c]         ;150
00004c  2e02              CMP      r6,#2                 ;147
00004e  d206              BCS      |L6.94|
000050  0a00              LSRS     r0,r0,#8              ;148
000052  69c9              LDR      r1,[r1,#0x1c]         ;148
000054  4010              ANDS     r0,r0,r2              ;148
000056  0909              LSRS     r1,r1,#4
                  |L6.88|
000058  0789              LSLS     r1,r1,#30
00005a  0f89              LSRS     r1,r1,#30
00005c  e004              B        |L6.104|
                  |L6.94|
00005e  0a40              LSRS     r0,r0,#9              ;150
000060  69c9              LDR      r1,[r1,#0x1c]         ;150
000062  4010              ANDS     r0,r0,r2              ;150
000064  0609              LSLS     r1,r1,#24             ;150
000066  0f89              LSRS     r1,r1,#30             ;150
                  |L6.104|
000068  4308              ORRS     r0,r0,r1              ;148
00006a  2802              CMP      r0,#2                 ;153
00006c  d021              BEQ      |L6.178|
00006e  0080              LSLS     r0,r0,#2              ;160
000070  a911              ADD      r1,sp,#0x44           ;160
000072  5808              LDR      r0,[r1,r0]            ;160
                  |L6.116|
000074  901a              STR      r0,[sp,#0x68]         ;128
000076  991f              LDR      r1,[sp,#0x7c]         ;165
000078  f7fffffe          BL       __aeabi_uidivmod
00007c  901b              STR      r0,[sp,#0x6c]         ;165
                  |L6.126|
00007e  4629              MOV      r1,r5                 ;165
000080  f7fffffe          BL       __aeabi_uidivmod
000084  2101              MOVS     r1,#1                 ;167
000086  0609              LSLS     r1,r1,#24             ;167
000088  4288              CMP      r0,r1                 ;167
00008a  d817              BHI      |L6.188|
00008c  492f              LDR      r1,|L6.332|
00008e  1841              ADDS     r1,r0,r1              ;171
000090  0209              LSLS     r1,r1,#8              ;171
000092  0e0f              LSRS     r7,r1,#24             ;171
000094  2f03              CMP      r7,#3                 ;174
000096  d200              BCS      |L6.154|
000098  2702              MOVS     r7,#2                 ;175
                  |L6.154|
00009a  4639              MOV      r1,r7                 ;177
00009c  f7fffffe          BL       __aeabi_uidivmod
0000a0  2101              MOVS     r1,#1                 ;179
0000a2  0409              LSLS     r1,r1,#16             ;179
0000a4  4288              CMP      r0,r1                 ;179
0000a6  d809              BHI      |L6.188|
0000a8  2801              CMP      r0,#1                 ;181
0000aa  d000              BEQ      |L6.174|
0000ac  b280              UXTH     r0,r0                 ;184
                  |L6.174|
0000ae  9019              STR      r0,[sp,#0x64]         ;182
0000b0  e00a              B        |L6.200|
                  |L6.178|
0000b2  f7fffffe          BL       SystemCoreClockUpdate
0000b6  4828              LDR      r0,|L6.344|
0000b8  6800              LDR      r0,[r0,#0]            ;156  ; SystemCoreClock
0000ba  e7db              B        |L6.116|
                  |L6.188|
0000bc  0668              LSLS     r0,r5,#25             ;163
0000be  0e05              LSRS     r5,r0,#24             ;163
0000c0  2d11              CMP      r5,#0x11              ;163
0000c2  d201              BCS      |L6.200|
0000c4  981b              LDR      r0,[sp,#0x6c]         ;163
0000c6  e7da              B        |L6.126|
                  |L6.200|
0000c8  4639              MOV      r1,r7                 ;189
0000ca  9819              LDR      r0,[sp,#0x64]         ;189
0000cc  4369              MULS     r1,r5,r1              ;189
0000ce  4341              MULS     r1,r0,r1              ;189
0000d0  981a              LDR      r0,[sp,#0x68]         ;189
0000d2  f7fffffe          BL       __aeabi_uidivmod
0000d6  901a              STR      r0,[sp,#0x68]         ;192
0000d8  1e7f              SUBS     r7,r7,#1              ;189
0000da  9819              LDR      r0,[sp,#0x64]         ;192
0000dc  b2f9              UXTB     r1,r7                 ;191
0000de  1e40              SUBS     r0,r0,#1              ;192
0000e0  b287              UXTH     r7,r0                 ;192
0000e2  00a8              LSLS     r0,r5,#2              ;194
0000e4  466a              MOV      r2,sp                 ;194
0000e6  5c15              LDRB     r5,[r2,r0]            ;194
0000e8  6822              LDR      r2,[r4,#0]            ;197
0000ea  0870              LSRS     r0,r6,#1              ;197
0000ec  4684              MOV      r12,r0                ;197
0000ee  00c0              LSLS     r0,r0,#3              ;197
0000f0  23ff              MOVS     r3,#0xff              ;197
0000f2  4083              LSLS     r3,r3,r0              ;197
0000f4  439a              BICS     r2,r2,r3              ;197
0000f6  4081              LSLS     r1,r1,r0              ;197
0000f8  430a              ORRS     r2,r2,r1              ;197
0000fa  6022              STR      r2,[r4,#0]            ;197
0000fc  6861              LDR      r1,[r4,#4]            ;198
0000fe  00b0              LSLS     r0,r6,#2              ;198
000100  2207              MOVS     r2,#7                 ;198
000102  4082              LSLS     r2,r2,r0              ;198
000104  4391              BICS     r1,r1,r2              ;198
000106  4085              LSLS     r5,r5,r0              ;198
000108  4329              ORRS     r1,r1,r5              ;198
00010a  6061              STR      r1,[r4,#4]            ;198
00010c  68a1              LDR      r1,[r4,#8]            ;200
00010e  2201              MOVS     r2,#1                 ;200
000110  4660              MOV      r0,r12                ;200
000112  0792              LSLS     r2,r2,#30             ;200
000114  4082              LSLS     r2,r2,r0              ;200
000116  4391              BICS     r1,r1,r2              ;200
000118  60a1              STR      r1,[r4,#8]            ;200
00011a  68a0              LDR      r0,[r4,#8]            ;201
00011c  00f2              LSLS     r2,r6,#3              ;201
00011e  2108              MOVS     r1,#8                 ;201
000120  4091              LSLS     r1,r1,r2              ;201
000122  4308              ORRS     r0,r0,r1              ;201
000124  60a0              STR      r0,[r4,#8]            ;201
000126  210c              MOVS     r1,#0xc               ;205
000128  434e              MULS     r6,r1,r6              ;205
00012a  9820              LDR      r0,[sp,#0x80]         ;203
00012c  1934              ADDS     r4,r6,r4              ;205
00012e  2800              CMP      r0,#0                 ;203
000130  d005              BEQ      |L6.318|
000132  1c79              ADDS     r1,r7,#1              ;205
000134  4348              MULS     r0,r1,r0              ;205
000136  2164              MOVS     r1,#0x64              ;205
000138  f7fffffe          BL       __aeabi_uidivmod
00013c  1e40              SUBS     r0,r0,#1              ;205
                  |L6.318|
00013e  6120              STR      r0,[r4,#0x10]         ;209
000140  60e7              STR      r7,[r4,#0xc]          ;211
000142  981a              LDR      r0,[sp,#0x68]         ;213
000144  b021              ADD      sp,sp,#0x84
000146  bdf0              POP      {r4-r7,pc}
;;;215    
                          ENDP

                  |L6.328|
                          DCD      ||.constdata||+0x64
                  |L6.332|
                          DCD      0x0000ffff
                  |L6.336|
                          DCD      0x40040000
                  |L6.340|
                          DCD      0x50000200
                  |L6.344|
                          DCD      SystemCoreClock

                          AREA ||i.PWM_DisableADCTrigger||, CODE, READONLY, ALIGN=1

                  PWM_DisableADCTrigger PROC
;;;307     */
;;;308    void PWM_DisableADCTrigger(PWM_T *pwm, uint32_t u32ChannelNum)
000000  3080              ADDS     r0,r0,#0x80
;;;309    {
;;;310        (pwm)->TCON = ((pwm)->TCON & ~(PWM_TCON_PWM0TEN_Msk << u32ChannelNum));
000002  6802              LDR      r2,[r0,#0]
000004  2301              MOVS     r3,#1
000006  408b              LSLS     r3,r3,r1
000008  439a              BICS     r2,r2,r3
00000a  6002              STR      r2,[r0,#0]
;;;311    }
00000c  4770              BX       lr
;;;312    
                          ENDP


                          AREA ||i.PWM_DisableCapture||, CODE, READONLY, ALIGN=1

                  PWM_DisableCapture PROC
;;;379     */
;;;380    void PWM_DisableCapture(PWM_T *pwm, uint32_t u32ChannelMask)
000000  b5f0              PUSH     {r4-r7,lr}
;;;381    {
;;;382        uint32_t i;
;;;383        for(i = 0; i < PWM_CHANNEL_NUM; i ++)
000002  2200              MOVS     r2,#0
;;;384        {
;;;385            if(u32ChannelMask & (1 << i))
000004  2501              MOVS     r5,#1
;;;386            {
;;;387                if(i < 2)
;;;388                {
;;;389                    (pwm)->CCR0 &= ~(PWM_CCR0_CAPCH0EN_Msk << (i * 16));
000006  2308              MOVS     r3,#8
                  |L8.8|
000008  462c              MOV      r4,r5                 ;385
00000a  4094              LSLS     r4,r4,r2              ;385
00000c  420c              TST      r4,r1                 ;385
00000e  d00f              BEQ      |L8.48|
000010  2a02              CMP      r2,#2                 ;387
000012  d206              BCS      |L8.34|
000014  6d04              LDR      r4,[r0,#0x50]
000016  0116              LSLS     r6,r2,#4
000018  461f              MOV      r7,r3
00001a  40b7              LSLS     r7,r7,r6
00001c  43bc              BICS     r4,r4,r7
00001e  6504              STR      r4,[r0,#0x50]
000020  e006              B        |L8.48|
                  |L8.34|
;;;390                }
;;;391                else
;;;392                {
;;;393                    (pwm)->CCR2 &= ~(PWM_CCR2_CAPCH2EN_Msk << ((i - 2) * 16));
000022  0114              LSLS     r4,r2,#4
000024  461e              MOV      r6,r3
000026  3c20              SUBS     r4,r4,#0x20
000028  40a6              LSLS     r6,r6,r4
00002a  6d44              LDR      r4,[r0,#0x54]
00002c  43b4              BICS     r4,r4,r6
00002e  6544              STR      r4,[r0,#0x54]
                  |L8.48|
000030  1c52              ADDS     r2,r2,#1
000032  2a04              CMP      r2,#4                 ;383
000034  d3e8              BCC      |L8.8|
;;;394                }
;;;395            }
;;;396        }
;;;397        (pwm)->CAPENR &= ~u32ChannelMask;
000036  6f82              LDR      r2,[r0,#0x78]
000038  438a              BICS     r2,r2,r1
00003a  6782              STR      r2,[r0,#0x78]
;;;398    }
00003c  bdf0              POP      {r4-r7,pc}
;;;399    
                          ENDP


                          AREA ||i.PWM_DisableCaptureInt||, CODE, READONLY, ALIGN=1

                  PWM_DisableCaptureInt PROC
;;;500     */
;;;501    void PWM_DisableCaptureInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge)
000000  010b              LSLS     r3,r1,#4
;;;502    {
;;;503        if(u32ChannelNum < 2)
000002  2902              CMP      r1,#2
000004  d205              BCS      |L9.18|
;;;504            (pwm)->CCR0 &= u32Edge << ~(u32ChannelNum * 16);
000006  6d01              LDR      r1,[r0,#0x50]
000008  43db              MVNS     r3,r3
00000a  409a              LSLS     r2,r2,r3
00000c  4011              ANDS     r1,r1,r2
00000e  6501              STR      r1,[r0,#0x50]
;;;505        else
;;;506            (pwm)->CCR2 &= u32Edge << ~((u32ChannelNum - 2) * 16);
;;;507    }
000010  4770              BX       lr
                  |L9.18|
000012  3b20              SUBS     r3,r3,#0x20
000014  43d9              MVNS     r1,r3                 ;506
000016  408a              LSLS     r2,r2,r1              ;506
000018  6d41              LDR      r1,[r0,#0x54]         ;506
00001a  400a              ANDS     r2,r2,r1              ;506
00001c  6542              STR      r2,[r0,#0x54]         ;506
00001e  4770              BX       lr
;;;508    
                          ENDP


                          AREA ||i.PWM_DisableDeadZone||, CODE, READONLY, ALIGN=1

                  PWM_DisableDeadZone PROC
;;;459     */
;;;460    void PWM_DisableDeadZone(PWM_T *pwm, uint32_t u32ChannelNum)
000000  6883              LDR      r3,[r0,#8]
;;;461    {
;;;462        // every two channels shares the same setting
;;;463        u32ChannelNum >>= 1;
000002  0849              LSRS     r1,r1,#1
;;;464        // enable dead zone
;;;465        (pwm)->PCR &= ~(PWM_PCR_DZEN01_Msk << u32ChannelNum);
000004  2210              MOVS     r2,#0x10
000006  408a              LSLS     r2,r2,r1
000008  4393              BICS     r3,r3,r2
00000a  6083              STR      r3,[r0,#8]
;;;466    }
00000c  4770              BX       lr
;;;467    
                          ENDP


                          AREA ||i.PWM_DisableDutyInt||, CODE, READONLY, ALIGN=1

                  PWM_DisableDutyInt PROC
;;;578     */
;;;579    void PWM_DisableDutyInt(PWM_T *pwm, uint32_t u32ChannelNum)
000000  6c02              LDR      r2,[r0,#0x40]
;;;580    {
;;;581        (pwm)->PIER &= ~(PWM_PIER_PWMDIE0_Msk << u32ChannelNum);
000002  23ff              MOVS     r3,#0xff
000004  3301              ADDS     r3,#1
000006  408b              LSLS     r3,r3,r1
000008  439a              BICS     r2,r2,r3
00000a  6402              STR      r2,[r0,#0x40]
;;;582    }
00000c  4770              BX       lr
;;;583    
                          ENDP


                          AREA ||i.PWM_DisableOutput||, CODE, READONLY, ALIGN=1

                  PWM_DisableOutput PROC
;;;424     */
;;;425    void PWM_DisableOutput(PWM_T *pwm, uint32_t u32ChannelMask)
000000  6fc2              LDR      r2,[r0,#0x7c]
;;;426    {
;;;427        (pwm)->POE &= ~u32ChannelMask;
000002  438a              BICS     r2,r2,r1
000004  67c2              STR      r2,[r0,#0x7c]
;;;428    }
000006  4770              BX       lr
;;;429    
                          ENDP


                          AREA ||i.PWM_DisablePeriodInt||, CODE, READONLY, ALIGN=1

                  PWM_DisablePeriodInt PROC
;;;632     */
;;;633    void PWM_DisablePeriodInt(PWM_T *pwm, uint32_t u32ChannelNum)
000000  6c02              LDR      r2,[r0,#0x40]
;;;634    {
;;;635        (pwm)->PIER &= ~(PWM_PIER_PWMIE0_Msk << u32ChannelNum);
000002  2301              MOVS     r3,#1
000004  408b              LSLS     r3,r3,r1
000006  439a              BICS     r2,r2,r3
000008  6402              STR      r2,[r0,#0x40]
;;;636    }
00000a  4770              BX       lr
;;;637    
                          ENDP


                          AREA ||i.PWM_EnableADCTrigger||, CODE, READONLY, ALIGN=1

                  PWM_EnableADCTrigger PROC
;;;295     */
;;;296    void PWM_EnableADCTrigger(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Condition)
000000  3080              ADDS     r0,r0,#0x80
;;;297    {
;;;298        (pwm)->TCON |= (PWM_TCON_PWM0TEN_Msk << u32ChannelNum);
000002  6802              LDR      r2,[r0,#0]
000004  2301              MOVS     r3,#1
000006  408b              LSLS     r3,r3,r1
000008  431a              ORRS     r2,r2,r3
00000a  6002              STR      r2,[r0,#0]
;;;299    }
00000c  4770              BX       lr
;;;300    
                          ENDP


                          AREA ||i.PWM_EnableCapture||, CODE, READONLY, ALIGN=1

                  PWM_EnableCapture PROC
;;;348     */
;;;349    void PWM_EnableCapture(PWM_T *pwm, uint32_t u32ChannelMask)
000000  b5f0              PUSH     {r4-r7,lr}
;;;350    {
;;;351        uint32_t i;
;;;352        for(i = 0; i < PWM_CHANNEL_NUM; i ++)
000002  2200              MOVS     r2,#0
;;;353        {
;;;354            if(u32ChannelMask & (1 << i))
000004  2501              MOVS     r5,#1
;;;355            {
;;;356                if(i < 2)
;;;357                {
;;;358                    (pwm)->CCR0 |= PWM_CCR0_CAPCH0EN_Msk << (i * 16);
000006  2608              MOVS     r6,#8
                  |L15.8|
000008  462c              MOV      r4,r5                 ;354
00000a  4094              LSLS     r4,r4,r2              ;354
00000c  420c              TST      r4,r1                 ;354
00000e  d00f              BEQ      |L15.48|
000010  2a02              CMP      r2,#2                 ;356
000012  d206              BCS      |L15.34|
000014  6d04              LDR      r4,[r0,#0x50]
000016  0117              LSLS     r7,r2,#4
000018  4633              MOV      r3,r6
00001a  40bb              LSLS     r3,r3,r7
00001c  431c              ORRS     r4,r4,r3
00001e  6504              STR      r4,[r0,#0x50]
000020  e006              B        |L15.48|
                  |L15.34|
;;;359                }
;;;360                else
;;;361                {
;;;362                    (pwm)->CCR2 |= PWM_CCR2_CAPCH2EN_Msk << ((i - 2) * 16);
000022  0114              LSLS     r4,r2,#4
000024  4633              MOV      r3,r6
000026  3c20              SUBS     r4,r4,#0x20
000028  40a3              LSLS     r3,r3,r4
00002a  6d44              LDR      r4,[r0,#0x54]
00002c  4323              ORRS     r3,r3,r4
00002e  6543              STR      r3,[r0,#0x54]
                  |L15.48|
000030  1c52              ADDS     r2,r2,#1
000032  2a04              CMP      r2,#4                 ;352
000034  d3e8              BCC      |L15.8|
;;;363                }
;;;364            }
;;;365        }
;;;366        (pwm)->CAPENR |= u32ChannelMask;
000036  6f82              LDR      r2,[r0,#0x78]
000038  430a              ORRS     r2,r2,r1
00003a  6782              STR      r2,[r0,#0x78]
;;;367        (pwm)->PBCR = 1;
00003c  63c5              STR      r5,[r0,#0x3c]
;;;368    }
00003e  bdf0              POP      {r4-r7,pc}
;;;369    
                          ENDP


                          AREA ||i.PWM_EnableCaptureInt||, CODE, READONLY, ALIGN=1

                  PWM_EnableCaptureInt PROC
;;;479     */
;;;480    void PWM_EnableCaptureInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Edge)
000000  010b              LSLS     r3,r1,#4
;;;481    {
;;;482        if(u32ChannelNum < 2)
000002  2902              CMP      r1,#2
000004  d204              BCS      |L16.16|
;;;483            (pwm)->CCR0 |= u32Edge << (u32ChannelNum * 16);
000006  6d01              LDR      r1,[r0,#0x50]
000008  409a              LSLS     r2,r2,r3
00000a  4311              ORRS     r1,r1,r2
00000c  6501              STR      r1,[r0,#0x50]
;;;484        else
;;;485            (pwm)->CCR2 |= u32Edge << ((u32ChannelNum - 2) * 16);
;;;486    
;;;487    }
00000e  4770              BX       lr
                  |L16.16|
000010  3b20              SUBS     r3,r3,#0x20
000012  6d41              LDR      r1,[r0,#0x54]         ;485
000014  409a              LSLS     r2,r2,r3              ;485
000016  430a              ORRS     r2,r2,r1              ;485
000018  6542              STR      r2,[r0,#0x54]         ;485
00001a  4770              BX       lr
;;;488    
                          ENDP


                          AREA ||i.PWM_EnableDeadZone||, CODE, READONLY, ALIGN=1

                  PWM_EnableDeadZone PROC
;;;440     */
;;;441    void PWM_EnableDeadZone(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32Duration)
000000  b530              PUSH     {r4,r5,lr}
;;;442    {
;;;443        // every two channels shares the same setting
;;;444        u32ChannelNum >>= 1;
;;;445        // set duration
;;;446        (pwm)->PPR = ((pwm)->PPR & ~(PWM_PPR_DZI01_Msk << (8 * u32ChannelNum))) | (u32Duration << (PWM_PPR_DZI01_Pos + 8 * u32ChannelNum));
000002  6804              LDR      r4,[r0,#0]
000004  0849              LSRS     r1,r1,#1              ;444
000006  00cb              LSLS     r3,r1,#3
000008  25ff              MOVS     r5,#0xff
00000a  042d              LSLS     r5,r5,#16
00000c  409d              LSLS     r5,r5,r3
00000e  3310              ADDS     r3,r3,#0x10
000010  43ac              BICS     r4,r4,r5
000012  409a              LSLS     r2,r2,r3
000014  4314              ORRS     r4,r4,r2
000016  6004              STR      r4,[r0,#0]
;;;447        // enable dead zone
;;;448        (pwm)->PCR |= (PWM_PCR_DZEN01_Msk << u32ChannelNum);
000018  6882              LDR      r2,[r0,#8]
00001a  2310              MOVS     r3,#0x10
00001c  408b              LSLS     r3,r3,r1
00001e  431a              ORRS     r2,r2,r3
000020  6082              STR      r2,[r0,#8]
;;;449    }
000022  bd30              POP      {r4,r5,pc}
;;;450    
                          ENDP


                          AREA ||i.PWM_EnableDutyInt||, CODE, READONLY, ALIGN=1

                  PWM_EnableDutyInt PROC
;;;564     */
;;;565    void PWM_EnableDutyInt(PWM_T *pwm, uint32_t u32ChannelNum, uint32_t u32IntDutyType)
000000  6c02              LDR      r2,[r0,#0x40]
;;;566    {
;;;567        (pwm)->PIER |= (PWM_PIER_PWMDIE0_Msk << u32ChannelNum);
000002  23ff              MOVS     r3,#0xff
000004  3301              ADDS     r3,#1
000006  408b              LSLS     r3,r3,r1
000008  431a              ORRS     r2,r2,r3
00000a  6402              STR      r2,[r0,#0x40]
;;;568    }
00000c  4770              BX       lr
;;;569    
                          ENDP


                          AREA ||i.PWM_EnableOutput||, CODE, READONLY, ALIGN=1

                  PWM_EnableOutput PROC
;;;409     */
;;;410    void PWM_EnableOutput(PWM_T *pwm, uint32_t u32ChannelMask)
000000  6fc2              LDR      r2,[r0,#0x7c]
;;;411    {
;;;412        (pwm)->POE |= u32ChannelMask;
000002  430a              ORRS     r2,r2,r1
000004  67c2              STR      r2,[r0,#0x7c]
;;;413    }
000006  4770              BX       lr
;;;414    
                          ENDP


                          AREA ||i.PWM_EnablePeriodInt||, CODE, READONLY, ALIGN=1

                  PWM_EnablePeriodInt PROC
;;;619     */
;;;620    void PWM_EnablePeriodInt(PWM_T *pwm, uint32_t u32ChannelNum,  uint32_t u32IntPeriodType)
000000  b530              PUSH     {r4,r5,lr}
;;;621    {
;;;622        (pwm)->PIER = ((pwm)->PIER & ~(PWM_PIER_INT01TYPE_Msk << (u32ChannelNum >> 1))) | \
000002  6c04              LDR      r4,[r0,#0x40]
000004  084b              LSRS     r3,r1,#1
000006  2501              MOVS     r5,#1
000008  042d              LSLS     r5,r5,#16
00000a  409d              LSLS     r5,r5,r3
00000c  43ac              BICS     r4,r4,r5
00000e  2501              MOVS     r5,#1
000010  408d              LSLS     r5,r5,r1
000012  432c              ORRS     r4,r4,r5
000014  409a              LSLS     r2,r2,r3
000016  4314              ORRS     r4,r4,r2
000018  6404              STR      r4,[r0,#0x40]
;;;623                      (PWM_PIER_PWMIE0_Msk << u32ChannelNum) | (u32IntPeriodType << (u32ChannelNum >> 1));
;;;624    }
00001a  bd30              POP      {r4,r5,pc}
;;;625    
                          ENDP


                          AREA ||i.PWM_ForceStop||, CODE, READONLY, ALIGN=1

                  PWM_ForceStop PROC
;;;272     */
;;;273    void PWM_ForceStop(PWM_T *pwm, uint32_t u32ChannelMask)
000000  b570              PUSH     {r4-r6,lr}
;;;274    {
;;;275        uint32_t u32Mask = 0, i;
000002  2300              MOVS     r3,#0
;;;276        for(i = 0; i < PWM_CHANNEL_NUM; i ++)
000004  461a              MOV      r2,r3
;;;277        {
;;;278            if(u32ChannelMask & (1 << i))
000006  2601              MOVS     r6,#1
                  |L21.8|
000008  4635              MOV      r5,r6
00000a  4095              LSLS     r5,r5,r2
00000c  4634              MOV      r4,r6
00000e  420d              TST      r5,r1
000010  d002              BEQ      |L21.24|
;;;279            {
;;;280                u32Mask |= (PWM_PCR_CH0EN_Msk << (i * 8));
000012  00d5              LSLS     r5,r2,#3
000014  40ac              LSLS     r4,r4,r5
000016  4323              ORRS     r3,r3,r4
                  |L21.24|
000018  1c52              ADDS     r2,r2,#1
00001a  2a04              CMP      r2,#4                 ;276
00001c  d3f4              BCC      |L21.8|
;;;281            }
;;;282        }
;;;283    
;;;284        (pwm)->PCR &= ~u32Mask;
00001e  6881              LDR      r1,[r0,#8]
000020  4399              BICS     r1,r1,r3
000022  6081              STR      r1,[r0,#8]
;;;285    }
000024  bd70              POP      {r4-r6,pc}
;;;286    
                          ENDP


                          AREA ||i.PWM_GetADCTriggerFlag||, CODE, READONLY, ALIGN=1

                  PWM_GetADCTriggerFlag PROC
;;;333     */
;;;334    uint32_t PWM_GetADCTriggerFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  3080              ADDS     r0,r0,#0x80
;;;335    {
;;;336        return (((pwm)->TSTATUS & (PWM_TSTATUS_PWM0TF_Msk << (u32ChannelNum))) ? 1 : 0);
000002  6840              LDR      r0,[r0,#4]
000004  2201              MOVS     r2,#1
000006  408a              LSLS     r2,r2,r1
000008  4010              ANDS     r0,r0,r2
00000a  d000              BEQ      |L22.14|
00000c  2001              MOVS     r0,#1
                  |L22.14|
;;;337    }
00000e  4770              BX       lr
;;;338    
                          ENDP


                          AREA ||i.PWM_GetCaptureIntFlag||, CODE, READONLY, ALIGN=1

                  PWM_GetCaptureIntFlag PROC
;;;541     */
;;;542    uint32_t PWM_GetCaptureIntFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  23c0              MOVS     r3,#0xc0
;;;543    {
;;;544        if(u32ChannelNum < 2)
;;;545        {
;;;546            return (((pwm)->CCR0 & ((PWM_CCR0_CRLRI0_Msk | PWM_CCR0_CFLRI0_Msk) << (u32ChannelNum * 16))) >> (PWM_CCR0_CRLRI0_Pos + u32ChannelNum * 16));
000002  010a              LSLS     r2,r1,#4
000004  2902              CMP      r1,#2                 ;544
000006  d204              BCS      |L23.18|
000008  6d00              LDR      r0,[r0,#0x50]
00000a  4093              LSLS     r3,r3,r2
00000c  4018              ANDS     r0,r0,r3
00000e  1d92              ADDS     r2,r2,#6
000010  e005              B        |L23.30|
                  |L23.18|
;;;547        }
;;;548        else
;;;549        {
;;;550            return (((pwm)->CCR2 & ((PWM_CCR2_CRLRI2_Msk | PWM_CCR2_CFLRI2_Msk) << ((u32ChannelNum - 2) * 16))) >> (PWM_CCR2_CRLRI2_Pos + (u32ChannelNum - 2) * 16));
000012  4611              MOV      r1,r2
000014  3920              SUBS     r1,r1,#0x20
000016  6d40              LDR      r0,[r0,#0x54]
000018  408b              LSLS     r3,r3,r1
00001a  4018              ANDS     r0,r0,r3
00001c  3a1a              SUBS     r2,r2,#0x1a
                  |L23.30|
00001e  40d0              LSRS     r0,r0,r2
;;;551        }
;;;552    
;;;553    }
000020  4770              BX       lr
;;;554    /**
                          ENDP


                          AREA ||i.PWM_GetDutyIntFlag||, CODE, READONLY, ALIGN=1

                  PWM_GetDutyIntFlag PROC
;;;603     */
;;;604    uint32_t PWM_GetDutyIntFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  6c40              LDR      r0,[r0,#0x44]
;;;605    {
;;;606        return (((pwm)->PIIR & (PWM_PIIR_PWMDIF0_Msk << u32ChannelNum)) ? 1 : 0);
000002  22ff              MOVS     r2,#0xff
000004  3201              ADDS     r2,#1
000006  408a              LSLS     r2,r2,r1
000008  4010              ANDS     r0,r0,r2
00000a  d000              BEQ      |L24.14|
00000c  2001              MOVS     r0,#1
                  |L24.14|
;;;607    }
00000e  4770              BX       lr
;;;608    
                          ENDP


                          AREA ||i.PWM_GetPeriodIntFlag||, CODE, READONLY, ALIGN=1

                  PWM_GetPeriodIntFlag PROC
;;;657     */
;;;658    uint32_t PWM_GetPeriodIntFlag(PWM_T *pwm, uint32_t u32ChannelNum)
000000  6c40              LDR      r0,[r0,#0x44]
;;;659    {
;;;660        return (((pwm)->PIIR & (PWM_PIIR_PWMIF0_Msk << (u32ChannelNum))) ? 1 : 0);
000002  2201              MOVS     r2,#1
000004  408a              LSLS     r2,r2,r1
000006  4010              ANDS     r0,r0,r2
000008  d000              BEQ      |L25.12|
00000a  2001              MOVS     r0,#1
                  |L25.12|
;;;661    }
00000c  4770              BX       lr
;;;662    
                          ENDP


                          AREA ||i.PWM_Start||, CODE, READONLY, ALIGN=1

                  PWM_Start PROC
;;;226     */
;;;227    void PWM_Start(PWM_T *pwm, uint32_t u32ChannelMask)
000000  b570              PUSH     {r4-r6,lr}
;;;228    {
;;;229        uint32_t u32Mask = 0, i;
000002  2300              MOVS     r3,#0
;;;230        for(i = 0; i < PWM_CHANNEL_NUM; i ++)
000004  461a              MOV      r2,r3
;;;231        {
;;;232            if(u32ChannelMask & (1 << i))
000006  2601              MOVS     r6,#1
                  |L26.8|
000008  4635              MOV      r5,r6
00000a  4095              LSLS     r5,r5,r2
00000c  4634              MOV      r4,r6
00000e  420d              TST      r5,r1
000010  d002              BEQ      |L26.24|
;;;233            {
;;;234                u32Mask |= (PWM_PCR_CH0EN_Msk << (i * 8));
000012  00d5              LSLS     r5,r2,#3
000014  40ac              LSLS     r4,r4,r5
000016  4323              ORRS     r3,r3,r4
                  |L26.24|
000018  1c52              ADDS     r2,r2,#1
00001a  2a04              CMP      r2,#4                 ;230
00001c  d3f4              BCC      |L26.8|
;;;235            }
;;;236        }
;;;237    
;;;238        (pwm)->PCR |= u32Mask;
00001e  6881              LDR      r1,[r0,#8]
000020  4319              ORRS     r1,r1,r3
000022  6081              STR      r1,[r0,#8]
;;;239    }
000024  bd70              POP      {r4-r6,pc}
;;;240    
                          ENDP


                          AREA ||i.PWM_Stop||, CODE, READONLY, ALIGN=1

                  PWM_Stop PROC
;;;250     */
;;;251    void PWM_Stop(PWM_T *pwm, uint32_t u32ChannelMask)
000000  b530              PUSH     {r4,r5,lr}
;;;252    {
;;;253        uint32_t i;
;;;254        for(i = 0; i < PWM_CHANNEL_NUM; i ++)
000002  2200              MOVS     r2,#0
;;;255        {
;;;256            if(u32ChannelMask & (1 << i))
000004  2501              MOVS     r5,#1
000006  4614              MOV      r4,r2
                  |L27.8|
000008  462b              MOV      r3,r5
00000a  4093              LSLS     r3,r3,r2
00000c  420b              TST      r3,r1
00000e  d003              BEQ      |L27.24|
;;;257            {
;;;258                *((__IO uint32_t *)((((uint32_t) & ((pwm)->CNR0)) + i * 12))) = 0;
000010  230c              MOVS     r3,#0xc
000012  4353              MULS     r3,r2,r3
000014  181b              ADDS     r3,r3,r0
000016  60dc              STR      r4,[r3,#0xc]
                  |L27.24|
000018  1c52              ADDS     r2,r2,#1
00001a  2a04              CMP      r2,#4                 ;254
00001c  d3f4              BCC      |L27.8|
;;;259            }
;;;260        }
;;;261    }
00001e  bd30              POP      {r4,r5,pc}
;;;262    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                          DCD      0x00b71b00
                          DCD      0x00008000
                          DCD      0x00000000
                          DCD      0x01518000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00002710
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000001
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000002
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000003
                          DCD      0x00b71b00
                          DCD      0x00008000
                          DCD      0x00000000
                          DCD      0x01518000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00002710
                          DCD      0x00000000
                          DCD      0x00000004
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000001
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000002
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000003

;*** Start embedded assembler ***

#line 1 "Libraries\\StdDriver\\src\\pwm.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_pwm_c_c4896a9e____REV16|
#line 118 ".\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___5_pwm_c_c4896a9e____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_pwm_c_c4896a9e____REVSH|
#line 132
|__asm___5_pwm_c_c4896a9e____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
