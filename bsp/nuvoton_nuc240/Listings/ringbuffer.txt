; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\ringbuffer.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\ringbuffer.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I.\Libraries\Device\Nuvoton -I..\..\components\finsh -I.\Libraries\CMSIS\Include -I.\Libraries\StdDriver\inc -I..\..\include -I.\APP -I.\Drivers -I..\..\components\drivers\include -I..\..\components\drivers\include\drivers -I..\nuvoton_nuc240 -I.\Libraries\Device\Nuvoton\NUC230_240\Include -I..\..\include -I..\..\components\drivers\usb\usbdevice\class -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=521 --omf_browse=.\objects\ringbuffer.crf ..\..\components\drivers\src\ringbuffer.c]
                          THUMB

                          AREA ||i.rt_ringbuffer_data_len||, CODE, READONLY, ALIGN=1

                  rt_ringbuffer_data_len PROC
;;;225    /** return the size of data in rb */
;;;226    rt_inline rt_uint16_t rt_ringbuffer_data_len(struct rt_ringbuffer *rb)
000000  b510              PUSH     {r4,lr}
;;;227    {
000002  4604              MOV      r4,r0
;;;228        switch (rt_ringbuffer_status(rb))
000004  f7fffffe          BL       rt_ringbuffer_status
000008  2800              CMP      r0,#0
00000a  d00b              BEQ      |L1.36|
00000c  2801              CMP      r0,#1
00000e  d00a              BEQ      |L1.38|
;;;229        {
;;;230        case RT_RINGBUFFER_EMPTY:
;;;231            return 0;
;;;232        case RT_RINGBUFFER_FULL:
;;;233            return rb->buffer_size;
;;;234        case RT_RINGBUFFER_HALFFULL:
;;;235        default:
;;;236            if (rb->write_index > rb->read_index)
000010  88e0              LDRH     r0,[r4,#6]
000012  0841              LSRS     r1,r0,#1
000014  88a0              LDRH     r0,[r4,#4]
000016  0840              LSRS     r0,r0,#1
000018  4281              CMP      r1,r0
00001a  d801              BHI      |L1.32|
;;;237                return rb->write_index - rb->read_index;
;;;238            else
;;;239                return rb->buffer_size - (rb->read_index - rb->write_index);
00001c  1a40              SUBS     r0,r0,r1
00001e  8921              LDRH     r1,[r4,#8]
                  |L1.32|
000020  1a08              SUBS     r0,r1,r0              ;237
000022  b280              UXTH     r0,r0                 ;237
                  |L1.36|
;;;240        };
;;;241    }
000024  bd10              POP      {r4,pc}
                  |L1.38|
000026  8920              LDRH     r0,[r4,#8]            ;233
000028  bd10              POP      {r4,pc}
;;;242    
                          ENDP


                          AREA ||i.rt_ringbuffer_get||, CODE, READONLY, ALIGN=1

                  rt_ringbuffer_get PROC
;;;149     */
;;;150    rt_size_t rt_ringbuffer_get(struct rt_ringbuffer *rb,
000000  b570              PUSH     {r4-r6,lr}
;;;151                                rt_uint8_t           *ptr,
;;;152                                rt_uint16_t           length)
;;;153    {
000002  4615              MOV      r5,r2
000004  460e              MOV      r6,r1
000006  4604              MOV      r4,r0
;;;154        rt_size_t size;
;;;155    
;;;156        RT_ASSERT(rb != RT_NULL);
;;;157    
;;;158        /* whether has enough data  */
;;;159        size = rt_ringbuffer_data_len(rb);
000008  f7fffffe          BL       rt_ringbuffer_data_len
;;;160    
;;;161        /* no data */
;;;162        if (size == 0)
00000c  2800              CMP      r0,#0
00000e  d031              BEQ      |L2.116|
;;;163            return 0;
;;;164    
;;;165        /* less data */
;;;166        if (size < length)
000010  42a8              CMP      r0,r5
000012  d200              BCS      |L2.22|
;;;167            length = size;
000014  4605              MOV      r5,r0
                  |L2.22|
;;;168    
;;;169        if (rb->buffer_size - rb->read_index > length)
000016  2108              MOVS     r1,#8
000018  88a0              LDRH     r0,[r4,#4]
00001a  5e61              LDRSH    r1,[r4,r1]
00001c  0840              LSRS     r0,r0,#1
00001e  1a0a              SUBS     r2,r1,r0
000020  6821              LDR      r1,[r4,#0]
000022  42aa              CMP      r2,r5
000024  dd0b              BLE      |L2.62|
;;;170        {
;;;171            /* copy all of data */
;;;172            memcpy(ptr, &rb->buffer_ptr[rb->read_index], length);
000026  1809              ADDS     r1,r1,r0
000028  462a              MOV      r2,r5
00002a  4630              MOV      r0,r6
00002c  f7fffffe          BL       __aeabi_memcpy
;;;173            /* this should not cause overflow because there is enough space for
;;;174             * length of data in current mirror */
;;;175            rb->read_index += length;
000030  88a0              LDRH     r0,[r4,#4]
000032  07c1              LSLS     r1,r0,#31
000034  0840              LSRS     r0,r0,#1
000036  0fc9              LSRS     r1,r1,#31
000038  1940              ADDS     r0,r0,r5
00003a  0040              LSLS     r0,r0,#1
;;;176            return length;
00003c  e017              B        |L2.110|
                  |L2.62|
;;;177        }
;;;178    
;;;179        memcpy(&ptr[0],
00003e  1809              ADDS     r1,r1,r0
000040  4630              MOV      r0,r6
000042  f7fffffe          BL       __aeabi_memcpy
;;;180               &rb->buffer_ptr[rb->read_index],
;;;181               rb->buffer_size - rb->read_index);
;;;182        memcpy(&ptr[rb->buffer_size - rb->read_index],
000046  2008              MOVS     r0,#8
000048  88a1              LDRH     r1,[r4,#4]
00004a  5e20              LDRSH    r0,[r4,r0]
00004c  0849              LSRS     r1,r1,#1
00004e  1a40              SUBS     r0,r0,r1
000050  1a2a              SUBS     r2,r5,r0
000052  1980              ADDS     r0,r0,r6
000054  6821              LDR      r1,[r4,#0]
000056  f7fffffe          BL       __aeabi_memcpy
;;;183               &rb->buffer_ptr[0],
;;;184               length - (rb->buffer_size - rb->read_index));
;;;185    
;;;186        /* we are going into the other side of the mirror */
;;;187        rb->read_mirror = ~rb->read_mirror;
00005a  88a0              LDRH     r0,[r4,#4]
00005c  2101              MOVS     r1,#1
00005e  4048              EORS     r0,r0,r1
;;;188        rb->read_index = length - (rb->buffer_size - rb->read_index);
000060  8921              LDRH     r1,[r4,#8]
000062  0842              LSRS     r2,r0,#1
000064  1a89              SUBS     r1,r1,r2
000066  1a69              SUBS     r1,r5,r1
000068  0049              LSLS     r1,r1,#1
00006a  07c0              LSLS     r0,r0,#31
00006c  0fc0              LSRS     r0,r0,#31
                  |L2.110|
00006e  4301              ORRS     r1,r1,r0
000070  80a1              STRH     r1,[r4,#4]
;;;189    
;;;190        return length;
000072  4628              MOV      r0,r5
                  |L2.116|
;;;191    }
000074  bd70              POP      {r4-r6,pc}
;;;192    RTM_EXPORT(rt_ringbuffer_get);
                          ENDP


                          AREA ||i.rt_ringbuffer_getchar||, CODE, READONLY, ALIGN=1

                  rt_ringbuffer_getchar PROC
;;;261     */
;;;262    rt_size_t rt_ringbuffer_getchar(struct rt_ringbuffer *rb, rt_uint8_t *ch)
000000  b570              PUSH     {r4-r6,lr}
;;;263    {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;264        RT_ASSERT(rb != RT_NULL);
;;;265    
;;;266        /* ringbuffer is empty */
;;;267        if (!rt_ringbuffer_data_len(rb))
000006  f7fffffe          BL       rt_ringbuffer_data_len
00000a  2800              CMP      r0,#0
00000c  d016              BEQ      |L3.60|
;;;268            return 0;
;;;269    
;;;270        /* put character */
;;;271        *ch = rb->buffer_ptr[rb->read_index];
00000e  88a1              LDRH     r1,[r4,#4]
000010  6820              LDR      r0,[r4,#0]
000012  0849              LSRS     r1,r1,#1
000014  5c40              LDRB     r0,[r0,r1]
000016  7028              STRB     r0,[r5,#0]
;;;272    
;;;273        if (rb->read_index == rb->buffer_size-1)
000018  2208              MOVS     r2,#8
00001a  88a0              LDRH     r0,[r4,#4]
00001c  5ea2              LDRSH    r2,[r4,r2]
00001e  0841              LSRS     r1,r0,#1
000020  1e52              SUBS     r2,r2,#1
000022  4291              CMP      r1,r2
000024  d103              BNE      |L3.46|
;;;274        {
;;;275            rb->read_mirror = ~rb->read_mirror;
000026  2101              MOVS     r1,#1
000028  4048              EORS     r0,r0,r1
;;;276            rb->read_index = 0;
00002a  4008              ANDS     r0,r0,r1
00002c  e004              B        |L3.56|
                  |L3.46|
;;;277        }
;;;278        else
;;;279        {
;;;280            rb->read_index++;
00002e  07c0              LSLS     r0,r0,#31
000030  0fc0              LSRS     r0,r0,#31
000032  1c49              ADDS     r1,r1,#1
000034  0049              LSLS     r1,r1,#1
000036  4308              ORRS     r0,r0,r1
                  |L3.56|
000038  80a0              STRH     r0,[r4,#4]
;;;281        }
;;;282    
;;;283        return 1;
00003a  2001              MOVS     r0,#1
                  |L3.60|
;;;284    }
00003c  bd70              POP      {r4-r6,pc}
;;;285    RTM_EXPORT(rt_ringbuffer_getchar);
                          ENDP


                          AREA ||i.rt_ringbuffer_init||, CODE, READONLY, ALIGN=1

                  rt_ringbuffer_init PROC
;;;29     
;;;30     void rt_ringbuffer_init(struct rt_ringbuffer *rb,
000000  2300              MOVS     r3,#0
;;;31                             rt_uint8_t           *pool,
;;;32                             rt_int16_t            size)
;;;33     {
;;;34         RT_ASSERT(rb != RT_NULL);
;;;35         RT_ASSERT(size > 0)
;;;36     
;;;37         /* initialize read and write index */
;;;38         rb->read_mirror = rb->read_index = 0;
000002  8083              STRH     r3,[r0,#4]
;;;39         rb->write_mirror = rb->write_index = 0;
000004  80c3              STRH     r3,[r0,#6]
;;;40     
;;;41         /* set buffer pool and size */
;;;42         rb->buffer_ptr = pool;
;;;43         rb->buffer_size = RT_ALIGN_DOWN(size, RT_ALIGN_SIZE);
000006  6001              STR      r1,[r0,#0]
000008  0891              LSRS     r1,r2,#2
00000a  0089              LSLS     r1,r1,#2
00000c  8101              STRH     r1,[r0,#8]
;;;44     }
00000e  4770              BX       lr
;;;45     RTM_EXPORT(rt_ringbuffer_init);
                          ENDP


                          AREA ||i.rt_ringbuffer_put||, CODE, READONLY, ALIGN=1

                  rt_ringbuffer_put PROC
;;;49      */
;;;50     rt_size_t rt_ringbuffer_put(struct rt_ringbuffer *rb,
000000  b570              PUSH     {r4-r6,lr}
;;;51                                 const rt_uint8_t     *ptr,
;;;52                                 rt_uint16_t           length)
;;;53     {
000002  4615              MOV      r5,r2
000004  460e              MOV      r6,r1
000006  4604              MOV      r4,r0
;;;54         rt_uint16_t size;
;;;55     
;;;56         RT_ASSERT(rb != RT_NULL);
;;;57     
;;;58         /* whether has enough space */
;;;59         size = rt_ringbuffer_space_len(rb);
000008  f7fffffe          BL       rt_ringbuffer_data_len
00000c  2108              MOVS     r1,#8
00000e  5e61              LDRSH    r1,[r4,r1]
000010  1a08              SUBS     r0,r1,r0
000012  0400              LSLS     r0,r0,#16
000014  0c00              LSRS     r0,r0,#16
;;;60     
;;;61         /* no space */
;;;62         if (size == 0)
000016  d02f              BEQ      |L5.120|
;;;63             return 0;
;;;64     
;;;65         /* drop some data */
;;;66         if (size < length)
000018  42a8              CMP      r0,r5
00001a  d200              BCS      |L5.30|
;;;67             length = size;
00001c  4605              MOV      r5,r0
                  |L5.30|
;;;68     
;;;69         if (rb->buffer_size - rb->write_index > length)
00001e  88e0              LDRH     r0,[r4,#6]
000020  0840              LSRS     r0,r0,#1
000022  1a0a              SUBS     r2,r1,r0
000024  6821              LDR      r1,[r4,#0]
000026  42aa              CMP      r2,r5
000028  dd0b              BLE      |L5.66|
;;;70         {
;;;71             /* read_index - write_index = empty space */
;;;72             memcpy(&rb->buffer_ptr[rb->write_index], ptr, length);
00002a  1808              ADDS     r0,r1,r0
00002c  462a              MOV      r2,r5
00002e  4631              MOV      r1,r6
000030  f7fffffe          BL       __aeabi_memcpy
;;;73             /* this should not cause overflow because there is enough space for
;;;74              * length of data in current mirror */
;;;75             rb->write_index += length;
000034  88e0              LDRH     r0,[r4,#6]
000036  07c1              LSLS     r1,r0,#31
000038  0840              LSRS     r0,r0,#1
00003a  0fc9              LSRS     r1,r1,#31
00003c  1940              ADDS     r0,r0,r5
00003e  0040              LSLS     r0,r0,#1
;;;76             return length;
000040  e017              B        |L5.114|
                  |L5.66|
;;;77         }
;;;78     
;;;79         memcpy(&rb->buffer_ptr[rb->write_index],
000042  1808              ADDS     r0,r1,r0
000044  4631              MOV      r1,r6
000046  f7fffffe          BL       __aeabi_memcpy
;;;80                &ptr[0],
;;;81                rb->buffer_size - rb->write_index);
;;;82         memcpy(&rb->buffer_ptr[0],
00004a  2008              MOVS     r0,#8
00004c  88e1              LDRH     r1,[r4,#6]
00004e  5e20              LDRSH    r0,[r4,r0]
000050  0849              LSRS     r1,r1,#1
000052  1a40              SUBS     r0,r0,r1
000054  1a2a              SUBS     r2,r5,r0
000056  1981              ADDS     r1,r0,r6
000058  6820              LDR      r0,[r4,#0]
00005a  f7fffffe          BL       __aeabi_memcpy
;;;83                &ptr[rb->buffer_size - rb->write_index],
;;;84                length - (rb->buffer_size - rb->write_index));
;;;85     
;;;86         /* we are going into the other side of the mirror */
;;;87         rb->write_mirror = ~rb->write_mirror;
00005e  88e0              LDRH     r0,[r4,#6]
000060  2101              MOVS     r1,#1
000062  4048              EORS     r0,r0,r1
;;;88         rb->write_index = length - (rb->buffer_size - rb->write_index);
000064  8921              LDRH     r1,[r4,#8]
000066  0842              LSRS     r2,r0,#1
000068  1a89              SUBS     r1,r1,r2
00006a  1a69              SUBS     r1,r5,r1
00006c  0049              LSLS     r1,r1,#1
00006e  07c0              LSLS     r0,r0,#31
000070  0fc0              LSRS     r0,r0,#31
                  |L5.114|
000072  4301              ORRS     r1,r1,r0
000074  80e1              STRH     r1,[r4,#6]
;;;89     
;;;90         return length;
000076  4628              MOV      r0,r5
                  |L5.120|
;;;91     }
000078  bd70              POP      {r4-r6,pc}
;;;92     RTM_EXPORT(rt_ringbuffer_put);
                          ENDP


                          AREA ||i.rt_ringbuffer_put_force||, CODE, READONLY, ALIGN=1

                  rt_ringbuffer_put_force PROC
;;;98      */
;;;99     rt_size_t rt_ringbuffer_put_force(struct rt_ringbuffer *rb,
000000  b5f8              PUSH     {r3-r7,lr}
;;;100                                const rt_uint8_t     *ptr,
;;;101                                rt_uint16_t           length)
;;;102    {
000002  4615              MOV      r5,r2
000004  460f              MOV      r7,r1
000006  4604              MOV      r4,r0
;;;103        rt_uint16_t space_length;
;;;104    
;;;105        RT_ASSERT(rb != RT_NULL);
;;;106    
;;;107        space_length = rt_ringbuffer_space_len(rb);
000008  f7fffffe          BL       rt_ringbuffer_data_len
00000c  2108              MOVS     r1,#8
00000e  5e61              LDRSH    r1,[r4,r1]
000010  1a08              SUBS     r0,r1,r0
000012  b286              UXTH     r6,r0
;;;108    
;;;109        if (length > space_length)
000014  42b5              CMP      r5,r6
000016  d900              BLS      |L6.26|
;;;110            length = rb->buffer_size;
000018  8925              LDRH     r5,[r4,#8]
                  |L6.26|
;;;111    
;;;112        if (rb->buffer_size - rb->write_index > length)
00001a  88e0              LDRH     r0,[r4,#6]
00001c  0840              LSRS     r0,r0,#1
00001e  1a0a              SUBS     r2,r1,r0
000020  6821              LDR      r1,[r4,#0]
000022  42aa              CMP      r2,r5
000024  dd17              BLE      |L6.86|
;;;113        {
;;;114            /* read_index - write_index = empty space */
;;;115            memcpy(&rb->buffer_ptr[rb->write_index], ptr, length);
000026  1808              ADDS     r0,r1,r0
000028  462a              MOV      r2,r5
00002a  4639              MOV      r1,r7
00002c  f7fffffe          BL       __aeabi_memcpy
;;;116            /* this should not cause overflow because there is enough space for
;;;117             * length of data in current mirror */
;;;118            rb->write_index += length;
000030  88e1              LDRH     r1,[r4,#6]
000032  07c8              LSLS     r0,r1,#31
000034  0849              LSRS     r1,r1,#1
000036  1949              ADDS     r1,r1,r5
000038  0449              LSLS     r1,r1,#17
00003a  0fc0              LSRS     r0,r0,#31
00003c  0c09              LSRS     r1,r1,#16
00003e  4308              ORRS     r0,r0,r1
000040  80e0              STRH     r0,[r4,#6]
;;;119    
;;;120            if (length > space_length)
000042  42b5              CMP      r5,r6
000044  d929              BLS      |L6.154|
;;;121                rb->read_index = rb->write_index;
000046  7921              LDRB     r1,[r4,#4]
000048  0840              LSRS     r0,r0,#1
00004a  07c9              LSLS     r1,r1,#31
00004c  0fc9              LSRS     r1,r1,#31
00004e  0040              LSLS     r0,r0,#1
000050  4301              ORRS     r1,r1,r0
000052  80a1              STRH     r1,[r4,#4]
000054  e021              B        |L6.154|
                  |L6.86|
;;;122    
;;;123            return length;
;;;124        }
;;;125    
;;;126        memcpy(&rb->buffer_ptr[rb->write_index],
000056  1808              ADDS     r0,r1,r0
000058  4639              MOV      r1,r7
00005a  f7fffffe          BL       __aeabi_memcpy
;;;127               &ptr[0],
;;;128               rb->buffer_size - rb->write_index);
;;;129        memcpy(&rb->buffer_ptr[0],
00005e  2008              MOVS     r0,#8
000060  88e1              LDRH     r1,[r4,#6]
000062  5e20              LDRSH    r0,[r4,r0]
000064  0849              LSRS     r1,r1,#1
000066  1a40              SUBS     r0,r0,r1
000068  1a2a              SUBS     r2,r5,r0
00006a  19c1              ADDS     r1,r0,r7
00006c  6820              LDR      r0,[r4,#0]
00006e  f7fffffe          BL       __aeabi_memcpy
;;;130               &ptr[rb->buffer_size - rb->write_index],
;;;131               length - (rb->buffer_size - rb->write_index));
;;;132    
;;;133        /* we are going into the other side of the mirror */
;;;134        rb->write_mirror = ~rb->write_mirror;
000072  88e0              LDRH     r0,[r4,#6]
000074  2201              MOVS     r2,#1
000076  4050              EORS     r0,r0,r2
;;;135        rb->write_index = length - (rb->buffer_size - rb->write_index);
000078  8921              LDRH     r1,[r4,#8]
00007a  0843              LSRS     r3,r0,#1
00007c  1ac9              SUBS     r1,r1,r3
00007e  1a69              SUBS     r1,r5,r1
000080  0449              LSLS     r1,r1,#17
000082  0c09              LSRS     r1,r1,#16
000084  4010              ANDS     r0,r0,r2
000086  4301              ORRS     r1,r1,r0
000088  80e1              STRH     r1,[r4,#6]
;;;136    
;;;137        if (length > space_length)
00008a  42b5              CMP      r5,r6
00008c  d905              BLS      |L6.154|
;;;138        {
;;;139            rb->read_mirror = ~rb->read_mirror;
00008e  7920              LDRB     r0,[r4,#4]
;;;140            rb->read_index = rb->write_index;
000090  4391              BICS     r1,r1,r2
000092  4050              EORS     r0,r0,r2              ;139
000094  4010              ANDS     r0,r0,r2
000096  4308              ORRS     r0,r0,r1
000098  80a0              STRH     r0,[r4,#4]
                  |L6.154|
;;;141        }
;;;142    
;;;143        return length;
00009a  4628              MOV      r0,r5
;;;144    }
00009c  bdf8              POP      {r3-r7,pc}
;;;145    RTM_EXPORT(rt_ringbuffer_put_force);
                          ENDP


                          AREA ||i.rt_ringbuffer_putchar||, CODE, READONLY, ALIGN=1

                  rt_ringbuffer_putchar PROC
;;;196     */
;;;197    rt_size_t rt_ringbuffer_putchar(struct rt_ringbuffer *rb, const rt_uint8_t ch)
000000  b570              PUSH     {r4-r6,lr}
;;;198    {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;199        RT_ASSERT(rb != RT_NULL);
;;;200    
;;;201        /* whether has enough space */
;;;202        if (!rt_ringbuffer_space_len(rb))
000006  f7fffffe          BL       rt_ringbuffer_data_len
00000a  2108              MOVS     r1,#8
00000c  5e61              LDRSH    r1,[r4,r1]
00000e  4288              CMP      r0,r1
000010  d101              BNE      |L7.22|
;;;203            return 0;
000012  2000              MOVS     r0,#0
;;;204    
;;;205        rb->buffer_ptr[rb->write_index] = ch;
;;;206    
;;;207        /* flip mirror */
;;;208        if (rb->write_index == rb->buffer_size-1)
;;;209        {
;;;210            rb->write_mirror = ~rb->write_mirror;
;;;211            rb->write_index = 0;
;;;212        }
;;;213        else
;;;214        {
;;;215            rb->write_index++;
;;;216        }
;;;217    
;;;218        return 1;
;;;219    }
000014  bd70              POP      {r4-r6,pc}
                  |L7.22|
000016  88e1              LDRH     r1,[r4,#6]            ;205
000018  6820              LDR      r0,[r4,#0]            ;205
00001a  0849              LSRS     r1,r1,#1              ;205
00001c  5445              STRB     r5,[r0,r1]            ;205
00001e  2208              MOVS     r2,#8                 ;208
000020  88e0              LDRH     r0,[r4,#6]            ;208
000022  5ea2              LDRSH    r2,[r4,r2]            ;208
000024  0841              LSRS     r1,r0,#1              ;208
000026  1e52              SUBS     r2,r2,#1              ;208
000028  4291              CMP      r1,r2                 ;208
00002a  d103              BNE      |L7.52|
00002c  2101              MOVS     r1,#1                 ;210
00002e  4048              EORS     r0,r0,r1              ;210
000030  4008              ANDS     r0,r0,r1              ;211
000032  e004              B        |L7.62|
                  |L7.52|
000034  07c0              LSLS     r0,r0,#31             ;215
000036  0fc0              LSRS     r0,r0,#31             ;215
000038  1c49              ADDS     r1,r1,#1              ;215
00003a  0049              LSLS     r1,r1,#1              ;215
00003c  4308              ORRS     r0,r0,r1              ;215
                  |L7.62|
00003e  80e0              STRH     r0,[r4,#6]            ;215
000040  2001              MOVS     r0,#1                 ;218
000042  bd70              POP      {r4-r6,pc}
;;;220    RTM_EXPORT(rt_ringbuffer_putchar);
                          ENDP


                          AREA ||i.rt_ringbuffer_putchar_force||, CODE, READONLY, ALIGN=1

                  rt_ringbuffer_putchar_force PROC
;;;226     */
;;;227    rt_size_t rt_ringbuffer_putchar_force(struct rt_ringbuffer *rb, const rt_uint8_t ch)
000000  b570              PUSH     {r4-r6,lr}
;;;228    {
000002  460d              MOV      r5,r1
000004  4604              MOV      r4,r0
;;;229        enum rt_ringbuffer_state old_state;
;;;230    
;;;231        RT_ASSERT(rb != RT_NULL);
;;;232    
;;;233        old_state = rt_ringbuffer_status(rb);
000006  f7fffffe          BL       rt_ringbuffer_status
00000a  4602              MOV      r2,r0
;;;234    
;;;235        rb->buffer_ptr[rb->write_index] = ch;
00000c  88e1              LDRH     r1,[r4,#6]
00000e  6820              LDR      r0,[r4,#0]
000010  0849              LSRS     r1,r1,#1
000012  5445              STRB     r5,[r0,r1]
;;;236    
;;;237        /* flip mirror */
;;;238        if (rb->write_index == rb->buffer_size-1)
000014  2308              MOVS     r3,#8
000016  88e0              LDRH     r0,[r4,#6]
000018  5ee3              LDRSH    r3,[r4,r3]
00001a  0841              LSRS     r1,r0,#1
00001c  1e5b              SUBS     r3,r3,#1
00001e  4299              CMP      r1,r3
000020  d10a              BNE      |L8.56|
;;;239        {
;;;240            rb->write_mirror = ~rb->write_mirror;
000022  2101              MOVS     r1,#1
000024  4048              EORS     r0,r0,r1
;;;241            rb->write_index = 0;
000026  4008              ANDS     r0,r0,r1
000028  80e0              STRH     r0,[r4,#6]
;;;242            if (old_state == RT_RINGBUFFER_FULL)
00002a  2a01              CMP      r2,#1
00002c  d112              BNE      |L8.84|
;;;243            {
;;;244                rb->read_mirror = ~rb->read_mirror;
00002e  7920              LDRB     r0,[r4,#4]
000030  4048              EORS     r0,r0,r1
;;;245                rb->read_index = rb->write_index;
000032  4008              ANDS     r0,r0,r1
000034  80a0              STRH     r0,[r4,#4]
000036  e00d              B        |L8.84|
                  |L8.56|
;;;246            }
;;;247        }
;;;248        else
;;;249        {
;;;250            rb->write_index++;
000038  1c49              ADDS     r1,r1,#1
00003a  07c0              LSLS     r0,r0,#31
00003c  0449              LSLS     r1,r1,#17
00003e  0fc0              LSRS     r0,r0,#31
000040  0c09              LSRS     r1,r1,#16
000042  4308              ORRS     r0,r0,r1
000044  80e0              STRH     r0,[r4,#6]
;;;251            if (old_state == RT_RINGBUFFER_FULL)
000046  2a01              CMP      r2,#1
000048  d104              BNE      |L8.84|
;;;252                rb->read_index = rb->write_index;
00004a  7921              LDRB     r1,[r4,#4]
00004c  4390              BICS     r0,r0,r2
00004e  4011              ANDS     r1,r1,r2
000050  4301              ORRS     r1,r1,r0
000052  80a1              STRH     r1,[r4,#4]
                  |L8.84|
;;;253        }
;;;254    
;;;255        return 1;
000054  2001              MOVS     r0,#1
;;;256    }
000056  bd70              POP      {r4-r6,pc}
;;;257    RTM_EXPORT(rt_ringbuffer_putchar_force);
                          ENDP


                          AREA ||i.rt_ringbuffer_status||, CODE, READONLY, ALIGN=1

                  rt_ringbuffer_status PROC
;;;212    rt_inline enum rt_ringbuffer_state
;;;213    rt_ringbuffer_status(struct rt_ringbuffer *rb)
000000  8881              LDRH     r1,[r0,#4]
;;;214    {
;;;215        if (rb->read_index == rb->write_index)
000002  88c0              LDRH     r0,[r0,#6]
000004  084a              LSRS     r2,r1,#1
000006  0843              LSRS     r3,r0,#1
000008  429a              CMP      r2,r3
00000a  d109              BNE      |L9.32|
;;;216        {
;;;217            if (rb->read_mirror == rb->write_mirror)
00000c  07c9              LSLS     r1,r1,#31
00000e  07c0              LSLS     r0,r0,#31
000010  0fc9              LSRS     r1,r1,#31
000012  0fc0              LSRS     r0,r0,#31
000014  4281              CMP      r1,r0
000016  d101              BNE      |L9.28|
;;;218                return RT_RINGBUFFER_EMPTY;
000018  2000              MOVS     r0,#0
;;;219            else
;;;220                return RT_RINGBUFFER_FULL;
;;;221        }
;;;222        return RT_RINGBUFFER_HALFFULL;
;;;223    }
00001a  4770              BX       lr
                  |L9.28|
00001c  2001              MOVS     r0,#1                 ;220
00001e  4770              BX       lr
                  |L9.32|
000020  2002              MOVS     r0,#2                 ;222
000022  4770              BX       lr
;;;224    
                          ENDP

