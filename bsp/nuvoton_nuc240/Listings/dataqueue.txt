; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\dataqueue.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\dataqueue.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I.\Libraries\Device\Nuvoton -I..\..\components\finsh -I.\Libraries\CMSIS\Include -I.\Libraries\StdDriver\inc -I..\..\include -I.\APP -I.\Drivers -I..\..\components\drivers\include -I..\..\components\drivers\include\drivers -I..\nuvoton_nuc240 -I.\Libraries\Device\Nuvoton\NUC230_240\Include -I..\..\include -I..\..\components\drivers\usb\usbdevice\class -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=521 --omf_browse=.\objects\dataqueue.crf ..\..\components\drivers\src\dataqueue.c]
                          THUMB

                          AREA ||i.rt_data_queue_init||, CODE, READONLY, ALIGN=1

                  rt_data_queue_init PROC
;;;36     rt_err_t
;;;37     rt_data_queue_init(struct rt_data_queue *queue,
000000  b510              PUSH     {r4,lr}
;;;38                        rt_uint16_t size,
;;;39                        rt_uint16_t lwm,
;;;40                        void (*evt_notify)(struct rt_data_queue *queue, rt_uint32_t event))
;;;41     {
;;;42         RT_ASSERT(queue != RT_NULL);
;;;43     
;;;44         queue->evt_notify = evt_notify;
;;;45     
;;;46         queue->size = size;
000002  61c3              STR      r3,[r0,#0x1c]
000004  8001              STRH     r1,[r0,#0]
000006  4604              MOV      r4,r0                 ;41
;;;47         queue->lwm = lwm;
000008  8042              STRH     r2,[r0,#2]
;;;48     
;;;49         queue->get_index = 0;
00000a  2000              MOVS     r0,#0
00000c  80a0              STRH     r0,[r4,#4]
;;;50         queue->put_index = 0;
00000e  80e0              STRH     r0,[r4,#6]
;;;51     
;;;52         rt_list_init(&(queue->suspended_push_list));
000010  4620              MOV      r0,r4
000012  300c              ADDS     r0,r0,#0xc
000014  6120              STR      r0,[r4,#0x10]
;;;53         rt_list_init(&(queue->suspended_pop_list));
000016  60e0              STR      r0,[r4,#0xc]
000018  3008              ADDS     r0,r0,#8
00001a  61a0              STR      r0,[r4,#0x18]
;;;54     
;;;55         queue->queue = (struct rt_data_item *)rt_malloc(sizeof(struct rt_data_item) * size);
00001c  6160              STR      r0,[r4,#0x14]
00001e  00c8              LSLS     r0,r1,#3
000020  f7fffffe          BL       rt_malloc
;;;56         if (queue->queue == RT_NULL)
000024  60a0              STR      r0,[r4,#8]
000026  2800              CMP      r0,#0
000028  d001              BEQ      |L1.46|
;;;57         {
;;;58             return -RT_ENOMEM;
;;;59         }
;;;60     
;;;61         return RT_EOK;
00002a  2000              MOVS     r0,#0
;;;62     }
00002c  bd10              POP      {r4,pc}
                  |L1.46|
00002e  2004              MOVS     r0,#4                 ;58
000030  43c0              MVNS     r0,r0                 ;58
000032  bd10              POP      {r4,pc}
;;;63     RTM_EXPORT(rt_data_queue_init);
                          ENDP


                          AREA ||i.rt_data_queue_peak||, CODE, READONLY, ALIGN=1

                  rt_data_queue_peak PROC
;;;255    
;;;256    rt_err_t rt_data_queue_peak(struct rt_data_queue *queue,
000000  b5f8              PUSH     {r3-r7,lr}
;;;257                                const void** data_ptr,
;;;258                                rt_size_t *size)
;;;259    {
000002  4616              MOV      r6,r2
000004  460f              MOV      r7,r1
000006  4604              MOV      r4,r0
;;;260        rt_ubase_t  level;
;;;261    
;;;262        RT_ASSERT(queue != RT_NULL);
;;;263    
;;;264        level = rt_hw_interrupt_disable();
000008  f7fffffe          BL       rt_hw_interrupt_disable
00000c  4605              MOV      r5,r0
;;;265    
;;;266        if (queue->get_index == queue->put_index) 
00000e  88a0              LDRH     r0,[r4,#4]
000010  88e1              LDRH     r1,[r4,#6]
000012  4288              CMP      r0,r1
000014  d105              BNE      |L2.34|
;;;267        {
;;;268            rt_hw_interrupt_enable(level);
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       rt_hw_interrupt_enable
;;;269            
;;;270            return -RT_EEMPTY;
00001c  2003              MOVS     r0,#3
00001e  43c0              MVNS     r0,r0
;;;271        }
;;;272    
;;;273        *data_ptr = queue->queue[queue->get_index % queue->size].data_ptr;
;;;274        *size     = queue->queue[queue->get_index % queue->size].data_size;
;;;275    
;;;276        rt_hw_interrupt_enable(level);
;;;277    
;;;278        return RT_EOK;
;;;279    }
000020  bdf8              POP      {r3-r7,pc}
                  |L2.34|
000022  8821              LDRH     r1,[r4,#0]            ;273
000024  f7fffffe          BL       __aeabi_uidivmod
000028  00c8              LSLS     r0,r1,#3              ;273
00002a  68a1              LDR      r1,[r4,#8]            ;273
00002c  5808              LDR      r0,[r1,r0]            ;273
00002e  6038              STR      r0,[r7,#0]            ;274
000030  8821              LDRH     r1,[r4,#0]            ;274
000032  88a0              LDRH     r0,[r4,#4]            ;274
000034  f7fffffe          BL       __aeabi_uidivmod
000038  00c8              LSLS     r0,r1,#3              ;274
00003a  68a1              LDR      r1,[r4,#8]            ;274
00003c  1d00              ADDS     r0,r0,#4              ;274
00003e  5808              LDR      r0,[r1,r0]            ;274
000040  6030              STR      r0,[r6,#0]            ;276
000042  4628              MOV      r0,r5                 ;276
000044  f7fffffe          BL       rt_hw_interrupt_enable
000048  2000              MOVS     r0,#0                 ;278
00004a  bdf8              POP      {r3-r7,pc}
;;;280    RTM_EXPORT(rt_data_queue_peak);
                          ENDP


                          AREA ||i.rt_data_queue_pop||, CODE, READONLY, ALIGN=1

                  rt_data_queue_pop PROC
;;;153    
;;;154    rt_err_t rt_data_queue_pop(struct rt_data_queue *queue,
000000  b5ff              PUSH     {r0-r7,lr}
;;;155                               const void** data_ptr,
;;;156                               rt_size_t *size, 
;;;157                               rt_int32_t timeout)
;;;158    {
000002  b085              SUB      sp,sp,#0x14
000004  4604              MOV      r4,r0
;;;159        rt_ubase_t  level;
;;;160        rt_thread_t thread;
;;;161        rt_err_t    result;
;;;162    
;;;163        RT_ASSERT(queue != RT_NULL);
;;;164        RT_ASSERT(data_ptr != RT_NULL);
;;;165        RT_ASSERT(size != RT_NULL);
;;;166    
;;;167        result = RT_EOK;
000006  2500              MOVS     r5,#0
;;;168        thread = rt_thread_self();
000008  f7fffffe          BL       rt_thread_self
00000c  4606              MOV      r6,r0
;;;169    
;;;170        level = rt_hw_interrupt_disable();
00000e  f7fffffe          BL       rt_hw_interrupt_disable
;;;171        while (queue->get_index == queue->put_index)
;;;172        {
;;;173            /* queue is empty */
;;;174            if (timeout == 0)
;;;175            {
;;;176                result = -RT_ETIMEOUT;
;;;177                goto __exit;
;;;178            }
;;;179    
;;;180            /* current context checking */
;;;181            RT_DEBUG_NOT_IN_INTERRUPT;
;;;182    
;;;183            /* reset thread error number */
;;;184            thread->error = RT_EOK;
;;;185            
;;;186            /* suspend thread on the pop list */
;;;187            rt_thread_suspend(thread);
;;;188            rt_list_insert_before(&(queue->suspended_pop_list), &(thread->tlist));
000012  9000              STR      r0,[sp,#0]
000014  4630              MOV      r0,r6
000016  3014              ADDS     r0,r0,#0x14
000018  9001              STR      r0,[sp,#4]
00001a  4620              MOV      r0,r4
00001c  3014              ADDS     r0,r0,#0x14
;;;189            /* start timer */
;;;190            if (timeout > 0)
;;;191            {
;;;192                /* reset the timeout of thread timer and start it */
;;;193                rt_timer_control(&(thread->thread_timer),
00001e  9002              STR      r0,[sp,#8]
000020  2700              MOVS     r7,#0                 ;170
000022  4630              MOV      r0,r6
000024  304c              ADDS     r0,r0,#0x4c
000026  9003              STR      r0,[sp,#0xc]          ;171
000028  e024              B        |L3.116|
                  |L3.42|
00002a  9808              LDR      r0,[sp,#0x20]         ;174
00002c  2800              CMP      r0,#0                 ;174
00002e  d01e              BEQ      |L3.110|
000030  4630              MOV      r0,r6                 ;187
000032  6337              STR      r7,[r6,#0x30]         ;187
000034  f7fffffe          BL       rt_thread_suspend
000038  9901              LDR      r1,[sp,#4]            ;188
00003a  9802              LDR      r0,[sp,#8]            ;188
00003c  f7fffffe          BL       rt_list_insert_before
000040  9808              LDR      r0,[sp,#0x20]         ;190
000042  2800              CMP      r0,#0                 ;190
000044  dd07              BLE      |L3.86|
000046  aa08              ADD      r2,sp,#0x20
000048  2100              MOVS     r1,#0
00004a  9803              LDR      r0,[sp,#0xc]
00004c  f7fffffe          BL       rt_timer_control
;;;194                                 RT_TIMER_CTRL_SET_TIME,
;;;195                                 &timeout);
;;;196                rt_timer_start(&(thread->thread_timer));
000050  9803              LDR      r0,[sp,#0xc]
000052  f7fffffe          BL       rt_timer_start
                  |L3.86|
;;;197            }
;;;198    
;;;199            /* enable interrupt */
;;;200            rt_hw_interrupt_enable(level);
000056  9800              LDR      r0,[sp,#0]
000058  f7fffffe          BL       rt_hw_interrupt_enable
;;;201    
;;;202            /* do schedule */
;;;203            rt_schedule();
00005c  f7fffffe          BL       rt_schedule
;;;204    
;;;205            /* thread is waked up */
;;;206            result = thread->error;
;;;207            level  = rt_hw_interrupt_disable();
000060  6b35              LDR      r5,[r6,#0x30]
000062  f7fffffe          BL       rt_hw_interrupt_disable
;;;208            if (result != RT_EOK)
000066  9000              STR      r0,[sp,#0]
000068  2d00              CMP      r5,#0
00006a  d003              BEQ      |L3.116|
00006c  e03a              B        |L3.228|
                  |L3.110|
00006e  2501              MOVS     r5,#1                 ;176
000070  43ed              MVNS     r5,r5                 ;176
000072  e037              B        |L3.228|
                  |L3.116|
000074  88a0              LDRH     r0,[r4,#4]            ;171
000076  88e1              LDRH     r1,[r4,#6]            ;171
000078  4288              CMP      r0,r1                 ;171
00007a  d0d6              BEQ      |L3.42|
;;;209                goto __exit;
;;;210        }
;;;211    
;;;212        *data_ptr = queue->queue[queue->get_index % queue->size].data_ptr;
00007c  8821              LDRH     r1,[r4,#0]
00007e  b280              UXTH     r0,r0
000080  f7fffffe          BL       __aeabi_uidivmod
000084  00c8              LSLS     r0,r1,#3
000086  68a1              LDR      r1,[r4,#8]
000088  5809              LDR      r1,[r1,r0]
00008a  9806              LDR      r0,[sp,#0x18]
;;;213        *size     = queue->queue[queue->get_index % queue->size].data_size;
00008c  6001              STR      r1,[r0,#0]
00008e  8821              LDRH     r1,[r4,#0]
000090  88a0              LDRH     r0,[r4,#4]
000092  f7fffffe          BL       __aeabi_uidivmod
000096  00c8              LSLS     r0,r1,#3
000098  68a1              LDR      r1,[r4,#8]
00009a  1d00              ADDS     r0,r0,#4
00009c  5809              LDR      r1,[r1,r0]
00009e  9807              LDR      r0,[sp,#0x1c]
;;;214    
;;;215        queue->get_index += 1;
0000a0  6001              STR      r1,[r0,#0]
0000a2  88a0              LDRH     r0,[r4,#4]
0000a4  1c40              ADDS     r0,r0,#1
0000a6  b280              UXTH     r0,r0
0000a8  80a0              STRH     r0,[r4,#4]
;;;216    
;;;217        if ((queue->put_index - queue->get_index) <= queue->lwm)
0000aa  88e1              LDRH     r1,[r4,#6]
0000ac  1a08              SUBS     r0,r1,r0
0000ae  8861              LDRH     r1,[r4,#2]
0000b0  4288              CMP      r0,r1
0000b2  dc17              BGT      |L3.228|
;;;218        {
;;;219            /* there is at least one thread in suspended list */
;;;220            if (!rt_list_isempty(&(queue->suspended_push_list)))
0000b4  4620              MOV      r0,r4
0000b6  300c              ADDS     r0,r0,#0xc
0000b8  f7fffffe          BL       rt_list_isempty
0000bc  2800              CMP      r0,#0
0000be  d007              BEQ      |L3.208|
;;;221            {
;;;222                /* get thread entry */
;;;223                thread = rt_list_entry(queue->suspended_push_list.next,
;;;224                                       struct rt_thread,
;;;225                                       tlist);
;;;226    
;;;227                /* resume it */
;;;228                rt_thread_resume(thread);
;;;229                rt_hw_interrupt_enable(level);
;;;230    
;;;231                /* perform a schedule */
;;;232                rt_schedule();
;;;233            }
;;;234            else
;;;235            {
;;;236                rt_hw_interrupt_enable(level);
0000c0  9800              LDR      r0,[sp,#0]
0000c2  f7fffffe          BL       rt_hw_interrupt_enable
                  |L3.198|
;;;237            }
;;;238    
;;;239            if (queue->evt_notify != RT_NULL)
0000c6  69e2              LDR      r2,[r4,#0x1c]
0000c8  2a00              CMP      r2,#0
0000ca  d016              BEQ      |L3.250|
;;;240                queue->evt_notify(queue, RT_DATAQUEUE_EVENT_LWM);
0000cc  2103              MOVS     r1,#3
0000ce  e012              B        |L3.246|
                  |L3.208|
0000d0  68e0              LDR      r0,[r4,#0xc]          ;223
0000d2  3814              SUBS     r0,r0,#0x14           ;223
0000d4  f7fffffe          BL       rt_thread_resume
0000d8  9800              LDR      r0,[sp,#0]            ;229
0000da  f7fffffe          BL       rt_hw_interrupt_enable
0000de  f7fffffe          BL       rt_schedule
0000e2  e7f0              B        |L3.198|
                  |L3.228|
;;;241    
;;;242            return result;
;;;243        }
;;;244    
;;;245    __exit:
;;;246        rt_hw_interrupt_enable(level);
0000e4  9800              LDR      r0,[sp,#0]
0000e6  f7fffffe          BL       rt_hw_interrupt_enable
;;;247        if ((result == RT_EOK) && (queue->evt_notify != RT_NULL))
0000ea  2d00              CMP      r5,#0
0000ec  d105              BNE      |L3.250|
0000ee  69e2              LDR      r2,[r4,#0x1c]
0000f0  2a00              CMP      r2,#0
0000f2  d002              BEQ      |L3.250|
;;;248        {
;;;249            queue->evt_notify(queue, RT_DATAQUEUE_EVENT_POP);
0000f4  2101              MOVS     r1,#1
                  |L3.246|
0000f6  4620              MOV      r0,r4                 ;240
0000f8  4790              BLX      r2                    ;240
                  |L3.250|
;;;250        }
;;;251    
;;;252        return result;
0000fa  4628              MOV      r0,r5
;;;253    }
0000fc  b009              ADD      sp,sp,#0x24
0000fe  bdf0              POP      {r4-r7,pc}
;;;254    RTM_EXPORT(rt_data_queue_pop);
                          ENDP


                          AREA ||i.rt_data_queue_push||, CODE, READONLY, ALIGN=1

                  rt_data_queue_push PROC
;;;64     
;;;65     rt_err_t rt_data_queue_push(struct rt_data_queue *queue,
000000  b5ff              PUSH     {r0-r7,lr}
;;;66                                 const void *data_ptr,
;;;67                                 rt_size_t data_size,
;;;68                                 rt_int32_t timeout)
;;;69     {
000002  b085              SUB      sp,sp,#0x14
000004  4604              MOV      r4,r0
;;;70         rt_ubase_t  level;
;;;71         rt_thread_t thread;
;;;72         rt_err_t    result;
;;;73         
;;;74         RT_ASSERT(queue != RT_NULL);
;;;75     
;;;76         result = RT_EOK;
000006  2500              MOVS     r5,#0
;;;77         thread = rt_thread_self();
000008  f7fffffe          BL       rt_thread_self
00000c  4606              MOV      r6,r0
;;;78     
;;;79         level = rt_hw_interrupt_disable();
00000e  f7fffffe          BL       rt_hw_interrupt_disable
;;;80         while (queue->put_index - queue->get_index == queue->size)
;;;81         {
;;;82             /* queue is full */
;;;83             if (timeout == 0)
;;;84             {
;;;85                 result = -RT_ETIMEOUT;
;;;86     
;;;87                 goto __exit;
;;;88             }
;;;89     
;;;90             /* current context checking */
;;;91             RT_DEBUG_NOT_IN_INTERRUPT;
;;;92     
;;;93             /* reset thread error number */
;;;94             thread->error = RT_EOK;
;;;95             
;;;96             /* suspend thread on the push list */
;;;97             rt_thread_suspend(thread);
;;;98             rt_list_insert_before(&(queue->suspended_push_list), &(thread->tlist));
000012  9000              STR      r0,[sp,#0]
000014  4630              MOV      r0,r6
000016  3014              ADDS     r0,r0,#0x14
000018  9001              STR      r0,[sp,#4]
00001a  4620              MOV      r0,r4
00001c  300c              ADDS     r0,r0,#0xc
;;;99             /* start timer */
;;;100            if (timeout > 0)
;;;101            {
;;;102                /* reset the timeout of thread timer and start it */
;;;103                rt_timer_control(&(thread->thread_timer),
00001e  9002              STR      r0,[sp,#8]
000020  2700              MOVS     r7,#0                 ;79
000022  4630              MOV      r0,r6
000024  304c              ADDS     r0,r0,#0x4c
000026  9003              STR      r0,[sp,#0xc]          ;80
000028  e024              B        |L4.116|
                  |L4.42|
00002a  9808              LDR      r0,[sp,#0x20]         ;83
00002c  2800              CMP      r0,#0                 ;83
00002e  d01e              BEQ      |L4.110|
000030  4630              MOV      r0,r6                 ;97
000032  6337              STR      r7,[r6,#0x30]         ;97
000034  f7fffffe          BL       rt_thread_suspend
000038  9901              LDR      r1,[sp,#4]            ;98
00003a  9802              LDR      r0,[sp,#8]            ;98
00003c  f7fffffe          BL       rt_list_insert_before
000040  9808              LDR      r0,[sp,#0x20]         ;100
000042  2800              CMP      r0,#0                 ;100
000044  dd07              BLE      |L4.86|
000046  aa08              ADD      r2,sp,#0x20
000048  2100              MOVS     r1,#0
00004a  9803              LDR      r0,[sp,#0xc]
00004c  f7fffffe          BL       rt_timer_control
;;;104                                 RT_TIMER_CTRL_SET_TIME,
;;;105                                 &timeout);
;;;106                rt_timer_start(&(thread->thread_timer));
000050  9803              LDR      r0,[sp,#0xc]
000052  f7fffffe          BL       rt_timer_start
                  |L4.86|
;;;107            }
;;;108    
;;;109            /* enable interrupt */
;;;110            rt_hw_interrupt_enable(level);
000056  9800              LDR      r0,[sp,#0]
000058  f7fffffe          BL       rt_hw_interrupt_enable
;;;111    
;;;112            /* do schedule */
;;;113            rt_schedule();
00005c  f7fffffe          BL       rt_schedule
;;;114    
;;;115            /* thread is waked up */
;;;116            result = thread->error;
;;;117            level = rt_hw_interrupt_disable();
000060  6b35              LDR      r5,[r6,#0x30]
000062  f7fffffe          BL       rt_hw_interrupt_disable
;;;118            if (result != RT_EOK) goto __exit;
000066  9000              STR      r0,[sp,#0]
000068  2d00              CMP      r5,#0
00006a  d003              BEQ      |L4.116|
00006c  e022              B        |L4.180|
                  |L4.110|
00006e  2501              MOVS     r5,#1                 ;85
000070  43ed              MVNS     r5,r5                 ;85
000072  e01f              B        |L4.180|
                  |L4.116|
000074  88e0              LDRH     r0,[r4,#6]            ;80
000076  88a1              LDRH     r1,[r4,#4]            ;80
000078  1a40              SUBS     r0,r0,r1              ;80
00007a  8821              LDRH     r1,[r4,#0]            ;80
00007c  4288              CMP      r0,r1                 ;80
00007e  d0d4              BEQ      |L4.42|
;;;119        }
;;;120    
;;;121        queue->queue[queue->put_index % queue->size].data_ptr  = data_ptr;
000080  b289              UXTH     r1,r1
000082  88e0              LDRH     r0,[r4,#6]
000084  f7fffffe          BL       __aeabi_uidivmod
000088  68a2              LDR      r2,[r4,#8]
00008a  00c9              LSLS     r1,r1,#3
00008c  9806              LDR      r0,[sp,#0x18]
00008e  5050              STR      r0,[r2,r1]
;;;122        queue->queue[queue->put_index % queue->size].data_size = data_size;
000090  8821              LDRH     r1,[r4,#0]
000092  88e0              LDRH     r0,[r4,#6]
000094  f7fffffe          BL       __aeabi_uidivmod
000098  00c8              LSLS     r0,r1,#3
00009a  68a2              LDR      r2,[r4,#8]
00009c  1d00              ADDS     r0,r0,#4
00009e  9907              LDR      r1,[sp,#0x1c]
0000a0  5011              STR      r1,[r2,r0]
;;;123        queue->put_index += 1;
0000a2  88e0              LDRH     r0,[r4,#6]
0000a4  1c40              ADDS     r0,r0,#1
0000a6  80e0              STRH     r0,[r4,#6]
;;;124    
;;;125        /* there is at least one thread in suspended list */
;;;126        if (!rt_list_isempty(&(queue->suspended_pop_list)))
0000a8  4620              MOV      r0,r4
0000aa  3014              ADDS     r0,r0,#0x14
0000ac  f7fffffe          BL       rt_list_isempty
0000b0  2800              CMP      r0,#0
0000b2  d005              BEQ      |L4.192|
                  |L4.180|
;;;127        {
;;;128            /* get thread entry */
;;;129            thread = rt_list_entry(queue->suspended_pop_list.next,
;;;130                                   struct rt_thread,
;;;131                                   tlist);
;;;132    
;;;133            /* resume it */
;;;134            rt_thread_resume(thread);
;;;135            rt_hw_interrupt_enable(level);
;;;136    
;;;137            /* perform a schedule */
;;;138            rt_schedule();
;;;139    
;;;140            return result;
;;;141        }
;;;142    
;;;143    __exit:
;;;144        rt_hw_interrupt_enable(level);
0000b4  9800              LDR      r0,[sp,#0]
0000b6  f7fffffe          BL       rt_hw_interrupt_enable
;;;145        if ((result == RT_EOK) && queue->evt_notify != RT_NULL)
0000ba  2d00              CMP      r5,#0
0000bc  d00a              BEQ      |L4.212|
0000be  e00f              B        |L4.224|
                  |L4.192|
0000c0  6960              LDR      r0,[r4,#0x14]         ;129
0000c2  3814              SUBS     r0,r0,#0x14           ;129
0000c4  f7fffffe          BL       rt_thread_resume
0000c8  9800              LDR      r0,[sp,#0]            ;135
0000ca  f7fffffe          BL       rt_hw_interrupt_enable
0000ce  f7fffffe          BL       rt_schedule
0000d2  e005              B        |L4.224|
                  |L4.212|
0000d4  69e2              LDR      r2,[r4,#0x1c]
0000d6  2a00              CMP      r2,#0
0000d8  d002              BEQ      |L4.224|
;;;146        {
;;;147            queue->evt_notify(queue, RT_DATAQUEUE_EVENT_PUSH);
0000da  2102              MOVS     r1,#2
0000dc  4620              MOV      r0,r4
0000de  4790              BLX      r2
                  |L4.224|
;;;148        }
;;;149    
;;;150        return result;
0000e0  4628              MOV      r0,r5
;;;151    }
0000e2  b009              ADD      sp,sp,#0x24
0000e4  bdf0              POP      {r4-r7,pc}
;;;152    RTM_EXPORT(rt_data_queue_push);
                          ENDP


                          AREA ||i.rt_data_queue_reset||, CODE, READONLY, ALIGN=1

                  rt_data_queue_reset PROC
;;;281    
;;;282    void rt_data_queue_reset(struct rt_data_queue *queue)
000000  b5f8              PUSH     {r3-r7,lr}
;;;283    {
000002  4604              MOV      r4,r0
;;;284        struct rt_thread *thread;
;;;285        register rt_ubase_t temp;
;;;286    
;;;287        rt_enter_critical();
000004  f7fffffe          BL       rt_enter_critical
;;;288        /* wakeup all suspend threads */
;;;289    
;;;290        /* resume on pop list */
;;;291        while (!rt_list_isempty(&(queue->suspended_pop_list)))
;;;292        {
;;;293            /* disable interrupt */
;;;294            temp = rt_hw_interrupt_disable();
;;;295    
;;;296            /* get next suspend thread */
;;;297            thread = rt_list_entry(queue->suspended_pop_list.next,
;;;298                                   struct rt_thread,
;;;299                                   tlist);
;;;300            /* set error code to RT_ERROR */
;;;301            thread->error = -RT_ERROR;
000008  2600              MOVS     r6,#0
00000a  43f6              MVNS     r6,r6
00000c  4627              MOV      r7,r4                 ;291
00000e  3714              ADDS     r7,r7,#0x14           ;291
000010  e00a              B        |L5.40|
                  |L5.18|
000012  f7fffffe          BL       rt_hw_interrupt_disable
000016  4605              MOV      r5,r0                 ;294
000018  6960              LDR      r0,[r4,#0x14]
00001a  61c6              STR      r6,[r0,#0x1c]
00001c  3814              SUBS     r0,r0,#0x14
;;;302    
;;;303            /*
;;;304             * resume thread
;;;305             * In rt_thread_resume function, it will remove current thread from
;;;306             * suspend list
;;;307             */
;;;308            rt_thread_resume(thread);
00001e  f7fffffe          BL       rt_thread_resume
;;;309    
;;;310            /* enable interrupt */
;;;311            rt_hw_interrupt_enable(temp);
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       rt_hw_interrupt_enable
                  |L5.40|
000028  4638              MOV      r0,r7
00002a  f7fffffe          BL       rt_list_isempty
00002e  2800              CMP      r0,#0                 ;291
000030  d0ef              BEQ      |L5.18|
;;;312        }
;;;313    
;;;314        /* resume on push list */
;;;315        while (!rt_list_isempty(&(queue->suspended_push_list)))
000032  4627              MOV      r7,r4
000034  370c              ADDS     r7,r7,#0xc
                  |L5.54|
000036  4638              MOV      r0,r7
000038  f7fffffe          BL       rt_list_isempty
00003c  2800              CMP      r0,#0
00003e  d004              BEQ      |L5.74|
;;;316        {
;;;317            /* disable interrupt */
;;;318            temp = rt_hw_interrupt_disable();
;;;319    
;;;320            /* get next suspend thread */
;;;321            thread = rt_list_entry(queue->suspended_push_list.next,
;;;322                                   struct rt_thread,
;;;323                                   tlist);
;;;324            /* set error code to RT_ERROR */
;;;325            thread->error = -RT_ERROR;
;;;326    
;;;327            /*
;;;328             * resume thread
;;;329             * In rt_thread_resume function, it will remove current thread from
;;;330             * suspend list
;;;331             */
;;;332            rt_thread_resume(thread);
;;;333    
;;;334            /* enable interrupt */
;;;335            rt_hw_interrupt_enable(temp);
;;;336        }
;;;337        rt_exit_critical();
000040  f7fffffe          BL       rt_exit_critical
;;;338    
;;;339        rt_schedule();
000044  f7fffffe          BL       rt_schedule
;;;340    }
000048  bdf8              POP      {r3-r7,pc}
                  |L5.74|
00004a  f7fffffe          BL       rt_hw_interrupt_disable
00004e  4605              MOV      r5,r0                 ;318
000050  68e0              LDR      r0,[r4,#0xc]          ;325
000052  61c6              STR      r6,[r0,#0x1c]         ;325
000054  3814              SUBS     r0,r0,#0x14           ;325
000056  f7fffffe          BL       rt_thread_resume
00005a  4628              MOV      r0,r5                 ;335
00005c  f7fffffe          BL       rt_hw_interrupt_enable
000060  e7e9              B        |L5.54|
;;;341    RTM_EXPORT(rt_data_queue_reset);
                          ENDP


                          AREA ||i.rt_list_insert_before||, CODE, READONLY, ALIGN=1

                  rt_list_insert_before PROC
;;;76      */
;;;77     rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
000000  6842              LDR      r2,[r0,#4]
;;;78     {
;;;79         l->prev->next = n;
;;;80         n->prev = l->prev;
000002  6011              STR      r1,[r2,#0]
000004  6842              LDR      r2,[r0,#4]
;;;81     
;;;82         l->prev = n;
000006  604a              STR      r2,[r1,#4]
;;;83         n->next = l;
000008  6041              STR      r1,[r0,#4]
00000a  6008              STR      r0,[r1,#0]
;;;84     }
00000c  4770              BX       lr
;;;85     
                          ENDP


                          AREA ||i.rt_list_isempty||, CODE, READONLY, ALIGN=1

                  rt_list_isempty PROC
;;;101     */
;;;102    rt_inline int rt_list_isempty(const rt_list_t *l)
000000  6801              LDR      r1,[r0,#0]
;;;103    {
;;;104        return l->next == l;
000002  4281              CMP      r1,r0
000004  d101              BNE      |L7.10|
000006  2001              MOVS     r0,#1
;;;105    }
000008  4770              BX       lr
                  |L7.10|
00000a  2000              MOVS     r0,#0                 ;104
00000c  4770              BX       lr
;;;106    
                          ENDP

