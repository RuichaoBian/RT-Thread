L 1 "..\..\src\module.c"
N/*
N * File      : module.c
N * This file is part of RT-Thread RTOS
N * COPYRIGHT (C) 2006 - 2012, RT-Thread Development Team
N *
N *  This program is free software; you can redistribute it and/or modify
N *  it under the terms of the GNU General Public License as published by
N *  the Free Software Foundation; either version 2 of the License, or
N *  (at your option) any later version.
N *
N *  This program is distributed in the hope that it will be useful,
N *  but WITHOUT ANY WARRANTY; without even the implied warranty of
N *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
N *  GNU General Public License for more details.
N *
N *  You should have received a copy of the GNU General Public License along
N *  with this program; if not, write to the Free Software Foundation, Inc.,
N *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
N *
N * Change Logs:
N * Date           Author       Notes
N * 2010-01-09     Bernard      first version
N * 2010-04-09     yi.qiu       implement based on first version
N * 2010-10-23     yi.qiu       implement module memory allocator
N * 2011-05-25     yi.qiu       implement module hook function
N * 2011-06-23     yi.qiu       rewrite module memory allocator
N * 2012-11-23     Bernard      using RT_DEBUG_LOG instead of rt_kprintf.
N * 2012-11-28     Bernard      remove rt_current_module and user
N *                             can use rt_module_unload to remove a module.
N */
N
N#include <rthw.h>
L 1 "..\..\include\rthw.h" 1
N/*
N * File      : rthw.h
N * This file is part of RT-Thread RTOS
N * COPYRIGHT (C) 2006 - 2012, RT-Thread Development Team
N *
N *  This program is free software; you can redistribute it and/or modify
N *  it under the terms of the GNU General Public License as published by
N *  the Free Software Foundation; either version 2 of the License, or
N *  (at your option) any later version.
N *
N *  This program is distributed in the hope that it will be useful,
N *  but WITHOUT ANY WARRANTY; without even the implied warranty of
N *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
N *  GNU General Public License for more details.
N *
N *  You should have received a copy of the GNU General Public License along
N *  with this program; if not, write to the Free Software Foundation, Inc.,
N *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
N *
N * Change Logs:
N * Date           Author       Notes
N * 2006-03-18     Bernard      the first version
N * 2006-04-25     Bernard      add rt_hw_context_switch_interrupt declaration
N * 2006-09-24     Bernard      add rt_hw_context_switch_to declaration
N * 2012-12-29     Bernard      add rt_hw_exception_install declaration
N */
N
N#ifndef __RT_HW_H__
N#define __RT_HW_H__
N
N#include <rtthread.h>
L 1 "..\..\include\rtthread.h" 1
N/*
N * File      : rtthread.h
N * This file is part of RT-Thread RTOS
N * COPYRIGHT (C) 2006 - 2012, RT-Thread Development Team
N *
N *  This program is free software; you can redistribute it and/or modify
N *  it under the terms of the GNU General Public License as published by
N *  the Free Software Foundation; either version 2 of the License, or
N *  (at your option) any later version.
N *
N *  This program is distributed in the hope that it will be useful,
N *  but WITHOUT ANY WARRANTY; without even the implied warranty of
N *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
N *  GNU General Public License for more details.
N *
N *  You should have received a copy of the GNU General Public License along
N *  with this program; if not, write to the Free Software Foundation, Inc.,
N *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
N *
N * Change Logs:
N * Date           Author       Notes
N * 2006-03-18     Bernard      the first version
N * 2006-04-26     Bernard      add semaphore APIs
N * 2006-08-10     Bernard      add version information
N * 2007-01-28     Bernard      rename RT_OBJECT_Class_Static to RT_Object_Class_Static
N * 2007-03-03     Bernard      clean up the definitions to rtdef.h
N * 2010-04-11     yi.qiu       add module feature
N * 2013-06-24     Bernard      add rt_kprintf re-define when not use RT_USING_CONSOLE.
N * 2016-08-09     ArdaFu       add new thread and interrupt hook.
N */
N
N#ifndef __RT_THREAD_H__
N#define __RT_THREAD_H__
N
N#include <rtconfig.h>
L 1 "..\nuvoton_nuc240\rtconfig.h" 1
N/* RT-Thread config file */
N#ifndef __RTTHREAD_CFG_H__
N#define __RTTHREAD_CFG_H__
N
N/* RT_NAME_MAX*/
N#define RT_NAME_MAX	   8
N
N/* RT_ALIGN_SIZE*/
N#define RT_ALIGN_SIZE	4
N
N/* PRIORITY_MAX */
N#define RT_THREAD_PRIORITY_MAX	32
N#define IDLE_THREAD_STACK_SIZE 128
N/* Tick per Second 10msÒ»¸öµÎ´ð*/
N#define RT_TICK_PER_SECOND	100
N
N
N#define RT_USING_USB_HOST
N#define RT_USING_USB_DEVICE
N#define RT_USB_DEVICE_COMPOSITE
N/* SECTION: RT_DEBUG */
N/* Thread Debug */
N//#define RT_DEBUG
N//#define RT_DEBUG_INIT 1
N//#define RT_USING_OVERFLOW_CHECK
N
N/* Using Hook */
N/* #define RT_USING_HOOK */
N
N/* Using Software Timer */
N #define RT_USING_TIMER_SOFT 
N#define RT_TIMER_THREAD_PRIO		4
N#define RT_TIMER_THREAD_STACK_SIZE	512
N#define RT_TIMER_TICK_PER_SECOND	10
N
N/* SECTION: IPC */
N/* Using Semaphore*/
N#define RT_USING_SEMAPHORE
N
N/* Using Mutex */
N #define RT_USING_MUTEX 
N
N/* Using Event */
N #define RT_USING_EVENT
N
N/* Using MailBox */
N #define RT_USING_MAILBOX 
N
N/* Using Message Queue */
N #define RT_USING_MESSAGEQUEUE 
N
N/* SECTION: Memory Management */
N/* Using Memory Pool Management*/
N #define RT_USING_MEMPOOL 
N
N/* Using Dynamic Heap Management */
N#define RT_USING_HEAP
N
N/* Using Small MM */
N#define RT_USING_SMALL_MEM
N
N// <bool name="RT_USING_COMPONENTS_INIT" description="Using RT-Thread components initialization" default="true" />
N#define RT_USING_COMPONENTS_INIT
N
N/* SECTION: Device System */
N/* Using Device System */
N#define RT_USING_DEVICE
N// <bool name="RT_USING_DEVICE_IPC" description="Using device communication" default="true" />
N#define RT_USING_DEVICE_IPC
N// <bool name="RT_USING_SERIAL" description="Using Serial" default="true" />
N#define RT_USING_SERIAL
N
N/* SECTION: Console options */
N#define RT_USING_CONSOLE
N/* the buffer size of console*/
N#define RT_CONSOLEBUF_SIZE	64
N// <string name="RT_CONSOLE_DEVICE_NAME" description="The device name for console" default="uart1" />
N#define RT_CONSOLE_DEVICE_NAME	    "uart0"
N
N
N
N/* SECTION: finsh, a C-Express shell */
N#define RT_USING_FINSH
N/* configure finsh parameters */
N#define FINSH_THREAD_PRIORITY 25
N#define FINSH_THREAD_STACK_SIZE	512
N#define FINSH_USING_HISTORY 0
N#define FINSH_HISTORY_LINES	1
N/* Using symbol table */
N#define FINSH_USING_SYMTAB
N#define FINSH_USING_DESCRIPTION
N
N/* SECTION: libc management */
N//#define RT_USING_LIBC
N
N/* SECTION: device filesystem */
N/* #define RT_USING_DFS */
N//#define RT_USING_DFS_ELMFAT
N#define RT_DFS_ELM_WORD_ACCESS
N/* Reentrancy (thread safe) of the FatFs module.  */
N#define RT_DFS_ELM_REENTRANT
N/* Number of volumes (logical drives) to be used. */
N#define RT_DFS_ELM_DRIVES			2
N/* #define RT_DFS_ELM_USE_LFN			1 */
N#define RT_DFS_ELM_MAX_LFN			255
N/* Maximum sector size to be handled. */
N#define RT_DFS_ELM_MAX_SECTOR_SIZE  512
N
N#define RT_USING_DFS_ROMFS
N
N/* the max number of mounted filesystem */
N#define DFS_FILESYSTEMS_MAX			2
N/* the max number of opened files 		*/
N#define DFS_FD_MAX					4
N
N#endif
L 36 "..\..\include\rtthread.h" 2
N#include <rtdebug.h>
L 1 "..\..\include\rtdebug.h" 1
N/*
N * File      : rtdebug.h
N * This file is part of RT-Thread RTOS
N * COPYRIGHT (C) 2006 - 2012, RT-Thread Development Team
N *
N *  This program is free software; you can redistribute it and/or modify
N *  it under the terms of the GNU General Public License as published by
N *  the Free Software Foundation; either version 2 of the License, or
N *  (at your option) any later version.
N *
N *  This program is distributed in the hope that it will be useful,
N *  but WITHOUT ANY WARRANTY; without even the implied warranty of
N *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
N *  GNU General Public License for more details.
N *
N *  You should have received a copy of the GNU General Public License along
N *  with this program; if not, write to the Free Software Foundation, Inc.,
N *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
N */
N
N#ifndef __RTDEBUG_H__
N#define __RTDEBUG_H__
N
N#include <rtconfig.h>
N
N/* Using this macro to control all kernel debug features. */
N#ifdef RT_DEBUG
S
S/* Turn on some of these (set to non-zero) to debug kernel */
S#ifndef RT_DEBUG_MEM
S#define RT_DEBUG_MEM                   0
S#endif
S
S#ifndef RT_DEBUG_MEMHEAP
S#define RT_DEBUG_MEMHEAP               0
S#endif
S
S#ifndef RT_DEBUG_MODULE
S#define RT_DEBUG_MODULE                0
S#endif
S
S#ifndef RT_DEBUG_SCHEDULER
S#define RT_DEBUG_SCHEDULER             0
S#endif
S
S#ifndef RT_DEBUG_SLAB
S#define RT_DEBUG_SLAB                  0
S#endif
S
S#ifndef RT_DEBUG_THREAD
S#define RT_DEBUG_THREAD                0
S#endif
S
S#ifndef RT_DEBUG_TIMER
S#define RT_DEBUG_TIMER                 0
S#endif
S
S#ifndef RT_DEBUG_IRQ
S#define RT_DEBUG_IRQ                   0
S#endif
S
S#ifndef RT_DEBUG_IPC
S#define RT_DEBUG_IPC                   0
S#endif
S
S#ifndef RT_DEBUG_INIT
S#define RT_DEBUG_INIT                  0
S#endif
S
S/* Turn on this to enable context check */
S#ifndef RT_DEBUG_CONTEXT_CHECK
S#define RT_DEBUG_CONTEXT_CHECK         1
S#endif
S
S#define RT_DEBUG_LOG(type, message)                                           \
Sdo                                                                            \
S{                                                                             \
S    if (type)                                                                 \
S        rt_kprintf message;                                                   \
S}                                                                             \
Swhile (0)
X#define RT_DEBUG_LOG(type, message)                                           do                                                                            {                                                                                 if (type)                                                                         rt_kprintf message;                                                   }                                                                             while (0)
S
S#define RT_ASSERT(EX)                                                         \
Sif (!(EX))                                                                    \
S{                                                                             \
S    rt_assert_handler(#EX, __FUNCTION__, __LINE__);                           \
S}
X#define RT_ASSERT(EX)                                                         if (!(EX))                                                                    {                                                                                 rt_assert_handler(#EX, __FUNCTION__, __LINE__);                           }
S
S/* Macro to check current context */
S#if RT_DEBUG_CONTEXT_CHECK
S#define RT_DEBUG_NOT_IN_INTERRUPT                                             \
Sdo                                                                            \
S{                                                                             \
S    rt_base_t level;                                                          \
S    level = rt_hw_interrupt_disable();                                        \
S    if (rt_interrupt_get_nest() != 0)                                         \
S    {                                                                         \
S        rt_kprintf("Function[%s] shall not used in ISR\n", __FUNCTION__);     \
S        RT_ASSERT(0)                                                          \
S    }                                                                         \
S    rt_hw_interrupt_enable(level);                                            \
S}                                                                             \
Swhile (0)
X#define RT_DEBUG_NOT_IN_INTERRUPT                                             do                                                                            {                                                                                 rt_base_t level;                                                              level = rt_hw_interrupt_disable();                                            if (rt_interrupt_get_nest() != 0)                                             {                                                                                 rt_kprintf("Function[%s] shall not used in ISR\n", __FUNCTION__);             RT_ASSERT(0)                                                              }                                                                             rt_hw_interrupt_enable(level);                                            }                                                                             while (0)
S
S/* "In thread context" means:
S *     1) the scheduler has been started
S *     2) not in interrupt context.
S */
S#define RT_DEBUG_IN_THREAD_CONTEXT                                            \
Sdo                                                                            \
S{                                                                             \
S    rt_base_t level;                                                          \
S    level = rt_hw_interrupt_disable();                                        \
S    if (rt_thread_self() == RT_NULL)                                          \
S    {                                                                         \
S        rt_kprintf("Function[%s] shall not be used before scheduler start\n", \
S                   __FUNCTION__);                                             \
S        RT_ASSERT(0)                                                          \
S    }                                                                         \
S    RT_DEBUG_NOT_IN_INTERRUPT;                                                \
S    rt_hw_interrupt_enable(level);                                            \
S}                                                                             \
Swhile (0)
X#define RT_DEBUG_IN_THREAD_CONTEXT                                            do                                                                            {                                                                                 rt_base_t level;                                                              level = rt_hw_interrupt_disable();                                            if (rt_thread_self() == RT_NULL)                                              {                                                                                 rt_kprintf("Function[%s] shall not be used before scheduler start\n",                    __FUNCTION__);                                                     RT_ASSERT(0)                                                              }                                                                             RT_DEBUG_NOT_IN_INTERRUPT;                                                    rt_hw_interrupt_enable(level);                                            }                                                                             while (0)
S#else
S#define RT_DEBUG_NOT_IN_INTERRUPT
S#define RT_DEBUG_IN_THREAD_CONTEXT
S#endif
S
N#else /* RT_DEBUG */
N
N#define RT_ASSERT(EX)
N#define RT_DEBUG_LOG(type, message)
N#define RT_DEBUG_NOT_IN_INTERRUPT
N#define RT_DEBUG_IN_THREAD_CONTEXT
N
N#endif /* RT_DEBUG */
N
N#endif /* __RTDEBUG_H__ */
L 37 "..\..\include\rtthread.h" 2
N#include <rtdef.h>
L 1 "..\..\include\rtdef.h" 1
N/*
N * File      : rtdef.h
N * This file is part of RT-Thread RTOS
N * COPYRIGHT (C) 2006 - 2015, RT-Thread Development Team
N *
N *  This program is free software; you can redistribute it and/or modify
N *  it under the terms of the GNU General Public License as published by
N *  the Free Software Foundation; either version 2 of the License, or
N *  (at your option) any later version.
N *
N *  This program is distributed in the hope that it will be useful,
N *  but WITHOUT ANY WARRANTY; without even the implied warranty of
N *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
N *  GNU General Public License for more details.
N *
N *  You should have received a copy of the GNU General Public License along
N *  with this program; if not, write to the Free Software Foundation, Inc.,
N *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
N *
N * Change Logs:
N * Date           Author       Notes
N * 2007-01-10     Bernard      the first version
N * 2008-07-12     Bernard      remove all rt_int8, rt_uint32_t etc typedef
N * 2010-10-26     yi.qiu       add module support
N * 2010-11-10     Bernard      add cleanup callback function in thread exit.
N * 2011-05-09     Bernard      use builtin va_arg in GCC 4.x
N * 2012-11-16     Bernard      change RT_NULL from ((void*)0) to 0.
N * 2012-12-29     Bernard      change the RT_USING_MEMPOOL location and add
N *                             RT_USING_MEMHEAP condition.
N * 2012-12-30     Bernard      add more control command for graphic.
N * 2013-01-09     Bernard      change version number.
N * 2015-02-01     Bernard      change version number to v2.1.0
N */
N
N#ifndef __RT_DEF_H__
N#define __RT_DEF_H__
N
N/* include rtconfig header to import configuration */
N#include <rtconfig.h>
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/**
N * @addtogroup BasicDef
N */
N
N/*@{*/
N
N/* RT-Thread version information */
N#define RT_VERSION                      2L              /**< major version number */
N#define RT_SUBVERSION                   1L              /**< minor version number */
N#define RT_REVISION                     0L              /**< revise version number */
N
N/* RT-Thread version */
N#define RTTHREAD_VERSION                ((RT_VERSION * 10000) + \
N                                         (RT_SUBVERSION * 100) + RT_REVISION)
X#define RTTHREAD_VERSION                ((RT_VERSION * 10000) +                                          (RT_SUBVERSION * 100) + RT_REVISION)
N
N/* RT-Thread basic data type definitions */
Ntypedef signed   char                   rt_int8_t;      /**<  8bit integer type */
Ntypedef signed   short                  rt_int16_t;     /**< 16bit integer type */
Ntypedef signed   long                   rt_int32_t;     /**< 32bit integer type */
Ntypedef unsigned char                   rt_uint8_t;     /**<  8bit unsigned integer type */
Ntypedef unsigned short                  rt_uint16_t;    /**< 16bit unsigned integer type */
Ntypedef unsigned long                   rt_uint32_t;    /**< 32bit unsigned integer type */
Ntypedef int                             rt_bool_t;      /**< boolean type */
N
N/* 32bit CPU */
Ntypedef long                            rt_base_t;      /**< Nbit CPU related date type */
Ntypedef unsigned long                   rt_ubase_t;     /**< Nbit unsigned CPU related data type */
N
Ntypedef rt_base_t                       rt_err_t;       /**< Type for error number */
Ntypedef rt_uint32_t                     rt_time_t;      /**< Type for time stamp */
Ntypedef rt_uint32_t                     rt_tick_t;      /**< Type for tick count */
Ntypedef rt_base_t                       rt_flag_t;      /**< Type for flags */
Ntypedef rt_ubase_t                      rt_size_t;      /**< Type for size number */
Ntypedef rt_ubase_t                      rt_dev_t;       /**< Type for device */
Ntypedef rt_base_t                       rt_off_t;       /**< Type for offset */
N
N/* boolean type definitions */
N#define RT_TRUE                         1               /**< boolean true  */
N#define RT_FALSE                        0               /**< boolean fails */
N
N/*@}*/
N
N/* maximum value of base type */
N#define RT_UINT8_MAX                    0xff            /**< Maxium number of UINT8 */
N#define RT_UINT16_MAX                   0xffff          /**< Maxium number of UINT16 */
N#define RT_UINT32_MAX                   0xffffffff      /**< Maxium number of UINT32 */
N#define RT_TICK_MAX                     RT_UINT32_MAX   /**< Maxium number of tick */
N
N/* Compiler Related Definitions */
N#ifdef __CC_ARM                         /* ARM Compiler */
N    #include <stdarg.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdarg.h" 1
N/* stdarg.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.8 */
N/* Copyright (C) Codemist Ltd., 1988                            */
N/* Copyright (C) ARM Ltd., 1991-1999. All rights reserved */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N#ifndef __stdarg_h
N#define __stdarg_h
N#define __ARMCLIB_VERSION 5060016
N
N  #ifndef __STDARG_DECLS
N  #define __STDARG_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N/*
N * stdarg.h declares a type and defines macros for advancing through a
N * list of arguments whose number and types are not known to the called
N * function when it is translated. A function may be called with a variable
N * number of arguments of differing types. Its parameter list contains one or
N * more parameters. The rightmost parameter plays a special role in the access
N * mechanism, and will be called parmN in this description.
N */
N
N/* N.B. <stdio.h> is required to declare vfprintf() without defining      */
N/* va_list.  Clearly the type __va_list there must keep in step.          */
N#ifdef __clang__
S  typedef __builtin_va_list va_list;
S  #define va_start(ap, param) __builtin_va_start(ap, param)
S  #define va_end(ap)          __builtin_va_end(ap)
S  #define va_arg(ap, type)    __builtin_va_arg(ap, type)
S  #if __STDC_VERSION__ >= 199900L || __cplusplus >= 201103L || !defined(__STRICT_ANSI__)
S  #define va_copy(dest, src)  __builtin_va_copy(dest, src)
S  #endif
N#else
N  #ifdef __TARGET_ARCH_AARCH64
S    typedef struct __va_list {
S      void *__stack;
S      void *__gr_top;
S      void *__vr_top;
S      int __gr_offs;
S      int __vr_offs;
S    } va_list;
N  #else
N    typedef struct __va_list { void *__ap; } va_list;
N  #endif
N   /*
N    * an array type suitable for holding information needed by the macro va_arg
N    * and the function va_end. The called function shall declare a variable
N    * (referred to as ap) having type va_list. The variable ap may be passed as
N    * an argument to another function.
N    * Note: va_list is an array type so that when an object of that type
N    * is passed as an argument it gets passed by reference.
N    */
N  #define va_start(ap, parmN) __va_start(ap, parmN)
N
N   /*
N    * The va_start macro shall be executed before any access to the unnamed
N    * arguments. The parameter ap points to an object that has type va_list.
N    * The va_start macro initialises ap for subsequent use by va_arg and
N    * va_end. The parameter parmN is the identifier of the rightmost parameter
N    * in the variable parameter list in the function definition (the one just
N    * before the '...'). If the parameter parmN is declared with the register
N    * storage class an error is given.
N    * If parmN is a narrow type (char, short, float) an error is given in
N    * strict ANSI mode, or a warning otherwise.
N    * Returns: no value.
N    */
N  #define va_arg(ap, type) __va_arg(ap, type)
N
N   /*
N    * The va_arg macro expands to an expression that has the type and value of
N    * the next argument in the call. The parameter ap shall be the same as the
N    * va_list ap initialised by va_start. Each invocation of va_arg modifies
N    * ap so that successive arguments are returned in turn. The parameter
N    * 'type' is a type name such that the type of a pointer to an object that
N    * has the specified type can be obtained simply by postfixing a * to
N    * 'type'. If type is a narrow type, an error is given in strict ANSI
N    * mode, or a warning otherwise. If the type is an array or function type,
N    * an error is given.
N    * In non-strict ANSI mode, 'type' is allowed to be any expression.
N    * Returns: The first invocation of the va_arg macro after that of the
N    *          va_start macro returns the value of the argument after that
N    *          specified by parmN. Successive invocations return the values of
N    *          the remaining arguments in succession.
N    *          The result is cast to 'type', even if 'type' is narrow.
N    */
N
N#define __va_copy(dest, src) ((void)((dest) = (src)))
N
N#if !defined(__STRICT_ANSI__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X#if !0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
N   /* va_copy is in C99 and non-strict C90 and non-strict C++
N    * __va_copy is always present.
N    */
N  #define va_copy(dest, src) ((void)((dest) = (src)))
N
N   /* The va_copy macro makes the va_list dest be a copy of
N    * the va_list src, as if the va_start macro had been applied
N    * to it followed by the same sequence of uses of the va_arg
N    * macro as had previously been used to reach the present state
N    * of src.
N    */
N#endif
N
N#define va_end(ap) __va_end(ap)
N   /*
N    * The va_end macro facilitates a normal return from the function whose
N    * variable argument list was referenced by the expansion of va_start that
N    * initialised the va_list ap. If the va_end macro is not invoked before
N    * the return, the behaviour is undefined.
N    * Returns: no value.
N    */
N#endif /* __clang__ */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N
N    #ifdef __GNUC__
S     /* be cooperative with glibc */
S     typedef __CLIBNS va_list __gnuc_va_list;
S     #define __GNUC_VA_LIST
S     #undef __need___va_list
N    #endif
N
N  #endif /* __STDARG_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STDARG_NO_EXPORTS
S      using ::std::va_list;
S    #endif
N  #endif /* __cplusplus */
N#endif
N
N/* end of stdarg.h */
N
L 96 "..\..\include\rtdef.h" 2
N    #define SECTION(x)                  __attribute__((section(x)))
N    #define RT_UNUSED                   __attribute__((unused))
N    #define RT_USED                     __attribute__((used))
N    #define ALIGN(n)                    __attribute__((aligned(n)))
N    #define WEAK						__weak
N    #define rt_inline                   static __inline
N    /* module compiling */
N    #ifdef RT_USING_MODULE
S        #define RTT_API                 __declspec(dllimport)
N    #else
N        #define RTT_API                 __declspec(dllexport)
N    #endif
N
N#elif defined (__IAR_SYSTEMS_ICC__)     /* for IAR Compiler */
S    #include <stdarg.h>
S    #define SECTION(x)                  @ x
S    #define RT_UNUSED
S    #define RT_USED
S    #define PRAGMA(x)                   _Pragma(#x)
S    #define ALIGN(n)                    PRAGMA(data_alignment=n)
S    #define WEAK                        __weak
S    #define rt_inline                   static inline
S    #define RTT_API
S
S#elif defined (__GNUC__)                /* GNU GCC Compiler */
S    #ifdef RT_USING_NEWLIB
S        #include <stdarg.h>
S    #else
S		/* the version of GNU GCC must be greater than 4.x */
S        typedef __builtin_va_list   __gnuc_va_list;
S        typedef __gnuc_va_list      va_list;
S        #define va_start(v,l)       __builtin_va_start(v,l)
S        #define va_end(v)           __builtin_va_end(v)
S        #define va_arg(v,l)         __builtin_va_arg(v,l)
S    #endif
S
S    #define SECTION(x)                  __attribute__((section(x)))
S    #define RT_UNUSED                   __attribute__((unused))
S    #define RT_USED                     __attribute__((used))
S    #define ALIGN(n)                    __attribute__((aligned(n)))
S    #define WEAK                        __attribute__((weak))
S    #define rt_inline                   static __inline
S    #define RTT_API
S#elif defined (__ADSPBLACKFIN__)        /* for VisualDSP++ Compiler */
S    #include <stdarg.h>
S    #define SECTION(x)                  __attribute__((section(x)))
S    #define RT_UNUSED                   __attribute__((unused))
S    #define RT_USED                     __attribute__((used))
S    #define ALIGN(n)                    __attribute__((aligned(n)))
S	#define WEAK                        __attribute__((weak))
S    #define rt_inline                   static inline
S    #define RTT_API
S#elif defined (_MSC_VER)
S    #include <stdarg.h>
S    #define SECTION(x)
S    #define RT_UNUSED
S    #define RT_USED
S    #define ALIGN(n)                    __declspec(align(n))
S	#define WEAK
S    #define rt_inline                   static __inline
S    #define RTT_API
S#elif defined (__TI_COMPILER_VERSION__)
S    #include <stdarg.h>
S    /* The way that TI compiler set section is different from other(at least
S     * GCC and MDK) compilers. See ARM Optimizing C/C++ Compiler 5.9.3 for more
S     * details. */
S    #define SECTION(x)
S    #define RT_UNUSED
S    #define RT_USED
S    #define PRAGMA(x)                   _Pragma(#x)
S    #define ALIGN(n)
S    #define WEAK
S    #define rt_inline                   static inline
S    #define RTT_API
S#else
S    #error not supported tool chain
N#endif
N
N/* initialization export */
N#ifdef RT_USING_COMPONENTS_INIT
Ntypedef int (*init_fn_t)(void);
N#ifdef _MSC_VER /* we do not support MS VC++ compiler */
S    #define INIT_EXPORT(fn, level)
N#else
N	#if RT_DEBUG_INIT
S		struct rt_init_desc
S		{
S			const char* fn_name;
S			const init_fn_t fn;
S		};
S		#define INIT_EXPORT(fn, level)  		\
S			const char __rti_##fn##_name[] = #fn; \
S			const struct rt_init_desc __rt_init_desc_##fn SECTION(".rti_fn."level) = \
S			{ __rti_##fn##_name, fn};
X		#define INIT_EXPORT(fn, level)  					const char __rti_##fn##_name[] = #fn; 			const struct rt_init_desc __rt_init_desc_##fn SECTION(".rti_fn."level) = 			{ __rti_##fn##_name, fn};
N	#else
N    	#define INIT_EXPORT(fn, level)  \
N        	const init_fn_t __rt_init_##fn SECTION(".rti_fn."level) = fn
X    	#define INIT_EXPORT(fn, level)          	const init_fn_t __rt_init_##fn SECTION(".rti_fn."level) = fn
N	#endif
N#endif
N#else
S#define INIT_EXPORT(fn, level)
N#endif
N
N/* board init routines will be called in board_init() function */
N#define INIT_BOARD_EXPORT(fn)           INIT_EXPORT(fn, "1")
N/* device/component/fs/app init routines will be called in init_thread */
N/* device initialization */
N#define INIT_DEVICE_EXPORT(fn)          INIT_EXPORT(fn, "2")
N/* components initialization (dfs, lwip, ...) */
N#define INIT_COMPONENT_EXPORT(fn)       INIT_EXPORT(fn, "3")
N/* file system initialization (dfs-elm, dfs-rom, ...) */
N#define INIT_FS_EXPORT(fn)              INIT_EXPORT(fn, "4")
N/* environment initialization (mount disk, ...) */
N#define INIT_ENV_EXPORT(fn)				INIT_EXPORT(fn, "5")
N/* appliation initialization (rtgui application etc ...) */
N#define INIT_APP_EXPORT(fn)             INIT_EXPORT(fn, "6")
N
N#if !defined(RT_USING_FINSH)
X#if !1L
S/* define these to empty, even if not include finsh.h file */
S#define FINSH_FUNCTION_EXPORT(name, desc)
S#define FINSH_FUNCTION_EXPORT_ALIAS(name, alias, desc)
S#define FINSH_VAR_EXPORT(name, type, desc)
S
S#define MSH_CMD_EXPORT(command, desc)
S#define MSH_CMD_EXPORT_ALIAS(command, alias, desc)
S#elif !defined(FINSH_USING_SYMTAB)
X#elif !1L
S#define FINSH_FUNCTION_EXPORT_CMD(name, cmd, desc)
N#endif
N
N/* event length */
N#define RT_EVENT_LENGTH                 32
N
N/* memory management option */
N#define RT_MM_PAGE_SIZE                 4096
N#define RT_MM_PAGE_MASK                 (RT_MM_PAGE_SIZE - 1)
N#define RT_MM_PAGE_BITS                 12
N
N/* kernel malloc definitions */
N#ifndef RT_KERNEL_MALLOC
N#define RT_KERNEL_MALLOC(sz)            rt_malloc(sz)
N#endif
N
N#ifndef RT_KERNEL_FREE
N#define RT_KERNEL_FREE(ptr)             rt_free(ptr)
N#endif
N
N#ifndef RT_KERNEL_REALLOC
N#define RT_KERNEL_REALLOC(ptr, size)    rt_realloc(ptr, size)
N#endif
N
N/**
N * @addtogroup Error
N */
N
N/*@{*/
N
N/* RT-Thread error code definitions */
N#define RT_EOK                          0               /**< There is no error */
N#define RT_ERROR                        1               /**< A generic error happens */
N#define RT_ETIMEOUT                     2               /**< Timed out */
N#define RT_EFULL                        3               /**< The resource is full */
N#define RT_EEMPTY                       4               /**< The resource is empty */
N#define RT_ENOMEM                       5               /**< No memory */
N#define RT_ENOSYS                       6               /**< No system */
N#define RT_EBUSY                        7               /**< Busy */
N#define RT_EIO                          8               /**< IO error */
N
N/*@}*/
N
N/**
N * @ingroup BasicDef
N *
N * @def RT_ALIGN(size, align)
N * Return the most contiguous size aligned at specified width. RT_ALIGN(13, 4)
N * would return 16.
N */
N#define RT_ALIGN(size, align)           (((size) + (align) - 1) & ~((align) - 1))
N
N/**
N * @ingroup BasicDef
N *
N * @def RT_ALIGN_DOWN(size, align)
N * Return the down number of aligned at specified width. RT_ALIGN_DOWN(13, 4)
N * would return 12.
N */
N#define RT_ALIGN_DOWN(size, align)      ((size) & ~((align) - 1))
N
N/**
N * @ingroup BasicDef
N *
N * @def RT_NULL
N * Similar as the \c NULL in C library.
N */
N#define RT_NULL                         (0)
N
Nstruct rt_list_node
N{
N    struct rt_list_node *next;                          /**< point to next node. */
N    struct rt_list_node *prev;                          /**< point to prev node. */
N};
Ntypedef struct rt_list_node rt_list_t;                  /**< Type for lists. */
N
N/**
N * @addtogroup KernelObject
N */
N
N/*@{*/
N
N/*
N * kernel object macros
N */
N#define RT_OBJECT_FLAG_MODULE           0x80            /**< is module object. */
N
N/**
N * Base structure of Kernel object
N */
Nstruct rt_object
N{
N    char       name[RT_NAME_MAX];                       /**< name of kernel object */
X    char       name[8];                        
N    rt_uint8_t type;                                    /**< type of kernel object */
N    rt_uint8_t flag;                                    /**< flag of kernel object */
N
N#ifdef RT_USING_MODULE
S    void      *module_id;                               /**< id of application module */
N#endif
N    rt_list_t  list;                                    /**< list node of kernel object */
N};
Ntypedef struct rt_object *rt_object_t;                  /**< Type for kernel objects. */
N
N/**
N *  The object type can be one of the follows with specific
N *  macros enabled:
N *  - Thread
N *  - Semaphore
N *  - Mutex
N *  - Event
N *  - MailBox
N *  - MessageQueue
N *  - MemHeap
N *  - MemPool
N *  - Device
N *  - Timer
N *  - Module
N *  - Unknown
N *  - Static
N */
Nenum rt_object_class_type
N{
N    RT_Object_Class_Thread = 0,                         /**< The object is a thread. */
N#ifdef RT_USING_SEMAPHORE
N    RT_Object_Class_Semaphore,                          /**< The object is a semaphore. */
N#endif
N#ifdef RT_USING_MUTEX
N    RT_Object_Class_Mutex,                              /**< The object is a mutex. */
N#endif
N#ifdef RT_USING_EVENT
N    RT_Object_Class_Event,                              /**< The object is a event. */
N#endif
N#ifdef RT_USING_MAILBOX
N    RT_Object_Class_MailBox,                            /**< The object is a mail box. */
N#endif
N#ifdef RT_USING_MESSAGEQUEUE
N    RT_Object_Class_MessageQueue,                       /**< The object is a message queue. */
N#endif
N#ifdef RT_USING_MEMHEAP
S    RT_Object_Class_MemHeap,                            /**< The object is a memory heap */
N#endif
N#ifdef RT_USING_MEMPOOL
N    RT_Object_Class_MemPool,                            /**< The object is a memory pool. */
N#endif
N#ifdef RT_USING_DEVICE
N    RT_Object_Class_Device,                             /**< The object is a device */
N#endif
N    RT_Object_Class_Timer,                              /**< The object is a timer. */
N#ifdef RT_USING_MODULE
S    RT_Object_Class_Module,                             /**< The object is a module. */
N#endif
N    RT_Object_Class_Unknown,                            /**< The object is unknown. */
N    RT_Object_Class_Static = 0x80                       /**< The object is a static object. */
N};
N
N/**
N * The information of the kernel object
N */
Nstruct rt_object_information
N{
N    enum rt_object_class_type type;                     /**< object class type */
N    rt_list_t                 object_list;              /**< object list */
N    rt_size_t                 object_size;              /**< object size */
N};
N
N/**
N * The hook function call macro
N */
N#ifdef RT_USING_HOOK
S#define RT_OBJECT_HOOK_CALL(func, argv) \
S    do { if ((func) != RT_NULL) func argv; } while (0)
X#define RT_OBJECT_HOOK_CALL(func, argv)     do { if ((func) != RT_NULL) func argv; } while (0)
N#else
N#define RT_OBJECT_HOOK_CALL(func, argv)
N#endif
N
N/*@}*/
N
N/**
N * @addtogroup Clock
N */
N
N/*@{*/
N
N/**
N * clock & timer macros
N */
N#define RT_TIMER_FLAG_DEACTIVATED       0x0             /**< timer is deactive */
N#define RT_TIMER_FLAG_ACTIVATED         0x1             /**< timer is active */
N#define RT_TIMER_FLAG_ONE_SHOT          0x0             /**< one shot timer */
N#define RT_TIMER_FLAG_PERIODIC          0x2             /**< periodic timer */
N
N#define RT_TIMER_FLAG_HARD_TIMER        0x0             /**< hard timer,the timer's callback function will be called in tick isr. */
N#define RT_TIMER_FLAG_SOFT_TIMER        0x4             /**< soft timer,the timer's callback function will be called in timer thread. */
N
N#define RT_TIMER_CTRL_SET_TIME          0x0             /**< set timer control command */
N#define RT_TIMER_CTRL_GET_TIME          0x1             /**< get timer control command */
N#define RT_TIMER_CTRL_SET_ONESHOT       0x2             /**< change timer to one shot */
N#define RT_TIMER_CTRL_SET_PERIODIC      0x3             /**< change timer to periodic */
N
N#ifndef RT_TIMER_SKIP_LIST_LEVEL
N#define RT_TIMER_SKIP_LIST_LEVEL          1
N#endif
N
N/* 1 or 3 */
N#ifndef RT_TIMER_SKIP_LIST_MASK
N#define RT_TIMER_SKIP_LIST_MASK         0x3
N#endif
N
N/**
N * timer structure
N */
Nstruct rt_timer
N{
N    struct rt_object parent;                            /**< inherit from rt_object */
N
N    rt_list_t        row[RT_TIMER_SKIP_LIST_LEVEL];
X    rt_list_t        row[1];
N
N    void (*timeout_func)(void *parameter);              /**< timeout function */
N    void            *parameter;                         /**< timeout function's parameter */
N
N    rt_tick_t        init_tick;                         /**< timer timeout tick */
N    rt_tick_t        timeout_tick;                      /**< timeout tick */
N};
Ntypedef struct rt_timer *rt_timer_t;
N
N/*@}*/
N
N/**
N * @addtogroup Thread
N */
N
N/*@{*/
N
N/*
N * Thread
N */
N
N/*
N * thread state definitions
N */
N#define RT_THREAD_INIT                  0x00                /**< Initialized status */
N#define RT_THREAD_READY                 0x01                /**< Ready status */
N#define RT_THREAD_SUSPEND               0x02                /**< Suspend status */
N#define RT_THREAD_RUNNING               0x03                /**< Running status */
N#define RT_THREAD_BLOCK                 RT_THREAD_SUSPEND   /**< Blocked status */
N#define RT_THREAD_CLOSE                 0x04                /**< Closed status */
N
N/**
N * thread control command definitions
N */
N#define RT_THREAD_CTRL_STARTUP          0x00                /**< Startup thread. */
N#define RT_THREAD_CTRL_CLOSE            0x01                /**< Close thread. */
N#define RT_THREAD_CTRL_CHANGE_PRIORITY  0x02                /**< Change thread priority. */
N#define RT_THREAD_CTRL_INFO             0x03                /**< Get thread information. */
N
N/**
N * Thread structure
N */
Nstruct rt_thread
N{
N    /* rt object */
N    char        name[RT_NAME_MAX];                      /**< the name of thread */
X    char        name[8];                       
N    rt_uint8_t  type;                                   /**< type of object */
N    rt_uint8_t  flags;                                  /**< thread's flags */
N
N#ifdef RT_USING_MODULE
S    void       *module_id;                              /**< id of application module */
N#endif
N
N    rt_list_t   list;                                   /**< the object list */
N    rt_list_t   tlist;                                  /**< the thread list */
N
N    /* stack point and entry */
N    void       *sp;                                     /**< stack point */
N    void       *entry;                                  /**< entry */
N    void       *parameter;                              /**< parameter */
N    void       *stack_addr;                             /**< stack address */
N    rt_uint32_t stack_size;                             /**< stack size */
N
N    /* error code */
N    rt_err_t    error;                                  /**< error code */
N
N    rt_uint8_t  stat;                                   /**< thread stat */
N
N    /* priority */
N    rt_uint8_t  current_priority;                       /**< current priority */
N    rt_uint8_t  init_priority;                          /**< initialized priority */
N#if RT_THREAD_PRIORITY_MAX > 32
X#if 32 > 32
S    rt_uint8_t  number;
S    rt_uint8_t  high_mask;
N#endif
N    rt_uint32_t number_mask;
N
N#if defined(RT_USING_EVENT)
X#if 1L
N    /* thread event */
N    rt_uint32_t event_set;
N    rt_uint8_t  event_info;
N#endif
N
N    rt_ubase_t  init_tick;                              /**< thread's initialized tick */
N    rt_ubase_t  remaining_tick;                         /**< remaining tick */
N
N    struct rt_timer thread_timer;                       /**< built-in thread timer */
N
N    void (*cleanup)(struct rt_thread *tid);             /**< cleanup function when thread exit */
N
N    rt_uint32_t user_data;                              /**< private user data beyond this thread */
N};
Ntypedef struct rt_thread *rt_thread_t;
N
N/*@}*/
N
N/**
N * @addtogroup IPC
N */
N
N/*@{*/
N
N/**
N * IPC flags and control command definitions
N */
N#define RT_IPC_FLAG_FIFO                0x00            /**< FIFOed IPC. @ref IPC. */
N#define RT_IPC_FLAG_PRIO                0x01            /**< PRIOed IPC. @ref IPC. */
N
N#define RT_IPC_CMD_UNKNOWN              0x00            /**< unknown IPC command */
N#define RT_IPC_CMD_RESET                0x01            /**< reset IPC object */
N
N#define RT_WAITING_FOREVER              -1              /**< Block forever until get resource. */
N#define RT_WAITING_NO                   0               /**< Non-block. */
N
N/**
N * Base structure of IPC object
N */
Nstruct rt_ipc_object
N{
N    struct rt_object parent;                            /**< inherit from rt_object */
N
N    rt_list_t        suspend_thread;                    /**< threads pended on this resource */
N};
N
N#ifdef RT_USING_SEMAPHORE
N/**
N * Semaphore structure
N */
Nstruct rt_semaphore
N{
N    struct rt_ipc_object parent;                        /**< inherit from ipc_object */
N
N    rt_uint16_t          value;                         /**< value of semaphore. */
N};
Ntypedef struct rt_semaphore *rt_sem_t;
N#endif
N
N#ifdef RT_USING_MUTEX
N/**
N * Mutual exclusion (mutex) structure
N */
Nstruct rt_mutex
N{
N    struct rt_ipc_object parent;                        /**< inherit from ipc_object */
N
N    rt_uint16_t          value;                         /**< value of mutex */
N
N    rt_uint8_t           original_priority;             /**< priority of last thread hold the mutex */
N    rt_uint8_t           hold;                          /**< numbers of thread hold the mutex */
N
N    struct rt_thread    *owner;                         /**< current owner of mutex */
N};
Ntypedef struct rt_mutex *rt_mutex_t;
N#endif
N
N#ifdef RT_USING_EVENT
N/**
N * flag defintions in event
N */
N#define RT_EVENT_FLAG_AND               0x01            /**< logic and */
N#define RT_EVENT_FLAG_OR                0x02            /**< logic or */
N#define RT_EVENT_FLAG_CLEAR             0x04            /**< clear flag */
N
N/*
N * event structure
N */
Nstruct rt_event
N{
N    struct rt_ipc_object parent;                        /**< inherit from ipc_object */
N
N    rt_uint32_t          set;                           /**< event set */
N};
Ntypedef struct rt_event *rt_event_t;
N#endif
N
N#ifdef RT_USING_MAILBOX
N/**
N * mailbox structure
N */
Nstruct rt_mailbox
N{
N    struct rt_ipc_object parent;                        /**< inherit from ipc_object */
N
N    rt_uint32_t         *msg_pool;                      /**< start address of message buffer */
N
N    rt_uint16_t          size;                          /**< size of message pool */
N
N    rt_uint16_t          entry;                         /**< index of messages in msg_pool */
N    rt_uint16_t          in_offset;                     /**< input offset of the message buffer */
N    rt_uint16_t          out_offset;                    /**< output offset of the message buffer */
N
N    rt_list_t            suspend_sender_thread;         /**< sender thread suspended on this mailbox */
N};
Ntypedef struct rt_mailbox *rt_mailbox_t;
N#endif
N
N#ifdef RT_USING_MESSAGEQUEUE
N/**
N * message queue structure
N */
Nstruct rt_messagequeue
N{
N    struct rt_ipc_object parent;                        /**< inherit from ipc_object */
N
N    void                *msg_pool;                      /**< start address of message queue */
N
N    rt_uint16_t          msg_size;                      /**< message size of each message */
N    rt_uint16_t          max_msgs;                      /**< max number of messages */
N
N    rt_uint16_t          entry;                         /**< index of messages in the queue */
N
N    void                *msg_queue_head;                /**< list head */
N    void                *msg_queue_tail;                /**< list tail */
N    void                *msg_queue_free;                /**< pointer indicated the free node of queue */
N};
Ntypedef struct rt_messagequeue *rt_mq_t;
N#endif
N
N/*@}*/
N
N/**
N * @addtogroup MM
N */
N
N/*@{*/
N
N/*
N * memory management
N * heap & partition
N */
N
N#ifdef RT_USING_MEMHEAP
S/**
S * memory item on the heap
S */
Sstruct rt_memheap_item
S{
S    rt_uint32_t             magic;                      /**< magic number for memheap */
S    struct rt_memheap      *pool_ptr;                   /**< point of pool */
S
S    struct rt_memheap_item *next;                       /**< next memheap item */
S    struct rt_memheap_item *prev;                       /**< prev memheap item */
S
S    struct rt_memheap_item *next_free;                  /**< next free memheap item */
S    struct rt_memheap_item *prev_free;                  /**< prev free memheap item */
S};
S
S/**
S * Base structure of memory heap object
S */
Sstruct rt_memheap
S{
S    struct rt_object        parent;                     /**< inherit from rt_object */
S
S    void                   *start_addr;                 /**< pool start address and size */
S
S    rt_uint32_t             pool_size;                  /**< pool size */
S    rt_uint32_t             available_size;             /**< available size */
S    rt_uint32_t             max_used_size;              /**< maximum allocated size */
S
S    struct rt_memheap_item *block_list;                 /**< used block list */
S
S    struct rt_memheap_item *free_list;                  /**< free block list */
S    struct rt_memheap_item  free_header;                /**< free block list header */
S
S    struct rt_semaphore     lock;                       /**< semaphore lock */
S};
N#endif
N
N#ifdef RT_USING_MEMPOOL
N/**
N * Base structure of Memory pool object
N */
Nstruct rt_mempool
N{
N    struct rt_object parent;                            /**< inherit from rt_object */
N
N    void            *start_address;                     /**< memory pool start */
N    rt_size_t        size;                              /**< size of memory pool */
N
N    rt_size_t        block_size;                        /**< size of memory blocks */
N    rt_uint8_t      *block_list;                        /**< memory blocks list */
N
N    rt_size_t        block_total_count;                 /**< numbers of memory block */
N    rt_size_t        block_free_count;                  /**< numbers of free memory block */
N
N    rt_list_t        suspend_thread;                    /**< threads pended on this resource */
N    rt_size_t        suspend_thread_count;              /**< numbers of thread pended on this resource */
N};
Ntypedef struct rt_mempool *rt_mp_t;
N#endif
N
N/*@}*/
N
N#ifdef RT_USING_DEVICE
N/**
N * @addtogroup Device
N */
N
N/*@{*/
N
N/**
N * device (I/O) class type
N */
Nenum rt_device_class_type
N{
N    RT_Device_Class_Char = 0,                           /**< character device */
N    RT_Device_Class_Block,                              /**< block device */
N    RT_Device_Class_NetIf,                              /**< net interface */
N    RT_Device_Class_MTD,                                /**< memory device */
N    RT_Device_Class_CAN,                                /**< CAN device */
N    RT_Device_Class_RTC,                                /**< RTC device */
N    RT_Device_Class_Sound,                              /**< Sound device */
N    RT_Device_Class_Graphic,                            /**< Graphic device */
N    RT_Device_Class_I2CBUS,                             /**< I2C bus device */
N    RT_Device_Class_USBDevice,                          /**< USB slave device */
N    RT_Device_Class_USBHost,                            /**< USB host bus */
N    RT_Device_Class_SPIBUS,                             /**< SPI bus device */
N    RT_Device_Class_SPIDevice,                          /**< SPI device */
N    RT_Device_Class_SDIO,                               /**< SDIO bus device */
N    RT_Device_Class_PM,                                 /**< PM pseudo device */
N    RT_Device_Class_Pipe,                               /**< Pipe device */
N    RT_Device_Class_Portal,                             /**< Portal device */
N    RT_Device_Class_Timer,                              /**< Timer device */
N	RT_Device_Class_Miscellaneous,                      /**< Miscellaneous device */
N	RT_Device_Class_Unknown                             /**< unknown device */
N};
N
N/**
N * device flags defitions
N */
N#define RT_DEVICE_FLAG_DEACTIVATE       0x000           /**< device is not not initialized */
N
N#define RT_DEVICE_FLAG_RDONLY           0x001           /**< read only */
N#define RT_DEVICE_FLAG_WRONLY           0x002           /**< write only */
N#define RT_DEVICE_FLAG_RDWR             0x003           /**< read and write */
N
N#define RT_DEVICE_FLAG_REMOVABLE        0x004           /**< removable device */
N#define RT_DEVICE_FLAG_STANDALONE       0x008           /**< standalone device */
N#define RT_DEVICE_FLAG_ACTIVATED        0x010           /**< device is activated */
N#define RT_DEVICE_FLAG_SUSPENDED        0x020           /**< device is suspended */
N#define RT_DEVICE_FLAG_STREAM           0x040           /**< stream mode */
N
N#define RT_DEVICE_CTRL_CONFIG           0x03    	/* configure device */
N#define RT_DEVICE_CTRL_SET_INT          0x10    	/* enable receive irq */
N#define RT_DEVICE_CTRL_CLR_INT          0x11    	/* disable receive irq */
N#define RT_DEVICE_CTRL_GET_INT          0x12
N
N#define RT_DEVICE_FLAG_INT_RX           0x100           /**< INT mode on Rx */
N#define RT_DEVICE_FLAG_DMA_RX           0x200           /**< DMA mode on Rx */
N#define RT_DEVICE_FLAG_INT_TX           0x400           /**< INT mode on Tx */
N#define RT_DEVICE_FLAG_DMA_TX           0x800           /**< DMA mode on Tx */
N
N#define RT_DEVICE_OFLAG_CLOSE           0x000           /**< device is closed */
N#define RT_DEVICE_OFLAG_RDONLY          0x001           /**< read only access */
N#define RT_DEVICE_OFLAG_WRONLY          0x002           /**< write only access */
N#define RT_DEVICE_OFLAG_RDWR            0x003           /**< read and write */
N#define RT_DEVICE_OFLAG_OPEN            0x008           /**< device is opened */
N
N/**
N * general device commands
N */
N#define RT_DEVICE_CTRL_RESUME           0x01            /**< resume device */
N#define RT_DEVICE_CTRL_SUSPEND          0x02            /**< suspend device */
N
N/**
N * special device commands
N */
N#define RT_DEVICE_CTRL_CHAR_STREAM      0x10            /**< stream mode on char device */
N#define RT_DEVICE_CTRL_BLK_GETGEOME     0x10            /**< get geometry information   */
N#define RT_DEVICE_CTRL_BLK_SYNC         0x11            /**< flush data to block device */
N#define RT_DEVICE_CTRL_BLK_ERASE        0x12            /**< erase block on block device */
N#define RT_DEVICE_CTRL_BLK_AUTOREFRESH  0x13            /**< block device : enter/exit auto refresh mode */
N#define RT_DEVICE_CTRL_NETIF_GETMAC     0x10            /**< get mac address */
N#define RT_DEVICE_CTRL_MTD_FORMAT       0x10            /**< format a MTD device */
N#define RT_DEVICE_CTRL_RTC_GET_TIME     0x10            /**< get time */
N#define RT_DEVICE_CTRL_RTC_SET_TIME     0x11            /**< set time */
N#define RT_DEVICE_CTRL_RTC_GET_ALARM    0x12            /**< get alarm */
N#define RT_DEVICE_CTRL_RTC_SET_ALARM    0x13            /**< set alarm */
N
Ntypedef struct rt_device *rt_device_t;
N/**
N * Device structure
N */
Nstruct rt_device
N{
N    struct rt_object          parent;                   /**< inherit from rt_object */
N
N    enum rt_device_class_type type;                     /**< device type */
N    rt_uint16_t               flag;                     /**< device flag */
N    rt_uint16_t               open_flag;                /**< device open flag */
N
N    rt_uint8_t                ref_count;                /**< reference count */
N    rt_uint8_t                device_id;                /**< 0 - 255 */
N
N    /* device call back */
N    rt_err_t (*rx_indicate)(rt_device_t dev, rt_size_t size);
N    rt_err_t (*tx_complete)(rt_device_t dev, void *buffer);
N
N    /* common device interface */
N    rt_err_t  (*init)   (rt_device_t dev);
N    rt_err_t  (*open)   (rt_device_t dev, rt_uint16_t oflag);
N    rt_err_t  (*close)  (rt_device_t dev);
N    rt_size_t (*read)   (rt_device_t dev, rt_off_t pos, void *buffer, rt_size_t size);
N    rt_size_t (*write)  (rt_device_t dev, rt_off_t pos, const void *buffer, rt_size_t size);
N    rt_err_t  (*control)(rt_device_t dev, rt_uint8_t cmd, void *args);
N
N    void                     *user_data;                /**< device private data */
N};
N
N/**
N * block device geometry structure
N */
Nstruct rt_device_blk_geometry
N{
N    rt_uint32_t sector_count;                           /**< count of sectors */
N    rt_uint32_t bytes_per_sector;                       /**< number of bytes per sector */
N    rt_uint32_t block_size;                             /**< number of bytes to erase one block */
N};
N
N/**
N * sector arrange struct on block device
N */
Nstruct rt_device_blk_sectors
N{
N    rt_uint32_t sector_begin;                           /**< begin sector */
N    rt_uint32_t sector_end;                             /**< end sector   */
N};
N
N/**
N * cursor control command
N */
N#define RT_DEVICE_CTRL_CURSOR_SET_POSITION  0x10
N#define RT_DEVICE_CTRL_CURSOR_SET_TYPE      0x11
N
N/**
N * graphic device control command
N */
N#define RTGRAPHIC_CTRL_RECT_UPDATE      0
N#define RTGRAPHIC_CTRL_POWERON          1
N#define RTGRAPHIC_CTRL_POWEROFF         2
N#define RTGRAPHIC_CTRL_GET_INFO         3
N#define RTGRAPHIC_CTRL_SET_MODE         4
N#define RTGRAPHIC_CTRL_GET_EXT          5
N
N/* graphic deice */
Nenum
N{
N    RTGRAPHIC_PIXEL_FORMAT_MONO = 0,
N    RTGRAPHIC_PIXEL_FORMAT_GRAY4,
N    RTGRAPHIC_PIXEL_FORMAT_GRAY16,
N    RTGRAPHIC_PIXEL_FORMAT_RGB332,
N    RTGRAPHIC_PIXEL_FORMAT_RGB444,
N    RTGRAPHIC_PIXEL_FORMAT_RGB565,
N    RTGRAPHIC_PIXEL_FORMAT_RGB565P,
N    RTGRAPHIC_PIXEL_FORMAT_BGR565 = RTGRAPHIC_PIXEL_FORMAT_RGB565P,
N    RTGRAPHIC_PIXEL_FORMAT_RGB666,
N    RTGRAPHIC_PIXEL_FORMAT_RGB888,
N    RTGRAPHIC_PIXEL_FORMAT_ARGB888,
N    RTGRAPHIC_PIXEL_FORMAT_ABGR888,
N    RTGRAPHIC_PIXEL_FORMAT_ARGB565,
N    RTGRAPHIC_PIXEL_FORMAT_ALPHA,
N};
N
N/**
N * build a pixel position according to (x, y) coordinates.
N */
N#define RTGRAPHIC_PIXEL_POSITION(x, y)  ((x << 16) | y)
N
N/**
N * graphic device information structure
N */
Nstruct rt_device_graphic_info
N{
N    rt_uint8_t  pixel_format;                           /**< graphic format */
N    rt_uint8_t  bits_per_pixel;                         /**< bits per pixel */
N    rt_uint16_t reserved;                               /**< reserved field */
N
N    rt_uint16_t width;                                  /**< width of graphic device */
N    rt_uint16_t height;                                 /**< height of graphic device */
N
N    rt_uint8_t *framebuffer;                            /**< frame buffer */
N};
N
N/**
N * rectangle information structure
N */
Nstruct rt_device_rect_info
N{
N    rt_uint16_t x;                                      /**< x coordinate */
N    rt_uint16_t y;                                      /**< y coordinate */
N    rt_uint16_t width;                                  /**< width */
N    rt_uint16_t height;                                 /**< height */
N};
N
N/**
N * graphic operations
N */
Nstruct rt_device_graphic_ops
N{
N    void (*set_pixel) (const char *pixel, int x, int y);
N    void (*get_pixel) (char *pixel, int x, int y);
N
N    void (*draw_hline)(const char *pixel, int x1, int x2, int y);
N    void (*draw_vline)(const char *pixel, int x, int y1, int y2);
N
N    void (*blit_line) (const char *pixel, int x, int y, rt_size_t size);
N};
N#define rt_graphix_ops(device)          ((struct rt_device_graphic_ops *)(device->user_data))
N
N/*@}*/
N#endif
N
N#ifdef RT_USING_MODULE
S/**
S * @addtogroup Module
S */
S
S/*@{*/
S
S/*
S * module system
S */
S
S#define RT_MODULE_FLAG_WITHENTRY        0x00            /**< with entry point */
S#define RT_MODULE_FLAG_WITHOUTENTRY     0x01            /**< without entry point */
S
S/**
S * Application Module structure
S */
Sstruct rt_module
S{
S    struct rt_object             parent;                /**< inherit from object */
S
S    rt_uint32_t                  vstart_addr;            /**< VMA base address for the
S                                                          first LOAD segment. */
S    rt_uint8_t                  *module_space;          /**< module memory space */
S
S    void                        *module_entry;          /**< the entry address of module */
S    rt_thread_t                  module_thread;         /**< the main thread of module */
S
S	rt_uint8_t*                  module_cmd_line;		/**< module command line */
S	rt_uint32_t                  module_cmd_size;		/**< the size of module command line */
S
S#ifdef RT_USING_SLAB
S    /* module memory allocator */
S    void                        *mem_list;              /**< module's free memory list */
S    void                        *page_array;            /**< module's using pages */
S    rt_uint32_t                  page_cnt;              /**< module's using pages count */
S#endif
S
S    rt_uint16_t                  nref;                  /**< reference count */
S
S    rt_uint16_t                  nsym;                  /**< number of symbol in the module */
S    struct rt_module_symtab     *symtab;                /**< module symbol table */
S
S    /* object in this module, module object is the last basic object type */
S    struct rt_object_information module_object[RT_Object_Class_Unknown];
S};
Stypedef struct rt_module *rt_module_t;
S
S/*@}*/
N#endif
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 38 "..\..\include\rtthread.h" 2
N#include <rtservice.h>
L 1 "..\..\include\rtservice.h" 1
N/*
N * File      : rtservice.h
N * This file is part of RT-Thread RTOS
N * COPYRIGHT (C) 2006 - 2012, RT-Thread Development Team
N *
N *  This program is free software; you can redistribute it and/or modify
N *  it under the terms of the GNU General Public License as published by
N *  the Free Software Foundation; either version 2 of the License, or
N *  (at your option) any later version.
N *
N *  This program is distributed in the hope that it will be useful,
N *  but WITHOUT ANY WARRANTY; without even the implied warranty of
N *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
N *  GNU General Public License for more details.
N *
N *  You should have received a copy of the GNU General Public License along
N *  with this program; if not, write to the Free Software Foundation, Inc.,
N *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
N *
N * Change Logs:
N * Date           Author       Notes
N * 2006-03-16     Bernard      the first version
N * 2006-09-07     Bernard      move the kservice APIs to rtthread.h
N * 2007-06-27     Bernard      fix the rt_list_remove bug
N * 2012-03-22     Bernard      rename kservice.h to rtservice.h
N */
N
N#ifndef __RT_SERVICE_H__
N#define __RT_SERVICE_H__
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/**
N * @addtogroup KernelService
N */
N
N/*@{*/
N
N/**
N * @brief initialize a list object
N */
N#define RT_LIST_OBJECT_INIT(object) { &(object), &(object) }
N
N/**
N * @brief initialize a list
N *
N * @param l list to be initialized
N */
Nrt_inline void rt_list_init(rt_list_t *l)
Xstatic __inline void rt_list_init(rt_list_t *l)
N{
N    l->next = l->prev = l;
N}
N
N/**
N * @brief insert a node after a list
N * ½«Á´±íÖÐ n ²åÈëµ½ l Ö®ºó
N * @param l list to insert it
N * @param n new node to be inserted
N */
Nrt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
Xstatic __inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
N{
N    l->next->prev = n;
N    n->next = l->next;
N
N    l->next = n;
N    n->prev = l;
N}
N
N/**
N * @brief insert a node before a list
N *        ½«Á´±íÖÐ n ²åÈëµ½ l Ö®Ç°
N * @param n new node to be inserted
N * @param l list to insert it
N */
Nrt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
Xstatic __inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
N{
N    l->prev->next = n;
N    n->prev = l->prev;
N
N    l->prev = n;
N    n->next = l;
N}
N
N/**
N * @brief remove node from list.
N * ½«n´ÓÁ´±íÖÐÒÆ³ý
N * @param n the node to remove from the list.
N */
Nrt_inline void rt_list_remove(rt_list_t *n)
Xstatic __inline void rt_list_remove(rt_list_t *n)
N{
N    n->next->prev = n->prev;
N    n->prev->next = n->next;
N
N    n->next = n->prev = n;
N}
N
N/**
N * @brief tests whether a list is empty
N * @param l the list to test.
N */
Nrt_inline int rt_list_isempty(const rt_list_t *l)
Xstatic __inline int rt_list_isempty(const rt_list_t *l)
N{
N    return l->next == l;
N}
N
N/**
N * @brief get the struct for this entry
N * @param node the entry point
N * @param type the type of structure
N * @param member the name of list in structure
N */
N#define rt_list_entry(node, type, member) \
N    ((type *)((char *)(node) - (unsigned long)(&((type *)0)->member)))
X#define rt_list_entry(node, type, member)     ((type *)((char *)(node) - (unsigned long)(&((type *)0)->member)))
N
N/**
N * rt_list_for_each_entry  -   iterate over list of given type
N * @pos:    the type * to use as a loop cursor.
N * @head:   the head for your list.
N * @member: the name of the list_struct within the struct.
N */
N#define rt_list_for_each_entry(pos, head, member)              \
N    for (pos = rt_list_entry((head)->next, typeof(*pos), member);  \
N         &pos->member != (head);    \
N         pos = rt_list_entry(pos->member.next, typeof(*pos), member))
X#define rt_list_for_each_entry(pos, head, member)                  for (pos = rt_list_entry((head)->next, typeof(*pos), member);           &pos->member != (head);             pos = rt_list_entry(pos->member.next, typeof(*pos), member))
N
N/**
N * rt_list_first_entry - get the first element from a list
N * @ptr:    the list head to take the element from.
N * @type:   the type of the struct this is embedded in.
N * @member: the name of the list_struct within the struct.
N *
N * Note, that list is expected to be not empty.
N */
N#define rt_list_first_entry(ptr, type, member) \
N    rt_list_entry((ptr)->next, type, member)
X#define rt_list_first_entry(ptr, type, member)     rt_list_entry((ptr)->next, type, member)
N/*@}*/
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 39 "..\..\include\rtthread.h" 2
N#include <rtm.h>
L 1 "..\..\include\rtm.h" 1
N/*
N * File      : rtm.h
N * This file is part of RT-Thread RTOS
N * COPYRIGHT (C) 2006 - 2012, RT-Thread Development Team
N *
N *  This program is free software; you can redistribute it and/or modify
N *  it under the terms of the GNU General Public License as published by
N *  the Free Software Foundation; either version 2 of the License, or
N *  (at your option) any later version.
N *
N *  This program is distributed in the hope that it will be useful,
N *  but WITHOUT ANY WARRANTY; without even the implied warranty of
N *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
N *  GNU General Public License for more details.
N *
N *  You should have received a copy of the GNU General Public License along
N *  with this program; if not, write to the Free Software Foundation, Inc.,
N *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
N */
N
N#ifndef __RTM_H__
N#define __RTM_H__
N
N#include <rtdef.h>
N#include <rtthread.h>
L 1 "..\..\include\rtthread.h" 1
N/*
N * File      : rtthread.h
N * This file is part of RT-Thread RTOS
N * COPYRIGHT (C) 2006 - 2012, RT-Thread Development Team
N *
N *  This program is free software; you can redistribute it and/or modify
N *  it under the terms of the GNU General Public License as published by
N *  the Free Software Foundation; either version 2 of the License, or
N *  (at your option) any later version.
N *
N *  This program is distributed in the hope that it will be useful,
N *  but WITHOUT ANY WARRANTY; without even the implied warranty of
N *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
N *  GNU General Public License for more details.
N *
N *  You should have received a copy of the GNU General Public License along
N *  with this program; if not, write to the Free Software Foundation, Inc.,
N *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
N *
N * Change Logs:
N * Date           Author       Notes
N * 2006-03-18     Bernard      the first version
N * 2006-04-26     Bernard      add semaphore APIs
N * 2006-08-10     Bernard      add version information
N * 2007-01-28     Bernard      rename RT_OBJECT_Class_Static to RT_Object_Class_Static
N * 2007-03-03     Bernard      clean up the definitions to rtdef.h
N * 2010-04-11     yi.qiu       add module feature
N * 2013-06-24     Bernard      add rt_kprintf re-define when not use RT_USING_CONSOLE.
N * 2016-08-09     ArdaFu       add new thread and interrupt hook.
N */
N
N#ifndef __RT_THREAD_H__
S#define __RT_THREAD_H__
S
S#include <rtconfig.h>
S#include <rtdebug.h>
S#include <rtdef.h>
S#include <rtservice.h>
S#include <rtm.h>
S
S#ifdef __cplusplus
Sextern "C" {
S#endif
S
S/**
S * @addtogroup KernelObject
S */
S
S/**@{*/
S
S/*
S * kernel object interface
S */
Svoid rt_system_object_init(void);
Sstruct rt_object_information *
Srt_object_get_information(enum rt_object_class_type type);
Svoid rt_object_init(struct rt_object         *object,
S                    enum rt_object_class_type type,
S                    const char               *name);
Svoid rt_object_detach(rt_object_t object);
Srt_object_t rt_object_allocate(enum rt_object_class_type type,
S                               const char               *name);
Svoid rt_object_delete(rt_object_t object);
Srt_bool_t rt_object_is_systemobject(rt_object_t object);
Srt_object_t rt_object_find(const char *name, rt_uint8_t type);
S
S#ifdef RT_USING_HOOK
Svoid rt_object_attach_sethook(void (*hook)(struct rt_object *object));
Svoid rt_object_detach_sethook(void (*hook)(struct rt_object *object));
Svoid rt_object_trytake_sethook(void (*hook)(struct rt_object *object));
Svoid rt_object_take_sethook(void (*hook)(struct rt_object *object));
Svoid rt_object_put_sethook(void (*hook)(struct rt_object *object));
S#endif
S
S/**@}*/
S
S/**
S * @addtogroup Clock
S */
S
S/**@{*/
S
S/*
S * clock & timer interface
S */
Svoid rt_system_tick_init(void);
Srt_tick_t rt_tick_get(void);
Svoid rt_tick_set(rt_tick_t tick);
Svoid rt_tick_increase(void);
Srt_tick_t rt_tick_from_millisecond(rt_uint32_t ms);
S
Svoid rt_system_timer_init(void);
Svoid rt_system_timer_thread_init(void);
S
Svoid rt_timer_init(rt_timer_t  timer,
S                   const char *name,
S                   void (*timeout)(void *parameter),
S                   void       *parameter,
S                   rt_tick_t   time,
S                   rt_uint8_t  flag);
Srt_err_t rt_timer_detach(rt_timer_t timer);
Srt_timer_t rt_timer_create(const char *name,
S                           void (*timeout)(void *parameter),
S                           void       *parameter,
S                           rt_tick_t   time,
S                           rt_uint8_t  flag);
Srt_err_t rt_timer_delete(rt_timer_t timer);
Srt_err_t rt_timer_start(rt_timer_t timer);
Srt_err_t rt_timer_stop(rt_timer_t timer);
Srt_err_t rt_timer_control(rt_timer_t timer, rt_uint8_t cmd, void *arg);
S
Srt_tick_t rt_timer_next_timeout_tick(void);
Svoid rt_timer_check(void);
S
S#ifdef RT_USING_HOOK
Svoid rt_timer_timeout_sethook(void (*hook)(struct rt_timer *timer));
S#endif
S
S/**@}*/
S
S/**
S * @addtogroup Thread
S */
S
S/**@{*/
S
S/*
S * thread interface
S */
Srt_err_t rt_thread_init(struct rt_thread *thread,
S                        const char       *name,
S                        void (*entry)(void *parameter),
S                        void             *parameter,
S                        void             *stack_start,
S                        rt_uint32_t       stack_size,
S                        rt_uint8_t        priority,
S                        rt_uint32_t       tick);
Srt_err_t rt_thread_detach(rt_thread_t thread);
Srt_thread_t rt_thread_create(const char *name,
S                             void (*entry)(void *parameter),
S                             void       *parameter,
S                             rt_uint32_t stack_size,
S                             rt_uint8_t  priority,
S                             rt_uint32_t tick);
Srt_thread_t rt_thread_self(void);
Srt_thread_t rt_thread_find(char *name);
Srt_err_t rt_thread_startup(rt_thread_t thread);
Srt_err_t rt_thread_delete(rt_thread_t thread);
S
Srt_err_t rt_thread_yield(void);
Srt_err_t rt_thread_delay(rt_tick_t tick);
Srt_err_t rt_thread_control(rt_thread_t thread, rt_uint8_t cmd, void *arg);
Srt_err_t rt_thread_suspend(rt_thread_t thread);
Srt_err_t rt_thread_resume(rt_thread_t thread);
Svoid rt_thread_timeout(void *parameter);
S
S#ifdef RT_USING_HOOK
Svoid rt_thread_suspend_sethook(void (*hook)(rt_thread_t thread));
Svoid rt_thread_resume_sethook (void (*hook)(rt_thread_t thread));
Svoid rt_thread_inited_sethook (void (*hook)(rt_thread_t thread));
S#endif
S
S/*
S * idle thread interface
S */
Svoid rt_thread_idle_init(void);
S#if defined(RT_USING_HOOK) || defined(RT_USING_IDLE_HOOK)
Svoid rt_thread_idle_sethook(void (*hook)(void));
S#endif
Svoid rt_thread_idle_excute(void);
Srt_thread_t rt_thread_idle_gethandler(void);
S
S/*
S * schedule service
S */
Svoid rt_system_scheduler_init(void);
Svoid rt_system_scheduler_start(void);
S
Svoid rt_schedule(void);
Svoid rt_schedule_insert_thread(struct rt_thread *thread);
Svoid rt_schedule_remove_thread(struct rt_thread *thread);
S
Svoid rt_enter_critical(void);
Svoid rt_exit_critical(void);
Srt_uint16_t rt_critical_level(void);
S
S#ifdef RT_USING_HOOK
Svoid rt_scheduler_sethook(void (*hook)(rt_thread_t from, rt_thread_t to));
S#endif
S
S/**@}*/
S
S/**
S * @addtogroup MM
S */
S
S/**@{*/
S
S/*
S * memory management interface
S */
S#ifdef RT_USING_MEMPOOL
S/*
S * memory pool interface
S */
Srt_err_t rt_mp_init(struct rt_mempool *mp,
S                    const char        *name,
S                    void              *start,
S                    rt_size_t          size,
S                    rt_size_t          block_size);
Srt_err_t rt_mp_detach(struct rt_mempool *mp);
Srt_mp_t rt_mp_create(const char *name,
S                     rt_size_t   block_count,
S                     rt_size_t   block_size);
Srt_err_t rt_mp_delete(rt_mp_t mp);
S
Svoid *rt_mp_alloc(rt_mp_t mp, rt_int32_t time);
Svoid rt_mp_free(void *block);
S
S#ifdef RT_USING_HOOK
Svoid rt_mp_alloc_sethook(void (*hook)(struct rt_mempool *mp, void *block));
Svoid rt_mp_free_sethook(void (*hook)(struct rt_mempool *mp, void *block));
S#endif
S
S#endif
S
S#ifdef RT_USING_HEAP
S/*
S * heap memory interface
S */
Svoid rt_system_heap_init(void *begin_addr, void *end_addr);
S
Svoid *rt_malloc(rt_size_t nbytes);
Svoid rt_free(void *ptr);
Svoid *rt_realloc(void *ptr, rt_size_t nbytes);
Svoid *rt_calloc(rt_size_t count, rt_size_t size);
Svoid *rt_malloc_align(rt_size_t size, rt_size_t align);
Svoid rt_free_align(void *ptr);
S
Svoid rt_memory_info(rt_uint32_t *total,
S                    rt_uint32_t *used,
S                    rt_uint32_t *max_used);
S
S#ifdef RT_USING_SLAB
Svoid *rt_page_alloc(rt_size_t npages);
Svoid rt_page_free(void *addr, rt_size_t npages);
S#endif
S
S#ifdef RT_USING_HOOK
Svoid rt_malloc_sethook(void (*hook)(void *ptr, rt_uint32_t size));
Svoid rt_free_sethook(void (*hook)(void *ptr));
S#endif
S
S#endif
S
S#ifdef RT_USING_MEMHEAP
S/**
S * memory heap object interface
S */
Srt_err_t rt_memheap_init(struct rt_memheap *memheap,
S                         const char        *name,
S                         void              *start_addr,
S                         rt_uint32_t        size);
Srt_err_t rt_memheap_detach(struct rt_memheap *heap);
Svoid* rt_memheap_alloc(struct rt_memheap *heap, rt_uint32_t size);
Svoid *rt_memheap_realloc(struct rt_memheap* heap, void* ptr, rt_size_t newsize);
Svoid rt_memheap_free(void *ptr);
S#endif
S
S/**@}*/
S
S/**
S * @addtogroup IPC
S */
S
S/**@{*/
S
S#ifdef RT_USING_SEMAPHORE
S/*
S * semaphore interface
S */
Srt_err_t rt_sem_init(rt_sem_t    sem,
S                     const char *name,
S                     rt_uint32_t value,
S                     rt_uint8_t  flag);
Srt_err_t rt_sem_detach(rt_sem_t sem);
Srt_sem_t rt_sem_create(const char *name, rt_uint32_t value, rt_uint8_t flag);
Srt_err_t rt_sem_delete(rt_sem_t sem);
S
Srt_err_t rt_sem_take(rt_sem_t sem, rt_int32_t time);
Srt_err_t rt_sem_trytake(rt_sem_t sem);
Srt_err_t rt_sem_release(rt_sem_t sem);
Srt_err_t rt_sem_control(rt_sem_t sem, rt_uint8_t cmd, void *arg);
S#endif
S
S#ifdef RT_USING_MUTEX
S/*
S * mutex interface
S */
Srt_err_t rt_mutex_init(rt_mutex_t mutex, const char *name, rt_uint8_t flag);
Srt_err_t rt_mutex_detach(rt_mutex_t mutex);
Srt_mutex_t rt_mutex_create(const char *name, rt_uint8_t flag);
Srt_err_t rt_mutex_delete(rt_mutex_t mutex);
S
Srt_err_t rt_mutex_take(rt_mutex_t mutex, rt_int32_t time);
Srt_err_t rt_mutex_release(rt_mutex_t mutex);
Srt_err_t rt_mutex_control(rt_mutex_t mutex, rt_uint8_t cmd, void *arg);
S#endif
S
S#ifdef RT_USING_EVENT
S/*
S * event interface
S */
Srt_err_t rt_event_init(rt_event_t event, const char *name, rt_uint8_t flag);
Srt_err_t rt_event_detach(rt_event_t event);
Srt_event_t rt_event_create(const char *name, rt_uint8_t flag);
Srt_err_t rt_event_delete(rt_event_t event);
S
Srt_err_t rt_event_send(rt_event_t event, rt_uint32_t set);
Srt_err_t rt_event_recv(rt_event_t   event,
S                       rt_uint32_t  set,
S                       rt_uint8_t   opt,
S                       rt_int32_t   timeout,
S                       rt_uint32_t *recved);
Srt_err_t rt_event_control(rt_event_t event, rt_uint8_t cmd, void *arg);
S#endif
S
S#ifdef RT_USING_MAILBOX
S/*
S * mailbox interface
S */
Srt_err_t rt_mb_init(rt_mailbox_t mb,
S                    const char  *name,
S                    void        *msgpool,
S                    rt_size_t    size,
S                    rt_uint8_t   flag);
Srt_err_t rt_mb_detach(rt_mailbox_t mb);
Srt_mailbox_t rt_mb_create(const char *name, rt_size_t size, rt_uint8_t flag);
Srt_err_t rt_mb_delete(rt_mailbox_t mb);
S
Srt_err_t rt_mb_send(rt_mailbox_t mb, rt_uint32_t value);
Srt_err_t rt_mb_send_wait(rt_mailbox_t mb,
S                         rt_uint32_t  value,
S                         rt_int32_t   timeout);
Srt_err_t rt_mb_recv(rt_mailbox_t mb, rt_uint32_t *value, rt_int32_t timeout);
Srt_err_t rt_mb_control(rt_mailbox_t mb, rt_uint8_t cmd, void *arg);
S#endif
S
S#ifdef RT_USING_MESSAGEQUEUE
S/*
S * message queue interface
S */
Srt_err_t rt_mq_init(rt_mq_t     mq,
S                    const char *name,
S                    void       *msgpool,
S                    rt_size_t   msg_size,
S                    rt_size_t   pool_size,
S                    rt_uint8_t  flag);
Srt_err_t rt_mq_detach(rt_mq_t mq);
Srt_mq_t rt_mq_create(const char *name,
S                     rt_size_t   msg_size,
S                     rt_size_t   max_msgs,
S                     rt_uint8_t  flag);
Srt_err_t rt_mq_delete(rt_mq_t mq);
S
Srt_err_t rt_mq_send(rt_mq_t mq, void *buffer, rt_size_t size);
Srt_err_t rt_mq_urgent(rt_mq_t mq, void *buffer, rt_size_t size);
Srt_err_t rt_mq_recv(rt_mq_t    mq,
S                    void      *buffer,
S                    rt_size_t  size,
S                    rt_int32_t timeout);
Srt_err_t rt_mq_control(rt_mq_t mq, rt_uint8_t cmd, void *arg);
S#endif
S
S/**@}*/
S
S#ifdef RT_USING_DEVICE
S/**
S * @addtogroup Device
S */
S
S/**@{*/
S
S/*
S * device (I/O) system interface
S */
Srt_device_t rt_device_find(const char *name);
S
Srt_err_t rt_device_register(rt_device_t dev,
S                            const char *name,
S                            rt_uint16_t flags);
Srt_err_t rt_device_unregister(rt_device_t dev);
Srt_err_t rt_device_init_all(void);
S
Srt_err_t
Srt_device_set_rx_indicate(rt_device_t dev,
S                          rt_err_t (*rx_ind)(rt_device_t dev, rt_size_t size));
Srt_err_t
Srt_device_set_tx_complete(rt_device_t dev,
S                          rt_err_t (*tx_done)(rt_device_t dev, void *buffer));
S
Srt_err_t  rt_device_init (rt_device_t dev);
Srt_err_t  rt_device_open (rt_device_t dev, rt_uint16_t oflag);
Srt_err_t  rt_device_close(rt_device_t dev);
Srt_size_t rt_device_read (rt_device_t dev,
S                          rt_off_t    pos,
S                          void       *buffer,
S                          rt_size_t   size);
Srt_size_t rt_device_write(rt_device_t dev,
S                          rt_off_t    pos,
S                          const void *buffer,
S                          rt_size_t   size);
Srt_err_t  rt_device_control(rt_device_t dev, rt_uint8_t cmd, void *arg);
S
S/**@}*/
S#endif
S
S#ifdef RT_USING_MODULE
S/**
S * @addtogroup Module
S */
S
S/**@{*/
S
S/*
S * module interface
S */
Srt_module_t rt_module_load(const char *name, void *module_ptr);
Srt_err_t rt_module_unload(rt_module_t module);
S#ifdef RT_USING_DFS
Srt_module_t rt_module_open(const char *filename);
Srt_module_t rt_module_exec_cmd(const char *path, const char* cmd_line, int size);
S#endif
Svoid *rt_module_malloc(rt_size_t size);
Svoid *rt_module_realloc(void *ptr, rt_size_t size);
Svoid rt_module_free(rt_module_t module, void *addr);
Srt_module_t rt_module_self(void);
Srt_module_t rt_module_find(const char *name);
S
S#ifdef RT_USING_HOOK
Svoid rt_module_load_sethook(void (*hook)(rt_module_t module));
Svoid rt_module_unload_sethook(void (*hook)(rt_module_t module));
S#endif
S
Svoid rt_module_init_object_container(struct rt_module *module);
Srt_err_t rt_module_destroy(rt_module_t module);
S
S/*
S * application module system initialization
S */
Sint rt_system_module_init(void);
S
S/**@}*/
S#endif
S
S/*
S * interrupt service
S */
S
S/*
S * rt_interrupt_enter and rt_interrupt_leave only can be called by BSP
S */
Svoid rt_interrupt_enter(void);
Svoid rt_interrupt_leave(void);
S
S/*
S * the number of nested interrupts.
S */
Srt_uint8_t rt_interrupt_get_nest(void);
S
S#ifdef RT_USING_HOOK
Svoid rt_interrupt_enter_sethook(void (*hook)(void));
Svoid rt_interrupt_leave_sethook(void (*hook)(void));
S#endif
S
S#ifdef RT_USING_COMPONENTS_INIT
Svoid rt_components_init(void);
Svoid rt_components_board_init(void);
S#endif
S
S/**
S * @addtogroup KernelService
S */
S
S/**@{*/
S
S/*
S * general kernel service
S */
S#ifndef RT_USING_CONSOLE
S#define rt_kprintf(...)
S#define rt_kputs(str)
S#else
Svoid rt_kprintf(const char *fmt, ...);
Svoid rt_kputs(const char *str);
S#endif
Srt_int32_t rt_vsprintf(char *dest, const char *format, va_list arg_ptr);
Srt_int32_t rt_vsnprintf(char *buf, rt_size_t size, const char *fmt, va_list args);
Srt_int32_t rt_sprintf(char *buf ,const char *format, ...);
Srt_int32_t rt_snprintf(char *buf, rt_size_t size, const char *format, ...);
S
S#if defined(RT_USING_DEVICE) && defined(RT_USING_CONSOLE)
Srt_device_t rt_console_set_device(const char *name);
Srt_device_t rt_console_get_device(void);
S#endif
S
Srt_err_t rt_get_errno(void);
Svoid rt_set_errno(rt_err_t no);
Sint *_rt_errno(void);
S#if !defined(RT_USING_NEWLIB) && !defined(_WIN32)
S#ifndef errno
S#define errno    *_rt_errno()
S#endif
S#endif
S
Svoid *rt_memset(void *src, int c, rt_ubase_t n);
Svoid *rt_memcpy(void *dest, const void *src, rt_ubase_t n);
S
Srt_int32_t rt_strncmp(const char *cs, const char *ct, rt_ubase_t count);
Srt_int32_t rt_strcmp (const char *cs, const char *ct);
Srt_size_t rt_strlen (const char *src);
Schar *rt_strdup(const char *s);
S
Schar *rt_strstr(const char *str1, const char *str2);
Srt_int32_t rt_sscanf(const char *buf, const char *fmt, ...);
Schar *rt_strncpy(char *dest, const char *src, rt_ubase_t n);
Svoid *rt_memmove(void *dest, const void *src, rt_ubase_t n);
Srt_int32_t rt_memcmp(const void *cs, const void *ct, rt_ubase_t count);
Srt_uint32_t rt_strcasecmp(const char *a, const char *b);
S
Svoid rt_show_version(void);
S
S#ifdef RT_DEBUG
Sextern void (*rt_assert_hook)(const char* ex, const char* func, rt_size_t line);
Svoid rt_assert_set_hook(void (*hook)(const char* ex, const char* func, rt_size_t line));
S
Svoid rt_assert_handler(const char* ex, const char* func, rt_size_t line);
S#endif /* RT_DEBUG */
S
S/**@}*/
S
S#ifdef __cplusplus
S}
S#endif
S
N#endif
L 26 "..\..\include\rtm.h" 2
N
N#ifdef RT_USING_MODULE
Sstruct rt_module_symtab
S{
S    void       *addr;
S    const char *name;
S};
S
S#if defined(_MSC_VER)
S#pragma section("RTMSymTab$f",read)
S#define RTM_EXPORT(symbol)                                            \
S__declspec(allocate("RTMSymTab$f"))const char __rtmsym_##symbol##_name[] = "__vs_rtm_"#symbol;
X#define RTM_EXPORT(symbol)                                            __declspec(allocate("RTMSymTab$f"))const char __rtmsym_##symbol##_name[] = "__vs_rtm_"#symbol;
S#pragma comment(linker, "/merge:RTMSymTab=mytext")
S
S#elif defined(__MINGW32__)
S#define RTM_EXPORT(symbol)
S
S#else
S#define RTM_EXPORT(symbol)                                            \
Sconst char __rtmsym_##symbol##_name[] SECTION(".rodata.name") = #symbol;     \
Sconst struct rt_module_symtab __rtmsym_##symbol SECTION("RTMSymTab")= \
S{                                                                     \
S    (void *)&symbol,                                                  \
S    __rtmsym_##symbol##_name                                          \
S};
X#define RTM_EXPORT(symbol)                                            const char __rtmsym_##symbol##_name[] SECTION(".rodata.name") = #symbol;     const struct rt_module_symtab __rtmsym_##symbol SECTION("RTMSymTab")= {                                                                         (void *)&symbol,                                                      __rtmsym_##symbol##_name                                          };
S#endif
S
N#else
N#define RTM_EXPORT(symbol)
N#endif
N
N#endif
L 40 "..\..\include\rtthread.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/**
N * @addtogroup KernelObject
N */
N
N/**@{*/
N
N/*
N * kernel object interface
N */
Nvoid rt_system_object_init(void);
Nstruct rt_object_information *
Nrt_object_get_information(enum rt_object_class_type type);
Nvoid rt_object_init(struct rt_object         *object,
N                    enum rt_object_class_type type,
N                    const char               *name);
Nvoid rt_object_detach(rt_object_t object);
Nrt_object_t rt_object_allocate(enum rt_object_class_type type,
N                               const char               *name);
Nvoid rt_object_delete(rt_object_t object);
Nrt_bool_t rt_object_is_systemobject(rt_object_t object);
Nrt_object_t rt_object_find(const char *name, rt_uint8_t type);
N
N#ifdef RT_USING_HOOK
Svoid rt_object_attach_sethook(void (*hook)(struct rt_object *object));
Svoid rt_object_detach_sethook(void (*hook)(struct rt_object *object));
Svoid rt_object_trytake_sethook(void (*hook)(struct rt_object *object));
Svoid rt_object_take_sethook(void (*hook)(struct rt_object *object));
Svoid rt_object_put_sethook(void (*hook)(struct rt_object *object));
N#endif
N
N/**@}*/
N
N/**
N * @addtogroup Clock
N */
N
N/**@{*/
N
N/*
N * clock & timer interface
N */
Nvoid rt_system_tick_init(void);
Nrt_tick_t rt_tick_get(void);
Nvoid rt_tick_set(rt_tick_t tick);
Nvoid rt_tick_increase(void);
Nrt_tick_t rt_tick_from_millisecond(rt_uint32_t ms);
N
Nvoid rt_system_timer_init(void);
Nvoid rt_system_timer_thread_init(void);
N
Nvoid rt_timer_init(rt_timer_t  timer,
N                   const char *name,
N                   void (*timeout)(void *parameter),
N                   void       *parameter,
N                   rt_tick_t   time,
N                   rt_uint8_t  flag);
Nrt_err_t rt_timer_detach(rt_timer_t timer);
Nrt_timer_t rt_timer_create(const char *name,
N                           void (*timeout)(void *parameter),
N                           void       *parameter,
N                           rt_tick_t   time,
N                           rt_uint8_t  flag);
Nrt_err_t rt_timer_delete(rt_timer_t timer);
Nrt_err_t rt_timer_start(rt_timer_t timer);
Nrt_err_t rt_timer_stop(rt_timer_t timer);
Nrt_err_t rt_timer_control(rt_timer_t timer, rt_uint8_t cmd, void *arg);
N
Nrt_tick_t rt_timer_next_timeout_tick(void);
Nvoid rt_timer_check(void);
N
N#ifdef RT_USING_HOOK
Svoid rt_timer_timeout_sethook(void (*hook)(struct rt_timer *timer));
N#endif
N
N/**@}*/
N
N/**
N * @addtogroup Thread
N */
N
N/**@{*/
N
N/*
N * thread interface
N */
Nrt_err_t rt_thread_init(struct rt_thread *thread,
N                        const char       *name,
N                        void (*entry)(void *parameter),
N                        void             *parameter,
N                        void             *stack_start,
N                        rt_uint32_t       stack_size,
N                        rt_uint8_t        priority,
N                        rt_uint32_t       tick);
Nrt_err_t rt_thread_detach(rt_thread_t thread);
Nrt_thread_t rt_thread_create(const char *name,
N                             void (*entry)(void *parameter),
N                             void       *parameter,
N                             rt_uint32_t stack_size,
N                             rt_uint8_t  priority,
N                             rt_uint32_t tick);
Nrt_thread_t rt_thread_self(void);
Nrt_thread_t rt_thread_find(char *name);
Nrt_err_t rt_thread_startup(rt_thread_t thread);
Nrt_err_t rt_thread_delete(rt_thread_t thread);
N
Nrt_err_t rt_thread_yield(void);
Nrt_err_t rt_thread_delay(rt_tick_t tick);
Nrt_err_t rt_thread_control(rt_thread_t thread, rt_uint8_t cmd, void *arg);
Nrt_err_t rt_thread_suspend(rt_thread_t thread);
Nrt_err_t rt_thread_resume(rt_thread_t thread);
Nvoid rt_thread_timeout(void *parameter);
N
N#ifdef RT_USING_HOOK
Svoid rt_thread_suspend_sethook(void (*hook)(rt_thread_t thread));
Svoid rt_thread_resume_sethook (void (*hook)(rt_thread_t thread));
Svoid rt_thread_inited_sethook (void (*hook)(rt_thread_t thread));
N#endif
N
N/*
N * idle thread interface
N */
Nvoid rt_thread_idle_init(void);
N#if defined(RT_USING_HOOK) || defined(RT_USING_IDLE_HOOK)
X#if 0L || 0L
Svoid rt_thread_idle_sethook(void (*hook)(void));
N#endif
Nvoid rt_thread_idle_excute(void);
Nrt_thread_t rt_thread_idle_gethandler(void);
N
N/*
N * schedule service
N */
Nvoid rt_system_scheduler_init(void);
Nvoid rt_system_scheduler_start(void);
N
Nvoid rt_schedule(void);
Nvoid rt_schedule_insert_thread(struct rt_thread *thread);
Nvoid rt_schedule_remove_thread(struct rt_thread *thread);
N
Nvoid rt_enter_critical(void);
Nvoid rt_exit_critical(void);
Nrt_uint16_t rt_critical_level(void);
N
N#ifdef RT_USING_HOOK
Svoid rt_scheduler_sethook(void (*hook)(rt_thread_t from, rt_thread_t to));
N#endif
N
N/**@}*/
N
N/**
N * @addtogroup MM
N */
N
N/**@{*/
N
N/*
N * memory management interface
N */
N#ifdef RT_USING_MEMPOOL
N/*
N * memory pool interface
N */
Nrt_err_t rt_mp_init(struct rt_mempool *mp,
N                    const char        *name,
N                    void              *start,
N                    rt_size_t          size,
N                    rt_size_t          block_size);
Nrt_err_t rt_mp_detach(struct rt_mempool *mp);
Nrt_mp_t rt_mp_create(const char *name,
N                     rt_size_t   block_count,
N                     rt_size_t   block_size);
Nrt_err_t rt_mp_delete(rt_mp_t mp);
N
Nvoid *rt_mp_alloc(rt_mp_t mp, rt_int32_t time);
Nvoid rt_mp_free(void *block);
N
N#ifdef RT_USING_HOOK
Svoid rt_mp_alloc_sethook(void (*hook)(struct rt_mempool *mp, void *block));
Svoid rt_mp_free_sethook(void (*hook)(struct rt_mempool *mp, void *block));
N#endif
N
N#endif
N
N#ifdef RT_USING_HEAP
N/*
N * heap memory interface
N */
Nvoid rt_system_heap_init(void *begin_addr, void *end_addr);
N
Nvoid *rt_malloc(rt_size_t nbytes);
Nvoid rt_free(void *ptr);
Nvoid *rt_realloc(void *ptr, rt_size_t nbytes);
Nvoid *rt_calloc(rt_size_t count, rt_size_t size);
Nvoid *rt_malloc_align(rt_size_t size, rt_size_t align);
Nvoid rt_free_align(void *ptr);
N
Nvoid rt_memory_info(rt_uint32_t *total,
N                    rt_uint32_t *used,
N                    rt_uint32_t *max_used);
N
N#ifdef RT_USING_SLAB
Svoid *rt_page_alloc(rt_size_t npages);
Svoid rt_page_free(void *addr, rt_size_t npages);
N#endif
N
N#ifdef RT_USING_HOOK
Svoid rt_malloc_sethook(void (*hook)(void *ptr, rt_uint32_t size));
Svoid rt_free_sethook(void (*hook)(void *ptr));
N#endif
N
N#endif
N
N#ifdef RT_USING_MEMHEAP
S/**
S * memory heap object interface
S */
Srt_err_t rt_memheap_init(struct rt_memheap *memheap,
S                         const char        *name,
S                         void              *start_addr,
S                         rt_uint32_t        size);
Srt_err_t rt_memheap_detach(struct rt_memheap *heap);
Svoid* rt_memheap_alloc(struct rt_memheap *heap, rt_uint32_t size);
Svoid *rt_memheap_realloc(struct rt_memheap* heap, void* ptr, rt_size_t newsize);
Svoid rt_memheap_free(void *ptr);
N#endif
N
N/**@}*/
N
N/**
N * @addtogroup IPC
N */
N
N/**@{*/
N
N#ifdef RT_USING_SEMAPHORE
N/*
N * semaphore interface
N */
Nrt_err_t rt_sem_init(rt_sem_t    sem,
N                     const char *name,
N                     rt_uint32_t value,
N                     rt_uint8_t  flag);
Nrt_err_t rt_sem_detach(rt_sem_t sem);
Nrt_sem_t rt_sem_create(const char *name, rt_uint32_t value, rt_uint8_t flag);
Nrt_err_t rt_sem_delete(rt_sem_t sem);
N
Nrt_err_t rt_sem_take(rt_sem_t sem, rt_int32_t time);
Nrt_err_t rt_sem_trytake(rt_sem_t sem);
Nrt_err_t rt_sem_release(rt_sem_t sem);
Nrt_err_t rt_sem_control(rt_sem_t sem, rt_uint8_t cmd, void *arg);
N#endif
N
N#ifdef RT_USING_MUTEX
N/*
N * mutex interface
N */
Nrt_err_t rt_mutex_init(rt_mutex_t mutex, const char *name, rt_uint8_t flag);
Nrt_err_t rt_mutex_detach(rt_mutex_t mutex);
Nrt_mutex_t rt_mutex_create(const char *name, rt_uint8_t flag);
Nrt_err_t rt_mutex_delete(rt_mutex_t mutex);
N
Nrt_err_t rt_mutex_take(rt_mutex_t mutex, rt_int32_t time);
Nrt_err_t rt_mutex_release(rt_mutex_t mutex);
Nrt_err_t rt_mutex_control(rt_mutex_t mutex, rt_uint8_t cmd, void *arg);
N#endif
N
N#ifdef RT_USING_EVENT
N/*
N * event interface
N */
Nrt_err_t rt_event_init(rt_event_t event, const char *name, rt_uint8_t flag);
Nrt_err_t rt_event_detach(rt_event_t event);
Nrt_event_t rt_event_create(const char *name, rt_uint8_t flag);
Nrt_err_t rt_event_delete(rt_event_t event);
N
Nrt_err_t rt_event_send(rt_event_t event, rt_uint32_t set);
Nrt_err_t rt_event_recv(rt_event_t   event,
N                       rt_uint32_t  set,
N                       rt_uint8_t   opt,
N                       rt_int32_t   timeout,
N                       rt_uint32_t *recved);
Nrt_err_t rt_event_control(rt_event_t event, rt_uint8_t cmd, void *arg);
N#endif
N
N#ifdef RT_USING_MAILBOX
N/*
N * mailbox interface
N */
Nrt_err_t rt_mb_init(rt_mailbox_t mb,
N                    const char  *name,
N                    void        *msgpool,
N                    rt_size_t    size,
N                    rt_uint8_t   flag);
Nrt_err_t rt_mb_detach(rt_mailbox_t mb);
Nrt_mailbox_t rt_mb_create(const char *name, rt_size_t size, rt_uint8_t flag);
Nrt_err_t rt_mb_delete(rt_mailbox_t mb);
N
Nrt_err_t rt_mb_send(rt_mailbox_t mb, rt_uint32_t value);
Nrt_err_t rt_mb_send_wait(rt_mailbox_t mb,
N                         rt_uint32_t  value,
N                         rt_int32_t   timeout);
Nrt_err_t rt_mb_recv(rt_mailbox_t mb, rt_uint32_t *value, rt_int32_t timeout);
Nrt_err_t rt_mb_control(rt_mailbox_t mb, rt_uint8_t cmd, void *arg);
N#endif
N
N#ifdef RT_USING_MESSAGEQUEUE
N/*
N * message queue interface
N */
Nrt_err_t rt_mq_init(rt_mq_t     mq,
N                    const char *name,
N                    void       *msgpool,
N                    rt_size_t   msg_size,
N                    rt_size_t   pool_size,
N                    rt_uint8_t  flag);
Nrt_err_t rt_mq_detach(rt_mq_t mq);
Nrt_mq_t rt_mq_create(const char *name,
N                     rt_size_t   msg_size,
N                     rt_size_t   max_msgs,
N                     rt_uint8_t  flag);
Nrt_err_t rt_mq_delete(rt_mq_t mq);
N
Nrt_err_t rt_mq_send(rt_mq_t mq, void *buffer, rt_size_t size);
Nrt_err_t rt_mq_urgent(rt_mq_t mq, void *buffer, rt_size_t size);
Nrt_err_t rt_mq_recv(rt_mq_t    mq,
N                    void      *buffer,
N                    rt_size_t  size,
N                    rt_int32_t timeout);
Nrt_err_t rt_mq_control(rt_mq_t mq, rt_uint8_t cmd, void *arg);
N#endif
N
N/**@}*/
N
N#ifdef RT_USING_DEVICE
N/**
N * @addtogroup Device
N */
N
N/**@{*/
N
N/*
N * device (I/O) system interface
N */
Nrt_device_t rt_device_find(const char *name);
N
Nrt_err_t rt_device_register(rt_device_t dev,
N                            const char *name,
N                            rt_uint16_t flags);
Nrt_err_t rt_device_unregister(rt_device_t dev);
Nrt_err_t rt_device_init_all(void);
N
Nrt_err_t
Nrt_device_set_rx_indicate(rt_device_t dev,
N                          rt_err_t (*rx_ind)(rt_device_t dev, rt_size_t size));
Nrt_err_t
Nrt_device_set_tx_complete(rt_device_t dev,
N                          rt_err_t (*tx_done)(rt_device_t dev, void *buffer));
N
Nrt_err_t  rt_device_init (rt_device_t dev);
Nrt_err_t  rt_device_open (rt_device_t dev, rt_uint16_t oflag);
Nrt_err_t  rt_device_close(rt_device_t dev);
Nrt_size_t rt_device_read (rt_device_t dev,
N                          rt_off_t    pos,
N                          void       *buffer,
N                          rt_size_t   size);
Nrt_size_t rt_device_write(rt_device_t dev,
N                          rt_off_t    pos,
N                          const void *buffer,
N                          rt_size_t   size);
Nrt_err_t  rt_device_control(rt_device_t dev, rt_uint8_t cmd, void *arg);
N
N/**@}*/
N#endif
N
N#ifdef RT_USING_MODULE
S/**
S * @addtogroup Module
S */
S
S/**@{*/
S
S/*
S * module interface
S */
Srt_module_t rt_module_load(const char *name, void *module_ptr);
Srt_err_t rt_module_unload(rt_module_t module);
S#ifdef RT_USING_DFS
Srt_module_t rt_module_open(const char *filename);
Srt_module_t rt_module_exec_cmd(const char *path, const char* cmd_line, int size);
S#endif
Svoid *rt_module_malloc(rt_size_t size);
Svoid *rt_module_realloc(void *ptr, rt_size_t size);
Svoid rt_module_free(rt_module_t module, void *addr);
Srt_module_t rt_module_self(void);
Srt_module_t rt_module_find(const char *name);
S
S#ifdef RT_USING_HOOK
Svoid rt_module_load_sethook(void (*hook)(rt_module_t module));
Svoid rt_module_unload_sethook(void (*hook)(rt_module_t module));
S#endif
S
Svoid rt_module_init_object_container(struct rt_module *module);
Srt_err_t rt_module_destroy(rt_module_t module);
S
S/*
S * application module system initialization
S */
Sint rt_system_module_init(void);
S
S/**@}*/
N#endif
N
N/*
N * interrupt service
N */
N
N/*
N * rt_interrupt_enter and rt_interrupt_leave only can be called by BSP
N */
Nvoid rt_interrupt_enter(void);
Nvoid rt_interrupt_leave(void);
N
N/*
N * the number of nested interrupts.
N */
Nrt_uint8_t rt_interrupt_get_nest(void);
N
N#ifdef RT_USING_HOOK
Svoid rt_interrupt_enter_sethook(void (*hook)(void));
Svoid rt_interrupt_leave_sethook(void (*hook)(void));
N#endif
N
N#ifdef RT_USING_COMPONENTS_INIT
Nvoid rt_components_init(void);
Nvoid rt_components_board_init(void);
N#endif
N
N/**
N * @addtogroup KernelService
N */
N
N/**@{*/
N
N/*
N * general kernel service
N */
N#ifndef RT_USING_CONSOLE
S#define rt_kprintf(...)
S#define rt_kputs(str)
N#else
Nvoid rt_kprintf(const char *fmt, ...);
Nvoid rt_kputs(const char *str);
N#endif
Nrt_int32_t rt_vsprintf(char *dest, const char *format, va_list arg_ptr);
Nrt_int32_t rt_vsnprintf(char *buf, rt_size_t size, const char *fmt, va_list args);
Nrt_int32_t rt_sprintf(char *buf ,const char *format, ...);
Nrt_int32_t rt_snprintf(char *buf, rt_size_t size, const char *format, ...);
N
N#if defined(RT_USING_DEVICE) && defined(RT_USING_CONSOLE)
X#if 1L && 1L
Nrt_device_t rt_console_set_device(const char *name);
Nrt_device_t rt_console_get_device(void);
N#endif
N
Nrt_err_t rt_get_errno(void);
Nvoid rt_set_errno(rt_err_t no);
Nint *_rt_errno(void);
N#if !defined(RT_USING_NEWLIB) && !defined(_WIN32)
X#if !0L && !0L
N#ifndef errno
N#define errno    *_rt_errno()
N#endif
N#endif
N
Nvoid *rt_memset(void *src, int c, rt_ubase_t n);
Nvoid *rt_memcpy(void *dest, const void *src, rt_ubase_t n);
N
Nrt_int32_t rt_strncmp(const char *cs, const char *ct, rt_ubase_t count);
Nrt_int32_t rt_strcmp (const char *cs, const char *ct);
Nrt_size_t rt_strlen (const char *src);
Nchar *rt_strdup(const char *s);
N
Nchar *rt_strstr(const char *str1, const char *str2);
Nrt_int32_t rt_sscanf(const char *buf, const char *fmt, ...);
Nchar *rt_strncpy(char *dest, const char *src, rt_ubase_t n);
Nvoid *rt_memmove(void *dest, const void *src, rt_ubase_t n);
Nrt_int32_t rt_memcmp(const void *cs, const void *ct, rt_ubase_t count);
Nrt_uint32_t rt_strcasecmp(const char *a, const char *b);
N
Nvoid rt_show_version(void);
N
N#ifdef RT_DEBUG
Sextern void (*rt_assert_hook)(const char* ex, const char* func, rt_size_t line);
Svoid rt_assert_set_hook(void (*hook)(const char* ex, const char* func, rt_size_t line));
S
Svoid rt_assert_handler(const char* ex, const char* func, rt_size_t line);
N#endif /* RT_DEBUG */
N
N/**@}*/
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 32 "..\..\include\rthw.h" 2
N
N#ifdef __cplusplus
Sextern "C" {
N#endif
N
N/*
N * CPU interfaces
N */
Nvoid rt_hw_cpu_icache_enable(void);
Nvoid rt_hw_cpu_icache_disable(void);
Nrt_base_t rt_hw_cpu_icache_status(void);
Nvoid rt_hw_cpu_dcache_enable(void);
Nvoid rt_hw_cpu_dcache_disable(void);
Nrt_base_t rt_hw_cpu_dcache_status(void);
Nvoid rt_hw_cpu_reset(void);
Nvoid rt_hw_cpu_shutdown(void);
N
Nrt_uint8_t *rt_hw_stack_init(void       *entry,
N                             void       *parameter,
N                             rt_uint8_t *stack_addr,
N                             void       *exit);
N
N/*
N * Interrupt handler definition
N */
Ntypedef void (*rt_isr_handler_t)(int vector, void *param);
N
Nstruct rt_irq_desc
N{
N    rt_isr_handler_t handler;
N    void            *param;
N
N#ifdef RT_USING_INTERRUPT_INFO
S    char             name[RT_NAME_MAX];
S    rt_uint32_t      counter;
N#endif
N};
N
N/*
N * Interrupt interfaces
N */
Nvoid rt_hw_interrupt_init(void);
Nvoid rt_hw_interrupt_mask(int vector);
Nvoid rt_hw_interrupt_umask(int vector);
Nrt_isr_handler_t rt_hw_interrupt_install(int              vector,
N                                         rt_isr_handler_t handler,
N                                         void            *param,
N                                         char            *name);
N
Nrt_base_t rt_hw_interrupt_disable(void);
Nvoid rt_hw_interrupt_enable(rt_base_t level);
N
N/*
N * Context interfaces
N */
Nvoid rt_hw_context_switch(rt_uint32_t from, rt_uint32_t to);
Nvoid rt_hw_context_switch_to(rt_uint32_t to);
Nvoid rt_hw_context_switch_interrupt(rt_uint32_t from, rt_uint32_t to);
N
Nvoid rt_hw_console_output(const char *str);
N
Nvoid rt_hw_backtrace(rt_uint32_t *fp, rt_uint32_t thread_entry);
Nvoid rt_hw_show_memory(rt_uint32_t addr, rt_uint32_t size);
N
N/*
N * Exception interfaces
N */
Nvoid rt_hw_exception_install(rt_err_t (*exception_handle)(void *context));
N
N#ifdef __cplusplus
S}
N#endif
N
N#endif
L 33 "..\..\src\module.c" 2
N#include <rtthread.h>
N#include <rtm.h>
N
N#ifdef RT_USING_FINSH
N#include <finsh.h>
L 1 "..\..\components\finsh\finsh.h" 1
N/*
N * File      : finsh.h
N * This file is part of RT-Thread RTOS
N * COPYRIGHT (C) 2006 - 2010, RT-Thread Development Team
N *
N * The license and distribution terms for this file may be
N * found in the file LICENSE in this distribution or at
N * http://www.rt-thread.org/license/LICENSE
N *
N * Change Logs:
N * Date           Author       Notes
N * 2010-03-22     Bernard      first version
N */
N#ifndef __FINSH_H__
N#define __FINSH_H__
N
N#include <rtthread.h>
N
N#if defined(_MSC_VER)
X#if 0L
S#pragma section("FSymTab$f",read)
S#pragma section("VSymTab",read)
N#endif
N
N/* -- the beginning of option -- */
N#define FINSH_NAME_MAX          16      /* max length of identifier */
N#define FINSH_NODE_MAX          16      /* max number of node */
N
N#define FINSH_HEAP_MAX          128     /* max length of heap */
N#define FINSH_STRING_MAX        128     /* max length of string */
N#define FINSH_VARIABLE_MAX      8       /* max number of variable */
N
N#define FINSH_STACK_MAX         64      /* max stack size */
N#define FINSH_TEXT_MAX          128     /* max text segment size */
N
N#define HEAP_ALIGNMENT          4       /* heap alignment */
N
N#define FINSH_GET16(x)    (*(x)) | (*((x)+1) << 8)
N#define FINSH_GET32(x)    (rt_uint32_t)(*(x)) | ((rt_uint32_t)*((x)+1) << 8) | \
N    ((rt_uint32_t)*((x)+2) << 16) | ((rt_uint32_t)*((x)+3) << 24)
X#define FINSH_GET32(x)    (rt_uint32_t)(*(x)) | ((rt_uint32_t)*((x)+1) << 8) |     ((rt_uint32_t)*((x)+2) << 16) | ((rt_uint32_t)*((x)+3) << 24)
N
N#define FINSH_SET16(x, v)           \
N    do                              \
N    {                               \
N        *(x)     = (v) & 0x00ff;    \
N        (*((x)+1)) = (v) >> 8;      \
N    } while ( 0 )
X#define FINSH_SET16(x, v)               do                                  {                                       *(x)     = (v) & 0x00ff;            (*((x)+1)) = (v) >> 8;          } while ( 0 )
N
N#define FINSH_SET32(x, v)                                       \
N    do                                                          \
N    {                                                           \
N        *(x)     = (rt_uint32_t)(v)  & 0x000000ff;              \
N        (*((x)+1)) = ((rt_uint32_t)(v) >> 8) & 0x000000ff;      \
N        (*((x)+2)) = ((rt_uint32_t)(v) >> 16) & 0x000000ff;     \
N        (*((x)+3)) = ((rt_uint32_t)(v) >> 24);                  \
N    } while ( 0 )
X#define FINSH_SET32(x, v)                                           do                                                              {                                                                   *(x)     = (rt_uint32_t)(v)  & 0x000000ff;                      (*((x)+1)) = ((rt_uint32_t)(v) >> 8) & 0x000000ff;              (*((x)+2)) = ((rt_uint32_t)(v) >> 16) & 0x000000ff;             (*((x)+3)) = ((rt_uint32_t)(v) >> 24);                      } while ( 0 )
N
N/* -- the end of option -- */
N
N#if defined(RT_USING_NEWLIB) || defined (RT_USING_MINILIBC)
X#if 0L || 0L
S#include <sys/types.h>
S#include <string.h>
N#else
Ntypedef unsigned char  u_char;
Ntypedef unsigned short u_short;
Ntypedef unsigned long  u_long;
N
N#if !defined(__CC_ARM)             && \
N    !defined(__IAR_SYSTEMS_ICC__)  && \
N    !defined(__ADSPBLACKFIN__)     && \
N    !defined(_MSC_VER)
X#if !1L             &&     !0L  &&     !0L     &&     !0L
S
S/* only for GNU GCC */
S
S#if !(defined(__GNUC__) && defined(__x86_64__))
Stypedef unsigned int size_t;
S#else
S#include <stdio.h>
S#endif
S
S#ifndef NULL
S#define NULL RT_NULL
S#endif
S
N#else
N/* use libc of armcc */
N#include <ctype.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\ctype.h" 1
N/* ctype.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.3 */
N/* Copyright (C) Codemist Ltd. 1988-1993.                       */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.        */
N/* version 0.03 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N
N/*
N * ctype.h declares several functions useful for testing and mapping
N * characters. In all cases the argument is an int, the value of which shall
N * be representable as an unsigned char or shall equal the value of the
N * macro EOF. If the argument has any other value, the behaviour is undefined.
N */
N
N#ifndef __ctype_h
N#define __ctype_h
N#define __ARMCLIB_VERSION 5060016
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N
N#ifdef __cplusplus
S#define _ARMABI_INLINE_DEF inline
S#elif defined(__GNUC__) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__)
X#elif 0L || (1L && 199901L <= 199409L)
S#define _ARMABI_INLINE_DEF static inline
S#elif defined(_USE_STATIC_INLINE)
X#elif 0L
S#define _ARMABI_INLINE_DEF static __inline
N#else
N#define _ARMABI_INLINE_DEF __inline
N#endif
N
N  #ifndef __CTYPE_DECLS
N  #define __CTYPE_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N/* AEABI portable ctype flag bits */
N#define _ABI_A    1       /* alphabetic        */
N#define _ABI_X    2       /* A-F, a-f and 0-9  */
N#define _ABI_P    4       /* punctuation       */
N#define _ABI_B    8       /* blank             */
N#define _ABI_S   16       /* white space       */
N#define _ABI_L   32       /* lower case letter */
N#define _ABI_U   64       /* upper case letter */
N#define _ABI_C  128       /* control chars     */
N
N/* ARM internal ctype flag bits */
N/* N.B. - keep in step with <ctype.c> */
N
N/*
N * __ARM_CT_A (alphabetic) is required because characters in some locales
N * (e.g. Japanese) can be alphabetic but neither uppercase nor
N * lowercase. Unfortunately there wasn't a bit free for this, so
N * instead we've defined __ARM_CT_A as __ARM_CT_N+__ARM_CT_X (on the grounds that this
N * was a previously unused combination). Hence some of the ctype
N * predicates below are slightly less than obvious in
N * implementation.
N */
N#define __ARM_CT_S 1            /* whitespace           */
N#define __ARM_CT_P 2            /* punctuation          */
N#define __ARM_CT_B 4            /* blank                */
N#define __ARM_CT_L 8            /* lower case letter    */
N#define __ARM_CT_U 16           /* upper case letter    */
N#define __ARM_CT_N 32           /* (decimal) digit      */
N#define __ARM_CT_C 64           /* control chars        */
N#define __ARM_CT_X 128          /* A-F and a-f          */
N#define __ARM_CT_A (__ARM_CT_N+__ARM_CT_X)    /* alphabetic           */
N
N#if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X#if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S  #define _AEABI_PORTABLE
N#endif
N
N#if _AEABI_PORTABILITY_LEVEL != 0 || (!defined _AEABI_PORTABILITY_LEVEL && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
X#if _AEABI_PORTABILITY_LEVEL != 0 || (!0L && __DEFAULT_AEABI_PORTABILITY_LEVEL != 0)
S
Sextern int (isalnum)(int /*c*/);
Sextern int (isalpha)(int /*c*/);
Sextern int (isblank)(int /*c*/);
Sextern int (iscntrl)(int /*c*/);
Sextern int (isdigit)(int /*c*/);
Sextern int (isgraph)(int /*c*/);
Sextern int (islower)(int /*c*/);
Sextern int (isprint)(int /*c*/);
Sextern int (ispunct)(int /*c*/);
Sextern int (isspace)(int /*c*/);
Sextern int (isupper)(int /*c*/);
Sextern int (isxdigit)(int /*c*/);
S
S/* Mandatory character attribute arrays indexed from 0 to 256 */
Sextern unsigned char const __aeabi_ctype_table_C[257];  /* "C" locale */
Sextern unsigned char const __aeabi_ctype_table_[257];   /* default locale */
S         /* The default locale might be the C locale */
S/* Optional character attribute arrays indexed from 0 to 256.        */
S/* These do not have to be provided by every execution environment   */
S/* but, if provided, shall be provided with these names and meaning. */
Sextern unsigned char const __aeabi_ctype_table_ISO8859_1[257];
Sextern unsigned char const __aeabi_ctype_table_SJIS[257];
Sextern unsigned char const __aeabi_ctype_table_BIG5[257];
Sextern unsigned char const __aeabi_ctype_table_UTF8[257];
S#ifdef _AEABI_LC_CTYPE
S# define _AEABI_CTYPE_TABLE(_X) __aeabi_ctype_table_ ## _X
S# define _AEABI_CTYPE(_X) _AEABI_CTYPE_TABLE(_X)
S# define __aeabi_ctype_table _AEABI_CTYPE(_AEABI_LC_CTYPE)
S#else
S# define __aeabi_ctype_table __aeabi_ctype_table_
S#endif
S
S#define isspace(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_S)
S#define isalpha(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_A)
S#define isalnum(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] << 30) /* test for _ABI_A and _ABI_X */
S#define isprint(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] << 28) /* test for _ABI_A, _ABI_X, _ABI_P and _ABI_B */
S#define isupper(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_U)
S#define islower(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_L)
S#define isxdigit(x) ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_X)
S#define isgraph(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] << 29) /* test for _ABI_A, _ABI_X and _ABI_P */
S#define iscntrl(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_C)
S#define ispunct(x)  ((__CLIBNS __aeabi_ctype_table+1)[(x)] & _ABI_P)
S#define isdigit(c)  (((unsigned)(c) - '0') < 10)
S
N#else /* __AEABI_PORTABILITY_LEVEL */
N
Nextern _ARMABI_PURE unsigned char **__rt_ctype_table(void);
Xextern __declspec(__nothrow) __attribute__((const)) unsigned char **__rt_ctype_table(void);
N
N#define __arm_ctype (*__CLIBNS __rt_ctype_table())
N
N#ifdef __cplusplus
S    inline int isalnum(int __c) { return (__arm_ctype[__c] & (__ARM_CT_U+__ARM_CT_L+__ARM_CT_N)); }
N#else
N    #define isalnum(c) (__arm_ctype[c] & (__ARM_CT_U+__ARM_CT_L+__ARM_CT_N))
N    extern int (isalnum)(int /*c*/);
N#endif
N    /* non-0 iff c is alphabetic or numeric */
N
N#ifdef __cplusplus
S    inline int isalpha(int __c) { return (__arm_ctype[__c] & (__ARM_CT_U+__ARM_CT_L+__ARM_CT_X)); }
N#else
N    #define isalpha(c) (__arm_ctype[c] & (__ARM_CT_U+__ARM_CT_L+__ARM_CT_X))
N    extern int (isalpha)(int /*c*/);
N#endif
N    /* non-0 iff c is alphabetic */
N
N#ifdef __cplusplus
S    inline int iscntrl(int __c) { return (__arm_ctype[__c] & __ARM_CT_C); }
N#else
N    #define iscntrl(c) (__arm_ctype[c] & __ARM_CT_C)
N    extern int (iscntrl)(int /*c*/);
N#endif
N    /* non-0 iff c is a control character - in the "C" locale */
N    /*       this means (c < ' ') || (c > '~')                */
N
N/* isdigit must test for the presence of _only_ __ARM_CT_N, not just __ARM_CT_N at all. */
N#ifdef __cplusplus
S    inline int isdigit(int __c) { return (__arm_ctype[__c] == __ARM_CT_N); }
N#else
N    #define isdigit(c) (__arm_ctype[c] == __ARM_CT_N)
N    extern int (isdigit)(int /*c*/);
N#endif
N    /* non-0 iff c is a decimal digit */
N
N    extern int (isblank)(int /*c*/);
N    /* non-0 iff c is ' ', '\t' or some other locale-specific, */
N    /* word-separating character (there are no others in "C"   */
N    /* locale) */
N
N#ifdef __cplusplus
S    inline int isgraph(int __c) {return(__arm_ctype[__c] & (__ARM_CT_L+__ARM_CT_U+__ARM_CT_N+__ARM_CT_X+__ARM_CT_P));}
N#else
N    #define isgraph(c) (__arm_ctype[c]&(__ARM_CT_L+__ARM_CT_U+__ARM_CT_N+__ARM_CT_X+__ARM_CT_P))
N    extern int (isgraph)(int /*c*/);
N#endif
N    /* non-0 iff c is any printing character other than ' ' */
N
N#ifdef __cplusplus
S    inline int islower(int __c) { return (__arm_ctype[__c] & __ARM_CT_L); }
N#else
N    #define islower(c) (__arm_ctype[c] & __ARM_CT_L)
N    extern int (islower)(int /*c*/);
N#endif
N    /* non-0 iff c is a lower-case letter */
N
N#ifdef __cplusplus
S    inline int isprint(int __c) { return (__arm_ctype[__c] & (__ARM_CT_L+__ARM_CT_U+__ARM_CT_N+__ARM_CT_P+__ARM_CT_B)); }
N#else
N    #define isprint(c) (__arm_ctype[c] & (__ARM_CT_L+__ARM_CT_U+__ARM_CT_N+__ARM_CT_P+__ARM_CT_B))
N    extern int (isprint)(int /*c*/);
N#endif
N    /* non-0 iff c is a printing character - in the "C" locale */
N    /*       this means 0x20 (space) -> 0x7E (tilde)           */
N
N#ifdef __cplusplus
S    inline int ispunct(int __c) { return (__arm_ctype[__c] & __ARM_CT_P); }
N#else
N    #define ispunct(c) (__arm_ctype[c] & __ARM_CT_P)
N    extern int (ispunct)(int /*c*/);
N#endif
N    /* non-0 iff c is a non-space, non-alpha-numeric, printing character */
N
N#ifdef __cplusplus
S    inline int isspace(int __c) { return (__arm_ctype[__c] & __ARM_CT_S); }
N#else
N    #define isspace(c) (__arm_ctype[c] & __ARM_CT_S)
N    extern int (isspace)(int /*c*/);
N#endif
N    /* non-0 iff c is a white-space char: ' ', '\f', '\n', '\r', '\t', '\v'. */
N
N#ifdef __cplusplus
S    inline int isupper(int __c) { return (__arm_ctype[__c] & __ARM_CT_U); }
N#else
N    #define isupper(c) (__arm_ctype[c] & __ARM_CT_U)
N    extern int (isupper)(int /*c*/);
N#endif
N    /* non-0 iff c is an upper-case letter */
N
N/* isxdigit must test for the presence of __ARM_CT_N or __ARM_CT_X but not both. */
N/* This helper function avoids needing to evaluate c twice. */
N
N_ARMABI_INLINE_DEF int __isxdigit_helper(int __t) { return (__t ^ (__t << 2)); }
X__inline int __isxdigit_helper(int __t) { return (__t ^ (__t << 2)); }
N#ifdef __cplusplus
S    inline int isxdigit(int __c){return __isxdigit_helper(__arm_ctype[__c]) & __ARM_CT_X;}
N#else
N    #define isxdigit(c) (__isxdigit_helper(__arm_ctype[c]) & __ARM_CT_X)
N    extern int (isxdigit)(int /*c*/);
N#endif
N    /* non-0 iff c is a digit, in 'a'..'f', or in 'A'..'F' */
N
N#endif /* __AEABI_PORTABILITY_LEVEL */
N
Nextern int tolower(int /*c*/);
N    /* if c is an upper-case letter then return the corresponding */
N    /* lower-case letter, otherwise return c.                     */
N
Nextern int toupper(int /*c*/);
N    /* if c is an lower-case letter then return the corresponding */
N    /* upper-case letter, otherwise return c.                     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __CTYPE_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __CTYPE_NO_EXPORTS
S      using ::std::isalnum;
S      using ::std::isalpha;
S      using ::std::iscntrl;
S      using ::std::isdigit;
S      using ::std::isblank;
S      using ::std::isgraph;
S      using ::std::islower;
S      using ::std::isprint;
S      using ::std::ispunct;
S      using ::std::isspace;
S      using ::std::isupper;
S      using ::std::isxdigit;
S      using ::std::tolower;
S      using ::std::toupper;
S    #endif /* __CTYPE_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of ctype.h */
N
L 87 "..\..\components\finsh\finsh.h" 2
N#include <stdlib.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\stdlib.h" 1
N/* stdlib.h: ANSI draft (X3J11 May 88) library header, section 4.10 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                          */
N/* Copyright 1991-1998,2014 ARM Limited. All rights reserved.       */
N/*
N * RCS $Revision$
N * Checkin $Date$
N * Revising $Author: agrant $
N */
N 
N/*
N * stdlib.h declares four types, several general purpose functions,
N * and defines several macros.
N */
N
N#ifndef __stdlib_h
N#define __stdlib_h
N#define __ARMCLIB_VERSION 5060016
N
N#if defined(__clang__) || (defined(__ARMCC_VERSION) && !defined(__STRICT_ANSI__))
X#if 0L || (1L && !0L)
N  /* armclang and non-strict armcc allow 'long long' in system headers */
N  #define __LONGLONG long long
N#else
S  /* strict armcc has '__int64' */
S  #define __LONGLONG __int64
N#endif
N
N#define _ARMABI __declspec(__nothrow)
N#define _ARMABI_PURE __declspec(__nothrow) __attribute__((const))
N#define _ARMABI_NORETURN __declspec(__nothrow) __declspec(__noreturn)
N#define _ARMABI_THROW
N
N  #ifndef __STDLIB_DECLS
N  #define __STDLIB_DECLS
N
N  /*
N   * Some of these declarations are new in C99.  To access them in C++
N   * you can use -D__USE_C99_STDLIB (or -D__USE_C99ALL).
N   */
N  #ifndef __USE_C99_STDLIB
N    #if defined(__USE_C99_ALL) || (defined(__STDC_VERSION__) && 199901L <= __STDC_VERSION__) || (defined(__cplusplus) && 201103L <= __cplusplus)
X    #if 0L || (1L && 199901L <= 199409L) || (0L && 201103L <= __cplusplus)
S      #define __USE_C99_STDLIB 1
N    #endif
N  #endif
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S      namespace std {
S          #define __CLIBNS ::std::
S          extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
N#ifndef __cplusplus  /* wchar_t is a builtin type for C++ */
N  #if !defined(__STRICT_ANSI__)
X  #if !0L
N   /* unconditional in non-strict C for consistency of debug info */
N   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
X   #if 0L || (0L && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
N   #else
N    typedef unsigned short wchar_t; /* see <stddef.h> */
N   #endif
N  #elif !defined(__wchar_t)
S    #define __wchar_t 1
S   #if defined(__WCHAR32) || (defined(__ARM_SIZEOF_WCHAR_T) && __ARM_SIZEOF_WCHAR_T == 4)
S    typedef unsigned int wchar_t; /* see <stddef.h> */
S   #else
S    typedef unsigned short wchar_t; /* see <stddef.h> */
S   #endif
N  #endif
N#endif
N
Ntypedef struct div_t { int quot, rem; } div_t;
N   /* type of the value returned by the div function. */
Ntypedef struct ldiv_t { long int quot, rem; } ldiv_t;
N   /* type of the value returned by the ldiv function. */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Ntypedef struct lldiv_t { __LONGLONG quot, rem; } lldiv_t;
Xtypedef struct lldiv_t { long long quot, rem; } lldiv_t;
N   /* type of the value returned by the lldiv function. */
N#endif
N
N#ifdef __EXIT_FAILURE
S#  define EXIT_FAILURE __EXIT_FAILURE
S   /*
S    * an integral expression which may be used as an argument to the exit
S    * function to return unsuccessful termination status to the host
S    * environment.
S    */
N#else
N#  define EXIT_FAILURE 1  /* unixoid */
N#endif
N#define EXIT_SUCCESS 0
N   /*
N    * an integral expression which may be used as an argument to the exit
N    * function to return successful termination status to the host
N    * environment.
N    */
N
N   /*
N    * Defining __USE_ANSI_EXAMPLE_RAND at compile time switches to
N    * the example implementation of rand() and srand() provided in
N    * the ANSI C standard. This implementation is very poor, but is
N    * provided for completeness.
N    */
N#ifdef __USE_ANSI_EXAMPLE_RAND
S#define srand _ANSI_srand
S#define rand _ANSI_rand
S#define RAND_MAX 0x7fff
N#else
N#define RAND_MAX 0x7fffffff
N#endif
N   /*
N    * RAND_MAX: an integral constant expression, the value of which
N    * is the maximum value returned by the rand function.
N    */
Nextern _ARMABI int __aeabi_MB_CUR_MAX(void);
Xextern __declspec(__nothrow) int __aeabi_MB_CUR_MAX(void);
N#define MB_CUR_MAX ( __aeabi_MB_CUR_MAX() )
N   /*
N    * a positive integer expression whose value is the maximum number of bytes
N    * in a multibyte character for the extended character set specified by the
N    * current locale (category LC_CTYPE), and whose value is never greater
N    * than MB_LEN_MAX.
N    */
N
N   /*
N    * If the compiler supports signalling nans as per N965 then it
N    * will define __SUPPORT_SNAN__, in which case a user may define
N    * _WANT_SNAN in order to obtain a compliant version of the strtod
N    * family of functions.
N    */
N#if defined(__SUPPORT_SNAN__) && defined(_WANT_SNAN)
X#if 0L && 0L
S#pragma import(__use_snan)
N#endif
N
Nextern _ARMABI double atof(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double atof(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI int atoi(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atoi(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to int
N    * representation.
N    * Returns: the converted value.
N    */
Nextern _ARMABI long int atol(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long int atol(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation.
N    * Returns: the converted value.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI __LONGLONG atoll(const char * /*nptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long long atoll(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to
N    * long long int representation.
N    * Returns: the converted value.
N    */
N#endif
N
Nextern _ARMABI double strtod(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) double strtod(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to double
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling a
N    * floating point constant; and a final string of one or more unrecognised
N    * characters, including the terminating null character of the input string.
N    * Then it attempts to convert the subject sequence to a floating point
N    * number, and returns the result. A pointer to the final string is stored
N    * in the object pointed to by endptr, provided that endptr is not a null
N    * pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned. If the correct value is outside the range of
N    *          representable values, plus or minus HUGE_VAL is returned
N    *          (according to the sign of the value), and the value of the macro
N    *          ERANGE is stored in errno. If the correct value would cause
N    *          underflow, zero is returned and the value of the macro ERANGE is
N    *          stored in errno.
N    */
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI float strtof(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) float strtof(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
Nextern _ARMABI long double strtold(const char * __restrict /*nptr*/, char ** __restrict /*endptr*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) long double strtold(const char * __restrict  , char ** __restrict  ) __attribute__((__nonnull__(1)));
N   /*
N    * same as strtod, but return float and long double respectively.
N    */
N#endif
Nextern _ARMABI long int strtol(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long int strtol(const char * __restrict  ,
N                        char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to long int
N    * representation. First it decomposes the input string into three parts:
N    * an initial, possibly empty, sequence of white-space characters (as
N    * specified by the isspace function), a subject sequence resembling an
N    * integer represented in some radix determined by the value of base, and a
N    * final string of one or more unrecognised characters, including the
N    * terminating null character of the input string. Then it attempts to
N    * convert the subject sequence to an integer, and returns the result.
N    * If the value of base is 0, the expected form of the subject sequence is
N    * that of an integer constant (described in ANSI Draft, section 3.1.3.2),
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. If the value of base is between 2 and 36, the expected form of
N    * the subject sequence is a sequence of letters and digits representing an
N    * integer with the radix specified by base, optionally preceded by a plus
N    * or minus sign, but not including an integer suffix. The letters from a
N    * (or A) through z (or Z) are ascribed the values 10 to 35; only letters
N    * whose ascribed values are less than that of the base are permitted. If
N    * the value of base is 16, the characters 0x or 0X may optionally precede
N    * the sequence of letters and digits following the sign if present.
N    * A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, LONG_MAX or LONG_MIN is returned
N    *          (according to the sign of the value), and the value of the
N    *          macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned long int strtoul(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long int strtoul(const char * __restrict  ,
N                                       char ** __restrict /*endptr*/, int /*base*/) __attribute__((__nonnull__(1)));
N   /*
N    * converts the initial part of the string pointed to by nptr to unsigned
N    * long int representation. First it decomposes the input string into three
N    * parts: an initial, possibly empty, sequence of white-space characters (as
N    * determined by the isspace function), a subject sequence resembling an
N    * unsigned integer represented in some radix determined by the value of
N    * base, and a final string of one or more unrecognised characters,
N    * including the terminating null character of the input string. Then it
N    * attempts to convert the subject sequence to an unsigned integer, and
N    * returns the result. If the value of base is zero, the expected form of
N    * the subject sequence is that of an integer constant (described in ANSI
N    * Draft, section 3.1.3.2), optionally preceded by a '+' or '-' sign, but
N    * not including an integer suffix. If the value of base is between 2 and
N    * 36, the expected form of the subject sequence is a sequence of letters
N    * and digits representing an integer with the radix specified by base,
N    * optionally preceded by a '+' or '-' sign, but not including an integer
N    * suffix. The letters from a (or A) through z (or Z) stand for the values
N    * 10 to 35; only letters whose ascribed values are less than that of the
N    * base are permitted. If the value of base is 16, the characters 0x or 0X
N    * may optionally precede the sequence of letters and digits following the
N    * sign, if present. A pointer to the final string is stored in the object
N    * pointed to by endptr, provided that endptr is not a null pointer.
N    * Returns: the converted value if any. If no conversion could be performed,
N    *          zero is returned and nptr is stored in *endptr.
N    *          If the correct value is outside the range of
N    *          representable values, ULONG_MAX is returned, and the value of
N    *          the macro ERANGE is stored in errno.
N    */
N
N/* C90 reserves all names beginning with 'str' */
Nextern _ARMABI __LONGLONG strtoll(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) long long strtoll(const char * __restrict  ,
N                                  char ** __restrict /*endptr*/, int /*base*/)
N                          __attribute__((__nonnull__(1)));
N   /*
N    * as strtol but returns a long long int value.  If the correct value is
N    * outside the range of representable values,  LLONG_MAX or LLONG_MIN is
N    * returned (according to the sign of the value), and the value of the
N    * macro ERANGE is stored in errno.
N    */
Nextern _ARMABI unsigned __LONGLONG strtoull(const char * __restrict /*nptr*/,
Xextern __declspec(__nothrow) unsigned long long strtoull(const char * __restrict  ,
N                                            char ** __restrict /*endptr*/, int /*base*/)
N                                   __attribute__((__nonnull__(1)));
N   /*
N    * as strtoul but returns an unsigned long long int value.  If the correct
N    * value is outside the range of representable values, ULLONG_MAX is returned,
N    * and the value of the macro ERANGE is stored in errno.
N    */
N
Nextern _ARMABI int rand(void);
Xextern __declspec(__nothrow) int rand(void);
N   /*
N    * Computes a sequence of pseudo-random integers in the range 0 to RAND_MAX.
N    * Uses an additive generator (Mitchell & Moore) of the form:
N    *   Xn = (X[n-24] + X[n-55]) MOD 2^31
N    * This is described in section 3.2.2 of Knuth, vol 2. It's period is
N    * in excess of 2^55 and its randomness properties, though unproven, are
N    * conjectured to be good. Empirical testing since 1958 has shown no flaws.
N    * Returns: a pseudo-random integer.
N    */
Nextern _ARMABI void srand(unsigned int /*seed*/);
Xextern __declspec(__nothrow) void srand(unsigned int  );
N   /*
N    * uses its argument as a seed for a new sequence of pseudo-random numbers
N    * to be returned by subsequent calls to rand. If srand is then called with
N    * the same seed value, the sequence of pseudo-random numbers is repeated.
N    * If rand is called before any calls to srand have been made, the same
N    * sequence is generated as when srand is first called with a seed value
N    * of 1.
N    */
N
Nstruct _rand_state { int __x[57]; };
Nextern _ARMABI int _rand_r(struct _rand_state *);
Xextern __declspec(__nothrow) int _rand_r(struct _rand_state *);
Nextern _ARMABI void _srand_r(struct _rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _srand_r(struct _rand_state *, unsigned int);
Nstruct _ANSI_rand_state { int __x[1]; };
Nextern _ARMABI int _ANSI_rand_r(struct _ANSI_rand_state *);
Xextern __declspec(__nothrow) int _ANSI_rand_r(struct _ANSI_rand_state *);
Nextern _ARMABI void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
Xextern __declspec(__nothrow) void _ANSI_srand_r(struct _ANSI_rand_state *, unsigned int);
N   /*
N    * Re-entrant variants of both flavours of rand, which operate on
N    * an explicitly supplied state buffer.
N    */
N
Nextern _ARMABI void *calloc(size_t /*nmemb*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *calloc(size_t  , size_t  );
N   /*
N    * allocates space for an array of nmemb objects, each of whose size is
N    * 'size'. The space is initialised to all bits zero.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void free(void * /*ptr*/);
Xextern __declspec(__nothrow) void free(void *  );
N   /*
N    * causes the space pointed to by ptr to be deallocated (i.e., made
N    * available for further allocation). If ptr is a null pointer, no action
N    * occurs. Otherwise, if ptr does not match a pointer earlier returned by
N    * calloc, malloc or realloc or if the space has been deallocated by a call
N    * to free or realloc, the behaviour is undefined.
N    */
Nextern _ARMABI void *malloc(size_t /*size*/);
Xextern __declspec(__nothrow) void *malloc(size_t  );
N   /*
N    * allocates space for an object whose size is specified by 'size' and whose
N    * value is indeterminate.
N    * Returns: either a null pointer or a pointer to the allocated space.
N    */
Nextern _ARMABI void *realloc(void * /*ptr*/, size_t /*size*/);
Xextern __declspec(__nothrow) void *realloc(void *  , size_t  );
N   /*
N    * changes the size of the object pointed to by ptr to the size specified by
N    * size. The contents of the object shall be unchanged up to the lesser of
N    * the new and old sizes. If the new size is larger, the value of the newly
N    * allocated portion of the object is indeterminate. If ptr is a null
N    * pointer, the realloc function behaves like a call to malloc for the
N    * specified size. Otherwise, if ptr does not match a pointer earlier
N    * returned by calloc, malloc or realloc, or if the space has been
N    * deallocated by a call to free or realloc, the behaviour is undefined.
N    * If the space cannot be allocated, the object pointed to by ptr is
N    * unchanged. If size is zero and ptr is not a null pointer, the object it
N    * points to is freed.
N    * Returns: either a null pointer or a pointer to the possibly moved
N    *          allocated space.
N    */
N#if !defined(__STRICT_ANSI__)
X#if !0L
Nextern _ARMABI int posix_memalign(void ** /*ret*/, size_t /*alignment*/, size_t /*size*/);
Xextern __declspec(__nothrow) int posix_memalign(void **  , size_t  , size_t  );
N   /*
N    * allocates space for an object of size 'size', aligned to a
N    * multiple of 'alignment' (which must be a power of two and at
N    * least 4).
N    *
N    * On success, a pointer to the allocated object is stored in
N    * *ret, and zero is returned. On failure, the return value is
N    * either ENOMEM (allocation failed because no suitable piece of
N    * memory was available) or EINVAL (the 'alignment' parameter was
N    * invalid).
N    */
N#endif
Ntypedef int (*__heapprt)(void *, char const *, ...);
Nextern _ARMABI void __heapstats(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) void __heapstats(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                        void * /*param*/) __attribute__((__nonnull__(1)));
N   /*
N    * reports current heap statistics (eg. number of free blocks in
N    * the free-list). Output is as implementation-defined free-form
N    * text, provided via the dprint function. `param' gives an
N    * extra data word to pass to dprint. You can call
N    * __heapstats(fprintf,stdout) by casting fprintf to the above
N    * function type; the typedef `__heapprt' is provided for this
N    * purpose.
N    *
N    * `dprint' will not be called while the heap is being examined,
N    * so it can allocate memory itself without trouble.
N    */
Nextern _ARMABI int __heapvalid(int (* /*dprint*/)(void * /*param*/,
Xextern __declspec(__nothrow) int __heapvalid(int (*  )(void *  ,
N                                           char const * /*format*/, ...),
N                       void * /*param*/, int /*verbose*/) __attribute__((__nonnull__(1)));
N   /*
N    * performs a consistency check on the heap. Errors are reported
N    * through dprint, like __heapstats. If `verbose' is nonzero,
N    * full diagnostic information on the heap state is printed out.
N    *
N    * This routine probably won't work if the heap isn't a
N    * contiguous chunk (for example, if __user_heap_extend has been
N    * overridden).
N    *
N    * `dprint' may be called while the heap is being examined or
N    * even in an invalid state, so it must perform no memory
N    * allocation. In particular, if `dprint' calls (or is) a stdio
N    * function, the stream it outputs to must already have either
N    * been written to or been setvbuf'ed, or else the system will
N    * allocate buffer space for it on the first call to dprint.
N    */
Nextern _ARMABI_NORETURN void abort(void);
Xextern __declspec(__nothrow) __declspec(__noreturn) void abort(void);
N   /*
N    * causes abnormal program termination to occur, unless the signal SIGABRT
N    * is being caught and the signal handler does not return. Whether open
N    * output streams are flushed or open streams are closed or temporary
N    * files removed is implementation-defined.
N    * An implementation-defined form of the status 'unsuccessful termination'
N    * is returned to the host environment by means of a call to
N    * raise(SIGABRT).
N    */
N
Nextern _ARMABI int atexit(void (* /*func*/)(void)) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) int atexit(void (*  )(void)) __attribute__((__nonnull__(1)));
N   /*
N    * registers the function pointed to by func, to be called without its
N    * arguments at normal program termination. It is possible to register at
N    * least 32 functions.
N    * Returns: zero if the registration succeeds, nonzero if it fails.
N    */
N#if defined(__EDG__) && !defined(__GNUC__)
X#if 1L && !0L
N#define __LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE
N#endif
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE) 
X#if 0L && 1L 
S    /* atexit that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode  
S     */
S    typedef void (* __C_exitfuncptr)();
S    extern "C++"
S    inline int atexit(void (* __func)()) {
S      return atexit((__C_exitfuncptr)__func);
S    }
N#endif
N
N
Nextern _ARMABI_NORETURN void exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void exit(int  );
N   /*
N    * causes normal program termination to occur. If more than one call to the
N    * exit function is executed by a program, the behaviour is undefined.
N    * First, all functions registered by the atexit function are called, in the
N    * reverse order of their registration.
N    * Next, all open output streams are flushed, all open streams are closed,
N    * and all files created by the tmpfile function are removed.
N    * Finally, control is returned to the host environment. If the value of
N    * status is zero or EXIT_SUCCESS, an implementation-defined form of the
N    * status 'successful termination' is returned. If the value of status is
N    * EXIT_FAILURE, an implementation-defined form of the status
N    * 'unsuccessful termination' is returned. Otherwise the status returned
N    * is implementation-defined.
N    */
N
Nextern _ARMABI_NORETURN void _Exit(int /*status*/);
Xextern __declspec(__nothrow) __declspec(__noreturn) void _Exit(int  );
N   /*
N    * causes normal program termination to occur. No functions registered
N    * by the atexit function are called.
N    * In this implementation, all open output streams are flushed, all
N    * open streams are closed, and all files created by the tmpfile function
N    * are removed.
N    * Control is returned to the host environment. The status returned to
N    * the host environment is determined in the same way as for 'exit'.
N    */     
N
Nextern _ARMABI char *getenv(const char * /*name*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *getenv(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * searches the environment list, provided by the host environment, for a
N    * string that matches the string pointed to by name. The set of environment
N    * names and the method for altering the environment list are
N    * implementation-defined.
N    * Returns: a pointer to a string associated with the matched list member.
N    *          The array pointed to shall not be modified by the program, but
N    *          may be overwritten by a subsequent call to the getenv function.
N    *          If the specified name cannot be found, a null pointer is
N    *          returned.
N    */
N
Nextern _ARMABI int  system(const char * /*string*/);
Xextern __declspec(__nothrow) int  system(const char *  );
N   /*
N    * passes the string pointed to by string to the host environment to be
N    * executed by a command processor in an implementation-defined manner.
N    * A null pointer may be used for string, to inquire whether a command
N    * processor exists.
N    *
N    * Returns: If the argument is a null pointer, the system function returns
N    *          non-zero only if a command processor is available. If the
N    *          argument is not a null pointer, the system function returns an
N    *          implementation-defined value.
N    */
N
Nextern _ARMABI_THROW void *bsearch(const void * /*key*/, const void * /*base*/,
Xextern  void *bsearch(const void *  , const void *  ,
N              size_t /*nmemb*/, size_t /*size*/,
N              int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
N   /*
N    * searches an array of nmemb objects, the initial member of which is
N    * pointed to by base, for a member that matches the object pointed to by
N    * key. The size of each member of the array is specified by size.
N    * The contents of the array shall be in ascending sorted order according to
N    * a comparison function pointed to by compar, which is called with two
N    * arguments that point to the key object and to an array member, in that
N    * order. The function shall return an integer less than, equal to, or
N    * greater than zero if the key object is considered, respectively, to be
N    * less than, to match, or to be greater than the array member.
N    * Returns: a pointer to a matching member of the array, or a null pointer
N    *          if no match is found. If two members compare as equal, which
N    *          member is matched is unspecified.
N    */
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* bsearch that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */
S    typedef int (* __C_compareprocptr)(const void *, const void *);
S    extern "C++"
S    void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,2,5)));
S    extern "C++"
S    inline void *bsearch(const void * __key, const void * __base,
S              size_t __nmemb, size_t __size,
S              int (* __compar)(const void *, const void *)) {
S      return bsearch(__key, __base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
N
Nextern _ARMABI_THROW void qsort(void * /*base*/, size_t /*nmemb*/, size_t /*size*/,
Xextern  void qsort(void *  , size_t  , size_t  ,
N           int (* /*compar*/)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
N   /*
N    * sorts an array of nmemb objects, the initial member of which is pointed
N    * to by base. The size of each object is specified by size.
N    * The contents of the array shall be in ascending order according to a
N    * comparison function pointed to by compar, which is called with two
N    * arguments that point to the objects being compared. The function shall
N    * return an integer less than, equal to, or greater than zero if the first
N    * argument is considered to be respectively less than, equal to, or greater
N    * than the second. If two members compare as equal, their order in the
N    * sorted array is unspecified.
N    */
N
N#if defined(__cplusplus) && defined(__LANGUAGE_LINKAGE_CHANGES_FUNCTION_TYPE)
X#if 0L && 1L
S    /* qsort that takes a ptr to a function with C++ linkage 
S     * but not in GNU mode
S     */    
S    extern "C++"
S    void qsort(void * __base, size_t __nmemb, size_t __size,
S               int (* __compar)(const void *, const void *)) __attribute__((__nonnull__(1,4)));
S    extern "C++"
S    inline void qsort(void * __base, size_t __nmemb, size_t __size,
S                      int (* __compar)(const void *, const void *)) {
S      qsort(__base, __nmemb, __size, (__C_compareprocptr)__compar);
S    }
N#endif
N
Nextern _ARMABI_PURE int abs(int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) int abs(int  );
N   /*
N    * computes the absolute value of an integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N
Nextern _ARMABI_PURE div_t div(int /*numer*/, int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) div_t div(int  , int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the resulting
N    * quotient is the integer of lesser magnitude that is the nearest to the
N    * algebraic quotient. If the result cannot be represented, the behaviour is
N    * undefined; otherwise, quot * denom + rem shall equal numer.
N    * Returns: a structure of type div_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          int quot; int rem;
N    */
Nextern _ARMABI_PURE long int labs(long int /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long int labs(long int  );
N   /*
N    * computes the absolute value of an long integer j. If the result cannot be
N    * represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE long abs(long int x) { return labs(x); }
N#endif
N
Nextern _ARMABI_PURE ldiv_t ldiv(long int /*numer*/, long int /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) ldiv_t ldiv(long int  , long int  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type ldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long int quot; long int rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE ldiv_t div(long int __numer, long int __denom) {
S       return ldiv(__numer, __denom);
S   }
N#endif
N
N#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
X#if !0L || __USE_C99_STDLIB
Nextern _ARMABI_PURE __LONGLONG llabs(__LONGLONG /*j*/);
Xextern __declspec(__nothrow) __attribute__((const)) long long llabs(long long  );
N   /*
N    * computes the absolute value of a long long integer j. If the
N    * result cannot be represented, the behaviour is undefined.
N    * Returns: the absolute value.
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE __LONGLONG abs(__LONGLONG x) { return llabs(x); }
N#endif
N
Nextern _ARMABI_PURE lldiv_t lldiv(__LONGLONG /*numer*/, __LONGLONG /*denom*/);
Xextern __declspec(__nothrow) __attribute__((const)) lldiv_t lldiv(long long  , long long  );
N   /*
N    * computes the quotient and remainder of the division of the numerator
N    * numer by the denominator denom. If the division is inexact, the sign of
N    * the resulting quotient is that of the algebraic quotient, and the
N    * magnitude of the resulting quotient is the largest integer less than the
N    * magnitude of the algebraic quotient. If the result cannot be represented,
N    * the behaviour is undefined; otherwise, quot * denom + rem shall equal
N    * numer.
N    * Returns: a structure of type lldiv_t, comprising both the quotient and the
N    *          remainder. the structure shall contain the following members,
N    *          in either order.
N    *          long long quot; long long rem;
N    */
N#ifdef __cplusplus
S   extern "C++" inline _ARMABI_PURE lldiv_t div(__LONGLONG __numer, __LONGLONG __denom) {
S       return lldiv(__numer, __denom);
S   }
N#endif
N#endif
N
N#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
N/*
N * ARM real-time divide functions for guaranteed performance
N */
Ntypedef struct __sdiv32by16 { int quot, rem; } __sdiv32by16;
Ntypedef struct __udiv32by16 { unsigned int quot, rem; } __udiv32by16;
N   /* used int so that values return in separate regs, although 16-bit */
Ntypedef struct __sdiv64by32 { int rem, quot; } __sdiv64by32;
N
N__value_in_regs extern _ARMABI_PURE __sdiv32by16 __rt_sdiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv32by16 __rt_sdiv32by16(
N     int /*numer*/,
N     short int /*denom*/);
N   /*
N    * Signed divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __udiv32by16 __rt_udiv32by16(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __udiv32by16 __rt_udiv32by16(
N     unsigned int /*numer*/,
N     unsigned short /*denom*/);
N   /*
N    * Unsigned divide: (16-bit quot), (16-bit rem) = (32-bit) / (16-bit)
N    */
N__value_in_regs extern _ARMABI_PURE __sdiv64by32 __rt_sdiv64by32(
X__value_in_regs extern __declspec(__nothrow) __attribute__((const)) __sdiv64by32 __rt_sdiv64by32(
N     int /*numer_h*/, unsigned int /*numer_l*/,
N     int /*denom*/);
N   /*
N    * Signed divide: (32-bit quot), (32-bit rem) = (64-bit) / (32-bit)
N    */
N#endif
N
N/*
N * ARM floating-point mask/status function (for both hardfp and softfp)
N */
Nextern _ARMABI unsigned int __fp_status(unsigned int /*mask*/, unsigned int /*flags*/);
Xextern __declspec(__nothrow) unsigned int __fp_status(unsigned int  , unsigned int  );
N   /*
N    * mask and flags are bit-fields which correspond directly to the
N    * floating point status register in the FPE/FPA and fplib.  
N    * __fp_status returns the current value of the status register,
N    * and also sets the writable bits of the word
N    * (the exception control and flag bytes) to:
N    *
N    *     new = (old & ~mask) ^ flags;
N    */
N#define __fpsr_IXE  0x100000
N#define __fpsr_UFE  0x80000
N#define __fpsr_OFE  0x40000
N#define __fpsr_DZE  0x20000
N#define __fpsr_IOE  0x10000
N
N#define __fpsr_IXC  0x10
N#define __fpsr_UFC  0x8
N#define __fpsr_OFC  0x4
N#define __fpsr_DZC  0x2
N#define __fpsr_IOC  0x1
N
N/*
N * Multibyte Character Functions.
N * The behaviour of the multibyte character functions is affected by the
N * LC_CTYPE category of the current locale. For a state-dependent encoding,
N * each function is placed into its initial state by a call for which its
N * character pointer argument, s, is a null pointer. Subsequent calls with s
N * as other than a null pointer cause the internal state of the function to be
N * altered as necessary. A call with s as a null pointer causes these functions
N * to return a nonzero value if encodings have state dependency, and a zero
N * otherwise. After the LC_CTYPE category is changed, the shift state of these
N * functions is indeterminate.
N */
Nextern _ARMABI int mblen(const char * /*s*/, size_t /*n*/);
Xextern __declspec(__nothrow) int mblen(const char *  , size_t  );
N   /*
N    * If s is not a null pointer, the mblen function determines the number of
N    * bytes compromising the multibyte character pointed to by s. Except that
N    * the shift state of the mbtowc function is not affected, it is equivalent
N    * to   mbtowc((wchar_t *)0, s, n);
N    * Returns: If s is a null pointer, the mblen function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mblen function either returns a 0 (if s points to a
N    *          null character), or returns the number of bytes that compromise
N    *          the multibyte character (if the next n of fewer bytes form a
N    *          valid multibyte character), or returns -1 (they do not form a
N    *          valid multibyte character).
N    */
Nextern _ARMABI int mbtowc(wchar_t * __restrict /*pwc*/,
Xextern __declspec(__nothrow) int mbtowc(wchar_t * __restrict  ,
N                   const char * __restrict /*s*/, size_t /*n*/);
N   /*
N    * If s is not a null pointer, the mbtowc function determines the number of
N    * bytes that compromise the multibyte character pointed to by s. It then
N    * determines the code for value of type wchar_t that corresponds to that
N    * multibyte character. (The value of the code corresponding to the null
N    * character is zero). If the multibyte character is valid and pwc is not a
N    * null pointer, the mbtowc function stores the code in the object pointed
N    * to by pwc. At most n bytes of the array pointed to by s will be examined.
N    * Returns: If s is a null pointer, the mbtowc function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the mbtowc function either returns a 0 (if s points to
N    *          a null character), or returns the number of bytes that
N    *          compromise the converted multibyte character (if the next n of
N    *          fewer bytes form a valid multibyte character), or returns -1
N    *          (they do not form a valid multibyte character).
N    */
Nextern _ARMABI int wctomb(char * /*s*/, wchar_t /*wchar*/);
Xextern __declspec(__nothrow) int wctomb(char *  , wchar_t  );
N   /*
N    * determines the number of bytes need to represent the multibyte character
N    * corresponding to the code whose value is wchar (including any change in
N    * shift state). It stores the multibyte character representation in the
N    * array object pointed to by s (if s is not a null pointer). At most
N    * MB_CUR_MAX characters are stored. If the value of wchar is zero, the
N    * wctomb function is left in the initial shift state).
N    * Returns: If s is a null pointer, the wctomb function returns a nonzero or
N    *          zero value, if multibyte character encodings, respectively, do
N    *          or do not have state-dependent encodings. If s is not a null
N    *          pointer, the wctomb function returns a -1 if the value of wchar
N    *          does not correspond to a valid multibyte character, or returns
N    *          the number of bytes that compromise the multibyte character
N    *          corresponding to the value of wchar.
N    */
N
N/*
N * Multibyte String Functions.
N * The behaviour of the multibyte string functions is affected by the LC_CTYPE
N * category of the current locale.
N */
Nextern _ARMABI size_t mbstowcs(wchar_t * __restrict /*pwcs*/,
Xextern __declspec(__nothrow) size_t mbstowcs(wchar_t * __restrict  ,
N                      const char * __restrict /*s*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of multibyte character that begins in the initial
N    * shift state from the array pointed to by s into a sequence of
N    * corresponding codes and stores not more than n codes into the array
N    * pointed to by pwcs. No multibyte character that follow a null character
N    * (which is converted into a code with value zero) will be examined or
N    * converted. Each multibyte character is converted as if by a call to
N    * mbtowc function, except that the shift state of the mbtowc function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by pwcs. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If an invalid multibyte character is encountered, the mbstowcs
N    *          function returns (size_t)-1. Otherwise, the mbstowcs function
N    *          returns the number of array elements modified, not including
N    *          a terminating zero code, if any.
N    */
Nextern _ARMABI size_t wcstombs(char * __restrict /*s*/,
Xextern __declspec(__nothrow) size_t wcstombs(char * __restrict  ,
N                      const wchar_t * __restrict /*pwcs*/, size_t /*n*/) __attribute__((__nonnull__(2)));
N   /*
N    * converts a sequence of codes that correspond to multibyte characters
N    * from the array pointed to by pwcs into a sequence of multibyte
N    * characters that begins in the initial shift state and stores these
N    * multibyte characters into the array pointed to by s, stopping if a
N    * multibyte character would exceed the limit of n total bytes or if a
N    * null character is stored. Each code is converted as if by a call to the
N    * wctomb function, except that the shift state of the wctomb function is
N    * not affected. No more than n elements will be modified in the array
N    * pointed to by s. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: If a code is encountered that does not correspond to a valid
N    *          multibyte character, the wcstombs function returns (size_t)-1.
N    *          Otherwise, the wcstombs function returns the number of bytes
N    *          modified, not including a terminating null character, if any.
N    */
N
Nextern _ARMABI void __use_realtime_heap(void);
Xextern __declspec(__nothrow) void __use_realtime_heap(void);
Nextern _ARMABI void __use_realtime_division(void);
Xextern __declspec(__nothrow) void __use_realtime_division(void);
Nextern _ARMABI void __use_two_region_memory(void);
Xextern __declspec(__nothrow) void __use_two_region_memory(void);
Nextern _ARMABI void __use_no_heap(void);
Xextern __declspec(__nothrow) void __use_no_heap(void);
Nextern _ARMABI void __use_no_heap_region(void);
Xextern __declspec(__nothrow) void __use_no_heap_region(void);
N
Nextern _ARMABI char const *__C_library_version_string(void);
Xextern __declspec(__nothrow) char const *__C_library_version_string(void);
Nextern _ARMABI int __C_library_version_number(void);
Xextern __declspec(__nothrow) int __C_library_version_number(void);
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STDLIB_DECLS */
N
N  #if _AEABI_PORTABILITY_LEVEL != 0 && !defined _AEABI_PORTABLE
X  #if _AEABI_PORTABILITY_LEVEL != 0 && !0L
S    #define _AEABI_PORTABLE
N  #endif
N
N  #ifdef __cplusplus
S    #ifndef __STDLIB_NO_EXPORTS
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::atoll;
S        using ::std::lldiv_t;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S      using ::std::div_t;
S      using ::std::ldiv_t;
S      using ::std::atof;
S      using ::std::atoi;
S      using ::std::atol;
S      using ::std::strtod;
S#if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S      using ::std::strtof;
S      using ::std::strtold;
S#endif
S      using ::std::strtol;
S      using ::std::strtoul;
S      using ::std::strtoll;
S      using ::std::strtoull;
S      using ::std::rand;
S      using ::std::srand;
S      using ::std::_rand_state;
S      using ::std::_rand_r;
S      using ::std::_srand_r;
S      using ::std::_ANSI_rand_state;
S      using ::std::_ANSI_rand_r;
S      using ::std::_ANSI_srand_r;
S      using ::std::calloc;
S      using ::std::free;
S      using ::std::malloc;
S      using ::std::realloc;
S#if !defined(__STRICT_ANSI__)
S      using ::std::posix_memalign;
S#endif
S      using ::std::__heapprt;
S      using ::std::__heapstats;
S      using ::std::__heapvalid;
S      using ::std::abort;
S      using ::std::atexit;
S      using ::std::exit;
S      using ::std::_Exit;
S      using ::std::getenv;
S      using ::std::system;
S      using ::std::bsearch;
S      using ::std::qsort;
S      using ::std::abs;
S      using ::std::div;
S      using ::std::labs;
S      using ::std::ldiv;
S      #if !defined(__STRICT_ANSI__) || __USE_C99_STDLIB
S        using ::std::llabs;
S        using ::std::lldiv;
S      #endif /* !defined(__STRICT_ANSI__) || __USE_C99_STDLIB */
S#if !(__ARM_NO_DEPRECATED_FUNCTIONS)
S      using ::std::__sdiv32by16;
S      using ::std::__udiv32by16;
S      using ::std::__sdiv64by32;
S      using ::std::__rt_sdiv32by16;
S      using ::std::__rt_udiv32by16;
S      using ::std::__rt_sdiv64by32;
S#endif
S      using ::std::__fp_status;
S      using ::std::mblen;
S      using ::std::mbtowc;
S      using ::std::wctomb;
S      using ::std::mbstowcs;
S      using ::std::wcstombs;
S      using ::std::__use_realtime_heap;
S      using ::std::__use_realtime_division;
S      using ::std::__use_two_region_memory;
S      using ::std::__use_no_heap;
S      using ::std::__use_no_heap_region;
S      using ::std::__C_library_version_string;
S      using ::std::__C_library_version_number;
S      using ::std::size_t;
S      using ::std::__aeabi_MB_CUR_MAX;
S    #endif /* __STDLIB_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#undef __LONGLONG
N
N#endif /* __stdlib_h */
N
N/* end of stdlib.h */
L 88 "..\..\components\finsh\finsh.h" 2
N#include <string.h>
L 1 "C:\Keil_v5\ARM\ARMCC\Bin\..\include\string.h" 1
N/* string.h: ANSI 'C' (X3J11 Oct 88) library header, section 4.11 */
N/* Copyright (C) Codemist Ltd., 1988-1993.                        */
N/* Copyright 1991-1993 ARM Limited. All rights reserved.          */
N/* version 0.04 */
N
N/*
N * RCS $Revision$
N * Checkin $Date$
N */
N
N/*
N * string.h declares one type and several functions, and defines one macro
N * useful for manipulating character arrays and other objects treated as
N * character arrays. Various methods are used for determining the lengths of
N * the arrays, but in all cases a char * or void * argument points to the
N * initial (lowest addresses) character of the array. If an array is written
N * beyond the end of an object, the behaviour is undefined.
N */
N
N#ifndef __string_h
N#define __string_h
N#define __ARMCLIB_VERSION 5060016
N
N#define _ARMABI __declspec(__nothrow)
N
N  #ifndef __STRING_DECLS
N  #define __STRING_DECLS
N
N    #undef __CLIBNS
N
N    #ifdef __cplusplus
S        namespace std {
S        #define __CLIBNS std::
S        extern "C" {
N    #else
N      #define __CLIBNS
N    #endif  /* __cplusplus */
N
N#if defined(__cplusplus) || !defined(__STRICT_ANSI__)
X#if 0L || !0L
N /* unconditional in C++ and non-strict C for consistency of debug info */
N  #if __sizeof_ptr == 8
X  #if 4 == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
N  #else
N    typedef unsigned int size_t;   /* see <stddef.h> */
N  #endif
N#elif !defined(__size_t)
S  #define __size_t 1
S  #if __sizeof_ptr == 8
S    typedef unsigned long size_t;   /* see <stddef.h> */
S  #else
S    typedef unsigned int size_t;   /* see <stddef.h> */
S  #endif
N#endif
N
N#undef NULL
N#define NULL 0                   /* see <stddef.h> */
N
Nextern _ARMABI void *memcpy(void * __restrict /*s1*/,
Xextern __declspec(__nothrow) void *memcpy(void * __restrict  ,
N                    const void * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI void *memmove(void * /*s1*/,
Xextern __declspec(__nothrow) void *memmove(void *  ,
N                    const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies n characters from the object pointed to by s2 into the object
N    * pointed to by s1. Copying takes place as if the n characters from the
N    * object pointed to by s2 are first copied into a temporary array of n
N    * characters that does not overlap the objects pointed to by s1 and s2,
N    * and then the n characters from the temporary array are copied into the
N    * object pointed to by s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strcpy(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcpy(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string pointed to by s2 (including the terminating nul
N    * character) into the array pointed to by s1. If copying takes place
N    * between objects that overlap, the behaviour is undefined.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncpy(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncpy(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies not more than n characters (characters that follow a null
N    * character are not copied) from the array pointed to by s2 into the array
N    * pointed to by s1. If copying takes place between objects that overlap,
N    * the behaviour is undefined.
N    * Returns: the value of s1.
N    */
N
Nextern _ARMABI char *strcat(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strcat(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends a copy of the string pointed to by s2 (including the terminating
N    * null character) to the end of the string pointed to by s1. The initial
N    * character of s2 overwrites the null character at the end of s1.
N    * Returns: the value of s1.
N    */
Nextern _ARMABI char *strncat(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strncat(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * appends not more than n characters (a null character and characters that
N    * follow it are not appended) from the array pointed to by s2 to the end of
N    * the string pointed to by s1. The initial character of s2 overwrites the
N    * null character at the end of s1. A terminating null character is always
N    * appended to the result.
N    * Returns: the value of s1.
N    */
N
N/*
N * The sign of a nonzero value returned by the comparison functions is
N * determined by the sign of the difference between the values of the first
N * pair of characters (both interpreted as unsigned char) that differ in the
N * objects being compared.
N */
N
Nextern _ARMABI int memcmp(const void * /*s1*/, const void * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int memcmp(const void *  , const void *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the first n characters of the object pointed to by s1 to the
N    * first n characters of the object pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the object pointed to by s1 is greater than, equal to, or
N    *          less than the object pointed to by s2.
N    */
Nextern _ARMABI int strcmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcasecmp(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcasecmp(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2,
N    * case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strncasecmp(const char * /*s1*/, const char * /*s2*/, size_t /*n*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strncasecmp(const char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares not more than n characters (characters that follow a null
N    * character are not compared) from the array pointed to by s1 to the array
N    * pointed to by s2, case-insensitively as defined by the current locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2.
N    */
Nextern _ARMABI int strcoll(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) int strcoll(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * compares the string pointed to by s1 to the string pointed to by s2, both
N    * interpreted as appropriate to the LC_COLLATE category of the current
N    * locale.
N    * Returns: an integer greater than, equal to, or less than zero, according
N    *          as the string pointed to by s1 is greater than, equal to, or
N    *          less than the string pointed to by s2 when both are interpreted
N    *          as appropriate to the current locale.
N    */
N
Nextern _ARMABI size_t strxfrm(char * __restrict /*s1*/, const char * __restrict /*s2*/, size_t /*n*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) size_t strxfrm(char * __restrict  , const char * __restrict  , size_t  ) __attribute__((__nonnull__(2)));
N   /*
N    * transforms the string pointed to by s2 and places the resulting string
N    * into the array pointed to by s1. The transformation function is such that
N    * if the strcmp function is applied to two transformed strings, it returns
N    * a value greater than, equal to or less than zero, corresponding to the
N    * result of the strcoll function applied to the same two original strings.
N    * No more than n characters are placed into the resulting array pointed to
N    * by s1, including the terminating null character. If n is zero, s1 is
N    * permitted to be a null pointer. If copying takes place between objects
N    * that overlap, the behaviour is undefined.
N    * Returns: The length of the transformed string is returned (not including
N    *          the terminating null character). If the value returned is n or
N    *          more, the contents of the array pointed to by s1 are
N    *          indeterminate.
N    */
N
N
N#ifdef __cplusplus
Sextern _ARMABI const void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Sextern "C++" void *memchr(void * __s, int __c, size_t __n) __attribute__((__nonnull__(1)));
Sextern "C++" inline void *memchr(void * __s, int __c, size_t __n)
S    { return const_cast<void *>(memchr(const_cast<const void *>(__s), __c, __n)); }
N#else
Nextern _ARMABI void *memchr(const void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memchr(const void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an unsigned char) in the
N    * initial n characters (each interpreted as unsigned char) of the object
N    * pointed to by s.
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the object.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strchr(char * __s, int __c)
S    { return const_cast<char *>(strchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the first occurence of c (converted to an char) in the string
N    * pointed to by s (including the terminating null character).
N    * Returns: a pointer to the located character, or a null pointer if the
N    *          character does not occur in the string.
N    */
N
Nextern _ARMABI size_t strcspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strcspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters not from the string pointed to by
N    * s2. The terminating null character is not considered part of s2.
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strpbrk(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strpbrk(char * __s1, const char * __s2)
S    { return const_cast<char *>(strpbrk(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strpbrk(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strpbrk(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of any
N    * character from the string pointed to by s2.
N    * Returns: returns a pointer to the character, or a null pointer if no
N    *          character form s2 occurs in s1.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Sextern "C++" char *strrchr(char * __s, int __c) __attribute__((__nonnull__(1)));
Sextern "C++" inline char *strrchr(char * __s, int __c)
S    { return const_cast<char *>(strrchr(const_cast<const char *>(__s), __c)); }
N#else
Nextern _ARMABI char *strrchr(const char * /*s*/, int /*c*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) char *strrchr(const char *  , int  ) __attribute__((__nonnull__(1)));
N#endif
N   /*
N    * locates the last occurence of c (converted to a char) in the string
N    * pointed to by s. The terminating null character is considered part of
N    * the string.
N    * Returns: returns a pointer to the character, or a null pointer if c does
N    *          not occur in the string.
N    */
N
Nextern _ARMABI size_t strspn(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strspn(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * computes the length of the initial segment of the string pointed to by s1
N    * which consists entirely of characters from the string pointed to by S2
N    * Returns: the length of the segment.
N    */
N
N#ifdef __cplusplus
Sextern _ARMABI const char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Sextern "C++" char *strstr(char * __s1, const char * __s2) __attribute__((__nonnull__(1,2)));
Sextern "C++" inline char *strstr(char * __s1, const char * __s2)
S    { return const_cast<char *>(strstr(const_cast<const char *>(__s1), __s2)); }
N#else
Nextern _ARMABI char *strstr(const char * /*s1*/, const char * /*s2*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) char *strstr(const char *  , const char *  ) __attribute__((__nonnull__(1,2)));
N#endif
N   /*
N    * locates the first occurence in the string pointed to by s1 of the
N    * sequence of characters (excluding the terminating null character) in the
N    * string pointed to by s2.
N    * Returns: a pointer to the located string, or a null pointer if the string
N    *          is not found.
N    */
N
Nextern _ARMABI char *strtok(char * __restrict /*s1*/, const char * __restrict /*s2*/) __attribute__((__nonnull__(2)));
Xextern __declspec(__nothrow) char *strtok(char * __restrict  , const char * __restrict  ) __attribute__((__nonnull__(2)));
Nextern _ARMABI char *_strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *_strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#ifndef __STRICT_ANSI__
Nextern _ARMABI char *strtok_r(char * /*s1*/, const char * /*s2*/, char ** /*ptr*/) __attribute__((__nonnull__(2,3)));
Xextern __declspec(__nothrow) char *strtok_r(char *  , const char *  , char **  ) __attribute__((__nonnull__(2,3)));
N#endif
N   /*
N    * A sequence of calls to the strtok function breaks the string pointed to
N    * by s1 into a sequence of tokens, each of which is delimited by a
N    * character from the string pointed to by s2. The first call in the
N    * sequence has s1 as its first argument, and is followed by calls with a
N    * null pointer as their first argument. The separator string pointed to by
N    * s2 may be different from call to call.
N    * The first call in the sequence searches for the first character that is
N    * not contained in the current separator string s2. If no such character
N    * is found, then there are no tokens in s1 and the strtok function returns
N    * a null pointer. If such a character is found, it is the start of the
N    * first token.
N    * The strtok function then searches from there for a character that is
N    * contained in the current separator string. If no such character is found,
N    * the current token extends to the end of the string pointed to by s1, and
N    * subsequent searches for a token will fail. If such a character is found,
N    * it is overwritten by a null character, which terminates the current
N    * token. The strtok function saves a pointer to the following character,
N    * from which the next search for a token will start.
N    * Each subsequent call, with a null pointer as the value for the first
N    * argument, starts searching from the saved pointer and behaves as
N    * described above.
N    * Returns: pointer to the first character of a token, or a null pointer if
N    *          there is no token.
N    *
N    * strtok_r() is a common extension which works exactly like
N    * strtok(), but instead of storing its state in a hidden
N    * library variable, requires the user to pass in a pointer to a
N    * char * variable which will be used instead. Any sequence of
N    * calls to strtok_r() passing the same char ** pointer should
N    * behave exactly like the corresponding sequence of calls to
N    * strtok(). This means that strtok_r() can safely be used in
N    * multi-threaded programs, and also that you can tokenise two
N    * strings in parallel.
N    */
N
Nextern _ARMABI void *memset(void * /*s*/, int /*c*/, size_t /*n*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) void *memset(void *  , int  , size_t  ) __attribute__((__nonnull__(1)));
N   /*
N    * copies the value of c (converted to an unsigned char) into each of the
N    * first n charactes of the object pointed to by s.
N    * Returns: the value of s.
N    */
Nextern _ARMABI char *strerror(int /*errnum*/);
Xextern __declspec(__nothrow) char *strerror(int  );
N   /*
N    * maps the error number in errnum to an error message string.
N    * Returns: a pointer to the string, the contents of which are
N    *          implementation-defined. The array pointed to shall not be
N    *          modified by the program, but may be overwritten by a
N    *          subsequent call to the strerror function.
N    */
Nextern _ARMABI size_t strlen(const char * /*s*/) __attribute__((__nonnull__(1)));
Xextern __declspec(__nothrow) size_t strlen(const char *  ) __attribute__((__nonnull__(1)));
N   /*
N    * computes the length of the string pointed to by s.
N    * Returns: the number of characters that precede the terminating null
N    *          character.
N    */
N
Nextern _ARMABI size_t strlcpy(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcpy(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * copies the string src into the string dst, using no more than
N    * len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src. Thus, the operation
N    * succeeded without truncation if and only if ret < len;
N    * otherwise, the value in ret tells you how big to make dst if
N    * you decide to reallocate it. (That value does _not_ include
N    * the NUL.)
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI size_t strlcat(char * /*dst*/, const char * /*src*/, size_t /*len*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) size_t strlcat(char *  , const char *  , size_t  ) __attribute__((__nonnull__(1,2)));
N   /*
N    * concatenates the string src to the string dst, using no more
N    * than len bytes of dst. Always null-terminates dst _within the
N    * length len (i.e. will copy at most len-1 bytes of string plus
N    * a NUL), unless len is actually zero.
N    * 
N    * Return value is the length of the string that _would_ have
N    * been written, i.e. the length of src plus the original length
N    * of dst. Thus, the operation succeeded without truncation if
N    * and only if ret < len; otherwise, the value in ret tells you
N    * how big to make dst if you decide to reallocate it. (That
N    * value does _not_ include the NUL.)
N    * 
N    * If no NUL is encountered within the first len bytes of dst,
N    * then the length of dst is considered to have been equal to
N    * len for the purposes of the return value (as if there were a
N    * NUL at dst[len]). Thus, the return value in this case is len
N    * + strlen(src).
N    * 
N    * This is a BSD-derived library extension, which we are
N    * permitted to declare in a standard header because ISO defines
N    * function names beginning with 'str' as reserved for future
N    * expansion of <string.h>.
N    */
N
Nextern _ARMABI void _membitcpybl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpybb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpybb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpyhb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpyhb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitcpywb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitcpywb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovebb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovebb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovehb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovehb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewl(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewl(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
Nextern _ARMABI void _membitmovewb(void * /*dest*/, const void * /*src*/, int /*destoffset*/, int /*srcoffset*/, size_t /*nbits*/) __attribute__((__nonnull__(1,2)));
Xextern __declspec(__nothrow) void _membitmovewb(void *  , const void *  , int  , int  , size_t  ) __attribute__((__nonnull__(1,2)));
N    /*
N     * Copies or moves a piece of memory from one place to another,
N     * with one-bit granularity. So you can start or finish a copy
N     * part way through a byte, and you can copy between regions
N     * with different alignment within a byte.
N     * 
N     * All these functions have the same prototype: two void *
N     * pointers for destination and source, then two integers
N     * giving the bit offset from those pointers, and finally the
N     * number of bits to copy.
N     * 
N     * Just like memcpy and memmove, the "cpy" functions copy as
N     * fast as they can in the assumption that the memory regions
N     * do not overlap, while the "move" functions cope correctly
N     * with overlap.
N     *
N     * Treating memory as a stream of individual bits requires
N     * defining a convention about what order those bits are
N     * considered to be arranged in. The above functions support
N     * multiple conventions:
N     * 
N     *  - the "bl" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in little-endian fashion, so that the LSB comes
N     *    first. (For example, membitcpybl(a,b,0,7,1) would copy
N     *    the MSB of the byte at b to the LSB of the byte at a.)
N     * 
N     *  - the "bb" functions consider the unit of memory to be the
N     *    byte, and consider the bits within each byte to be
N     *    arranged in big-endian fashion, so that the MSB comes
N     *    first.
N     * 
N     *  - the "hl" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in little-endian fashion.
N     * 
N     *  - the "hb" functions consider the unit of memory to be the
N     *    16-bit halfword, and consider the bits within each word
N     *    to be arranged in big-endian fashion.
N     * 
N     *  - the "wl" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in little-endian fashion.
N     * 
N     *  - the "wb" functions consider the unit of memory to be the
N     *    32-bit word, and consider the bits within each word to be
N     *    arranged in big-endian fashion.
N     */
N
N    #ifdef __cplusplus
S         }  /* extern "C" */
S      }  /* namespace std */
N    #endif /* __cplusplus */
N  #endif /* __STRING_DECLS */
N
N  #ifdef __cplusplus
S    #ifndef __STRING_NO_EXPORTS
S      using ::std::size_t;
S      using ::std::memcpy;
S      using ::std::memmove;
S      using ::std::strcpy;
S      using ::std::strncpy;
S      using ::std::strcat;
S      using ::std::strncat;
S      using ::std::memcmp;
S      using ::std::strcmp;
S      using ::std::strncmp;
S      using ::std::strcasecmp;
S      using ::std::strncasecmp;
S      using ::std::strcoll;
S      using ::std::strxfrm;
S      using ::std::memchr;
S      using ::std::strchr;
S      using ::std::strcspn;
S      using ::std::strpbrk;
S      using ::std::strrchr;
S      using ::std::strspn;
S      using ::std::strstr;
S      using ::std::strtok;
S#ifndef __STRICT_ANSI__
S      using ::std::strtok_r;
S#endif
S      using ::std::_strtok_r;
S      using ::std::memset;
S      using ::std::strerror;
S      using ::std::strlen;
S      using ::std::strlcpy;
S      using ::std::strlcat;
S      using ::std::_membitcpybl;
S      using ::std::_membitcpybb;
S      using ::std::_membitcpyhl;
S      using ::std::_membitcpyhb;
S      using ::std::_membitcpywl;
S      using ::std::_membitcpywb;
S      using ::std::_membitmovebl;
S      using ::std::_membitmovebb;
S      using ::std::_membitmovehl;
S      using ::std::_membitmovehb;
S      using ::std::_membitmovewl;
S      using ::std::_membitmovewb;
S    #endif /* __STRING_NO_EXPORTS */
N  #endif /* __cplusplus */
N
N#endif
N
N/* end of string.h */
N
L 89 "..\..\components\finsh\finsh.h" 2
N#endif
N#endif
N
N#define FINSH_VERSION_MAJOR			1
N#define FINSH_VERSION_MINOR			0
N
N/**
N * @addtogroup finsh
N */
N/*@{*/
N#define FINSH_ERROR_OK              0   /**< No error 			*/
N#define FINSH_ERROR_INVALID_TOKEN	1	/**< Invalid token 		*/
N#define FINSH_ERROR_EXPECT_TYPE		2	/**< Expect a type 		*/
N#define FINSH_ERROR_UNKNOWN_TYPE	3	/**< Unknown type 		*/
N#define FINSH_ERROR_VARIABLE_EXIST	4	/**< Variable exist 	*/
N#define FINSH_ERROR_EXPECT_OPERATOR	5	/**< Expect a operator 	*/
N#define FINSH_ERROR_MEMORY_FULL		6	/**< Memory full 		*/
N#define FINSH_ERROR_UNKNOWN_OP		7 	/**< Unknown operator 	*/
N#define FINSH_ERROR_UNKNOWN_NODE	8	/**< Unknown node 		*/
N#define FINSH_ERROR_EXPECT_CHAR		9	/**< Expect a character */
N#define FINSH_ERROR_UNEXPECT_END	10	/**< Unexpect end 		*/
N#define FINSH_ERROR_UNKNOWN_TOKEN	11	/**< Unknown token 		*/
N#define FINSH_ERROR_NO_FLOAT		12	/**< Float not supported */
N#define FINSH_ERROR_UNKNOWN_SYMBOL	13	/**< Unknown symbol 	*/
N#define FINSH_ERROR_NULL_NODE		14	/**< Null node 			*/
N/*@}*/
N
Ntypedef long (*syscall_func)();
N
N/* system call table */
Nstruct finsh_syscall
N{
N	const char*		name;		/* the name of system call */
N#if defined(FINSH_USING_DESCRIPTION) && defined(FINSH_USING_SYMTAB)
X#if 1L && 1L
N	const char*		desc;		/* description of system call */
N#endif
N	syscall_func func;		/* the function address of system call */
N};
N
N/* system call item */
Nstruct finsh_syscall_item
N{
N	struct finsh_syscall_item* next;	/* next item */
N	struct finsh_syscall syscall;		/* syscall */
N};
Nextern struct finsh_syscall *_syscall_table_begin, *_syscall_table_end;
Nextern struct finsh_syscall_item *global_syscall_list;
N
N/* find out system call, which should be implemented in user program */
Nstruct finsh_syscall* finsh_syscall_lookup(const char* name);
N
N/* system variable table */
Nstruct finsh_sysvar
N{
N	const char*		name;		/* the name of variable */
N#if defined(FINSH_USING_DESCRIPTION) && defined(FINSH_USING_SYMTAB)
X#if 1L && 1L
N	const char* 	desc;		/* description of system variable */
N#endif
N	u_char		 type;		/* the type of variable */
N	void*		 var ;		/* the address of variable */
N};
N
N#if defined(_MSC_VER) || (defined(__GNUC__) && defined(__x86_64__))
X#if 0L || (0L && 0L)
Sstruct finsh_syscall* finsh_syscall_next(struct finsh_syscall* call);
Sstruct finsh_sysvar* finsh_sysvar_next(struct finsh_sysvar* call);
S#define FINSH_NEXT_SYSCALL(index)  index=finsh_syscall_next(index)
S#define FINSH_NEXT_SYSVAR(index)   index=finsh_sysvar_next(index)
N#else
N#define FINSH_NEXT_SYSCALL(index)  index++
N#define FINSH_NEXT_SYSVAR(index)   index++
N#endif
N
N/* system variable item */
Nstruct finsh_sysvar_item
N{
N	struct finsh_sysvar_item *next;		/* next item */
N	struct finsh_sysvar sysvar;			/* system variable */
N};
Nextern struct finsh_sysvar *_sysvar_table_begin, *_sysvar_table_end;
Nextern struct finsh_sysvar_item* global_sysvar_list;
N
N/* find out system variable, which should be implemented in user program */
Nstruct finsh_sysvar* finsh_sysvar_lookup(const char* name);
N
N#ifdef FINSH_USING_SYMTAB
N
N#ifdef __TI_COMPILER_VERSION__
S#define __TI_FINSH_EXPORT_FUNCTION(f)  PRAGMA(DATA_SECTION(f,"FSymTab"))
S#define __TI_FINSH_EXPORT_VAR(v)       PRAGMA(DATA_SECTION(v,"VSymTab"))
N#endif
N
N    #ifdef FINSH_USING_DESCRIPTION
N        #ifdef _MSC_VER
S            #define FINSH_FUNCTION_EXPORT_CMD(name, cmd, desc)      \
S                const char __fsym_##cmd##_name[] = #cmd;            \
S                const char __fsym_##cmd##_desc[] = #desc;           \
S                __declspec(allocate("FSymTab$f"))                   \
S                const struct finsh_syscall __fsym_##cmd =           \
S                {                           \
S                    __fsym_##cmd##_name,    \
S                    __fsym_##cmd##_desc,    \
S                    (syscall_func)&name     \
S                };
X            #define FINSH_FUNCTION_EXPORT_CMD(name, cmd, desc)                      const char __fsym_##cmd##_name[] = #cmd;                            const char __fsym_##cmd##_desc[] = #desc;                           __declspec(allocate("FSymTab$f"))                                   const struct finsh_syscall __fsym_##cmd =                           {                                               __fsym_##cmd##_name,                        __fsym_##cmd##_desc,                        (syscall_func)&name                     };
S            #pragma comment(linker, "/merge:FSymTab=mytext")
S
S            #define FINSH_VAR_EXPORT(name, type, desc)              \
S                const char __vsym_##name##_name[] = #name;          \
S                const char __vsym_##name##_desc[] = #desc;          \
S                __declspec(allocate("VSymTab"))                     \
S                const struct finsh_sysvar __vsym_##name =           \
S                {                           \
S                    __vsym_##name##_name,   \
S                    __vsym_##name##_desc,   \
S                    type,                   \
S                    (void*)&name            \
S                };
X            #define FINSH_VAR_EXPORT(name, type, desc)                              const char __vsym_##name##_name[] = #name;                          const char __vsym_##name##_desc[] = #desc;                          __declspec(allocate("VSymTab"))                                     const struct finsh_sysvar __vsym_##name =                           {                                               __vsym_##name##_name,                       __vsym_##name##_desc,                       type,                                       (void*)&name                            };
S
S        #elif defined(__TI_COMPILER_VERSION__)
X        #elif 0L
S            #define FINSH_FUNCTION_EXPORT_CMD(name, cmd, desc)      \
S                __TI_FINSH_EXPORT_FUNCTION(__fsym_##cmd);           \
S                const char __fsym_##cmd##_name[] = #cmd;            \
S                const char __fsym_##cmd##_desc[] = #desc;           \
S                const struct finsh_syscall __fsym_##cmd =           \
S                {                           \
S                    __fsym_##cmd##_name,    \
S                    __fsym_##cmd##_desc,    \
S                    (syscall_func)&name     \
S                };
X            #define FINSH_FUNCTION_EXPORT_CMD(name, cmd, desc)                      __TI_FINSH_EXPORT_FUNCTION(__fsym_##cmd);                           const char __fsym_##cmd##_name[] = #cmd;                            const char __fsym_##cmd##_desc[] = #desc;                           const struct finsh_syscall __fsym_##cmd =                           {                                               __fsym_##cmd##_name,                        __fsym_##cmd##_desc,                        (syscall_func)&name                     };
S
S            #define FINSH_VAR_EXPORT(name, type, desc)              \
S                __TI_FINSH_EXPORT_VAR(__vsym_##name);               \
S                const char __vsym_##name##_name[] = #name;          \
S                const char __vsym_##name##_desc[] = #desc;          \
S                const struct finsh_sysvar __vsym_##name =           \
S                {                           \
S                    __vsym_##name##_name,   \
S                    __vsym_##name##_desc,   \
S                    type,                   \
S                    (void*)&name            \
S                };
X            #define FINSH_VAR_EXPORT(name, type, desc)                              __TI_FINSH_EXPORT_VAR(__vsym_##name);                               const char __vsym_##name##_name[] = #name;                          const char __vsym_##name##_desc[] = #desc;                          const struct finsh_sysvar __vsym_##name =                           {                                               __vsym_##name##_name,                       __vsym_##name##_desc,                       type,                                       (void*)&name                            };
S            
N        #else
N            #define FINSH_FUNCTION_EXPORT_CMD(name, cmd, desc)      \
N                const char __fsym_##cmd##_name[] SECTION(".rodata.name") = #cmd;   \
N                const char __fsym_##cmd##_desc[] SECTION(".rodata.name") = #desc;  \
N                const struct finsh_syscall __fsym_##cmd SECTION("FSymTab")= \
N                {                           \
N                    __fsym_##cmd##_name,    \
N                    __fsym_##cmd##_desc,    \
N                    (syscall_func)&name     \
N                };
X            #define FINSH_FUNCTION_EXPORT_CMD(name, cmd, desc)                      const char __fsym_##cmd##_name[] SECTION(".rodata.name") = #cmd;                   const char __fsym_##cmd##_desc[] SECTION(".rodata.name") = #desc;                  const struct finsh_syscall __fsym_##cmd SECTION("FSymTab")=                 {                                               __fsym_##cmd##_name,                        __fsym_##cmd##_desc,                        (syscall_func)&name                     };
N
N            #define FINSH_VAR_EXPORT(name, type, desc)              \
N                const char __vsym_##name##_name[] SECTION(".rodata.name") = #name; \
N                const char __vsym_##name##_desc[] SECTION(".rodata.name") = #desc; \
N                const struct finsh_sysvar __vsym_##name SECTION("VSymTab")= \
N                {                           \
N                    __vsym_##name##_name,   \
N                    __vsym_##name##_desc,   \
N                    type,                   \
N                    (void*)&name            \
N                };
X            #define FINSH_VAR_EXPORT(name, type, desc)                              const char __vsym_##name##_name[] SECTION(".rodata.name") = #name;                 const char __vsym_##name##_desc[] SECTION(".rodata.name") = #desc;                 const struct finsh_sysvar __vsym_##name SECTION("VSymTab")=                 {                                               __vsym_##name##_name,                       __vsym_##name##_desc,                       type,                                       (void*)&name                            };
N
N        #endif
N    #else
S        #ifdef _MSC_VER
S            #define FINSH_FUNCTION_EXPORT_CMD(name, cmd, desc)      \
S                const char __fsym_##cmd##_name[] = #cmd;            \
S                __declspec(allocate("FSymTab$f"))                   \
S                const struct finsh_syscall __fsym_##cmd =           \
S                {                           \
S                    __fsym_##cmd##_name,    \
S                    (syscall_func)&name     \
S                };
X            #define FINSH_FUNCTION_EXPORT_CMD(name, cmd, desc)                      const char __fsym_##cmd##_name[] = #cmd;                            __declspec(allocate("FSymTab$f"))                                   const struct finsh_syscall __fsym_##cmd =                           {                                               __fsym_##cmd##_name,                        (syscall_func)&name                     };
S            #pragma comment(linker, "/merge:FSymTab=mytext")
S
S            #define FINSH_VAR_EXPORT(name, type, desc)              \
S                const char __vsym_##name##_name[] = #name;          \
S                __declspec(allocate("VSymTab")) const struct finsh_sysvar __vsym_##name = \
S                {                           \
S                    __vsym_##name##_name,   \
S                    type,                   \
S                    (void*)&name            \
S                };
X            #define FINSH_VAR_EXPORT(name, type, desc)                              const char __vsym_##name##_name[] = #name;                          __declspec(allocate("VSymTab")) const struct finsh_sysvar __vsym_##name =                 {                                               __vsym_##name##_name,                       type,                                       (void*)&name                            };
S
S        #elif defined(__TI_COMPILER_VERSION__)
S            #define FINSH_FUNCTION_EXPORT_CMD(name, cmd, desc)      \
S                __TI_FINSH_EXPORT_FUNCTION(__fsym_##cmd);           \
S                const char __fsym_##cmd##_name[] = #cmd;            \
S                const struct finsh_syscall __fsym_##cmd =           \
S                {                           \
S                    __fsym_##cmd##_name,    \
S                    (syscall_func)&name     \
S                };
X            #define FINSH_FUNCTION_EXPORT_CMD(name, cmd, desc)                      __TI_FINSH_EXPORT_FUNCTION(__fsym_##cmd);                           const char __fsym_##cmd##_name[] = #cmd;                            const struct finsh_syscall __fsym_##cmd =                           {                                               __fsym_##cmd##_name,                        (syscall_func)&name                     };
S
S            #define FINSH_VAR_EXPORT(name, type, desc)              \
S                __TI_FINSH_EXPORT_VAR(__vsym_##name);               \
S                const char __vsym_##name##_name[] = #name;          \
S                const struct finsh_sysvar __vsym_##name =           \
S                {                           \
S                    __vsym_##name##_name,   \
S                    type,                   \
S                    (void*)&name            \
S                };
X            #define FINSH_VAR_EXPORT(name, type, desc)                              __TI_FINSH_EXPORT_VAR(__vsym_##name);                               const char __vsym_##name##_name[] = #name;                          const struct finsh_sysvar __vsym_##name =                           {                                               __vsym_##name##_name,                       type,                                       (void*)&name                            };
S            
S        #else
S            #define FINSH_FUNCTION_EXPORT_CMD(name, cmd, desc)      \
S                const char __fsym_##cmd##_name[] = #cmd;            \
S                const struct finsh_syscall __fsym_##cmd SECTION("FSymTab")= \
S                {                           \
S                    __fsym_##cmd##_name,    \
S                    (syscall_func)&name     \
S                };
X            #define FINSH_FUNCTION_EXPORT_CMD(name, cmd, desc)                      const char __fsym_##cmd##_name[] = #cmd;                            const struct finsh_syscall __fsym_##cmd SECTION("FSymTab")=                 {                                               __fsym_##cmd##_name,                        (syscall_func)&name                     };
S
S            #define FINSH_VAR_EXPORT(name, type, desc)              \
S                const char __vsym_##name##_name[] = #name;          \
S                const struct finsh_sysvar __vsym_##name SECTION("VSymTab")= \
S                {                           \
S                    __vsym_##name##_name,   \
S                    type,                   \
S                    (void*)&name            \
S                };
X            #define FINSH_VAR_EXPORT(name, type, desc)                              const char __vsym_##name##_name[] = #name;                          const struct finsh_sysvar __vsym_##name SECTION("VSymTab")=                 {                                               __vsym_##name##_name,                       type,                                       (void*)&name                            };
S
S        #endif  
N    #endif /* end of FINSH_USING_DESCRIPTION */
N#endif /* end of FINSH_USING_SYMTAB */
N
N/**
N * @ingroup finsh
N *
N * This macro exports a system function to finsh shell.
N *
N * @param name the name of function.
N * @param desc the description of function, which will show in help.
N */
N#define FINSH_FUNCTION_EXPORT(name, desc)   \
N    FINSH_FUNCTION_EXPORT_CMD(name, name, desc)
X#define FINSH_FUNCTION_EXPORT(name, desc)       FINSH_FUNCTION_EXPORT_CMD(name, name, desc)
N
N/**
N * @ingroup finsh
N *
N * This macro exports a system function with an alias name to finsh shell.
N *
N * @param name the name of function.
N * @param alias the alias name of function.
N * @param desc the description of function, which will show in help.
N */
N#define FINSH_FUNCTION_EXPORT_ALIAS(name, alias, desc)  \
N        FINSH_FUNCTION_EXPORT_CMD(name, alias, desc)
X#define FINSH_FUNCTION_EXPORT_ALIAS(name, alias, desc)          FINSH_FUNCTION_EXPORT_CMD(name, alias, desc)
N
N/**
N * @ingroup finsh
N *
N * This macro exports a command to module shell.
N *
N * @param command the name of command.
N * @param desc the description of command, which will show in help.
N */
N#ifdef FINSH_USING_MSH
S#define MSH_CMD_EXPORT(command, desc)   \
S    FINSH_FUNCTION_EXPORT_CMD(command, __cmd_##command, desc)
X#define MSH_CMD_EXPORT(command, desc)       FINSH_FUNCTION_EXPORT_CMD(command, __cmd_##command, desc)
S#define MSH_CMD_EXPORT_ALIAS(command, alias, desc)  \
S    FINSH_FUNCTION_EXPORT_ALIAS(command, __cmd_##alias, desc)
X#define MSH_CMD_EXPORT_ALIAS(command, alias, desc)      FINSH_FUNCTION_EXPORT_ALIAS(command, __cmd_##alias, desc)
N#else
N#define MSH_CMD_EXPORT(command, desc)
N#define MSH_CMD_EXPORT_ALIAS(command, alias, desc)
N#endif
N
Nstruct finsh_token
N{
N	char eof;
N	char replay;
N
N	int  position;
N	u_char current_token;
N
N	union {
N		char char_value;
N		int int_value;
N		long long_value;
N	} value;
N	u_char string[FINSH_STRING_MAX];
X	u_char string[128];
N
N	u_char* line;
N};
N
N#define FINSH_IDTYPE_VAR		0x01
N#define FINSH_IDTYPE_SYSVAR		0x02
N#define FINSH_IDTYPE_SYSCALL	0x04
N#define FINSH_IDTYPE_ADDRESS	0x08
Nstruct finsh_node
N{
N	u_char node_type;	/* node node_type */
N	u_char data_type;	/* node data node_type */
N	u_char idtype;		/* id node information */
N
N	union {			/* value node */
N		char 	char_value;
N		short 	short_value;
N		int 	int_value;
N		long 	long_value;
N		void* 	ptr;
N	} value;
N	union
N	{
N		/* point to variable identifier or function identifier */
N		struct finsh_var	*var;
N		struct finsh_sysvar	*sysvar;
N		struct finsh_syscall*syscall;
N	}id;
N
N	/* sibling and child node */
N	struct finsh_node *sibling, *child;
N};
N
Nstruct finsh_parser
N{
N	u_char* parser_string;
N
N    struct finsh_token token;
N	struct finsh_node* root;
N};
N
N/**
N * @ingroup finsh
N *
N * The basic data type in finsh shell
N */
Nenum finsh_type {
N	finsh_type_unknown = 0, /**< unknown data type */
N	finsh_type_void,		/**< void  			*/
N	finsh_type_voidp,		/**< void pointer  	*/
N	finsh_type_char,		/**< char  			*/
N	finsh_type_uchar,		/**< unsigned char  */
N	finsh_type_charp,		/**< char pointer  	*/
N	finsh_type_short,		/**< short  		*/
N	finsh_type_ushort,		/**< unsigned short */
N	finsh_type_shortp,		/**< short pointer  */
N	finsh_type_int,			/**< int 			*/
N	finsh_type_uint,		/**< unsigned int 	*/
N	finsh_type_intp,		/**< int pointer 	*/
N	finsh_type_long,		/**< long 			*/
N	finsh_type_ulong,		/**< unsigned long 	*/
N	finsh_type_longp		/**< long pointer 	*/
N};
N
N/* init finsh environment */
Nint finsh_init(struct finsh_parser* parser);
N/* flush finsh node, text segment */
Nint finsh_flush(struct finsh_parser* parser);
N/* reset all of finsh */
Nint finsh_reset(struct finsh_parser* parser);
N#ifdef RT_USING_DEVICE
Nvoid finsh_set_device(const char* device_name);
N#endif
N
N/* run finsh parser to generate abstract synatx tree */
Nvoid finsh_parser_run (struct finsh_parser* parser, const unsigned char* string);
N/* run compiler to compile abstract syntax tree */
Nint finsh_compiler_run(struct finsh_node* node);
N/* run finsh virtual machine */
Nvoid finsh_vm_run(void);
N
N/* get variable value */
Nstruct finsh_var* finsh_var_lookup(const char* name);
N/* get bottom value of stack */
Nlong finsh_stack_bottom(void);
N
N/* get error number of finsh */
Nu_char finsh_errno(void);
N/* get error string */
Nconst char* finsh_error_string(u_char type);
N
N#ifdef RT_USING_HEAP
N/**
N * @ingroup finsh
N *
N * This function appends a system call to finsh runtime environment
N * @param name the name of system call
N * @param func the function pointer of system call
N */
Nvoid finsh_syscall_append(const char* name, syscall_func func);
N
N/**
N * @ingroup finsh
N *
N * This function appends a system variable to finsh runtime environment
N * @param name the name of system variable
N * @param type the data type of system variable
N * @param addr the address of system variable
N */
Nvoid finsh_sysvar_append(const char* name, u_char type, void* addr);
N#endif
N#endif
L 38 "..\..\src\module.c" 2
N#endif
N
N#ifdef RT_USING_MODULE
S#include "module.h"
S
S#define elf_module        ((Elf32_Ehdr *)module_ptr)
S#define shdr              ((Elf32_Shdr *)((rt_uint8_t *)module_ptr + elf_module->e_shoff))
S#define phdr              ((Elf32_Phdr *)((rt_uint8_t *)module_ptr + elf_module->e_phoff))
S
S#define IS_PROG(s)        (s.sh_type == SHT_PROGBITS)
S#define IS_NOPROG(s)      (s.sh_type == SHT_NOBITS)
S#define IS_REL(s)         (s.sh_type == SHT_REL)
S#define IS_RELA(s)        (s.sh_type == SHT_RELA)
S#define IS_ALLOC(s)       (s.sh_flags == SHF_ALLOC)
S#define IS_AX(s)          ((s.sh_flags & SHF_ALLOC) && (s.sh_flags & SHF_EXECINSTR))
S#define IS_AW(s)          ((s.sh_flags & SHF_ALLOC) && (s.sh_flags & SHF_WRITE))
S
S#ifdef RT_USING_MODULE_STKSZ
S#undef RT_USING_MODULE_STKSZ
S#endif
S
S#ifndef RT_USING_MODULE_STKSZ
S#define RT_USING_MODULE_STKSZ (4096 * 2)
S#endif
S
S#ifndef RT_USING_MODULE_PRIO
S#define RT_USING_MODULE_PRIO (RT_THREAD_PRIORITY_MAX - 2)
S#endif
S
S#ifdef RT_USING_SLAB
S#define PAGE_COUNT_MAX    256
S
S/* module memory allocator */
Sstruct rt_mem_head
S{
S    rt_size_t size;                /* size of memory block */
S    struct rt_mem_head *next;      /* next valid memory block */
S};
S
Sstruct rt_page_info
S{
S    rt_uint32_t *page_ptr;
S    rt_uint32_t npage;
S};
S
Sstatic void *rt_module_malloc_page(rt_size_t npages);
Sstatic void rt_module_free_page(rt_module_t module,
S                                void       *page_ptr,
S                                rt_size_t   npages);
S
Sstatic struct rt_semaphore mod_sem;
S#endif
S
Sstatic struct rt_module_symtab *_rt_module_symtab_begin = RT_NULL;
Sstatic struct rt_module_symtab *_rt_module_symtab_end   = RT_NULL;
S
S#if defined(__IAR_SYSTEMS_ICC__) /* for IAR compiler */
S    #pragma section="RTMSymTab"
S#endif
S
S/**
S * @ingroup SystemInit
S *
S * This function will initialize system module
S */
Sint rt_system_module_init(void)
S{
S#if defined(__GNUC__) && !defined(__CC_ARM)
S    extern int __rtmsymtab_start;
S    extern int __rtmsymtab_end;
S
S    _rt_module_symtab_begin = (struct rt_module_symtab *)&__rtmsymtab_start;
S    _rt_module_symtab_end   = (struct rt_module_symtab *)&__rtmsymtab_end;
S#elif defined (__CC_ARM)
S    extern int RTMSymTab$$Base;
S    extern int RTMSymTab$$Limit;
S
S    _rt_module_symtab_begin = (struct rt_module_symtab *)&RTMSymTab$$Base;
S    _rt_module_symtab_end   = (struct rt_module_symtab *)&RTMSymTab$$Limit;
S#elif defined (__IAR_SYSTEMS_ICC__)
S    _rt_module_symtab_begin = __section_begin("RTMSymTab");
S    _rt_module_symtab_end   = __section_begin("RTMSymTab");
S#endif
S
S#ifdef RT_USING_SLAB
S    /* initialize heap semaphore */
S    rt_sem_init(&mod_sem, "module", 1, RT_IPC_FLAG_FIFO);
S#endif
S    return 0;
S}
SINIT_COMPONENT_EXPORT(rt_system_module_init);
S
S#ifdef RT_USING_FINSH
Svoid list_symbol(void)
S{
S    /* find in kernel symbol table */
S    struct rt_module_symtab *index;
S
S    for (index = _rt_module_symtab_begin;
S         index != _rt_module_symtab_end;
S         index ++)
S    {
S    	rt_kprintf("%s\n", index->name);
S    }
S
S    return ;
S}
SFINSH_FUNCTION_EXPORT(list_symbol, list symbol for module);
SMSH_CMD_EXPORT(list_symbol, list symbol for module);
S#endif
S
Sstatic rt_uint32_t rt_module_symbol_find(const char *sym_str)
S{
S    /* find in kernel symbol table */
S    struct rt_module_symtab *index;
S
S    for (index = _rt_module_symtab_begin;
S         index != _rt_module_symtab_end;
S         index ++)
S    {
S        if (rt_strcmp(index->name, sym_str) == 0)
S            return (rt_uint32_t)index->addr;
S    }
S
S    return 0;
S}
S
S/**
S * This function will return self module object
S *
S * @return the self module object
S */
Srt_module_t rt_module_self(void)
S{
S    rt_thread_t tid;
S
S    tid = rt_thread_self();
S    if (tid == RT_NULL)
S        return RT_NULL;
S
S    /* return current module */
S    return (rt_module_t)tid->module_id;
S}
SRTM_EXPORT(rt_module_self);
S
Sstatic int rt_module_arm_relocate(struct rt_module *module,
S                                  Elf32_Rel        *rel,
S                                  Elf32_Addr        sym_val)
S{
S    Elf32_Addr *where, tmp;
S    Elf32_Sword addend, offset;
S    rt_uint32_t upper, lower, sign, j1, j2;
S
S    where = (Elf32_Addr *)((rt_uint8_t *)module->module_space
S                           + rel->r_offset
S                           - module->vstart_addr);
S    switch (ELF32_R_TYPE(rel->r_info))
S    {
S    case R_ARM_NONE:
S        break;
S    case R_ARM_ABS32:
S        *where += (Elf32_Addr)sym_val;
S        RT_DEBUG_LOG(RT_DEBUG_MODULE, ("R_ARM_ABS32: %x -> %x\n",
S                                       where, *where));
S        break;
S    case R_ARM_PC24:
S    case R_ARM_PLT32:
S    case R_ARM_CALL:
S    case R_ARM_JUMP24:
S        addend = *where & 0x00ffffff;
S        if (addend & 0x00800000)
S            addend |= 0xff000000;
S        tmp = sym_val - (Elf32_Addr)where + (addend << 2);
S        tmp >>= 2;
S        *where = (*where & 0xff000000) | (tmp & 0x00ffffff);
S        RT_DEBUG_LOG(RT_DEBUG_MODULE, ("R_ARM_PC24: %x -> %x\n",
S                                       where, *where));
S        break;
S    case R_ARM_REL32:
S        *where += sym_val - (Elf32_Addr)where;
S        RT_DEBUG_LOG(RT_DEBUG_MODULE,
S                     ("R_ARM_REL32: %x -> %x, sym %x, offset %x\n",
S                      where, *where, sym_val, rel->r_offset));
S        break;
S    case R_ARM_V4BX:
S        *where &= 0xf000000f;
S        *where |= 0x01a0f000;
S        break;
S    case R_ARM_GLOB_DAT:
S    case R_ARM_JUMP_SLOT:
S        *where = (Elf32_Addr)sym_val;
S        RT_DEBUG_LOG(RT_DEBUG_MODULE, ("R_ARM_JUMP_SLOT: 0x%x -> 0x%x 0x%x\n",
S                                       where, *where, sym_val));
S        break;
S#if 0        /* To do */
S    case R_ARM_GOT_BREL:
S        temp   = (Elf32_Addr)sym_val;
S        *where = (Elf32_Addr)&temp;
S        RT_DEBUG_LOG(RT_DEBUG_MODULE, ("R_ARM_GOT_BREL: 0x%x -> 0x%x 0x%x\n",
S                                       where, *where, sym_val));
S        break;
S#endif
S    case R_ARM_RELATIVE:
S        *where = (Elf32_Addr)sym_val + *where;
S        RT_DEBUG_LOG(RT_DEBUG_MODULE, ("R_ARM_RELATIVE: 0x%x -> 0x%x 0x%x\n",
S                                       where, *where, sym_val));
S        break;
S    case R_ARM_THM_CALL:
S    case R_ARM_THM_JUMP24:
S        upper  = *(rt_uint16_t *)where;
S        lower  = *(rt_uint16_t *)((Elf32_Addr)where + 2);
S
S        sign   = (upper >> 10) & 1;
S        j1     = (lower >> 13) & 1;
S        j2     = (lower >> 11) & 1;
S        offset = (sign << 24) |
S            ((~(j1 ^ sign) & 1) << 23) |
S            ((~(j2 ^ sign) & 1) << 22) |
S            ((upper & 0x03ff) << 12) |
S            ((lower & 0x07ff) << 1);
S        if (offset & 0x01000000)
S            offset -= 0x02000000;
S        offset += sym_val - (Elf32_Addr)where;
S
S        if (!(offset & 1) ||
S            offset <= (rt_int32_t)0xff000000 ||
S            offset >= (rt_int32_t)0x01000000)
S        {
S            rt_kprintf("Module: Only Thumb addresses allowed\n");
S
S            return -1;
S        }
S
S        sign = (offset >> 24) & 1;
S        j1   = sign ^ (~(offset >> 23) & 1);
S        j2   = sign ^ (~(offset >> 22) & 1);
S        *(rt_uint16_t *)where = (rt_uint16_t)((upper & 0xf800) |
S                                              (sign << 10) |
S                                              ((offset >> 12) & 0x03ff));
S        *(rt_uint16_t *)(where + 2) = (rt_uint16_t)((lower & 0xd000) |
S                                                    (j1 << 13) | (j2 << 11) |
S                                                    ((offset >> 1) & 0x07ff));
S        upper = *(rt_uint16_t *)where;
S        lower = *(rt_uint16_t *)((Elf32_Addr)where + 2);
S        break;
S    default:
S        return -1;
S    }
S
S    return 0;
S}
S
Svoid rt_module_init_object_container(struct rt_module *module)
S{
S    RT_ASSERT(module != RT_NULL);
S
S    /* initialize object container - thread */
S    rt_list_init(&(module->module_object[RT_Object_Class_Thread].object_list));
S    module->module_object[RT_Object_Class_Thread].object_size = sizeof(struct rt_thread);
S    module->module_object[RT_Object_Class_Thread].type = RT_Object_Class_Thread;
S
S#ifdef RT_USING_SEMAPHORE
S    /* initialize object container - semaphore */
S    rt_list_init(&(module->module_object[RT_Object_Class_Semaphore].object_list));
S    module->module_object[RT_Object_Class_Semaphore].object_size = sizeof(struct rt_semaphore);
S    module->module_object[RT_Object_Class_Semaphore].type = RT_Object_Class_Semaphore;
S#endif
S
S#ifdef RT_USING_MUTEX
S    /* initialize object container - mutex */
S    rt_list_init(&(module->module_object[RT_Object_Class_Mutex].object_list));
S    module->module_object[RT_Object_Class_Mutex].object_size = sizeof(struct rt_mutex);
S    module->module_object[RT_Object_Class_Mutex].type = RT_Object_Class_Mutex;
S#endif
S
S#ifdef RT_USING_EVENT
S    /* initialize object container - event */
S    rt_list_init(&(module->module_object[RT_Object_Class_Event].object_list));
S    module->module_object[RT_Object_Class_Event].object_size = sizeof(struct rt_event);
S    module->module_object[RT_Object_Class_Event].type = RT_Object_Class_Event;
S#endif
S
S#ifdef RT_USING_MAILBOX
S    /* initialize object container - mailbox */
S    rt_list_init(&(module->module_object[RT_Object_Class_MailBox].object_list));
S    module->module_object[RT_Object_Class_MailBox].object_size = sizeof(struct rt_mailbox);
S    module->module_object[RT_Object_Class_MailBox].type = RT_Object_Class_MailBox;
S#endif
S
S#ifdef RT_USING_MESSAGEQUEUE
S    /* initialize object container - message queue */
S    rt_list_init(&(module->module_object[RT_Object_Class_MessageQueue].object_list));
S    module->module_object[RT_Object_Class_MessageQueue].object_size = sizeof(struct rt_messagequeue);
S    module->module_object[RT_Object_Class_MessageQueue].type = RT_Object_Class_MessageQueue;
S#endif
S
S#ifdef RT_USING_MEMHEAP
S    /* initialize object container - memory heap */
S    rt_list_init(&(module->module_object[RT_Object_Class_MemHeap].object_list));
S    module->module_object[RT_Object_Class_MemHeap].object_size = sizeof(struct rt_memheap);
S    module->module_object[RT_Object_Class_MemHeap].type = RT_Object_Class_MemHeap;
S#endif
S
S#ifdef RT_USING_MEMPOOL
S    /* initialize object container - memory pool */
S    rt_list_init(&(module->module_object[RT_Object_Class_MemPool].object_list));
S    module->module_object[RT_Object_Class_MemPool].object_size = sizeof(struct rt_mempool);
S    module->module_object[RT_Object_Class_MemPool].type = RT_Object_Class_MemPool;
S#endif
S
S#ifdef RT_USING_DEVICE
S    /* initialize object container - device */
S    rt_list_init(&(module->module_object[RT_Object_Class_Device].object_list));
S    module->module_object[RT_Object_Class_Device].object_size = sizeof(struct rt_device);
S    module->module_object[RT_Object_Class_Device].type = RT_Object_Class_Device;
S#endif
S
S    /* initialize object container - timer */
S    rt_list_init(&(module->module_object[RT_Object_Class_Timer].object_list));
S    module->module_object[RT_Object_Class_Timer].object_size = sizeof(struct rt_timer);
S    module->module_object[RT_Object_Class_Timer].type = RT_Object_Class_Timer;
S}
S
S#ifdef RT_USING_HOOK
Sstatic void (*rt_module_load_hook)(rt_module_t module);
Sstatic void (*rt_module_unload_hook)(rt_module_t module);
S
S/**
S * @addtogroup Hook
S */
S
S/**@{*/
S
S/**
S * This function will set a hook function, which will be invoked when module
S * be loaded to system.
S *
S * @param hook the hook function
S */
Svoid rt_module_load_sethook(void (*hook)(rt_module_t module))
S{
S    rt_module_load_hook = hook;
S}
S
S/**
S * This function will set a hook function, which will be invoked when module
S * be unloaded from system.
S *
S * @param hook the hook function
S */
Svoid rt_module_unload_sethook(void (*hook)(rt_module_t module))
S{
S    rt_module_unload_hook = hook;
S}
S
S/**@}*/
S#endif
S
Sstatic struct rt_module *_load_shared_object(const char *name,
S                                             void       *module_ptr)
S{
S    rt_module_t module = RT_NULL;
S    rt_bool_t linked   = RT_FALSE;
S    rt_uint32_t index, module_size = 0;
S    Elf32_Addr vstart_addr, vend_addr;
S    rt_bool_t has_vstart;
S
S    RT_ASSERT(module_ptr != RT_NULL);
S
S    if (rt_memcmp(elf_module->e_ident, RTMMAG, SELFMAG) == 0)
S    {
S        /* rtmlinker finished */
S        linked = RT_TRUE;
S    }
S
S    /* get the ELF image size */
S    has_vstart = RT_FALSE;
S    vstart_addr = vend_addr = RT_NULL;
S    for (index = 0; index < elf_module->e_phnum; index++)
S    {
S        if (phdr[index].p_type != PT_LOAD)
S            continue;
S
S        RT_DEBUG_LOG(RT_DEBUG_MODULE, ("LOAD segment: %d, 0x%p, 0x%08x\n",
S                                       index, phdr[index].p_vaddr, phdr[index].p_memsz));
S
S        if (phdr[index].p_memsz < phdr[index].p_filesz)
S        {
S            rt_kprintf("invalid elf: segment %d: p_memsz: %d, p_filesz: %d\n",
S                       index, phdr[index].p_memsz, phdr[index].p_filesz);
S            return RT_NULL;
S        }
S        if (!has_vstart)
S        {
S            vstart_addr = phdr[index].p_vaddr;
S            vend_addr = phdr[index].p_vaddr + phdr[index].p_memsz;
S            has_vstart = RT_TRUE;
S            if (vend_addr < vstart_addr)
S            {
S                rt_kprintf("invalid elf: segment %d: p_vaddr: %d, p_memsz: %d\n",
S                           index, phdr[index].p_vaddr, phdr[index].p_memsz);
S                return RT_NULL;
S            }
S        }
S        else
S        {
S            if (phdr[index].p_vaddr < vend_addr)
S            {
S                rt_kprintf("invalid elf: segment should be sorted and not overlapped\n");
S                return RT_NULL;
S            }
S            if (phdr[index].p_vaddr > vend_addr + 16)
S            {
S                /* There should not be too much padding in the object files. */
S                rt_kprintf("warning: too much padding before segment %d\n", index);
S            }
S
S            vend_addr = phdr[index].p_vaddr + phdr[index].p_memsz;
S            if (vend_addr < phdr[index].p_vaddr)
S            {
S                rt_kprintf("invalid elf: "
S                           "segment %d address overflow\n", index);
S                return RT_NULL;
S            }
S        }
S    }
S
S    module_size = vend_addr - vstart_addr;
S
S    RT_DEBUG_LOG(RT_DEBUG_MODULE, ("module size: %d, vstart_addr: 0x%p\n",
S                                   module_size, vstart_addr));
S
S    if (module_size == 0)
S    {
S        rt_kprintf("Module: size error\n");
S
S        return RT_NULL;
S    }
S
S    /* allocate module */
S    module = (struct rt_module *)rt_object_allocate(RT_Object_Class_Module,
S                                                    name);
S    if (!module)
S        return RT_NULL;
S
S    module->vstart_addr = vstart_addr;
S
S    module->nref = 0;
S
S    /* allocate module space */
S    module->module_space = rt_malloc(module_size);
S    if (module->module_space == RT_NULL)
S    {
S        rt_kprintf("Module: allocate space failed.\n");
S        rt_object_delete(&(module->parent));
S
S        return RT_NULL;
S    }
S
S    /* zero all space */
S    rt_memset(module->module_space, 0, module_size);
S
S    for (index = 0; index < elf_module->e_phnum; index++)
S    {
S        if (phdr[index].p_type == PT_LOAD)
S        {
S            rt_memcpy(module->module_space + phdr[index].p_vaddr - vstart_addr,
S                      (rt_uint8_t *)elf_module + phdr[index].p_offset,
S                      phdr[index].p_filesz);
S        }
S    }
S
S    /* set module entry */
S    module->module_entry = module->module_space
S        + elf_module->e_entry - vstart_addr;
S
S    /* handle relocation section */
S    for (index = 0; index < elf_module->e_shnum; index ++)
S    {
S        rt_uint32_t i, nr_reloc;
S        Elf32_Sym *symtab;
S        Elf32_Rel *rel;
S        rt_uint8_t *strtab;
S        static rt_bool_t unsolved = RT_FALSE;
S
S        if (!IS_REL(shdr[index]))
S            continue;
S
S        /* get relocate item */
S        rel = (Elf32_Rel *)((rt_uint8_t *)module_ptr + shdr[index].sh_offset);
S
S        /* locate .rel.plt and .rel.dyn section */
S        symtab = (Elf32_Sym *)((rt_uint8_t *)module_ptr +
S                               shdr[shdr[index].sh_link].sh_offset);
S        strtab = (rt_uint8_t *)module_ptr +
S            shdr[shdr[shdr[index].sh_link].sh_link].sh_offset;
S        nr_reloc = (rt_uint32_t)(shdr[index].sh_size / sizeof(Elf32_Rel));
S
S        /* relocate every items */
S        for (i = 0; i < nr_reloc; i ++)
S        {
S            Elf32_Sym *sym = &symtab[ELF32_R_SYM(rel->r_info)];
S
S            RT_DEBUG_LOG(RT_DEBUG_MODULE, ("relocate symbol %s shndx %d\n",
S                                           strtab + sym->st_name,
S                                           sym->st_shndx));
S
S            if ((sym->st_shndx != SHT_NULL) ||
S                (ELF_ST_BIND(sym->st_info) == STB_LOCAL))
S            {
S                rt_module_arm_relocate(module, rel,
S                                       (Elf32_Addr)(module->module_space
S                                                    + sym->st_value
S                                                    - vstart_addr));
S            }
S            else if (!linked)
S            {
S                Elf32_Addr addr;
S
S                RT_DEBUG_LOG(RT_DEBUG_MODULE, ("relocate symbol: %s\n",
S                                               strtab + sym->st_name));
S
S                /* need to resolve symbol in kernel symbol table */
S                addr = rt_module_symbol_find((const char *)(strtab + sym->st_name));
S                if (addr == 0)
S                {
S                    rt_kprintf("Module: can't find %s in kernel symbol table\n",
S                               strtab + sym->st_name);
S                    unsolved = RT_TRUE;
S                }
S                else
S                    rt_module_arm_relocate(module, rel, addr);
S            }
S            rel ++;
S        }
S
S        if (unsolved)
S        {
S            rt_object_delete(&(module->parent));
S
S            return RT_NULL;
S        }
S    }
S
S    /* construct module symbol table */
S    for (index = 0; index < elf_module->e_shnum; index ++)
S    {
S        /* find .dynsym section */
S        rt_uint8_t *shstrab;
S        shstrab = (rt_uint8_t *)module_ptr +
S            shdr[elf_module->e_shstrndx].sh_offset;
S        if (rt_strcmp((const char *)(shstrab + shdr[index].sh_name), ELF_DYNSYM) == 0)
S            break;
S    }
S
S    /* found .dynsym section */
S    if (index != elf_module->e_shnum)
S    {
S        int i, count = 0;
S        Elf32_Sym  *symtab = RT_NULL;
S        rt_uint8_t *strtab = RT_NULL;
S
S        symtab =(Elf32_Sym *)((rt_uint8_t *)module_ptr + shdr[index].sh_offset);
S        strtab = (rt_uint8_t *)module_ptr + shdr[shdr[index].sh_link].sh_offset;
S
S        for (i = 0; i < shdr[index].sh_size/sizeof(Elf32_Sym); i++)
S        {
S            if ((ELF_ST_BIND(symtab[i].st_info) == STB_GLOBAL) &&
S                (ELF_ST_TYPE(symtab[i].st_info) == STT_FUNC))
S                count ++;
S        }
S
S        module->symtab = (struct rt_module_symtab *)rt_malloc
S            (count * sizeof(struct rt_module_symtab));
S        module->nsym = count;
S        for (i = 0, count = 0; i < shdr[index].sh_size/sizeof(Elf32_Sym); i++)
S        {
S            rt_size_t length;
S
S            if ((ELF_ST_BIND(symtab[i].st_info) != STB_GLOBAL) ||
S                (ELF_ST_TYPE(symtab[i].st_info) != STT_FUNC))
S                continue;
S
S            length = rt_strlen((const char *)(strtab + symtab[i].st_name)) + 1;
S
S            module->symtab[count].addr =
S                (void *)(module->module_space + symtab[i].st_value);
S            module->symtab[count].name = rt_malloc(length);
S            rt_memset((void *)module->symtab[count].name, 0, length);
S            rt_memcpy((void *)module->symtab[count].name,
S                      strtab + symtab[i].st_name,
S                      length);
S            count ++;
S        }
S    }
S
S    return module;
S}
S
Sstatic struct rt_module* _load_relocated_object(const char *name,
S                                                void       *module_ptr)
S{
S    rt_uint32_t index, rodata_addr = 0, bss_addr = 0, data_addr = 0;
S    rt_uint32_t module_addr = 0, module_size = 0;
S    struct rt_module *module = RT_NULL;
S    rt_uint8_t *ptr, *strtab, *shstrab;
S
S    /* get the ELF image size */
S    for (index = 0; index < elf_module->e_shnum; index ++)
S    {
S        /* text */
S        if (IS_PROG(shdr[index]) && IS_AX(shdr[index]))
S        {
S            module_size += shdr[index].sh_size;
S            module_addr = shdr[index].sh_addr;
S        }
S        /* rodata */
S        if (IS_PROG(shdr[index]) && IS_ALLOC(shdr[index]))
S        {
S            module_size += shdr[index].sh_size;
S        }
S        /* data */
S        if (IS_PROG(shdr[index]) && IS_AW(shdr[index]))
S        {
S            module_size += shdr[index].sh_size;
S        }
S        /* bss */
S        if (IS_NOPROG(shdr[index]) && IS_AW(shdr[index]))
S        {
S            module_size += shdr[index].sh_size;
S        }
S    }
S
S    /* no text, data and bss on image */
S    if (module_size == 0)
S        return RT_NULL;
S
S    /* allocate module */
S    module = (struct rt_module *)
S        rt_object_allocate(RT_Object_Class_Module, (const char *)name);
S    if (module == RT_NULL)
S        return RT_NULL;
S
S    module->vstart_addr = 0;
S
S    /* allocate module space */
S    module->module_space = rt_malloc(module_size);
S    if (module->module_space == RT_NULL)
S    {
S        rt_kprintf("Module: allocate space failed.\n");
S        rt_object_delete(&(module->parent));
S
S        return RT_NULL;
S    }
S
S    /* zero all space */
S    ptr = module->module_space;
S    rt_memset(ptr, 0, module_size);
S
S    /* load text and data section */
S    for (index = 0; index < elf_module->e_shnum; index ++)
S    {
S        /* load text section */
S        if (IS_PROG(shdr[index]) && IS_AX(shdr[index]))
S        {
S            rt_memcpy(ptr,
S                      (rt_uint8_t *)elf_module + shdr[index].sh_offset,
S                      shdr[index].sh_size);
S            RT_DEBUG_LOG(RT_DEBUG_MODULE, ("load text 0x%x, size %d\n",
S                                           ptr, shdr[index].sh_size));
S            ptr += shdr[index].sh_size;
S        }
S
S        /* load rodata section */
S        if (IS_PROG(shdr[index]) && IS_ALLOC(shdr[index]))
S        {
S            rt_memcpy(ptr,
S                      (rt_uint8_t *)elf_module + shdr[index].sh_offset,
S                      shdr[index].sh_size);
S            rodata_addr = (rt_uint32_t)ptr;
S            RT_DEBUG_LOG(RT_DEBUG_MODULE,
S                         ("load rodata 0x%x, size %d, rodata 0x%x\n",
S                          ptr, shdr[index].sh_size, *(rt_uint32_t *)data_addr));
S            ptr += shdr[index].sh_size;
S        }
S
S        /* load data section */
S        if (IS_PROG(shdr[index]) && IS_AW(shdr[index]))
S        {
S            rt_memcpy(ptr,
S                      (rt_uint8_t *)elf_module + shdr[index].sh_offset,
S                      shdr[index].sh_size);
S            data_addr = (rt_uint32_t)ptr;
S            RT_DEBUG_LOG(RT_DEBUG_MODULE,
S                         ("load data 0x%x, size %d, data 0x%x\n",
S                          ptr, shdr[index].sh_size, *(rt_uint32_t *)data_addr));
S            ptr += shdr[index].sh_size;
S        }
S
S        /* load bss section */
S        if (IS_NOPROG(shdr[index]) && IS_AW(shdr[index]))
S        {
S            rt_memset(ptr, 0, shdr[index].sh_size);
S            bss_addr = (rt_uint32_t)ptr;
S            RT_DEBUG_LOG(RT_DEBUG_MODULE, ("load bss 0x%x, size %d,\n",
S                                           ptr, shdr[index].sh_size));
S        }
S    }
S
S    /* set module entry */
S    module->module_entry =
S        (rt_uint8_t *)module->module_space + elf_module->e_entry - module_addr;
S
S    /* handle relocation section */
S    for (index = 0; index < elf_module->e_shnum; index ++)
S    {
S        rt_uint32_t i, nr_reloc;
S        Elf32_Sym *symtab;
S        Elf32_Rel *rel;
S
S        if (!IS_REL(shdr[index]))
S            continue;
S
S        /* get relocate item */
S        rel = (Elf32_Rel *)((rt_uint8_t *)module_ptr + shdr[index].sh_offset);
S
S        /* locate .dynsym and .dynstr */
S        symtab   = (Elf32_Sym *)((rt_uint8_t *)module_ptr +
S                                 shdr[shdr[index].sh_link].sh_offset);
S        strtab   = (rt_uint8_t *)module_ptr +
S            shdr[shdr[shdr[index].sh_link].sh_link].sh_offset;
S        shstrab  = (rt_uint8_t *)module_ptr +
S            shdr[elf_module->e_shstrndx].sh_offset;
S        nr_reloc = (rt_uint32_t)(shdr[index].sh_size / sizeof(Elf32_Rel));
S
S        /* relocate every items */
S        for (i = 0; i < nr_reloc; i ++)
S        {
S            Elf32_Sym *sym = &symtab[ELF32_R_SYM(rel->r_info)];
S
S            RT_DEBUG_LOG(RT_DEBUG_MODULE, ("relocate symbol: %s\n",
S                                           strtab + sym->st_name));
S
S            if (sym->st_shndx != STN_UNDEF)
S            {
S                if ((ELF_ST_TYPE(sym->st_info) == STT_SECTION) ||
S                    (ELF_ST_TYPE(sym->st_info) == STT_OBJECT))
S                {
S                    if (rt_strncmp((const char *)(shstrab +
S                                                  shdr[sym->st_shndx].sh_name), ELF_RODATA, 8) == 0)
S                    {
S                        /* relocate rodata section */
S                        RT_DEBUG_LOG(RT_DEBUG_MODULE, ("rodata\n"));
S                        rt_module_arm_relocate(module, rel,
S                                               (Elf32_Addr)(rodata_addr + sym->st_value));
S                    }
S                    else if (rt_strncmp((const char*)
S                                        (shstrab + shdr[sym->st_shndx].sh_name), ELF_BSS, 5) == 0)
S                    {
S                        /* relocate bss section */
S                        RT_DEBUG_LOG(RT_DEBUG_MODULE, ("bss\n"));
S                        rt_module_arm_relocate(module, rel,
S                                               (Elf32_Addr)bss_addr + sym->st_value);
S                    }
S                    else if (rt_strncmp((const char *)(shstrab + shdr[sym->st_shndx].sh_name),
S                                        ELF_DATA, 6) == 0)
S                    {
S                        /* relocate data section */
S                        RT_DEBUG_LOG(RT_DEBUG_MODULE, ("data\n"));
S                        rt_module_arm_relocate(module, rel,
S                                               (Elf32_Addr)data_addr + sym->st_value);
S                    }
S                }
S            }
S            else if (ELF_ST_TYPE(sym->st_info) == STT_FUNC)
S            {
S                /* relocate function */
S                rt_module_arm_relocate(module, rel,
S                                       (Elf32_Addr)((rt_uint8_t *)
S                                                    module->module_space
S                                                    - module_addr
S                                                    + sym->st_value));
S            }
S            else
S            {
S                Elf32_Addr addr;
S
S                if (ELF32_R_TYPE(rel->r_info) != R_ARM_V4BX)
S                {
S                    RT_DEBUG_LOG(RT_DEBUG_MODULE, ("relocate symbol: %s\n",
S                                                   strtab + sym->st_name));
S
S                    /* need to resolve symbol in kernel symbol table */
S                    addr = rt_module_symbol_find((const char *)(strtab + sym->st_name));
S                    if (addr != (Elf32_Addr)RT_NULL)
S                    {
S                        rt_module_arm_relocate(module, rel, addr);
S                        RT_DEBUG_LOG(RT_DEBUG_MODULE, ("symbol addr 0x%x\n",
S                                                       addr));
S                    }
S                    else
S                        rt_kprintf("Module: can't find %s in kernel symbol table\n",
S                                   strtab + sym->st_name);
S                }
S                else
S                {
S                    rt_module_arm_relocate(module, rel,
S                                           (Elf32_Addr)((rt_uint8_t*)
S                                                        module->module_space
S                                                        - module_addr
S                                                        + sym->st_value));
S                }
S            }
S            rel ++;
S        }
S    }
S
S    return module;
S}
S
S#define RT_MODULE_ARG_MAX    8
Sstatic int _rt_module_split_arg(char* cmd, rt_size_t length, char* argv[])
S{
S    int argc = 0;
S    char *ptr = cmd;
S
S    while ((ptr - cmd) < length)
S    {
S        /* strip bank and tab */
S        while ((*ptr == ' ' || *ptr == '\t') && (ptr -cmd)< length)
S            *ptr++ = '\0';
S        /* check whether it's the end of line */
S        if ((ptr - cmd)>= length) break;
S
S        /* handle string with quote */
S        if (*ptr == '"')
S        {
S            argv[argc++] = ++ptr;
S
S            /* skip this string */
S            while (*ptr != '"' && (ptr-cmd) < length)
S                if (*ptr ++ == '\\')  ptr ++;
S            if ((ptr - cmd) >= length) break;
S
S            /* skip '"' */
S            *ptr ++ = '\0';
S        }
S        else
S        {
S            argv[argc++] = ptr;
S            while ((*ptr != ' ' && *ptr != '\t') && (ptr - cmd) < length)
S                ptr ++;
S        }
S
S        if (argc >= RT_MODULE_ARG_MAX) break;
S    }
S
S    return argc;
S}
S
S/* module main thread entry */
Sstatic void module_main_entry(void* parameter)
S{
S    int argc;
S    char *argv[RT_MODULE_ARG_MAX];
S    typedef int (*main_func_t)(int argc, char** argv);
S
S    rt_module_t module = (rt_module_t) parameter;
S    if (module == RT_NULL)
S        return;
S
S    if (module->module_cmd_line == RT_NULL && module->module_cmd_size != 0)
S        /* malloc for module_cmd_line failed. */
S        return;
S
S    /* FIXME: we should run some C++ initialize code before jump into the
S     * entry. */
S
S    if (module->module_cmd_line == RT_NULL)
S    {
S        RT_DEBUG_LOG(RT_DEBUG_MODULE, ("run bare entry: 0x%p\n",
S                                       module->module_entry));
S        ((main_func_t)module->module_entry)(0, RT_NULL);
S        return;
S    }
S
S    rt_memset(argv, 0x00, sizeof(argv));
S    argc = _rt_module_split_arg((char*)module->module_cmd_line,
S                                module->module_cmd_size, argv);
S    if (argc == 0)
S        return;
S
S    RT_DEBUG_LOG(RT_DEBUG_MODULE, ("run main entry: 0x%p with %s\n",
S                                   module->module_entry,
S                                   module->module_cmd_line));
S    /* do the main function */
S    ((main_func_t)module->module_entry)(argc, argv);
S    return;
S}
S
S/**
S * This function will load a module with a main function from memory and create a 
S * main thread for it
S *
S * @param name the name of module, which shall be unique
S * @param module_ptr the memory address of module image
S * @argc the count of argument
S * @argd the argument data, which should be a 
S *
S * @return the module object
S */
Srt_module_t rt_module_do_main(const char *name,
S                              void *module_ptr,
S                              const char* cmd_line,
S                              int line_size)
S{
S    rt_module_t module;
S
S    RT_DEBUG_NOT_IN_INTERRUPT;
S
S    RT_DEBUG_LOG(RT_DEBUG_MODULE, ("rt_module_load: %s\n", name));
S
S    /* check ELF header */
S    if (rt_memcmp(elf_module->e_ident, RTMMAG, SELFMAG) != 0 &&
S        rt_memcmp(elf_module->e_ident, ELFMAG, SELFMAG) != 0)
S    {
S        rt_kprintf("Module: magic error\n");
S
S        return RT_NULL;
S    }
S
S    /* check ELF class */
S    if (elf_module->e_ident[EI_CLASS] != ELFCLASS32)
S    {
S        rt_kprintf("Module: ELF class error\n");
S
S        return RT_NULL;
S    }
S
S    if (elf_module->e_type == ET_REL)
S    {
S        module = _load_relocated_object(name, module_ptr);
S    }
S    else if (elf_module->e_type == ET_DYN)
S    {
S        module = _load_shared_object(name, module_ptr);
S    }
S    else
S    {
S        rt_kprintf("Module: unsupported elf type\n");
S
S        return RT_NULL;
S    }
S
S    if (module == RT_NULL)
S        return RT_NULL;
S
S    /* init module object container */
S    rt_module_init_object_container(module);
S
S    if (line_size && cmd_line)
S    {
S        /* set module argument */
S        module->module_cmd_line = (rt_uint8_t*)rt_malloc(line_size + 1);
S        if (module->module_cmd_line)
S        {
S            rt_memcpy(module->module_cmd_line, cmd_line, line_size);
S            module->module_cmd_line[line_size] = '\0';
S        }
S        module->module_cmd_size = line_size;
S    }
S    else
S    {
S        /* initialize an empty command */
S        module->module_cmd_line = RT_NULL;
S        module->module_cmd_size = 0;
S    }
S
S    /* increase module reference count */
S    module->nref ++;
S
S    if (elf_module->e_entry != 0)
S    {
S#ifdef RT_USING_SLAB
S        /* init module memory allocator */
S        module->mem_list = RT_NULL;
S
S        /* create page array */
S        module->page_array =
S            (void *)rt_malloc(PAGE_COUNT_MAX * sizeof(struct rt_page_info));
S        module->page_cnt = 0;
S#endif
S
S        /* create module thread */
S        module->module_thread = rt_thread_create(name,
S                                                 module_main_entry, module,
S                                                 RT_USING_MODULE_STKSZ,
S                                                 RT_USING_MODULE_PRIO, 10);
S
S        RT_DEBUG_LOG(RT_DEBUG_MODULE, ("thread entry 0x%x\n",
S                                       module->module_entry));
S
S        /* set module id */
S        module->module_thread->module_id = (void *)module;
S        module->parent.flag = RT_MODULE_FLAG_WITHENTRY;
S
S        /* startup module thread */
S        rt_thread_startup(module->module_thread);
S    }
S    else
S    {
S        /* without entry point */
S        module->parent.flag |= RT_MODULE_FLAG_WITHOUTENTRY;
S    }
S
S#ifdef RT_USING_HOOK
S    if (rt_module_load_hook != RT_NULL)
S    {
S        rt_module_load_hook(module);
S    }
S#endif
S
S    return module;
S}
S
S/**
S * This function will load a module from memory and create a thread for it
S *
S * @param name the name of module, which shall be unique
S * @param module_ptr the memory address of module image
S *
S * @return the module object
S */
Srt_module_t rt_module_load(const char *name, void *module_ptr)
S{
S    return rt_module_do_main(name, module_ptr, RT_NULL, 0);
S}
S
S#ifdef RT_USING_DFS
S#include <dfs_posix.h>
S
Sstatic char* _module_name(const char *path)
S{
S    const char *first, *end, *ptr;
S    char *name;
S    int size;
S
S    ptr   = (char *)path;
S    first = ptr;
S    end   = path + rt_strlen(path);
S
S    while (*ptr != '\0')
S    {
S        if (*ptr == '/')
S            first = ptr + 1;
S        if (*ptr == '.')
S            end = ptr - 1;
S
S        ptr ++;
S    }
S
S    size = end - first + 1;
S    name = rt_malloc(size);
S    rt_strncpy(name, first, size);
S    name[size] = '\0';
S
S    return name;
S}
S
S/**
S * This function will load a module from a file
S *
S * @param path the full path of application module
S *
S * @return the module object
S */
Srt_module_t rt_module_open(const char *path)
S{
S    int fd, length;
S    struct rt_module *module;
S    struct stat s;
S    char *buffer, *offset_ptr;
S    char *name;
S
S    RT_DEBUG_NOT_IN_INTERRUPT;
S
S    /* check parameters */
S    RT_ASSERT(path != RT_NULL);
S
S    if (stat(path, &s) !=0)
S    {
S        rt_kprintf("Module: access %s failed\n", path);
S
S        return RT_NULL;
S    }
S    buffer = (char *)rt_malloc(s.st_size);
S    if (buffer == RT_NULL)
S    {
S        rt_kprintf("Module: out of memory\n");
S
S        return RT_NULL;
S    }
S
S    offset_ptr = buffer;
S    fd = open(path, O_RDONLY, 0);
S    if (fd < 0)
S    {
S        rt_kprintf("Module: open %s failed\n", path);
S        rt_free(buffer);
S
S        return RT_NULL;
S    }
S
S    do
S    {
S        length = read(fd, offset_ptr, 4096);
S        if (length > 0)
S        {
S            offset_ptr += length;
S        }
S    }while (length > 0);
S
S    /* close fd */
S    close(fd);
S
S    if ((rt_uint32_t)offset_ptr - (rt_uint32_t)buffer != s.st_size)
S    {
S        rt_kprintf("Module: read file failed\n");
S        rt_free(buffer);
S
S        return RT_NULL;
S    }
S
S    name   = _module_name(path);
S    module = rt_module_load(name, (void *)buffer);
S    rt_free(buffer);
S    rt_free(name);
S
S    return module;
S}
S
S/**
S * This function will do a excutable program with main function and parameters.
S *
S * @param path the full path of application module
S * @param cmd_line the command line of program
S * @param size the size of command line of program
S *
S * @return the module object
S */
Srt_module_t rt_module_exec_cmd(const char *path, const char* cmd_line, int size)
S{
S    struct stat s;
S    int fd, length;
S    char *name, *buffer, *offset_ptr;
S    struct rt_module *module = RT_NULL;
S
S    name = buffer = RT_NULL;
S
S    RT_DEBUG_NOT_IN_INTERRUPT;
S
S    /* check parameters */
S    RT_ASSERT(path != RT_NULL);
S
S    /* get file size */
S    if (stat(path, &s) !=0)
S    {
S        rt_kprintf("Module: access %s failed\n", path);
S        goto __exit;
S    }
S
S    /* allocate buffer to save program */
S    offset_ptr = buffer = (char *)rt_malloc(s.st_size);
S    if (buffer == RT_NULL)
S    {
S        rt_kprintf("Module: out of memory\n");
S        goto __exit;
S    }
S
S    fd = open(path, O_RDONLY, 0);
S    if (fd < 0)
S    {
S        rt_kprintf("Module: open %s failed\n", path);
S        goto __exit;
S    }
S
S    do
S    {
S        length = read(fd, offset_ptr, 4096);
S        if (length > 0)
S        {
S            offset_ptr += length;
S        }
S    }while (length > 0);
S    /* close fd */
S    close(fd);
S
S    if ((rt_uint32_t)offset_ptr - (rt_uint32_t)buffer != s.st_size)
S    {
S        rt_kprintf("Module: read file failed\n");
S        goto __exit;
S    }
S
S    /* get module */
S    name   = _module_name(path);
S    /* execute module */
S    module = rt_module_do_main(name, (void *)buffer, cmd_line, size);
S
S__exit:
S    rt_free(buffer);
S    rt_free(name);
S
S    return module;
S}
S
S#if defined(RT_USING_FINSH)
S#include <finsh.h>
SFINSH_FUNCTION_EXPORT_ALIAS(rt_module_open, exec, exec module from a file);
S#endif
S
S#endif
S
S/**
S * This function will destroy a module and release its resource.
S *
S * @param module the module to be destroyed.
S *
S * @return the operation status, RT_EOK on OK; -RT_ERROR on error
S */
Srt_err_t rt_module_destroy(rt_module_t module)
S{
S    int i;
S    struct rt_object *object;
S    struct rt_list_node *list;
S
S    RT_DEBUG_NOT_IN_INTERRUPT;
S
S    /* check parameter */
S    RT_ASSERT(module != RT_NULL);
S    RT_ASSERT(module->nref == 0);
S
S    RT_DEBUG_LOG(RT_DEBUG_MODULE, ("rt_module_destroy: %8.*s\n",
S                                   RT_NAME_MAX, module->parent.name));
S
S    /* module has entry point */
S    if (!(module->parent.flag & RT_MODULE_FLAG_WITHOUTENTRY))
S    {
S#ifdef RT_USING_SEMAPHORE
S        /* delete semaphores */
S        list = &module->module_object[RT_Object_Class_Semaphore].object_list;
S        while (list->next != list)
S        {
S            object = rt_list_entry(list->next, struct rt_object, list);
S            if (rt_object_is_systemobject(object) == RT_TRUE)
S            {
S                /* detach static object */
S                rt_sem_detach((rt_sem_t)object);
S            }
S            else
S            {
S                /* delete dynamic object */
S                rt_sem_delete((rt_sem_t)object);
S            }
S        }
S#endif
S
S#ifdef RT_USING_MUTEX
S        /* delete mutexs*/
S        list = &module->module_object[RT_Object_Class_Mutex].object_list;
S        while (list->next != list)
S        {
S            object = rt_list_entry(list->next, struct rt_object, list);
S            if (rt_object_is_systemobject(object) == RT_TRUE)
S            {
S                /* detach static object */
S                rt_mutex_detach((rt_mutex_t)object);
S            }
S            else
S            {
S                /* delete dynamic object */
S                rt_mutex_delete((rt_mutex_t)object);
S            }
S        }
S#endif
S
S#ifdef RT_USING_EVENT
S        /* delete mailboxs */
S        list = &module->module_object[RT_Object_Class_Event].object_list;
S        while (list->next != list)
S        {
S            object = rt_list_entry(list->next, struct rt_object, list);
S            if (rt_object_is_systemobject(object) == RT_TRUE)
S            {
S                /* detach static object */
S                rt_event_detach((rt_event_t)object);
S            }
S            else
S            {
S                /* delete dynamic object */
S                rt_event_delete((rt_event_t)object);
S            }
S        }
S#endif
S
S#ifdef RT_USING_MAILBOX
S        /* delete mailboxs */
S        list = &module->module_object[RT_Object_Class_MailBox].object_list;
S        while (list->next != list)
S        {
S            object = rt_list_entry(list->next, struct rt_object, list);
S            if (rt_object_is_systemobject(object) == RT_TRUE)
S            {
S                /* detach static object */
S                rt_mb_detach((rt_mailbox_t)object);
S            }
S            else
S            {
S                /* delete dynamic object */
S                rt_mb_delete((rt_mailbox_t)object);
S            }
S        }
S#endif
S
S#ifdef RT_USING_MESSAGEQUEUE
S        /* delete msgqueues */
S        list = &module->module_object[RT_Object_Class_MessageQueue].object_list;
S        while (list->next != list)
S        {
S            object = rt_list_entry(list->next, struct rt_object, list);
S            if (rt_object_is_systemobject(object) == RT_TRUE)
S            {
S                /* detach static object */
S                rt_mq_detach((rt_mq_t)object);
S            }
S            else
S            {
S                /* delete dynamic object */
S                rt_mq_delete((rt_mq_t)object);
S            }
S        }
S#endif
S
S#ifdef RT_USING_MEMPOOL
S        /* delete mempools */
S        list = &module->module_object[RT_Object_Class_MemPool].object_list;
S        while (list->next != list)
S        {
S            object = rt_list_entry(list->next, struct rt_object, list);
S            if (rt_object_is_systemobject(object) == RT_TRUE)
S            {
S                /* detach static object */
S                rt_mp_detach((rt_mp_t)object);
S            }
S            else
S            {
S                /* delete dynamic object */
S                rt_mp_delete((rt_mp_t)object);
S            }
S        }
S#endif
S
S#ifdef RT_USING_DEVICE
S        /* delete devices */
S        list = &module->module_object[RT_Object_Class_Device].object_list;
S        while (list->next != list)
S        {
S            object = rt_list_entry(list->next, struct rt_object, list);
S            rt_device_unregister((rt_device_t)object);
S        }
S#endif
S
S        /* delete timers */
S        list = &module->module_object[RT_Object_Class_Timer].object_list;
S        while (list->next != list)
S        {
S            object = rt_list_entry(list->next, struct rt_object, list);
S            if (rt_object_is_systemobject(object) == RT_TRUE)
S            {
S                /* detach static object */
S                rt_timer_detach((rt_timer_t)object);
S            }
S            else
S            {
S                /* delete dynamic object */
S                rt_timer_delete((rt_timer_t)object);
S            }
S        }
S
S        /* delete command line */
S        if (module->module_cmd_line != RT_NULL)
S        {
S            rt_free(module->module_cmd_line);
S        }
S    }
S
S#ifdef RT_USING_SLAB
S    if (module->page_cnt > 0)
S    {
S        struct rt_page_info *page = (struct rt_page_info *)module->page_array;
S
S        rt_kprintf("Module: warning - memory still hasn't been free finished\n");
S
S        while (module->page_cnt != 0)
S        {
S            rt_module_free_page(module, page[0].page_ptr, page[0].npage);
S        }
S    }
S#endif
S
S    /* release module space memory */
S    rt_free(module->module_space);
S
S    /* release module symbol table */
S    for (i = 0; i < module->nsym; i ++)
S    {
S        rt_free((void *)module->symtab[i].name);
S    }
S    if (module->symtab != RT_NULL)
S        rt_free(module->symtab);
S
S#ifdef RT_USING_SLAB
S    if (module->page_array != RT_NULL)
S        rt_free(module->page_array);
S#endif
S
S    /* delete module object */
S    rt_object_delete((rt_object_t)module);
S
S    return RT_EOK;
S}
S
S/**
S * This function will unload a module from memory and release resources
S *
S * @param module the module to be unloaded
S *
S * @return the operation status, RT_EOK on OK; -RT_ERROR on error
S */
Srt_err_t rt_module_unload(rt_module_t module)
S{
S    struct rt_object *object;
S    struct rt_list_node *list;
S
S    RT_DEBUG_NOT_IN_INTERRUPT;
S
S    /* check parameter */
S    if (module == RT_NULL)
S        return -RT_ERROR;
S
S    rt_enter_critical();
S    if (!(module->parent.flag & RT_MODULE_FLAG_WITHOUTENTRY))
S    {
S        /* delete all sub-threads */
S        list = &module->module_object[RT_Object_Class_Thread].object_list;
S        while (list->next != list)
S        {
S            object = rt_list_entry(list->next, struct rt_object, list);
S            if (rt_object_is_systemobject(object) == RT_TRUE)
S            {
S                /* detach static object */
S                rt_thread_detach((rt_thread_t)object);
S            }
S            else
S            {
S                /* delete dynamic object */
S                rt_thread_delete((rt_thread_t)object);
S            }
S        }
S
S        /* delete the main thread of module */
S        if (module->module_thread != RT_NULL)
S        {
S            rt_thread_delete(module->module_thread);
S        }
S    }
S    rt_exit_critical();
S
S#ifdef RT_USING_HOOK
S    if (rt_module_unload_hook != RT_NULL)
S    {
S        rt_module_unload_hook(module);
S    }
S#endif
S
S    return RT_EOK;
S}
S
S/**
S * This function will find the specified module.
S *
S * @param name the name of module finding
S *
S * @return the module
S */
Srt_module_t rt_module_find(const char *name)
S{
S    struct rt_object_information *information;
S    struct rt_object *object;
S    struct rt_list_node *node;
S
S    extern struct rt_object_information rt_object_container[];
S
S    RT_DEBUG_NOT_IN_INTERRUPT;
S
S    /* enter critical */
S    rt_enter_critical();
S
S    /* try to find device object */
S    information = &rt_object_container[RT_Object_Class_Module];
S    for (node = information->object_list.next;
S         node != &(information->object_list);
S         node = node->next)
S    {
S        object = rt_list_entry(node, struct rt_object, list);
S        if (rt_strncmp(object->name, name, RT_NAME_MAX) == 0)
S        {
S            /* leave critical */
S            rt_exit_critical();
S
S            return (rt_module_t)object;
S        }
S    }
S
S    /* leave critical */
S    rt_exit_critical();
S
S    /* not found */
S    return RT_NULL;
S}
SRTM_EXPORT(rt_module_find);
S
S#ifdef RT_USING_SLAB
S/*
S * This function will allocate the numbers page with specified size
S * in page memory.
S *
S * @param size the size of memory to be allocated.
S * @note this function is used for RT-Thread Application Module
S */
Sstatic void *rt_module_malloc_page(rt_size_t npages)
S{
S    void *chunk;
S    struct rt_page_info *page;
S    rt_module_t self_module;
S
S    self_module = rt_module_self();
S    RT_ASSERT(self_module != RT_NULL);
S
S    chunk = rt_page_alloc(npages);
S    if (chunk == RT_NULL)
S        return RT_NULL;
S
S    page = (struct rt_page_info *)self_module->page_array;
S    page[self_module->page_cnt].page_ptr = chunk;
S    page[self_module->page_cnt].npage    = npages;
S    self_module->page_cnt ++;
S
S    RT_ASSERT(self_module->page_cnt <= PAGE_COUNT_MAX);
S    RT_DEBUG_LOG(RT_DEBUG_MODULE, ("rt_module_malloc_page 0x%x %d\n",
S                                   chunk, npages));
S
S    return chunk;
S}
S
S/*
S * This function will release the previously allocated memory page
S * by rt_malloc_page.
S *
S * @param page_ptr the page address to be released.
S * @param npages the number of page shall be released.
S *
S * @note this function is used for RT-Thread Application Module
S */
Sstatic void rt_module_free_page(rt_module_t module,
S                                void       *page_ptr,
S                                rt_size_t   npages)
S{
S    int i, index;
S    struct rt_page_info *page;
S    rt_module_t self_module;
S
S    self_module = rt_module_self();
S    RT_ASSERT(self_module != RT_NULL);
S
S    RT_DEBUG_LOG(RT_DEBUG_MODULE, ("rt_module_free_page 0x%x %d\n",
S                                   page_ptr, npages));
S    rt_page_free(page_ptr, npages);
S
S    page = (struct rt_page_info *)module->page_array;
S
S    for (i = 0; i < module->page_cnt; i ++)
S    {
S        if (page[i].page_ptr == page_ptr)
S        {
S            if (page[i].npage == npages + 1)
S            {
S                page[i].page_ptr +=
S                    npages * RT_MM_PAGE_SIZE / sizeof(rt_uint32_t);
S                page[i].npage    -= npages;
S            }
S            else if (page[i].npage == npages)
S            {
S                for (index = i; index < module->page_cnt-1; index ++)
S                {
S                    page[index].page_ptr = page[index + 1].page_ptr;
S                    page[index].npage    = page[index + 1].npage;
S                }
S                page[module->page_cnt - 1].page_ptr = RT_NULL;
S                page[module->page_cnt - 1].npage    = 0;
S
S                module->page_cnt --;
S            }
S            else
S                RT_ASSERT(RT_FALSE);
S            self_module->page_cnt --;
S
S            return;
S        }
S    }
S
S    /* should not get here */
S    RT_ASSERT(RT_FALSE);
S}
S
S/**
S * rt_module_malloc - allocate memory block in free list
S */
Svoid *rt_module_malloc(rt_size_t size)
S{
S    struct rt_mem_head *b, *n, *up;
S    struct rt_mem_head **prev;
S    rt_uint32_t npage;
S    rt_size_t nunits;
S    rt_module_t self_module;
S
S    self_module = rt_module_self();
S    RT_ASSERT(self_module != RT_NULL);
S
S    RT_DEBUG_NOT_IN_INTERRUPT;
S
S    nunits = (size + sizeof(struct rt_mem_head) - 1) /
S        sizeof(struct rt_mem_head)
S        + 1;
S
S    RT_ASSERT(size != 0);
S    RT_ASSERT(nunits != 0);
S
S    rt_sem_take(&mod_sem, RT_WAITING_FOREVER);
S
S    for (prev = (struct rt_mem_head **)&self_module->mem_list;
S         (b = *prev) != RT_NULL;
S         prev = &(b->next))
S    {
S        if (b->size > nunits)
S        {
S            /* split memory */
S            n       = b + nunits;
S            n->next = b->next;
S            n->size = b->size - nunits;
S            b->size = nunits;
S            *prev   = n;
S
S            RT_DEBUG_LOG(RT_DEBUG_MODULE, ("rt_module_malloc 0x%x, %d\n",
S                                           b + 1, size));
S            rt_sem_release(&mod_sem);
S
S            return (void *)(b + 1);
S        }
S
S        if (b->size == nunits)
S        {
S            /* this node fit, remove this node */
S            *prev = b->next;
S
S            RT_DEBUG_LOG(RT_DEBUG_MODULE, ("rt_module_malloc 0x%x, %d\n",
S                                           b + 1, size));
S
S            rt_sem_release(&mod_sem);
S
S            return (void *)(b + 1);
S        }
S    }
S
S    /* allocate pages from system heap */
S    npage = (size + sizeof(struct rt_mem_head) + RT_MM_PAGE_SIZE - 1) /
S        RT_MM_PAGE_SIZE;
S    if ((up = (struct rt_mem_head *)rt_module_malloc_page(npage)) == RT_NULL)
S        return RT_NULL;
S
S    up->size = npage * RT_MM_PAGE_SIZE / sizeof(struct rt_mem_head);
S
S    for (prev = (struct rt_mem_head **)&self_module->mem_list;
S         (b = *prev) != RT_NULL;
S         prev = &(b->next))
S    {
S        if (b > up + up->size)
S            break;
S    }
S
S    up->next = b;
S    *prev    = up;
S
S    rt_sem_release(&mod_sem);
S
S    return rt_module_malloc(size);
S}
S
S/**
S * rt_module_free - free memory block in free list
S */
Svoid rt_module_free(rt_module_t module, void *addr)
S{
S    struct rt_mem_head *b, *n, *r;
S    struct rt_mem_head **prev;
S
S    RT_DEBUG_NOT_IN_INTERRUPT;
S
S    RT_ASSERT(addr);
S    RT_ASSERT((((rt_uint32_t)addr) & (sizeof(struct rt_mem_head) -1)) == 0);
S
S    RT_DEBUG_LOG(RT_DEBUG_MODULE, ("rt_module_free 0x%x\n", addr));
S
S    rt_sem_take(&mod_sem, RT_WAITING_FOREVER);
S
S    n = (struct rt_mem_head *)addr - 1;
S    prev = (struct rt_mem_head **)&module->mem_list;
S
S    while ((b = *prev) != RT_NULL)
S    {
S        RT_ASSERT(b->size > 0);
S        RT_ASSERT(b > n || b + b->size <= n);
S
S        if (b + b->size == n && ((rt_uint32_t)n % RT_MM_PAGE_SIZE != 0))
S        {
S            if (b + (b->size + n->size) == b->next)
S            {
S                b->size += b->next->size + n->size;
S                b->next = b->next->next;
S            }
S            else
S                b->size += n->size;
S
S            if ((rt_uint32_t)b % RT_MM_PAGE_SIZE == 0)
S            {
S                int npage =
S                    b->size * sizeof(struct rt_page_info) / RT_MM_PAGE_SIZE;
S                if (npage > 0)
S                {
S                    if ((b->size * sizeof(struct rt_page_info) % RT_MM_PAGE_SIZE) != 0)
S                    {
S                        rt_size_t nunits = npage *
S                            RT_MM_PAGE_SIZE /
S                            sizeof(struct rt_mem_head);
S                        /* split memory */
S                        r       = b + nunits;
S                        r->next = b->next;
S                        r->size = b->size - nunits;
S                        *prev   = r;
S                    }
S                    else
S                    {
S                        *prev = b->next;
S                    }
S
S                    rt_module_free_page(module, b, npage);
S                }
S            }
S
S            /* unlock */
S            rt_sem_release(&mod_sem);
S
S            return;
S        }
S
S        if (b == n + n->size)
S        {
S            n->size = b->size + n->size;
S            n->next = b->next;
S
S            if ((rt_uint32_t)n % RT_MM_PAGE_SIZE == 0)
S            {
S                int npage =
S                    n->size * sizeof(struct rt_page_info) / RT_MM_PAGE_SIZE;
S                if (npage > 0)
S                {
S                    if ((n->size * sizeof(struct rt_page_info) % RT_MM_PAGE_SIZE) != 0)
S                    {
S                        rt_size_t nunits = npage *
S                            RT_MM_PAGE_SIZE /
S                            sizeof(struct rt_mem_head);
S                        /* split memory */
S                        r       = n + nunits;
S                        r->next = n->next;
S                        r->size = n->size - nunits;
S                        *prev   = r;
S                    }
S                    else
S                        *prev = n->next;
S
S                    rt_module_free_page(module, n, npage);
S                }
S            }
S            else
S            {
S                *prev = n;
S            }
S
S            /* unlock */
S            rt_sem_release(&mod_sem);
S
S            return;
S        }
S        if (b > n + n->size)
S            break;
S
S        prev = &(b->next);
S    }
S
S    if ((rt_uint32_t)n % RT_MM_PAGE_SIZE == 0)
S    {
S        int npage = n->size * sizeof(struct rt_page_info) / RT_MM_PAGE_SIZE;
S        if (npage > 0)
S        {
S            rt_module_free_page(module, n, npage);
S            if (n->size % RT_MM_PAGE_SIZE != 0)
S            {
S                rt_size_t nunits =
S                    npage * RT_MM_PAGE_SIZE / sizeof(struct rt_mem_head);
S                /* split memory */
S                r       = n + nunits;
S                r->next = b;
S                r->size = n->size - nunits;
S                *prev   = r;
S            }
S            else
S            {
S                *prev = b;
S            }
S        }
S    }
S    else
S    {
S        n->next = b;
S        *prev   = n;
S    }
S
S    /* unlock */
S    rt_sem_release(&mod_sem);
S}
S
S/**
S * rt_module_realloc - realloc memory block in free list
S */
Svoid *rt_module_realloc(void *ptr, rt_size_t size)
S{
S    struct rt_mem_head *b, *p, *prev, *tmpp;
S    rt_size_t nunits;
S    rt_module_t self_module;
S
S    self_module = rt_module_self();
S    RT_ASSERT(self_module != RT_NULL);
S
S    RT_DEBUG_NOT_IN_INTERRUPT;
S
S    if (!ptr)
S        return rt_module_malloc(size);
S    if (size == 0)
S    {
S        rt_module_free(self_module, ptr);
S
S        return RT_NULL;
S    }
S
S    nunits = (size + sizeof(struct rt_mem_head) - 1) /
S        sizeof(struct rt_mem_head)
S        +1;
S    b = (struct rt_mem_head *)ptr - 1;
S
S    if (nunits <= b->size)
S    {
S        /* new size is smaller or equal then before */
S        if (nunits == b->size)
S            return ptr;
S        else
S        {
S            p       = b + nunits;
S            p->size = b->size - nunits;
S            b->size = nunits;
S            rt_module_free(self_module, (void *)(p + 1));
S
S            return (void *)(b + 1);
S        }
S    }
S    else
S    {
S        /* more space then required */
S        prev = (struct rt_mem_head *)self_module->mem_list;
S        for (p = prev->next;
S             p != (b->size + b) && p != RT_NULL;
S             prev = p, p = p->next)
S        {
S            break;
S        }
S
S        /* available block after ap in freelist */
S        if (p != RT_NULL &&
S            (p->size >= (nunits - (b->size))) &&
S            p == (b + b->size))
S        {
S            /* perfect match */
S            if (p->size == (nunits - (b->size)))
S            {
S                b->size    = nunits;
S                prev->next = p->next;
S            }
S            else  /* more space then required, split block */
S            {
S                /* pointer to old header */
S                tmpp = p;
S                p    = b + nunits;
S
S                /* restoring old pointer */
S                p->next = tmpp->next;
S
S                /* new size for p */
S                p->size    = tmpp->size + b->size - nunits;
S                b->size    = nunits;
S                prev->next = p;
S            }
S            self_module->mem_list = (void *)prev;
S
S            return (void *)(b + 1);
S        }
S        else /* allocate new memory and copy old data */
S        {
S            if ((p = rt_module_malloc(size)) == RT_NULL)
S                return RT_NULL;
S            rt_memmove(p, (b+1), ((b->size) * sizeof(struct rt_mem_head)));
S            rt_module_free(self_module, (void *)(b + 1));
S
S            return (void *)(p);
S        }
S    }
S}
S
S#ifdef RT_USING_FINSH
S#include <finsh.h>
S
Svoid list_memlist(const char *name)
S{
S    rt_module_t module;
S    struct rt_mem_head **prev;
S    struct rt_mem_head *b;
S
S    module = rt_module_find(name);
S    if (module == RT_NULL)
S        return;
S
S    for (prev = (struct rt_mem_head **)&module->mem_list;
S         (b = *prev) != RT_NULL;
S         prev = &(b->next))
S    {
S        rt_kprintf("0x%x--%d\n", b, b->size * sizeof(struct rt_mem_head));
S    }
S}
SFINSH_FUNCTION_EXPORT(list_memlist, list module free memory information)
S
Svoid list_mempage(const char *name)
S{
S    rt_module_t module;
S    struct rt_page_info *page;
S    int i;
S
S    module = rt_module_find(name);
S    if (module == RT_NULL)
S        return;
S
S    page = (struct rt_page_info *)module->page_array;
S
S    for (i = 0; i < module->page_cnt; i ++)
S    {
S        rt_kprintf("0x%x--%d\n", page[i].page_ptr, page[i].npage);
S    }
S}
SFINSH_FUNCTION_EXPORT(list_mempage, list module using memory page information)
S#endif /* RT_USING_FINSH */
S
S#endif /* RT_USING_SLAB */
S
N#endif
