; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\ipc.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\ipc.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I.\Libraries\Device\Nuvoton -I..\..\components\finsh -I.\Libraries\CMSIS\Include -I.\Libraries\StdDriver\inc -I..\..\include -I.\APP -I.\Drivers -I..\..\components\drivers\include -I..\..\components\drivers\include\drivers -I..\nuvoton_nuc240 -I.\Libraries\Device\Nuvoton\NUC230_240\Include -I..\..\include -I..\..\components\drivers\usb\usbdevice\class -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=521 --omf_browse=.\objects\ipc.crf ..\..\src\ipc.c]
                          THUMB

                          AREA ||i.rt_event_control||, CODE, READONLY, ALIGN=1

                  rt_event_control PROC
;;;1212    */
;;;1213   rt_err_t rt_event_control(rt_event_t event, rt_uint8_t cmd, void *arg)
000000  b570              PUSH     {r4-r6,lr}
;;;1214   {
000002  4604              MOV      r4,r0
;;;1215       rt_ubase_t level;
;;;1216       RT_ASSERT(event != RT_NULL);
;;;1217   
;;;1218       if (cmd == RT_IPC_CMD_RESET)
000004  2901              CMP      r1,#1
000006  d002              BEQ      |L1.14|
;;;1219       {
;;;1220           /* disable interrupt */
;;;1221           level = rt_hw_interrupt_disable();
;;;1222   
;;;1223           /* resume all waiting thread */
;;;1224           rt_ipc_list_resume_all(&event->parent.suspend_thread);
;;;1225   
;;;1226           /* init event set */
;;;1227           event->set = 0;
;;;1228   
;;;1229           /* enable interrupt */
;;;1230           rt_hw_interrupt_enable(level);
;;;1231   
;;;1232           rt_schedule();
;;;1233   
;;;1234           return RT_EOK;
;;;1235       }
;;;1236   
;;;1237       return -RT_ERROR;
000008  2000              MOVS     r0,#0
00000a  43c0              MVNS     r0,r0
;;;1238   }
00000c  bd70              POP      {r4-r6,pc}
                  |L1.14|
00000e  f7fffffe          BL       rt_hw_interrupt_disable
000012  4605              MOV      r5,r0                 ;1221
000014  4620              MOV      r0,r4                 ;1224
000016  3014              ADDS     r0,r0,#0x14           ;1224
000018  f7fffffe          BL       rt_ipc_list_resume_all
00001c  2000              MOVS     r0,#0                 ;1227
00001e  61e0              STR      r0,[r4,#0x1c]         ;1230
000020  4628              MOV      r0,r5                 ;1230
000022  f7fffffe          BL       rt_hw_interrupt_enable
000026  f7fffffe          BL       rt_schedule
00002a  2000              MOVS     r0,#0                 ;1234
00002c  bd70              POP      {r4-r6,pc}
;;;1239   RTM_EXPORT(rt_event_control);
                          ENDP


                          AREA ||i.rt_event_create||, CODE, READONLY, ALIGN=1

                  rt_event_create PROC
;;;939     */
;;;940    rt_event_t rt_event_create(const char *name, rt_uint8_t flag)
000000  b510              PUSH     {r4,lr}
;;;941    {
000002  460c              MOV      r4,r1
;;;942        rt_event_t event;
;;;943    
;;;944        RT_DEBUG_NOT_IN_INTERRUPT;
;;;945    
;;;946        /* allocate object */
;;;947        event = (rt_event_t)rt_object_allocate(RT_Object_Class_Event, name);
000004  4601              MOV      r1,r0
000006  2003              MOVS     r0,#3
000008  f7fffffe          BL       rt_object_allocate
;;;948        if (event == RT_NULL)
00000c  2800              CMP      r0,#0
00000e  d006              BEQ      |L2.30|
000010  4601              MOV      r1,r0
;;;949            return event;
;;;950    
;;;951        /* set parent */
;;;952        event->parent.parent.flag = flag;
000012  7244              STRB     r4,[r0,#9]
000014  3114              ADDS     r1,r1,#0x14
000016  6181              STR      r1,[r0,#0x18]
;;;953    
;;;954        /* init ipc object */
;;;955        rt_ipc_object_init(&(event->parent));
;;;956    
;;;957        /* init event */
;;;958        event->set = 0;
000018  6141              STR      r1,[r0,#0x14]
00001a  2100              MOVS     r1,#0
00001c  61c1              STR      r1,[r0,#0x1c]
                  |L2.30|
;;;959    
;;;960        return event;
;;;961    }
00001e  bd10              POP      {r4,pc}
;;;962    RTM_EXPORT(rt_event_create);
                          ENDP


                          AREA ||i.rt_event_delete||, CODE, READONLY, ALIGN=1

                  rt_event_delete PROC
;;;970     */
;;;971    rt_err_t rt_event_delete(rt_event_t event)
000000  b510              PUSH     {r4,lr}
;;;972    {
000002  4604              MOV      r4,r0
;;;973        /* parameter check */
;;;974        RT_ASSERT(event != RT_NULL);
;;;975    
;;;976        RT_DEBUG_NOT_IN_INTERRUPT;
;;;977    
;;;978        /* resume all suspended thread */
;;;979        rt_ipc_list_resume_all(&(event->parent.suspend_thread));
000004  3014              ADDS     r0,r0,#0x14
000006  f7fffffe          BL       rt_ipc_list_resume_all
;;;980    
;;;981        /* delete event object */
;;;982        rt_object_delete(&(event->parent.parent));
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       rt_object_delete
;;;983    
;;;984        return RT_EOK;
000010  2000              MOVS     r0,#0
;;;985    }
000012  bd10              POP      {r4,pc}
;;;986    RTM_EXPORT(rt_event_delete);
                          ENDP


                          AREA ||i.rt_event_detach||, CODE, READONLY, ALIGN=1

                  rt_event_detach PROC
;;;915     */
;;;916    rt_err_t rt_event_detach(rt_event_t event)
000000  b510              PUSH     {r4,lr}
;;;917    {
000002  4604              MOV      r4,r0
;;;918        /* parameter check */
;;;919        RT_ASSERT(event != RT_NULL);
;;;920    
;;;921        /* resume all suspended thread */
;;;922        rt_ipc_list_resume_all(&(event->parent.suspend_thread));
000004  3014              ADDS     r0,r0,#0x14
000006  f7fffffe          BL       rt_ipc_list_resume_all
;;;923    
;;;924        /* detach event object */
;;;925        rt_object_detach(&(event->parent.parent));
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       rt_object_detach
;;;926    
;;;927        return RT_EOK;
000010  2000              MOVS     r0,#0
;;;928    }
000012  bd10              POP      {r4,pc}
;;;929    RTM_EXPORT(rt_event_detach);
                          ENDP


                          AREA ||i.rt_event_init||, CODE, READONLY, ALIGN=1

                  rt_event_init PROC
;;;888     */
;;;889    rt_err_t rt_event_init(rt_event_t event, const char *name, rt_uint8_t flag)
000000  b570              PUSH     {r4-r6,lr}
;;;890    {
000002  4614              MOV      r4,r2
;;;891        RT_ASSERT(event != RT_NULL);
;;;892    
;;;893        /* init object */
;;;894        rt_object_init(&(event->parent.parent), RT_Object_Class_Event, name);
000004  460a              MOV      r2,r1
000006  4605              MOV      r5,r0                 ;890
000008  2103              MOVS     r1,#3
00000a  f7fffffe          BL       rt_object_init
;;;895    
;;;896        /* set parent flag */
;;;897        event->parent.parent.flag = flag;
00000e  726c              STRB     r4,[r5,#9]
000010  462c              MOV      r4,r5
000012  3414              ADDS     r4,r4,#0x14
000014  61ac              STR      r4,[r5,#0x18]
;;;898    
;;;899        /* init ipc object */
;;;900        rt_ipc_object_init(&(event->parent));
;;;901    
;;;902        /* init event */
;;;903        event->set = 0;
000016  2000              MOVS     r0,#0
000018  616c              STR      r4,[r5,#0x14]
00001a  61e8              STR      r0,[r5,#0x1c]
;;;904    
;;;905        return RT_EOK;
;;;906    }
00001c  bd70              POP      {r4-r6,pc}
;;;907    RTM_EXPORT(rt_event_init);
                          ENDP


                          AREA ||i.rt_event_recv||, CODE, READONLY, ALIGN=2

                  rt_event_recv PROC
;;;1092    */
;;;1093   rt_err_t rt_event_recv(rt_event_t   event,
000000  b5ff              PUSH     {r0-r7,lr}
;;;1094                          rt_uint32_t  set,
;;;1095                          rt_uint8_t   option,
;;;1096                          rt_int32_t   timeout,
;;;1097                          rt_uint32_t *recved)
;;;1098   {
000002  4605              MOV      r5,r0
;;;1099       struct rt_thread *thread;
;;;1100       register rt_ubase_t level;
;;;1101       register rt_base_t status;
;;;1102   
;;;1103       RT_DEBUG_IN_THREAD_CONTEXT;
;;;1104   
;;;1105       /* parameter check */
;;;1106       RT_ASSERT(event != RT_NULL);
;;;1107       if (set == 0)
;;;1108           return -RT_ERROR;
000004  482c              LDR      r0,|L6.184|
000006  b081              SUB      sp,sp,#4              ;1098
000008  4617              MOV      r7,r2                 ;1098
00000a  000e              MOVS     r6,r1                 ;1098
00000c  d04d              BEQ      |L6.170|
;;;1109   
;;;1110       /* init status */
;;;1111       status = -RT_ERROR;
;;;1112       /* get current thread */
;;;1113       thread = rt_thread_self();
00000e  f7fffffe          BL       rt_thread_self
000012  4604              MOV      r4,r0
;;;1114       /* reset thread error */
;;;1115       thread->error = RT_EOK;
000014  2000              MOVS     r0,#0
;;;1116   
;;;1117       RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(event->parent.parent)));
;;;1118   
;;;1119       /* disable interrupt */
;;;1120       level = rt_hw_interrupt_disable();
000016  6320              STR      r0,[r4,#0x30]
000018  f7fffffe          BL       rt_hw_interrupt_disable
;;;1121   
;;;1122       /* check event set */
;;;1123       if (option & RT_EVENT_FLAG_AND)
00001c  9000              STR      r0,[sp,#0]
00001e  07f8              LSLS     r0,r7,#31
000020  d004              BEQ      |L6.44|
;;;1124       {
;;;1125           if ((event->set & set) == set)
000022  69e9              LDR      r1,[r5,#0x1c]
000024  4630              MOV      r0,r6
000026  4388              BICS     r0,r0,r1
000028  d005              BEQ      |L6.54|
00002a  e011              B        |L6.80|
                  |L6.44|
;;;1126               status = RT_EOK;
;;;1127       }
;;;1128       else if (option & RT_EVENT_FLAG_OR)
00002c  07b8              LSLS     r0,r7,#30
00002e  d50f              BPL      |L6.80|
;;;1129       {
;;;1130           if (event->set & set)
000030  69e8              LDR      r0,[r5,#0x1c]
000032  4230              TST      r0,r6
000034  d00c              BEQ      |L6.80|
                  |L6.54|
;;;1131               status = RT_EOK;
;;;1132       }
;;;1133       else
;;;1134       {
;;;1135           /* either RT_EVENT_FLAG_AND or RT_EVENT_FLAG_OR should be set */
;;;1136           RT_ASSERT(0);
;;;1137       }
;;;1138   
;;;1139       if (status == RT_EOK)
;;;1140       {
;;;1141           /* set received event */
;;;1142           if (recved)
000036  980a              LDR      r0,[sp,#0x28]
000038  2800              CMP      r0,#0
00003a  d003              BEQ      |L6.68|
;;;1143               *recved = (event->set & set);
00003c  69e8              LDR      r0,[r5,#0x1c]
00003e  990a              LDR      r1,[sp,#0x28]
000040  4030              ANDS     r0,r0,r6
000042  6008              STR      r0,[r1,#0]
                  |L6.68|
;;;1144   
;;;1145           /* received event */
;;;1146           if (option & RT_EVENT_FLAG_CLEAR)
000044  0778              LSLS     r0,r7,#29
000046  d52c              BPL      |L6.162|
;;;1147               event->set &= ~set;
000048  69e8              LDR      r0,[r5,#0x1c]
00004a  43b0              BICS     r0,r0,r6
00004c  61e8              STR      r0,[r5,#0x1c]
00004e  e028              B        |L6.162|
                  |L6.80|
;;;1148       }
;;;1149       else if (timeout == 0)
000050  9804              LDR      r0,[sp,#0x10]
000052  2800              CMP      r0,#0
000054  d02b              BEQ      |L6.174|
;;;1150       {
;;;1151           /* no waiting */
;;;1152           thread->error = -RT_ETIMEOUT;
;;;1153       }
;;;1154       else
;;;1155       {
;;;1156           /* fill thread event info */
;;;1157           thread->event_set  = set;
;;;1158           thread->event_info = option;
000056  2040              MOVS     r0,#0x40
000058  63e6              STR      r6,[r4,#0x3c]
00005a  5507              STRB     r7,[r0,r4]
;;;1159   
;;;1160           /* put thread to suspended thread list */
;;;1161           rt_ipc_list_suspend(&(event->parent.suspend_thread),
00005c  4628              MOV      r0,r5
00005e  7a6a              LDRB     r2,[r5,#9]
000060  4621              MOV      r1,r4
000062  3014              ADDS     r0,r0,#0x14
000064  f7fffffe          BL       rt_ipc_list_suspend
;;;1162                               thread,
;;;1163                               event->parent.parent.flag);
;;;1164   
;;;1165           /* if there is a waiting timeout, active thread timer */
;;;1166           if (timeout > 0)
000068  9804              LDR      r0,[sp,#0x10]
00006a  2800              CMP      r0,#0
00006c  dd09              BLE      |L6.130|
;;;1167           {
;;;1168               /* reset the timeout of thread timer and start it */
;;;1169               rt_timer_control(&(thread->thread_timer),
00006e  4620              MOV      r0,r4
000070  304c              ADDS     r0,r0,#0x4c
000072  aa04              ADD      r2,sp,#0x10
000074  2100              MOVS     r1,#0
000076  4605              MOV      r5,r0
000078  f7fffffe          BL       rt_timer_control
00007c  4628              MOV      r0,r5
;;;1170                                RT_TIMER_CTRL_SET_TIME,
;;;1171                                &timeout);
;;;1172               rt_timer_start(&(thread->thread_timer));
00007e  f7fffffe          BL       rt_timer_start
                  |L6.130|
;;;1173           }
;;;1174   
;;;1175           /* enable interrupt */
;;;1176           rt_hw_interrupt_enable(level);
000082  9800              LDR      r0,[sp,#0]
000084  f7fffffe          BL       rt_hw_interrupt_enable
;;;1177   
;;;1178           /* do a schedule */
;;;1179           rt_schedule();
000088  f7fffffe          BL       rt_schedule
;;;1180   
;;;1181           if (thread->error != RT_EOK)
00008c  6b20              LDR      r0,[r4,#0x30]
00008e  2800              CMP      r0,#0
000090  d10b              BNE      |L6.170|
;;;1182           {
;;;1183               /* return error */
;;;1184               return thread->error;
;;;1185           }
;;;1186   
;;;1187           /* received an event, disable interrupt to protect */
;;;1188           level = rt_hw_interrupt_disable();
000092  f7fffffe          BL       rt_hw_interrupt_disable
;;;1189   
;;;1190           /* set received event */
;;;1191           if (recved)
000096  9000              STR      r0,[sp,#0]
000098  980a              LDR      r0,[sp,#0x28]
00009a  2800              CMP      r0,#0
00009c  d001              BEQ      |L6.162|
;;;1192               *recved = thread->event_set;
00009e  6be1              LDR      r1,[r4,#0x3c]
0000a0  6001              STR      r1,[r0,#0]
                  |L6.162|
;;;1193       }
;;;1194   
;;;1195       /* enable interrupt */
;;;1196       rt_hw_interrupt_enable(level);
0000a2  9800              LDR      r0,[sp,#0]
0000a4  f7fffffe          BL       rt_hw_interrupt_enable
;;;1197   
;;;1198       RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(event->parent.parent)));
;;;1199   
;;;1200       return thread->error;
0000a8  6b20              LDR      r0,[r4,#0x30]
                  |L6.170|
;;;1201   }
0000aa  b005              ADD      sp,sp,#0x14
0000ac  bdf0              POP      {r4-r7,pc}
                  |L6.174|
0000ae  2001              MOVS     r0,#1                 ;1152
0000b0  43c0              MVNS     r0,r0                 ;1152
0000b2  6320              STR      r0,[r4,#0x30]         ;1152
0000b4  e7f5              B        |L6.162|
;;;1202   RTM_EXPORT(rt_event_recv);
                          ENDP

0000b6  0000              DCW      0x0000
                  |L6.184|
                          DCD      0xffffffff

                          AREA ||i.rt_event_send||, CODE, READONLY, ALIGN=1

                  rt_event_send PROC
;;;997     */
;;;998    rt_err_t rt_event_send(rt_event_t event, rt_uint32_t set)
000000  b5fe              PUSH     {r1-r7,lr}
;;;999    {
000002  000d              MOVS     r5,r1
000004  4604              MOV      r4,r0
000006  d00e              BEQ      |L7.38|
;;;1000       struct rt_list_node *n;
;;;1001       struct rt_thread *thread;
;;;1002       register rt_ubase_t level;
;;;1003       register rt_base_t status;
;;;1004       rt_bool_t need_schedule;
;;;1005   
;;;1006       /* parameter check */
;;;1007       RT_ASSERT(event != RT_NULL);
;;;1008       if (set == 0)
;;;1009           return -RT_ERROR;
;;;1010   
;;;1011       need_schedule = RT_FALSE;
000008  2600              MOVS     r6,#0
;;;1012       RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(event->parent.parent)));
;;;1013   
;;;1014       /* disable interrupt */
;;;1015       level = rt_hw_interrupt_disable();
00000a  f7fffffe          BL       rt_hw_interrupt_disable
;;;1016   
;;;1017       /* set event */
;;;1018       event->set |= set;
00000e  9001              STR      r0,[sp,#4]
000010  69e0              LDR      r0,[r4,#0x1c]
000012  4328              ORRS     r0,r0,r5
;;;1019   
;;;1020       if (!rt_list_isempty(&event->parent.suspend_thread))
000014  61e0              STR      r0,[r4,#0x1c]
000016  4620              MOV      r0,r4
000018  3014              ADDS     r0,r0,#0x14
00001a  9000              STR      r0,[sp,#0]
00001c  f7fffffe          BL       rt_list_isempty
000020  2800              CMP      r0,#0
000022  d003              BEQ      |L7.44|
000024  e02c              B        |L7.128|
                  |L7.38|
000026  2000              MOVS     r0,#0                 ;1009
000028  43c0              MVNS     r0,r0                 ;1009
;;;1021       {
;;;1022           /* search thread list to resume thread */
;;;1023           n = event->parent.suspend_thread.next;
;;;1024           while (n != &(event->parent.suspend_thread))
;;;1025           {
;;;1026               /* get thread */
;;;1027               thread = rt_list_entry(n, struct rt_thread, tlist);
;;;1028   
;;;1029               status = -RT_ERROR;
;;;1030               if (thread->event_info & RT_EVENT_FLAG_AND)
;;;1031               {
;;;1032                   if ((thread->event_set & event->set) == thread->event_set)
;;;1033                   {
;;;1034                       /* received an AND event */
;;;1035                       status = RT_EOK;
;;;1036                   }
;;;1037               }
;;;1038               else if (thread->event_info & RT_EVENT_FLAG_OR)
;;;1039               {
;;;1040                   if (thread->event_set & event->set)
;;;1041                   {
;;;1042                       /* save recieved event set */
;;;1043                       thread->event_set = thread->event_set & event->set;
;;;1044   
;;;1045                       /* received an OR event */
;;;1046                       status = RT_EOK;
;;;1047                   }
;;;1048               }
;;;1049   
;;;1050               /* move node to the next */
;;;1051               n = n->next;
;;;1052   
;;;1053               /* condition is satisfied, resume thread */
;;;1054               if (status == RT_EOK)
;;;1055               {
;;;1056                   /* clear event */
;;;1057                   if (thread->event_info & RT_EVENT_FLAG_CLEAR)
;;;1058                       event->set &= ~thread->event_set;
;;;1059   
;;;1060                   /* resume thread, and thread list breaks out */
;;;1061                   rt_thread_resume(thread);
;;;1062   
;;;1063                   /* need do a scheduling */
;;;1064                   need_schedule = RT_TRUE;
;;;1065               }
;;;1066           }
;;;1067       }
;;;1068   
;;;1069       /* enable interrupt */
;;;1070       rt_hw_interrupt_enable(level);
;;;1071   
;;;1072       /* do a schedule */
;;;1073       if (need_schedule == RT_TRUE)
;;;1074           rt_schedule();
;;;1075   
;;;1076       return RT_EOK;
;;;1077   }
00002a  bdfe              POP      {r1-r7,pc}
                  |L7.44|
00002c  6965              LDR      r5,[r4,#0x14]         ;1024
00002e  e024              B        |L7.122|
                  |L7.48|
000030  4628              MOV      r0,r5                 ;1027
000032  3814              SUBS     r0,r0,#0x14           ;1027
000034  462a              MOV      r2,r5                 ;1030
000036  322c              ADDS     r2,r2,#0x2c           ;1030
000038  4613              MOV      r3,r2                 ;1030
00003a  2100              MOVS     r1,#0                 ;1029
00003c  7812              LDRB     r2,[r2,#0]            ;1030
00003e  43c9              MVNS     r1,r1                 ;1029
000040  07d7              LSLS     r7,r2,#31             ;1030
000042  d005              BEQ      |L7.80|
000044  6bc2              LDR      r2,[r0,#0x3c]         ;1032
000046  69e7              LDR      r7,[r4,#0x1c]         ;1032
000048  43ba              BICS     r2,r2,r7              ;1032
00004a  d109              BNE      |L7.96|
                  |L7.76|
00004c  2100              MOVS     r1,#0                 ;1035
00004e  e007              B        |L7.96|
                  |L7.80|
000050  0792              LSLS     r2,r2,#30             ;1038
000052  d505              BPL      |L7.96|
000054  6bc2              LDR      r2,[r0,#0x3c]         ;1040
000056  69e7              LDR      r7,[r4,#0x1c]         ;1040
000058  403a              ANDS     r2,r2,r7              ;1040
00005a  d001              BEQ      |L7.96|
00005c  63c2              STR      r2,[r0,#0x3c]         ;1046
00005e  e7f5              B        |L7.76|
                  |L7.96|
000060  682d              LDR      r5,[r5,#0]            ;1051
000062  2900              CMP      r1,#0                 ;1054
000064  d109              BNE      |L7.122|
000066  7819              LDRB     r1,[r3,#0]            ;1057
000068  0749              LSLS     r1,r1,#29             ;1057
00006a  d503              BPL      |L7.116|
00006c  69e1              LDR      r1,[r4,#0x1c]         ;1058
00006e  6bc2              LDR      r2,[r0,#0x3c]         ;1058
000070  4391              BICS     r1,r1,r2              ;1058
000072  61e1              STR      r1,[r4,#0x1c]         ;1058
                  |L7.116|
000074  f7fffffe          BL       rt_thread_resume
000078  2601              MOVS     r6,#1                 ;1064
                  |L7.122|
00007a  9800              LDR      r0,[sp,#0]            ;1024
00007c  4285              CMP      r5,r0                 ;1024
00007e  d1d7              BNE      |L7.48|
                  |L7.128|
000080  9801              LDR      r0,[sp,#4]            ;1070
000082  f7fffffe          BL       rt_hw_interrupt_enable
000086  2e00              CMP      r6,#0                 ;1073
000088  d001              BEQ      |L7.142|
00008a  f7fffffe          BL       rt_schedule
                  |L7.142|
00008e  2000              MOVS     r0,#0                 ;1076
000090  bdfe              POP      {r1-r7,pc}
;;;1078   RTM_EXPORT(rt_event_send);
                          ENDP


                          AREA ||i.rt_ipc_list_resume||, CODE, READONLY, ALIGN=1

                  rt_ipc_list_resume PROC
;;;145     */
;;;146    rt_inline rt_err_t rt_ipc_list_resume(rt_list_t *list)
000000  b510              PUSH     {r4,lr}
;;;147    {
;;;148        struct rt_thread *thread;
;;;149    
;;;150        /* get thread entry */
;;;151        thread = rt_list_entry(list->next, struct rt_thread, tlist);
000002  6800              LDR      r0,[r0,#0]
000004  3814              SUBS     r0,r0,#0x14
;;;152    
;;;153        RT_DEBUG_LOG(RT_DEBUG_IPC, ("resume thread:%s\n", thread->name));
;;;154    
;;;155        /* resume it */
;;;156        rt_thread_resume(thread);
000006  f7fffffe          BL       rt_thread_resume
;;;157    
;;;158        return RT_EOK;
00000a  2000              MOVS     r0,#0
;;;159    }
00000c  bd10              POP      {r4,pc}
;;;160    
                          ENDP


                          AREA ||i.rt_ipc_list_resume_all||, CODE, READONLY, ALIGN=1

                  rt_ipc_list_resume_all PROC
;;;168     */
;;;169    rt_inline rt_err_t rt_ipc_list_resume_all(rt_list_t *list)
000000  b570              PUSH     {r4-r6,lr}
;;;170    {
;;;171        struct rt_thread *thread;
;;;172        register rt_ubase_t temp;
;;;173    
;;;174        /* wakeup all suspend threads */
;;;175        while (!rt_list_isempty(list))
;;;176        {
;;;177            /* disable interrupt */
;;;178            temp = rt_hw_interrupt_disable();
;;;179    
;;;180            /* get next suspend thread */
;;;181            thread = rt_list_entry(list->next, struct rt_thread, tlist);
;;;182            /* set error code to RT_ERROR */
;;;183            thread->error = -RT_ERROR;
000002  2600              MOVS     r6,#0
000004  4605              MOV      r5,r0                 ;170
000006  43f6              MVNS     r6,r6
000008  e00a              B        |L9.32|
                  |L9.10|
00000a  f7fffffe          BL       rt_hw_interrupt_disable
00000e  4604              MOV      r4,r0                 ;178
000010  6828              LDR      r0,[r5,#0]
000012  61c6              STR      r6,[r0,#0x1c]
000014  3814              SUBS     r0,r0,#0x14
;;;184    
;;;185            /*
;;;186             * resume thread
;;;187             * In rt_thread_resume function, it will remove current thread from
;;;188             * suspend list
;;;189             */
;;;190            rt_thread_resume(thread);
000016  f7fffffe          BL       rt_thread_resume
;;;191    
;;;192            /* enable interrupt */
;;;193            rt_hw_interrupt_enable(temp);
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       rt_hw_interrupt_enable
                  |L9.32|
000020  4628              MOV      r0,r5                 ;175
000022  f7fffffe          BL       rt_list_isempty
000026  2800              CMP      r0,#0                 ;175
000028  d0ef              BEQ      |L9.10|
;;;194        }
;;;195    
;;;196        return RT_EOK;
00002a  2000              MOVS     r0,#0
;;;197    }
00002c  bd70              POP      {r4-r6,pc}
;;;198    
                          ENDP


                          AREA ||i.rt_ipc_list_suspend||, CODE, READONLY, ALIGN=1

                  rt_ipc_list_suspend PROC
;;;91      */
;;;92     rt_inline rt_err_t rt_ipc_list_suspend(rt_list_t        *list,
000000  b5f8              PUSH     {r3-r7,lr}
;;;93                                            struct rt_thread *thread,
;;;94                                            rt_uint8_t        flag)
;;;95     {
000002  4605              MOV      r5,r0
000004  4614              MOV      r4,r2
000006  460e              MOV      r6,r1
;;;96         /* suspend thread */
;;;97         rt_thread_suspend(thread);
000008  4608              MOV      r0,r1
00000a  f7fffffe          BL       rt_thread_suspend
;;;98     
;;;99         switch (flag)
;;;100        {
;;;101        case RT_IPC_FLAG_FIFO:
;;;102            rt_list_insert_before(list, &(thread->tlist));
00000e  4637              MOV      r7,r6
000010  3714              ADDS     r7,r7,#0x14
000012  2c00              CMP      r4,#0                 ;99
000014  d015              BEQ      |L10.66|
000016  2c01              CMP      r4,#1                 ;99
000018  d117              BNE      |L10.74|
;;;103            break;
;;;104    
;;;105        case RT_IPC_FLAG_PRIO:
;;;106            {
;;;107                struct rt_list_node *n;
;;;108                struct rt_thread *sthread;
;;;109    
;;;110                /* find a suitable position */
;;;111                for (n = list->next; n != list; n = n->next)
00001a  3620              ADDS     r6,r6,#0x20
00001c  682c              LDR      r4,[r5,#0]
00001e  e00c              B        |L10.58|
                  |L10.32|
;;;112                {
;;;113                    sthread = rt_list_entry(n, struct rt_thread, tlist);
;;;114    
;;;115                    /* find out */
;;;116                    if (thread->current_priority < sthread->current_priority)
000020  2121              MOVS     r1,#0x21
000022  4620              MOV      r0,r4                 ;113
000024  7d72              LDRB     r2,[r6,#0x15]
000026  5d09              LDRB     r1,[r1,r4]
000028  3814              SUBS     r0,r0,#0x14           ;113
00002a  428a              CMP      r2,r1
00002c  d204              BCS      |L10.56|
00002e  4639              MOV      r1,r7
000030  3014              ADDS     r0,r0,#0x14
;;;117                    {
;;;118                        /* insert this thread before the sthread */
;;;119                        rt_list_insert_before(&(sthread->tlist), &(thread->tlist));
000032  f7fffffe          BL       rt_list_insert_before
;;;120                        break;
000036  e002              B        |L10.62|
                  |L10.56|
000038  6824              LDR      r4,[r4,#0]            ;111
                  |L10.58|
00003a  42ac              CMP      r4,r5                 ;111
00003c  d1f0              BNE      |L10.32|
                  |L10.62|
;;;121                    }
;;;122                }
;;;123    
;;;124                /*
;;;125                 * not found a suitable position,
;;;126                 * append to the end of suspend_thread list
;;;127                 */
;;;128                if (n == list)
00003e  42ac              CMP      r4,r5
000040  d103              BNE      |L10.74|
                  |L10.66|
000042  4639              MOV      r1,r7
;;;129                    rt_list_insert_before(list, &(thread->tlist));
000044  4628              MOV      r0,r5
000046  f7fffffe          BL       rt_list_insert_before
                  |L10.74|
;;;130            }
;;;131            break;
;;;132        }
;;;133    
;;;134        return RT_EOK;
00004a  2000              MOVS     r0,#0
;;;135    }
00004c  bdf8              POP      {r3-r7,pc}
;;;136    
                          ENDP


                          AREA ||i.rt_list_insert_before||, CODE, READONLY, ALIGN=1

                  rt_list_insert_before PROC
;;;76      */
;;;77     rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
000000  6842              LDR      r2,[r0,#4]
;;;78     {
;;;79         l->prev->next = n;
;;;80         n->prev = l->prev;
000002  6011              STR      r1,[r2,#0]
000004  6842              LDR      r2,[r0,#4]
;;;81     
;;;82         l->prev = n;
000006  604a              STR      r2,[r1,#4]
;;;83         n->next = l;
000008  6041              STR      r1,[r0,#4]
00000a  6008              STR      r0,[r1,#0]
;;;84     }
00000c  4770              BX       lr
;;;85     
                          ENDP


                          AREA ||i.rt_list_isempty||, CODE, READONLY, ALIGN=1

                  rt_list_isempty PROC
;;;102     */
;;;103    rt_inline int rt_list_isempty(const rt_list_t *l)
000000  6801              LDR      r1,[r0,#0]
;;;104    {
;;;105        return l->next == l;
000002  4281              CMP      r1,r0
000004  d101              BNE      |L12.10|
000006  2001              MOVS     r0,#1
;;;106    }
000008  4770              BX       lr
                  |L12.10|
00000a  2000              MOVS     r0,#0                 ;105
00000c  4770              BX       lr
;;;107    
                          ENDP


                          AREA ||i.rt_mb_control||, CODE, READONLY, ALIGN=1

                  rt_mb_control PROC
;;;1687    */
;;;1688   rt_err_t rt_mb_control(rt_mailbox_t mb, rt_uint8_t cmd, void *arg)
000000  b570              PUSH     {r4-r6,lr}
;;;1689   {
000002  4604              MOV      r4,r0
;;;1690       rt_ubase_t level;
;;;1691       RT_ASSERT(mb != RT_NULL);
;;;1692   
;;;1693       if (cmd == RT_IPC_CMD_RESET)
000004  2901              CMP      r1,#1
000006  d002              BEQ      |L13.14|
;;;1694       {
;;;1695           /* disable interrupt */
;;;1696           level = rt_hw_interrupt_disable();
;;;1697   
;;;1698           /* resume all waiting thread */
;;;1699           rt_ipc_list_resume_all(&(mb->parent.suspend_thread));
;;;1700           /* also resume all mailbox private suspended thread */
;;;1701           rt_ipc_list_resume_all(&(mb->suspend_sender_thread));
;;;1702   
;;;1703           /* re-init mailbox */
;;;1704           mb->entry      = 0;
;;;1705           mb->in_offset  = 0;
;;;1706           mb->out_offset = 0;
;;;1707   
;;;1708           /* enable interrupt */
;;;1709           rt_hw_interrupt_enable(level);
;;;1710   
;;;1711           rt_schedule();
;;;1712   
;;;1713           return RT_EOK;
;;;1714       }
;;;1715   
;;;1716       return -RT_ERROR;
000008  2000              MOVS     r0,#0
00000a  43c0              MVNS     r0,r0
;;;1717   }
00000c  bd70              POP      {r4-r6,pc}
                  |L13.14|
00000e  f7fffffe          BL       rt_hw_interrupt_disable
000012  4605              MOV      r5,r0                 ;1696
000014  4620              MOV      r0,r4                 ;1699
000016  3014              ADDS     r0,r0,#0x14           ;1699
000018  f7fffffe          BL       rt_ipc_list_resume_all
00001c  4620              MOV      r0,r4                 ;1701
00001e  3028              ADDS     r0,r0,#0x28           ;1701
000020  f7fffffe          BL       rt_ipc_list_resume_all
000024  2000              MOVS     r0,#0                 ;1704
000026  8460              STRH     r0,[r4,#0x22]         ;1704
000028  84a0              STRH     r0,[r4,#0x24]         ;1705
00002a  84e0              STRH     r0,[r4,#0x26]         ;1706
00002c  4628              MOV      r0,r5                 ;1709
00002e  f7fffffe          BL       rt_hw_interrupt_enable
000032  f7fffffe          BL       rt_schedule
000036  2000              MOVS     r0,#0                 ;1713
000038  bd70              POP      {r4-r6,pc}
;;;1718   RTM_EXPORT(rt_mb_control);
                          ENDP


                          AREA ||i.rt_mb_create||, CODE, READONLY, ALIGN=1

                  rt_mb_create PROC
;;;1319    */
;;;1320   rt_mailbox_t rt_mb_create(const char *name, rt_size_t size, rt_uint8_t flag)
000000  b570              PUSH     {r4-r6,lr}
;;;1321   {
000002  460d              MOV      r5,r1
;;;1322       rt_mailbox_t mb;
;;;1323   
;;;1324       RT_DEBUG_NOT_IN_INTERRUPT;
;;;1325   
;;;1326       /* allocate object */
;;;1327       mb = (rt_mailbox_t)rt_object_allocate(RT_Object_Class_MailBox, name);
000004  4601              MOV      r1,r0
000006  4616              MOV      r6,r2                 ;1321
000008  2004              MOVS     r0,#4
00000a  f7fffffe          BL       rt_object_allocate
00000e  0004              MOVS     r4,r0
;;;1328       if (mb == RT_NULL)
000010  d015              BEQ      |L14.62|
000012  4620              MOV      r0,r4
;;;1329           return mb;
;;;1330   
;;;1331       /* set parent */
;;;1332       mb->parent.parent.flag = flag;
000014  7266              STRB     r6,[r4,#9]
000016  3014              ADDS     r0,r0,#0x14
000018  61a0              STR      r0,[r4,#0x18]
;;;1333   
;;;1334       /* init ipc object */
;;;1335       rt_ipc_object_init(&(mb->parent));
;;;1336   
;;;1337       /* init mailbox */
;;;1338       mb->size     = size;
00001a  6160              STR      r0,[r4,#0x14]
00001c  b2a8              UXTH     r0,r5
00001e  8420              STRH     r0,[r4,#0x20]
;;;1339       mb->msg_pool = RT_KERNEL_MALLOC(mb->size * sizeof(rt_uint32_t));
000020  0080              LSLS     r0,r0,#2
000022  f7fffffe          BL       rt_malloc
;;;1340       if (mb->msg_pool == RT_NULL)
000026  61e0              STR      r0,[r4,#0x1c]
000028  2800              CMP      r0,#0
00002a  d009              BEQ      |L14.64|
;;;1341       {
;;;1342           /* delete mailbox object */
;;;1343           rt_object_delete(&(mb->parent.parent));
;;;1344   
;;;1345           return RT_NULL;
;;;1346       }
;;;1347       mb->entry      = 0;
00002c  2000              MOVS     r0,#0
00002e  8460              STRH     r0,[r4,#0x22]
;;;1348       mb->in_offset  = 0;
000030  84a0              STRH     r0,[r4,#0x24]
;;;1349       mb->out_offset = 0;
000032  84e0              STRH     r0,[r4,#0x26]
;;;1350   
;;;1351       /* init an additional list of sender suspend thread */
;;;1352       rt_list_init(&(mb->suspend_sender_thread));
000034  4620              MOV      r0,r4
000036  3028              ADDS     r0,r0,#0x28
000038  62e0              STR      r0,[r4,#0x2c]
;;;1353   
;;;1354       return mb;
00003a  62a0              STR      r0,[r4,#0x28]
00003c  4620              MOV      r0,r4
                  |L14.62|
;;;1355   }
00003e  bd70              POP      {r4-r6,pc}
                  |L14.64|
000040  4620              MOV      r0,r4                 ;1343
000042  f7fffffe          BL       rt_object_delete
000046  2000              MOVS     r0,#0                 ;1345
000048  bd70              POP      {r4-r6,pc}
;;;1356   RTM_EXPORT(rt_mb_create);
                          ENDP


                          AREA ||i.rt_mb_delete||, CODE, READONLY, ALIGN=1

                  rt_mb_delete PROC
;;;1364    */
;;;1365   rt_err_t rt_mb_delete(rt_mailbox_t mb)
000000  b510              PUSH     {r4,lr}
;;;1366   {
000002  4604              MOV      r4,r0
;;;1367       RT_DEBUG_NOT_IN_INTERRUPT;
;;;1368   
;;;1369       /* parameter check */
;;;1370       RT_ASSERT(mb != RT_NULL);
;;;1371   
;;;1372       /* resume all suspended thread */
;;;1373       rt_ipc_list_resume_all(&(mb->parent.suspend_thread));
000004  3014              ADDS     r0,r0,#0x14
000006  f7fffffe          BL       rt_ipc_list_resume_all
;;;1374   
;;;1375       /* also resume all mailbox private suspended thread */
;;;1376       rt_ipc_list_resume_all(&(mb->suspend_sender_thread));
00000a  4620              MOV      r0,r4
00000c  3028              ADDS     r0,r0,#0x28
00000e  f7fffffe          BL       rt_ipc_list_resume_all
;;;1377   
;;;1378   #if defined(RT_USING_MODULE) && defined(RT_USING_SLAB)
;;;1379       /* the mb object belongs to an application module */
;;;1380       if (mb->parent.parent.flag & RT_OBJECT_FLAG_MODULE)
;;;1381           rt_module_free(mb->parent.parent.module_id, mb->msg_pool);
;;;1382       else
;;;1383   #endif
;;;1384   
;;;1385       /* free mailbox pool */
;;;1386       RT_KERNEL_FREE(mb->msg_pool);
000012  69e0              LDR      r0,[r4,#0x1c]
000014  f7fffffe          BL       rt_free
;;;1387   
;;;1388       /* delete mailbox object */
;;;1389       rt_object_delete(&(mb->parent.parent));
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       rt_object_delete
;;;1390   
;;;1391       return RT_EOK;
00001e  2000              MOVS     r0,#0
;;;1392   }
000020  bd10              POP      {r4,pc}
;;;1393   RTM_EXPORT(rt_mb_delete);
                          ENDP


                          AREA ||i.rt_mb_detach||, CODE, READONLY, ALIGN=1

                  rt_mb_detach PROC
;;;1292    */
;;;1293   rt_err_t rt_mb_detach(rt_mailbox_t mb)
000000  b510              PUSH     {r4,lr}
;;;1294   {
000002  4604              MOV      r4,r0
;;;1295       /* parameter check */
;;;1296       RT_ASSERT(mb != RT_NULL);
;;;1297   
;;;1298       /* resume all suspended thread */
;;;1299       rt_ipc_list_resume_all(&(mb->parent.suspend_thread));
000004  3014              ADDS     r0,r0,#0x14
000006  f7fffffe          BL       rt_ipc_list_resume_all
;;;1300       /* also resume all mailbox private suspended thread */
;;;1301       rt_ipc_list_resume_all(&(mb->suspend_sender_thread));
00000a  4620              MOV      r0,r4
00000c  3028              ADDS     r0,r0,#0x28
00000e  f7fffffe          BL       rt_ipc_list_resume_all
;;;1302   
;;;1303       /* detach mailbox object */
;;;1304       rt_object_detach(&(mb->parent.parent));
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       rt_object_detach
;;;1305   
;;;1306       return RT_EOK;
000018  2000              MOVS     r0,#0
;;;1307   }
00001a  bd10              POP      {r4,pc}
;;;1308   RTM_EXPORT(rt_mb_detach);
                          ENDP


                          AREA ||i.rt_mb_init||, CODE, READONLY, ALIGN=1

                  rt_mb_init PROC
;;;1254    */
;;;1255   rt_err_t rt_mb_init(rt_mailbox_t mb,
000000  b5f8              PUSH     {r3-r7,lr}
;;;1256                       const char  *name,
;;;1257                       void        *msgpool,
;;;1258                       rt_size_t    size,
;;;1259                       rt_uint8_t   flag)
;;;1260   {
000002  4616              MOV      r6,r2
;;;1261       RT_ASSERT(mb != RT_NULL);
;;;1262   
;;;1263       /* init object */
;;;1264       rt_object_init(&(mb->parent.parent), RT_Object_Class_MailBox, name);
000004  460a              MOV      r2,r1
000006  461d              MOV      r5,r3                 ;1260
000008  4604              MOV      r4,r0                 ;1260
00000a  2104              MOVS     r1,#4
00000c  9f06              LDR      r7,[sp,#0x18]
00000e  f7fffffe          BL       rt_object_init
000012  4620              MOV      r0,r4
;;;1265   
;;;1266       /* set parent flag */
;;;1267       mb->parent.parent.flag = flag;
000014  7267              STRB     r7,[r4,#9]
000016  3014              ADDS     r0,r0,#0x14
000018  61a0              STR      r0,[r4,#0x18]
;;;1268   
;;;1269       /* init ipc object */
;;;1270       rt_ipc_object_init(&(mb->parent));
;;;1271   
;;;1272       /* init mailbox */
;;;1273       mb->msg_pool   = msgpool;
;;;1274       mb->size       = size;
00001a  61e6              STR      r6,[r4,#0x1c]
00001c  6160              STR      r0,[r4,#0x14]
00001e  8425              STRH     r5,[r4,#0x20]
;;;1275       mb->entry      = 0;
000020  2000              MOVS     r0,#0
000022  8460              STRH     r0,[r4,#0x22]
;;;1276       mb->in_offset  = 0;
000024  84a0              STRH     r0,[r4,#0x24]
;;;1277       mb->out_offset = 0;
000026  84e0              STRH     r0,[r4,#0x26]
000028  3428              ADDS     r4,r4,#0x28
00002a  6064              STR      r4,[r4,#4]
00002c  6024              STR      r4,[r4,#0]
;;;1278   
;;;1279       /* init an additional list of sender suspend thread */
;;;1280       rt_list_init(&(mb->suspend_sender_thread));
;;;1281   
;;;1282       return RT_EOK;
;;;1283   }
00002e  bdf8              POP      {r3-r7,pc}
;;;1284   RTM_EXPORT(rt_mb_init);
                          ENDP


                          AREA ||i.rt_mb_recv||, CODE, READONLY, ALIGN=1

                  rt_mb_recv PROC
;;;1552    */
;;;1553   rt_err_t rt_mb_recv(rt_mailbox_t mb, rt_uint32_t *value, rt_int32_t timeout)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;1554   {
000002  b082              SUB      sp,sp,#8
000004  4604              MOV      r4,r0
;;;1555       struct rt_thread *thread;
;;;1556       register rt_ubase_t temp;
;;;1557       rt_uint32_t tick_delta;
;;;1558   
;;;1559       /* parameter check */
;;;1560       RT_ASSERT(mb != RT_NULL);
;;;1561   
;;;1562       /* initialize delta tick */
;;;1563       tick_delta = 0;
000006  2600              MOVS     r6,#0
;;;1564       /* get current thread */
;;;1565       thread = rt_thread_self();
000008  f7fffffe          BL       rt_thread_self
00000c  4605              MOV      r5,r0
;;;1566   
;;;1567       RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(mb->parent.parent)));
;;;1568   
;;;1569       /* disable interrupt */
;;;1570       temp = rt_hw_interrupt_disable();
00000e  f7fffffe          BL       rt_hw_interrupt_disable
;;;1571   
;;;1572       /* for non-blocking call */
;;;1573       if (mb->entry == 0 && timeout == 0)
000012  9000              STR      r0,[sp,#0]
000014  8c60              LDRH     r0,[r4,#0x22]
000016  9904              LDR      r1,[sp,#0x10]
000018  2700              MOVS     r7,#0
00001a  4308              ORRS     r0,r0,r1
00001c  2800              CMP      r0,#0
00001e  d135              BNE      |L18.140|
;;;1574       {
;;;1575           rt_hw_interrupt_enable(temp);
000020  9800              LDR      r0,[sp,#0]
000022  f7fffffe          BL       rt_hw_interrupt_enable
;;;1576   
;;;1577           return -RT_ETIMEOUT;
000026  1eb0              SUBS     r0,r6,#2
                  |L18.40|
;;;1578       }
;;;1579   
;;;1580       /* mailbox is empty */
;;;1581       while (mb->entry == 0)
;;;1582       {
;;;1583           /* reset error number in thread */
;;;1584           thread->error = RT_EOK;
;;;1585   
;;;1586           /* no waiting, return timeout */
;;;1587           if (timeout == 0)
;;;1588           {
;;;1589               /* enable interrupt */
;;;1590               rt_hw_interrupt_enable(temp);
;;;1591   
;;;1592               thread->error = -RT_ETIMEOUT;
;;;1593   
;;;1594               return -RT_ETIMEOUT;
;;;1595           }
;;;1596   
;;;1597           RT_DEBUG_IN_THREAD_CONTEXT;
;;;1598           /* suspend current thread */
;;;1599           rt_ipc_list_suspend(&(mb->parent.suspend_thread),
;;;1600                               thread,
;;;1601                               mb->parent.parent.flag);
;;;1602   
;;;1603           /* has waiting time, start thread timer */
;;;1604           if (timeout > 0)
;;;1605           {
;;;1606               /* get the start tick of timer */
;;;1607               tick_delta = rt_tick_get();
;;;1608   
;;;1609               RT_DEBUG_LOG(RT_DEBUG_IPC, ("mb_recv: start timer of thread:%s\n",
;;;1610                                           thread->name));
;;;1611   
;;;1612               /* reset the timeout of thread timer and start it */
;;;1613               rt_timer_control(&(thread->thread_timer),
;;;1614                                RT_TIMER_CTRL_SET_TIME,
;;;1615                                &timeout);
;;;1616               rt_timer_start(&(thread->thread_timer));
;;;1617           }
;;;1618   
;;;1619           /* enable interrupt */
;;;1620           rt_hw_interrupt_enable(temp);
;;;1621   
;;;1622           /* re-schedule */
;;;1623           rt_schedule();
;;;1624   
;;;1625           /* resume from suspend state */
;;;1626           if (thread->error != RT_EOK)
;;;1627           {
;;;1628               /* return error */
;;;1629               return thread->error;
;;;1630           }
;;;1631   
;;;1632           /* disable interrupt */
;;;1633           temp = rt_hw_interrupt_disable();
;;;1634   
;;;1635           /* if it's not waiting forever and then re-calculate timeout tick */
;;;1636           if (timeout > 0)
;;;1637           {
;;;1638               tick_delta = rt_tick_get() - tick_delta;
;;;1639               timeout -= tick_delta;
;;;1640               if (timeout < 0)
;;;1641                   timeout = 0;
;;;1642           }
;;;1643       }
;;;1644   
;;;1645       /* fill ptr */
;;;1646       *value = mb->msg_pool[mb->out_offset];
;;;1647   
;;;1648       /* increase output offset */
;;;1649       ++ mb->out_offset;
;;;1650       if (mb->out_offset >= mb->size)
;;;1651           mb->out_offset = 0;
;;;1652       /* decrease message entry */
;;;1653       mb->entry --;
;;;1654   
;;;1655       /* resume suspended thread */
;;;1656       if (!rt_list_isempty(&(mb->suspend_sender_thread)))
;;;1657       {
;;;1658           rt_ipc_list_resume(&(mb->suspend_sender_thread));
;;;1659   
;;;1660           /* enable interrupt */
;;;1661           rt_hw_interrupt_enable(temp);
;;;1662   
;;;1663           RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mb->parent.parent)));
;;;1664   
;;;1665           rt_schedule();
;;;1666   
;;;1667           return RT_EOK;
;;;1668       }
;;;1669   
;;;1670       /* enable interrupt */
;;;1671       rt_hw_interrupt_enable(temp);
;;;1672   
;;;1673       RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mb->parent.parent)));
;;;1674   
;;;1675       return RT_EOK;
;;;1676   }
000028  b005              ADD      sp,sp,#0x14
00002a  bdf0              POP      {r4-r7,pc}
                  |L18.44|
00002c  632f              STR      r7,[r5,#0x30]         ;1587
00002e  9804              LDR      r0,[sp,#0x10]         ;1587
000030  2800              CMP      r0,#0                 ;1587
000032  d04b              BEQ      |L18.204|
000034  4620              MOV      r0,r4                 ;1599
000036  7a62              LDRB     r2,[r4,#9]            ;1599
000038  4629              MOV      r1,r5                 ;1599
00003a  3014              ADDS     r0,r0,#0x14           ;1599
00003c  f7fffffe          BL       rt_ipc_list_suspend
000040  9804              LDR      r0,[sp,#0x10]         ;1604
000042  2800              CMP      r0,#0                 ;1604
000044  dd0c              BLE      |L18.96|
000046  f7fffffe          BL       rt_tick_get
00004a  4606              MOV      r6,r0                 ;1607
00004c  4628              MOV      r0,r5                 ;1613
00004e  304c              ADDS     r0,r0,#0x4c           ;1613
000050  aa04              ADD      r2,sp,#0x10           ;1613
000052  2100              MOVS     r1,#0                 ;1613
000054  9001              STR      r0,[sp,#4]            ;1613
000056  f7fffffe          BL       rt_timer_control
00005a  9801              LDR      r0,[sp,#4]            ;1616
00005c  f7fffffe          BL       rt_timer_start
                  |L18.96|
000060  9800              LDR      r0,[sp,#0]            ;1620
000062  f7fffffe          BL       rt_hw_interrupt_enable
000066  f7fffffe          BL       rt_schedule
00006a  6b28              LDR      r0,[r5,#0x30]         ;1626
00006c  2800              CMP      r0,#0                 ;1626
00006e  d1db              BNE      |L18.40|
000070  f7fffffe          BL       rt_hw_interrupt_disable
000074  9000              STR      r0,[sp,#0]            ;1636
000076  9804              LDR      r0,[sp,#0x10]         ;1636
000078  2800              CMP      r0,#0                 ;1636
00007a  dd07              BLE      |L18.140|
00007c  f7fffffe          BL       rt_tick_get
000080  1b86              SUBS     r6,r0,r6              ;1638
000082  9804              LDR      r0,[sp,#0x10]         ;1639
000084  1b80              SUBS     r0,r0,r6              ;1639
000086  9004              STR      r0,[sp,#0x10]         ;1640
000088  d500              BPL      |L18.140|
00008a  9704              STR      r7,[sp,#0x10]         ;1641
                  |L18.140|
00008c  8c60              LDRH     r0,[r4,#0x22]         ;1581
00008e  2800              CMP      r0,#0                 ;1581
000090  d0cc              BEQ      |L18.44|
000092  8ce1              LDRH     r1,[r4,#0x26]         ;1646
000094  69e0              LDR      r0,[r4,#0x1c]         ;1646
000096  0089              LSLS     r1,r1,#2              ;1646
000098  5841              LDR      r1,[r0,r1]            ;1646
00009a  9803              LDR      r0,[sp,#0xc]          ;1646
00009c  6001              STR      r1,[r0,#0]            ;1649
00009e  8ce0              LDRH     r0,[r4,#0x26]         ;1649
0000a0  1c40              ADDS     r0,r0,#1              ;1649
0000a2  b280              UXTH     r0,r0                 ;1649
0000a4  84e0              STRH     r0,[r4,#0x26]         ;1649
0000a6  8c21              LDRH     r1,[r4,#0x20]         ;1650
0000a8  4288              CMP      r0,r1                 ;1650
0000aa  d300              BCC      |L18.174|
0000ac  84e7              STRH     r7,[r4,#0x26]         ;1651
                  |L18.174|
0000ae  8c60              LDRH     r0,[r4,#0x22]         ;1653
0000b0  1e40              SUBS     r0,r0,#1              ;1653
0000b2  8460              STRH     r0,[r4,#0x22]         ;1653
0000b4  4620              MOV      r0,r4                 ;1656
0000b6  3028              ADDS     r0,r0,#0x28           ;1656
0000b8  4604              MOV      r4,r0                 ;1656
0000ba  f7fffffe          BL       rt_list_isempty
0000be  2800              CMP      r0,#0                 ;1656
0000c0  d00b              BEQ      |L18.218|
0000c2  9800              LDR      r0,[sp,#0]            ;1671
0000c4  f7fffffe          BL       rt_hw_interrupt_enable
                  |L18.200|
0000c8  2000              MOVS     r0,#0                 ;1675
0000ca  e7ad              B        |L18.40|
                  |L18.204|
0000cc  9800              LDR      r0,[sp,#0]            ;1590
0000ce  f7fffffe          BL       rt_hw_interrupt_enable
0000d2  2001              MOVS     r0,#1                 ;1592
0000d4  43c0              MVNS     r0,r0                 ;1592
0000d6  6328              STR      r0,[r5,#0x30]         ;1594
0000d8  e7a6              B        |L18.40|
                  |L18.218|
0000da  4620              MOV      r0,r4
0000dc  f7fffffe          BL       rt_ipc_list_resume
0000e0  9800              LDR      r0,[sp,#0]            ;1661
0000e2  f7fffffe          BL       rt_hw_interrupt_enable
0000e6  f7fffffe          BL       rt_schedule
0000ea  e7ed              B        |L18.200|
;;;1677   RTM_EXPORT(rt_mb_recv);
                          ENDP


                          AREA ||i.rt_mb_send||, CODE, READONLY, ALIGN=1

                  rt_mb_send PROC
;;;1536    */
;;;1537   rt_err_t rt_mb_send(rt_mailbox_t mb, rt_uint32_t value)
000000  b510              PUSH     {r4,lr}
;;;1538   {
;;;1539       return rt_mb_send_wait(mb, value, 0);
000002  2200              MOVS     r2,#0
000004  f7fffffe          BL       rt_mb_send_wait
;;;1540   }
000008  bd10              POP      {r4,pc}
;;;1541   RTM_EXPORT(rt_mb_send);
                          ENDP


                          AREA ||i.rt_mb_send_wait||, CODE, READONLY, ALIGN=1

                  rt_mb_send_wait PROC
;;;1405    */
;;;1406   rt_err_t rt_mb_send_wait(rt_mailbox_t mb,
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;1407                            rt_uint32_t  value,
;;;1408                            rt_int32_t   timeout)
;;;1409   {
000002  b082              SUB      sp,sp,#8
000004  4604              MOV      r4,r0
;;;1410       struct rt_thread *thread;
;;;1411       register rt_ubase_t temp;
;;;1412       rt_uint32_t tick_delta;
;;;1413   
;;;1414       /* parameter check */
;;;1415       RT_ASSERT(mb != RT_NULL);
;;;1416   
;;;1417       /* initialize delta tick */
;;;1418       tick_delta = 0;
000006  2600              MOVS     r6,#0
;;;1419       /* get current thread */
;;;1420       thread = rt_thread_self();
000008  f7fffffe          BL       rt_thread_self
00000c  4605              MOV      r5,r0
;;;1421   
;;;1422       RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mb->parent.parent)));
;;;1423   
;;;1424       /* disable interrupt */
;;;1425       temp = rt_hw_interrupt_disable();
00000e  f7fffffe          BL       rt_hw_interrupt_disable
;;;1426   
;;;1427       /* for non-blocking call */
;;;1428       if (mb->entry == mb->size && timeout == 0)
000012  9000              STR      r0,[sp,#0]
000014  8c60              LDRH     r0,[r4,#0x22]
000016  8c21              LDRH     r1,[r4,#0x20]
000018  2700              MOVS     r7,#0
00001a  4288              CMP      r0,r1
00001c  d133              BNE      |L20.134|
00001e  9804              LDR      r0,[sp,#0x10]
000020  2800              CMP      r0,#0
000022  d051              BEQ      |L20.200|
000024  e02f              B        |L20.134|
                  |L20.38|
;;;1429       {
;;;1430           rt_hw_interrupt_enable(temp);
;;;1431   
;;;1432           return -RT_EFULL;
;;;1433       }
;;;1434   
;;;1435       /* mailbox is full */
;;;1436       while (mb->entry == mb->size)
;;;1437       {
;;;1438           /* reset error number in thread */
;;;1439           thread->error = RT_EOK;
;;;1440   
;;;1441           /* no waiting, return timeout */
;;;1442           if (timeout == 0)
000026  632f              STR      r7,[r5,#0x30]
000028  9804              LDR      r0,[sp,#0x10]
00002a  2800              CMP      r0,#0
00002c  d04c              BEQ      |L20.200|
;;;1443           {
;;;1444               /* enable interrupt */
;;;1445               rt_hw_interrupt_enable(temp);
;;;1446   
;;;1447               return -RT_EFULL;
;;;1448           }
;;;1449   
;;;1450           RT_DEBUG_IN_THREAD_CONTEXT;
;;;1451           /* suspend current thread */
;;;1452           rt_ipc_list_suspend(&(mb->suspend_sender_thread),
00002e  4620              MOV      r0,r4
000030  7a62              LDRB     r2,[r4,#9]
000032  4629              MOV      r1,r5
000034  3028              ADDS     r0,r0,#0x28
000036  f7fffffe          BL       rt_ipc_list_suspend
;;;1453                               thread,
;;;1454                               mb->parent.parent.flag);
;;;1455   
;;;1456           /* has waiting time, start thread timer */
;;;1457           if (timeout > 0)
00003a  9804              LDR      r0,[sp,#0x10]
00003c  2800              CMP      r0,#0
00003e  dd0c              BLE      |L20.90|
;;;1458           {
;;;1459               /* get the start tick of timer */
;;;1460               tick_delta = rt_tick_get();
000040  f7fffffe          BL       rt_tick_get
000044  4606              MOV      r6,r0
;;;1461   
;;;1462               RT_DEBUG_LOG(RT_DEBUG_IPC, ("mb_send_wait: start timer of thread:%s\n",
;;;1463                                           thread->name));
;;;1464   
;;;1465               /* reset the timeout of thread timer and start it */
;;;1466               rt_timer_control(&(thread->thread_timer),
000046  4628              MOV      r0,r5
000048  304c              ADDS     r0,r0,#0x4c
00004a  aa04              ADD      r2,sp,#0x10
00004c  2100              MOVS     r1,#0
00004e  9001              STR      r0,[sp,#4]
000050  f7fffffe          BL       rt_timer_control
;;;1467                                RT_TIMER_CTRL_SET_TIME,
;;;1468                                &timeout);
;;;1469               rt_timer_start(&(thread->thread_timer));
000054  9801              LDR      r0,[sp,#4]
000056  f7fffffe          BL       rt_timer_start
                  |L20.90|
;;;1470           }
;;;1471   
;;;1472           /* enable interrupt */
;;;1473           rt_hw_interrupt_enable(temp);
00005a  9800              LDR      r0,[sp,#0]
00005c  f7fffffe          BL       rt_hw_interrupt_enable
;;;1474   
;;;1475           /* re-schedule */
;;;1476           rt_schedule();
000060  f7fffffe          BL       rt_schedule
;;;1477   
;;;1478           /* resume from suspend state */
;;;1479           if (thread->error != RT_EOK)
000064  6b28              LDR      r0,[r5,#0x30]
000066  2800              CMP      r0,#0
000068  d12c              BNE      |L20.196|
;;;1480           {
;;;1481               /* return error */
;;;1482               return thread->error;
;;;1483           }
;;;1484   
;;;1485           /* disable interrupt */
;;;1486           temp = rt_hw_interrupt_disable();
00006a  f7fffffe          BL       rt_hw_interrupt_disable
;;;1487   
;;;1488           /* if it's not waiting forever and then re-calculate timeout tick */
;;;1489           if (timeout > 0)
00006e  9000              STR      r0,[sp,#0]
000070  9804              LDR      r0,[sp,#0x10]
000072  2800              CMP      r0,#0
000074  dd07              BLE      |L20.134|
;;;1490           {
;;;1491               tick_delta = rt_tick_get() - tick_delta;
000076  f7fffffe          BL       rt_tick_get
00007a  1b86              SUBS     r6,r0,r6
;;;1492               timeout -= tick_delta;
00007c  9804              LDR      r0,[sp,#0x10]
00007e  1b80              SUBS     r0,r0,r6
;;;1493               if (timeout < 0)
000080  9004              STR      r0,[sp,#0x10]
000082  d500              BPL      |L20.134|
;;;1494                   timeout = 0;
000084  9704              STR      r7,[sp,#0x10]
                  |L20.134|
000086  8c60              LDRH     r0,[r4,#0x22]         ;1436
000088  8c21              LDRH     r1,[r4,#0x20]         ;1436
00008a  4288              CMP      r0,r1                 ;1436
00008c  d0cb              BEQ      |L20.38|
;;;1495           }
;;;1496       }
;;;1497   
;;;1498       /* set ptr */
;;;1499       mb->msg_pool[mb->in_offset] = value;
00008e  8ca2              LDRH     r2,[r4,#0x24]
000090  69e1              LDR      r1,[r4,#0x1c]
000092  9803              LDR      r0,[sp,#0xc]
000094  0092              LSLS     r2,r2,#2
000096  5088              STR      r0,[r1,r2]
;;;1500       /* increase input offset */
;;;1501       ++ mb->in_offset;
000098  8ca0              LDRH     r0,[r4,#0x24]
00009a  1c40              ADDS     r0,r0,#1
00009c  b280              UXTH     r0,r0
00009e  84a0              STRH     r0,[r4,#0x24]
;;;1502       if (mb->in_offset >= mb->size)
0000a0  8c21              LDRH     r1,[r4,#0x20]
0000a2  4288              CMP      r0,r1
0000a4  d300              BCC      |L20.168|
;;;1503           mb->in_offset = 0;
0000a6  84a7              STRH     r7,[r4,#0x24]
                  |L20.168|
;;;1504       /* increase message entry */
;;;1505       mb->entry ++;
0000a8  8c60              LDRH     r0,[r4,#0x22]
0000aa  1c40              ADDS     r0,r0,#1
0000ac  8460              STRH     r0,[r4,#0x22]
;;;1506   
;;;1507       /* resume suspended thread */
;;;1508       if (!rt_list_isempty(&mb->parent.suspend_thread))
0000ae  4620              MOV      r0,r4
0000b0  3014              ADDS     r0,r0,#0x14
0000b2  4604              MOV      r4,r0
0000b4  f7fffffe          BL       rt_list_isempty
0000b8  2800              CMP      r0,#0
0000ba  d00b              BEQ      |L20.212|
;;;1509       {
;;;1510           rt_ipc_list_resume(&(mb->parent.suspend_thread));
;;;1511   
;;;1512           /* enable interrupt */
;;;1513           rt_hw_interrupt_enable(temp);
;;;1514   
;;;1515           rt_schedule();
;;;1516   
;;;1517           return RT_EOK;
;;;1518       }
;;;1519   
;;;1520       /* enable interrupt */
;;;1521       rt_hw_interrupt_enable(temp);
0000bc  9800              LDR      r0,[sp,#0]
0000be  f7fffffe          BL       rt_hw_interrupt_enable
                  |L20.194|
;;;1522   
;;;1523       return RT_EOK;
0000c2  2000              MOVS     r0,#0
                  |L20.196|
;;;1524   }
0000c4  b005              ADD      sp,sp,#0x14
0000c6  bdf0              POP      {r4-r7,pc}
                  |L20.200|
0000c8  9800              LDR      r0,[sp,#0]            ;1445
0000ca  f7fffffe          BL       rt_hw_interrupt_enable
0000ce  2002              MOVS     r0,#2                 ;1447
0000d0  43c0              MVNS     r0,r0                 ;1447
0000d2  e7f7              B        |L20.196|
                  |L20.212|
0000d4  4620              MOV      r0,r4
0000d6  f7fffffe          BL       rt_ipc_list_resume
0000da  9800              LDR      r0,[sp,#0]            ;1513
0000dc  f7fffffe          BL       rt_hw_interrupt_enable
0000e0  f7fffffe          BL       rt_schedule
0000e4  e7ed              B        |L20.194|
;;;1525   RTM_EXPORT(rt_mb_send_wait);
                          ENDP


                          AREA ||i.rt_mq_control||, CODE, READONLY, ALIGN=1

                  rt_mq_control PROC
;;;2235    */
;;;2236   rt_err_t rt_mq_control(rt_mq_t mq, rt_uint8_t cmd, void *arg)
000000  b570              PUSH     {r4-r6,lr}
;;;2237   {
000002  4604              MOV      r4,r0
;;;2238       rt_ubase_t level;
;;;2239       struct rt_mq_message *msg;
;;;2240   
;;;2241       RT_ASSERT(mq != RT_NULL);
;;;2242   
;;;2243       if (cmd == RT_IPC_CMD_RESET)
000004  2901              CMP      r1,#1
000006  d002              BEQ      |L21.14|
;;;2244       {
;;;2245           /* disable interrupt */
;;;2246           level = rt_hw_interrupt_disable();
;;;2247   
;;;2248           /* resume all waiting thread */
;;;2249           rt_ipc_list_resume_all(&mq->parent.suspend_thread);
;;;2250   
;;;2251           /* release all message in the queue */
;;;2252           while (mq->msg_queue_head != RT_NULL)
;;;2253           {
;;;2254               /* get message from queue */
;;;2255               msg = (struct rt_mq_message *)mq->msg_queue_head;
;;;2256   
;;;2257               /* move message queue head */
;;;2258               mq->msg_queue_head = msg->next;
;;;2259               /* reach queue tail, set to NULL */
;;;2260               if (mq->msg_queue_tail == msg)
;;;2261                   mq->msg_queue_tail = RT_NULL;
;;;2262   
;;;2263               /* put message to free list */
;;;2264               msg->next = (struct rt_mq_message *)mq->msg_queue_free;
;;;2265               mq->msg_queue_free = msg;
;;;2266           }
;;;2267   
;;;2268           /* clean entry */
;;;2269           mq->entry = 0;
;;;2270   
;;;2271           /* enable interrupt */
;;;2272           rt_hw_interrupt_enable(level);
;;;2273   
;;;2274           rt_schedule();
;;;2275   
;;;2276           return RT_EOK;
;;;2277       }
;;;2278   
;;;2279       return -RT_ERROR;
000008  2000              MOVS     r0,#0
00000a  43c0              MVNS     r0,r0
;;;2280   }
00000c  bd70              POP      {r4-r6,pc}
                  |L21.14|
00000e  f7fffffe          BL       rt_hw_interrupt_disable
000012  4605              MOV      r5,r0                 ;2246
000014  4620              MOV      r0,r4                 ;2249
000016  3014              ADDS     r0,r0,#0x14           ;2249
000018  f7fffffe          BL       rt_ipc_list_resume_all
00001c  2100              MOVS     r1,#0                 ;2249
00001e  e008              B        |L21.50|
                  |L21.32|
000020  6802              LDR      r2,[r0,#0]            ;2258
000022  62a2              STR      r2,[r4,#0x28]         ;2260
000024  6ae2              LDR      r2,[r4,#0x2c]         ;2260
000026  4282              CMP      r2,r0                 ;2260
000028  d100              BNE      |L21.44|
00002a  62e1              STR      r1,[r4,#0x2c]         ;2261
                  |L21.44|
00002c  6b22              LDR      r2,[r4,#0x30]         ;2264
00002e  6002              STR      r2,[r0,#0]            ;2265
000030  6320              STR      r0,[r4,#0x30]         ;2265
                  |L21.50|
000032  6aa0              LDR      r0,[r4,#0x28]         ;2252
000034  2800              CMP      r0,#0                 ;2252
000036  d1f3              BNE      |L21.32|
000038  84a1              STRH     r1,[r4,#0x24]         ;2269
00003a  4628              MOV      r0,r5                 ;2272
00003c  f7fffffe          BL       rt_hw_interrupt_enable
000040  f7fffffe          BL       rt_schedule
000044  2000              MOVS     r0,#0                 ;2276
000046  bd70              POP      {r4-r6,pc}
;;;2281   RTM_EXPORT(rt_mq_control);
                          ENDP


                          AREA ||i.rt_mq_create||, CODE, READONLY, ALIGN=2

                  rt_mq_create PROC
;;;1822    */
;;;1823   rt_mq_t rt_mq_create(const char *name,
000000  b5f8              PUSH     {r3-r7,lr}
;;;1824                        rt_size_t   msg_size,
;;;1825                        rt_size_t   max_msgs,
;;;1826                        rt_uint8_t  flag)
;;;1827   {
000002  460e              MOV      r6,r1
;;;1828       struct rt_messagequeue *mq;
;;;1829       struct rt_mq_message *head;
;;;1830       register rt_base_t temp;
;;;1831   
;;;1832       RT_DEBUG_NOT_IN_INTERRUPT;
;;;1833   
;;;1834       /* allocate object */
;;;1835       mq = (rt_mq_t)rt_object_allocate(RT_Object_Class_MessageQueue, name);
000004  4601              MOV      r1,r0
000006  461f              MOV      r7,r3                 ;1827
000008  4615              MOV      r5,r2                 ;1827
00000a  2005              MOVS     r0,#5
00000c  f7fffffe          BL       rt_object_allocate
000010  0004              MOVS     r4,r0
;;;1836       if (mq == RT_NULL)
000012  d01b              BEQ      |L22.76|
000014  4620              MOV      r0,r4
;;;1837           return mq;
;;;1838   
;;;1839       /* set parent */
;;;1840       mq->parent.parent.flag = flag;
000016  7267              STRB     r7,[r4,#9]
000018  3014              ADDS     r0,r0,#0x14
00001a  61a0              STR      r0,[r4,#0x18]
;;;1841   
;;;1842       /* init ipc object */
;;;1843       rt_ipc_object_init(&(mq->parent));
;;;1844   
;;;1845       /* init message queue */
;;;1846   
;;;1847       /* get correct message size */
;;;1848       mq->msg_size = RT_ALIGN(msg_size, RT_ALIGN_SIZE);
00001c  6160              STR      r0,[r4,#0x14]
00001e  4913              LDR      r1,|L22.108|
000020  1cf0              ADDS     r0,r6,#3
000022  4008              ANDS     r0,r0,r1
000024  8420              STRH     r0,[r4,#0x20]
;;;1849       mq->max_msgs = max_msgs;
000026  b2a9              UXTH     r1,r5
000028  1d00              ADDS     r0,r0,#4
00002a  8461              STRH     r1,[r4,#0x22]
;;;1850   
;;;1851       /* allocate message pool */
;;;1852       mq->msg_pool = RT_KERNEL_MALLOC((mq->msg_size + sizeof(struct rt_mq_message))* mq->max_msgs);
00002c  4348              MULS     r0,r1,r0
00002e  f7fffffe          BL       rt_malloc
;;;1853       if (mq->msg_pool == RT_NULL)
000032  61e0              STR      r0,[r4,#0x1c]
000034  2800              CMP      r0,#0
000036  d005              BEQ      |L22.68|
;;;1854       {
;;;1855           rt_mq_delete(mq);
;;;1856   
;;;1857           return RT_NULL;
;;;1858       }
;;;1859   
;;;1860       /* init message list */
;;;1861       mq->msg_queue_head = RT_NULL;
000038  2200              MOVS     r2,#0
;;;1862       mq->msg_queue_tail = RT_NULL;
00003a  62a2              STR      r2,[r4,#0x28]
;;;1863   
;;;1864       /* init message empty list */
;;;1865       mq->msg_queue_free = RT_NULL;
00003c  62e2              STR      r2,[r4,#0x2c]
;;;1866       for (temp = 0; temp < mq->max_msgs; temp ++)
00003e  4610              MOV      r0,r2
000040  6322              STR      r2,[r4,#0x30]
000042  e00d              B        |L22.96|
                  |L22.68|
000044  4620              MOV      r0,r4                 ;1855
000046  f7fffffe          BL       rt_mq_delete
00004a  2000              MOVS     r0,#0                 ;1857
                  |L22.76|
;;;1867       {
;;;1868           head = (struct rt_mq_message *)((rt_uint8_t *)mq->msg_pool +
;;;1869                  temp * (mq->msg_size + sizeof(struct rt_mq_message)));
;;;1870           head->next = mq->msg_queue_free;
;;;1871           mq->msg_queue_free = head;
;;;1872       }
;;;1873   
;;;1874       /* the initial entry is zero */
;;;1875       mq->entry = 0;
;;;1876   
;;;1877       return mq;
;;;1878   }
00004c  bdf8              POP      {r3-r7,pc}
                  |L22.78|
00004e  8c21              LDRH     r1,[r4,#0x20]         ;1868
000050  69e3              LDR      r3,[r4,#0x1c]         ;1868
000052  1d09              ADDS     r1,r1,#4              ;1868
000054  4341              MULS     r1,r0,r1              ;1868
000056  1859              ADDS     r1,r3,r1              ;1868
000058  6b23              LDR      r3,[r4,#0x30]         ;1870
00005a  600b              STR      r3,[r1,#0]            ;1871
00005c  1c40              ADDS     r0,r0,#1              ;1871
00005e  6321              STR      r1,[r4,#0x30]         ;1871
                  |L22.96|
000060  8c61              LDRH     r1,[r4,#0x22]         ;1866
000062  4281              CMP      r1,r0                 ;1866
000064  dcf3              BGT      |L22.78|
000066  84a2              STRH     r2,[r4,#0x24]         ;1875
000068  4620              MOV      r0,r4                 ;1877
00006a  bdf8              POP      {r3-r7,pc}
;;;1879   RTM_EXPORT(rt_mq_create);
                          ENDP

                  |L22.108|
                          DCD      0x0000fffc

                          AREA ||i.rt_mq_delete||, CODE, READONLY, ALIGN=1

                  rt_mq_delete PROC
;;;1887    */
;;;1888   rt_err_t rt_mq_delete(rt_mq_t mq)
000000  b510              PUSH     {r4,lr}
;;;1889   {
000002  4604              MOV      r4,r0
;;;1890       RT_DEBUG_NOT_IN_INTERRUPT;
;;;1891   
;;;1892       /* parameter check */
;;;1893       RT_ASSERT(mq != RT_NULL);
;;;1894   
;;;1895       /* resume all suspended thread */
;;;1896       rt_ipc_list_resume_all(&(mq->parent.suspend_thread));
000004  3014              ADDS     r0,r0,#0x14
000006  f7fffffe          BL       rt_ipc_list_resume_all
;;;1897   
;;;1898   #if defined(RT_USING_MODULE) && defined(RT_USING_SLAB)
;;;1899       /* the mq object belongs to an application module */
;;;1900       if (mq->parent.parent.flag & RT_OBJECT_FLAG_MODULE)
;;;1901           rt_module_free(mq->parent.parent.module_id, mq->msg_pool);
;;;1902       else
;;;1903   #endif
;;;1904   
;;;1905       /* free message queue pool */
;;;1906       RT_KERNEL_FREE(mq->msg_pool);
00000a  69e0              LDR      r0,[r4,#0x1c]
00000c  f7fffffe          BL       rt_free
;;;1907   
;;;1908       /* delete message queue object */
;;;1909       rt_object_delete(&(mq->parent.parent));
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       rt_object_delete
;;;1910   
;;;1911       return RT_EOK;
000016  2000              MOVS     r0,#0
;;;1912   }
000018  bd10              POP      {r4,pc}
;;;1913   RTM_EXPORT(rt_mq_delete);
                          ENDP


                          AREA ||i.rt_mq_detach||, CODE, READONLY, ALIGN=1

                  rt_mq_detach PROC
;;;1796    */
;;;1797   rt_err_t rt_mq_detach(rt_mq_t mq)
000000  b510              PUSH     {r4,lr}
;;;1798   {
000002  4604              MOV      r4,r0
;;;1799       /* parameter check */
;;;1800       RT_ASSERT(mq != RT_NULL);
;;;1801   
;;;1802       /* resume all suspended thread */
;;;1803       rt_ipc_list_resume_all(&mq->parent.suspend_thread);
000004  3014              ADDS     r0,r0,#0x14
000006  f7fffffe          BL       rt_ipc_list_resume_all
;;;1804   
;;;1805       /* detach message queue object */
;;;1806       rt_object_detach(&(mq->parent.parent));
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       rt_object_detach
;;;1807   
;;;1808       return RT_EOK;
000010  2000              MOVS     r0,#0
;;;1809   }
000012  bd10              POP      {r4,pc}
;;;1810   RTM_EXPORT(rt_mq_detach);
                          ENDP


                          AREA ||i.rt_mq_init||, CODE, READONLY, ALIGN=2

                  rt_mq_init PROC
;;;1739    */
;;;1740   rt_err_t rt_mq_init(rt_mq_t     mq,
000000  b5f8              PUSH     {r3-r7,lr}
;;;1741                       const char *name,
;;;1742                       void       *msgpool,
;;;1743                       rt_size_t   msg_size,
;;;1744                       rt_size_t   pool_size,
;;;1745                       rt_uint8_t  flag)
;;;1746   {
000002  4616              MOV      r6,r2
;;;1747       struct rt_mq_message *head;
;;;1748       register rt_base_t temp;
;;;1749   
;;;1750       /* parameter check */
;;;1751       RT_ASSERT(mq != RT_NULL);
;;;1752   
;;;1753       /* init object */
;;;1754       rt_object_init(&(mq->parent.parent), RT_Object_Class_MessageQueue, name);
000004  460a              MOV      r2,r1
000006  461d              MOV      r5,r3                 ;1746
000008  4604              MOV      r4,r0                 ;1746
00000a  2105              MOVS     r1,#5
00000c  9f07              LDR      r7,[sp,#0x1c]
00000e  f7fffffe          BL       rt_object_init
000012  4620              MOV      r0,r4
;;;1755   
;;;1756       /* set parent flag */
;;;1757       mq->parent.parent.flag = flag;
000014  7267              STRB     r7,[r4,#9]
000016  3014              ADDS     r0,r0,#0x14
000018  61a0              STR      r0,[r4,#0x18]
;;;1758   
;;;1759       /* init ipc object */
;;;1760       rt_ipc_object_init(&(mq->parent));
;;;1761   
;;;1762       /* set messasge pool */
;;;1763       mq->msg_pool = msgpool;
;;;1764   
;;;1765       /* get correct message size */
;;;1766       mq->msg_size = RT_ALIGN(msg_size, RT_ALIGN_SIZE);
00001a  61e6              STR      r6,[r4,#0x1c]
00001c  6160              STR      r0,[r4,#0x14]
00001e  480f              LDR      r0,|L25.92|
000020  1ce9              ADDS     r1,r5,#3
000022  4001              ANDS     r1,r1,r0
000024  8421              STRH     r1,[r4,#0x20]
;;;1767       mq->max_msgs = pool_size / (mq->msg_size + sizeof(struct rt_mq_message));
000026  1d09              ADDS     r1,r1,#4
000028  9806              LDR      r0,[sp,#0x18]
00002a  f7fffffe          BL       __aeabi_uidivmod
00002e  8460              STRH     r0,[r4,#0x22]
;;;1768   
;;;1769       /* init message list */
;;;1770       mq->msg_queue_head = RT_NULL;
000030  2200              MOVS     r2,#0
;;;1771       mq->msg_queue_tail = RT_NULL;
000032  62a2              STR      r2,[r4,#0x28]
;;;1772   
;;;1773       /* init message empty list */
;;;1774       mq->msg_queue_free = RT_NULL;
000034  62e2              STR      r2,[r4,#0x2c]
;;;1775       for (temp = 0; temp < mq->max_msgs; temp ++)
000036  4610              MOV      r0,r2
000038  6322              STR      r2,[r4,#0x30]
00003a  e008              B        |L25.78|
                  |L25.60|
;;;1776       {
;;;1777           head = (struct rt_mq_message *)((rt_uint8_t *)mq->msg_pool +
00003c  8c21              LDRH     r1,[r4,#0x20]
00003e  69e3              LDR      r3,[r4,#0x1c]
000040  1d09              ADDS     r1,r1,#4
000042  4341              MULS     r1,r0,r1
000044  1859              ADDS     r1,r3,r1
;;;1778               temp * (mq->msg_size + sizeof(struct rt_mq_message)));
;;;1779           head->next = mq->msg_queue_free;
000046  6b23              LDR      r3,[r4,#0x30]
;;;1780           mq->msg_queue_free = head;
000048  600b              STR      r3,[r1,#0]
00004a  1c40              ADDS     r0,r0,#1
00004c  6321              STR      r1,[r4,#0x30]
                  |L25.78|
00004e  8c61              LDRH     r1,[r4,#0x22]         ;1775
000050  4281              CMP      r1,r0                 ;1775
000052  dcf3              BGT      |L25.60|
;;;1781       }
;;;1782   
;;;1783       /* the initial entry is zero */
;;;1784       mq->entry = 0;
000054  84a2              STRH     r2,[r4,#0x24]
;;;1785   
;;;1786       return RT_EOK;
000056  2000              MOVS     r0,#0
;;;1787   }
000058  bdf8              POP      {r3-r7,pc}
;;;1788   RTM_EXPORT(rt_mq_init);
                          ENDP

00005a  0000              DCW      0x0000
                  |L25.92|
                          DCD      0x0000fffc

                          AREA ||i.rt_mq_recv||, CODE, READONLY, ALIGN=1

                  rt_mq_recv PROC
;;;2096    */
;;;2097   rt_err_t rt_mq_recv(rt_mq_t    mq,
000000  b5ff              PUSH     {r0-r7,lr}
;;;2098                       void      *buffer,
;;;2099                       rt_size_t  size,
;;;2100                       rt_int32_t timeout)
;;;2101   {
000002  b083              SUB      sp,sp,#0xc
000004  4604              MOV      r4,r0
;;;2102       struct rt_thread *thread;
;;;2103       register rt_ubase_t temp;
;;;2104       struct rt_mq_message *msg;
;;;2105       rt_uint32_t tick_delta;
;;;2106   
;;;2107       RT_ASSERT(mq != RT_NULL);
;;;2108       RT_ASSERT(buffer != RT_NULL);
;;;2109       RT_ASSERT(size != 0);
;;;2110   
;;;2111       /* initialize delta tick */
;;;2112       tick_delta = 0;
000006  2600              MOVS     r6,#0
;;;2113       /* get current thread */
;;;2114       thread = rt_thread_self();
000008  f7fffffe          BL       rt_thread_self
00000c  4605              MOV      r5,r0
;;;2115       RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(mq->parent.parent)));
;;;2116   
;;;2117       /* disable interrupt */
;;;2118       temp = rt_hw_interrupt_disable();
00000e  f7fffffe          BL       rt_hw_interrupt_disable
;;;2119   
;;;2120       /* for non-blocking call */
;;;2121       if (mq->entry == 0 && timeout == 0)
000012  9000              STR      r0,[sp,#0]
000014  8ca0              LDRH     r0,[r4,#0x24]
000016  9906              LDR      r1,[sp,#0x18]
000018  2700              MOVS     r7,#0
00001a  4308              ORRS     r0,r0,r1
00001c  2800              CMP      r0,#0
00001e  d135              BNE      |L26.140|
;;;2122       {
;;;2123           rt_hw_interrupt_enable(temp);
000020  9800              LDR      r0,[sp,#0]
000022  f7fffffe          BL       rt_hw_interrupt_enable
;;;2124   
;;;2125           return -RT_ETIMEOUT;
000026  1eb0              SUBS     r0,r6,#2
                  |L26.40|
;;;2126       }
;;;2127   
;;;2128       /* message queue is empty */
;;;2129       while (mq->entry == 0)
;;;2130       {
;;;2131           RT_DEBUG_IN_THREAD_CONTEXT;
;;;2132   
;;;2133           /* reset error number in thread */
;;;2134           thread->error = RT_EOK;
;;;2135   
;;;2136           /* no waiting, return timeout */
;;;2137           if (timeout == 0)
;;;2138           {
;;;2139               /* enable interrupt */
;;;2140               rt_hw_interrupt_enable(temp);
;;;2141   
;;;2142               thread->error = -RT_ETIMEOUT;
;;;2143   
;;;2144               return -RT_ETIMEOUT;
;;;2145           }
;;;2146   
;;;2147           /* suspend current thread */
;;;2148           rt_ipc_list_suspend(&(mq->parent.suspend_thread),
;;;2149                               thread,
;;;2150                               mq->parent.parent.flag);
;;;2151   
;;;2152           /* has waiting time, start thread timer */
;;;2153           if (timeout > 0)
;;;2154           {
;;;2155               /* get the start tick of timer */
;;;2156               tick_delta = rt_tick_get();
;;;2157   
;;;2158               RT_DEBUG_LOG(RT_DEBUG_IPC, ("set thread:%s to timer list\n",
;;;2159                                           thread->name));
;;;2160   
;;;2161               /* reset the timeout of thread timer and start it */
;;;2162               rt_timer_control(&(thread->thread_timer),
;;;2163                                RT_TIMER_CTRL_SET_TIME,
;;;2164                                &timeout);
;;;2165               rt_timer_start(&(thread->thread_timer));
;;;2166           }
;;;2167   
;;;2168           /* enable interrupt */
;;;2169           rt_hw_interrupt_enable(temp);
;;;2170   
;;;2171           /* re-schedule */
;;;2172           rt_schedule();
;;;2173   
;;;2174           /* recv message */
;;;2175           if (thread->error != RT_EOK)
;;;2176           {
;;;2177               /* return error */
;;;2178               return thread->error;
;;;2179           }
;;;2180   
;;;2181           /* disable interrupt */
;;;2182           temp = rt_hw_interrupt_disable();
;;;2183   
;;;2184           /* if it's not waiting forever and then re-calculate timeout tick */
;;;2185           if (timeout > 0)
;;;2186           {
;;;2187               tick_delta = rt_tick_get() - tick_delta;
;;;2188               timeout -= tick_delta;
;;;2189               if (timeout < 0)
;;;2190                   timeout = 0;
;;;2191           }
;;;2192       }
;;;2193   
;;;2194       /* get message from queue */
;;;2195       msg = (struct rt_mq_message *)mq->msg_queue_head;
;;;2196   
;;;2197       /* move message queue head */
;;;2198       mq->msg_queue_head = msg->next;
;;;2199       /* reach queue tail, set to NULL */
;;;2200       if (mq->msg_queue_tail == msg)
;;;2201           mq->msg_queue_tail = RT_NULL;
;;;2202   
;;;2203       /* decrease message entry */
;;;2204       mq->entry --;
;;;2205   
;;;2206       /* enable interrupt */
;;;2207       rt_hw_interrupt_enable(temp);
;;;2208   
;;;2209       /* copy message */
;;;2210       rt_memcpy(buffer, msg + 1, size > mq->msg_size ? mq->msg_size : size);
;;;2211   
;;;2212       /* disable interrupt */
;;;2213       temp = rt_hw_interrupt_disable();
;;;2214       /* put message to free list */
;;;2215       msg->next = (struct rt_mq_message *)mq->msg_queue_free;
;;;2216       mq->msg_queue_free = msg;
;;;2217       /* enable interrupt */
;;;2218       rt_hw_interrupt_enable(temp);
;;;2219   
;;;2220       RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mq->parent.parent)));
;;;2221   
;;;2222       return RT_EOK;
;;;2223   }
000028  b007              ADD      sp,sp,#0x1c
00002a  bdf0              POP      {r4-r7,pc}
                  |L26.44|
00002c  632f              STR      r7,[r5,#0x30]         ;2137
00002e  9806              LDR      r0,[sp,#0x18]         ;2137
000030  2800              CMP      r0,#0                 ;2137
000032  d04d              BEQ      |L26.208|
000034  4620              MOV      r0,r4                 ;2148
000036  7a62              LDRB     r2,[r4,#9]            ;2148
000038  4629              MOV      r1,r5                 ;2148
00003a  3014              ADDS     r0,r0,#0x14           ;2148
00003c  f7fffffe          BL       rt_ipc_list_suspend
000040  9806              LDR      r0,[sp,#0x18]         ;2153
000042  2800              CMP      r0,#0                 ;2153
000044  dd0c              BLE      |L26.96|
000046  f7fffffe          BL       rt_tick_get
00004a  4606              MOV      r6,r0                 ;2156
00004c  4628              MOV      r0,r5                 ;2162
00004e  304c              ADDS     r0,r0,#0x4c           ;2162
000050  aa06              ADD      r2,sp,#0x18           ;2162
000052  2100              MOVS     r1,#0                 ;2162
000054  9001              STR      r0,[sp,#4]            ;2162
000056  f7fffffe          BL       rt_timer_control
00005a  9801              LDR      r0,[sp,#4]            ;2165
00005c  f7fffffe          BL       rt_timer_start
                  |L26.96|
000060  9800              LDR      r0,[sp,#0]            ;2169
000062  f7fffffe          BL       rt_hw_interrupt_enable
000066  f7fffffe          BL       rt_schedule
00006a  6b28              LDR      r0,[r5,#0x30]         ;2175
00006c  2800              CMP      r0,#0                 ;2175
00006e  d1db              BNE      |L26.40|
000070  f7fffffe          BL       rt_hw_interrupt_disable
000074  9000              STR      r0,[sp,#0]            ;2185
000076  9806              LDR      r0,[sp,#0x18]         ;2185
000078  2800              CMP      r0,#0                 ;2185
00007a  dd07              BLE      |L26.140|
00007c  f7fffffe          BL       rt_tick_get
000080  1b86              SUBS     r6,r0,r6              ;2187
000082  9806              LDR      r0,[sp,#0x18]         ;2188
000084  1b80              SUBS     r0,r0,r6              ;2188
000086  9006              STR      r0,[sp,#0x18]         ;2189
000088  d500              BPL      |L26.140|
00008a  9706              STR      r7,[sp,#0x18]         ;2190
                  |L26.140|
00008c  8ca0              LDRH     r0,[r4,#0x24]         ;2129
00008e  2800              CMP      r0,#0                 ;2129
000090  d0cc              BEQ      |L26.44|
000092  6aa5              LDR      r5,[r4,#0x28]         ;2198
000094  6828              LDR      r0,[r5,#0]            ;2198
000096  62a0              STR      r0,[r4,#0x28]         ;2200
000098  6ae0              LDR      r0,[r4,#0x2c]         ;2200
00009a  42a8              CMP      r0,r5                 ;2200
00009c  d100              BNE      |L26.160|
00009e  62e7              STR      r7,[r4,#0x2c]         ;2201
                  |L26.160|
0000a0  8ca0              LDRH     r0,[r4,#0x24]         ;2204
0000a2  1e40              SUBS     r0,r0,#1              ;2204
0000a4  84a0              STRH     r0,[r4,#0x24]         ;2204
0000a6  9800              LDR      r0,[sp,#0]            ;2207
0000a8  f7fffffe          BL       rt_hw_interrupt_enable
0000ac  8c22              LDRH     r2,[r4,#0x20]         ;2210
0000ae  9805              LDR      r0,[sp,#0x14]         ;2210
0000b0  4282              CMP      r2,r0                 ;2210
0000b2  d300              BCC      |L26.182|
0000b4  4602              MOV      r2,r0                 ;2210
                  |L26.182|
0000b6  1d29              ADDS     r1,r5,#4              ;2210
0000b8  9804              LDR      r0,[sp,#0x10]         ;2210
0000ba  f7fffffe          BL       rt_memcpy
0000be  f7fffffe          BL       rt_hw_interrupt_disable
0000c2  6b21              LDR      r1,[r4,#0x30]         ;2215
0000c4  6029              STR      r1,[r5,#0]            ;2216
0000c6  6325              STR      r5,[r4,#0x30]         ;2218
0000c8  f7fffffe          BL       rt_hw_interrupt_enable
0000cc  2000              MOVS     r0,#0                 ;2222
0000ce  e7ab              B        |L26.40|
                  |L26.208|
0000d0  9800              LDR      r0,[sp,#0]            ;2140
0000d2  f7fffffe          BL       rt_hw_interrupt_enable
0000d6  2001              MOVS     r0,#1                 ;2142
0000d8  43c0              MVNS     r0,r0                 ;2142
0000da  6328              STR      r0,[r5,#0x30]         ;2142
0000dc  e7a4              B        |L26.40|
;;;2224   RTM_EXPORT(rt_mq_recv);
                          ENDP


                          AREA ||i.rt_mq_send||, CODE, READONLY, ALIGN=1

                  rt_mq_send PROC
;;;1925    */
;;;1926   rt_err_t rt_mq_send(rt_mq_t mq, void *buffer, rt_size_t size)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1927   {
000002  4604              MOV      r4,r0
;;;1928       register rt_ubase_t temp;
;;;1929       struct rt_mq_message *msg;
;;;1930   
;;;1931       RT_ASSERT(mq != RT_NULL);
;;;1932       RT_ASSERT(buffer != RT_NULL);
;;;1933       RT_ASSERT(size != 0);
;;;1934   
;;;1935       /* greater than one message size */
;;;1936       if (size > mq->msg_size)
000004  8c00              LDRH     r0,[r0,#0x20]
000006  4616              MOV      r6,r2                 ;1927
000008  460f              MOV      r7,r1                 ;1927
00000a  42b0              CMP      r0,r6
00000c  d202              BCS      |L27.20|
;;;1937           return -RT_ERROR;
00000e  2000              MOVS     r0,#0
000010  43c0              MVNS     r0,r0
;;;1938   
;;;1939       RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mq->parent.parent)));
;;;1940   
;;;1941       /* disable interrupt */
;;;1942       temp = rt_hw_interrupt_disable();
;;;1943   
;;;1944       /* get a free list, there must be an empty item */
;;;1945       msg = (struct rt_mq_message*)mq->msg_queue_free;
;;;1946       /* message queue is full */
;;;1947       if (msg == RT_NULL)
;;;1948       {
;;;1949           /* enable interrupt */
;;;1950           rt_hw_interrupt_enable(temp);
;;;1951   
;;;1952           return -RT_EFULL;
;;;1953       }
;;;1954       /* move free list pointer */
;;;1955       mq->msg_queue_free = msg->next;
;;;1956   
;;;1957       /* enable interrupt */
;;;1958       rt_hw_interrupt_enable(temp);
;;;1959   
;;;1960       /* the msg is the new tailer of list, the next shall be NULL */
;;;1961       msg->next = RT_NULL;
;;;1962       /* copy buffer */
;;;1963       rt_memcpy(msg + 1, buffer, size);
;;;1964   
;;;1965       /* disable interrupt */
;;;1966       temp = rt_hw_interrupt_disable();
;;;1967       /* link msg to message queue */
;;;1968       if (mq->msg_queue_tail != RT_NULL)
;;;1969       {
;;;1970           /* if the tail exists, */
;;;1971           ((struct rt_mq_message *)mq->msg_queue_tail)->next = msg;
;;;1972       }
;;;1973   
;;;1974       /* set new tail */
;;;1975       mq->msg_queue_tail = msg;
;;;1976       /* if the head is empty, set head */
;;;1977       if (mq->msg_queue_head == RT_NULL)
;;;1978           mq->msg_queue_head = msg;
;;;1979   
;;;1980       /* increase message entry */
;;;1981       mq->entry ++;
;;;1982   
;;;1983       /* resume suspended thread */
;;;1984       if (!rt_list_isempty(&mq->parent.suspend_thread))
;;;1985       {
;;;1986           rt_ipc_list_resume(&(mq->parent.suspend_thread));
;;;1987   
;;;1988           /* enable interrupt */
;;;1989           rt_hw_interrupt_enable(temp);
;;;1990   
;;;1991           rt_schedule();
;;;1992   
;;;1993           return RT_EOK;
;;;1994       }
;;;1995   
;;;1996       /* enable interrupt */
;;;1997       rt_hw_interrupt_enable(temp);
;;;1998   
;;;1999       return RT_EOK;
;;;2000   }
000012  bdf8              POP      {r3-r7,pc}
                  |L27.20|
000014  f7fffffe          BL       rt_hw_interrupt_disable
000018  6b25              LDR      r5,[r4,#0x30]         ;1947
00001a  2d00              CMP      r5,#0                 ;1947
00001c  d016              BEQ      |L27.76|
00001e  6829              LDR      r1,[r5,#0]            ;1955
000020  6321              STR      r1,[r4,#0x30]         ;1958
000022  f7fffffe          BL       rt_hw_interrupt_enable
000026  2000              MOVS     r0,#0                 ;1961
000028  6028              STR      r0,[r5,#0]            ;1963
00002a  4632              MOV      r2,r6                 ;1963
00002c  4639              MOV      r1,r7                 ;1963
00002e  1d28              ADDS     r0,r5,#4              ;1963
000030  f7fffffe          BL       rt_memcpy
000034  f7fffffe          BL       rt_hw_interrupt_disable
000038  4606              MOV      r6,r0                 ;1966
00003a  6ae0              LDR      r0,[r4,#0x2c]         ;1968
00003c  2800              CMP      r0,#0                 ;1968
00003e  d000              BEQ      |L27.66|
000040  6005              STR      r5,[r0,#0]            ;1971
                  |L27.66|
000042  62e5              STR      r5,[r4,#0x2c]         ;1977
000044  6aa0              LDR      r0,[r4,#0x28]         ;1977
000046  2800              CMP      r0,#0                 ;1977
000048  d005              BEQ      |L27.86|
00004a  e005              B        |L27.88|
                  |L27.76|
00004c  f7fffffe          BL       rt_hw_interrupt_enable
000050  2002              MOVS     r0,#2                 ;1952
000052  43c0              MVNS     r0,r0                 ;1952
000054  bdf8              POP      {r3-r7,pc}
                  |L27.86|
000056  62a5              STR      r5,[r4,#0x28]         ;1978
                  |L27.88|
000058  8ca0              LDRH     r0,[r4,#0x24]         ;1981
00005a  1c40              ADDS     r0,r0,#1              ;1981
00005c  84a0              STRH     r0,[r4,#0x24]         ;1981
00005e  4620              MOV      r0,r4                 ;1984
000060  3014              ADDS     r0,r0,#0x14           ;1984
000062  4604              MOV      r4,r0                 ;1984
000064  f7fffffe          BL       rt_list_isempty
000068  2800              CMP      r0,#0                 ;1984
00006a  d004              BEQ      |L27.118|
00006c  4630              MOV      r0,r6                 ;1997
00006e  f7fffffe          BL       rt_hw_interrupt_enable
                  |L27.114|
000072  2000              MOVS     r0,#0                 ;1999
000074  bdf8              POP      {r3-r7,pc}
                  |L27.118|
000076  4620              MOV      r0,r4
000078  f7fffffe          BL       rt_ipc_list_resume
00007c  4630              MOV      r0,r6                 ;1989
00007e  f7fffffe          BL       rt_hw_interrupt_enable
000082  f7fffffe          BL       rt_schedule
000086  e7f4              B        |L27.114|
;;;2001   RTM_EXPORT(rt_mq_send);
                          ENDP


                          AREA ||i.rt_mq_urgent||, CODE, READONLY, ALIGN=1

                  rt_mq_urgent PROC
;;;2013    */
;;;2014   rt_err_t rt_mq_urgent(rt_mq_t mq, void *buffer, rt_size_t size)
000000  b5f8              PUSH     {r3-r7,lr}
;;;2015   {
000002  4604              MOV      r4,r0
;;;2016       register rt_ubase_t temp;
;;;2017       struct rt_mq_message *msg;
;;;2018   
;;;2019       RT_ASSERT(mq != RT_NULL);
;;;2020       RT_ASSERT(buffer != RT_NULL);
;;;2021       RT_ASSERT(size != 0);
;;;2022   
;;;2023       /* greater than one message size */
;;;2024       if (size > mq->msg_size)
000004  8c00              LDRH     r0,[r0,#0x20]
000006  4616              MOV      r6,r2                 ;2015
000008  460f              MOV      r7,r1                 ;2015
00000a  42b0              CMP      r0,r6
00000c  d202              BCS      |L28.20|
;;;2025           return -RT_ERROR;
00000e  2000              MOVS     r0,#0
000010  43c0              MVNS     r0,r0
;;;2026   
;;;2027       RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mq->parent.parent)));
;;;2028   
;;;2029       /* disable interrupt */
;;;2030       temp = rt_hw_interrupt_disable();
;;;2031   
;;;2032       /* get a free list, there must be an empty item */
;;;2033       msg = (struct rt_mq_message *)mq->msg_queue_free;
;;;2034       /* message queue is full */
;;;2035       if (msg == RT_NULL)
;;;2036       {
;;;2037           /* enable interrupt */
;;;2038           rt_hw_interrupt_enable(temp);
;;;2039   
;;;2040           return -RT_EFULL;
;;;2041       }
;;;2042       /* move free list pointer */
;;;2043       mq->msg_queue_free = msg->next;
;;;2044   
;;;2045       /* enable interrupt */
;;;2046       rt_hw_interrupt_enable(temp);
;;;2047   
;;;2048       /* copy buffer */
;;;2049       rt_memcpy(msg + 1, buffer, size);
;;;2050   
;;;2051       /* disable interrupt */
;;;2052       temp = rt_hw_interrupt_disable();
;;;2053   
;;;2054       /* link msg to the beginning of message queue */
;;;2055       msg->next = mq->msg_queue_head;
;;;2056       mq->msg_queue_head = msg;
;;;2057   
;;;2058       /* if there is no tail */
;;;2059       if (mq->msg_queue_tail == RT_NULL)
;;;2060           mq->msg_queue_tail = msg;
;;;2061   
;;;2062       /* increase message entry */
;;;2063       mq->entry ++;
;;;2064   
;;;2065       /* resume suspended thread */
;;;2066       if (!rt_list_isempty(&mq->parent.suspend_thread))
;;;2067       {
;;;2068           rt_ipc_list_resume(&(mq->parent.suspend_thread));
;;;2069   
;;;2070           /* enable interrupt */
;;;2071           rt_hw_interrupt_enable(temp);
;;;2072   
;;;2073           rt_schedule();
;;;2074   
;;;2075           return RT_EOK;
;;;2076       }
;;;2077   
;;;2078       /* enable interrupt */
;;;2079       rt_hw_interrupt_enable(temp);
;;;2080   
;;;2081       return RT_EOK;
;;;2082   }
000012  bdf8              POP      {r3-r7,pc}
                  |L28.20|
000014  f7fffffe          BL       rt_hw_interrupt_disable
000018  6b25              LDR      r5,[r4,#0x30]         ;2035
00001a  2d00              CMP      r5,#0                 ;2035
00001c  d012              BEQ      |L28.68|
00001e  6829              LDR      r1,[r5,#0]            ;2043
000020  6321              STR      r1,[r4,#0x30]         ;2046
000022  f7fffffe          BL       rt_hw_interrupt_enable
000026  4632              MOV      r2,r6                 ;2049
000028  4639              MOV      r1,r7                 ;2049
00002a  1d28              ADDS     r0,r5,#4              ;2049
00002c  f7fffffe          BL       rt_memcpy
000030  f7fffffe          BL       rt_hw_interrupt_disable
000034  4606              MOV      r6,r0                 ;2052
000036  6aa0              LDR      r0,[r4,#0x28]         ;2055
000038  6028              STR      r0,[r5,#0]            ;2056
00003a  62a5              STR      r5,[r4,#0x28]         ;2059
00003c  6ae0              LDR      r0,[r4,#0x2c]         ;2059
00003e  2800              CMP      r0,#0                 ;2059
000040  d005              BEQ      |L28.78|
000042  e005              B        |L28.80|
                  |L28.68|
000044  f7fffffe          BL       rt_hw_interrupt_enable
000048  2002              MOVS     r0,#2                 ;2040
00004a  43c0              MVNS     r0,r0                 ;2040
00004c  bdf8              POP      {r3-r7,pc}
                  |L28.78|
00004e  62e5              STR      r5,[r4,#0x2c]         ;2060
                  |L28.80|
000050  8ca0              LDRH     r0,[r4,#0x24]         ;2063
000052  1c40              ADDS     r0,r0,#1              ;2063
000054  84a0              STRH     r0,[r4,#0x24]         ;2063
000056  4620              MOV      r0,r4                 ;2066
000058  3014              ADDS     r0,r0,#0x14           ;2066
00005a  4604              MOV      r4,r0                 ;2066
00005c  f7fffffe          BL       rt_list_isempty
000060  2800              CMP      r0,#0                 ;2066
000062  d004              BEQ      |L28.110|
000064  4630              MOV      r0,r6                 ;2079
000066  f7fffffe          BL       rt_hw_interrupt_enable
                  |L28.106|
00006a  2000              MOVS     r0,#0                 ;2081
00006c  bdf8              POP      {r3-r7,pc}
                  |L28.110|
00006e  4620              MOV      r0,r4
000070  f7fffffe          BL       rt_ipc_list_resume
000074  4630              MOV      r0,r6                 ;2071
000076  f7fffffe          BL       rt_hw_interrupt_enable
00007a  f7fffffe          BL       rt_schedule
00007e  e7f4              B        |L28.106|
;;;2083   RTM_EXPORT(rt_mq_urgent);
                          ENDP


                          AREA ||i.rt_mutex_control||, CODE, READONLY, ALIGN=1

                  rt_mutex_control PROC
;;;870     */
;;;871    rt_err_t rt_mutex_control(rt_mutex_t mutex, rt_uint8_t cmd, void *arg)
000000  2000              MOVS     r0,#0
;;;872    {
;;;873        return -RT_ERROR;
000002  43c0              MVNS     r0,r0
;;;874    }
000004  4770              BX       lr
;;;875    RTM_EXPORT(rt_mutex_control);
                          ENDP


                          AREA ||i.rt_mutex_create||, CODE, READONLY, ALIGN=1

                  rt_mutex_create PROC
;;;580     */
;;;581    rt_mutex_t rt_mutex_create(const char *name, rt_uint8_t flag)
000000  b510              PUSH     {r4,lr}
;;;582    {
000002  460c              MOV      r4,r1
;;;583        struct rt_mutex *mutex;
;;;584    
;;;585        RT_DEBUG_NOT_IN_INTERRUPT;
;;;586    
;;;587        /* allocate object */
;;;588        mutex = (rt_mutex_t)rt_object_allocate(RT_Object_Class_Mutex, name);
000004  4601              MOV      r1,r0
000006  2002              MOVS     r0,#2
000008  f7fffffe          BL       rt_object_allocate
;;;589        if (mutex == RT_NULL)
00000c  2800              CMP      r0,#0
00000e  d00b              BEQ      |L30.40|
000010  4601              MOV      r1,r0
000012  3114              ADDS     r1,r1,#0x14
000014  6181              STR      r1,[r0,#0x18]
;;;590            return mutex;
;;;591    
;;;592        /* init ipc object */
;;;593        rt_ipc_object_init(&(mutex->parent));
;;;594    
;;;595        mutex->value              = 1;
000016  6141              STR      r1,[r0,#0x14]
000018  2101              MOVS     r1,#1
00001a  8381              STRH     r1,[r0,#0x1c]
;;;596        mutex->owner              = RT_NULL;
00001c  2100              MOVS     r1,#0
;;;597        mutex->original_priority  = 0xFF;
00001e  22ff              MOVS     r2,#0xff
000020  6201              STR      r1,[r0,#0x20]
000022  7782              STRB     r2,[r0,#0x1e]
;;;598        mutex->hold               = 0;
000024  77c1              STRB     r1,[r0,#0x1f]
;;;599    
;;;600        /* set flag */
;;;601        mutex->parent.parent.flag = flag;
000026  7244              STRB     r4,[r0,#9]
                  |L30.40|
;;;602    
;;;603        return mutex;
;;;604    }
000028  bd10              POP      {r4,pc}
;;;605    RTM_EXPORT(rt_mutex_create);
                          ENDP


                          AREA ||i.rt_mutex_delete||, CODE, READONLY, ALIGN=1

                  rt_mutex_delete PROC
;;;615     */
;;;616    rt_err_t rt_mutex_delete(rt_mutex_t mutex)
000000  b510              PUSH     {r4,lr}
;;;617    {
000002  4604              MOV      r4,r0
;;;618        RT_DEBUG_NOT_IN_INTERRUPT;
;;;619    
;;;620        RT_ASSERT(mutex != RT_NULL);
;;;621    
;;;622        /* wakeup all suspend threads */
;;;623        rt_ipc_list_resume_all(&(mutex->parent.suspend_thread));
000004  3014              ADDS     r0,r0,#0x14
000006  f7fffffe          BL       rt_ipc_list_resume_all
;;;624    
;;;625        /* delete semaphore object */
;;;626        rt_object_delete(&(mutex->parent.parent));
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       rt_object_delete
;;;627    
;;;628        return RT_EOK;
000010  2000              MOVS     r0,#0
;;;629    }
000012  bd10              POP      {r4,pc}
;;;630    RTM_EXPORT(rt_mutex_delete);
                          ENDP


                          AREA ||i.rt_mutex_detach||, CODE, READONLY, ALIGN=1

                  rt_mutex_detach PROC
;;;555     */
;;;556    rt_err_t rt_mutex_detach(rt_mutex_t mutex)
000000  b510              PUSH     {r4,lr}
;;;557    {
000002  4604              MOV      r4,r0
;;;558        RT_ASSERT(mutex != RT_NULL);
;;;559    
;;;560        /* wakeup all suspend threads */
;;;561        rt_ipc_list_resume_all(&(mutex->parent.suspend_thread));
000004  3014              ADDS     r0,r0,#0x14
000006  f7fffffe          BL       rt_ipc_list_resume_all
;;;562    
;;;563        /* detach semaphore object */
;;;564        rt_object_detach(&(mutex->parent.parent));
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       rt_object_detach
;;;565    
;;;566        return RT_EOK;
000010  2000              MOVS     r0,#0
;;;567    }
000012  bd10              POP      {r4,pc}
;;;568    RTM_EXPORT(rt_mutex_detach);
                          ENDP


                          AREA ||i.rt_mutex_init||, CODE, READONLY, ALIGN=1

                  rt_mutex_init PROC
;;;524     */
;;;525    rt_err_t rt_mutex_init(rt_mutex_t mutex, const char *name, rt_uint8_t flag)
000000  b570              PUSH     {r4-r6,lr}
;;;526    {
000002  4615              MOV      r5,r2
;;;527        RT_ASSERT(mutex != RT_NULL);
;;;528    
;;;529        /* init object */
;;;530        rt_object_init(&(mutex->parent.parent), RT_Object_Class_Mutex, name);
000004  460a              MOV      r2,r1
000006  4604              MOV      r4,r0                 ;526
000008  2102              MOVS     r1,#2
00000a  f7fffffe          BL       rt_object_init
00000e  4620              MOV      r0,r4
000010  3014              ADDS     r0,r0,#0x14
000012  61a0              STR      r0,[r4,#0x18]
;;;531    
;;;532        /* init ipc object */
;;;533        rt_ipc_object_init(&(mutex->parent));
;;;534    
;;;535        mutex->value = 1;
000014  6160              STR      r0,[r4,#0x14]
000016  2001              MOVS     r0,#1
000018  83a0              STRH     r0,[r4,#0x1c]
;;;536        mutex->owner = RT_NULL;
00001a  2000              MOVS     r0,#0
;;;537        mutex->original_priority = 0xFF;
00001c  21ff              MOVS     r1,#0xff
00001e  6220              STR      r0,[r4,#0x20]
000020  77a1              STRB     r1,[r4,#0x1e]
;;;538        mutex->hold  = 0;
000022  77e0              STRB     r0,[r4,#0x1f]
;;;539    
;;;540        /* set flag */
;;;541        mutex->parent.parent.flag = flag;
000024  7265              STRB     r5,[r4,#9]
;;;542    
;;;543        return RT_EOK;
;;;544    }
000026  bd70              POP      {r4-r6,pc}
;;;545    RTM_EXPORT(rt_mutex_init);
                          ENDP


                          AREA ||i.rt_mutex_release||, CODE, READONLY, ALIGN=1

                  rt_mutex_release PROC
;;;771     */
;;;772    rt_err_t rt_mutex_release(rt_mutex_t mutex)
000000  b5f8              PUSH     {r3-r7,lr}
;;;773    {
000002  4604              MOV      r4,r0
;;;774        register rt_base_t temp;
;;;775        struct rt_thread *thread;
;;;776        rt_bool_t need_schedule;
;;;777    
;;;778        need_schedule = RT_FALSE;
000004  2700              MOVS     r7,#0
;;;779    
;;;780        /* only thread could release mutex because we need test the ownership */
;;;781        RT_DEBUG_IN_THREAD_CONTEXT;
;;;782    
;;;783        /* get current thread */
;;;784        thread = rt_thread_self();
000006  f7fffffe          BL       rt_thread_self
00000a  4606              MOV      r6,r0
;;;785    
;;;786        /* disable interrupt */
;;;787        temp = rt_hw_interrupt_disable();
00000c  f7fffffe          BL       rt_hw_interrupt_disable
000010  4605              MOV      r5,r0
;;;788    
;;;789        RT_DEBUG_LOG(RT_DEBUG_IPC,
;;;790                     ("mutex_release:current thread %s, mutex value: %d, hold: %d\n",
;;;791                      thread->name, mutex->value, mutex->hold));
;;;792    
;;;793        RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(mutex->parent.parent)));
;;;794    
;;;795        /* mutex only can be released by owner */
;;;796        if (thread != mutex->owner)
000012  6a20              LDR      r0,[r4,#0x20]
000014  42b0              CMP      r0,r6
000016  d006              BEQ      |L34.38|
;;;797        {
;;;798            thread->error = -RT_ERROR;
000018  1e7c              SUBS     r4,r7,#1
;;;799    
;;;800            /* enable interrupt */
;;;801            rt_hw_interrupt_enable(temp);
00001a  4628              MOV      r0,r5
00001c  6334              STR      r4,[r6,#0x30]
00001e  f7fffffe          BL       rt_hw_interrupt_enable
;;;802    
;;;803            return -RT_ERROR;
000022  4620              MOV      r0,r4
;;;804        }
;;;805    
;;;806        /* decrease hold */
;;;807        mutex->hold --;
;;;808        /* if no hold */
;;;809        if (mutex->hold == 0)
;;;810        {
;;;811            /* change the owner thread to original priority */
;;;812            if (mutex->original_priority != mutex->owner->current_priority)
;;;813            {
;;;814                rt_thread_control(mutex->owner,
;;;815                                  RT_THREAD_CTRL_CHANGE_PRIORITY,
;;;816                                  &(mutex->original_priority));
;;;817            }
;;;818    
;;;819            /* wakeup suspended thread */
;;;820            if (!rt_list_isempty(&mutex->parent.suspend_thread))
;;;821            {
;;;822                /* get suspended thread */
;;;823                thread = rt_list_entry(mutex->parent.suspend_thread.next,
;;;824                                       struct rt_thread,
;;;825                                       tlist);
;;;826    
;;;827                RT_DEBUG_LOG(RT_DEBUG_IPC, ("mutex_release: resume thread: %s\n",
;;;828                                            thread->name));
;;;829    
;;;830                /* set new owner and priority */
;;;831                mutex->owner             = thread;
;;;832                mutex->original_priority = thread->current_priority;
;;;833                mutex->hold ++;
;;;834    
;;;835                /* resume thread */
;;;836                rt_ipc_list_resume(&(mutex->parent.suspend_thread));
;;;837    
;;;838                need_schedule = RT_TRUE;
;;;839            }
;;;840            else
;;;841            {
;;;842                /* increase value */
;;;843                mutex->value ++;
;;;844    
;;;845                /* clear owner */
;;;846                mutex->owner             = RT_NULL;
;;;847                mutex->original_priority = 0xff;
;;;848            }
;;;849        }
;;;850    
;;;851        /* enable interrupt */
;;;852        rt_hw_interrupt_enable(temp);
;;;853    
;;;854        /* perform a schedule */
;;;855        if (need_schedule == RT_TRUE)
;;;856            rt_schedule();
;;;857    
;;;858        return RT_EOK;
;;;859    }
000024  bdf8              POP      {r3-r7,pc}
                  |L34.38|
000026  7fe1              LDRB     r1,[r4,#0x1f]         ;807
000028  1e49              SUBS     r1,r1,#1              ;807
00002a  0609              LSLS     r1,r1,#24             ;807
00002c  0e09              LSRS     r1,r1,#24             ;807
00002e  77e1              STRB     r1,[r4,#0x1f]         ;807
000030  d117              BNE      |L34.98|
000032  2135              MOVS     r1,#0x35              ;812
000034  7fa2              LDRB     r2,[r4,#0x1e]         ;812
000036  5c09              LDRB     r1,[r1,r0]            ;812
000038  428a              CMP      r2,r1                 ;812
00003a  d004              BEQ      |L34.70|
00003c  4622              MOV      r2,r4                 ;814
00003e  321e              ADDS     r2,r2,#0x1e           ;814
000040  2102              MOVS     r1,#2                 ;814
000042  f7fffffe          BL       rt_thread_control
                  |L34.70|
000046  4620              MOV      r0,r4                 ;820
000048  3014              ADDS     r0,r0,#0x14           ;820
00004a  4606              MOV      r6,r0                 ;820
00004c  f7fffffe          BL       rt_list_isempty
000050  2800              CMP      r0,#0                 ;820
000052  d00f              BEQ      |L34.116|
000054  8ba0              LDRH     r0,[r4,#0x1c]         ;843
000056  1c40              ADDS     r0,r0,#1              ;843
000058  83a0              STRH     r0,[r4,#0x1c]         ;843
00005a  2000              MOVS     r0,#0                 ;846
00005c  6220              STR      r0,[r4,#0x20]         ;847
00005e  20ff              MOVS     r0,#0xff              ;847
000060  77a0              STRB     r0,[r4,#0x1e]         ;847
                  |L34.98|
000062  4628              MOV      r0,r5                 ;852
000064  f7fffffe          BL       rt_hw_interrupt_enable
000068  2f00              CMP      r7,#0                 ;855
00006a  d001              BEQ      |L34.112|
00006c  f7fffffe          BL       rt_schedule
                  |L34.112|
000070  2000              MOVS     r0,#0                 ;858
000072  bdf8              POP      {r3-r7,pc}
                  |L34.116|
000074  6960              LDR      r0,[r4,#0x14]         ;823
000076  3814              SUBS     r0,r0,#0x14           ;823
000078  6220              STR      r0,[r4,#0x20]         ;831
00007a  3020              ADDS     r0,r0,#0x20           ;831
00007c  7d40              LDRB     r0,[r0,#0x15]         ;832
00007e  77a0              STRB     r0,[r4,#0x1e]         ;832
000080  7fe0              LDRB     r0,[r4,#0x1f]         ;833
000082  1c40              ADDS     r0,r0,#1              ;833
000084  77e0              STRB     r0,[r4,#0x1f]         ;833
000086  4630              MOV      r0,r6                 ;833
000088  f7fffffe          BL       rt_ipc_list_resume
00008c  2701              MOVS     r7,#1                 ;838
00008e  e7e8              B        |L34.98|
;;;860    RTM_EXPORT(rt_mutex_release);
                          ENDP


                          AREA ||i.rt_mutex_take||, CODE, READONLY, ALIGN=1

                  rt_mutex_take PROC
;;;641     */
;;;642    rt_err_t rt_mutex_take(rt_mutex_t mutex, rt_int32_t time)
000000  b573              PUSH     {r0,r1,r4-r6,lr}
;;;643    {
000002  4604              MOV      r4,r0
;;;644        register rt_base_t temp;
;;;645        struct rt_thread *thread;
;;;646    
;;;647        /* this function must not be used in interrupt even if time = 0 */
;;;648        RT_DEBUG_IN_THREAD_CONTEXT;
;;;649    
;;;650        RT_ASSERT(mutex != RT_NULL);
;;;651    
;;;652        /* disable interrupt */
;;;653        temp = rt_hw_interrupt_disable();
000004  f7fffffe          BL       rt_hw_interrupt_disable
000008  4606              MOV      r6,r0
;;;654    
;;;655        /* get current thread */
;;;656        thread = rt_thread_self();
00000a  f7fffffe          BL       rt_thread_self
00000e  4605              MOV      r5,r0
;;;657    
;;;658        RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(mutex->parent.parent)));
;;;659    
;;;660        RT_DEBUG_LOG(RT_DEBUG_IPC,
;;;661                     ("mutex_take: current thread %s, mutex value: %d, hold: %d\n",
;;;662                      thread->name, mutex->value, mutex->hold));
;;;663    
;;;664        /* reset thread error */
;;;665        thread->error = RT_EOK;
000010  2000              MOVS     r0,#0
;;;666    
;;;667        if (mutex->owner == thread)
000012  6328              STR      r0,[r5,#0x30]
000014  6a20              LDR      r0,[r4,#0x20]
000016  42a8              CMP      r0,r5
000018  d103              BNE      |L35.34|
                  |L35.26|
;;;668        {
;;;669            /* it's the same thread */
;;;670            mutex->hold ++;
00001a  7fe0              LDRB     r0,[r4,#0x1f]
00001c  1c40              ADDS     r0,r0,#1
00001e  77e0              STRB     r0,[r4,#0x1f]
000020  e034              B        |L35.140|
                  |L35.34|
;;;671        }
;;;672        else
;;;673        {
;;;674            /* The value of mutex is 1 in initial status. Therefore, if the
;;;675             * value is great than 0, it indicates the mutex is avaible.
;;;676             */
;;;677            if (mutex->value > 0)
000022  8ba1              LDRH     r1,[r4,#0x1c]
000024  2900              CMP      r1,#0
000026  d006              BEQ      |L35.54|
000028  1e49              SUBS     r1,r1,#1
;;;678            {
;;;679                /* mutex is available */
;;;680                mutex->value --;
00002a  83a1              STRH     r1,[r4,#0x1c]
;;;681    
;;;682                /* set mutex owner and original priority */
;;;683                mutex->owner             = thread;
00002c  6225              STR      r5,[r4,#0x20]
00002e  3520              ADDS     r5,r5,#0x20
;;;684                mutex->original_priority = thread->current_priority;
000030  7d68              LDRB     r0,[r5,#0x15]
000032  77a0              STRB     r0,[r4,#0x1e]
;;;685                mutex->hold ++;
000034  e7f1              B        |L35.26|
                  |L35.54|
;;;686            }
;;;687            else
;;;688            {
;;;689                /* no waiting, return with timeout */
;;;690                if (time == 0)
000036  9901              LDR      r1,[sp,#4]
000038  2900              CMP      r1,#0
00003a  d02c              BEQ      |L35.150|
;;;691                {
;;;692                    /* set error as timeout */
;;;693                    thread->error = -RT_ETIMEOUT;
;;;694    
;;;695                    /* enable interrupt */
;;;696                    rt_hw_interrupt_enable(temp);
;;;697    
;;;698                    return -RT_ETIMEOUT;
;;;699                }
;;;700                else
;;;701                {
;;;702                    /* mutex is unavailable, push to suspend list */
;;;703                    RT_DEBUG_LOG(RT_DEBUG_IPC, ("mutex_take: suspend thread: %s\n",
;;;704                                                thread->name));
;;;705    
;;;706                    /* change the owner thread priority of mutex */
;;;707                    if (thread->current_priority < mutex->owner->current_priority)
00003c  2135              MOVS     r1,#0x35
00003e  5d4a              LDRB     r2,[r1,r5]
000040  5c09              LDRB     r1,[r1,r0]
000042  428a              CMP      r2,r1
000044  d204              BCS      |L35.80|
;;;708                    {
;;;709                        /* change the owner thread priority */
;;;710                        rt_thread_control(mutex->owner,
000046  462a              MOV      r2,r5
000048  3235              ADDS     r2,r2,#0x35
00004a  2102              MOVS     r1,#2
00004c  f7fffffe          BL       rt_thread_control
                  |L35.80|
;;;711                                          RT_THREAD_CTRL_CHANGE_PRIORITY,
;;;712                                          &thread->current_priority);
;;;713                    }
;;;714    
;;;715                    /* suspend current thread */
;;;716                    rt_ipc_list_suspend(&(mutex->parent.suspend_thread),
000050  4620              MOV      r0,r4
000052  7a62              LDRB     r2,[r4,#9]
000054  4629              MOV      r1,r5
000056  3014              ADDS     r0,r0,#0x14
000058  f7fffffe          BL       rt_ipc_list_suspend
;;;717                                        thread,
;;;718                                        mutex->parent.parent.flag);
;;;719    
;;;720                    /* has waiting time, start thread timer */
;;;721                    if (time > 0)
00005c  9801              LDR      r0,[sp,#4]
00005e  2800              CMP      r0,#0
000060  dd09              BLE      |L35.118|
;;;722                    {
;;;723                        RT_DEBUG_LOG(RT_DEBUG_IPC,
;;;724                                     ("mutex_take: start the timer of thread:%s\n",
;;;725                                      thread->name));
;;;726    
;;;727                        /* reset the timeout of thread timer and start it */
;;;728                        rt_timer_control(&(thread->thread_timer),
000062  4628              MOV      r0,r5
000064  304c              ADDS     r0,r0,#0x4c
000066  aa01              ADD      r2,sp,#4
000068  2100              MOVS     r1,#0
00006a  4604              MOV      r4,r0
00006c  f7fffffe          BL       rt_timer_control
000070  4620              MOV      r0,r4
;;;729                                         RT_TIMER_CTRL_SET_TIME,
;;;730                                         &time);
;;;731                        rt_timer_start(&(thread->thread_timer));
000072  f7fffffe          BL       rt_timer_start
                  |L35.118|
;;;732                    }
;;;733    
;;;734                    /* enable interrupt */
;;;735                    rt_hw_interrupt_enable(temp);
000076  4630              MOV      r0,r6
000078  f7fffffe          BL       rt_hw_interrupt_enable
;;;736    
;;;737                    /* do schedule */
;;;738                    rt_schedule();
00007c  f7fffffe          BL       rt_schedule
;;;739    
;;;740                    if (thread->error != RT_EOK)
000080  6b28              LDR      r0,[r5,#0x30]
000082  2800              CMP      r0,#0
000084  d106              BNE      |L35.148|
;;;741                    {
;;;742                        /* return error */
;;;743                        return thread->error;
;;;744                    }
;;;745                    else
;;;746                    {
;;;747                        /* the mutex is taken successfully. */
;;;748                        /* disable interrupt */
;;;749                        temp = rt_hw_interrupt_disable();
000086  f7fffffe          BL       rt_hw_interrupt_disable
00008a  4606              MOV      r6,r0
                  |L35.140|
;;;750                    }
;;;751                }
;;;752            }
;;;753        }
;;;754    
;;;755        /* enable interrupt */
;;;756        rt_hw_interrupt_enable(temp);
00008c  4630              MOV      r0,r6
00008e  f7fffffe          BL       rt_hw_interrupt_enable
;;;757    
;;;758        RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(mutex->parent.parent)));
;;;759    
;;;760        return RT_EOK;
000092  2000              MOVS     r0,#0
                  |L35.148|
;;;761    }
000094  bd7c              POP      {r2-r6,pc}
                  |L35.150|
000096  2401              MOVS     r4,#1                 ;693
000098  43e4              MVNS     r4,r4                 ;693
00009a  4630              MOV      r0,r6                 ;696
00009c  632c              STR      r4,[r5,#0x30]         ;696
00009e  f7fffffe          BL       rt_hw_interrupt_enable
0000a2  4620              MOV      r0,r4                 ;698
0000a4  bd7c              POP      {r2-r6,pc}
;;;762    RTM_EXPORT(rt_mutex_take);
                          ENDP


                          AREA ||i.rt_sem_control||, CODE, READONLY, ALIGN=1

                  rt_sem_control PROC
;;;480     */
;;;481    rt_err_t rt_sem_control(rt_sem_t sem, rt_uint8_t cmd, void *arg)
000000  b570              PUSH     {r4-r6,lr}
;;;482    {
000002  4614              MOV      r4,r2
000004  4605              MOV      r5,r0
;;;483        rt_ubase_t level;
;;;484        RT_ASSERT(sem != RT_NULL);
;;;485    
;;;486        if (cmd == RT_IPC_CMD_RESET)
000006  2901              CMP      r1,#1
000008  d002              BEQ      |L36.16|
;;;487        {
;;;488            rt_uint32_t value;
;;;489    
;;;490            /* get value */
;;;491            value = (rt_uint32_t)arg;
;;;492            /* disable interrupt */
;;;493            level = rt_hw_interrupt_disable();
;;;494    
;;;495            /* resume all waiting thread */
;;;496            rt_ipc_list_resume_all(&sem->parent.suspend_thread);
;;;497    
;;;498            /* set new value */
;;;499            sem->value = (rt_uint16_t)value;
;;;500    
;;;501            /* enable interrupt */
;;;502            rt_hw_interrupt_enable(level);
;;;503    
;;;504            rt_schedule();
;;;505    
;;;506            return RT_EOK;
;;;507        }
;;;508    
;;;509        return -RT_ERROR;
00000a  2000              MOVS     r0,#0
00000c  43c0              MVNS     r0,r0
;;;510    }
00000e  bd70              POP      {r4-r6,pc}
                  |L36.16|
000010  f7fffffe          BL       rt_hw_interrupt_disable
000014  4606              MOV      r6,r0                 ;493
000016  4628              MOV      r0,r5                 ;496
000018  3014              ADDS     r0,r0,#0x14           ;496
00001a  f7fffffe          BL       rt_ipc_list_resume_all
00001e  83ac              STRH     r4,[r5,#0x1c]         ;499
000020  4630              MOV      r0,r6                 ;502
000022  f7fffffe          BL       rt_hw_interrupt_enable
000026  f7fffffe          BL       rt_schedule
00002a  2000              MOVS     r0,#0                 ;506
00002c  bd70              POP      {r4-r6,pc}
;;;511    RTM_EXPORT(rt_sem_control);
                          ENDP


                          AREA ||i.rt_sem_create||, CODE, READONLY, ALIGN=1

                  rt_sem_create PROC
;;;268     */
;;;269    rt_sem_t rt_sem_create(const char *name, rt_uint32_t value, rt_uint8_t flag)
000000  b570              PUSH     {r4-r6,lr}
;;;270    {
000002  460c              MOV      r4,r1
;;;271        rt_sem_t sem;
;;;272    
;;;273        RT_DEBUG_NOT_IN_INTERRUPT;
;;;274    
;;;275        /* allocate object */
;;;276        sem = (rt_sem_t)rt_object_allocate(RT_Object_Class_Semaphore, name);
000004  4601              MOV      r1,r0
000006  4615              MOV      r5,r2                 ;270
000008  2001              MOVS     r0,#1
00000a  f7fffffe          BL       rt_object_allocate
;;;277        if (sem == RT_NULL)
00000e  2800              CMP      r0,#0
000010  d005              BEQ      |L37.30|
000012  4601              MOV      r1,r0
000014  3114              ADDS     r1,r1,#0x14
000016  6181              STR      r1,[r0,#0x18]
;;;278            return sem;
;;;279    
;;;280        /* init ipc object */
;;;281        rt_ipc_object_init(&(sem->parent));
;;;282    
;;;283        /* set init value */
;;;284        sem->value = value;
000018  6141              STR      r1,[r0,#0x14]
00001a  8384              STRH     r4,[r0,#0x1c]
;;;285    
;;;286        /* set parent */
;;;287        sem->parent.parent.flag = flag;
00001c  7245              STRB     r5,[r0,#9]
                  |L37.30|
;;;288    
;;;289        return sem;
;;;290    }
00001e  bd70              POP      {r4-r6,pc}
;;;291    RTM_EXPORT(rt_sem_create);
                          ENDP


                          AREA ||i.rt_sem_delete||, CODE, READONLY, ALIGN=1

                  rt_sem_delete PROC
;;;301     */
;;;302    rt_err_t rt_sem_delete(rt_sem_t sem)
000000  b510              PUSH     {r4,lr}
;;;303    {
000002  4604              MOV      r4,r0
;;;304        RT_DEBUG_NOT_IN_INTERRUPT;
;;;305    
;;;306        RT_ASSERT(sem != RT_NULL);
;;;307    
;;;308        /* wakeup all suspend threads */
;;;309        rt_ipc_list_resume_all(&(sem->parent.suspend_thread));
000004  3014              ADDS     r0,r0,#0x14
000006  f7fffffe          BL       rt_ipc_list_resume_all
;;;310    
;;;311        /* delete semaphore object */
;;;312        rt_object_delete(&(sem->parent.parent));
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       rt_object_delete
;;;313    
;;;314        return RT_EOK;
000010  2000              MOVS     r0,#0
;;;315    }
000012  bd10              POP      {r4,pc}
;;;316    RTM_EXPORT(rt_sem_delete);
                          ENDP


                          AREA ||i.rt_sem_detach||, CODE, READONLY, ALIGN=1

                  rt_sem_detach PROC
;;;242     */
;;;243    rt_err_t rt_sem_detach(rt_sem_t sem)
000000  b510              PUSH     {r4,lr}
;;;244    {
000002  4604              MOV      r4,r0
;;;245        RT_ASSERT(sem != RT_NULL);
;;;246    
;;;247        /* wakeup all suspend threads */
;;;248        rt_ipc_list_resume_all(&(sem->parent.suspend_thread));
000004  3014              ADDS     r0,r0,#0x14
000006  f7fffffe          BL       rt_ipc_list_resume_all
;;;249    
;;;250        /* detach semaphore object */
;;;251        rt_object_detach(&(sem->parent.parent));
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       rt_object_detach
;;;252    
;;;253        return RT_EOK;
000010  2000              MOVS     r0,#0
;;;254    }
000012  bd10              POP      {r4,pc}
;;;255    RTM_EXPORT(rt_sem_detach);
                          ENDP


                          AREA ||i.rt_sem_init||, CODE, READONLY, ALIGN=1

                  rt_sem_init PROC
;;;210     */
;;;211    rt_err_t rt_sem_init(rt_sem_t    sem,
000000  b5f8              PUSH     {r3-r7,lr}
;;;212                         const char *name,
;;;213                         rt_uint32_t value,
;;;214                         rt_uint8_t  flag)
;;;215    {
000002  4616              MOV      r6,r2
;;;216        RT_ASSERT(sem != RT_NULL);
;;;217    
;;;218        /* init object */
;;;219        rt_object_init(&(sem->parent.parent), RT_Object_Class_Semaphore, name);
000004  460a              MOV      r2,r1
000006  461f              MOV      r7,r3                 ;215
000008  4605              MOV      r5,r0                 ;215
00000a  2101              MOVS     r1,#1
00000c  f7fffffe          BL       rt_object_init
000010  462c              MOV      r4,r5
000012  3414              ADDS     r4,r4,#0x14
000014  61ac              STR      r4,[r5,#0x18]
;;;220    
;;;221        /* init ipc object */
;;;222        rt_ipc_object_init(&(sem->parent));
;;;223    
;;;224        /* set init value */
;;;225        sem->value = value;
000016  616c              STR      r4,[r5,#0x14]
000018  83ae              STRH     r6,[r5,#0x1c]
;;;226    
;;;227        /* set parent */
;;;228        sem->parent.parent.flag = flag;
00001a  726f              STRB     r7,[r5,#9]
;;;229    
;;;230        return RT_EOK;
00001c  2000              MOVS     r0,#0
;;;231    }
00001e  bdf8              POP      {r3-r7,pc}
;;;232    RTM_EXPORT(rt_sem_init);
                          ENDP


                          AREA ||i.rt_sem_release||, CODE, READONLY, ALIGN=1

                  rt_sem_release PROC
;;;434     */
;;;435    rt_err_t rt_sem_release(rt_sem_t sem)
000000  b5f8              PUSH     {r3-r7,lr}
;;;436    {
000002  4604              MOV      r4,r0
;;;437        register rt_base_t temp;
;;;438        register rt_bool_t need_schedule;
;;;439    
;;;440        RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(sem->parent.parent)));
;;;441    
;;;442        need_schedule = RT_FALSE;
000004  2500              MOVS     r5,#0
;;;443    
;;;444        /* disable interrupt */
;;;445        temp = rt_hw_interrupt_disable();
000006  f7fffffe          BL       rt_hw_interrupt_disable
00000a  4606              MOV      r6,r0
;;;446    
;;;447        RT_DEBUG_LOG(RT_DEBUG_IPC, ("thread %s releases sem:%s, which value is: %d\n",
;;;448                                    rt_thread_self()->name,
;;;449                                    ((struct rt_object *)sem)->name,
;;;450                                    sem->value));
;;;451    
;;;452        if (!rt_list_isempty(&sem->parent.suspend_thread))
00000c  4620              MOV      r0,r4
00000e  3014              ADDS     r0,r0,#0x14
000010  4607              MOV      r7,r0
000012  f7fffffe          BL       rt_list_isempty
000016  2800              CMP      r0,#0
000018  d00b              BEQ      |L41.50|
;;;453        {
;;;454            /* resume the suspended thread */
;;;455            rt_ipc_list_resume(&(sem->parent.suspend_thread));
;;;456            need_schedule = RT_TRUE;
;;;457        }
;;;458        else
;;;459            sem->value ++; /* increase value */
00001a  8ba0              LDRH     r0,[r4,#0x1c]
00001c  1c40              ADDS     r0,r0,#1
00001e  83a0              STRH     r0,[r4,#0x1c]
                  |L41.32|
;;;460    
;;;461        /* enable interrupt */
;;;462        rt_hw_interrupt_enable(temp);
000020  4630              MOV      r0,r6
000022  f7fffffe          BL       rt_hw_interrupt_enable
;;;463    
;;;464        /* resume a thread, re-schedule */
;;;465        if (need_schedule == RT_TRUE)
000026  2d00              CMP      r5,#0
000028  d001              BEQ      |L41.46|
;;;466            rt_schedule();
00002a  f7fffffe          BL       rt_schedule
                  |L41.46|
;;;467    
;;;468        return RT_EOK;
00002e  2000              MOVS     r0,#0
;;;469    }
000030  bdf8              POP      {r3-r7,pc}
                  |L41.50|
000032  4638              MOV      r0,r7
000034  f7fffffe          BL       rt_ipc_list_resume
000038  2501              MOVS     r5,#1                 ;456
00003a  e7f1              B        |L41.32|
;;;470    RTM_EXPORT(rt_sem_release);
                          ENDP


                          AREA ||i.rt_sem_take||, CODE, READONLY, ALIGN=1

                  rt_sem_take PROC
;;;327     */
;;;328    rt_err_t rt_sem_take(rt_sem_t sem, rt_int32_t time)
000000  b573              PUSH     {r0,r1,r4-r6,lr}
;;;329    {
000002  4604              MOV      r4,r0
;;;330        register rt_base_t temp;
;;;331        struct rt_thread *thread;
;;;332    
;;;333        RT_ASSERT(sem != RT_NULL);
;;;334    
;;;335        RT_OBJECT_HOOK_CALL(rt_object_trytake_hook, (&(sem->parent.parent)));
;;;336    
;;;337        /* disable interrupt */
;;;338        temp = rt_hw_interrupt_disable();
000004  f7fffffe          BL       rt_hw_interrupt_disable
000008  4606              MOV      r6,r0
;;;339    
;;;340        RT_DEBUG_LOG(RT_DEBUG_IPC, ("thread %s take sem:%s, which value is: %d\n",
;;;341                                    rt_thread_self()->name,
;;;342                                    ((struct rt_object *)sem)->name,
;;;343                                    sem->value));
;;;344    
;;;345        if (sem->value > 0)
00000a  8ba0              LDRH     r0,[r4,#0x1c]
00000c  2800              CMP      r0,#0
00000e  d005              BEQ      |L42.28|
000010  1e40              SUBS     r0,r0,#1
;;;346        {
;;;347            /* semaphore is available */
;;;348            sem->value --;
000012  83a0              STRH     r0,[r4,#0x1c]
;;;349    
;;;350            /* enable interrupt */
;;;351            rt_hw_interrupt_enable(temp);
000014  4630              MOV      r0,r6
000016  f7fffffe          BL       rt_hw_interrupt_enable
00001a  e022              B        |L42.98|
                  |L42.28|
;;;352        }
;;;353        else
;;;354        {
;;;355            /* no waiting, return with timeout */
;;;356            if (time == 0)
00001c  9801              LDR      r0,[sp,#4]
00001e  2800              CMP      r0,#0
000020  d021              BEQ      |L42.102|
;;;357            {
;;;358                rt_hw_interrupt_enable(temp);
;;;359    
;;;360                return -RT_ETIMEOUT;
;;;361            }
;;;362            else
;;;363            {
;;;364                /* current context checking */
;;;365                RT_DEBUG_IN_THREAD_CONTEXT;
;;;366    
;;;367                /* semaphore is unavailable, push to suspend list */
;;;368                /* get current thread */
;;;369                thread = rt_thread_self();
000022  f7fffffe          BL       rt_thread_self
000026  4605              MOV      r5,r0
;;;370    
;;;371                /* reset thread error number */
;;;372                thread->error = RT_EOK;
000028  2000              MOVS     r0,#0
;;;373    
;;;374                RT_DEBUG_LOG(RT_DEBUG_IPC, ("sem take: suspend thread - %s\n",
;;;375                                            thread->name));
;;;376    
;;;377                /* suspend thread */
;;;378                rt_ipc_list_suspend(&(sem->parent.suspend_thread),
00002a  6328              STR      r0,[r5,#0x30]
00002c  4620              MOV      r0,r4
00002e  7a62              LDRB     r2,[r4,#9]
000030  4629              MOV      r1,r5
000032  3014              ADDS     r0,r0,#0x14
000034  f7fffffe          BL       rt_ipc_list_suspend
;;;379                                    thread,
;;;380                                    sem->parent.parent.flag);
;;;381    
;;;382                /* has waiting time, start thread timer */
;;;383                if (time > 0)
000038  9801              LDR      r0,[sp,#4]
00003a  2800              CMP      r0,#0
00003c  dd09              BLE      |L42.82|
;;;384                {
;;;385                    RT_DEBUG_LOG(RT_DEBUG_IPC, ("set thread:%s to timer list\n",
;;;386                                                thread->name));
;;;387    
;;;388                    /* reset the timeout of thread timer and start it */
;;;389                    rt_timer_control(&(thread->thread_timer),
00003e  4628              MOV      r0,r5
000040  304c              ADDS     r0,r0,#0x4c
000042  aa01              ADD      r2,sp,#4
000044  2100              MOVS     r1,#0
000046  4604              MOV      r4,r0
000048  f7fffffe          BL       rt_timer_control
00004c  4620              MOV      r0,r4
;;;390                                     RT_TIMER_CTRL_SET_TIME,
;;;391                                     &time);
;;;392                    rt_timer_start(&(thread->thread_timer));
00004e  f7fffffe          BL       rt_timer_start
                  |L42.82|
;;;393                }
;;;394    
;;;395                /* enable interrupt */
;;;396                rt_hw_interrupt_enable(temp);
000052  4630              MOV      r0,r6
000054  f7fffffe          BL       rt_hw_interrupt_enable
;;;397    
;;;398                /* do schedule */
;;;399                rt_schedule();
000058  f7fffffe          BL       rt_schedule
;;;400    
;;;401                if (thread->error != RT_EOK)
00005c  6b28              LDR      r0,[r5,#0x30]
00005e  2800              CMP      r0,#0
000060  d100              BNE      |L42.100|
                  |L42.98|
;;;402                {
;;;403                    return thread->error;
;;;404                }
;;;405            }
;;;406        }
;;;407    
;;;408        RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(sem->parent.parent)));
;;;409    
;;;410        return RT_EOK;
000062  2000              MOVS     r0,#0
                  |L42.100|
;;;411    }
000064  bd7c              POP      {r2-r6,pc}
                  |L42.102|
000066  4630              MOV      r0,r6                 ;358
000068  f7fffffe          BL       rt_hw_interrupt_enable
00006c  2001              MOVS     r0,#1                 ;360
00006e  43c0              MVNS     r0,r0                 ;360
000070  bd7c              POP      {r2-r6,pc}
;;;412    RTM_EXPORT(rt_sem_take);
                          ENDP


                          AREA ||i.rt_sem_trytake||, CODE, READONLY, ALIGN=1

                  rt_sem_trytake PROC
;;;420     */
;;;421    rt_err_t rt_sem_trytake(rt_sem_t sem)
000000  b510              PUSH     {r4,lr}
;;;422    {
;;;423        return rt_sem_take(sem, 0);
000002  2100              MOVS     r1,#0
000004  f7fffffe          BL       rt_sem_take
;;;424    }
000008  bd10              POP      {r4,pc}
;;;425    RTM_EXPORT(rt_sem_trytake);
                          ENDP

