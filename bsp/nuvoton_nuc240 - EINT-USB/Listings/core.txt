; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\core.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\core.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I.\Libraries\Device\Nuvoton -I..\..\components\finsh -I.\Libraries\CMSIS\Include -I.\Libraries\StdDriver\inc -I..\..\include -I.\APP -I.\Drivers -I..\..\components\drivers\include -I..\..\components\drivers\include\drivers -I..\nuvoton_nuc240 -I.\Libraries\Device\Nuvoton\NUC230_240\Include -I..\..\include -I..\..\components\drivers\usb\usbdevice\class -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=521 --omf_browse=.\objects\core.crf ..\..\components\drivers\usb\usbdevice\core\core.c]
                          THUMB

                          AREA ||i._data_notify||, CODE, READONLY, ALIGN=2

                  _data_notify PROC
;;;720     */
;;;721    static rt_err_t _data_notify(udevice_t device, struct ep_msg* ep_msg)
000000  b5fe              PUSH     {r1-r7,lr}
;;;722    {
000002  4605              MOV      r5,r0
;;;723        uep_t ep;
;;;724        ufunction_t func;
;;;725        rt_size_t size = 0;
000004  2000              MOVS     r0,#0
;;;726        
;;;727        RT_ASSERT(device != RT_NULL);
;;;728        RT_ASSERT(ep_msg != RT_NULL);
;;;729        
;;;730        if (device->state != USB_STATE_CONFIGURED)
000006  9000              STR      r0,[sp,#0]
000008  2024              MOVS     r0,#0x24
00000a  5d40              LDRB     r0,[r0,r5]
;;;731        {
;;;732            return -RT_ERROR;
00000c  2700              MOVS     r7,#0
00000e  43ff              MVNS     r7,r7
000010  460e              MOV      r6,r1                 ;722
000012  2807              CMP      r0,#7                 ;730
000014  d001              BEQ      |L1.26|
                  |L1.22|
000016  4638              MOV      r0,r7
;;;733        }
;;;734        
;;;735        ep = rt_usbd_find_endpoint(device, &func, ep_msg->ep_addr);
;;;736        if(ep == RT_NULL)
;;;737        {        
;;;738            rt_kprintf("invalid endpoint\n");
;;;739            return -RT_ERROR;
;;;740        }
;;;741    
;;;742        if(EP_ADDRESS(ep) & USB_DIR_IN)
;;;743        {
;;;744            if(ep->request.remain_size >= EP_MAXPACKET(ep))
;;;745            {
;;;746                dcd_ep_write(device->dcd, EP_ADDRESS(ep),
;;;747                    ep->request.buffer, EP_MAXPACKET(ep));
;;;748                ep->request.remain_size -= EP_MAXPACKET(ep);
;;;749                ep->request.buffer += EP_MAXPACKET(ep);     
;;;750            }
;;;751            else if(ep->request.remain_size > 0)
;;;752            {
;;;753                dcd_ep_write(device->dcd, EP_ADDRESS(ep), 
;;;754                    ep->request.buffer, ep->request.remain_size);
;;;755                ep->request.remain_size = 0;
;;;756            }
;;;757            else
;;;758            {
;;;759                EP_HANDLER(ep, func, size);
;;;760            }
;;;761        }
;;;762        else
;;;763        {
;;;764            size = ep_msg->size;
;;;765            if(ep->request.remain_size == 0)
;;;766            {
;;;767                return RT_EOK;            
;;;768            }
;;;769                
;;;770            if(size == 0)
;;;771            {
;;;772                size = dcd_ep_read(device->dcd, EP_ADDRESS(ep),
;;;773                    ep->request.buffer);
;;;774            }
;;;775    
;;;776            if(size > ep->request.remain_size)
;;;777            {
;;;778                ep->request.remain_size = 0;
;;;779            }
;;;780            else
;;;781            {
;;;782                ep->request.remain_size -= size;
;;;783                ep->request.buffer += size;
;;;784            }
;;;785    
;;;786            if(ep->request.req_type == UIO_REQUEST_READ_MOST)
;;;787            {
;;;788                EP_HANDLER(ep, func, size);
;;;789            }
;;;790            else if(ep->request.remain_size == 0)
;;;791            {
;;;792                EP_HANDLER(ep, func, ep->request.size);
;;;793            }
;;;794        }
;;;795    
;;;796        return RT_EOK;
;;;797    }
000018  bdfe              POP      {r1-r7,pc}
                  |L1.26|
00001a  7932              LDRB     r2,[r6,#4]            ;735
00001c  a901              ADD      r1,sp,#4              ;735
00001e  4628              MOV      r0,r5                 ;735
000020  f7fffffe          BL       rt_usbd_find_endpoint
000024  0004              MOVS     r4,r0                 ;735
000026  d022              BEQ      |L1.110|
000028  68a0              LDR      r0,[r4,#8]            ;742
00002a  2700              MOVS     r7,#0                 ;742
00002c  7881              LDRB     r1,[r0,#2]            ;742
00002e  060a              LSLS     r2,r1,#24             ;742
000030  2a00              CMP      r2,#0                 ;742
000032  da2b              BGE      |L1.140|
000034  7942              LDRB     r2,[r0,#5]            ;744
000036  7906              LDRB     r6,[r0,#4]            ;744
000038  0210              LSLS     r0,r2,#8              ;744
00003a  6aa3              LDR      r3,[r4,#0x28]         ;744
00003c  4330              ORRS     r0,r0,r6              ;744
00003e  4283              CMP      r3,r0                 ;744
000040  d319              BCC      |L1.118|
000042  6bad              LDR      r5,[r5,#0x38]         ;746
000044  4603              MOV      r3,r0                 ;746
000046  6a22              LDR      r2,[r4,#0x20]         ;746
000048  4628              MOV      r0,r5                 ;746
00004a  f7fffffe          BL       dcd_ep_write
00004e  68a0              LDR      r0,[r4,#8]            ;748
000050  6aa2              LDR      r2,[r4,#0x28]         ;748
000052  7941              LDRB     r1,[r0,#5]            ;748
000054  7903              LDRB     r3,[r0,#4]            ;748
000056  0209              LSLS     r1,r1,#8              ;748
000058  4319              ORRS     r1,r1,r3              ;748
00005a  1a51              SUBS     r1,r2,r1              ;748
00005c  62a1              STR      r1,[r4,#0x28]         ;749
00005e  7942              LDRB     r2,[r0,#5]            ;749
000060  7903              LDRB     r3,[r0,#4]            ;749
000062  0210              LSLS     r0,r2,#8              ;749
000064  6a21              LDR      r1,[r4,#0x20]         ;749
000066  4318              ORRS     r0,r0,r3              ;749
000068  1808              ADDS     r0,r1,r0              ;749
00006a  6220              STR      r0,[r4,#0x20]         ;749
00006c  e030              B        |L1.208|
                  |L1.110|
00006e  a019              ADR      r0,|L1.212|
000070  f7fffffe          BL       rt_kprintf
000074  e7cf              B        |L1.22|
                  |L1.118|
000076  2b00              CMP      r3,#0                 ;751
000078  d005              BEQ      |L1.134|
00007a  6a22              LDR      r2,[r4,#0x20]         ;753
00007c  6ba8              LDR      r0,[r5,#0x38]         ;753
00007e  f7fffffe          BL       dcd_ep_write
000082  62a7              STR      r7,[r4,#0x28]         ;755
000084  e024              B        |L1.208|
                  |L1.134|
000086  6ba2              LDR      r2,[r4,#0x38]         ;759
000088  9900              LDR      r1,[sp,#0]            ;759
00008a  e01f              B        |L1.204|
                  |L1.140|
00008c  6aa2              LDR      r2,[r4,#0x28]         ;765
00008e  6830              LDR      r0,[r6,#0]            ;765
000090  2a00              CMP      r2,#0                 ;765
000092  d01d              BEQ      |L1.208|
000094  2800              CMP      r0,#0                 ;770
000096  d103              BNE      |L1.160|
000098  6a22              LDR      r2,[r4,#0x20]         ;772
00009a  6ba8              LDR      r0,[r5,#0x38]         ;772
00009c  f7fffffe          BL       dcd_ep_read
                  |L1.160|
0000a0  6aa1              LDR      r1,[r4,#0x28]         ;776
0000a2  4281              CMP      r1,r0                 ;776
0000a4  d201              BCS      |L1.170|
0000a6  62a7              STR      r7,[r4,#0x28]         ;778
0000a8  e004              B        |L1.180|
                  |L1.170|
0000aa  1a09              SUBS     r1,r1,r0              ;782
0000ac  62a1              STR      r1,[r4,#0x28]         ;783
0000ae  6a21              LDR      r1,[r4,#0x20]         ;783
0000b0  1809              ADDS     r1,r1,r0              ;783
0000b2  6221              STR      r1,[r4,#0x20]         ;783
                  |L1.180|
0000b4  7f21              LDRB     r1,[r4,#0x1c]         ;786
0000b6  2901              CMP      r1,#1                 ;786
0000b8  d003              BEQ      |L1.194|
0000ba  6aa0              LDR      r0,[r4,#0x28]         ;790
0000bc  2800              CMP      r0,#0                 ;790
0000be  d003              BEQ      |L1.200|
0000c0  e006              B        |L1.208|
                  |L1.194|
0000c2  4601              MOV      r1,r0                 ;788
0000c4  6ba2              LDR      r2,[r4,#0x38]         ;788
0000c6  e001              B        |L1.204|
                  |L1.200|
0000c8  6ba2              LDR      r2,[r4,#0x38]         ;792
0000ca  6a61              LDR      r1,[r4,#0x24]         ;792
                  |L1.204|
0000cc  9801              LDR      r0,[sp,#4]            ;792
0000ce  4790              BLX      r2                    ;792
                  |L1.208|
0000d0  2000              MOVS     r0,#0                 ;796
0000d2  bdfe              POP      {r1-r7,pc}
;;;798    
                          ENDP

                  |L1.212|
0000d4  696e7661          DCB      "invalid endpoint\n",0
0000d8  6c696420
0000dc  656e6470
0000e0  6f696e74
0000e4  0a00    
0000e6  00                DCB      0
0000e7  00                DCB      0

                          AREA ||i._function_request||, CODE, READONLY, ALIGN=2

                  _function_request PROC
;;;621     */
;;;622    static rt_err_t _function_request(udevice_t device, ureq_t setup)
000000  b538              PUSH     {r3-r5,lr}
;;;623    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;624        uintf_t intf;
;;;625        ufunction_t func;
;;;626    
;;;627        /* parameter check */
;;;628        RT_ASSERT(device != RT_NULL);
;;;629        RT_ASSERT(setup != RT_NULL);
;;;630    
;;;631        /* verify request value */
;;;632        if(setup->index > device->curr_cfg->cfg_desc.bNumInterfaces)
000006  7948              LDRB     r0,[r1,#5]
000008  7909              LDRB     r1,[r1,#4]
00000a  0200              LSLS     r0,r0,#8
00000c  4308              ORRS     r0,r0,r1
00000e  6b29              LDR      r1,[r5,#0x30]
000010  7b09              LDRB     r1,[r1,#0xc]
000012  4288              CMP      r0,r1
000014  d905              BLS      |L2.34|
;;;633        {
;;;634            rt_usbd_ep0_set_stall(device);
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       rt_usbd_ep0_set_stall
;;;635            return -RT_ERROR;
00001c  2000              MOVS     r0,#0
00001e  43c0              MVNS     r0,r0
;;;636        }
;;;637    
;;;638        switch(setup->request_type & USB_REQ_TYPE_RECIPIENT_MASK)
;;;639        {
;;;640        case USB_REQ_TYPE_INTERFACE:
;;;641            intf = rt_usbd_find_interface(device, setup->index & 0xFF, &func);
;;;642            if(intf == RT_NULL)
;;;643            {
;;;644                rt_kprintf("unkwown interface request\n");
;;;645                rt_usbd_ep0_set_stall(device);
;;;646            }
;;;647            else
;;;648            {
;;;649                intf->handler(func, setup);
;;;650            }
;;;651            break;
;;;652        case USB_REQ_TYPE_ENDPOINT:
;;;653            break;
;;;654        default:
;;;655            rt_kprintf("unknown function request type\n");
;;;656            rt_usbd_ep0_set_stall(device);
;;;657            break;
;;;658        }
;;;659    
;;;660        return RT_EOK;
;;;661    }
000020  bd38              POP      {r3-r5,pc}
                  |L2.34|
000022  7821              LDRB     r1,[r4,#0]            ;638
000024  06c9              LSLS     r1,r1,#27             ;638
000026  0ec9              LSRS     r1,r1,#27             ;638
000028  2901              CMP      r1,#1                 ;638
00002a  d009              BEQ      |L2.64|
00002c  2902              CMP      r1,#2                 ;638
00002e  d005              BEQ      |L2.60|
000030  a00a              ADR      r0,|L2.92|
                  |L2.50|
000032  f7fffffe          BL       rt_kprintf
000036  4628              MOV      r0,r5                 ;656
000038  f7fffffe          BL       rt_usbd_ep0_set_stall
                  |L2.60|
00003c  2000              MOVS     r0,#0                 ;660
00003e  bd38              POP      {r3-r5,pc}
                  |L2.64|
000040  b2c1              UXTB     r1,r0                 ;641
000042  466a              MOV      r2,sp                 ;641
000044  4628              MOV      r0,r5                 ;641
000046  f7fffffe          BL       rt_usbd_find_interface
00004a  2800              CMP      r0,#0                 ;642
00004c  d004              BEQ      |L2.88|
00004e  6982              LDR      r2,[r0,#0x18]         ;649
000050  4621              MOV      r1,r4                 ;649
000052  9800              LDR      r0,[sp,#0]            ;649
000054  4790              BLX      r2                    ;649
000056  e7f1              B        |L2.60|
                  |L2.88|
000058  a008              ADR      r0,|L2.124|
00005a  e7ea              B        |L2.50|
;;;662    
                          ENDP

                  |L2.92|
00005c  756e6b6e          DCB      "unknown function request type\n",0
000060  6f776e20
000064  66756e63
000068  74696f6e
00006c  20726571
000070  75657374
000074  20747970
000078  650a00  
00007b  00                DCB      0
                  |L2.124|
00007c  756e6b77          DCB      "unkwown interface request\n",0
000080  6f776e20
000084  696e7465
000088  72666163
00008c  65207265
000090  71756573
000094  740a00  
000097  00                DCB      0

                          AREA ||i._get_descriptor||, CODE, READONLY, ALIGN=2

                  _get_descriptor PROC
;;;184     */
;;;185    static rt_err_t _get_descriptor(struct udevice* device, ureq_t setup)
000000  b510              PUSH     {r4,lr}
;;;186    {
000002  4604              MOV      r4,r0
;;;187        /* parameter check */
;;;188        RT_ASSERT(device != RT_NULL);
;;;189        RT_ASSERT(setup != RT_NULL);
;;;190    
;;;191        if(setup->request_type == USB_REQ_TYPE_DIR_IN)
000004  7808              LDRB     r0,[r1,#0]
000006  2880              CMP      r0,#0x80
000008  d001              BEQ      |L3.14|
;;;192        {
;;;193            switch(setup->value >> 8)
;;;194            {
;;;195            case USB_DESC_TYPE_DEVICE:
;;;196                _get_device_descriptor(device, setup);
;;;197                break;
;;;198            case USB_DESC_TYPE_CONFIGURATION:
;;;199                _get_config_descriptor(device, setup);
;;;200                break;
;;;201            case USB_DESC_TYPE_STRING:
;;;202                _get_string_descriptor(device, setup);
;;;203                break;
;;;204            case USB_DESC_TYPE_DEVICEQUALIFIER:
;;;205                _get_qualifier_descriptor(device, setup);
;;;206                break;
;;;207            default:
;;;208                rt_kprintf("unsupported descriptor request\n");
;;;209                rt_usbd_ep0_set_stall(device);
;;;210                break;
;;;211            }
;;;212        }
;;;213        else
;;;214        {
;;;215            rt_kprintf("request direction error\n");
00000a  a01f              ADR      r0,|L3.136|
;;;216            rt_usbd_ep0_set_stall(device);
00000c  e00d              B        |L3.42|
                  |L3.14|
00000e  78c8              LDRB     r0,[r1,#3]            ;193
000010  788a              LDRB     r2,[r1,#2]            ;193
000012  0200              LSLS     r0,r0,#8              ;193
000014  4310              ORRS     r0,r0,r2              ;193
000016  0a00              LSRS     r0,r0,#8              ;193
000018  2801              CMP      r0,#1                 ;193
00001a  d00a              BEQ      |L3.50|
00001c  2802              CMP      r0,#2                 ;193
00001e  d013              BEQ      |L3.72|
000020  2803              CMP      r0,#3                 ;193
000022  d021              BEQ      |L3.104|
000024  2806              CMP      r0,#6                 ;193
000026  d023              BEQ      |L3.112|
000028  a01e              ADR      r0,|L3.164|
                  |L3.42|
00002a  f7fffffe          BL       rt_kprintf
00002e  4620              MOV      r0,r4
000030  e026              B        |L3.128|
                  |L3.50|
000032  79ca              LDRB     r2,[r1,#7]
000034  7989              LDRB     r1,[r1,#6]
000036  0212              LSLS     r2,r2,#8
000038  430a              ORRS     r2,r2,r1
00003a  4620              MOV      r0,r4                 ;196
00003c  2a12              CMP      r2,#0x12              ;196
00003e  d900              BLS      |L3.66|
000040  2212              MOVS     r2,#0x12              ;196
                  |L3.66|
000042  4601              MOV      r1,r0                 ;196
000044  3108              ADDS     r1,r1,#8              ;196
000046  e018              B        |L3.122|
                  |L3.72|
000048  79ca              LDRB     r2,[r1,#7]            ;197
00004a  7989              LDRB     r1,[r1,#6]            ;197
00004c  6b23              LDR      r3,[r4,#0x30]         ;197
00004e  0212              LSLS     r2,r2,#8              ;197
000050  430a              ORRS     r2,r2,r1              ;197
000052  4620              MOV      r0,r4                 ;199
000054  7ad9              LDRB     r1,[r3,#0xb]          ;199
000056  7a9c              LDRB     r4,[r3,#0xa]          ;199
000058  0209              LSLS     r1,r1,#8              ;199
00005a  4321              ORRS     r1,r1,r4              ;199
00005c  3308              ADDS     r3,r3,#8              ;199
00005e  428a              CMP      r2,r1                 ;199
000060  d900              BLS      |L3.100|
000062  460a              MOV      r2,r1                 ;199
                  |L3.100|
000064  4619              MOV      r1,r3                 ;199
000066  e008              B        |L3.122|
                  |L3.104|
000068  4620              MOV      r0,r4                 ;202
00006a  f7fffffe          BL       _get_string_descriptor
00006e  e009              B        |L3.132|
                  |L3.112|
000070  69e1              LDR      r1,[r4,#0x1c]         ;203
000072  4620              MOV      r0,r4                 ;205
000074  2900              CMP      r1,#0                 ;205
000076  d003              BEQ      |L3.128|
000078  220a              MOVS     r2,#0xa               ;205
                  |L3.122|
00007a  f7fffffe          BL       rt_usbd_ep0_write
00007e  e001              B        |L3.132|
                  |L3.128|
000080  f7fffffe          BL       rt_usbd_ep0_set_stall
                  |L3.132|
;;;217        }
;;;218    
;;;219        return RT_EOK;
000084  2000              MOVS     r0,#0
;;;220    }
000086  bd10              POP      {r4,pc}
;;;221    
                          ENDP

                  |L3.136|
000088  72657175          DCB      "request direction error\n",0
00008c  65737420
000090  64697265
000094  6374696f
000098  6e206572
00009c  726f720a
0000a0  00      
0000a1  00                DCB      0
0000a2  00                DCB      0
0000a3  00                DCB      0
                  |L3.164|
0000a4  756e7375          DCB      "unsupported descriptor request\n",0
0000a8  70706f72
0000ac  74656420
0000b0  64657363
0000b4  72697074
0000b8  6f722072
0000bc  65717565
0000c0  73740a00

                          AREA ||i._get_string_descriptor||, CODE, READONLY, ALIGN=2

                  _get_string_descriptor PROC
;;;104     */
;;;105    static rt_err_t _get_string_descriptor(struct udevice* device, ureq_t setup)
000000  b5f0              PUSH     {r4-r7,lr}
;;;106    {
000002  b091              SUB      sp,sp,#0x44
000004  460e              MOV      r6,r1
000006  4604              MOV      r4,r0
;;;107        struct ustring_descriptor str_desc;
;;;108        rt_uint8_t index, i;
;;;109        rt_uint32_t len;
;;;110    
;;;111        /* parameter check */
;;;112        RT_ASSERT(device != RT_NULL);
;;;113        RT_ASSERT(setup != RT_NULL);
;;;114    
;;;115        RT_DEBUG_LOG(RT_DEBUG_USB, ("_get_string_descriptor\n"));
;;;116    
;;;117        str_desc.type = USB_DESC_TYPE_STRING;
000008  2003              MOVS     r0,#3
00000a  4669              MOV      r1,sp
00000c  7048              STRB     r0,[r1,#1]
;;;118        index = setup->value & 0xFF;
00000e  78f0              LDRB     r0,[r6,#3]
000010  78b1              LDRB     r1,[r6,#2]
000012  0200              LSLS     r0,r0,#8
000014  4308              ORRS     r0,r0,r1
000016  b2c0              UXTB     r0,r0
;;;119    
;;;120        if(index > USB_STRING_INTERFACE_INDEX)
000018  2805              CMP      r0,#5
00001a  d909              BLS      |L4.48|
;;;121        {
;;;122            rt_kprintf("unknown string index\n");
00001c  a01d              ADR      r0,|L4.148|
00001e  f7fffffe          BL       rt_kprintf
;;;123            rt_usbd_ep0_set_stall(device);
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       rt_usbd_ep0_set_stall
;;;124            return -RT_ERROR;
000028  2000              MOVS     r0,#0
00002a  43c0              MVNS     r0,r0
                  |L4.44|
;;;125        }
;;;126        if(index == 0)
;;;127        {
;;;128            str_desc.bLength = 4;
;;;129            str_desc.String[0] = 0x09;
;;;130            str_desc.String[1] = 0x04;
;;;131        }
;;;132        else
;;;133        {
;;;134            len = rt_strlen(device->str[index]);
;;;135            str_desc.bLength = len*2 + 2;
;;;136    
;;;137            for(i=0; i<len; i++)
;;;138            {
;;;139                str_desc.String[i*2] = device->str[index][i];
;;;140                str_desc.String[i*2 + 1] = 0;
;;;141            }
;;;142        }
;;;143    
;;;144        if (setup->length > str_desc.bLength)
;;;145            len = str_desc.bLength;
;;;146        else
;;;147            len = setup->length;
;;;148    
;;;149        /* send string descriptor to endpoint 0 */
;;;150        rt_usbd_ep0_write(device, (rt_uint8_t*)&str_desc, len);
;;;151    
;;;152        return RT_EOK;
;;;153    }
00002c  b011              ADD      sp,sp,#0x44
00002e  bdf0              POP      {r4-r7,pc}
                  |L4.48|
000030  2800              CMP      r0,#0                 ;126
000032  d00c              BEQ      |L4.78|
000034  6a21              LDR      r1,[r4,#0x20]         ;134
000036  0085              LSLS     r5,r0,#2              ;134
000038  5948              LDR      r0,[r1,r5]            ;134
00003a  f7fffffe          BL       rt_strlen
00003e  4601              MOV      r1,r0                 ;134
000040  0040              LSLS     r0,r0,#1              ;135
000042  466a              MOV      r2,sp                 ;135
000044  1c80              ADDS     r0,r0,#2              ;135
000046  7010              STRB     r0,[r2,#0]            ;135
000048  2200              MOVS     r2,#0                 ;137
00004a  466f              MOV      r7,sp                 ;107
00004c  e010              B        |L4.112|
                  |L4.78|
00004e  2004              MOVS     r0,#4                 ;128
000050  466a              MOV      r2,sp                 ;128
000052  7010              STRB     r0,[r2,#0]            ;128
000054  2109              MOVS     r1,#9                 ;129
000056  7091              STRB     r1,[r2,#2]            ;129
000058  70d0              STRB     r0,[r2,#3]            ;130
00005a  e00b              B        |L4.116|
                  |L4.92|
00005c  6a20              LDR      r0,[r4,#0x20]         ;139
00005e  5940              LDR      r0,[r0,r5]            ;139
000060  5c83              LDRB     r3,[r0,r2]            ;139
000062  0050              LSLS     r0,r2,#1              ;139
000064  19c0              ADDS     r0,r0,r7              ;139
000066  7083              STRB     r3,[r0,#2]            ;139
000068  2300              MOVS     r3,#0                 ;140
00006a  1c52              ADDS     r2,r2,#1              ;140
00006c  70c3              STRB     r3,[r0,#3]            ;140
00006e  b2d2              UXTB     r2,r2                 ;137
                  |L4.112|
000070  428a              CMP      r2,r1                 ;137
000072  d3f3              BCC      |L4.92|
                  |L4.116|
000074  79f0              LDRB     r0,[r6,#7]            ;144
000076  79b1              LDRB     r1,[r6,#6]            ;144
000078  0202              LSLS     r2,r0,#8              ;144
00007a  4668              MOV      r0,sp                 ;144
00007c  7800              LDRB     r0,[r0,#0]            ;144
00007e  430a              ORRS     r2,r2,r1              ;144
000080  4282              CMP      r2,r0                 ;144
000082  d900              BLS      |L4.134|
000084  4602              MOV      r2,r0                 ;145
                  |L4.134|
000086  4669              MOV      r1,sp                 ;150
000088  4620              MOV      r0,r4                 ;150
00008a  f7fffffe          BL       rt_usbd_ep0_write
00008e  2000              MOVS     r0,#0                 ;152
000090  e7cc              B        |L4.44|
;;;154    
                          ENDP

000092  0000              DCW      0x0000
                  |L4.148|
000094  756e6b6e          DCB      "unknown string index\n",0
000098  6f776e20
00009c  73747269
0000a0  6e672069
0000a4  6e646578
0000a8  0a00    
0000aa  00                DCB      0
0000ab  00                DCB      0

                          AREA ||i._set_config||, CODE, READONLY, ALIGN=1

                  _set_config PROC
;;;344     */
;;;345    static rt_err_t _set_config(struct udevice* device, ureq_t setup)
000000  b5f0              PUSH     {r4-r7,lr}
;;;346    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;347        struct rt_list_node *i, *j, *k;
;;;348        uconfig_t cfg;
;;;349        uintf_t intf;
;;;350        ualtsetting_t setting;
;;;351        uep_t ep;
;;;352    
;;;353        /* parameter check */
;;;354        RT_ASSERT(device != RT_NULL);
;;;355        RT_ASSERT(setup != RT_NULL);
;;;356    
;;;357        RT_DEBUG_LOG(RT_DEBUG_USB, ("_set_config\n"));
;;;358    
;;;359        if (setup->value > device->dev_desc.bNumConfigurations)
000006  78c8              LDRB     r0,[r1,#3]
000008  7889              LDRB     r1,[r1,#2]
00000a  0200              LSLS     r0,r0,#8
00000c  4308              ORRS     r0,r0,r1
00000e  7e69              LDRB     r1,[r5,#0x19]
000010  b085              SUB      sp,sp,#0x14           ;346
000012  4288              CMP      r0,r1
000014  d906              BLS      |L5.36|
;;;360        {
;;;361            rt_usbd_ep0_set_stall(device);
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       rt_usbd_ep0_set_stall
;;;362            return -RT_ERROR;
00001c  2000              MOVS     r0,#0
00001e  43c0              MVNS     r0,r0
                  |L5.32|
;;;363        }
;;;364    
;;;365        if (setup->value == 0)
;;;366        {
;;;367            RT_DEBUG_LOG(RT_DEBUG_USB, ("address state\n"));
;;;368            device->state = USB_STATE_ADDRESS;
;;;369    
;;;370            goto _exit;
;;;371        }
;;;372    
;;;373        /* set current configuration */
;;;374        rt_usbd_set_config(device, setup->value);
;;;375        dcd_set_config(device->dcd, setup->value);
;;;376        cfg = device->curr_cfg;
;;;377    
;;;378        for (i=cfg->func_list.next; i!=&cfg->func_list; i=i->next)
;;;379        {
;;;380            /* run all functiones and their endpoints in the configuration */
;;;381            ufunction_t func = (ufunction_t)rt_list_entry(i, struct ufunction, list);
;;;382            for(j=func->intf_list.next; j!=&func->intf_list; j=j->next)
;;;383            {
;;;384                intf = (uintf_t)rt_list_entry(j, struct uinterface, list);
;;;385                setting = intf->curr_setting;
;;;386                for(k=setting->ep_list.next; k != &setting->ep_list; k=k->next)
;;;387                {
;;;388                    ep = (uep_t)rt_list_entry(k, struct uendpoint, list);
;;;389    
;;;390                    /* first disable then enable an endpoint */
;;;391                    dcd_ep_disable(device->dcd, ep);
;;;392                    dcd_ep_enable(device->dcd, ep);
;;;393                }
;;;394            }
;;;395            /* after enabled endpoints, then enable function */
;;;396            FUNC_ENABLE(func);
;;;397        }
;;;398    
;;;399        device->state = USB_STATE_CONFIGURED;
;;;400    
;;;401    _exit:
;;;402        /* issue status stage */
;;;403        dcd_ep0_send_status(device->dcd);
;;;404    
;;;405        return RT_EOK;
;;;406    }
000020  b005              ADD      sp,sp,#0x14
000022  bdf0              POP      {r4-r7,pc}
                  |L5.36|
000024  4629              MOV      r1,r5                 ;368
000026  3120              ADDS     r1,r1,#0x20           ;368
000028  9100              STR      r1,[sp,#0]            ;365
00002a  2800              CMP      r0,#0                 ;365
00002c  d014              BEQ      |L5.88|
00002e  b2c1              UXTB     r1,r0                 ;374
000030  4628              MOV      r0,r5                 ;374
000032  f7fffffe          BL       rt_usbd_set_config
000036  78e1              LDRB     r1,[r4,#3]            ;375
000038  78a2              LDRB     r2,[r4,#2]            ;375
00003a  6ba8              LDR      r0,[r5,#0x38]         ;375
00003c  0209              LSLS     r1,r1,#8              ;375
00003e  4311              ORRS     r1,r1,r2              ;375
000040  6c00              LDR      r0,[r0,#0x40]         ;375
000042  b2c9              UXTB     r1,r1                 ;375
000044  6842              LDR      r2,[r0,#4]            ;375
000046  4608              MOV      r0,r1                 ;375
000048  4790              BLX      r2                    ;375
00004a  21ff              MOVS     r1,#0xff              ;378
00004c  6b28              LDR      r0,[r5,#0x30]         ;378
00004e  3115              ADDS     r1,r1,#0x15           ;378
000050  580f              LDR      r7,[r1,r0]            ;378
000052  1840              ADDS     r0,r0,r1              ;378
000054  9003              STR      r0,[sp,#0xc]          ;378
000056  e02c              B        |L5.178|
                  |L5.88|
000058  2106              MOVS     r1,#6                 ;368
00005a  e02d              B        |L5.184|
                  |L5.92|
00005c  4638              MOV      r0,r7                 ;382
00005e  301c              ADDS     r0,r0,#0x1c           ;382
000060  69fe              LDR      r6,[r7,#0x1c]         ;382
000062  9002              STR      r0,[sp,#8]            ;382
000064  e014              B        |L5.144|
                  |L5.102|
000066  68f0              LDR      r0,[r6,#0xc]          ;386
000068  6944              LDR      r4,[r0,#0x14]         ;386
00006a  3014              ADDS     r0,r0,#0x14           ;386
00006c  9001              STR      r0,[sp,#4]            ;386
00006e  e00b              B        |L5.136|
                  |L5.112|
000070  6ba9              LDR      r1,[r5,#0x38]         ;386
000072  4620              MOV      r0,r4                 ;391
000074  6c09              LDR      r1,[r1,#0x40]         ;391
000076  6949              LDR      r1,[r1,#0x14]         ;391
000078  4788              BLX      r1                    ;391
00007a  6ba9              LDR      r1,[r5,#0x38]         ;391
00007c  4620              MOV      r0,r4                 ;392
00007e  6c09              LDR      r1,[r1,#0x40]         ;392
000080  6909              LDR      r1,[r1,#0x10]         ;392
000082  4788              BLX      r1                    ;392
000084  6824              LDR      r4,[r4,#0]            ;386
000086  9801              LDR      r0,[sp,#4]            ;386
                  |L5.136|
000088  4284              CMP      r4,r0                 ;386
00008a  d1f1              BNE      |L5.112|
00008c  6836              LDR      r6,[r6,#0]            ;382
00008e  9802              LDR      r0,[sp,#8]            ;382
                  |L5.144|
000090  4286              CMP      r6,r0                 ;382
000092  d1e8              BNE      |L5.102|
000094  68b8              LDR      r0,[r7,#8]            ;396
000096  6801              LDR      r1,[r0,#0]            ;396
000098  2900              CMP      r1,#0                 ;396
00009a  d008              BEQ      |L5.174|
00009c  69b8              LDR      r0,[r7,#0x18]         ;396
00009e  2800              CMP      r0,#0                 ;396
0000a0  d105              BNE      |L5.174|
0000a2  4638              MOV      r0,r7                 ;396
0000a4  4788              BLX      r1                    ;396
0000a6  2800              CMP      r0,#0                 ;396
0000a8  d101              BNE      |L5.174|
0000aa  2101              MOVS     r1,#1                 ;396
0000ac  61b9              STR      r1,[r7,#0x18]         ;396
                  |L5.174|
0000ae  683f              LDR      r7,[r7,#0]            ;378
0000b0  9803              LDR      r0,[sp,#0xc]          ;378
                  |L5.178|
0000b2  4287              CMP      r7,r0                 ;378
0000b4  d1d2              BNE      |L5.92|
0000b6  2107              MOVS     r1,#7                 ;399
                  |L5.184|
0000b8  9800              LDR      r0,[sp,#0]            ;399
0000ba  7101              STRB     r1,[r0,#4]            ;399
0000bc  6ba8              LDR      r0,[r5,#0x38]         ;399
0000be  6c00              LDR      r0,[r0,#0x40]         ;399
0000c0  6a40              LDR      r0,[r0,#0x24]         ;399
0000c2  4780              BLX      r0                    ;399
0000c4  2000              MOVS     r0,#0                 ;405
0000c6  e7ab              B        |L5.32|
;;;407    
                          ENDP


                          AREA ||i._set_interface||, CODE, READONLY, ALIGN=1

                  _set_interface PROC
;;;264     */
;;;265    static rt_err_t _set_interface(struct udevice* device, ureq_t setup)
000000  b570              PUSH     {r4-r6,lr}
;;;266    {
000002  4605              MOV      r5,r0
;;;267        uintf_t intf;
;;;268        uep_t ep;
;;;269        struct rt_list_node* i;
;;;270        ualtsetting_t setting;
;;;271    
;;;272        /* parameter check */
;;;273        RT_ASSERT(device != RT_NULL);
;;;274        RT_ASSERT(setup != RT_NULL);
;;;275    
;;;276        RT_DEBUG_LOG(RT_DEBUG_USB, ("_set_interface\n"));
;;;277    
;;;278        if (device->state != USB_STATE_CONFIGURED)
000004  3020              ADDS     r0,r0,#0x20
000006  7900              LDRB     r0,[r0,#4]
000008  460c              MOV      r4,r1                 ;266
00000a  2807              CMP      r0,#7
00000c  d005              BEQ      |L6.26|
;;;279        {
;;;280            rt_usbd_ep0_set_stall(device);
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       rt_usbd_ep0_set_stall
;;;281            return -RT_ERROR;
000014  2000              MOVS     r0,#0
000016  43c0              MVNS     r0,r0
;;;282        }
;;;283            
;;;284        /* find the specified interface */
;;;285        intf = rt_usbd_find_interface(device, setup->index & 0xFF, RT_NULL);
;;;286    
;;;287        /* set alternate setting to the interface */
;;;288        rt_usbd_set_altsetting(intf, setup->value & 0xFF);
;;;289        setting = intf->curr_setting;
;;;290    
;;;291        /* start all endpoints of the interface alternate setting */
;;;292        for(i=setting->ep_list.next; i != &setting->ep_list; i=i->next)
;;;293        {
;;;294            ep = (uep_t)rt_list_entry(i, struct uendpoint, list);
;;;295            dcd_ep_disable(device->dcd, ep);
;;;296            dcd_ep_enable(device->dcd, ep);
;;;297        }
;;;298        dcd_ep0_send_status(device->dcd);
;;;299        
;;;300        return RT_EOK;
;;;301    }
000018  bd70              POP      {r4-r6,pc}
                  |L6.26|
00001a  7960              LDRB     r0,[r4,#5]            ;285
00001c  7921              LDRB     r1,[r4,#4]            ;285
00001e  0200              LSLS     r0,r0,#8              ;285
000020  4308              ORRS     r0,r0,r1              ;285
000022  b2c1              UXTB     r1,r0                 ;285
000024  2200              MOVS     r2,#0                 ;285
000026  4628              MOV      r0,r5                 ;285
000028  f7fffffe          BL       rt_usbd_find_interface
00002c  4606              MOV      r6,r0                 ;285
00002e  78e0              LDRB     r0,[r4,#3]            ;288
000030  78a1              LDRB     r1,[r4,#2]            ;288
000032  0200              LSLS     r0,r0,#8              ;288
000034  4308              ORRS     r0,r0,r1              ;288
000036  b2c1              UXTB     r1,r0                 ;288
000038  4630              MOV      r0,r6                 ;288
00003a  f7fffffe          BL       rt_usbd_set_altsetting
00003e  68f6              LDR      r6,[r6,#0xc]          ;289
000040  6974              LDR      r4,[r6,#0x14]         ;292
000042  3614              ADDS     r6,r6,#0x14           ;292
000044  e00a              B        |L6.92|
                  |L6.70|
000046  6ba9              LDR      r1,[r5,#0x38]         ;292
000048  4620              MOV      r0,r4                 ;295
00004a  6c09              LDR      r1,[r1,#0x40]         ;295
00004c  6949              LDR      r1,[r1,#0x14]         ;295
00004e  4788              BLX      r1                    ;295
000050  6ba9              LDR      r1,[r5,#0x38]         ;295
000052  4620              MOV      r0,r4                 ;296
000054  6c09              LDR      r1,[r1,#0x40]         ;296
000056  6909              LDR      r1,[r1,#0x10]         ;296
000058  4788              BLX      r1                    ;296
00005a  6824              LDR      r4,[r4,#0]            ;292
                  |L6.92|
00005c  42b4              CMP      r4,r6                 ;292
00005e  d1f2              BNE      |L6.70|
000060  6ba8              LDR      r0,[r5,#0x38]         ;292
000062  6c00              LDR      r0,[r0,#0x40]         ;292
000064  6a40              LDR      r0,[r0,#0x24]         ;292
000066  4780              BLX      r0                    ;292
000068  2000              MOVS     r0,#0                 ;300
00006a  bd70              POP      {r4-r6,pc}
;;;302    
                          ENDP


                          AREA ||i._standard_request||, CODE, READONLY, ALIGN=2

                  _standard_request PROC
;;;476     */
;;;477    static rt_err_t _standard_request(struct udevice* device, ureq_t setup)
000000  b5fe              PUSH     {r1-r7,lr}
;;;478    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;479        udcd_t dcd;
;;;480        rt_uint16_t value = 0;
000006  2000              MOVS     r0,#0
000008  4669              MOV      r1,sp
00000a  8008              STRH     r0,[r1,#0]
;;;481    
;;;482        /* parameter check */
;;;483        RT_ASSERT(device != RT_NULL);
;;;484        RT_ASSERT(setup != RT_NULL);
;;;485    
;;;486        dcd = device->dcd;
;;;487    
;;;488        switch(setup->request_type & USB_REQ_TYPE_RECIPIENT_MASK)
00000c  7820              LDRB     r0,[r4,#0]
00000e  462f              MOV      r7,r5
000010  06c0              LSLS     r0,r0,#27
000012  0ec0              LSRS     r0,r0,#27
000014  3720              ADDS     r7,r7,#0x20
000016  6bae              LDR      r6,[r5,#0x38]
000018  2800              CMP      r0,#0
00001a  d007              BEQ      |L7.44|
00001c  2801              CMP      r0,#1
00001e  d051              BEQ      |L7.196|
000020  2802              CMP      r0,#2
000022  d06f              BEQ      |L7.260|
000024  2803              CMP      r0,#3
000026  d06e              BEQ      |L7.262|
;;;489        {
;;;490        case USB_REQ_TYPE_DEVICE:
;;;491            switch(setup->request)
;;;492            {
;;;493            case USB_REQ_GET_STATUS:
;;;494                rt_usbd_ep0_write(device, &value, 2);
;;;495                break;
;;;496            case USB_REQ_CLEAR_FEATURE:
;;;497                rt_usbd_clear_feature(device, setup->value, setup->index);
;;;498                dcd_ep0_send_status(dcd);
;;;499                break;
;;;500            case USB_REQ_SET_FEATURE:
;;;501                rt_usbd_set_feature(device, setup->value, setup->index);
;;;502                break;
;;;503            case USB_REQ_SET_ADDRESS:
;;;504                _set_address(device, setup);
;;;505                break;
;;;506            case USB_REQ_GET_DESCRIPTOR:
;;;507                _get_descriptor(device, setup);
;;;508                break;
;;;509            case USB_REQ_SET_DESCRIPTOR:
;;;510                rt_usbd_ep0_set_stall(device);
;;;511                break;
;;;512            case USB_REQ_GET_CONFIGURATION:
;;;513                _get_config(device, setup);
;;;514                break;
;;;515            case USB_REQ_SET_CONFIGURATION:
;;;516                _set_config(device, setup);
;;;517                break;
;;;518            default:
;;;519                rt_kprintf("unknown device request\n");
;;;520                rt_usbd_ep0_set_stall(device);
;;;521                break;
;;;522            }
;;;523            break;
;;;524        case USB_REQ_TYPE_INTERFACE:
;;;525            switch(setup->request)
;;;526            {
;;;527            case USB_REQ_GET_INTERFACE:
;;;528                _get_interface(device, setup);
;;;529                break;
;;;530            case USB_REQ_SET_INTERFACE:
;;;531                _set_interface(device, setup);
;;;532                break;
;;;533            default:
;;;534                if (_request_interface(device, setup) != RT_EOK)
;;;535                {
;;;536                    rt_kprintf("unknown interface request\n");
;;;537                    rt_usbd_ep0_set_stall(device);
;;;538                    return - RT_ERROR;
;;;539                }
;;;540                else
;;;541                    break;
;;;542            }
;;;543            break;
;;;544        case USB_REQ_TYPE_ENDPOINT:
;;;545            switch(setup->request)
;;;546            {
;;;547            case USB_REQ_GET_STATUS:
;;;548            {
;;;549                uep_t ep;
;;;550            
;;;551                ep = rt_usbd_find_endpoint(device, RT_NULL, setup->index);
;;;552                value = ep->stalled;        
;;;553                rt_usbd_ep0_write(device, &value, 2);
;;;554            }
;;;555            break;
;;;556            case USB_REQ_CLEAR_FEATURE:
;;;557            {
;;;558                uep_t ep;
;;;559                uio_request_t req;
;;;560                struct rt_list_node *node;
;;;561    
;;;562                ep = rt_usbd_find_endpoint(device, RT_NULL, setup->index);
;;;563                if(USB_EP_HALT == setup->value && ep->stalled == RT_TRUE)
;;;564                {
;;;565                    rt_usbd_clear_feature(device, setup->value, setup->index);
;;;566                    dcd_ep0_send_status(dcd);
;;;567                    ep->stalled = RT_FALSE;  
;;;568    
;;;569                    for (node = ep->request_list.next; node != &ep->request_list; node = node->next)
;;;570                    {
;;;571                        req = (uio_request_t)rt_list_entry(node, struct uio_request, list);                    
;;;572                        rt_usbd_io_request(device, ep, req);
;;;573                        RT_DEBUG_LOG(RT_DEBUG_USB, ("fired a request\n"));                    
;;;574                    }
;;;575    
;;;576                    rt_list_init(&ep->request_list);
;;;577                }
;;;578            }
;;;579            break;
;;;580            case USB_REQ_SET_FEATURE:
;;;581            {
;;;582                uep_t ep;
;;;583    
;;;584                if(USB_EP_HALT == setup->value)
;;;585                {
;;;586                    ep = rt_usbd_find_endpoint(device, RT_NULL, setup->index);
;;;587                    ep->stalled = RT_TRUE;            
;;;588                    rt_usbd_set_feature(device, setup->value, setup->index);
;;;589                    dcd_ep0_send_status(dcd);
;;;590                }    
;;;591            }
;;;592            break;
;;;593            case USB_REQ_SYNCH_FRAME:
;;;594                break;
;;;595            default:
;;;596                rt_kprintf("unknown endpoint request\n");
;;;597                rt_usbd_ep0_set_stall(device);
;;;598                break;
;;;599            }
;;;600            break;
;;;601        case USB_REQ_TYPE_OTHER:
;;;602            rt_kprintf("unknown other type request\n");
;;;603            rt_usbd_ep0_set_stall(device);
;;;604            break;
;;;605        default:
;;;606            rt_kprintf("unknown type request\n");
000028  a07c              ADR      r0,|L7.540|
;;;607            rt_usbd_ep0_set_stall(device);
;;;608            break;
00002a  e0f3              B        |L7.532|
                  |L7.44|
00002c  7860              LDRB     r0,[r4,#1]            ;491
00002e  0003              MOVS     r3,r0                 ;491
000030  f7fffffe          BL       __ARM_common_switch8
000034  0a060846          DCB      0x0a,0x06,0x08,0x46
000038  1446202f          DCB      0x14,0x46,0x20,0x2f
00003c  6d344146          DCB      0x6d,0x34,0x41,0x46
                  |L7.64|
000040  2202              MOVS     r2,#2                 ;494
000042  e078              B        |L7.310|
000044  7960              LDRB     r0,[r4,#5]            ;497
000046  7921              LDRB     r1,[r4,#4]            ;497
000048  0202              LSLS     r2,r0,#8              ;497
00004a  78e0              LDRB     r0,[r4,#3]            ;497
00004c  430a              ORRS     r2,r2,r1              ;497
00004e  78a3              LDRB     r3,[r4,#2]            ;497
000050  0201              LSLS     r1,r0,#8              ;497
000052  4319              ORRS     r1,r1,r3              ;497
000054  4628              MOV      r0,r5                 ;497
000056  f7fffffe          BL       rt_usbd_clear_feature
00005a  e0d5              B        |L7.520|
00005c  7960              LDRB     r0,[r4,#5]            ;501
00005e  7921              LDRB     r1,[r4,#4]            ;501
000060  0202              LSLS     r2,r0,#8              ;501
000062  78e0              LDRB     r0,[r4,#3]            ;501
000064  430a              ORRS     r2,r2,r1              ;501
000066  78a3              LDRB     r3,[r4,#2]            ;501
000068  0201              LSLS     r1,r0,#8              ;501
00006a  4319              ORRS     r1,r1,r3              ;501
00006c  4628              MOV      r0,r5                 ;501
00006e  f7fffffe          BL       rt_usbd_set_feature
                  |L7.114|
000072  e0cc              B        |L7.526|
000074  6c30              LDR      r0,[r6,#0x40]         ;502
000076  6a40              LDR      r0,[r0,#0x24]         ;502
000078  4780              BLX      r0                    ;502
00007a  6ba9              LDR      r1,[r5,#0x38]         ;502
00007c  78e0              LDRB     r0,[r4,#3]            ;502
00007e  78a2              LDRB     r2,[r4,#2]            ;502
000080  6c09              LDR      r1,[r1,#0x40]         ;502
000082  0200              LSLS     r0,r0,#8              ;502
000084  4310              ORRS     r0,r0,r2              ;502
000086  6809              LDR      r1,[r1,#0]            ;502
000088  b2c0              UXTB     r0,r0                 ;502
00008a  4788              BLX      r1                    ;502
00008c  2006              MOVS     r0,#6                 ;502
00008e  7138              STRB     r0,[r7,#4]            ;502
000090  e0bd              B        |L7.526|
000092  4621              MOV      r1,r4                 ;507
000094  4628              MOV      r0,r5                 ;507
000096  f7fffffe          BL       _get_descriptor
00009a  e0b8              B        |L7.526|
00009c  7939              LDRB     r1,[r7,#4]            ;508
00009e  4628              MOV      r0,r5                 ;513
0000a0  2907              CMP      r1,#7                 ;513
0000a2  d005              BEQ      |L7.176|
0000a4  2100              MOVS     r1,#0                 ;513
                  |L7.166|
0000a6  466a              MOV      r2,sp                 ;513
0000a8  7111              STRB     r1,[r2,#4]            ;513
0000aa  2201              MOVS     r2,#1                 ;513
0000ac  a901              ADD      r1,sp,#4              ;513
0000ae  e043              B        |L7.312|
                  |L7.176|
0000b0  6b01              LDR      r1,[r0,#0x30]         ;514
0000b2  7b49              LDRB     r1,[r1,#0xd]          ;514
0000b4  e7f7              B        |L7.166|
0000b6  4621              MOV      r1,r4                 ;516
0000b8  4628              MOV      r0,r5                 ;516
0000ba  f7fffffe          BL       _set_config
0000be  e0a6              B        |L7.526|
0000c0  a05c              ADR      r0,|L7.564|
0000c2  e0a7              B        |L7.532|
                  |L7.196|
0000c4  7860              LDRB     r0,[r4,#1]            ;525
0000c6  280a              CMP      r0,#0xa               ;525
0000c8  d01e              BEQ      |L7.264|
0000ca  280b              CMP      r0,#0xb               ;525
0000cc  d037              BEQ      |L7.318|
0000ce  7961              LDRB     r1,[r4,#5]            ;525
0000d0  7922              LDRB     r2,[r4,#4]            ;525
0000d2  0209              LSLS     r1,r1,#8              ;525
0000d4  4311              ORRS     r1,r1,r2              ;525
0000d6  4628              MOV      r0,r5                 ;534
0000d8  b2c9              UXTB     r1,r1                 ;534
0000da  aa01              ADD      r2,sp,#4              ;534
0000dc  f7fffffe          BL       rt_usbd_find_interface
0000e0  2600              MOVS     r6,#0                 ;534
0000e2  43f6              MVNS     r6,r6                 ;534
0000e4  2800              CMP      r0,#0                 ;534
0000e6  d005              BEQ      |L7.244|
0000e8  6982              LDR      r2,[r0,#0x18]         ;534
0000ea  4621              MOV      r1,r4                 ;534
0000ec  9801              LDR      r0,[sp,#4]            ;534
0000ee  4790              BLX      r2                    ;534
0000f0  2800              CMP      r0,#0                 ;534
0000f2  d0be              BEQ      |L7.114|
                  |L7.244|
0000f4  a055              ADR      r0,|L7.588|
0000f6  f7fffffe          BL       rt_kprintf
0000fa  4628              MOV      r0,r5                 ;537
0000fc  f7fffffe          BL       rt_usbd_ep0_set_stall
000100  4630              MOV      r0,r6                 ;538
                  |L7.258|
;;;609        }
;;;610    
;;;611        return RT_EOK;
;;;612    }
000102  bdfe              POP      {r1-r7,pc}
                  |L7.260|
000104  e020              B        |L7.328|
                  |L7.262|
000106  e084              B        |L7.530|
                  |L7.264|
000108  7938              LDRB     r0,[r7,#4]
00010a  2807              CMP      r0,#7
00010c  d003              BEQ      |L7.278|
                  |L7.270|
00010e  4628              MOV      r0,r5
000110  f7fffffe          BL       rt_usbd_ep0_set_stall
000114  e07b              B        |L7.526|
                  |L7.278|
000116  7960              LDRB     r0,[r4,#5]
000118  7921              LDRB     r1,[r4,#4]
00011a  0200              LSLS     r0,r0,#8
00011c  4308              ORRS     r0,r0,r1
00011e  b2c1              UXTB     r1,r0
000120  2200              MOVS     r2,#0
000122  4628              MOV      r0,r5
000124  f7fffffe          BL       rt_usbd_find_interface
000128  68c0              LDR      r0,[r0,#0xc]
00012a  4669              MOV      r1,sp
00012c  6880              LDR      r0,[r0,#8]
00012e  2201              MOVS     r2,#1
000130  78c0              LDRB     r0,[r0,#3]
000132  7108              STRB     r0,[r1,#4]
000134  a901              ADD      r1,sp,#4
                  |L7.310|
000136  4628              MOV      r0,r5
                  |L7.312|
000138  f7fffffe          BL       rt_usbd_ep0_write
00013c  e067              B        |L7.526|
                  |L7.318|
00013e  4621              MOV      r1,r4                 ;531
000140  4628              MOV      r0,r5                 ;531
000142  f7fffffe          BL       _set_interface
000146  e062              B        |L7.526|
                  |L7.328|
000148  7860              LDRB     r0,[r4,#1]            ;545
00014a  2800              CMP      r0,#0                 ;545
00014c  d007              BEQ      |L7.350|
00014e  2801              CMP      r0,#1                 ;545
000150  d012              BEQ      |L7.376|
000152  2803              CMP      r0,#3                 ;545
000154  d03d              BEQ      |L7.466|
000156  280c              CMP      r0,#0xc               ;545
000158  d059              BEQ      |L7.526|
00015a  a043              ADR      r0,|L7.616|
00015c  e05a              B        |L7.532|
                  |L7.350|
00015e  7960              LDRB     r0,[r4,#5]            ;551
000160  7921              LDRB     r1,[r4,#4]            ;551
000162  0200              LSLS     r0,r0,#8              ;551
000164  4308              ORRS     r0,r0,r1              ;551
000166  b2c2              UXTB     r2,r0                 ;551
000168  2100              MOVS     r1,#0                 ;551
00016a  4628              MOV      r0,r5                 ;551
00016c  f7fffffe          BL       rt_usbd_find_endpoint
000170  8e00              LDRH     r0,[r0,#0x30]         ;552
000172  4669              MOV      r1,sp                 ;552
000174  8008              STRH     r0,[r1,#0]            ;552
000176  e763              B        |L7.64|
                  |L7.376|
000178  7960              LDRB     r0,[r4,#5]            ;562
00017a  7921              LDRB     r1,[r4,#4]            ;562
00017c  0200              LSLS     r0,r0,#8              ;562
00017e  4308              ORRS     r0,r0,r1              ;562
000180  b2c2              UXTB     r2,r0                 ;562
000182  2100              MOVS     r1,#0                 ;562
000184  4628              MOV      r0,r5                 ;562
000186  f7fffffe          BL       rt_usbd_find_endpoint
00018a  4607              MOV      r7,r0                 ;562
00018c  78e0              LDRB     r0,[r4,#3]            ;563
00018e  78a2              LDRB     r2,[r4,#2]            ;563
000190  0201              LSLS     r1,r0,#8              ;563
000192  4311              ORRS     r1,r1,r2              ;563
000194  d13b              BNE      |L7.526|
000196  6b38              LDR      r0,[r7,#0x30]         ;563
000198  2801              CMP      r0,#1                 ;563
00019a  d138              BNE      |L7.526|
00019c  7960              LDRB     r0,[r4,#5]            ;565
00019e  7923              LDRB     r3,[r4,#4]            ;565
0001a0  0202              LSLS     r2,r0,#8              ;565
0001a2  431a              ORRS     r2,r2,r3              ;565
0001a4  4628              MOV      r0,r5                 ;565
0001a6  f7fffffe          BL       rt_usbd_clear_feature
0001aa  6c30              LDR      r0,[r6,#0x40]         ;565
0001ac  6a40              LDR      r0,[r0,#0x24]         ;565
0001ae  4780              BLX      r0                    ;565
0001b0  2000              MOVS     r0,#0                 ;567
0001b2  6338              STR      r0,[r7,#0x30]         ;569
0001b4  463e              MOV      r6,r7                 ;569
0001b6  360c              ADDS     r6,r6,#0xc            ;569
0001b8  68fc              LDR      r4,[r7,#0xc]          ;569
0001ba  e005              B        |L7.456|
                  |L7.444|
0001bc  4622              MOV      r2,r4                 ;571
0001be  4639              MOV      r1,r7                 ;572
0001c0  4628              MOV      r0,r5                 ;572
0001c2  f7fffffe          BL       rt_usbd_io_request
0001c6  6824              LDR      r4,[r4,#0]            ;569
                  |L7.456|
0001c8  42b4              CMP      r4,r6                 ;569
0001ca  d1f7              BNE      |L7.444|
0001cc  6076              STR      r6,[r6,#4]            ;569
0001ce  6036              STR      r6,[r6,#0]            ;569
0001d0  e01d              B        |L7.526|
                  |L7.466|
0001d2  78e0              LDRB     r0,[r4,#3]            ;584
0001d4  78a1              LDRB     r1,[r4,#2]            ;584
0001d6  0200              LSLS     r0,r0,#8              ;584
0001d8  4308              ORRS     r0,r0,r1              ;584
0001da  d118              BNE      |L7.526|
0001dc  7960              LDRB     r0,[r4,#5]            ;586
0001de  7921              LDRB     r1,[r4,#4]            ;586
0001e0  0200              LSLS     r0,r0,#8              ;586
0001e2  4308              ORRS     r0,r0,r1              ;586
0001e4  b2c2              UXTB     r2,r0                 ;586
0001e6  2100              MOVS     r1,#0                 ;586
0001e8  4628              MOV      r0,r5                 ;586
0001ea  f7fffffe          BL       rt_usbd_find_endpoint
0001ee  2101              MOVS     r1,#1                 ;587
0001f0  6301              STR      r1,[r0,#0x30]         ;588
0001f2  7960              LDRB     r0,[r4,#5]            ;588
0001f4  7921              LDRB     r1,[r4,#4]            ;588
0001f6  0202              LSLS     r2,r0,#8              ;588
0001f8  78e0              LDRB     r0,[r4,#3]            ;588
0001fa  430a              ORRS     r2,r2,r1              ;588
0001fc  78a3              LDRB     r3,[r4,#2]            ;588
0001fe  0201              LSLS     r1,r0,#8              ;588
000200  4319              ORRS     r1,r1,r3              ;588
000202  4628              MOV      r0,r5                 ;588
000204  f7fffffe          BL       rt_usbd_set_feature
                  |L7.520|
000208  6c30              LDR      r0,[r6,#0x40]         ;588
00020a  6a40              LDR      r0,[r0,#0x24]         ;588
00020c  4780              BLX      r0                    ;588
                  |L7.526|
00020e  2000              MOVS     r0,#0                 ;611
000210  e777              B        |L7.258|
                  |L7.530|
000212  a01c              ADR      r0,|L7.644|
                  |L7.532|
000214  f7fffffe          BL       rt_kprintf
000218  e779              B        |L7.270|
;;;613    
                          ENDP

00021a  0000              DCW      0x0000
                  |L7.540|
00021c  756e6b6e          DCB      "unknown type request\n",0
000220  6f776e20
000224  74797065
000228  20726571
00022c  75657374
000230  0a00    
000232  00                DCB      0
000233  00                DCB      0
                  |L7.564|
000234  756e6b6e          DCB      "unknown device request\n",0
000238  6f776e20
00023c  64657669
000240  63652072
000244  65717565
000248  73740a00
                  |L7.588|
00024c  756e6b6e          DCB      "unknown interface request\n",0
000250  6f776e20
000254  696e7465
000258  72666163
00025c  65207265
000260  71756573
000264  740a00  
000267  00                DCB      0
                  |L7.616|
000268  756e6b6e          DCB      "unknown endpoint request\n",0
00026c  6f776e20
000270  656e6470
000274  6f696e74
000278  20726571
00027c  75657374
000280  0a00    
000282  00                DCB      0
000283  00                DCB      0
                  |L7.644|
000284  756e6b6e          DCB      "unknown other type request\n",0
000288  6f776e20
00028c  6f746865
000290  72207479
000294  70652072
000298  65717565
00029c  73740a00

                          AREA ||i._stop_notify||, CODE, READONLY, ALIGN=1

                  _stop_notify PROC
;;;869     */
;;;870    static rt_err_t _stop_notify(udevice_t device)
000000  b570              PUSH     {r4-r6,lr}
;;;871    {
000002  4605              MOV      r5,r0
;;;872        struct rt_list_node *i;
;;;873        ufunction_t func;
;;;874    
;;;875        RT_ASSERT(device != RT_NULL);
;;;876    
;;;877        /* to notity every function */
;;;878        for (i  = device->curr_cfg->func_list.next;
000004  6b00              LDR      r0,[r0,#0x30]
000006  30ff              ADDS     r0,r0,#0xff
000008  3001              ADDS     r0,#1
00000a  2600              MOVS     r6,#0
00000c  6944              LDR      r4,[r0,#0x14]         ;871
00000e  e00c              B        |L8.42|
                  |L8.16|
;;;879             i != &device->curr_cfg->func_list;
;;;880             i  = i->next)
;;;881        {
;;;882            func = (ufunction_t)rt_list_entry(i, struct ufunction, list);
;;;883            FUNC_DISABLE(func);
000010  68a1              LDR      r1,[r4,#8]
000012  4620              MOV      r0,r4                 ;882
000014  6849              LDR      r1,[r1,#4]
000016  2900              CMP      r1,#0
000018  d006              BEQ      |L8.40|
00001a  6981              LDR      r1,[r0,#0x18]
00001c  2901              CMP      r1,#1
00001e  d103              BNE      |L8.40|
000020  6186              STR      r6,[r0,#0x18]
000022  6881              LDR      r1,[r0,#8]
000024  6849              LDR      r1,[r1,#4]
000026  4788              BLX      r1
                  |L8.40|
000028  6824              LDR      r4,[r4,#0]            ;880
                  |L8.42|
00002a  6b28              LDR      r0,[r5,#0x30]         ;879
00002c  30ff              ADDS     r0,r0,#0xff           ;879
00002e  3015              ADDS     r0,r0,#0x15           ;879
000030  42a0              CMP      r0,r4                 ;879
000032  d1ed              BNE      |L8.16|
;;;884        }
;;;885    
;;;886        return RT_EOK;
000034  2000              MOVS     r0,#0
;;;887    }
000036  bd70              POP      {r4-r6,pc}
;;;888    
                          ENDP


                          AREA ||i.dcd_ep_read||, CODE, READONLY, ALIGN=1

                  dcd_ep_read PROC
;;;357    
;;;358    rt_inline rt_size_t dcd_ep_read(udcd_t dcd, rt_uint8_t address, void *buffer)
000000  b430              PUSH     {r4,r5}
;;;359    {
;;;360        RT_ASSERT(dcd != RT_NULL);
;;;361        RT_ASSERT(dcd->ops != RT_NULL);
;;;362    
;;;363        if(dcd->ops->ep_read != RT_NULL)
000002  6c00              LDR      r0,[r0,#0x40]
000004  460c              MOV      r4,r1                 ;359
000006  69c3              LDR      r3,[r0,#0x1c]
000008  2b00              CMP      r3,#0
00000a  d003              BEQ      |L9.20|
;;;364        {
;;;365            return dcd->ops->ep_read(address, buffer);
00000c  4620              MOV      r0,r4
00000e  bc30              POP      {r4,r5}
000010  4611              MOV      r1,r2
000012  4718              BX       r3
                  |L9.20|
;;;366        }
;;;367        else
;;;368        {
;;;369            return 0;
;;;370        }
;;;371    }
000014  bc30              POP      {r4,r5}
000016  2000              MOVS     r0,#0                 ;369
000018  4770              BX       lr
;;;372    
                          ENDP


                          AREA ||i.dcd_ep_read_prepare||, CODE, READONLY, ALIGN=1

                  dcd_ep_read_prepare PROC
;;;341    
;;;342    rt_inline rt_size_t dcd_ep_read_prepare(udcd_t dcd, rt_uint8_t address, void *buffer,
000000  b4f0              PUSH     {r4-r7}
;;;343                                   rt_size_t size)
;;;344    {
;;;345        RT_ASSERT(dcd != RT_NULL);
;;;346        RT_ASSERT(dcd->ops != RT_NULL);
;;;347    
;;;348        if(dcd->ops->ep_read_prepare != RT_NULL)
000002  6c00              LDR      r0,[r0,#0x40]
000004  4615              MOV      r5,r2                 ;344
000006  6984              LDR      r4,[r0,#0x18]
000008  460e              MOV      r6,r1                 ;344
00000a  2c00              CMP      r4,#0
00000c  d005              BEQ      |L10.26|
;;;349        {
;;;350            return dcd->ops->ep_read_prepare(address, buffer, size);
00000e  4629              MOV      r1,r5
000010  4630              MOV      r0,r6
000012  46a4              MOV      r12,r4
000014  bcf0              POP      {r4-r7}
000016  461a              MOV      r2,r3
000018  4760              BX       r12
                  |L10.26|
;;;351        }
;;;352        else
;;;353        {
;;;354            return 0;
;;;355        }
;;;356    }
00001a  bcf0              POP      {r4-r7}
00001c  2000              MOVS     r0,#0                 ;354
00001e  4770              BX       lr
;;;357    
                          ENDP


                          AREA ||i.dcd_ep_write||, CODE, READONLY, ALIGN=1

                  dcd_ep_write PROC
;;;372    
;;;373    rt_inline rt_size_t dcd_ep_write(udcd_t dcd, rt_uint8_t address, void *buffer,
000000  b4f0              PUSH     {r4-r7}
;;;374                                     rt_size_t size)
;;;375    {
;;;376        RT_ASSERT(dcd != RT_NULL);
;;;377        RT_ASSERT(dcd->ops != RT_NULL);
;;;378        RT_ASSERT(dcd->ops->ep_write != RT_NULL);
;;;379    
;;;380        return dcd->ops->ep_write(address, buffer, size);
000002  6c00              LDR      r0,[r0,#0x40]
000004  4615              MOV      r5,r2                 ;375
000006  460e              MOV      r6,r1                 ;375
000008  6a04              LDR      r4,[r0,#0x20]
00000a  4629              MOV      r1,r5
00000c  4630              MOV      r0,r6
00000e  46a4              MOV      r12,r4
000010  bcf0              POP      {r4-r7}
000012  461a              MOV      r2,r3
000014  4760              BX       r12
;;;381    }
;;;382    
                          ENDP


                          AREA ||i.rt_list_insert_before||, CODE, READONLY, ALIGN=1

                  rt_list_insert_before PROC
;;;76      */
;;;77     rt_inline void rt_list_insert_before(rt_list_t *l, rt_list_t *n)
000000  6842              LDR      r2,[r0,#4]
;;;78     {
;;;79         l->prev->next = n;
;;;80         n->prev = l->prev;
000002  6011              STR      r1,[r2,#0]
000004  6842              LDR      r2,[r0,#4]
;;;81     
;;;82         l->prev = n;
000006  604a              STR      r2,[r1,#4]
;;;83         n->next = l;
000008  6041              STR      r1,[r0,#4]
00000a  6008              STR      r0,[r1,#0]
;;;84     }
00000c  4770              BX       lr
;;;85     
                          ENDP


                          AREA ||i.rt_usbd_altsetting_add_endpoint||, CODE, READONLY, ALIGN=1

                  rt_usbd_altsetting_add_endpoint PROC
;;;1547    */
;;;1548   rt_err_t rt_usbd_altsetting_add_endpoint(ualtsetting_t setting, uep_t ep)
000000  b510              PUSH     {r4,lr}
;;;1549   {
000002  3014              ADDS     r0,r0,#0x14
;;;1550       RT_DEBUG_LOG(RT_DEBUG_USB, ("rt_usbd_altsetting_add_endpoint\n"));
;;;1551   
;;;1552       /* parameter check */
;;;1553       RT_ASSERT(setting != RT_NULL);
;;;1554       RT_ASSERT(ep != RT_NULL);
;;;1555   
;;;1556       /* insert the endpoint to the list */
;;;1557       rt_list_insert_before(&setting->ep_list, &ep->list);
000004  f7fffffe          BL       rt_list_insert_before
;;;1558   
;;;1559       return RT_EOK;
000008  2000              MOVS     r0,#0
;;;1560   }
00000a  bd10              POP      {r4,pc}
;;;1561   
                          ENDP


                          AREA ||i.rt_usbd_altsetting_config_descriptor||, CODE, READONLY, ALIGN=1

                  rt_usbd_altsetting_config_descriptor PROC
;;;1148    */
;;;1149   rt_err_t rt_usbd_altsetting_config_descriptor(ualtsetting_t setting, const void* desc, rt_off_t intf_pos)
000000  b570              PUSH     {r4-r6,lr}
;;;1150   {
000002  4615              MOV      r5,r2
000004  4604              MOV      r4,r0
;;;1151       RT_ASSERT(setting != RT_NULL);
;;;1152       RT_ASSERT(setting->desc !=RT_NULL);
;;;1153   
;;;1154       rt_memcpy(setting->desc, desc, setting->desc_size);
000006  6902              LDR      r2,[r0,#0x10]
000008  68c0              LDR      r0,[r0,#0xc]
00000a  f7fffffe          BL       rt_memcpy
;;;1155       setting->intf_desc = (uintf_desc_t)((char*)setting->desc + intf_pos);
00000e  68e0              LDR      r0,[r4,#0xc]
000010  1940              ADDS     r0,r0,r5
;;;1156   
;;;1157       return RT_EOK;
000012  60a0              STR      r0,[r4,#8]
000014  2000              MOVS     r0,#0
;;;1158   }
000016  bd70              POP      {r4-r6,pc}
;;;1159   
                          ENDP


                          AREA ||i.rt_usbd_altsetting_new||, CODE, READONLY, ALIGN=2

                  rt_usbd_altsetting_new PROC
;;;1105    */
;;;1106   ualtsetting_t rt_usbd_altsetting_new(rt_size_t desc_size)
000000  b570              PUSH     {r4-r6,lr}
;;;1107   {
000002  4605              MOV      r5,r0
;;;1108       ualtsetting_t setting;
;;;1109   
;;;1110       RT_DEBUG_LOG(RT_DEBUG_USB, ("rt_usbd_altsetting_new\n"));
;;;1111   
;;;1112       /* parameter check */
;;;1113       RT_ASSERT(desc_size > 0);
;;;1114   
;;;1115       /* allocate memory for the object */
;;;1116       setting = (ualtsetting_t)rt_malloc(sizeof(struct ualtsetting));
000004  201c              MOVS     r0,#0x1c
000006  f7fffffe          BL       rt_malloc
00000a  0004              MOVS     r4,r0
;;;1117       if(setting == RT_NULL)
00000c  d00e              BEQ      |L15.44|
;;;1118       {
;;;1119           rt_kprintf("alloc memery failed\n");
;;;1120           return RT_NULL;
;;;1121       }
;;;1122       /* allocate memory for the desc */
;;;1123       setting->desc = rt_malloc(desc_size);
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       rt_malloc
;;;1124       if (setting->desc == RT_NULL)
000014  60e0              STR      r0,[r4,#0xc]
000016  2800              CMP      r0,#0
000018  d00c              BEQ      |L15.52|
;;;1125       {
;;;1126           rt_kprintf("alloc desc memery failed\n");
;;;1127           rt_free(setting);
;;;1128           return RT_NULL;
;;;1129       }
;;;1130   
;;;1131       setting->desc_size = desc_size;
;;;1132       setting->intf_desc = RT_NULL;
00001a  2000              MOVS     r0,#0
;;;1133   
;;;1134       /* to initialize endpoint list */
;;;1135       rt_list_init(&setting->ep_list);
00001c  6125              STR      r5,[r4,#0x10]
00001e  60a0              STR      r0,[r4,#8]
000020  4620              MOV      r0,r4
000022  3014              ADDS     r0,r0,#0x14
000024  61a0              STR      r0,[r4,#0x18]
;;;1136   
;;;1137       return setting;
000026  6160              STR      r0,[r4,#0x14]
000028  4620              MOV      r0,r4
;;;1138   }
00002a  bd70              POP      {r4-r6,pc}
                  |L15.44|
00002c  a005              ADR      r0,|L15.68|
00002e  f7fffffe          BL       rt_kprintf
000032  e005              B        |L15.64|
                  |L15.52|
000034  a009              ADR      r0,|L15.92|
000036  f7fffffe          BL       rt_kprintf
00003a  4620              MOV      r0,r4                 ;1127
00003c  f7fffffe          BL       rt_free
                  |L15.64|
000040  2000              MOVS     r0,#0                 ;1128
000042  bd70              POP      {r4-r6,pc}
;;;1139   
                          ENDP

                  |L15.68|
000044  616c6c6f          DCB      "alloc memery failed\n",0
000048  63206d65
00004c  6d657279
000050  20666169
000054  6c65640a
000058  00      
000059  00                DCB      0
00005a  00                DCB      0
00005b  00                DCB      0
                  |L15.92|
00005c  616c6c6f          DCB      "alloc desc memery failed\n",0
000060  63206465
000064  7363206d
000068  656d6572
00006c  79206661
000070  696c6564
000074  0a00    
000076  00                DCB      0
000077  00                DCB      0

                          AREA ||i.rt_usbd_clear_feature||, CODE, READONLY, ALIGN=1

                  rt_usbd_clear_feature PROC
;;;1690    */
;;;1691   rt_err_t rt_usbd_clear_feature(udevice_t device, rt_uint16_t value, rt_uint16_t index)
000000  b510              PUSH     {r4,lr}
;;;1692   {
;;;1693       RT_ASSERT(device != RT_NULL);
;;;1694   
;;;1695       if (value == USB_FEATURE_DEV_REMOTE_WAKEUP)
000002  2901              CMP      r1,#1
000004  d006              BEQ      |L16.20|
;;;1696       {
;;;1697           RT_DEBUG_LOG(RT_DEBUG_USB, ("clear feature remote wakeup\n"));
;;;1698       }
;;;1699       else if (value == USB_FEATURE_ENDPOINT_HALT)
000006  2900              CMP      r1,#0
000008  d104              BNE      |L16.20|
;;;1700       {
;;;1701           RT_DEBUG_LOG(RT_DEBUG_USB, ("clear feature stall\n"));
;;;1702           dcd_ep_clear_stall(device->dcd, (rt_uint32_t)(index & 0xFF));
00000a  6b81              LDR      r1,[r0,#0x38]
00000c  b2d0              UXTB     r0,r2
00000e  6c09              LDR      r1,[r1,#0x40]
000010  68c9              LDR      r1,[r1,#0xc]
000012  4788              BLX      r1
                  |L16.20|
;;;1703       }
;;;1704       
;;;1705       return RT_EOK;
000014  2000              MOVS     r0,#0
;;;1706   }
000016  bd10              POP      {r4,pc}
;;;1707   
                          ENDP


                          AREA ||i.rt_usbd_config_add_function||, CODE, READONLY, ALIGN=1

                  rt_usbd_config_add_function PROC
;;;1478    */
;;;1479   rt_err_t rt_usbd_config_add_function(uconfig_t cfg, ufunction_t func)
000000  b510              PUSH     {r4,lr}
;;;1480   {
000002  30ff              ADDS     r0,r0,#0xff
000004  3015              ADDS     r0,r0,#0x15
;;;1481       RT_DEBUG_LOG(RT_DEBUG_USB, ("rt_usbd_config_add_function\n"));
;;;1482   
;;;1483       /* parameter check */
;;;1484       RT_ASSERT(cfg != RT_NULL);
;;;1485       RT_ASSERT(func != RT_NULL);
;;;1486   
;;;1487       /* insert the function to the list */
;;;1488       rt_list_insert_before(&cfg->func_list, &func->list);
000006  f7fffffe          BL       rt_list_insert_before
;;;1489   
;;;1490       return RT_EOK;
00000a  2000              MOVS     r0,#0
;;;1491   }
00000c  bd10              POP      {r4,pc}
;;;1492   
                          ENDP


                          AREA ||i.rt_usbd_config_new||, CODE, READONLY, ALIGN=2

                  rt_usbd_config_new PROC
;;;1034    */
;;;1035   uconfig_t rt_usbd_config_new(void)
000000  b570              PUSH     {r4-r6,lr}
;;;1036   {
;;;1037       uconfig_t cfg;
;;;1038   
;;;1039       RT_DEBUG_LOG(RT_DEBUG_USB, ("rt_usbd_config_new\n"));
;;;1040   
;;;1041       /* allocate memory for the object */
;;;1042       cfg = rt_malloc(sizeof(struct uconfig));
000002  25ff              MOVS     r5,#0xff
000004  351d              ADDS     r5,r5,#0x1d
000006  4628              MOV      r0,r5
000008  f7fffffe          BL       rt_malloc
00000c  0004              MOVS     r4,r0
;;;1043       if(cfg == RT_NULL)
00000e  d013              BEQ      |L18.56|
;;;1044       {
;;;1045           rt_kprintf("alloc memery failed\n");
;;;1046           return RT_NULL;
;;;1047       }
;;;1048       rt_memset(cfg, 0, sizeof(struct uconfig));
000010  462a              MOV      r2,r5
000012  2100              MOVS     r1,#0
000014  f7fffffe          BL       rt_memset
;;;1049   
;;;1050       /* set default value */
;;;1051       cfg->cfg_desc.bLength = USB_DESC_LENGTH_CONFIG;
000018  2009              MOVS     r0,#9
00001a  7220              STRB     r0,[r4,#8]
;;;1052       cfg->cfg_desc.type = USB_DESC_TYPE_CONFIGURATION;
00001c  2102              MOVS     r1,#2
00001e  7261              STRB     r1,[r4,#9]
;;;1053       cfg->cfg_desc.wTotalLength = USB_DESC_LENGTH_CONFIG;
000020  8160              STRH     r0,[r4,#0xa]
;;;1054       cfg->cfg_desc.bmAttributes = 0xC0;
000022  20c0              MOVS     r0,#0xc0
000024  73e0              STRB     r0,[r4,#0xf]
;;;1055       cfg->cfg_desc.MaxPower = 0x32;
000026  2032              MOVS     r0,#0x32
000028  7420              STRB     r0,[r4,#0x10]
;;;1056   
;;;1057       /* to initialize function object list */
;;;1058       rt_list_init(&cfg->func_list);
00002a  4620              MOV      r0,r4
00002c  30ff              ADDS     r0,r0,#0xff
00002e  3015              ADDS     r0,r0,#0x15
000030  6040              STR      r0,[r0,#4]
000032  6000              STR      r0,[r0,#0]
;;;1059   
;;;1060       return cfg;
000034  4620              MOV      r0,r4
;;;1061   }
000036  bd70              POP      {r4-r6,pc}
                  |L18.56|
000038  a002              ADR      r0,|L18.68|
00003a  f7fffffe          BL       rt_kprintf
00003e  2000              MOVS     r0,#0                 ;1046
000040  bd70              POP      {r4-r6,pc}
;;;1062   
                          ENDP

000042  0000              DCW      0x0000
                  |L18.68|
000044  616c6c6f          DCB      "alloc memery failed\n",0
000048  63206d65
00004c  6d657279
000050  20666169
000054  6c65640a
000058  00      
000059  00                DCB      0
00005a  00                DCB      0
00005b  00                DCB      0

                          AREA ||i.rt_usbd_connect_handler||, CODE, READONLY, ALIGN=1

                  rt_usbd_connect_handler PROC
;;;1905   
;;;1906   rt_err_t rt_usbd_connect_handler(udcd_t dcd)
000000  b51f              PUSH     {r0-r4,lr}
;;;1907   {
;;;1908       struct udev_msg msg;
;;;1909   
;;;1910       RT_ASSERT(dcd != RT_NULL);
;;;1911       
;;;1912       msg.type = USB_MSG_PLUG_IN;
000002  2106              MOVS     r1,#6
000004  466a              MOV      r2,sp
000006  7011              STRB     r1,[r2,#0]
;;;1913       msg.dcd = dcd;
;;;1914       rt_usbd_event_signal(&msg);
000008  9001              STR      r0,[sp,#4]
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       rt_usbd_event_signal
;;;1915   
;;;1916       return RT_EOK;
000010  2000              MOVS     r0,#0
;;;1917   }
000012  b004              ADD      sp,sp,#0x10
000014  bd10              POP      {r4,pc}
;;;1918   
                          ENDP


                          AREA ||i.rt_usbd_core_init||, CODE, READONLY, ALIGN=2

                  rt_usbd_core_init PROC
;;;2091    */
;;;2092   rt_err_t rt_usbd_core_init(void)
000000  b51f              PUSH     {r0-r4,lr}
;;;2093   {
;;;2094       rt_list_init(&device_list);
000002  4811              LDR      r0,|L20.72|
;;;2095   
;;;2096       /* create an usb message queue */
;;;2097       rt_mq_init(&usb_mq, "usbd", usb_mq_pool, USBD_MQ_MSG_SZ,
000004  2100              MOVS     r1,#0
000006  6040              STR      r0,[r0,#4]
000008  6000              STR      r0,[r0,#0]
00000a  2009              MOVS     r0,#9
00000c  0180              LSLS     r0,r0,#6
00000e  9101              STR      r1,[sp,#4]
000010  9000              STR      r0,[sp,#0]
000012  2320              MOVS     r3,#0x20
000014  4a0d              LDR      r2,|L20.76|
000016  a10e              ADR      r1,|L20.80|
000018  480f              LDR      r0,|L20.88|
00001a  f7fffffe          BL       rt_mq_init
;;;2098               sizeof(usb_mq_pool), RT_IPC_FLAG_FIFO);
;;;2099   
;;;2100       /* init usb device thread */
;;;2101       rt_thread_init(&usb_thread, "usbd", rt_usbd_thread_entry, RT_NULL,
00001e  480e              LDR      r0,|L20.88|
000020  2208              MOVS     r2,#8
000022  2314              MOVS     r3,#0x14
000024  0211              LSLS     r1,r2,#8
000026  3034              ADDS     r0,r0,#0x34
000028  466c              MOV      r4,sp
00002a  c40f              STM      r4!,{r0-r3}
00002c  4807              LDR      r0,|L20.76|
00002e  2300              MOVS     r3,#0
000030  4a0a              LDR      r2,|L20.92|
000032  a107              ADR      r1,|L20.80|
000034  3880              SUBS     r0,r0,#0x80
000036  f7fffffe          BL       rt_thread_init
;;;2102               usb_thread_stack, RT_USBD_THREAD_STACK_SZ, RT_USBD_THREAD_PRIO, 20);
;;;2103       /* rt_thread_init should always be OK, so start the thread without further
;;;2104        * checking. */
;;;2105       return rt_thread_startup(&usb_thread);
00003a  4804              LDR      r0,|L20.76|
00003c  3880              SUBS     r0,r0,#0x80
00003e  f7fffffe          BL       rt_thread_startup
;;;2106   }
000042  b004              ADD      sp,sp,#0x10
000044  bd10              POP      {r4,pc}
;;;2107   
                          ENDP

000046  0000              DCW      0x0000
                  |L20.72|
                          DCD      ||.data||
                  |L20.76|
                          DCD      ||.bss||+0x8b4
                  |L20.80|
000050  75736264          DCB      "usbd",0
000054  00      
000055  00                DCB      0
000056  00                DCB      0
000057  00                DCB      0
                  |L20.88|
                          DCD      ||.bss||
                  |L20.92|
                          DCD      rt_usbd_thread_entry

                          AREA ||i.rt_usbd_device_add_config||, CODE, READONLY, ALIGN=2

                  rt_usbd_device_add_config PROC
;;;1419    */
;;;1420   rt_err_t rt_usbd_device_add_config(udevice_t device, uconfig_t cfg)
000000  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;1421   {
000002  b083              SUB      sp,sp,#0xc
;;;1422       struct rt_list_node *i, *j, *k;
;;;1423       ufunction_t func;
;;;1424       uintf_t intf;
;;;1425       uep_t ep;
;;;1426   
;;;1427       RT_DEBUG_LOG(RT_DEBUG_USB, ("rt_usbd_device_add_config\n"));
;;;1428   
;;;1429       /* parameter check */
;;;1430       RT_ASSERT(device != RT_NULL);
;;;1431       RT_ASSERT(cfg != RT_NULL);
;;;1432   
;;;1433       /* set configuration number to the configuration descriptor */
;;;1434       cfg->cfg_desc.bConfigurationValue = device->dev_desc.bNumConfigurations + 1;
000004  9803              LDR      r0,[sp,#0xc]
000006  460c              MOV      r4,r1                 ;1421
000008  7e40              LDRB     r0,[r0,#0x19]
00000a  1c40              ADDS     r0,r0,#1
00000c  7348              STRB     r0,[r1,#0xd]
;;;1435       device->dev_desc.bNumConfigurations++;
00000e  9803              LDR      r0,[sp,#0xc]
000010  9903              LDR      r1,[sp,#0xc]
000012  7e40              LDRB     r0,[r0,#0x19]
000014  1c40              ADDS     r0,r0,#1
000016  7648              STRB     r0,[r1,#0x19]
;;;1436   
;;;1437       for (i=cfg->func_list.next; i!=&cfg->func_list; i=i->next)
000018  20ff              MOVS     r0,#0xff
00001a  3015              ADDS     r0,r0,#0x15
00001c  5907              LDR      r7,[r0,r4]
00001e  1820              ADDS     r0,r4,r0
000020  9001              STR      r0,[sp,#4]            ;1421
000022  e02c              B        |L21.126|
                  |L21.36|
;;;1438       {
;;;1439           func = (ufunction_t)rt_list_entry(i, struct ufunction, list);
;;;1440   
;;;1441           for(j=func->intf_list.next; j!=&func->intf_list; j=j->next)
000024  4638              MOV      r0,r7
000026  301c              ADDS     r0,r0,#0x1c
000028  69fe              LDR      r6,[r7,#0x1c]
00002a  9000              STR      r0,[sp,#0]
00002c  e023              B        |L21.118|
                  |L21.46|
;;;1442           {
;;;1443               intf = (uintf_t)rt_list_entry(j, struct uinterface, list);
;;;1444               cfg->cfg_desc.bNumInterfaces++;
00002e  7b20              LDRB     r0,[r4,#0xc]
000030  1c40              ADDS     r0,r0,#1
000032  7320              STRB     r0,[r4,#0xc]
;;;1445   
;;;1446               /* allocate address for every endpoint in the interface alternate setting */
;;;1447               for(k=intf->curr_setting->ep_list.next;
000034  68f0              LDR      r0,[r6,#0xc]
000036  6945              LDR      r5,[r0,#0x14]
000038  e009              B        |L21.78|
                  |L21.58|
;;;1448                       k!=&intf->curr_setting->ep_list; k=k->next)
;;;1449               {
;;;1450                   ep = (uep_t)rt_list_entry(k, struct uendpoint, list);
00003a  4629              MOV      r1,r5
;;;1451                   if(rt_usbd_ep_assign(device, ep) != RT_EOK)
00003c  9803              LDR      r0,[sp,#0xc]
00003e  f7fffffe          BL       rt_usbd_ep_assign
000042  2800              CMP      r0,#0
000044  d002              BEQ      |L21.76|
;;;1452                   {
;;;1453                       rt_kprintf("endpoint assign error\n");
000046  a013              ADR      r0,|L21.148|
000048  f7fffffe          BL       rt_kprintf
                  |L21.76|
00004c  682d              LDR      r5,[r5,#0]            ;1448
                  |L21.78|
00004e  68f0              LDR      r0,[r6,#0xc]          ;1448
000050  3014              ADDS     r0,r0,#0x14           ;1448
000052  42a8              CMP      r0,r5                 ;1448
000054  d1f1              BNE      |L21.58|
;;;1454                   }
;;;1455               }
;;;1456   
;;;1457               /* construct complete configuration descriptor */
;;;1458               rt_memcpy((void*)&cfg->cfg_desc.data[cfg->cfg_desc.wTotalLength - USB_DESC_LENGTH_CONFIG], 
000056  68f0              LDR      r0,[r6,#0xc]
000058  4623              MOV      r3,r4
00005a  6902              LDR      r2,[r0,#0x10]
00005c  68c1              LDR      r1,[r0,#0xc]
00005e  8960              LDRH     r0,[r4,#0xa]
000060  3308              ADDS     r3,r3,#8
000062  18c0              ADDS     r0,r0,r3
000064  f7fffffe          BL       rt_memcpy
;;;1459                           (void*)intf->curr_setting->desc,
;;;1460                           intf->curr_setting->desc_size);
;;;1461               cfg->cfg_desc.wTotalLength += intf->curr_setting->desc_size;
000068  68f0              LDR      r0,[r6,#0xc]
00006a  8961              LDRH     r1,[r4,#0xa]
00006c  8a00              LDRH     r0,[r0,#0x10]
00006e  1808              ADDS     r0,r1,r0
000070  8160              STRH     r0,[r4,#0xa]
000072  6836              LDR      r6,[r6,#0]            ;1441
000074  9800              LDR      r0,[sp,#0]            ;1441
                  |L21.118|
000076  4286              CMP      r6,r0                 ;1441
000078  d1d9              BNE      |L21.46|
00007a  683f              LDR      r7,[r7,#0]            ;1437
00007c  9801              LDR      r0,[sp,#4]            ;1437
                  |L21.126|
00007e  4287              CMP      r7,r0                 ;1437
000080  d1d0              BNE      |L21.36|
;;;1462           }
;;;1463       }
;;;1464   
;;;1465       /* insert the configuration to the list */
;;;1466       rt_list_insert_before(&device->cfg_list, &cfg->list);
000082  9803              LDR      r0,[sp,#0xc]
000084  4621              MOV      r1,r4
000086  3028              ADDS     r0,r0,#0x28
000088  f7fffffe          BL       rt_list_insert_before
;;;1467   
;;;1468       return RT_EOK;
00008c  2000              MOVS     r0,#0
;;;1469   }
00008e  b005              ADD      sp,sp,#0x14
000090  bdf0              POP      {r4-r7,pc}
;;;1470   
                          ENDP

000092  0000              DCW      0x0000
                  |L21.148|
000094  656e6470          DCB      "endpoint assign error\n",0
000098  6f696e74
00009c  20617373
0000a0  69676e20
0000a4  6572726f
0000a8  720a00  
0000ab  00                DCB      0

                          AREA ||i.rt_usbd_device_new||, CODE, READONLY, ALIGN=2

                  rt_usbd_device_new PROC
;;;932     */
;;;933    udevice_t rt_usbd_device_new(void)
000000  b510              PUSH     {r4,lr}
;;;934    {
;;;935        udevice_t udevice;
;;;936    
;;;937        RT_DEBUG_LOG(RT_DEBUG_USB, ("rt_usbd_device_new\n"));
;;;938    
;;;939        /* allocate memory for the object */
;;;940        udevice = rt_malloc(sizeof(struct udevice));
000002  203c              MOVS     r0,#0x3c
000004  f7fffffe          BL       rt_malloc
000008  0004              MOVS     r4,r0
;;;941        if(udevice == RT_NULL)
00000a  d00d              BEQ      |L22.40|
;;;942        {
;;;943            rt_kprintf("alloc memery failed\n");
;;;944            return RT_NULL;
;;;945        }
;;;946        rt_memset(udevice, 0, sizeof(struct udevice));
00000c  223c              MOVS     r2,#0x3c
00000e  2100              MOVS     r1,#0
000010  f7fffffe          BL       rt_memset
;;;947    
;;;948        /* to initialize configuration list */
;;;949        rt_list_init(&udevice->cfg_list);
000014  4620              MOV      r0,r4
000016  3028              ADDS     r0,r0,#0x28
000018  62e0              STR      r0,[r4,#0x2c]
;;;950    
;;;951        /* insert the device object to device list */
;;;952        rt_list_insert_before(&device_list, &udevice->list);
00001a  62a0              STR      r0,[r4,#0x28]
00001c  4621              MOV      r1,r4
00001e  4805              LDR      r0,|L22.52|
000020  f7fffffe          BL       rt_list_insert_before
;;;953    
;;;954        return udevice;
000024  4620              MOV      r0,r4
;;;955    }
000026  bd10              POP      {r4,pc}
                  |L22.40|
000028  a003              ADR      r0,|L22.56|
00002a  f7fffffe          BL       rt_kprintf
00002e  2000              MOVS     r0,#0                 ;944
000030  bd10              POP      {r4,pc}
;;;956    
                          ENDP

000032  0000              DCW      0x0000
                  |L22.52|
                          DCD      ||.data||
                  |L22.56|
000038  616c6c6f          DCB      "alloc memery failed\n",0
00003c  63206d65
000040  6d657279
000044  20666169
000048  6c65640a
00004c  00      
00004d  00                DCB      0
00004e  00                DCB      0
00004f  00                DCB      0

                          AREA ||i.rt_usbd_device_set_controller||, CODE, READONLY, ALIGN=1

                  rt_usbd_device_set_controller PROC
;;;995     */
;;;996    rt_err_t rt_usbd_device_set_controller(udevice_t device, udcd_t dcd)
000000  6381              STR      r1,[r0,#0x38]
;;;997    {
;;;998        /* parameter check */
;;;999        RT_ASSERT(device != RT_NULL);
;;;1000       RT_ASSERT(dcd != RT_NULL);
;;;1001   
;;;1002       /* set usb device controller driver to the device */
;;;1003       device->dcd = dcd;
;;;1004   
;;;1005       return RT_EOK;
000002  2000              MOVS     r0,#0
;;;1006   }
000004  4770              BX       lr
;;;1007   
                          ENDP


                          AREA ||i.rt_usbd_device_set_descriptor||, CODE, READONLY, ALIGN=1

                  rt_usbd_device_set_descriptor PROC
;;;1015    */
;;;1016   rt_err_t rt_usbd_device_set_descriptor(udevice_t device, udev_desc_t dev_desc)
000000  b510              PUSH     {r4,lr}
;;;1017   {
;;;1018       /* parameter check */
;;;1019       RT_ASSERT(device != RT_NULL);
;;;1020       RT_ASSERT(dev_desc != RT_NULL);
;;;1021   
;;;1022       /* copy the usb device descriptor to the device */
;;;1023       rt_memcpy((void *)&device->dev_desc, (void *)dev_desc, USB_DESC_LENGTH_DEVICE);
000002  2212              MOVS     r2,#0x12
000004  3008              ADDS     r0,r0,#8
000006  f7fffffe          BL       rt_memcpy
;;;1024   
;;;1025       return RT_EOK;
00000a  2000              MOVS     r0,#0
;;;1026   }
00000c  bd10              POP      {r4,pc}
;;;1027   
                          ENDP


                          AREA ||i.rt_usbd_device_set_qualifier||, CODE, READONLY, ALIGN=1

                  rt_usbd_device_set_qualifier PROC
;;;976    
;;;977    rt_err_t rt_usbd_device_set_qualifier(udevice_t device, struct usb_qualifier_descriptor* qualifier)
000000  61c1              STR      r1,[r0,#0x1c]
;;;978    {
;;;979        /* parameter check */
;;;980        RT_ASSERT(device != RT_NULL);
;;;981        RT_ASSERT(qualifier != RT_NULL);
;;;982    
;;;983        device->dev_qualifier = qualifier;
;;;984    
;;;985        return RT_EOK;
000002  2000              MOVS     r0,#0
;;;986    }
000004  4770              BX       lr
;;;987    
                          ENDP


                          AREA ||i.rt_usbd_device_set_string||, CODE, READONLY, ALIGN=1

                  rt_usbd_device_set_string PROC
;;;964     */
;;;965    rt_err_t rt_usbd_device_set_string(udevice_t device, const char** ustring)
000000  6201              STR      r1,[r0,#0x20]
;;;966    {
;;;967        /* parameter check */
;;;968        RT_ASSERT(device != RT_NULL);
;;;969        RT_ASSERT(ustring != RT_NULL);
;;;970    
;;;971        /* set string descriptor array to the device object */
;;;972        device->str = ustring;
;;;973    
;;;974        return RT_EOK;
000002  2000              MOVS     r0,#0
;;;975    }
000004  4770              BX       lr
;;;976    
                          ENDP


                          AREA ||i.rt_usbd_disconnect_handler||, CODE, READONLY, ALIGN=1

                  rt_usbd_disconnect_handler PROC
;;;1918   
;;;1919   rt_err_t rt_usbd_disconnect_handler(udcd_t dcd)
000000  b51f              PUSH     {r0-r4,lr}
;;;1920   {
;;;1921       struct udev_msg msg;
;;;1922   
;;;1923       RT_ASSERT(dcd != RT_NULL);
;;;1924       
;;;1925       msg.type = USB_MSG_PLUG_OUT;
000002  2107              MOVS     r1,#7
000004  466a              MOV      r2,sp
000006  7011              STRB     r1,[r2,#0]
;;;1926       msg.dcd = dcd;
;;;1927       rt_usbd_event_signal(&msg);
000008  9001              STR      r0,[sp,#4]
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       rt_usbd_event_signal
;;;1928   
;;;1929       return RT_EOK;
000010  2000              MOVS     r0,#0
;;;1930   }
000012  b004              ADD      sp,sp,#0x10
000014  bd10              POP      {r4,pc}
;;;1931   
                          ENDP


                          AREA ||i.rt_usbd_endpoint_new||, CODE, READONLY, ALIGN=2

                  rt_usbd_endpoint_new PROC
;;;1205    */
;;;1206   uep_t rt_usbd_endpoint_new(uep_desc_t ep_desc, udep_handler_t handler)
000000  b570              PUSH     {r4-r6,lr}
;;;1207   {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;1208       uep_t ep;
;;;1209   
;;;1210       RT_DEBUG_LOG(RT_DEBUG_USB, ("rt_usbd_endpoint_new\n"));
;;;1211   
;;;1212       /* parameter check */
;;;1213       RT_ASSERT(ep_desc != RT_NULL);
;;;1214   
;;;1215       /* allocate memory for the object */
;;;1216       ep = (uep_t)rt_malloc(sizeof(struct uendpoint));
000006  2040              MOVS     r0,#0x40
000008  f7fffffe          BL       rt_malloc
;;;1217       if(ep == RT_NULL)
00000c  2800              CMP      r0,#0
00000e  d009              BEQ      |L28.36|
;;;1218       {
;;;1219           rt_kprintf("alloc memery failed\n");
;;;1220           return RT_NULL;
;;;1221       }
;;;1222       ep->ep_desc = ep_desc;
;;;1223       ep->handler = handler;
;;;1224       ep->buffer  = RT_NULL;
000010  2100              MOVS     r1,#0
;;;1225       ep->stalled = RT_FALSE;
000012  62c1              STR      r1,[r0,#0x2c]
;;;1226       rt_list_init(&ep->request_list);
000014  6085              STR      r5,[r0,#8]
000016  6384              STR      r4,[r0,#0x38]
000018  6301              STR      r1,[r0,#0x30]
00001a  4601              MOV      r1,r0
00001c  310c              ADDS     r1,r1,#0xc
00001e  6101              STR      r1,[r0,#0x10]
;;;1227   
;;;1228       return ep;
000020  60c1              STR      r1,[r0,#0xc]
;;;1229   }
000022  bd70              POP      {r4-r6,pc}
                  |L28.36|
000024  a002              ADR      r0,|L28.48|
000026  f7fffffe          BL       rt_kprintf
00002a  2000              MOVS     r0,#0                 ;1220
00002c  bd70              POP      {r4-r6,pc}
;;;1230   
                          ENDP

00002e  0000              DCW      0x0000
                  |L28.48|
000030  616c6c6f          DCB      "alloc memery failed\n",0
000034  63206d65
000038  6d657279
00003c  20666169
000040  6c65640a
000044  00      
000045  00                DCB      0
000046  00                DCB      0
000047  00                DCB      0

                          AREA ||i.rt_usbd_ep0_clear_stall||, CODE, READONLY, ALIGN=1

                  rt_usbd_ep0_clear_stall PROC
;;;1714   
;;;1715   rt_err_t rt_usbd_ep0_clear_stall(udevice_t device)
000000  6b81              LDR      r1,[r0,#0x38]
;;;1716   {
;;;1717       RT_ASSERT(device != RT_NULL);
;;;1718       
;;;1719       return dcd_ep_clear_stall(device->dcd, 0);
000002  2000              MOVS     r0,#0
000004  6c09              LDR      r1,[r1,#0x40]
000006  68c9              LDR      r1,[r1,#0xc]
000008  4708              BX       r1
;;;1720   }
;;;1721   
                          ENDP


                          AREA ||i.rt_usbd_ep0_in_handler||, CODE, READONLY, ALIGN=1

                  rt_usbd_ep0_in_handler PROC
;;;1826   
;;;1827   rt_err_t rt_usbd_ep0_in_handler(udcd_t dcd)
000000  b510              PUSH     {r4,lr}
;;;1828   {
000002  4604              MOV      r4,r0
;;;1829       RT_ASSERT(dcd != RT_NULL);
;;;1830   
;;;1831       if(dcd->ep0.request.remain_size >= dcd->ep0.id->maxpacket)
000004  6ec3              LDR      r3,[r0,#0x6c]
000006  6f80              LDR      r0,[r0,#0x78]
000008  78c0              LDRB     r0,[r0,#3]
00000a  4283              CMP      r3,r0
00000c  d30a              BCC      |L30.36|
;;;1832       {
;;;1833           dcd_ep_write(dcd, EP0_IN_ADDR, dcd->ep0.request.buffer, dcd->ep0.id->maxpacket);
00000e  4603              MOV      r3,r0
000010  2180              MOVS     r1,#0x80
000012  4620              MOV      r0,r4
000014  6e62              LDR      r2,[r4,#0x64]
000016  f7fffffe          BL       dcd_ep_write
;;;1834           dcd->ep0.request.remain_size -= dcd->ep0.id->maxpacket;
00001a  6fa1              LDR      r1,[r4,#0x78]
00001c  6ee0              LDR      r0,[r4,#0x6c]
00001e  78c9              LDRB     r1,[r1,#3]
000020  1a40              SUBS     r0,r0,r1
000022  e007              B        |L30.52|
                  |L30.36|
;;;1835       }
;;;1836       else if(dcd->ep0.request.remain_size > 0)
000024  2b00              CMP      r3,#0
000026  d007              BEQ      |L30.56|
;;;1837       {
;;;1838           dcd_ep_write(dcd, EP0_IN_ADDR, dcd->ep0.request.buffer, dcd->ep0.request.remain_size);
000028  2180              MOVS     r1,#0x80
00002a  4620              MOV      r0,r4
00002c  6e62              LDR      r2,[r4,#0x64]
00002e  f7fffffe          BL       dcd_ep_write
;;;1839           dcd->ep0.request.remain_size = 0;
000032  2000              MOVS     r0,#0
                  |L30.52|
000034  66e0              STR      r0,[r4,#0x6c]
000036  e005              B        |L30.68|
                  |L30.56|
;;;1840       }
;;;1841       else
;;;1842       {
;;;1843           dcd_ep_write(dcd, EP0_IN_ADDR, RT_NULL, 0);
000038  2300              MOVS     r3,#0
00003a  461a              MOV      r2,r3
00003c  2180              MOVS     r1,#0x80
00003e  4620              MOV      r0,r4
000040  f7fffffe          BL       dcd_ep_write
                  |L30.68|
;;;1844       }
;;;1845   
;;;1846       return RT_EOK;
000044  2000              MOVS     r0,#0
;;;1847   }
000046  bd10              POP      {r4,pc}
;;;1848   
                          ENDP


                          AREA ||i.rt_usbd_ep0_out_handler||, CODE, READONLY, ALIGN=1

                  rt_usbd_ep0_out_handler PROC
;;;1848   
;;;1849   rt_err_t rt_usbd_ep0_out_handler(udcd_t dcd, rt_size_t size)
000000  b51f              PUSH     {r0-r4,lr}
;;;1850   {
;;;1851       struct udev_msg msg;
;;;1852   
;;;1853       RT_ASSERT(dcd != RT_NULL);
;;;1854   
;;;1855       msg.type = USB_MSG_EP0_OUT;
000002  2202              MOVS     r2,#2
000004  466b              MOV      r3,sp
000006  701a              STRB     r2,[r3,#0]
;;;1856       msg.dcd = dcd;
;;;1857       msg.content.ep_msg.size = size;
;;;1858       rt_usbd_event_signal(&msg);
000008  9001              STR      r0,[sp,#4]
00000a  9102              STR      r1,[sp,#8]
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       rt_usbd_event_signal
;;;1859   
;;;1860       return RT_EOK;
000012  2000              MOVS     r0,#0
;;;1861   }
000014  b004              ADD      sp,sp,#0x10
000016  bd10              POP      {r4,pc}
;;;1862   
                          ENDP


                          AREA ||i.rt_usbd_ep0_read||, CODE, READONLY, ALIGN=1

                  rt_usbd_ep0_read PROC
;;;1973   
;;;1974   rt_size_t rt_usbd_ep0_read(udevice_t device, void *buffer, rt_size_t size, 
000000  b510              PUSH     {r4,lr}
;;;1975       rt_err_t (*rx_ind)(udevice_t device, rt_size_t size))
;;;1976   {
000002  4614              MOV      r4,r2
;;;1977       uep_t ep0;
;;;1978   
;;;1979       RT_ASSERT(device != RT_NULL);
;;;1980       RT_ASSERT(device->dcd != RT_NULL);
;;;1981       RT_ASSERT(buffer != RT_NULL);
;;;1982   
;;;1983       ep0 = &device->dcd->ep0;
;;;1984       ep0->request.size = size;
000004  6b82              LDR      r2,[r0,#0x38]
;;;1985       ep0->request.buffer = buffer;    
;;;1986       ep0->request.remain_size = size;
000006  6694              STR      r4,[r2,#0x68]
000008  66d4              STR      r4,[r2,#0x6c]
00000a  6651              STR      r1,[r2,#0x64]
00000c  3244              ADDS     r2,r2,#0x44
;;;1987       ep0->rx_indicate = rx_ind;
;;;1988       dcd_ep_read_prepare(device->dcd, EP0_OUT_ADDR, buffer, size);
00000e  63d3              STR      r3,[r2,#0x3c]
000010  460a              MOV      r2,r1
000012  6b80              LDR      r0,[r0,#0x38]
000014  4623              MOV      r3,r4
000016  2100              MOVS     r1,#0
000018  f7fffffe          BL       dcd_ep_read_prepare
;;;1989   
;;;1990       return size;
00001c  4620              MOV      r0,r4
;;;1991   }
00001e  bd10              POP      {r4,pc}
;;;1992   
                          ENDP


                          AREA ||i.rt_usbd_ep0_set_stall||, CODE, READONLY, ALIGN=1

                  rt_usbd_ep0_set_stall PROC
;;;1707   
;;;1708   rt_err_t rt_usbd_ep0_set_stall(udevice_t device)
000000  6b81              LDR      r1,[r0,#0x38]
;;;1709   {
;;;1710       RT_ASSERT(device != RT_NULL);
;;;1711       
;;;1712       return dcd_ep_set_stall(device->dcd, 0);
000002  2000              MOVS     r0,#0
000004  6c09              LDR      r1,[r1,#0x40]
000006  6889              LDR      r1,[r1,#8]
000008  4708              BX       r1
;;;1713   }
;;;1714   
                          ENDP


                          AREA ||i.rt_usbd_ep0_setup_handler||, CODE, READONLY, ALIGN=2

                  rt_usbd_ep0_setup_handler PROC
;;;1798   
;;;1799   rt_err_t rt_usbd_ep0_setup_handler(udcd_t dcd, struct urequest* setup)
000000  b51f              PUSH     {r0-r4,lr}
;;;1800   {
000002  4604              MOV      r4,r0
000004  a802              ADD      r0,sp,#8
;;;1801       struct udev_msg msg;
;;;1802       rt_size_t size;
;;;1803   
;;;1804       RT_ASSERT(dcd != RT_NULL);
;;;1805   
;;;1806       if(setup == RT_NULL)
000006  2900              CMP      r1,#0
000008  d00c              BEQ      |L34.36|
;;;1807       {
;;;1808           size = dcd_ep_read(dcd, EP0_OUT_ADDR, (void*)&msg.content.setup);
;;;1809           if(size != sizeof(struct urequest))
;;;1810           {
;;;1811               rt_kprintf("read setup packet error\n");
;;;1812               return -RT_ERROR;
;;;1813           }
;;;1814       }
;;;1815       else
;;;1816       {
;;;1817           rt_memcpy((void*)&msg.content.setup, (void*)setup, sizeof(struct urequest));
00000a  2208              MOVS     r2,#8
00000c  f7fffffe          BL       rt_memcpy
                  |L34.16|
;;;1818       }    
;;;1819       
;;;1820       msg.type = USB_MSG_SETUP_NOTIFY;
000010  2000              MOVS     r0,#0
000012  4669              MOV      r1,sp
000014  7008              STRB     r0,[r1,#0]
;;;1821       msg.dcd = dcd;
;;;1822       rt_usbd_event_signal(&msg);
000016  4668              MOV      r0,sp
000018  9401              STR      r4,[sp,#4]
00001a  f7fffffe          BL       rt_usbd_event_signal
;;;1823   
;;;1824       return RT_EOK;
00001e  2000              MOVS     r0,#0
                  |L34.32|
;;;1825   }
000020  b004              ADD      sp,sp,#0x10
000022  bd10              POP      {r4,pc}
                  |L34.36|
000024  4602              MOV      r2,r0
000026  2100              MOVS     r1,#0                 ;1808
000028  4620              MOV      r0,r4                 ;1808
00002a  f7fffffe          BL       dcd_ep_read
00002e  2808              CMP      r0,#8                 ;1809
000030  d0ee              BEQ      |L34.16|
000032  a003              ADR      r0,|L34.64|
000034  f7fffffe          BL       rt_kprintf
000038  2000              MOVS     r0,#0                 ;1812
00003a  43c0              MVNS     r0,r0                 ;1812
00003c  e7f0              B        |L34.32|
;;;1826   
                          ENDP

00003e  0000              DCW      0x0000
                  |L34.64|
000040  72656164          DCB      "read setup packet error\n",0
000044  20736574
000048  75702070
00004c  61636b65
000050  74206572
000054  726f720a
000058  00      
000059  00                DCB      0
00005a  00                DCB      0
00005b  00                DCB      0

                          AREA ||i.rt_usbd_ep0_write||, CODE, READONLY, ALIGN=1

                  rt_usbd_ep0_write PROC
;;;1944   
;;;1945   rt_size_t rt_usbd_ep0_write(udevice_t device, void *buffer, rt_size_t size)
000000  b510              PUSH     {r4,lr}
;;;1946   {
;;;1947       uep_t ep0;
;;;1948       rt_size_t sent_size = 0;
;;;1949   
;;;1950       RT_ASSERT(device != RT_NULL);    
;;;1951       RT_ASSERT(device->dcd != RT_NULL);
;;;1952       RT_ASSERT(buffer != RT_NULL);
;;;1953       RT_ASSERT(size > 0);
;;;1954   
;;;1955       ep0 = &device->dcd->ep0;
;;;1956       ep0->request.size = size;
000002  6b84              LDR      r4,[r0,#0x38]
;;;1957       ep0->request.buffer = buffer;
;;;1958       ep0->request.remain_size = size;
000004  66a2              STR      r2,[r4,#0x68]
;;;1959       if(ep0->request.remain_size >= ep0->id->maxpacket)
000006  66e2              STR      r2,[r4,#0x6c]
000008  6661              STR      r1,[r4,#0x64]
00000a  6fa3              LDR      r3,[r4,#0x78]
00000c  3444              ADDS     r4,r4,#0x44
00000e  78db              LDRB     r3,[r3,#3]
;;;1960       {
;;;1961           sent_size = dcd_ep_write(device->dcd, EP0_IN_ADDR, ep0->request.buffer, ep0->id->maxpacket);
;;;1962           ep0->request.remain_size -= sent_size;
;;;1963           ep0->request.buffer += ep0->id->maxpacket;
;;;1964       }
;;;1965       else
;;;1966       {
;;;1967           sent_size = dcd_ep_write(device->dcd, EP0_IN_ADDR, ep0->request.buffer, ep0->request.remain_size);
000010  6b80              LDR      r0,[r0,#0x38]
000012  429a              CMP      r2,r3                 ;1959
000014  d30c              BCC      |L35.48|
000016  460a              MOV      r2,r1                 ;1946
000018  2180              MOVS     r1,#0x80              ;1961
00001a  f7fffffe          BL       dcd_ep_write
00001e  6aa1              LDR      r1,[r4,#0x28]         ;1962
000020  1a09              SUBS     r1,r1,r0              ;1962
000022  62a1              STR      r1,[r4,#0x28]         ;1963
000024  6b62              LDR      r2,[r4,#0x34]         ;1963
000026  6a21              LDR      r1,[r4,#0x20]         ;1963
000028  78d2              LDRB     r2,[r2,#3]            ;1963
00002a  1889              ADDS     r1,r1,r2              ;1963
00002c  6221              STR      r1,[r4,#0x20]         ;1963
;;;1968           ep0->request.remain_size -= sent_size;        
;;;1969       }
;;;1970   
;;;1971       return sent_size;
;;;1972   }
00002e  bd10              POP      {r4,pc}
                  |L35.48|
000030  4613              MOV      r3,r2
000032  460a              MOV      r2,r1
000034  2180              MOVS     r1,#0x80              ;1967
000036  f7fffffe          BL       dcd_ep_write
00003a  6aa1              LDR      r1,[r4,#0x28]         ;1968
00003c  1a09              SUBS     r1,r1,r0              ;1968
00003e  62a1              STR      r1,[r4,#0x28]         ;1968
000040  bd10              POP      {r4,pc}
;;;1973   
                          ENDP


                          AREA ||i.rt_usbd_ep_assign||, CODE, READONLY, ALIGN=1

                  rt_usbd_ep_assign PROC
;;;1755   
;;;1756   static rt_err_t rt_usbd_ep_assign(udevice_t device, uep_t ep)
000000  b5f0              PUSH     {r4-r7,lr}
;;;1757   {
;;;1758       int i = 0;
;;;1759       
;;;1760       RT_ASSERT(device != RT_NULL);
;;;1761       RT_ASSERT(device->dcd != RT_NULL);    
;;;1762       RT_ASSERT(device->dcd->ep_pool != RT_NULL);        
;;;1763       RT_ASSERT(ep != RT_NULL);
;;;1764       RT_ASSERT(ep->ep_desc != RT_NULL);
;;;1765   
;;;1766       while(device->dcd->ep_pool[i].addr != 0xFF)
;;;1767       {
;;;1768           if(device->dcd->ep_pool[i].status == ID_UNASSIGNED && 
000002  6b82              LDR      r2,[r0,#0x38]
000004  2400              MOVS     r4,#0                 ;1758
000006  3280              ADDS     r2,r2,#0x80
000008  6853              LDR      r3,[r2,#4]            ;1757
00000a  e022              B        |L36.82|
                  |L36.12|
00000c  1d15              ADDS     r5,r2,#4
00000e  5d5d              LDRB     r5,[r3,r5]
000010  2d00              CMP      r5,#0
000012  d11d              BNE      |L36.80|
;;;1769               ep->ep_desc->bmAttributes == device->dcd->ep_pool[i].type &&
000014  1c55              ADDS     r5,r2,#1
000016  5d5e              LDRB     r6,[r3,r5]
000018  688d              LDR      r5,[r1,#8]
00001a  78ef              LDRB     r7,[r5,#3]
00001c  42be              CMP      r6,r7
00001e  d117              BNE      |L36.80|
;;;1770               ep->ep_desc->bEndpointAddress == device->dcd->ep_pool[i].dir)
000020  1c96              ADDS     r6,r2,#2
000022  5d9e              LDRB     r6,[r3,r6]
000024  78af              LDRB     r7,[r5,#2]
000026  42be              CMP      r6,r7
000028  d112              BNE      |L36.80|
;;;1771           {
;;;1772               EP_ADDRESS(ep) |= device->dcd->ep_pool[i].addr;
00002a  00a6              LSLS     r6,r4,#2
00002c  19a4              ADDS     r4,r4,r6
00002e  5d1b              LDRB     r3,[r3,r4]
000030  78ac              LDRB     r4,[r5,#2]
000032  4323              ORRS     r3,r3,r4
000034  70ab              STRB     r3,[r5,#2]
;;;1773               ep->id = &device->dcd->ep_pool[i];
000036  6b83              LDR      r3,[r0,#0x38]
000038  3380              ADDS     r3,r3,#0x80
00003a  685b              LDR      r3,[r3,#4]
00003c  189b              ADDS     r3,r3,r2
;;;1774               device->dcd->ep_pool[i].status = ID_ASSIGNED;
00003e  634b              STR      r3,[r1,#0x34]
000040  6b80              LDR      r0,[r0,#0x38]
000042  2101              MOVS     r1,#1
000044  3080              ADDS     r0,r0,#0x80
000046  6840              LDR      r0,[r0,#4]
000048  1d12              ADDS     r2,r2,#4
00004a  5481              STRB     r1,[r0,r2]
;;;1775   
;;;1776               RT_DEBUG_LOG(RT_DEBUG_USB, ("assigned %d\n", device->dcd->ep_pool[i].addr));  
;;;1777               return RT_EOK;
00004c  2000              MOVS     r0,#0
;;;1778           }
;;;1779           
;;;1780           i++;
;;;1781       }
;;;1782       
;;;1783       return -RT_ERROR;
;;;1784   }
00004e  bdf0              POP      {r4-r7,pc}
                  |L36.80|
000050  1c64              ADDS     r4,r4,#1
                  |L36.82|
000052  00a2              LSLS     r2,r4,#2              ;1766
000054  18a2              ADDS     r2,r4,r2              ;1766
000056  5c9d              LDRB     r5,[r3,r2]            ;1766
000058  2dff              CMP      r5,#0xff              ;1766
00005a  d1d7              BNE      |L36.12|
00005c  2000              MOVS     r0,#0                 ;1783
00005e  43c0              MVNS     r0,r0                 ;1783
000060  bdf0              POP      {r4-r7,pc}
;;;1785   
                          ENDP


                          AREA ||i.rt_usbd_ep_clear_stall||, CODE, READONLY, ALIGN=1

                  rt_usbd_ep_clear_stall PROC
;;;1738   
;;;1739   rt_err_t rt_usbd_ep_clear_stall(udevice_t device, uep_t ep)
000000  b510              PUSH     {r4,lr}
;;;1740   {
000002  460c              MOV      r4,r1
;;;1741       rt_err_t ret;
;;;1742   
;;;1743       RT_ASSERT(device != RT_NULL);
;;;1744       RT_ASSERT(ep != RT_NULL);
;;;1745       RT_ASSERT(ep->ep_desc != RT_NULL);
;;;1746   
;;;1747       ret = dcd_ep_clear_stall(device->dcd, EP_ADDRESS(ep));
000004  6b81              LDR      r1,[r0,#0x38]
000006  68a0              LDR      r0,[r4,#8]
000008  6c09              LDR      r1,[r1,#0x40]
00000a  7880              LDRB     r0,[r0,#2]
00000c  68c9              LDR      r1,[r1,#0xc]
00000e  4788              BLX      r1
;;;1748       if(ret == RT_EOK)
000010  2800              CMP      r0,#0
000012  d101              BNE      |L37.24|
;;;1749       {
;;;1750           ep->stalled = RT_FALSE;
000014  2100              MOVS     r1,#0
000016  6321              STR      r1,[r4,#0x30]
                  |L37.24|
;;;1751       }
;;;1752       
;;;1753       return ret;
;;;1754   }
000018  bd10              POP      {r4,pc}
;;;1755   
                          ENDP


                          AREA ||i.rt_usbd_ep_in_handler||, CODE, READONLY, ALIGN=1

                  rt_usbd_ep_in_handler PROC
;;;1862   
;;;1863   rt_err_t rt_usbd_ep_in_handler(udcd_t dcd, rt_uint8_t address)
000000  b51f              PUSH     {r0-r4,lr}
;;;1864   {
;;;1865       struct udev_msg msg;
;;;1866   
;;;1867       RT_ASSERT(dcd != RT_NULL);
;;;1868   
;;;1869       msg.type = USB_MSG_DATA_NOTIFY;
000002  2201              MOVS     r2,#1
000004  466b              MOV      r3,sp
000006  701a              STRB     r2,[r3,#0]
;;;1870       msg.dcd = dcd;
;;;1871       msg.content.ep_msg.ep_addr = address;
000008  9001              STR      r0,[sp,#4]
00000a  7319              STRB     r1,[r3,#0xc]
;;;1872       msg.content.ep_msg.size = 0;
00000c  2000              MOVS     r0,#0
;;;1873       rt_usbd_event_signal(&msg);
00000e  9002              STR      r0,[sp,#8]
000010  4668              MOV      r0,sp
000012  f7fffffe          BL       rt_usbd_event_signal
;;;1874   
;;;1875       return RT_EOK;
000016  2000              MOVS     r0,#0
;;;1876   }
000018  b004              ADD      sp,sp,#0x10
00001a  bd10              POP      {r4,pc}
;;;1877   
                          ENDP


                          AREA ||i.rt_usbd_ep_out_handler||, CODE, READONLY, ALIGN=1

                  rt_usbd_ep_out_handler PROC
;;;1877   
;;;1878   rt_err_t rt_usbd_ep_out_handler(udcd_t dcd, rt_uint8_t address, rt_size_t size)
000000  b51f              PUSH     {r0-r4,lr}
;;;1879   {
;;;1880       struct udev_msg msg;
;;;1881   
;;;1882       RT_ASSERT(dcd != RT_NULL);
;;;1883   
;;;1884       msg.type = USB_MSG_DATA_NOTIFY;
000002  2301              MOVS     r3,#1
000004  466c              MOV      r4,sp
000006  7023              STRB     r3,[r4,#0]
;;;1885       msg.dcd = dcd;
;;;1886       msg.content.ep_msg.ep_addr = address;
000008  9001              STR      r0,[sp,#4]
00000a  7321              STRB     r1,[r4,#0xc]
;;;1887       msg.content.ep_msg.size = size;
;;;1888       rt_usbd_event_signal(&msg);
00000c  4668              MOV      r0,sp
00000e  9202              STR      r2,[sp,#8]
000010  f7fffffe          BL       rt_usbd_event_signal
;;;1889   
;;;1890       return RT_EOK;
000014  2000              MOVS     r0,#0
;;;1891   }
000016  b004              ADD      sp,sp,#0x10
000018  bd10              POP      {r4,pc}
;;;1892   
                          ENDP


                          AREA ||i.rt_usbd_ep_set_stall||, CODE, READONLY, ALIGN=1

                  rt_usbd_ep_set_stall PROC
;;;1721   
;;;1722   rt_err_t rt_usbd_ep_set_stall(udevice_t device, uep_t ep)
000000  b510              PUSH     {r4,lr}
;;;1723   {
000002  460c              MOV      r4,r1
;;;1724       rt_err_t ret;
;;;1725       
;;;1726       RT_ASSERT(device != RT_NULL);
;;;1727       RT_ASSERT(ep != RT_NULL);
;;;1728       RT_ASSERT(ep->ep_desc != RT_NULL);  
;;;1729   
;;;1730       ret = dcd_ep_set_stall(device->dcd, EP_ADDRESS(ep));
000004  6b81              LDR      r1,[r0,#0x38]
000006  68a0              LDR      r0,[r4,#8]
000008  6c09              LDR      r1,[r1,#0x40]
00000a  7880              LDRB     r0,[r0,#2]
00000c  6889              LDR      r1,[r1,#8]
00000e  4788              BLX      r1
;;;1731       if(ret == RT_EOK)
000010  2800              CMP      r0,#0
000012  d101              BNE      |L40.24|
;;;1732       {
;;;1733           ep->stalled = RT_TRUE;
000014  2101              MOVS     r1,#1
000016  6321              STR      r1,[r4,#0x30]
                  |L40.24|
;;;1734       }
;;;1735       
;;;1736       return ret;
;;;1737   }
000018  bd10              POP      {r4,pc}
;;;1738   
                          ENDP


                          AREA ||i.rt_usbd_event_signal||, CODE, READONLY, ALIGN=2

                  rt_usbd_event_signal PROC
;;;2066    */
;;;2067   rt_err_t rt_usbd_event_signal(struct udev_msg* msg)
000000  b510              PUSH     {r4,lr}
;;;2068   {
;;;2069       RT_ASSERT(msg != RT_NULL);
;;;2070   
;;;2071       /* send message to usb message queue */
;;;2072       return rt_mq_send(&usb_mq, (void*)msg, sizeof(struct udev_msg));
000002  4601              MOV      r1,r0
000004  2210              MOVS     r2,#0x10
000006  4802              LDR      r0,|L41.16|
000008  f7fffffe          BL       rt_mq_send
;;;2073   }
00000c  bd10              POP      {r4,pc}
;;;2074   
                          ENDP

00000e  0000              DCW      0x0000
                  |L41.16|
                          DCD      ||.bss||

                          AREA ||i.rt_usbd_find_altsetting||, CODE, READONLY, ALIGN=2

                  rt_usbd_find_altsetting PROC
;;;1338    */
;;;1339   ualtsetting_t rt_usbd_find_altsetting(uintf_t intf, rt_uint8_t value)
000000  b510              PUSH     {r4,lr}
;;;1340   {
;;;1341       struct rt_list_node *i;
;;;1342       ualtsetting_t setting;
;;;1343   
;;;1344       RT_DEBUG_LOG(RT_DEBUG_USB, ("rt_usbd_find_altsetting\n"));
;;;1345   
;;;1346       /* parameter check */
;;;1347       RT_ASSERT(intf != RT_NULL);
;;;1348   
;;;1349       if(intf->curr_setting != RT_NULL)
000002  68c2              LDR      r2,[r0,#0xc]
000004  2a00              CMP      r2,#0
000006  d005              BEQ      |L42.20|
;;;1350       {
;;;1351           /* if the value equal to the current alternate setting, then do not search */
;;;1352           if(intf->curr_setting->intf_desc->bAlternateSetting == value)
000008  6893              LDR      r3,[r2,#8]
00000a  78db              LDRB     r3,[r3,#3]
00000c  428b              CMP      r3,r1
00000e  d101              BNE      |L42.20|
000010  4610              MOV      r0,r2
                  |L42.18|
;;;1353               return intf->curr_setting;
;;;1354       }
;;;1355   
;;;1356       /* search a setting in the alternate setting list */
;;;1357       for(i=intf->setting_list.next; i!=&intf->setting_list; i=i->next)
;;;1358       {
;;;1359           setting =(ualtsetting_t)rt_list_entry(i, struct ualtsetting, list);
;;;1360           if(setting->intf_desc->bAlternateSetting == value)
;;;1361               return setting;
;;;1362       }
;;;1363   
;;;1364       rt_kprintf("can't find alternate setting %d\n", value);
;;;1365       return RT_NULL;
;;;1366   }
000012  bd10              POP      {r4,pc}
                  |L42.20|
000014  4603              MOV      r3,r0                 ;1357
000016  3310              ADDS     r3,r3,#0x10           ;1357
000018  6902              LDR      r2,[r0,#0x10]         ;1357
00001a  e005              B        |L42.40|
                  |L42.28|
00001c  6894              LDR      r4,[r2,#8]            ;1360
00001e  4610              MOV      r0,r2                 ;1359
000020  78e4              LDRB     r4,[r4,#3]            ;1360
000022  428c              CMP      r4,r1                 ;1360
000024  d0f5              BEQ      |L42.18|
000026  6802              LDR      r2,[r0,#0]            ;1357
                  |L42.40|
000028  429a              CMP      r2,r3                 ;1357
00002a  d1f7              BNE      |L42.28|
00002c  a002              ADR      r0,|L42.56|
00002e  f7fffffe          BL       rt_kprintf
000032  2000              MOVS     r0,#0                 ;1365
000034  bd10              POP      {r4,pc}
;;;1367   
                          ENDP

000036  0000              DCW      0x0000
                  |L42.56|
000038  63616e27          DCB      "can't find alternate setting %d\n",0
00003c  74206669
000040  6e642061
000044  6c746572
000048  6e617465
00004c  20736574
000050  74696e67
000054  2025640a
000058  00      
000059  00                DCB      0
00005a  00                DCB      0
00005b  00                DCB      0

                          AREA ||i.rt_usbd_find_config||, CODE, READONLY, ALIGN=2

                  rt_usbd_find_config PROC
;;;1264    */
;;;1265   uconfig_t rt_usbd_find_config(udevice_t device, rt_uint8_t value)
000000  b510              PUSH     {r4,lr}
;;;1266   {
;;;1267       struct rt_list_node* node;
;;;1268       uconfig_t cfg = RT_NULL;
;;;1269   
;;;1270       RT_DEBUG_LOG(RT_DEBUG_USB, ("rt_usbd_find_config\n"));
;;;1271   
;;;1272       /* parameter check */
;;;1273       RT_ASSERT(device != RT_NULL);
;;;1274       RT_ASSERT(value <= device->dev_desc.bNumConfigurations);
;;;1275   
;;;1276       /* search a configration in the the device */
;;;1277       for (node = device->cfg_list.next; node != &device->cfg_list; node = node->next)
000002  4603              MOV      r3,r0
000004  3328              ADDS     r3,r3,#0x28
000006  6a82              LDR      r2,[r0,#0x28]         ;1266
000008  e004              B        |L43.20|
                  |L43.10|
;;;1278       {
;;;1279           cfg = (uconfig_t)rt_list_entry(node, struct udevice, list);
;;;1280           if(cfg->cfg_desc.bConfigurationValue == value)
00000a  7b54              LDRB     r4,[r2,#0xd]
00000c  4610              MOV      r0,r2                 ;1279
00000e  428c              CMP      r4,r1
000010  d006              BEQ      |L43.32|
000012  6802              LDR      r2,[r0,#0]            ;1277
                  |L43.20|
000014  429a              CMP      r2,r3                 ;1277
000016  d1f8              BNE      |L43.10|
;;;1281           {
;;;1282               return cfg;
;;;1283           }
;;;1284       }
;;;1285   
;;;1286       rt_kprintf("can't find configuration %d\n", value);
000018  a002              ADR      r0,|L43.36|
00001a  f7fffffe          BL       rt_kprintf
;;;1287       return RT_NULL;
00001e  2000              MOVS     r0,#0
                  |L43.32|
;;;1288   }
000020  bd10              POP      {r4,pc}
;;;1289   
                          ENDP

000022  0000              DCW      0x0000
                  |L43.36|
000024  63616e27          DCB      "can't find configuration %d\n",0
000028  74206669
00002c  6e642063
000030  6f6e6669
000034  67757261
000038  74696f6e
00003c  2025640a
000040  00      
000041  00                DCB      0
000042  00                DCB      0
000043  00                DCB      0

                          AREA ||i.rt_usbd_find_device||, CODE, READONLY, ALIGN=2

                  rt_usbd_find_device PROC
;;;1237    */
;;;1238   udevice_t rt_usbd_find_device(udcd_t dcd)
000000  b510              PUSH     {r4,lr}
;;;1239   {
;;;1240       struct rt_list_node* node;
;;;1241       udevice_t device;
;;;1242   
;;;1243       /* parameter check */
;;;1244       RT_ASSERT(dcd != RT_NULL);
;;;1245   
;;;1246       /* search a device in the the device list */
;;;1247       for (node = device_list.next; node != &device_list; node = node->next)
000002  4907              LDR      r1,|L44.32|
000004  4602              MOV      r2,r0                 ;1239
000006  6808              LDR      r0,[r1,#0]            ;1239  ; device_list
000008  e003              B        |L44.18|
                  |L44.10|
;;;1248       {
;;;1249           device = (udevice_t)rt_list_entry(node, struct udevice, list);
;;;1250           if(device->dcd == dcd) return device;
00000a  6b83              LDR      r3,[r0,#0x38]
00000c  4293              CMP      r3,r2
00000e  d006              BEQ      |L44.30|
000010  6800              LDR      r0,[r0,#0]            ;1247
                  |L44.18|
000012  4288              CMP      r0,r1                 ;1247
000014  d1f9              BNE      |L44.10|
;;;1251       }
;;;1252   
;;;1253       rt_kprintf("can't find device\n");
000016  a003              ADR      r0,|L44.36|
000018  f7fffffe          BL       rt_kprintf
;;;1254       return RT_NULL;
00001c  2000              MOVS     r0,#0
                  |L44.30|
;;;1255   }
00001e  bd10              POP      {r4,pc}
;;;1256   
                          ENDP

                  |L44.32|
                          DCD      ||.data||
                  |L44.36|
000024  63616e27          DCB      "can't find device\n",0
000028  74206669
00002c  6e642064
000030  65766963
000034  650a00  
000037  00                DCB      0

                          AREA ||i.rt_usbd_find_endpoint||, CODE, READONLY, ALIGN=2

                  rt_usbd_find_endpoint PROC
;;;1375    */
;;;1376   uep_t rt_usbd_find_endpoint(udevice_t device, ufunction_t* pfunc, rt_uint8_t ep_addr)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1377   {
000002  468c              MOV      r12,r1
;;;1378       uep_t ep;
;;;1379       struct rt_list_node *i, *j, *k;
;;;1380       ufunction_t func;
;;;1381       uintf_t intf;
;;;1382   
;;;1383       /* parameter check */
;;;1384       RT_ASSERT(device != RT_NULL);
;;;1385   
;;;1386       /* search a endpoint in the current configuration */
;;;1387       for (i=device->curr_cfg->func_list.next;
000004  6b01              LDR      r1,[r0,#0x30]
000006  20ff              MOVS     r0,#0xff
000008  3015              ADDS     r0,r0,#0x15
00000a  5844              LDR      r4,[r0,r1]
00000c  1809              ADDS     r1,r1,r0
00000e  e017              B        |L45.64|
                  |L45.16|
;;;1388               i!=&device->curr_cfg->func_list; i=i->next)
;;;1389       {
;;;1390           func = (ufunction_t)rt_list_entry(i, struct ufunction, list);
;;;1391           for(j=func->intf_list.next; j!=&func->intf_list; j=j->next)
000010  4627              MOV      r7,r4
000012  371c              ADDS     r7,r7,#0x1c
000014  69e3              LDR      r3,[r4,#0x1c]
000016  e010              B        |L45.58|
                  |L45.24|
;;;1392           {
;;;1393               intf = (uintf_t)rt_list_entry(j, struct uinterface, list);
;;;1394               for(k=intf->curr_setting->ep_list.next;
000018  68de              LDR      r6,[r3,#0xc]
00001a  6970              LDR      r0,[r6,#0x14]
00001c  3614              ADDS     r6,r6,#0x14
00001e  e009              B        |L45.52|
                  |L45.32|
;;;1395                       k!=&intf->curr_setting->ep_list; k=k->next)
;;;1396               {
;;;1397                   ep = (uep_t)rt_list_entry(k, struct uendpoint, list);
;;;1398                   if(EP_ADDRESS(ep) == ep_addr)
000020  6885              LDR      r5,[r0,#8]
000022  78ad              LDRB     r5,[r5,#2]
000024  4295              CMP      r5,r2
000026  d104              BNE      |L45.50|
;;;1399                   {
;;;1400                       if (pfunc != RT_NULL)
000028  4661              MOV      r1,r12
00002a  2900              CMP      r1,#0
00002c  d000              BEQ      |L45.48|
;;;1401                           *pfunc = func;
00002e  600c              STR      r4,[r1,#0]
                  |L45.48|
;;;1402                       return ep;
;;;1403                   }
;;;1404               }
;;;1405           }
;;;1406       }
;;;1407   
;;;1408       rt_kprintf("can't find endpoint 0x%x\n", ep_addr);
;;;1409       return RT_NULL;
;;;1410   }
000030  bdf8              POP      {r3-r7,pc}
                  |L45.50|
000032  6800              LDR      r0,[r0,#0]            ;1395
                  |L45.52|
000034  4286              CMP      r6,r0                 ;1395
000036  d1f3              BNE      |L45.32|
000038  681b              LDR      r3,[r3,#0]            ;1391
                  |L45.58|
00003a  42bb              CMP      r3,r7                 ;1391
00003c  d1ec              BNE      |L45.24|
00003e  6824              LDR      r4,[r4,#0]            ;1388
                  |L45.64|
000040  42a1              CMP      r1,r4                 ;1388
000042  d1e5              BNE      |L45.16|
000044  4611              MOV      r1,r2                 ;1408
000046  a002              ADR      r0,|L45.80|
000048  f7fffffe          BL       rt_kprintf
00004c  2000              MOVS     r0,#0                 ;1409
00004e  bdf8              POP      {r3-r7,pc}
;;;1411   
                          ENDP

                  |L45.80|
000050  63616e27          DCB      "can't find endpoint 0x%x\n",0
000054  74206669
000058  6e642065
00005c  6e64706f
000060  696e7420
000064  30782578
000068  0a00    
00006a  00                DCB      0
00006b  00                DCB      0

                          AREA ||i.rt_usbd_find_interface||, CODE, READONLY, ALIGN=2

                  rt_usbd_find_interface PROC
;;;1297    */
;;;1298   uintf_t rt_usbd_find_interface(udevice_t device, rt_uint8_t value, ufunction_t *pfunc)
000000  b570              PUSH     {r4-r6,lr}
;;;1299   {
;;;1300       struct rt_list_node *i, *j;
;;;1301       ufunction_t func;
;;;1302       uintf_t intf;
;;;1303   
;;;1304       RT_DEBUG_LOG(RT_DEBUG_USB, ("rt_usbd_find_interface\n"));
;;;1305   
;;;1306       /* parameter check */
;;;1307       RT_ASSERT(device != RT_NULL);
;;;1308       RT_ASSERT(value < device->nr_intf);
;;;1309   
;;;1310       /* search an interface in the current configuration */
;;;1311       for (i=device->curr_cfg->func_list.next;
000002  6b06              LDR      r6,[r0,#0x30]
000004  20ff              MOVS     r0,#0xff
000006  3015              ADDS     r0,r0,#0x15
000008  5983              LDR      r3,[r0,r6]
00000a  1836              ADDS     r6,r6,r0
00000c  e00e              B        |L46.44|
                  |L46.14|
;;;1312               i!=&device->curr_cfg->func_list; i=i->next)
;;;1313       {
;;;1314           func = (ufunction_t)rt_list_entry(i, struct ufunction, list);
;;;1315           for(j=func->intf_list.next; j!=&func->intf_list; j=j->next)
00000e  461d              MOV      r5,r3
000010  351c              ADDS     r5,r5,#0x1c
000012  69d8              LDR      r0,[r3,#0x1c]
000014  e007              B        |L46.38|
                  |L46.22|
;;;1316           {
;;;1317               intf = (uintf_t)rt_list_entry(j, struct uinterface, list);
;;;1318               if(intf->intf_num == value)
000016  7a04              LDRB     r4,[r0,#8]
000018  428c              CMP      r4,r1
00001a  d103              BNE      |L46.36|
;;;1319               {
;;;1320                   if (pfunc != RT_NULL)
00001c  2a00              CMP      r2,#0
00001e  d000              BEQ      |L46.34|
;;;1321                       *pfunc = func;
000020  6013              STR      r3,[r2,#0]
                  |L46.34|
;;;1322                   return intf;
;;;1323               }
;;;1324           }
;;;1325       }
;;;1326   
;;;1327       rt_kprintf("can't find interface %d\n", value);
;;;1328       return RT_NULL;
;;;1329   }
000022  bd70              POP      {r4-r6,pc}
                  |L46.36|
000024  6800              LDR      r0,[r0,#0]            ;1315
                  |L46.38|
000026  42a8              CMP      r0,r5                 ;1315
000028  d1f5              BNE      |L46.22|
00002a  681b              LDR      r3,[r3,#0]            ;1312
                  |L46.44|
00002c  429e              CMP      r6,r3                 ;1312
00002e  d1ee              BNE      |L46.14|
000030  a002              ADR      r0,|L46.60|
000032  f7fffffe          BL       rt_kprintf
000036  2000              MOVS     r0,#0                 ;1328
000038  bd70              POP      {r4-r6,pc}
;;;1330   
                          ENDP

00003a  0000              DCW      0x0000
                  |L46.60|
00003c  63616e27          DCB      "can't find interface %d\n",0
000040  74206669
000044  6e642069
000048  6e746572
00004c  66616365
000050  2025640a
000054  00      
000055  00                DCB      0
000056  00                DCB      0
000057  00                DCB      0

                          AREA ||i.rt_usbd_function_add_interface||, CODE, READONLY, ALIGN=1

                  rt_usbd_function_add_interface PROC
;;;1500    */
;;;1501   rt_err_t rt_usbd_function_add_interface(ufunction_t func, uintf_t intf)
000000  b510              PUSH     {r4,lr}
;;;1502   {
000002  301c              ADDS     r0,r0,#0x1c
;;;1503   
;;;1504       RT_DEBUG_LOG(RT_DEBUG_USB, ("rt_usbd_function_add_interface\n"));
;;;1505   
;;;1506       /* parameter check */
;;;1507       RT_ASSERT(func != RT_NULL);
;;;1508       RT_ASSERT(intf != RT_NULL);
;;;1509   
;;;1510       /* insert the interface to the list */
;;;1511       rt_list_insert_before(&func->intf_list, &intf->list);
000004  f7fffffe          BL       rt_list_insert_before
;;;1512   
;;;1513       return RT_EOK;
000008  2000              MOVS     r0,#0
;;;1514   }
00000a  bd10              POP      {r4,pc}
;;;1515   
                          ENDP


                          AREA ||i.rt_usbd_function_new||, CODE, READONLY, ALIGN=2

                  rt_usbd_function_new PROC
;;;1168    */
;;;1169   ufunction_t rt_usbd_function_new(udevice_t device, udev_desc_t dev_desc,
000000  b570              PUSH     {r4-r6,lr}
;;;1170                                 ufunction_ops_t ops)
;;;1171   {
000002  4606              MOV      r6,r0
000004  4614              MOV      r4,r2
000006  460d              MOV      r5,r1
;;;1172       ufunction_t func;
;;;1173   
;;;1174       RT_DEBUG_LOG(RT_DEBUG_USB, ("rt_usbd_function_new\n"));
;;;1175   
;;;1176       /* parameter check */
;;;1177       RT_ASSERT(device != RT_NULL);
;;;1178       RT_ASSERT(dev_desc != RT_NULL);
;;;1179   
;;;1180       /* allocate memory for the object */
;;;1181       func = (ufunction_t)rt_malloc(sizeof(struct ufunction));
000008  2024              MOVS     r0,#0x24
00000a  f7fffffe          BL       rt_malloc
;;;1182       if(func == RT_NULL)
00000e  2800              CMP      r0,#0
000010  d009              BEQ      |L48.38|
;;;1183       {
;;;1184           rt_kprintf("alloc memery failed\n");
;;;1185           return RT_NULL;
;;;1186       }
;;;1187       func->dev_desc = dev_desc;
;;;1188       func->ops = ops;
;;;1189       func->device = device;
;;;1190       func->enabled = RT_FALSE;
;;;1191   
;;;1192       /* to initialize interface list */
;;;1193       rt_list_init(&func->intf_list);
000012  60c6              STR      r6,[r0,#0xc]
000014  6105              STR      r5,[r0,#0x10]
000016  2100              MOVS     r1,#0                 ;1190
000018  6084              STR      r4,[r0,#8]
00001a  6181              STR      r1,[r0,#0x18]
00001c  4601              MOV      r1,r0
00001e  311c              ADDS     r1,r1,#0x1c
000020  6201              STR      r1,[r0,#0x20]
;;;1194   
;;;1195       return func;
000022  61c1              STR      r1,[r0,#0x1c]
;;;1196   }
000024  bd70              POP      {r4-r6,pc}
                  |L48.38|
000026  a002              ADR      r0,|L48.48|
000028  f7fffffe          BL       rt_kprintf
00002c  2000              MOVS     r0,#0                 ;1185
00002e  bd70              POP      {r4-r6,pc}
;;;1197   
                          ENDP

                  |L48.48|
000030  616c6c6f          DCB      "alloc memery failed\n",0
000034  63206d65
000038  6d657279
00003c  20666169
000040  6c65640a
000044  00      
000045  00                DCB      0
000046  00                DCB      0
000047  00                DCB      0

                          AREA ||i.rt_usbd_interface_add_altsetting||, CODE, READONLY, ALIGN=1

                  rt_usbd_interface_add_altsetting PROC
;;;1523    */
;;;1524   rt_err_t rt_usbd_interface_add_altsetting(uintf_t intf, ualtsetting_t setting)
000000  b510              PUSH     {r4,lr}
;;;1525   {
;;;1526       RT_DEBUG_LOG(RT_DEBUG_USB, ("rt_usbd_interface_add_altsetting\n"));
;;;1527   
;;;1528       /* parameter check */
;;;1529       RT_ASSERT(intf != RT_NULL);
;;;1530       RT_ASSERT(setting != RT_NULL);
;;;1531   
;;;1532       setting->intf_desc->bInterfaceNumber = intf->intf_num;
000002  7a02              LDRB     r2,[r0,#8]
000004  688b              LDR      r3,[r1,#8]
000006  3010              ADDS     r0,r0,#0x10
000008  709a              STRB     r2,[r3,#2]
;;;1533   
;;;1534       /* insert the alternate setting to the list */
;;;1535       rt_list_insert_before(&intf->setting_list, &setting->list);
00000a  f7fffffe          BL       rt_list_insert_before
;;;1536   
;;;1537       return RT_EOK;
00000e  2000              MOVS     r0,#0
;;;1538   }
000010  bd10              POP      {r4,pc}
;;;1539   
                          ENDP


                          AREA ||i.rt_usbd_interface_new||, CODE, READONLY, ALIGN=2

                  rt_usbd_interface_new PROC
;;;1070    */
;;;1071   uintf_t rt_usbd_interface_new(udevice_t device, uintf_handler_t handler)
000000  b570              PUSH     {r4-r6,lr}
;;;1072   {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1073       uintf_t intf;
;;;1074   
;;;1075       RT_DEBUG_LOG(RT_DEBUG_USB, ("rt_usbd_interface_new\n"));
;;;1076   
;;;1077       /* parameter check */
;;;1078       RT_ASSERT(device != RT_NULL);
;;;1079   
;;;1080       /* allocate memory for the object */
;;;1081       intf = (uintf_t)rt_malloc(sizeof(struct uinterface));
000006  201c              MOVS     r0,#0x1c
000008  f7fffffe          BL       rt_malloc
;;;1082       if(intf == RT_NULL)
00000c  2800              CMP      r0,#0
00000e  d00d              BEQ      |L50.44|
000010  3420              ADDS     r4,r4,#0x20
;;;1083       {
;;;1084           rt_kprintf("alloc memery failed\n");
;;;1085           return RT_NULL;
;;;1086       }
;;;1087       intf->intf_num = device->nr_intf;
000012  7d21              LDRB     r1,[r4,#0x14]
000014  7201              STRB     r1,[r0,#8]
;;;1088       device->nr_intf++;
000016  7d21              LDRB     r1,[r4,#0x14]
000018  1c49              ADDS     r1,r1,#1
00001a  7521              STRB     r1,[r4,#0x14]
;;;1089       intf->handler = handler;
;;;1090       intf->curr_setting = RT_NULL;
00001c  2100              MOVS     r1,#0
;;;1091   
;;;1092       /* to initialize the alternate setting object list */
;;;1093       rt_list_init(&intf->setting_list);
00001e  6185              STR      r5,[r0,#0x18]
000020  60c1              STR      r1,[r0,#0xc]
000022  4601              MOV      r1,r0
000024  3110              ADDS     r1,r1,#0x10
000026  6141              STR      r1,[r0,#0x14]
;;;1094   
;;;1095       return intf;
000028  6101              STR      r1,[r0,#0x10]
;;;1096   }
00002a  bd70              POP      {r4-r6,pc}
                  |L50.44|
00002c  a002              ADR      r0,|L50.56|
00002e  f7fffffe          BL       rt_kprintf
000032  2000              MOVS     r0,#0                 ;1085
000034  bd70              POP      {r4-r6,pc}
;;;1097   
                          ENDP

000036  0000              DCW      0x0000
                  |L50.56|
000038  616c6c6f          DCB      "alloc memery failed\n",0
00003c  63206d65
000040  6d657279
000044  20666169
000048  6c65640a
00004c  00      
00004d  00                DCB      0
00004e  00                DCB      0
00004f  00                DCB      0

                          AREA ||i.rt_usbd_io_request||, CODE, READONLY, ALIGN=2

                  rt_usbd_io_request PROC
;;;1623    */
;;;1624   rt_size_t rt_usbd_io_request(udevice_t device, uep_t ep, uio_request_t req)
000000  b570              PUSH     {r4-r6,lr}
;;;1625   {
000002  4606              MOV      r6,r0
;;;1626       rt_size_t size = 0;
;;;1627       
;;;1628       RT_ASSERT(device != RT_NULL);
;;;1629       RT_ASSERT(req != RT_NULL);
;;;1630   
;;;1631       if(ep->stalled == RT_FALSE)
000004  6b08              LDR      r0,[r1,#0x30]
000006  2500              MOVS     r5,#0                 ;1626
000008  460c              MOV      r4,r1                 ;1625
00000a  2800              CMP      r0,#0
00000c  d006              BEQ      |L51.28|
;;;1632       {
;;;1633           switch(req->req_type)
;;;1634           {
;;;1635           case UIO_REQUEST_READ_MOST:
;;;1636           case UIO_REQUEST_READ_FULL:
;;;1637               ep->request.remain_size = ep->request.size;
;;;1638               size = rt_usbd_ep_read_prepare(device, ep, req->buffer, req->size);
;;;1639               break;
;;;1640           case UIO_REQUEST_WRITE:
;;;1641               ep->request.remain_size = ep->request.size;
;;;1642               size = rt_usbd_ep_write(device, ep, req->buffer, req->size);
;;;1643               break;
;;;1644           default:
;;;1645               rt_kprintf("unknown request type\n");
;;;1646               break;
;;;1647           }
;;;1648       }
;;;1649       else
;;;1650       {
;;;1651           rt_list_insert_before(&ep->request_list, &req->list);
00000e  4620              MOV      r0,r4
000010  4611              MOV      r1,r2
000012  300c              ADDS     r0,r0,#0xc
000014  f7fffffe          BL       rt_list_insert_before
                  |L51.24|
;;;1652           RT_DEBUG_LOG(RT_DEBUG_USB, ("suspend a request\n"));
;;;1653       }            
;;;1654   
;;;1655       return size;
000018  4628              MOV      r0,r5
;;;1656   }
00001a  bd70              POP      {r4-r6,pc}
                  |L51.28|
00001c  7a10              LDRB     r0,[r2,#8]            ;1633
00001e  2800              CMP      r0,#0                 ;1633
000020  d007              BEQ      |L51.50|
000022  2801              CMP      r0,#1                 ;1633
000024  d005              BEQ      |L51.50|
000026  2802              CMP      r0,#2                 ;1633
000028  d00e              BEQ      |L51.72|
00002a  a016              ADR      r0,|L51.132|
00002c  f7fffffe          BL       rt_kprintf
000030  e7f2              B        |L51.24|
                  |L51.50|
000032  6a60              LDR      r0,[r4,#0x24]         ;1637
000034  62a0              STR      r0,[r4,#0x28]         ;1638
000036  6888              LDR      r0,[r1,#8]            ;1638
000038  68d5              LDR      r5,[r2,#0xc]          ;1638
00003a  6913              LDR      r3,[r2,#0x10]         ;1638
00003c  7881              LDRB     r1,[r0,#2]            ;1638
00003e  462a              MOV      r2,r5                 ;1638
000040  6bb0              LDR      r0,[r6,#0x38]         ;1638
000042  f7fffffe          BL       dcd_ep_read_prepare
000046  e01a              B        |L51.126|
                  |L51.72|
000048  6a63              LDR      r3,[r4,#0x24]         ;1641
00004a  62a3              STR      r3,[r4,#0x28]         ;1641
00004c  68a0              LDR      r0,[r4,#8]            ;1641
00004e  7941              LDRB     r1,[r0,#5]            ;1641
000050  7902              LDRB     r2,[r0,#4]            ;1641
000052  020d              LSLS     r5,r1,#8              ;1641
000054  4315              ORRS     r5,r5,r2              ;1641
000056  7881              LDRB     r1,[r0,#2]            ;1641
000058  6a22              LDR      r2,[r4,#0x20]         ;1641
00005a  6bb0              LDR      r0,[r6,#0x38]         ;1641
00005c  42ab              CMP      r3,r5                 ;1641
00005e  d309              BCC      |L51.116|
000060  462b              MOV      r3,r5                 ;1641
000062  f7fffffe          BL       dcd_ep_write
000066  6aa1              LDR      r1,[r4,#0x28]         ;1641
000068  1a09              SUBS     r1,r1,r0              ;1641
00006a  62a1              STR      r1,[r4,#0x28]         ;1641
00006c  6a21              LDR      r1,[r4,#0x20]         ;1641
00006e  1949              ADDS     r1,r1,r5              ;1641
000070  6221              STR      r1,[r4,#0x20]         ;1641
000072  e004              B        |L51.126|
                  |L51.116|
000074  f7fffffe          BL       dcd_ep_write
000078  6aa1              LDR      r1,[r4,#0x28]         ;1641
00007a  1a09              SUBS     r1,r1,r0              ;1641
00007c  62a1              STR      r1,[r4,#0x28]         ;1641
                  |L51.126|
00007e  4605              MOV      r5,r0                 ;1642
000080  e7ca              B        |L51.24|
;;;1657   
                          ENDP

000082  0000              DCW      0x0000
                  |L51.132|
000084  756e6b6e          DCB      "unknown request type\n",0
000088  6f776e20
00008c  72657175
000090  65737420
000094  74797065
000098  0a00    
00009a  00                DCB      0
00009b  00                DCB      0

                          AREA ||i.rt_usbd_reset_handler||, CODE, READONLY, ALIGN=1

                  rt_usbd_reset_handler PROC
;;;1892   
;;;1893   rt_err_t rt_usbd_reset_handler(udcd_t dcd)
000000  b51f              PUSH     {r0-r4,lr}
;;;1894   {
;;;1895       struct udev_msg msg;
;;;1896   
;;;1897       RT_ASSERT(dcd != RT_NULL);
;;;1898       
;;;1899       msg.type = USB_MSG_RESET;
000002  2105              MOVS     r1,#5
000004  466a              MOV      r2,sp
000006  7011              STRB     r1,[r2,#0]
;;;1900       msg.dcd = dcd;
;;;1901       rt_usbd_event_signal(&msg);
000008  9001              STR      r0,[sp,#4]
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       rt_usbd_event_signal
;;;1902   
;;;1903       return RT_EOK;
000010  2000              MOVS     r0,#0
;;;1904   }
000012  b004              ADD      sp,sp,#0x10
000014  bd10              POP      {r4,pc}
;;;1905   
                          ENDP


                          AREA ||i.rt_usbd_set_altsetting||, CODE, READONLY, ALIGN=1

                  rt_usbd_set_altsetting PROC
;;;1569    */
;;;1570   rt_err_t rt_usbd_set_altsetting(uintf_t intf, rt_uint8_t value)
000000  b510              PUSH     {r4,lr}
;;;1571   {
000002  4604              MOV      r4,r0
;;;1572       ualtsetting_t setting;
;;;1573   
;;;1574       RT_DEBUG_LOG(RT_DEBUG_USB, ("rt_usbd_set_altsetting\n"));
;;;1575   
;;;1576       /* parameter check */
;;;1577       RT_ASSERT(intf != RT_NULL);
;;;1578   
;;;1579       /* find an alternate setting */
;;;1580       setting = rt_usbd_find_altsetting(intf, value);
000004  f7fffffe          BL       rt_usbd_find_altsetting
;;;1581   
;;;1582       /* set as current alternate setting */
;;;1583       intf->curr_setting = setting;
;;;1584   
;;;1585       return RT_EOK;
000008  60e0              STR      r0,[r4,#0xc]
00000a  2000              MOVS     r0,#0
;;;1586   }
00000c  bd10              POP      {r4,pc}
;;;1587   
                          ENDP


                          AREA ||i.rt_usbd_set_config||, CODE, READONLY, ALIGN=1

                  rt_usbd_set_config PROC
;;;1595    */
;;;1596   rt_err_t rt_usbd_set_config(udevice_t device, rt_uint8_t value)
000000  b510              PUSH     {r4,lr}
;;;1597   {
000002  4604              MOV      r4,r0
;;;1598       uconfig_t cfg;
;;;1599   
;;;1600       RT_DEBUG_LOG(RT_DEBUG_USB, ("rt_usbd_set_config\n"));
;;;1601   
;;;1602       /* parameter check */
;;;1603       RT_ASSERT(device != RT_NULL);
;;;1604       RT_ASSERT(value <= device->dev_desc.bNumConfigurations);
;;;1605   
;;;1606       /* find a configuration */
;;;1607       cfg = rt_usbd_find_config(device, value);
000004  f7fffffe          BL       rt_usbd_find_config
;;;1608   
;;;1609       /* set as current configuration */
;;;1610       device->curr_cfg = cfg;
;;;1611       
;;;1612       return RT_TRUE;
000008  6320              STR      r0,[r4,#0x30]
00000a  2001              MOVS     r0,#1
;;;1613   }
00000c  bd10              POP      {r4,pc}
;;;1614   
                          ENDP


                          AREA ||i.rt_usbd_set_feature||, CODE, READONLY, ALIGN=1

                  rt_usbd_set_feature PROC
;;;1665    */
;;;1666   rt_err_t rt_usbd_set_feature(udevice_t device, rt_uint16_t value, rt_uint16_t index)
000000  b510              PUSH     {r4,lr}
;;;1667   {
;;;1668       RT_ASSERT(device != RT_NULL);
;;;1669   
;;;1670       if (value == USB_FEATURE_DEV_REMOTE_WAKEUP)
000002  2901              CMP      r1,#1
000004  d006              BEQ      |L55.20|
;;;1671       {
;;;1672           RT_DEBUG_LOG(RT_DEBUG_USB, ("set feature remote wakeup\n"));
;;;1673       }
;;;1674       else if (value == USB_FEATURE_ENDPOINT_HALT)
000006  2900              CMP      r1,#0
000008  d104              BNE      |L55.20|
;;;1675       {
;;;1676           RT_DEBUG_LOG(RT_DEBUG_USB, ("set feature stall\n"));    
;;;1677           dcd_ep_set_stall(device->dcd, (rt_uint32_t)(index & 0xFF));
00000a  6b81              LDR      r1,[r0,#0x38]
00000c  b2d0              UXTB     r0,r2
00000e  6c09              LDR      r1,[r1,#0x40]
000010  6889              LDR      r1,[r1,#8]
000012  4788              BLX      r1
                  |L55.20|
;;;1678       }
;;;1679       
;;;1680       return RT_EOK;
000014  2000              MOVS     r0,#0
;;;1681   }
000016  bd10              POP      {r4,pc}
;;;1682   
                          ENDP


                          AREA ||i.rt_usbd_sof_handler||, CODE, READONLY, ALIGN=1

                  rt_usbd_sof_handler PROC
;;;1931   
;;;1932   rt_err_t rt_usbd_sof_handler(udcd_t dcd)
000000  b51f              PUSH     {r0-r4,lr}
;;;1933   {
;;;1934       struct udev_msg msg;
;;;1935   
;;;1936       RT_ASSERT(dcd != RT_NULL);
;;;1937       
;;;1938       msg.type = USB_MSG_SOF;
000002  2104              MOVS     r1,#4
000004  466a              MOV      r2,sp
000006  7011              STRB     r1,[r2,#0]
;;;1939       msg.dcd = dcd;
;;;1940       rt_usbd_event_signal(&msg);
000008  9001              STR      r0,[sp,#4]
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       rt_usbd_event_signal
;;;1941   
;;;1942       return RT_EOK;
000010  2000              MOVS     r0,#0
;;;1943   }
000012  b004              ADD      sp,sp,#0x10
000014  bd10              POP      {r4,pc}
;;;1944   
                          ENDP


                          AREA ||i.rt_usbd_thread_entry||, CODE, READONLY, ALIGN=2

                  rt_usbd_thread_entry PROC
;;;2002    */
;;;2003   static void rt_usbd_thread_entry(void* parameter)
000000  b51f              PUSH     {r0-r4,lr}
;;;2004   {
;;;2005       while(1)
;;;2006       {
;;;2007           struct udev_msg msg;
;;;2008           udevice_t device;
;;;2009   
;;;2010           /* receive message */
;;;2011           if(rt_mq_recv(&usb_mq, &msg, sizeof(struct udev_msg),
000002  2600              MOVS     r6,#0
000004  43f6              MVNS     r6,r6
000006  ad02              ADD      r5,sp,#8
                  |L57.8|
000008  4633              MOV      r3,r6
00000a  2210              MOVS     r2,#0x10
00000c  4669              MOV      r1,sp
00000e  483d              LDR      r0,|L57.260|
000010  f7fffffe          BL       rt_mq_recv
000014  2800              CMP      r0,#0
000016  d1f7              BNE      |L57.8|
;;;2012                       RT_WAITING_FOREVER) != RT_EOK )
;;;2013               continue;
;;;2014   
;;;2015           device = rt_usbd_find_device(msg.dcd);
000018  9801              LDR      r0,[sp,#4]
00001a  f7fffffe          BL       rt_usbd_find_device
00001e  0004              MOVS     r4,r0
;;;2016           if(device == RT_NULL)
000020  d009              BEQ      |L57.54|
;;;2017           {
;;;2018               rt_kprintf("invalid usb device\n");
;;;2019               continue;
;;;2020           }
;;;2021   
;;;2022           RT_DEBUG_LOG(RT_DEBUG_USB, ("message type %d\n", msg.type));
;;;2023           
;;;2024           switch (msg.type)
000022  4668              MOV      r0,sp
000024  7801              LDRB     r1,[r0,#0]
000026  000b              MOVS     r3,r1
000028  f7fffffe          BL       __ARM_common_switch8
00002c  081e193a          DCB      0x08,0x1e,0x19,0x3a
000030  6707575f          DCB      0x67,0x07,0x57,0x5f
000034  6367              DCB      0x63,0x67
                  |L57.54|
000036  a034              ADR      r0,|L57.264|
000038  e02f              B        |L57.154|
00003a  6b20              LDR      r0,[r4,#0x30]         ;2019
00003c  30ff              ADDS     r0,r0,#0xff           ;2019
00003e  3001              ADDS     r0,#1                 ;2019
;;;2025           {
;;;2026           case USB_MSG_SOF:
;;;2027               _sof_notify(device);
000040  6947              LDR      r7,[r0,#0x14]
000042  e006              B        |L57.82|
                  |L57.68|
000044  68b9              LDR      r1,[r7,#8]
000046  4638              MOV      r0,r7
000048  6889              LDR      r1,[r1,#8]
00004a  2900              CMP      r1,#0
00004c  d000              BEQ      |L57.80|
00004e  4788              BLX      r1
                  |L57.80|
000050  683f              LDR      r7,[r7,#0]
                  |L57.82|
000052  6b20              LDR      r0,[r4,#0x30]
000054  30ff              ADDS     r0,r0,#0xff
000056  3015              ADDS     r0,r0,#0x15
000058  42b8              CMP      r0,r7
00005a  d0d5              BEQ      |L57.8|
00005c  e7f2              B        |L57.68|
00005e  4629              MOV      r1,r5
;;;2028               break;
;;;2029           case USB_MSG_DATA_NOTIFY:
;;;2030               /* some buggy drivers will have USB_MSG_DATA_NOTIFY before the core
;;;2031                * got configured. */
;;;2032               _data_notify(device, &msg.content.ep_msg);
000060  4620              MOV      r0,r4
000062  f7fffffe          BL       _data_notify
;;;2033               break;
000066  e7cf              B        |L57.8|
000068  7a00              LDRB     r0,[r0,#8]
00006a  2260              MOVS     r2,#0x60
00006c  4629              MOV      r1,r5
00006e  4010              ANDS     r0,r0,r2
000070  d00a              BEQ      |L57.136|
000072  2820              CMP      r0,#0x20
000074  d00c              BEQ      |L57.144|
000076  2840              CMP      r0,#0x40
000078  d00e              BEQ      |L57.152|
00007a  a028              ADR      r0,|L57.284|
00007c  f7fffffe          BL       rt_kprintf
000080  4620              MOV      r0,r4
000082  f7fffffe          BL       rt_usbd_ep0_set_stall
000086  e7bf              B        |L57.8|
                  |L57.136|
000088  4620              MOV      r0,r4
00008a  f7fffffe          BL       _standard_request
00008e  e7bb              B        |L57.8|
                  |L57.144|
000090  4620              MOV      r0,r4
000092  f7fffffe          BL       _function_request
000096  e7b7              B        |L57.8|
                  |L57.152|
000098  a027              ADR      r0,|L57.312|
                  |L57.154|
00009a  f7fffffe          BL       rt_kprintf
00009e  e7b3              B        |L57.8|
0000a0  6ba0              LDR      r0,[r4,#0x38]
;;;2034           case USB_MSG_SETUP_NOTIFY:
;;;2035               _setup_request(device, &msg.content.setup);
;;;2036               break;
;;;2037           case USB_MSG_EP0_OUT:
;;;2038               _ep0_out_notify(device, &msg.content.ep_msg);
0000a2  4627              MOV      r7,r4
0000a4  4604              MOV      r4,r0
0000a6  6ec2              LDR      r2,[r0,#0x6c]
0000a8  3444              ADDS     r4,r4,#0x44
0000aa  9902              LDR      r1,[sp,#8]
0000ac  2a00              CMP      r2,#0
0000ae  d0ab              BEQ      |L57.8|
0000b0  2900              CMP      r1,#0
0000b2  d104              BNE      |L57.190|
0000b4  6a22              LDR      r2,[r4,#0x20]
0000b6  f7fffffe          BL       dcd_ep_read
0000ba  0001              MOVS     r1,r0
0000bc  d0a4              BEQ      |L57.8|
                  |L57.190|
0000be  6aa0              LDR      r0,[r4,#0x28]
0000c0  1a40              SUBS     r0,r0,r1
0000c2  62a0              STR      r0,[r4,#0x28]
0000c4  6a22              LDR      r2,[r4,#0x20]
0000c6  1852              ADDS     r2,r2,r1
0000c8  6222              STR      r2,[r4,#0x20]
0000ca  2800              CMP      r0,#0
0000cc  d19c              BNE      |L57.8|
0000ce  6be2              LDR      r2,[r4,#0x3c]
0000d0  2a00              CMP      r2,#0
0000d2  d099              BEQ      |L57.8|
0000d4  4638              MOV      r0,r7
0000d6  4790              BLX      r2
0000d8  e796              B        |L57.8|
;;;2039               break;
;;;2040           case USB_MSG_RESET:            
;;;2041               RT_DEBUG_LOG(RT_DEBUG_USB, ("reset %d\n", device->state));
;;;2042               if (device->state == USB_STATE_ADDRESS)
0000da  2024              MOVS     r0,#0x24
0000dc  5d00              LDRB     r0,[r0,r4]
0000de  2806              CMP      r0,#6
0000e0  d192              BNE      |L57.8|
                  |L57.226|
;;;2043                   _stop_notify(device);
0000e2  4620              MOV      r0,r4
0000e4  f7fffffe          BL       _stop_notify
0000e8  e78e              B        |L57.8|
;;;2044               break;
;;;2045           case USB_MSG_PLUG_IN:
;;;2046               device->state = USB_STATE_ATTACHED;
0000ea  2001              MOVS     r0,#1
0000ec  3420              ADDS     r4,r4,#0x20
0000ee  7120              STRB     r0,[r4,#4]
;;;2047               break;
0000f0  e78a              B        |L57.8|
;;;2048           case USB_MSG_PLUG_OUT:
;;;2049               device->state = USB_STATE_NOTATTACHED;    
0000f2  2100              MOVS     r1,#0
0000f4  2024              MOVS     r0,#0x24
0000f6  5501              STRB     r1,[r0,r4]
;;;2050               _stop_notify(device);
;;;2051               break;
0000f8  e7f3              B        |L57.226|
;;;2052           default:
;;;2053               rt_kprintf("unknown msg type %d\n", msg.type);
0000fa  a015              ADR      r0,|L57.336|
0000fc  f7fffffe          BL       rt_kprintf
;;;2054               break;
000100  e782              B        |L57.8|
;;;2055           }
;;;2056       }
;;;2057   }
;;;2058   
                          ENDP

000102  0000              DCW      0x0000
                  |L57.260|
                          DCD      ||.bss||
                  |L57.264|
000108  696e7661          DCB      "invalid usb device\n",0
00010c  6c696420
000110  75736220
000114  64657669
000118  63650a00
                  |L57.284|
00011c  756e6b6e          DCB      "unknown setup request type\n",0
000120  6f776e20
000124  73657475
000128  70207265
00012c  71756573
000130  74207479
000134  70650a00
                  |L57.312|
000138  76656e64          DCB      "vendor type request\n",0
00013c  6f722074
000140  79706520
000144  72657175
000148  6573740a
00014c  00      
00014d  00                DCB      0
00014e  00                DCB      0
00014f  00                DCB      0
                  |L57.336|
000150  756e6b6e          DCB      "unknown msg type %d\n",0
000154  6f776e20
000158  6d736720
00015c  74797065
000160  2025640a
000164  00      
000165  00                DCB      0
000166  00                DCB      0
000167  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  usb_mq
                          %        52
                  usb_thread_stack
                          %        2048
                  usb_thread
                          %        128
                  usb_mq_pool
                          %        576

                          AREA ||.data||, DATA, ALIGN=2

                  device_list
                          %        8

                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d200              BCS      |L332.16|
00000e  461d              MOV      r5,r3
                  |L332.16|
000010  5d63              LDRB     r3,[r4,r5]
000012  005b              LSLS     r3,r3,#1
000014  18e3              ADDS     r3,r4,r3
000016  bc30              POP      {r4,r5}
000018  4718              BX       r3
                          ENDP

