; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\completion.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\completion.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I.\Libraries\Device\Nuvoton -I..\..\components\finsh -I.\Libraries\CMSIS\Include -I.\Libraries\StdDriver\inc -I..\..\include -I.\APP -I.\Drivers -I..\..\components\drivers\include -I..\..\components\drivers\include\drivers -I..\nuvoton_nuc240 -I.\Libraries\Device\Nuvoton\NUC230_240\Include -I..\..\include -I..\..\components\drivers\usb\usbdevice\class -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=521 --omf_browse=.\objects\completion.crf ..\..\components\drivers\src\completion.c]
                          THUMB

                          AREA ||i.rt_completion_done||, CODE, READONLY, ALIGN=1

                  rt_completion_done PROC
;;;110    
;;;111    void rt_completion_done(struct rt_completion *completion)
000000  b570              PUSH     {r4-r6,lr}
;;;112    {
000002  4604              MOV      r4,r0
;;;113        rt_base_t level;
;;;114        RT_ASSERT(completion != RT_NULL);
;;;115    
;;;116        if (completion->flag == RT_COMPLETED)
000004  6800              LDR      r0,[r0,#0]
000006  2801              CMP      r0,#1
000008  d00b              BEQ      |L1.34|
;;;117            return;
;;;118    
;;;119        level = rt_hw_interrupt_disable();
00000a  f7fffffe          BL       rt_hw_interrupt_disable
00000e  4605              MOV      r5,r0
;;;120        completion->flag = RT_COMPLETED;
000010  2001              MOVS     r0,#1
000012  6020              STR      r0,[r4,#0]
000014  6860              LDR      r0,[r4,#4]
000016  1d24              ADDS     r4,r4,#4
000018  42a0              CMP      r0,r4
00001a  d103              BNE      |L1.36|
;;;121    
;;;122        if (!rt_list_isempty(&(completion->suspended_list)))
;;;123        {
;;;124            /* there is one thread in suspended list */
;;;125            struct rt_thread *thread;
;;;126    
;;;127            /* get thread entry */
;;;128            thread = rt_list_entry(completion->suspended_list.next,
;;;129                                   struct rt_thread,
;;;130                                   tlist);
;;;131    
;;;132            /* resume it */
;;;133            rt_thread_resume(thread);
;;;134            rt_hw_interrupt_enable(level);
;;;135    
;;;136            /* perform a schedule */
;;;137            rt_schedule();
;;;138        }
;;;139        else
;;;140        {
;;;141            rt_hw_interrupt_enable(level);
00001c  4628              MOV      r0,r5
00001e  f7fffffe          BL       rt_hw_interrupt_enable
                  |L1.34|
;;;142        }
;;;143    }
000022  bd70              POP      {r4-r6,pc}
                  |L1.36|
000024  3814              SUBS     r0,r0,#0x14
000026  f7fffffe          BL       rt_thread_resume
00002a  4628              MOV      r0,r5                 ;134
00002c  f7fffffe          BL       rt_hw_interrupt_enable
000030  f7fffffe          BL       rt_schedule
000034  bd70              POP      {r4-r6,pc}
;;;144    RTM_EXPORT(rt_completion_done);
                          ENDP


                          AREA ||i.rt_completion_init||, CODE, READONLY, ALIGN=1

                  rt_completion_init PROC
;;;31     
;;;32     void rt_completion_init(struct rt_completion *completion)
000000  b510              PUSH     {r4,lr}
;;;33     {
000002  4604              MOV      r4,r0
;;;34         rt_base_t level;
;;;35         RT_ASSERT(completion != RT_NULL);
;;;36     
;;;37         level = rt_hw_interrupt_disable();
000004  f7fffffe          BL       rt_hw_interrupt_disable
;;;38         completion->flag = RT_UNCOMPLETED;
000008  2100              MOVS     r1,#0
00000a  c402              STM      r4!,{r1}
00000c  6064              STR      r4,[r4,#4]
00000e  6024              STR      r4,[r4,#0]
;;;39         rt_list_init(&completion->suspended_list);
;;;40         rt_hw_interrupt_enable(level);
000010  f7fffffe          BL       rt_hw_interrupt_enable
;;;41     }
000014  bd10              POP      {r4,pc}
;;;42     RTM_EXPORT(rt_completion_init);
                          ENDP


                          AREA ||i.rt_completion_wait||, CODE, READONLY, ALIGN=1

                  rt_completion_wait PROC
;;;43     
;;;44     rt_err_t rt_completion_wait(struct rt_completion *completion,
000000  b5f3              PUSH     {r0,r1,r4-r7,lr}
;;;45                                 rt_int32_t            timeout)
;;;46     {
000002  b081              SUB      sp,sp,#4
000004  4606              MOV      r6,r0
;;;47         rt_err_t result;
;;;48         rt_base_t level;
;;;49         rt_thread_t thread;
;;;50         RT_ASSERT(completion != RT_NULL);
;;;51     
;;;52         result = RT_EOK;
000006  2400              MOVS     r4,#0
;;;53         thread = rt_thread_self();
000008  f7fffffe          BL       rt_thread_self
00000c  4605              MOV      r5,r0
;;;54     
;;;55         level = rt_hw_interrupt_disable();
00000e  f7fffffe          BL       rt_hw_interrupt_disable
;;;56         if (completion->flag != RT_COMPLETED)
000012  9000              STR      r0,[sp,#0]
000014  6830              LDR      r0,[r6,#0]
000016  2700              MOVS     r7,#0
000018  2801              CMP      r0,#1
00001a  d025              BEQ      |L3.104|
;;;57         {
;;;58             /* only one thread can suspend on complete */
;;;59             RT_ASSERT(rt_list_isempty(&(completion->suspended_list)));
;;;60     
;;;61             if (timeout == 0)
00001c  9802              LDR      r0,[sp,#8]
00001e  2800              CMP      r0,#0
000020  d028              BEQ      |L3.116|
;;;62             {
;;;63                 result = -RT_ETIMEOUT;
;;;64                 goto __exit;
;;;65             }
;;;66             else
;;;67             {
;;;68                 /* reset thread error number */
;;;69                 thread->error = RT_EOK;
;;;70     
;;;71                 /* suspend thread */
;;;72                 rt_thread_suspend(thread);
000022  4628              MOV      r0,r5
000024  632f              STR      r7,[r5,#0x30]
000026  f7fffffe          BL       rt_thread_suspend
;;;73                 /* add to suspended list */
;;;74                 rt_list_insert_before(&(completion->suspended_list),
00002a  462c              MOV      r4,r5
00002c  68b1              LDR      r1,[r6,#8]
00002e  3414              ADDS     r4,r4,#0x14
000030  600c              STR      r4,[r1,#0]
000032  68b1              LDR      r1,[r6,#8]
000034  61a9              STR      r1,[r5,#0x18]
000036  1d30              ADDS     r0,r6,#4
000038  60b4              STR      r4,[r6,#8]
;;;75                                       &(thread->tlist));
;;;76     
;;;77                 /* current context checking */
;;;78                 RT_DEBUG_NOT_IN_INTERRUPT;
;;;79     
;;;80                 /* start timer */
;;;81                 if (timeout > 0)
00003a  6168              STR      r0,[r5,#0x14]
00003c  9802              LDR      r0,[sp,#8]
00003e  2800              CMP      r0,#0
000040  dd09              BLE      |L3.86|
;;;82                 {
;;;83                     /* reset the timeout of thread timer and start it */
;;;84                     rt_timer_control(&(thread->thread_timer),
000042  4628              MOV      r0,r5
000044  304c              ADDS     r0,r0,#0x4c
000046  aa02              ADD      r2,sp,#8
000048  2100              MOVS     r1,#0
00004a  4604              MOV      r4,r0
00004c  f7fffffe          BL       rt_timer_control
000050  4620              MOV      r0,r4
;;;85                                      RT_TIMER_CTRL_SET_TIME,
;;;86                                      &timeout);
;;;87                     rt_timer_start(&(thread->thread_timer));
000052  f7fffffe          BL       rt_timer_start
                  |L3.86|
;;;88                 }
;;;89                 /* enable interrupt */
;;;90                 rt_hw_interrupt_enable(level);
000056  9800              LDR      r0,[sp,#0]
000058  f7fffffe          BL       rt_hw_interrupt_enable
;;;91     
;;;92                 /* do schedule */
;;;93                 rt_schedule();
00005c  f7fffffe          BL       rt_schedule
;;;94     
;;;95                 /* thread is waked up */
;;;96                 result = thread->error;
;;;97     
;;;98                 level = rt_hw_interrupt_disable();
000060  6b2c              LDR      r4,[r5,#0x30]
000062  f7fffffe          BL       rt_hw_interrupt_disable
000066  9000              STR      r0,[sp,#0]
                  |L3.104|
;;;99             }
;;;100        }
;;;101        /* clean completed flag */
;;;102        completion->flag = RT_UNCOMPLETED;
000068  6037              STR      r7,[r6,#0]
                  |L3.106|
;;;103    
;;;104    __exit:
;;;105        rt_hw_interrupt_enable(level);
00006a  9800              LDR      r0,[sp,#0]
00006c  f7fffffe          BL       rt_hw_interrupt_enable
;;;106    
;;;107        return result;
000070  4620              MOV      r0,r4
;;;108    }
000072  bdfe              POP      {r1-r7,pc}
                  |L3.116|
000074  2401              MOVS     r4,#1                 ;63
000076  43e4              MVNS     r4,r4                 ;63
000078  e7f7              B        |L3.106|
;;;109    RTM_EXPORT(rt_completion_wait);
                          ENDP

