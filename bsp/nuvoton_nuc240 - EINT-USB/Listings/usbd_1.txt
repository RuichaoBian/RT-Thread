; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\usbd_1.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\usbd_1.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I.\Libraries\Device\Nuvoton -I..\..\components\finsh -I.\Libraries\CMSIS\Include -I.\Libraries\StdDriver\inc -I..\..\include -I.\APP -I.\Drivers -I..\..\components\drivers\include -I..\..\components\drivers\include\drivers -I..\nuvoton_nuc240 -I.\Libraries\Device\Nuvoton\NUC230_240\Include -I..\..\include -I..\..\components\drivers\usb\usbdevice\class -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=521 --omf_browse=.\objects\usbd_1.crf Libraries\StdDriver\src\usbd.c]
                          THUMB

                          AREA ||i.USBD_CtrlIn||, CODE, READONLY, ALIGN=2

                  USBD_CtrlIn PROC
;;;502      */
;;;503    void USBD_CtrlIn(void)
000000  b570              PUSH     {r4-r6,lr}
;;;504    {
;;;505        static uint8_t u8ZeroFlag = 0;
;;;506        
;;;507        DBG_PRINTF("Ctrl In Ack. residue %d\n", g_usbd_CtrlInSize);
;;;508        if(g_usbd_CtrlInSize)
000002  4c22              LDR      r4,|L1.140|
000004  68a0              LDR      r0,[r4,#8]  ; g_usbd_CtrlInSize
000006  2600              MOVS     r6,#0
;;;509        {
;;;510            // Process remained data
;;;511            if(g_usbd_CtrlInSize > g_usbd_CtrlMaxPktSize)
;;;512            {
;;;513                // Data size > MXPLD
;;;514                USBD_MemCopy((uint8_t *)USBD_BUF_BASE + USBD_GET_EP_BUF_ADDR(EP0), (uint8_t *)g_usbd_CtrlInPointer, g_usbd_CtrlMaxPktSize);
000008  4d21              LDR      r5,|L1.144|
00000a  2800              CMP      r0,#0                 ;508
00000c  d025              BEQ      |L1.90|
00000e  68a0              LDR      r0,[r4,#8]            ;511  ; g_usbd_CtrlInSize
000010  6a23              LDR      r3,[r4,#0x20]         ;511  ; g_usbd_CtrlMaxPktSize
000012  4621              MOV      r1,r4                 ;508
000014  4298              CMP      r0,r3                 ;511
000016  4a1f              LDR      r2,|L1.148|
000018  6849              LDR      r1,[r1,#4]
;;;515                USBD_SET_PAYLOAD_LEN(EP0, g_usbd_CtrlMaxPktSize);
;;;516                g_usbd_CtrlInPointer += g_usbd_CtrlMaxPktSize;
;;;517                g_usbd_CtrlInSize -= g_usbd_CtrlMaxPktSize;
;;;518            }
;;;519            else
;;;520            {
;;;521                // Data size <= MXPLD
;;;522                USBD_MemCopy((uint8_t *)USBD_BUF_BASE + USBD_GET_EP_BUF_ADDR(EP0), (uint8_t *)g_usbd_CtrlInPointer, g_usbd_CtrlInSize);
00001a  6828              LDR      r0,[r5,#0]
00001c  d90e              BLS      |L1.60|
00001e  1880              ADDS     r0,r0,r2              ;514
000020  6a22              LDR      r2,[r4,#0x20]         ;514  ; g_usbd_CtrlMaxPktSize
000022  f7fffffe          BL       USBD_MemCopy
000026  6a20              LDR      r0,[r4,#0x20]         ;515  ; g_usbd_CtrlMaxPktSize
000028  6068              STR      r0,[r5,#4]            ;515
00002a  6a21              LDR      r1,[r4,#0x20]         ;516  ; g_usbd_CtrlMaxPktSize
00002c  6860              LDR      r0,[r4,#4]            ;516  ; g_usbd_CtrlInPointer
00002e  1840              ADDS     r0,r0,r1              ;516
000030  6060              STR      r0,[r4,#4]            ;517  ; g_usbd_CtrlInPointer
000032  68a0              LDR      r0,[r4,#8]            ;517  ; g_usbd_CtrlInSize
000034  6a21              LDR      r1,[r4,#0x20]         ;517  ; g_usbd_CtrlMaxPktSize
000036  1a40              SUBS     r0,r0,r1              ;517
000038  60a0              STR      r0,[r4,#8]            ;517  ; g_usbd_CtrlInSize
;;;523                USBD_SET_PAYLOAD_LEN(EP0, g_usbd_CtrlInSize);
;;;524                if(g_usbd_CtrlInSize == g_usbd_CtrlMaxPktSize)
;;;525                    u8ZeroFlag = 1;
;;;526                g_usbd_CtrlInPointer = 0;
;;;527                g_usbd_CtrlInSize = 0;
;;;528            }
;;;529        }
;;;530        else // No more data for IN token
;;;531        {
;;;532            // In ACK for Set address
;;;533            if((g_usbd_SetupPacket[0] == REQ_STANDARD) && (g_usbd_SetupPacket[1] == SET_ADDRESS))
;;;534            {
;;;535                if((USBD_GET_ADDR() != g_usbd_UsbAddr) && (USBD_GET_ADDR() == 0))
;;;536                {
;;;537                    USBD_SET_ADDR(g_usbd_UsbAddr);
;;;538                }
;;;539            }
;;;540    
;;;541            /* For the case of data size is integral times maximum packet size */
;;;542            if(u8ZeroFlag)
;;;543            {
;;;544                USBD_SET_PAYLOAD_LEN(EP0, 0);
;;;545                u8ZeroFlag = 0;
;;;546            }
;;;547            
;;;548            DBG_PRINTF("Ctrl In done.\n");
;;;549        }
;;;550    }
00003a  bd70              POP      {r4-r6,pc}
                  |L1.60|
00003c  1880              ADDS     r0,r0,r2              ;522
00003e  68a2              LDR      r2,[r4,#8]            ;522  ; g_usbd_CtrlInSize
000040  f7fffffe          BL       USBD_MemCopy
000044  68a0              LDR      r0,[r4,#8]            ;523  ; g_usbd_CtrlInSize
000046  6068              STR      r0,[r5,#4]            ;523
000048  68a0              LDR      r0,[r4,#8]            ;524  ; g_usbd_CtrlInSize
00004a  6a21              LDR      r1,[r4,#0x20]         ;524  ; g_usbd_CtrlMaxPktSize
00004c  4288              CMP      r0,r1                 ;524
00004e  d101              BNE      |L1.84|
000050  2001              MOVS     r0,#1                 ;525
000052  7060              STRB     r0,[r4,#1]            ;525
                  |L1.84|
000054  6066              STR      r6,[r4,#4]            ;527  ; g_usbd_CtrlInPointer
000056  60a6              STR      r6,[r4,#8]            ;527  ; g_usbd_CtrlInSize
                  |L1.88|
000058  bd70              POP      {r4-r6,pc}
                  |L1.90|
00005a  480c              LDR      r0,|L1.140|
00005c  3040              ADDS     r0,r0,#0x40           ;533
00005e  7801              LDRB     r1,[r0,#0]            ;533  ; g_usbd_SetupPacket
000060  2900              CMP      r1,#0                 ;533
000062  d10c              BNE      |L1.126|
000064  7840              LDRB     r0,[r0,#1]            ;533  ; g_usbd_SetupPacket
000066  2805              CMP      r0,#5                 ;533
000068  d109              BNE      |L1.126|
00006a  480b              LDR      r0,|L1.152|
00006c  6881              LDR      r1,[r0,#8]            ;535
00006e  69a2              LDR      r2,[r4,#0x18]         ;535  ; g_usbd_UsbAddr
000070  4291              CMP      r1,r2                 ;535
000072  d004              BEQ      |L1.126|
000074  6881              LDR      r1,[r0,#8]            ;535
000076  2900              CMP      r1,#0                 ;535
000078  d101              BNE      |L1.126|
00007a  69a1              LDR      r1,[r4,#0x18]         ;537  ; g_usbd_UsbAddr
00007c  6081              STR      r1,[r0,#8]            ;537
                  |L1.126|
00007e  7860              LDRB     r0,[r4,#1]            ;542  ; u8ZeroFlag
000080  2800              CMP      r0,#0                 ;542
000082  d0e9              BEQ      |L1.88|
000084  606e              STR      r6,[r5,#4]            ;544
000086  7066              STRB     r6,[r4,#1]            ;545
000088  bd70              POP      {r4-r6,pc}
;;;551    
                          ENDP

00008a  0000              DCW      0x0000
                  |L1.140|
                          DCD      ||.data||
                  |L1.144|
                          DCD      0x40060500
                  |L1.148|
                          DCD      0x40060100
                  |L1.152|
                          DCD      0x40060000

                          AREA ||i.USBD_CtrlOut||, CODE, READONLY, ALIGN=2

                  USBD_CtrlOut PROC
;;;580      */
;;;581    void USBD_CtrlOut(void)
000000  b570              PUSH     {r4-r6,lr}
;;;582    {
;;;583        uint32_t u32Size;
;;;584    
;;;585        DBG_PRINTF("Ctrl Out Ack %d\n", g_usbd_CtrlOutSize);
;;;586        if(g_usbd_CtrlOutSize < g_usbd_CtrlOutSizeLimit)
000002  4c0d              LDR      r4,|L2.56|
000004  6920              LDR      r0,[r4,#0x10]  ; g_usbd_CtrlOutSize
000006  6961              LDR      r1,[r4,#0x14]  ; g_usbd_CtrlOutSizeLimit
000008  4288              CMP      r0,r1
00000a  d214              BCS      |L2.54|
;;;587        {
;;;588            u32Size = USBD_GET_PAYLOAD_LEN(EP1);
00000c  4e0b              LDR      r6,|L2.60|
00000e  6975              LDR      r5,[r6,#0x14]
;;;589            USBD_MemCopy((uint8_t *)g_usbd_CtrlOutPointer, (uint8_t *)USBD_BUF_BASE + USBD_GET_EP_BUF_ADDR(EP1), u32Size);
000010  6930              LDR      r0,[r6,#0x10]
000012  490b              LDR      r1,|L2.64|
000014  462a              MOV      r2,r5
000016  1841              ADDS     r1,r0,r1
000018  68e0              LDR      r0,[r4,#0xc]  ; g_usbd_CtrlOutPointer
00001a  f7fffffe          BL       USBD_MemCopy
;;;590            g_usbd_CtrlOutPointer += u32Size;
00001e  68e0              LDR      r0,[r4,#0xc]  ; g_usbd_CtrlOutPointer
000020  1940              ADDS     r0,r0,r5
;;;591            g_usbd_CtrlOutSize += u32Size;
000022  60e0              STR      r0,[r4,#0xc]  ; g_usbd_CtrlOutPointer
000024  6920              LDR      r0,[r4,#0x10]  ; g_usbd_CtrlOutSize
000026  1940              ADDS     r0,r0,r5
000028  6120              STR      r0,[r4,#0x10]  ; g_usbd_CtrlOutSize
;;;592    
;;;593            if(g_usbd_CtrlOutSize < g_usbd_CtrlOutSizeLimit)
00002a  6920              LDR      r0,[r4,#0x10]  ; g_usbd_CtrlOutSize
00002c  6961              LDR      r1,[r4,#0x14]  ; g_usbd_CtrlOutSizeLimit
00002e  4288              CMP      r0,r1
000030  d201              BCS      |L2.54|
;;;594                USBD_SET_PAYLOAD_LEN(EP1, g_usbd_CtrlMaxPktSize);
000032  6a20              LDR      r0,[r4,#0x20]  ; g_usbd_CtrlMaxPktSize
000034  6170              STR      r0,[r6,#0x14]
                  |L2.54|
;;;595    
;;;596        }
;;;597    
;;;598    }
000036  bd70              POP      {r4-r6,pc}
;;;599    
                          ENDP

                  |L2.56|
                          DCD      ||.data||
                  |L2.60|
                          DCD      0x40060500
                  |L2.64|
                          DCD      0x40060100

                          AREA ||i.USBD_GetDescriptor||, CODE, READONLY, ALIGN=2

                  USBD_GetDescriptor PROC
;;;180      */
;;;181    void USBD_GetDescriptor(void)
000000  b570              PUSH     {r4-r6,lr}
;;;182    {
;;;183        uint32_t u32Len;
;;;184    
;;;185        u32Len = 0;
;;;186        u32Len = g_usbd_SetupPacket[7];
000002  4b28              LDR      r3,|L3.164|
;;;187        u32Len <<= 8;
;;;188        u32Len += g_usbd_SetupPacket[6];
;;;189    
;;;190        switch(g_usbd_SetupPacket[3])
;;;191        {
;;;192            // Get Device Descriptor
;;;193            case DESC_DEVICE:
;;;194            {
;;;195                u32Len = Minimum(u32Len, LEN_DEVICE);
;;;196                DBG_PRINTF("Get device desc, %d\n", u32Len);
;;;197                USBD_PrepareCtrlIn((uint8_t *)g_usbd_sInfo->gu8DevDesc, u32Len);
;;;198                USBD_PrepareCtrlOut(0, 0);
;;;199                break;
;;;200            }
;;;201            // Get Configuration Descriptor
;;;202            case DESC_CONFIG:
;;;203            {
;;;204                uint32_t u32TotalLen;
;;;205    
;;;206                u32TotalLen = g_usbd_sInfo->gu8ConfigDesc[3];
;;;207                u32TotalLen = g_usbd_sInfo->gu8ConfigDesc[2] + (u32TotalLen << 8);
;;;208    
;;;209                DBG_PRINTF("Get config desc len %d, actual len %d\n", u32Len, u32TotalLen);
;;;210                u32Len = Minimum(u32Len, u32TotalLen);
;;;211                DBG_PRINTF("Minimum len %d\n", u32Len);
;;;212                USBD_PrepareCtrlIn((uint8_t *)g_usbd_sInfo->gu8ConfigDesc, u32Len);
;;;213                USBD_PrepareCtrlOut(0, 0);
;;;214                break;
;;;215            }
;;;216            // Get HID Descriptor
;;;217            case DESC_HID:
;;;218            {
;;;219                /* CV3.0 HID Class Descriptor Test, 
;;;220                   Need to indicate index of the HID Descriptor within gu8ConfigDescriptor, specifically HID Composite device. */
;;;221                uint32_t u32ConfigDescOffset;   // u32ConfigDescOffset is configuration descriptor offset (HID descriptor start index)
;;;222                u32Len = Minimum(u32Len, LEN_HID);
;;;223                DBG_PRINTF("Get HID desc, %d\n", u32Len);
;;;224    
;;;225                u32ConfigDescOffset = g_usbd_sInfo->gu32ConfigHidDescIdx[g_usbd_SetupPacket[4]];
;;;226                USBD_PrepareCtrlIn((uint8_t *)&g_usbd_sInfo->gu8ConfigDesc[u32ConfigDescOffset], u32Len);
;;;227                
;;;228                USBD_PrepareCtrlOut(0, 0);
;;;229                break;
;;;230            }
;;;231            // Get Report Descriptor
;;;232            case DESC_HID_RPT:
;;;233            {
;;;234                DBG_PRINTF("Get HID report, %d\n", u32Len);
;;;235    
;;;236                u32Len = Minimum(u32Len, g_usbd_sInfo->gu32HidReportSize[g_usbd_SetupPacket[4]]);
;;;237                USBD_PrepareCtrlIn((uint8_t *)g_usbd_sInfo->gu8HidReportDesc[g_usbd_SetupPacket[4]], u32Len);
;;;238    
;;;239                USBD_PrepareCtrlOut(0, 0);
;;;240                break;
;;;241            }
;;;242            // Get String Descriptor
;;;243            case DESC_STRING:
;;;244            {
;;;245                // Get String Descriptor
;;;246                if(g_usbd_SetupPacket[2] < 4)
;;;247                {
;;;248                    u32Len = Minimum(u32Len, g_usbd_sInfo->gu8StringDesc[g_usbd_SetupPacket[2]][0]);
;;;249                    DBG_PRINTF("Get string desc %d\n", u32Len);
;;;250                    USBD_PrepareCtrlIn((uint8_t *)g_usbd_sInfo->gu8StringDesc[g_usbd_SetupPacket[2]], u32Len);
;;;251                    USBD_PrepareCtrlOut(0, 0);
;;;252                    break;
;;;253                }
;;;254                else
;;;255                {
;;;256                    // Not support. Reply STALL.
;;;257                    USBD_SET_EP_STALL(EP0);
000004  4c28              LDR      r4,|L3.168|
000006  79d8              LDRB     r0,[r3,#7]            ;186  ; g_usbd_SetupPacket
000008  7999              LDRB     r1,[r3,#6]            ;188  ; g_usbd_SetupPacket
00000a  0200              LSLS     r0,r0,#8              ;187
00000c  1809              ADDS     r1,r1,r0              ;188
00000e  4618              MOV      r0,r3                 ;197
000010  78da              LDRB     r2,[r3,#3]            ;190  ; g_usbd_SetupPacket
000012  3840              SUBS     r0,r0,#0x40           ;197
000014  2502              MOVS     r5,#2
000016  6bc0              LDR      r0,[r0,#0x3c]         ;197
000018  2a03              CMP      r2,#3                 ;190
00001a  d02b              BEQ      |L3.116|
00001c  dc04              BGT      |L3.40|
00001e  2a01              CMP      r2,#1                 ;190
000020  d00a              BEQ      |L3.56|
000022  2a02              CMP      r2,#2                 ;190
000024  d136              BNE      |L3.148|
000026  e00c              B        |L3.66|
                  |L3.40|
000028  4b1e              LDR      r3,|L3.164|
00002a  791b              LDRB     r3,[r3,#4]            ;225
00002c  009b              LSLS     r3,r3,#2              ;225
00002e  2a21              CMP      r2,#0x21              ;190
000030  d010              BEQ      |L3.84|
000032  2a22              CMP      r2,#0x22              ;190
000034  d12e              BNE      |L3.148|
000036  e015              B        |L3.100|
                  |L3.56|
000038  2912              CMP      r1,#0x12              ;195
00003a  d300              BCC      |L3.62|
00003c  2112              MOVS     r1,#0x12              ;195
                  |L3.62|
00003e  6800              LDR      r0,[r0,#0]            ;197
000040  e021              B        |L3.134|
                  |L3.66|
000042  6840              LDR      r0,[r0,#4]            ;206
000044  78c2              LDRB     r2,[r0,#3]            ;206
000046  7883              LDRB     r3,[r0,#2]            ;207
000048  0212              LSLS     r2,r2,#8              ;207
00004a  189a              ADDS     r2,r3,r2              ;207
00004c  4291              CMP      r1,r2                 ;210
00004e  d31a              BCC      |L3.134|
                  |L3.80|
000050  4611              MOV      r1,r2                 ;210
000052  e018              B        |L3.134|
                  |L3.84|
000054  2909              CMP      r1,#9                 ;222
000056  d300              BCC      |L3.90|
000058  2109              MOVS     r1,#9                 ;222
                  |L3.90|
00005a  6942              LDR      r2,[r0,#0x14]         ;225
00005c  6840              LDR      r0,[r0,#4]            ;226
00005e  58d2              LDR      r2,[r2,r3]            ;225
000060  1880              ADDS     r0,r0,r2              ;226
000062  e010              B        |L3.134|
                  |L3.100|
000064  6902              LDR      r2,[r0,#0x10]         ;236
000066  58d2              LDR      r2,[r2,r3]            ;236
000068  428a              CMP      r2,r1                 ;236
00006a  d800              BHI      |L3.110|
00006c  4611              MOV      r1,r2                 ;236
                  |L3.110|
00006e  68c0              LDR      r0,[r0,#0xc]          ;237
000070  58c0              LDR      r0,[r0,r3]            ;237
000072  e008              B        |L3.134|
                  |L3.116|
000074  789a              LDRB     r2,[r3,#2]            ;246  ; g_usbd_SetupPacket
000076  2a04              CMP      r2,#4                 ;246
000078  d20c              BCS      |L3.148|
00007a  6880              LDR      r0,[r0,#8]            ;248
00007c  0092              LSLS     r2,r2,#2              ;248
00007e  5880              LDR      r0,[r0,r2]            ;248
000080  7802              LDRB     r2,[r0,#0]            ;248
000082  428a              CMP      r2,r1                 ;248
000084  d9e4              BLS      |L3.80|
                  |L3.134|
000086  f7fffffe          BL       USBD_PrepareCtrlIn
00008a  2100              MOVS     r1,#0                 ;251
00008c  4608              MOV      r0,r1                 ;251
00008e  f7fffffe          BL       USBD_PrepareCtrlOut
;;;258                    USBD_SET_EP_STALL(EP1);
;;;259                    DBG_PRINTF("Unsupported string desc (%d). Stall ctrl pipe.\n", g_usbd_SetupPacket[2]);
;;;260                    break;
;;;261                }
;;;262            }
;;;263            default:
;;;264                // Not support. Reply STALL.
;;;265                USBD_SET_EP_STALL(EP0);
;;;266                USBD_SET_EP_STALL(EP1);
;;;267                DBG_PRINTF("Unsupported get desc type. stall ctrl pipe\n");
;;;268                break;
;;;269        }
;;;270    }
000092  bd70              POP      {r4-r6,pc}
                  |L3.148|
000094  68e0              LDR      r0,[r4,#0xc]          ;265
000096  4328              ORRS     r0,r0,r5              ;265
000098  60e0              STR      r0,[r4,#0xc]          ;265
00009a  69e0              LDR      r0,[r4,#0x1c]         ;266
00009c  4328              ORRS     r0,r0,r5              ;266
00009e  61e0              STR      r0,[r4,#0x1c]         ;266
0000a0  bd70              POP      {r4-r6,pc}
;;;271    
                          ENDP

0000a2  0000              DCW      0x0000
                  |L3.164|
                          DCD      ||.data||+0x40
                  |L3.168|
                          DCD      0x40060500

                          AREA ||i.USBD_GetSetupPacket||, CODE, READONLY, ALIGN=2

                  USBD_GetSetupPacket PROC
;;;117      */
;;;118    void USBD_GetSetupPacket(uint8_t *buf)
000000  b510              PUSH     {r4,lr}
;;;119    {
;;;120        USBD_MemCopy(buf, g_usbd_SetupPacket, 8);
000002  2208              MOVS     r2,#8
000004  4901              LDR      r1,|L4.12|
000006  f7fffffe          BL       USBD_MemCopy
;;;121    }
00000a  bd10              POP      {r4,pc}
;;;122    
                          ENDP

                  |L4.12|
                          DCD      ||.data||+0x40

                          AREA ||i.USBD_LockEpStall||, CODE, READONLY, ALIGN=2

                  USBD_LockEpStall PROC
;;;669     */
;;;670    void USBD_LockEpStall(uint32_t u32EpBitmap)
000000  4901              LDR      r1,|L5.8|
;;;671    {
;;;672        g_u32EpStallLock = u32EpBitmap;
000002  6388              STR      r0,[r1,#0x38]  ; g_u32EpStallLock
;;;673    }
000004  4770              BX       lr
;;;674    /*@}*/ /* end of group USBD_EXPORTED_FUNCTIONS */
                          ENDP

000006  0000              DCW      0x0000
                  |L5.8|
                          DCD      ||.data||

                          AREA ||i.USBD_MemCopy||, CODE, READONLY, ALIGN=1

                  USBD_MemCopy PROC
;;;528      */
;;;529    static __INLINE void USBD_MemCopy(uint8_t *dest, uint8_t *src, int32_t size)
000000  e003              B        |L6.10|
                  |L6.2|
;;;530    {
;;;531        while(size--) *dest++ = *src++;
000002  780b              LDRB     r3,[r1,#0]
000004  7003              STRB     r3,[r0,#0]
000006  1c40              ADDS     r0,r0,#1
000008  1c49              ADDS     r1,r1,#1
                  |L6.10|
00000a  1e52              SUBS     r2,r2,#1
00000c  d2f9              BCS      |L6.2|
;;;532    }
00000e  4770              BX       lr
;;;533    
                          ENDP


                          AREA ||i.USBD_Open||, CODE, READONLY, ALIGN=2

                  USBD_Open PROC
;;;70       */
;;;71     void USBD_Open(const S_USBD_INFO_T *param, CLASS_REQ pfnClassReq, SET_INTERFACE_REQ pfnSetInterface)
000000  4b08              LDR      r3,|L7.36|
;;;72     {
;;;73         g_usbd_sInfo = param;
;;;74         g_usbd_pfnClassRequest = pfnClassReq;
;;;75         g_usbd_pfnSetInterface = pfnSetInterface;
;;;76     
;;;77         /* get EP0 maximum packet size */
;;;78         g_usbd_CtrlMaxPktSize = g_usbd_sInfo->gu8DevDesc[7];
000002  631a              STR      r2,[r3,#0x30]  ; g_usbd_pfnSetInterface
000004  62d9              STR      r1,[r3,#0x2c]  ; g_usbd_pfnClassRequest
000006  63d8              STR      r0,[r3,#0x3c]  ; g_usbd_sInfo
000008  6800              LDR      r0,[r0,#0]
00000a  79c0              LDRB     r0,[r0,#7]
00000c  6218              STR      r0,[r3,#0x20]  ; g_usbd_CtrlMaxPktSize
;;;79     
;;;80         /* Initial USB engine */
;;;81         USBD->ATTR = 0x7D0;
00000e  207d              MOVS     r0,#0x7d
000010  4905              LDR      r1,|L7.40|
000012  0100              LSLS     r0,r0,#4
000014  6108              STR      r0,[r1,#0x10]
;;;82         /* Force SE0 */
;;;83         USBD_SET_SE0();
000016  4804              LDR      r0,|L7.40|
000018  3080              ADDS     r0,r0,#0x80
00001a  6901              LDR      r1,[r0,#0x10]
00001c  2201              MOVS     r2,#1
00001e  4311              ORRS     r1,r1,r2
000020  6101              STR      r1,[r0,#0x10]
;;;84     }
000022  4770              BX       lr
;;;85     
                          ENDP

                  |L7.36|
                          DCD      ||.data||
                  |L7.40|
                          DCD      0x40060000

                          AREA ||i.USBD_PrepareCtrlIn||, CODE, READONLY, ALIGN=2

                  USBD_PrepareCtrlIn PROC
;;;469      */
;;;470    void USBD_PrepareCtrlIn(uint8_t *pu8Buf, uint32_t u32Size)
000000  b570              PUSH     {r4-r6,lr}
;;;471    {
;;;472        DBG_PRINTF("Prepare Ctrl In %d\n", u32Size);
;;;473        if(u32Size > g_usbd_CtrlMaxPktSize)
000002  4c15              LDR      r4,|L8.88|
000004  460d              MOV      r5,r1                 ;471
000006  6a23              LDR      r3,[r4,#0x20]  ; g_usbd_CtrlMaxPktSize
;;;474        {
;;;475            // Data size > MXPLD
;;;476            g_usbd_CtrlInPointer = pu8Buf + g_usbd_CtrlMaxPktSize;
;;;477            g_usbd_CtrlInSize = u32Size - g_usbd_CtrlMaxPktSize;
;;;478            USBD_SET_DATA1(EP0);
000008  4e14              LDR      r6,|L8.92|
00000a  2180              MOVS     r1,#0x80
;;;479            USBD_MemCopy((uint8_t *)USBD_BUF_BASE + USBD_GET_EP_BUF_ADDR(EP0), pu8Buf, g_usbd_CtrlMaxPktSize);
00000c  4a14              LDR      r2,|L8.96|
00000e  429d              CMP      r5,r3                 ;473
000010  d912              BLS      |L8.56|
000012  6a23              LDR      r3,[r4,#0x20]         ;476  ; g_usbd_CtrlMaxPktSize
000014  18c3              ADDS     r3,r0,r3              ;476
000016  6063              STR      r3,[r4,#4]            ;477  ; g_usbd_CtrlInPointer
000018  6a23              LDR      r3,[r4,#0x20]         ;477  ; g_usbd_CtrlMaxPktSize
00001a  1aeb              SUBS     r3,r5,r3              ;477
00001c  60a3              STR      r3,[r4,#8]            ;477  ; g_usbd_CtrlInSize
00001e  68b3              LDR      r3,[r6,#8]            ;478
000020  430b              ORRS     r3,r3,r1              ;478
000022  60b3              STR      r3,[r6,#8]            ;478
000024  6831              LDR      r1,[r6,#0]
000026  188b              ADDS     r3,r1,r2
000028  6a22              LDR      r2,[r4,#0x20]  ; g_usbd_CtrlMaxPktSize
00002a  4601              MOV      r1,r0
00002c  4618              MOV      r0,r3
00002e  f7fffffe          BL       USBD_MemCopy
;;;480            USBD_SET_PAYLOAD_LEN(EP0, g_usbd_CtrlMaxPktSize);
000032  6a20              LDR      r0,[r4,#0x20]  ; g_usbd_CtrlMaxPktSize
000034  6070              STR      r0,[r6,#4]
;;;481        }
;;;482        else
;;;483        {
;;;484            // Data size <= MXPLD
;;;485            g_usbd_CtrlInPointer = 0;
;;;486            g_usbd_CtrlInSize = 0;
;;;487            USBD_SET_DATA1(EP0);
;;;488            USBD_MemCopy((uint8_t *)USBD_BUF_BASE + USBD_GET_EP_BUF_ADDR(EP0), pu8Buf, u32Size);
;;;489            USBD_SET_PAYLOAD_LEN(EP0, u32Size);
;;;490        }
;;;491    }
000036  bd70              POP      {r4-r6,pc}
                  |L8.56|
000038  2300              MOVS     r3,#0                 ;485
00003a  6063              STR      r3,[r4,#4]            ;486  ; g_usbd_CtrlInPointer
00003c  60a3              STR      r3,[r4,#8]            ;486  ; g_usbd_CtrlInSize
00003e  68b3              LDR      r3,[r6,#8]            ;487
000040  430b              ORRS     r3,r3,r1              ;487
000042  60b3              STR      r3,[r6,#8]            ;487
000044  6831              LDR      r1,[r6,#0]            ;488
000046  188b              ADDS     r3,r1,r2              ;488
000048  4601              MOV      r1,r0                 ;488
00004a  462a              MOV      r2,r5                 ;488
00004c  4618              MOV      r0,r3                 ;488
00004e  f7fffffe          BL       USBD_MemCopy
000052  6075              STR      r5,[r6,#4]            ;489
000054  bd70              POP      {r4-r6,pc}
;;;492    
                          ENDP

000056  0000              DCW      0x0000
                  |L8.88|
                          DCD      ||.data||
                  |L8.92|
                          DCD      0x40060500
                  |L8.96|
                          DCD      0x40060100

                          AREA ||i.USBD_PrepareCtrlOut||, CODE, READONLY, ALIGN=2

                  USBD_PrepareCtrlOut PROC
;;;562      */
;;;563    void USBD_PrepareCtrlOut(uint8_t *pu8Buf, uint32_t u32Size)
000000  4a04              LDR      r2,|L9.20|
;;;564    {
;;;565        g_usbd_CtrlOutPointer = pu8Buf;
;;;566        g_usbd_CtrlOutSize = 0;
000002  60d0              STR      r0,[r2,#0xc]  ; g_usbd_CtrlOutPointer
000004  2000              MOVS     r0,#0
000006  6110              STR      r0,[r2,#0x10]  ; g_usbd_CtrlOutSize
;;;567        g_usbd_CtrlOutSizeLimit = u32Size;
000008  6151              STR      r1,[r2,#0x14]  ; g_usbd_CtrlOutSizeLimit
;;;568        USBD_SET_PAYLOAD_LEN(EP1, g_usbd_CtrlMaxPktSize);
00000a  6a10              LDR      r0,[r2,#0x20]  ; g_usbd_CtrlMaxPktSize
00000c  4902              LDR      r1,|L9.24|
00000e  6148              STR      r0,[r1,#0x14]
;;;569    }
000010  4770              BX       lr
;;;570    
                          ENDP

000012  0000              DCW      0x0000
                  |L9.20|
                          DCD      ||.data||
                  |L9.24|
                          DCD      0x40060500

                          AREA ||i.USBD_ProcessSetupPacket||, CODE, READONLY, ALIGN=2

                  USBD_ProcessSetupPacket PROC
;;;132      */
;;;133    void USBD_ProcessSetupPacket(void)
000000  b510              PUSH     {r4,lr}
;;;134    {
;;;135        /* Get SETUP packet from USB buffer */
;;;136        USBD_MemCopy(g_usbd_SetupPacket, (uint8_t *)USBD_BUF_BASE, 8);
000002  2208              MOVS     r2,#8
000004  4910              LDR      r1,|L10.72|
000006  4811              LDR      r0,|L10.76|
000008  f7fffffe          BL       USBD_MemCopy
;;;137        /* Check the request type */
;;;138        switch(g_usbd_SetupPacket[0] & 0x60)
00000c  480f              LDR      r0,|L10.76|
00000e  2160              MOVS     r1,#0x60
000010  7800              LDRB     r0,[r0,#0]  ; g_usbd_SetupPacket
000012  4008              ANDS     r0,r0,r1
000014  d00e              BEQ      |L10.52|
;;;139        {
;;;140            case REQ_STANDARD:   // Standard
;;;141            {
;;;142                USBD_StandardRequest();
;;;143                break;
;;;144            }
;;;145            case REQ_CLASS:   // Class
;;;146            {
;;;147                if(g_usbd_pfnClassRequest != NULL)
000016  490d              LDR      r1,|L10.76|
000018  3940              SUBS     r1,r1,#0x40
00001a  2820              CMP      r0,#0x20              ;138
00001c  d00d              BEQ      |L10.58|
00001e  2840              CMP      r0,#0x40              ;138
000020  d00d              BEQ      |L10.62|
;;;148                {
;;;149                    g_usbd_pfnClassRequest();
;;;150                }
;;;151                break;
;;;152            }
;;;153            case REQ_VENDOR:   // Vendor
;;;154            {
;;;155                if(g_usbd_pfnVendorRequest != NULL)
;;;156                {
;;;157                    g_usbd_pfnVendorRequest();
;;;158                }
;;;159                break;
;;;160            }
;;;161            default:   // reserved
;;;162            {
;;;163                /* Setup error, stall the device */
;;;164                USBD_SET_EP_STALL(EP0);
000022  480b              LDR      r0,|L10.80|
000024  68c1              LDR      r1,[r0,#0xc]
000026  2202              MOVS     r2,#2
000028  4311              ORRS     r1,r1,r2
00002a  60c1              STR      r1,[r0,#0xc]
;;;165                USBD_SET_EP_STALL(EP1);
00002c  69c1              LDR      r1,[r0,#0x1c]
00002e  4311              ORRS     r1,r1,r2
000030  61c1              STR      r1,[r0,#0x1c]
;;;166                break;
;;;167            }
;;;168        }
;;;169    }
000032  bd10              POP      {r4,pc}
                  |L10.52|
000034  f7fffffe          BL       USBD_StandardRequest
                  |L10.56|
000038  bd10              POP      {r4,pc}
                  |L10.58|
00003a  6ac8              LDR      r0,[r1,#0x2c]         ;147  ; g_usbd_pfnClassRequest
00003c  e000              B        |L10.64|
                  |L10.62|
00003e  6a88              LDR      r0,[r1,#0x28]         ;155  ; g_usbd_pfnVendorRequest
                  |L10.64|
000040  2800              CMP      r0,#0                 ;147
000042  d0f9              BEQ      |L10.56|
000044  4780              BLX      r0                    ;157
000046  bd10              POP      {r4,pc}
;;;170    
                          ENDP

                  |L10.72|
                          DCD      0x40060100
                  |L10.76|
                          DCD      ||.data||+0x40
                  |L10.80|
                          DCD      0x40060500

                          AREA ||i.USBD_SetConfigCallback||, CODE, READONLY, ALIGN=2

                  USBD_SetConfigCallback PROC
;;;653     */
;;;654    void USBD_SetConfigCallback(SET_CONFIG_CB pfnSetConfigCallback)
000000  4901              LDR      r1,|L11.8|
;;;655    {
;;;656        g_usbd_pfnSetConfigCallback = pfnSetConfigCallback;
000002  6348              STR      r0,[r1,#0x34]  ; g_usbd_pfnSetConfigCallback
;;;657    }
000004  4770              BX       lr
;;;658    
                          ENDP

000006  0000              DCW      0x0000
                  |L11.8|
                          DCD      ||.data||

                          AREA ||i.USBD_SetVendorRequest||, CODE, READONLY, ALIGN=2

                  USBD_SetVendorRequest PROC
;;;639     */
;;;640    void USBD_SetVendorRequest(VENDOR_REQ pfnVendorReq)
000000  4901              LDR      r1,|L12.8|
;;;641    {
;;;642        g_usbd_pfnVendorRequest = pfnVendorReq;
000002  6288              STR      r0,[r1,#0x28]  ; g_usbd_pfnVendorRequest
;;;643    }
000004  4770              BX       lr
;;;644    
                          ENDP

000006  0000              DCW      0x0000
                  |L12.8|
                          DCD      ||.data||

                          AREA ||i.USBD_StandardRequest||, CODE, READONLY, ALIGN=2

                  USBD_StandardRequest PROC
;;;281      */
;;;282    void USBD_StandardRequest(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;283    {
;;;284        /* clear global variables for new request */
;;;285        g_usbd_CtrlInPointer = 0;
000002  4869              LDR      r0,|L13.424|
000004  2500              MOVS     r5,#0
;;;286        g_usbd_CtrlInSize = 0;
000006  6045              STR      r5,[r0,#4]  ; g_usbd_CtrlInPointer
000008  6085              STR      r5,[r0,#8]  ; g_usbd_CtrlInSize
;;;287    
;;;288        if(g_usbd_SetupPacket[0] & 0x80)    /* request data transfer direction */
00000a  4601              MOV      r1,r0
00000c  3140              ADDS     r1,r1,#0x40
00000e  780a              LDRB     r2,[r1,#0]  ; g_usbd_SetupPacket
000010  460b              MOV      r3,r1
;;;289        {
;;;290            // Device to host
;;;291            switch(g_usbd_SetupPacket[1])
;;;292            {
;;;293                case GET_CONFIGURATION:
;;;294                {
;;;295                    // Return current configuration setting
;;;296                    /* Data stage */
;;;297                    M8(USBD_BUF_BASE + USBD_GET_EP_BUF_ADDR(EP0)) = g_usbd_UsbConfig;
;;;298                    USBD_SET_DATA1(EP0);
;;;299                    USBD_SET_PAYLOAD_LEN(EP0, 1);
;;;300                    /* Status stage */
;;;301                    USBD_PrepareCtrlOut(0, 0);
;;;302                    DBG_PRINTF("Get configuration\n");
;;;303                    break;
;;;304                }
;;;305                case GET_DESCRIPTOR:
;;;306                {
;;;307                    USBD_GetDescriptor();
;;;308                    break;
;;;309                }
;;;310                case GET_INTERFACE:
;;;311                {
;;;312                    // Return current interface setting
;;;313                    /* Data stage */
;;;314                    M8(USBD_BUF_BASE + USBD_GET_EP_BUF_ADDR(EP0)) = g_usbd_UsbAltInterface;
;;;315                    USBD_SET_DATA1(EP0);
;;;316                    USBD_SET_PAYLOAD_LEN(EP0, 1);
;;;317                    /* Status stage */
;;;318                    USBD_PrepareCtrlOut(0, 0);
;;;319                    DBG_PRINTF("Get interface\n");
;;;320                    break;
;;;321                }
;;;322                case GET_STATUS:
;;;323                {
;;;324                    // Device
;;;325                    if(g_usbd_SetupPacket[0] == 0x80)
;;;326                    {
;;;327                        uint8_t u8Tmp;
;;;328    
;;;329                        u8Tmp = 0;
;;;330                        if(g_usbd_sInfo->gu8ConfigDesc[7] & 0x40) u8Tmp |= 1; // Self-Powered/Bus-Powered.
;;;331                        if(g_usbd_sInfo->gu8ConfigDesc[7] & 0x20) u8Tmp |= (g_usbd_RemoteWakeupEn << 1); // Remote wake up
;;;332    
;;;333                        M8(USBD_BUF_BASE + USBD_GET_EP_BUF_ADDR(EP0)) = u8Tmp;
;;;334                    }
;;;335                    // Interface
;;;336                    else if(g_usbd_SetupPacket[0] == 0x81)
;;;337                        M8(USBD_BUF_BASE + USBD_GET_EP_BUF_ADDR(EP0)) = 0;
;;;338                    // Endpoint
;;;339                    else if(g_usbd_SetupPacket[0] == 0x82)
;;;340                    {
;;;341                        uint8_t ep = g_usbd_SetupPacket[4] & 0xF;
000012  7919              LDRB     r1,[r3,#4]
000014  785b              LDRB     r3,[r3,#1]            ;291
000016  0709              LSLS     r1,r1,#28
000018  469c              MOV      r12,r3                ;291
00001a  0617              LSLS     r7,r2,#24             ;288
00001c  2680              MOVS     r6,#0x80              ;298
00001e  0f09              LSRS     r1,r1,#28
000020  2302              MOVS     r3,#2
000022  4c62              LDR      r4,|L13.428|
000024  2f00              CMP      r7,#0                 ;288
000026  4667              MOV      r7,r12                ;288
000028  da64              BGE      |L13.244|
00002a  2f00              CMP      r7,#0                 ;291
00002c  d01a              BEQ      |L13.100|
00002e  2f06              CMP      r7,#6                 ;291
000030  d006              BEQ      |L13.64|
000032  2f08              CMP      r7,#8                 ;291
000034  d002              BEQ      |L13.60|
000036  2f0a              CMP      r7,#0xa               ;291
000038  d155              BNE      |L13.230|
00003a  e004              B        |L13.70|
                  |L13.60|
00003c  69c0              LDR      r0,[r0,#0x1c]         ;297  ; g_usbd_UsbConfig
00003e  e003              B        |L13.72|
                  |L13.64|
000040  f7fffffe          BL       USBD_GetDescriptor
;;;342                        M8(USBD_BUF_BASE + USBD_GET_EP_BUF_ADDR(EP0)) = USBD_GetStall(ep) ? 1 : 0;
;;;343                    }
;;;344    
;;;345                    M8(USBD_BUF_BASE + USBD_GET_EP_BUF_ADDR(EP0) + 1) = 0;
;;;346                    /* Data stage */
;;;347                    USBD_SET_DATA1(EP0);
;;;348                    USBD_SET_PAYLOAD_LEN(EP0, 2);
;;;349                    /* Status stage */
;;;350                    USBD_PrepareCtrlOut(0, 0);
;;;351                    DBG_PRINTF("Get status\n");
;;;352                    break;
;;;353                }
;;;354                default:
;;;355                {
;;;356                    /* Setup error, stall the device */
;;;357                    USBD_SET_EP_STALL(EP0);
;;;358                    USBD_SET_EP_STALL(EP1);
;;;359                    DBG_PRINTF("Unknown request. stall ctrl pipe.\n");
;;;360                    break;
;;;361                }
;;;362            }
;;;363        }
;;;364        else
;;;365        {
;;;366            // Host to device
;;;367            switch(g_usbd_SetupPacket[1])
;;;368            {
;;;369                case CLEAR_FEATURE:
;;;370                {
;;;371                    if(g_usbd_SetupPacket[2] == FEATURE_ENDPOINT_HALT)
;;;372                    {
;;;373                        int32_t epNum, i;
;;;374    
;;;375                        /* EP number stall is not allow to be clear in MSC class "Error Recovery Test".
;;;376                           a flag: g_u32EpStallLock is added to support it */
;;;377                        epNum = g_usbd_SetupPacket[4] & 0xF;
;;;378                        for(i = 0; i < USBD_MAX_EP; i++)
;;;379                        {
;;;380                            if(((USBD->EP[i].CFG & 0xF) == epNum) && ((g_u32EpStallLock & (1 << i)) == 0))
;;;381                            {
;;;382                                USBD->EP[i].CFGP &= ~USBD_CFGP_SSTALL_Msk;
;;;383                                DBG_PRINTF("Clr stall ep%d %x\n", i, USBD->EP[i].CFGP);
;;;384                            }
;;;385                        }
;;;386                    }
;;;387                    else if(g_usbd_SetupPacket[2] == FEATURE_DEVICE_REMOTE_WAKEUP)
;;;388                        g_usbd_RemoteWakeupEn = 0;
;;;389                    /* Status stage */
;;;390                    USBD_SET_DATA1(EP0);
;;;391                    USBD_SET_PAYLOAD_LEN(EP0, 0);
;;;392                    DBG_PRINTF("Clear feature op %d\n", g_usbd_SetupPacket[2]);
;;;393                    break;
;;;394                }
;;;395                case SET_ADDRESS:
;;;396                {
;;;397                    g_usbd_UsbAddr = g_usbd_SetupPacket[2];
;;;398                    DBG_PRINTF("Set addr to %d\n", g_usbd_UsbAddr);
;;;399    
;;;400                    // DATA IN for end of setup
;;;401                    /* Status Stage */
;;;402                    USBD_SET_DATA1(EP0);
;;;403                    USBD_SET_PAYLOAD_LEN(EP0, 0);
;;;404                    break;
;;;405                }
;;;406                case SET_CONFIGURATION:
;;;407                {
;;;408                    g_usbd_UsbConfig = g_usbd_SetupPacket[2];
;;;409    
;;;410                    if(g_usbd_pfnSetConfigCallback)
;;;411                        g_usbd_pfnSetConfigCallback();
;;;412                    // DATA IN for end of setup
;;;413                    /* Status stage */
;;;414                    USBD_SET_DATA1(EP0);
;;;415                    USBD_SET_PAYLOAD_LEN(EP0, 0);
;;;416                    DBG_PRINTF("Set config to %d\n", g_usbd_UsbConfig);
;;;417                    break;
;;;418                }
;;;419                case SET_FEATURE:
;;;420                {
;;;421                    if(g_usbd_SetupPacket[2] == FEATURE_ENDPOINT_HALT)
;;;422                    {
;;;423                        USBD_SetStall(g_usbd_SetupPacket[4] & 0xF);
;;;424                        DBG_PRINTF("Set feature. stall ep %d\n", g_usbd_SetupPacket[4] & 0xF);
;;;425                    }
;;;426                    else if(g_usbd_SetupPacket[2] == FEATURE_DEVICE_REMOTE_WAKEUP)
;;;427                    {
;;;428                        g_usbd_RemoteWakeupEn = 1;
;;;429                        DBG_PRINTF("Set feature. enable remote wakeup\n");
;;;430                    }
;;;431                    /* Status stage */
;;;432                    USBD_SET_DATA1(EP0);
;;;433                    USBD_SET_PAYLOAD_LEN(EP0, 0);
;;;434                    break;
;;;435                }
;;;436                case SET_INTERFACE:
;;;437                {
;;;438                    g_usbd_UsbAltInterface = g_usbd_SetupPacket[2];
;;;439                    if(g_usbd_pfnSetInterface != NULL)
;;;440                        g_usbd_pfnSetInterface();
;;;441                    /* Status stage */
;;;442                    USBD_SET_DATA1(EP0);
;;;443                    USBD_SET_PAYLOAD_LEN(EP0, 0);
;;;444                    DBG_PRINTF("Set interface to %d\n", g_usbd_UsbAltInterface);
;;;445                    break;
;;;446                }
;;;447                default:
;;;448                {
;;;449                    /* Setup error, stall the device */
;;;450                    USBD_SET_EP_STALL(EP0);
;;;451                    USBD_SET_EP_STALL(EP1);
;;;452                    DBG_PRINTF("Unsupported request. stall ctrl pipe.\n");
;;;453                    break;
;;;454                }
;;;455            }
;;;456        }
;;;457    }
000044  bdf8              POP      {r3-r7,pc}
                  |L13.70|
000046  6a40              LDR      r0,[r0,#0x24]         ;314  ; g_usbd_UsbAltInterface
                  |L13.72|
000048  6822              LDR      r2,[r4,#0]            ;297
00004a  4959              LDR      r1,|L13.432|
00004c  1851              ADDS     r1,r2,r1              ;297
00004e  7008              STRB     r0,[r1,#0]            ;297
000050  68a0              LDR      r0,[r4,#8]            ;298
000052  4330              ORRS     r0,r0,r6              ;298
000054  60a0              STR      r0,[r4,#8]            ;298
000056  2001              MOVS     r0,#1                 ;299
000058  6060              STR      r0,[r4,#4]            ;299
                  |L13.90|
00005a  2100              MOVS     r1,#0                 ;301
00005c  4608              MOV      r0,r1                 ;301
00005e  f7fffffe          BL       USBD_PrepareCtrlOut
000062  bdf8              POP      {r3-r7,pc}
                  |L13.100|
000064  2a80              CMP      r2,#0x80              ;325
000066  d004              BEQ      |L13.114|
000068  2a81              CMP      r2,#0x81              ;336
00006a  d014              BEQ      |L13.150|
00006c  2a82              CMP      r2,#0x82              ;339
00006e  d017              BEQ      |L13.160|
000070  e030              B        |L13.212|
                  |L13.114|
000072  6bc2              LDR      r2,[r0,#0x3c]         ;330  ; g_usbd_sInfo
000074  2100              MOVS     r1,#0                 ;329
000076  6852              LDR      r2,[r2,#4]            ;330
000078  79d2              LDRB     r2,[r2,#7]            ;330
00007a  0657              LSLS     r7,r2,#25             ;330
00007c  d500              BPL      |L13.128|
00007e  2101              MOVS     r1,#1                 ;330
                  |L13.128|
000080  0692              LSLS     r2,r2,#26             ;331
000082  d503              BPL      |L13.140|
000084  7800              LDRB     r0,[r0,#0]            ;331  ; g_usbd_RemoteWakeupEn
000086  0040              LSLS     r0,r0,#1              ;331
000088  4308              ORRS     r0,r0,r1              ;331
00008a  b2c1              UXTB     r1,r0                 ;331
                  |L13.140|
00008c  6822              LDR      r2,[r4,#0]            ;333
00008e  4848              LDR      r0,|L13.432|
000090  1810              ADDS     r0,r2,r0              ;333
000092  7001              STRB     r1,[r0,#0]            ;333
000094  e01e              B        |L13.212|
                  |L13.150|
000096  6821              LDR      r1,[r4,#0]            ;337
000098  4845              LDR      r0,|L13.432|
00009a  1808              ADDS     r0,r1,r0              ;337
00009c  7005              STRB     r5,[r0,#0]            ;337
00009e  e019              B        |L13.212|
                  |L13.160|
0000a0  2000              MOVS     r0,#0                 ;337
                  |L13.162|
0000a2  4a42              LDR      r2,|L13.428|
0000a4  0107              LSLS     r7,r0,#4              ;337
0000a6  3208              ADDS     r2,r2,#8              ;337
0000a8  18ba              ADDS     r2,r7,r2              ;337
0000aa  6817              LDR      r7,[r2,#0]            ;337
0000ac  073f              LSLS     r7,r7,#28             ;337
0000ae  0f3f              LSRS     r7,r7,#28             ;337
0000b0  428f              CMP      r7,r1                 ;337
0000b2  d104              BNE      |L13.190|
0000b4  0101              LSLS     r1,r0,#4              ;337
0000b6  483d              LDR      r0,|L13.428|
0000b8  300c              ADDS     r0,r0,#0xc            ;337
0000ba  180a              ADDS     r2,r1,r0              ;337
0000bc  e002              B        |L13.196|
                  |L13.190|
0000be  1c40              ADDS     r0,r0,#1              ;337
0000c0  2808              CMP      r0,#8                 ;337
0000c2  dbee              BLT      |L13.162|
                  |L13.196|
0000c4  6810              LDR      r0,[r2,#0]            ;337
0000c6  4018              ANDS     r0,r0,r3              ;337
0000c8  d000              BEQ      |L13.204|
0000ca  2001              MOVS     r0,#1                 ;342
                  |L13.204|
0000cc  6822              LDR      r2,[r4,#0]            ;342
0000ce  4938              LDR      r1,|L13.432|
0000d0  1851              ADDS     r1,r2,r1              ;342
0000d2  7008              STRB     r0,[r1,#0]            ;342
                  |L13.212|
0000d4  6821              LDR      r1,[r4,#0]            ;345
0000d6  4836              LDR      r0,|L13.432|
0000d8  1808              ADDS     r0,r1,r0              ;345
0000da  7045              STRB     r5,[r0,#1]            ;345
0000dc  68a0              LDR      r0,[r4,#8]            ;347
0000de  4330              ORRS     r0,r0,r6              ;347
0000e0  60a0              STR      r0,[r4,#8]            ;347
0000e2  6063              STR      r3,[r4,#4]            ;348
0000e4  e7b9              B        |L13.90|
                  |L13.230|
0000e6  68e0              LDR      r0,[r4,#0xc]          ;357
0000e8  4318              ORRS     r0,r0,r3              ;357
0000ea  60e0              STR      r0,[r4,#0xc]          ;357
0000ec  69e0              LDR      r0,[r4,#0x1c]         ;358
0000ee  4318              ORRS     r0,r0,r3              ;358
0000f0  61e0              STR      r0,[r4,#0x1c]         ;358
0000f2  bdf8              POP      {r3-r7,pc}
                  |L13.244|
0000f4  4a2c              LDR      r2,|L13.424|
0000f6  3240              ADDS     r2,r2,#0x40           ;288
0000f8  7892              LDRB     r2,[r2,#2]            ;371
0000fa  2f05              CMP      r7,#5                 ;367
0000fc  d035              BEQ      |L13.362|
0000fe  dc08              BGT      |L13.274|
000100  2f01              CMP      r7,#1                 ;367
000102  d010              BEQ      |L13.294|
000104  2f03              CMP      r7,#3                 ;367
000106  d1ee              BNE      |L13.230|
000108  2a00              CMP      r2,#0                 ;421
00010a  d033              BEQ      |L13.372|
00010c  2a01              CMP      r2,#1                 ;426
00010e  d047              BEQ      |L13.416|
000110  e026              B        |L13.352|
                  |L13.274|
000112  2f09              CMP      r7,#9                 ;367
000114  d02b              BEQ      |L13.366|
000116  2f0b              CMP      r7,#0xb               ;367
000118  d1e5              BNE      |L13.230|
00011a  6242              STR      r2,[r0,#0x24]         ;438  ; g_usbd_UsbAltInterface
00011c  6b00              LDR      r0,[r0,#0x30]         ;439  ; g_usbd_pfnSetInterface
                  |L13.286|
00011e  2800              CMP      r0,#0                 ;439
000120  d01e              BEQ      |L13.352|
000122  4780              BLX      r0                    ;440
000124  e01c              B        |L13.352|
                  |L13.294|
000126  2a00              CMP      r2,#0                 ;371
000128  d002              BEQ      |L13.304|
00012a  2a01              CMP      r2,#1                 ;387
00012c  d017              BEQ      |L13.350|
00012e  e017              B        |L13.352|
                  |L13.304|
000130  6b80              LDR      r0,[r0,#0x38]         ;380
000132  2200              MOVS     r2,#0                 ;378
000134  4684              MOV      r12,r0                ;380
                  |L13.310|
000136  0110              LSLS     r0,r2,#4              ;380
000138  1900              ADDS     r0,r0,r4              ;380
00013a  6883              LDR      r3,[r0,#8]            ;380
00013c  071b              LSLS     r3,r3,#28             ;380
00013e  0f1b              LSRS     r3,r3,#28             ;380
000140  428b              CMP      r3,r1                 ;380
000142  d108              BNE      |L13.342|
000144  2301              MOVS     r3,#1                 ;380
000146  4093              LSLS     r3,r3,r2              ;380
000148  4667              MOV      r7,r12                ;380
00014a  423b              TST      r3,r7                 ;380
00014c  d103              BNE      |L13.342|
00014e  68c3              LDR      r3,[r0,#0xc]          ;382
000150  2702              MOVS     r7,#2                 ;382
000152  43bb              BICS     r3,r3,r7              ;382
000154  60c3              STR      r3,[r0,#0xc]          ;382
                  |L13.342|
000156  1c52              ADDS     r2,r2,#1              ;382
000158  2a08              CMP      r2,#8                 ;378
00015a  dbec              BLT      |L13.310|
00015c  e000              B        |L13.352|
                  |L13.350|
00015e  7005              STRB     r5,[r0,#0]            ;388
                  |L13.352|
000160  68a0              LDR      r0,[r4,#8]            ;390
000162  4330              ORRS     r0,r0,r6              ;390
000164  60a0              STR      r0,[r4,#8]            ;390
000166  6065              STR      r5,[r4,#4]            ;391
000168  bdf8              POP      {r3-r7,pc}
                  |L13.362|
00016a  6182              STR      r2,[r0,#0x18]         ;397  ; g_usbd_UsbAddr
00016c  e7f8              B        |L13.352|
                  |L13.366|
00016e  61c2              STR      r2,[r0,#0x1c]         ;408  ; g_usbd_UsbConfig
000170  6b40              LDR      r0,[r0,#0x34]         ;410  ; g_usbd_pfnSetConfigCallback
000172  e7d4              B        |L13.286|
                  |L13.372|
000174  4f0d              LDR      r7,|L13.428|
000176  2000              MOVS     r0,#0                 ;410
000178  3708              ADDS     r7,r7,#8              ;410
                  |L13.378|
00017a  0102              LSLS     r2,r0,#4              ;410
00017c  19d2              ADDS     r2,r2,r7              ;410
00017e  6812              LDR      r2,[r2,#0]            ;410
000180  0712              LSLS     r2,r2,#28             ;410
000182  0f12              LSRS     r2,r2,#28             ;410
000184  428a              CMP      r2,r1                 ;410
000186  d107              BNE      |L13.408|
000188  0101              LSLS     r1,r0,#4              ;410
00018a  4808              LDR      r0,|L13.428|
00018c  300c              ADDS     r0,r0,#0xc            ;410
00018e  1808              ADDS     r0,r1,r0              ;410
000190  6801              LDR      r1,[r0,#0]            ;410
000192  4319              ORRS     r1,r1,r3              ;410
000194  6001              STR      r1,[r0,#0]            ;410
000196  e7e3              B        |L13.352|
                  |L13.408|
000198  1c40              ADDS     r0,r0,#1              ;410
00019a  2808              CMP      r0,#8                 ;410
00019c  dbed              BLT      |L13.378|
00019e  e7df              B        |L13.352|
                  |L13.416|
0001a0  2101              MOVS     r1,#1                 ;428
0001a2  7001              STRB     r1,[r0,#0]            ;428
0001a4  e7dc              B        |L13.352|
;;;458    
                          ENDP

0001a6  0000              DCW      0x0000
                  |L13.424|
                          DCD      ||.data||
                  |L13.428|
                          DCD      0x40060500
                  |L13.432|
                          DCD      0x40060100

                          AREA ||i.USBD_Start||, CODE, READONLY, ALIGN=2

                  USBD_Start PROC
;;;94       */
;;;95     void USBD_Start(void)
000000  4806              LDR      r0,|L14.28|
;;;96     {
;;;97        // CLK_SysTickDelay(100000);//100000US
;;;98         /* Disable software-disconnect function */
;;;99         USBD_CLR_SE0();
000002  6901              LDR      r1,[r0,#0x10]
000004  0849              LSRS     r1,r1,#1
000006  0049              LSLS     r1,r1,#1
000008  6101              STR      r1,[r0,#0x10]
;;;100    
;;;101        /* Clear USB-related interrupts before enable interrupt *///
;;;102        USBD_CLR_INT_FLAG(USBD_INT_BUS | USBD_INT_USB | USBD_INT_FLDET | USBD_INT_WAKEUP);
00000a  21ff              MOVS     r1,#0xff
00000c  4803              LDR      r0,|L14.28|
00000e  3110              ADDS     r1,r1,#0x10
000010  3880              SUBS     r0,r0,#0x80
000012  6041              STR      r1,[r0,#4]
;;;103    
;;;104        /* Enable USB-related interrupts. */
;;;105        USBD_ENABLE_INT(USBD_INT_BUS | USBD_INT_USB | USBD_INT_FLDET | USBD_INT_WAKEUP);
000014  6802              LDR      r2,[r0,#0]
000016  430a              ORRS     r2,r2,r1
000018  6002              STR      r2,[r0,#0]
;;;106    }
00001a  4770              BX       lr
;;;107    
                          ENDP

                  |L14.28|
                          DCD      0x40060080

                          AREA ||i.USBD_SwReset||, CODE, READONLY, ALIGN=2

                  USBD_SwReset PROC
;;;609      */
;;;610    void USBD_SwReset(void)
000000  b530              PUSH     {r4,r5,lr}
;;;611    {
;;;612        int i;
;;;613        
;;;614        // Reset all variables for protocol
;;;615        g_usbd_CtrlInPointer = 0;
000002  480c              LDR      r0,|L15.52|
000004  2200              MOVS     r2,#0
;;;616        g_usbd_CtrlInSize = 0;
000006  6042              STR      r2,[r0,#4]  ; g_usbd_CtrlInPointer
000008  6082              STR      r2,[r0,#8]  ; g_usbd_CtrlInSize
;;;617        g_usbd_CtrlOutPointer = 0;
;;;618        g_usbd_CtrlOutSize = 0;
00000a  60c2              STR      r2,[r0,#0xc]  ; g_usbd_CtrlOutPointer
00000c  6102              STR      r2,[r0,#0x10]  ; g_usbd_CtrlOutSize
;;;619        g_usbd_CtrlOutSizeLimit = 0;
00000e  6142              STR      r2,[r0,#0x14]  ; g_usbd_CtrlOutSizeLimit
;;;620        g_u32EpStallLock = 0;
;;;621        memset(g_usbd_SetupPacket, 0, 8);
000010  6382              STR      r2,[r0,#0x38]  ; g_u32EpStallLock
000012  6402              STR      r2,[r0,#0x40]  ; g_usbd_SetupPacket
;;;622    
;;;623        /* Reset PID DATA0 */
;;;624        for(i=0; i<USBD_MAX_EP; i++)
000014  6442              STR      r2,[r0,#0x44]  ; g_usbd_SetupPacket
;;;625            USBD->EP[i].CFG &= ~USBD_CFG_DSQ_SYNC_Msk;
000016  4b08              LDR      r3,|L15.56|
000018  4610              MOV      r0,r2                 ;624
00001a  2480              MOVS     r4,#0x80
                  |L15.28|
00001c  0101              LSLS     r1,r0,#4
00001e  18c9              ADDS     r1,r1,r3
000020  688d              LDR      r5,[r1,#8]
000022  43a5              BICS     r5,r5,r4
000024  608d              STR      r5,[r1,#8]
000026  1c40              ADDS     r0,r0,#1
000028  2808              CMP      r0,#8                 ;624
00002a  dbf7              BLT      |L15.28|
;;;626    
;;;627        // Reset USB device address
;;;628        USBD_SET_ADDR(0);
00002c  4803              LDR      r0,|L15.60|
00002e  6082              STR      r2,[r0,#8]
;;;629    }
000030  bd30              POP      {r4,r5,pc}
;;;630    
                          ENDP

000032  0000              DCW      0x0000
                  |L15.52|
                          DCD      ||.data||
                  |L15.56|
                          DCD      0x40060500
                  |L15.60|
                          DCD      0x40060000

                          AREA ||.data||, DATA, ALIGN=2

                  g_usbd_RemoteWakeupEn
000000  00                DCB      0x00
                  u8ZeroFlag
000001  000000            DCB      0x00,0x00,0x00
                  g_usbd_CtrlInPointer
                          DCD      0x00000000
                  g_usbd_CtrlInSize
                          DCD      0x00000000
                  g_usbd_CtrlOutPointer
                          DCD      0x00000000
                  g_usbd_CtrlOutSize
                          DCD      0x00000000
                  g_usbd_CtrlOutSizeLimit
                          DCD      0x00000000
                  g_usbd_UsbAddr
                          DCD      0x00000000
                  g_usbd_UsbConfig
                          DCD      0x00000000
                  g_usbd_CtrlMaxPktSize
                          DCD      0x00000008
                  g_usbd_UsbAltInterface
                          DCD      0x00000000
                  g_usbd_pfnVendorRequest
                          DCD      0x00000000
                  g_usbd_pfnClassRequest
                          DCD      0x00000000
                  g_usbd_pfnSetInterface
                          DCD      0x00000000
                  g_usbd_pfnSetConfigCallback
                          DCD      0x00000000
                  g_u32EpStallLock
                          DCD      0x00000000
                  g_usbd_sInfo
                          DCD      0x00000000
                  g_usbd_SetupPacket
000040  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "Libraries\\StdDriver\\src\\usbd.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___6_usbd_c_4b498b38____REV16|
#line 118 ".\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___6_usbd_c_4b498b38____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___6_usbd_c_4b498b38____REVSH|
#line 132
|__asm___6_usbd_c_4b498b38____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
