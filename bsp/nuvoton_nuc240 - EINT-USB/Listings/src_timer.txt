; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\src_timer.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\src_timer.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I.\Libraries\Device\Nuvoton -I..\..\components\finsh -I.\Libraries\CMSIS\Include -I.\Libraries\StdDriver\inc -I..\..\include -I.\APP -I.\Drivers -I..\..\components\drivers\include -I..\..\components\drivers\include\drivers -I..\nuvoton_nuc240 -I.\Libraries\Device\Nuvoton\NUC230_240\Include -I..\..\include -I..\..\components\drivers\usb\usbdevice\class -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=521 --omf_browse=.\objects\src_timer.crf ..\..\src\src_timer.c]
                          THUMB

                          AREA ||i._rt_timer_init||, CODE, READONLY, ALIGN=1

                  _rt_timer_init PROC
;;;81     
;;;82     static void _rt_timer_init(rt_timer_t timer,
000000  b510              PUSH     {r4,lr}
;;;83                                void (*timeout)(void *parameter),
;;;84                                void      *parameter,
;;;85                                rt_tick_t  time,
;;;86                                rt_uint8_t flag)
;;;87     {
;;;88         int i;
;;;89     
;;;90         /* set flag */
;;;91         timer->parent.flag  = flag;
;;;92     
;;;93         /* set deactivated */
;;;94         timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
000002  9c02              LDR      r4,[sp,#8]
000004  0864              LSRS     r4,r4,#1
000006  0064              LSLS     r4,r4,#1
000008  7244              STRB     r4,[r0,#9]
;;;95     
;;;96         timer->timeout_func = timeout;
;;;97         timer->parameter    = parameter;
;;;98     
;;;99         timer->timeout_tick = 0;
00000a  6202              STR      r2,[r0,#0x20]
00000c  61c1              STR      r1,[r0,#0x1c]
00000e  2100              MOVS     r1,#0
;;;100        timer->init_tick    = time;
000010  6243              STR      r3,[r0,#0x24]
000012  6281              STR      r1,[r0,#0x28]
                  |L1.20|
;;;101    
;;;102        /* initialize timer list */
;;;103        for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
;;;104        {
;;;105            rt_list_init(&(timer->row[i]));
000014  00ca              LSLS     r2,r1,#3
000016  1812              ADDS     r2,r2,r0
000018  3214              ADDS     r2,r2,#0x14
00001a  6052              STR      r2,[r2,#4]
00001c  1c49              ADDS     r1,r1,#1
00001e  6012              STR      r2,[r2,#0]
000020  2901              CMP      r1,#1                 ;103
000022  dbf7              BLT      |L1.20|
;;;106        }
;;;107    }
000024  bd10              POP      {r4,pc}
;;;108    
                          ENDP


                          AREA ||i._rt_timer_remove||, CODE, READONLY, ALIGN=1

                  _rt_timer_remove PROC
;;;122    
;;;123    rt_inline void _rt_timer_remove(rt_timer_t timer)
000000  b510              PUSH     {r4,lr}
;;;124    {
;;;125        int i;
;;;126    
;;;127        for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
000002  2200              MOVS     r2,#0
                  |L2.4|
;;;128        {
;;;129            rt_list_remove(&timer->row[i]);
000004  00d1              LSLS     r1,r2,#3
000006  1809              ADDS     r1,r1,r0
000008  3114              ADDS     r1,r1,#0x14
00000a  c918              LDM      r1!,{r3,r4}
00000c  3908              SUBS     r1,r1,#8
00000e  605c              STR      r4,[r3,#4]
000010  c918              LDM      r1!,{r3,r4}
000012  3908              SUBS     r1,r1,#8
000014  6023              STR      r3,[r4,#0]
000016  6049              STR      r1,[r1,#4]
000018  1c52              ADDS     r2,r2,#1
00001a  6009              STR      r1,[r1,#0]
00001c  2a01              CMP      r2,#1                 ;127
00001e  dbf1              BLT      |L2.4|
;;;130        }
;;;131    }
000020  bd10              POP      {r4,pc}
;;;132    
                          ENDP


                          AREA ||i.rt_list_insert_after||, CODE, READONLY, ALIGN=1

                  rt_list_insert_after PROC
;;;61      */
;;;62     rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
000000  6802              LDR      r2,[r0,#0]
;;;63     {
;;;64         l->next->prev = n;
;;;65         n->next = l->next;
000002  6051              STR      r1,[r2,#4]
000004  6802              LDR      r2,[r0,#0]
;;;66     
;;;67         l->next = n;
000006  600a              STR      r2,[r1,#0]
;;;68         n->prev = l;
000008  6001              STR      r1,[r0,#0]
00000a  6048              STR      r0,[r1,#4]
;;;69     }
00000c  4770              BX       lr
;;;70     
                          ENDP


                          AREA ||i.rt_list_isempty||, CODE, READONLY, ALIGN=1

                  rt_list_isempty PROC
;;;102     */
;;;103    rt_inline int rt_list_isempty(const rt_list_t *l)
000000  6801              LDR      r1,[r0,#0]
;;;104    {
;;;105        return l->next == l;
000002  4281              CMP      r1,r0
000004  d101              BNE      |L4.10|
000006  2001              MOVS     r0,#1
;;;106    }
000008  4770              BX       lr
                  |L4.10|
00000a  2000              MOVS     r0,#0                 ;105
00000c  4770              BX       lr
;;;107    
                          ENDP


                          AREA ||i.rt_soft_timer_check||, CODE, READONLY, ALIGN=2

                  rt_soft_timer_check PROC
;;;562     */
;;;563    void rt_soft_timer_check(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;564    {
;;;565        rt_tick_t current_tick;
;;;566        rt_list_t *n;
;;;567        struct rt_timer *t;
;;;568    
;;;569        RT_DEBUG_LOG(RT_DEBUG_TIMER, ("software timer check enter\n"));
;;;570    
;;;571        current_tick = rt_tick_get();
000002  f7fffffe          BL       rt_tick_get
000006  4606              MOV      r6,r0
;;;572    
;;;573    	/* lock scheduler */
;;;574    	rt_enter_critical();
000008  f7fffffe          BL       rt_enter_critical
;;;575    
;;;576        for (n = rt_soft_timer_list[RT_TIMER_SKIP_LIST_LEVEL-1].next;
00000c  4f15              LDR      r7,|L5.100|
00000e  683d              LDR      r5,[r7,#0]  ; rt_soft_timer_list
000010  e023              B        |L5.90|
                  |L5.18|
;;;577             n != &(rt_soft_timer_list[RT_TIMER_SKIP_LIST_LEVEL-1]);)
;;;578        {
;;;579            t = rt_list_entry(n, struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL-1]);
;;;580    
;;;581            /*
;;;582             * It supposes that the new tick shall less than the half duration of
;;;583             * tick max.
;;;584             */
;;;585            if ((current_tick - t->timeout_tick) < RT_TICK_MAX / 2)
000012  6968              LDR      r0,[r5,#0x14]
000014  462c              MOV      r4,r5                 ;579
000016  4914              LDR      r1,|L5.104|
000018  3c14              SUBS     r4,r4,#0x14           ;579
00001a  1a30              SUBS     r0,r6,r0
00001c  4288              CMP      r0,r1
00001e  d21e              BCS      |L5.94|
;;;586            {
;;;587                RT_OBJECT_HOOK_CALL(rt_timer_timeout_hook, (t));
;;;588    
;;;589                /* move node to the next */
;;;590                n = n->next;
000020  682d              LDR      r5,[r5,#0]
;;;591    
;;;592                /* remove timer from timer list firstly */
;;;593                _rt_timer_remove(t);
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       _rt_timer_remove
;;;594    
;;;595    			/* not lock scheduler when performing timeout function */
;;;596    			rt_exit_critical();
000028  f7fffffe          BL       rt_exit_critical
;;;597                /* call timeout function */
;;;598                t->timeout_func(t->parameter);
00002c  69e1              LDR      r1,[r4,#0x1c]
00002e  6a20              LDR      r0,[r4,#0x20]
000030  4788              BLX      r1
;;;599    
;;;600                /* re-get tick */
;;;601                current_tick = rt_tick_get();
000032  f7fffffe          BL       rt_tick_get
000036  4606              MOV      r6,r0
;;;602    
;;;603                RT_DEBUG_LOG(RT_DEBUG_TIMER, ("current tick: %d\n", current_tick));
;;;604    
;;;605    			/* lock scheduler */
;;;606    			rt_enter_critical();
000038  f7fffffe          BL       rt_enter_critical
;;;607    
;;;608                if ((t->parent.flag & RT_TIMER_FLAG_PERIODIC) &&
00003c  7a60              LDRB     r0,[r4,#9]
00003e  0781              LSLS     r1,r0,#30
000040  d508              BPL      |L5.84|
;;;609                    (t->parent.flag & RT_TIMER_FLAG_ACTIVATED))
000042  07c1              LSLS     r1,r0,#31
000044  d006              BEQ      |L5.84|
;;;610                {
;;;611                    /* start it */
;;;612                    t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
000046  0840              LSRS     r0,r0,#1
000048  0040              LSLS     r0,r0,#1
00004a  7260              STRB     r0,[r4,#9]
;;;613                    rt_timer_start(t);
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       rt_timer_start
000052  e002              B        |L5.90|
                  |L5.84|
;;;614                }
;;;615                else
;;;616                {
;;;617                    /* stop timer */
;;;618                    t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
000054  0840              LSRS     r0,r0,#1
000056  0040              LSLS     r0,r0,#1
000058  7260              STRB     r0,[r4,#9]
                  |L5.90|
00005a  42bd              CMP      r5,r7                 ;577
00005c  d1d9              BNE      |L5.18|
                  |L5.94|
;;;619                }
;;;620            }
;;;621            else break; /* not check anymore */
;;;622        }
;;;623    
;;;624    	/* unlock scheduler */
;;;625    	rt_exit_critical();
00005e  f7fffffe          BL       rt_exit_critical
;;;626    
;;;627        RT_DEBUG_LOG(RT_DEBUG_TIMER, ("software timer check leave\n"));
;;;628    }
000062  bdf8              POP      {r3-r7,pc}
;;;629    
                          ENDP

                  |L5.100|
                          DCD      ||.data||+0xc
                  |L5.104|
                          DCD      0x7fffffff

                          AREA ||i.rt_system_timer_init||, CODE, READONLY, ALIGN=2

                  rt_system_timer_init PROC
;;;670     */
;;;671    void rt_system_timer_init(void)
000000  4a04              LDR      r2,|L6.20|
;;;672    {
;;;673        int i;
;;;674    
;;;675        for (i = 0; i < sizeof(rt_timer_list)/sizeof(rt_timer_list[0]); i++)
000002  2000              MOVS     r0,#0
                  |L6.4|
;;;676        {
;;;677            rt_list_init(rt_timer_list+i);
000004  00c1              LSLS     r1,r0,#3
000006  1889              ADDS     r1,r1,r2
000008  6049              STR      r1,[r1,#4]
00000a  6009              STR      r1,[r1,#0]
00000c  1c40              ADDS     r0,r0,#1
00000e  d0f9              BEQ      |L6.4|
;;;678        }
;;;679    }
000010  4770              BX       lr
;;;680    
                          ENDP

000012  0000              DCW      0x0000
                  |L6.20|
                          DCD      ||.data||+0x4

                          AREA ||i.rt_system_timer_thread_init||, CODE, READONLY, ALIGN=2

                  rt_system_timer_thread_init PROC
;;;685     */
;;;686    void rt_system_timer_thread_init(void)
000000  b51f              PUSH     {r0-r4,lr}
;;;687    {
;;;688    #ifdef RT_USING_TIMER_SOFT
;;;689        int i;
;;;690    
;;;691        for (i = 0;
;;;692             i < sizeof(rt_soft_timer_list)/sizeof(rt_soft_timer_list[0]);
;;;693             i++)
;;;694        {
;;;695            rt_list_init(rt_soft_timer_list+i);
000002  4a0c              LDR      r2,|L7.52|
000004  2000              MOVS     r0,#0                 ;691
                  |L7.6|
000006  00c1              LSLS     r1,r0,#3
000008  1889              ADDS     r1,r1,r2
00000a  6049              STR      r1,[r1,#4]
00000c  6009              STR      r1,[r1,#0]
00000e  1c40              ADDS     r0,r0,#1
000010  d0f9              BEQ      |L7.6|
;;;696        }
;;;697    
;;;698        /* start software timer thread */
;;;699        rt_thread_init(&timer_thread,
000012  2204              MOVS     r2,#4
000014  4808              LDR      r0,|L7.56|
000016  230a              MOVS     r3,#0xa
000018  01d1              LSLS     r1,r2,#7
00001a  466c              MOV      r4,sp
00001c  c40f              STM      r4!,{r0-r3}
00001e  2300              MOVS     r3,#0
000020  4a06              LDR      r2,|L7.60|
000022  a107              ADR      r1,|L7.64|
000024  3880              SUBS     r0,r0,#0x80
000026  f7fffffe          BL       rt_thread_init
;;;700                       "timer",
;;;701                       rt_thread_timer_entry,
;;;702                       RT_NULL,
;;;703                       &timer_thread_stack[0],
;;;704                       sizeof(timer_thread_stack),
;;;705                       RT_TIMER_THREAD_PRIO,
;;;706                       10);
;;;707    
;;;708        /* startup */
;;;709        rt_thread_startup(&timer_thread);
00002a  4803              LDR      r0,|L7.56|
00002c  3880              SUBS     r0,r0,#0x80
00002e  f7fffffe          BL       rt_thread_startup
;;;710    #endif
;;;711    }
000032  bd1f              POP      {r0-r4,pc}
;;;712    
                          ENDP

                  |L7.52|
                          DCD      ||.data||+0xc
                  |L7.56|
                          DCD      ||.bss||+0x80
                  |L7.60|
                          DCD      rt_thread_timer_entry
                  |L7.64|
000040  74696d65          DCB      "timer",0
000044  7200    
000046  00                DCB      0
000047  00                DCB      0

                          AREA ||i.rt_thread_timer_entry||, CODE, READONLY, ALIGN=2

                  rt_thread_timer_entry PROC
;;;630    /* system timer thread entry */
;;;631    static void rt_thread_timer_entry(void *parameter)
000000  4d0b              LDR      r5,|L8.48|
                  |L8.2|
;;;632    {
;;;633        rt_tick_t next_timeout;
;;;634    
;;;635        while (1)
;;;636        {
;;;637            /* get the next timeout tick */
;;;638            next_timeout = rt_timer_list_next_timeout(rt_soft_timer_list);
000002  480c              LDR      r0,|L8.52|
000004  f7fffffe          BL       rt_timer_list_next_timeout
000008  4604              MOV      r4,r0
;;;639            if (next_timeout == RT_TICK_MAX)
00000a  1c40              ADDS     r0,r0,#1
00000c  d009              BEQ      |L8.34|
;;;640            {
;;;641                /* no software timer exist, suspend self. */
;;;642                rt_thread_suspend(rt_thread_self());
;;;643                rt_schedule();
;;;644            }
;;;645            else
;;;646            {
;;;647                rt_tick_t current_tick;
;;;648    
;;;649                /* get current tick */
;;;650                current_tick = rt_tick_get();
00000e  f7fffffe          BL       rt_tick_get
;;;651    
;;;652                if ((next_timeout - current_tick) < RT_TICK_MAX/2)
000012  1a20              SUBS     r0,r4,r0
000014  42a8              CMP      r0,r5
000016  d201              BCS      |L8.28|
;;;653                {
;;;654                    /* get the delta timeout tick */
;;;655                    next_timeout = next_timeout - current_tick;
;;;656                    rt_thread_delay(next_timeout);
000018  f7fffffe          BL       rt_thread_delay
                  |L8.28|
;;;657                }
;;;658            }
;;;659    
;;;660            /* check software timer */
;;;661            rt_soft_timer_check();
00001c  f7fffffe          BL       rt_soft_timer_check
000020  e7ef              B        |L8.2|
                  |L8.34|
000022  f7fffffe          BL       rt_thread_self
000026  f7fffffe          BL       rt_thread_suspend
00002a  f7fffffe          BL       rt_schedule
00002e  e7f5              B        |L8.28|
;;;662        }
;;;663    }
;;;664    #endif
                          ENDP

                  |L8.48|
                          DCD      0x7fffffff
                  |L8.52|
                          DCD      ||.data||+0xc

                          AREA ||i.rt_timer_check||, CODE, READONLY, ALIGN=2

                  rt_timer_check PROC
;;;487     */
;;;488    void rt_timer_check(void)
000000  b570              PUSH     {r4-r6,lr}
;;;489    {
;;;490        struct rt_timer *t;
;;;491        rt_tick_t current_tick;
;;;492        register rt_base_t level;
;;;493    
;;;494        RT_DEBUG_LOG(RT_DEBUG_TIMER, ("timer check enter\n"));
;;;495    
;;;496        current_tick = rt_tick_get();
000002  f7fffffe          BL       rt_tick_get
000006  4605              MOV      r5,r0
;;;497    
;;;498        /* disable interrupt */
;;;499        level = rt_hw_interrupt_disable();
000008  f7fffffe          BL       rt_hw_interrupt_disable
00000c  4606              MOV      r6,r0
;;;500    
;;;501        while (!rt_list_isempty(&rt_timer_list[RT_TIMER_SKIP_LIST_LEVEL-1]))
00000e  e01f              B        |L9.80|
                  |L9.16|
;;;502        {
;;;503            t = rt_list_entry(rt_timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next,
000010  4814              LDR      r0,|L9.100|
;;;504                              struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);
;;;505    
;;;506            /*
;;;507             * It supposes that the new tick shall less than the half duration of
;;;508             * tick max.
;;;509             */
;;;510            if ((current_tick - t->timeout_tick) < RT_TICK_MAX/2)
000012  4915              LDR      r1,|L9.104|
000014  6804              LDR      r4,[r0,#0]  ; rt_timer_list
000016  6960              LDR      r0,[r4,#0x14]
000018  3c14              SUBS     r4,r4,#0x14
00001a  1a28              SUBS     r0,r5,r0
00001c  4288              CMP      r0,r1
00001e  d21c              BCS      |L9.90|
;;;511            {
;;;512                RT_OBJECT_HOOK_CALL(rt_timer_timeout_hook, (t));
;;;513    
;;;514                /* remove timer from timer list firstly */
;;;515                _rt_timer_remove(t);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       _rt_timer_remove
;;;516    
;;;517                /* call timeout function */
;;;518                t->timeout_func(t->parameter);
000026  69e1              LDR      r1,[r4,#0x1c]
000028  6a20              LDR      r0,[r4,#0x20]
00002a  4788              BLX      r1
;;;519    
;;;520                /* re-get tick */
;;;521                current_tick = rt_tick_get();
00002c  f7fffffe          BL       rt_tick_get
000030  4605              MOV      r5,r0
;;;522    
;;;523                RT_DEBUG_LOG(RT_DEBUG_TIMER, ("current tick: %d\n", current_tick));
;;;524    
;;;525                if ((t->parent.flag & RT_TIMER_FLAG_PERIODIC) &&
000032  7a60              LDRB     r0,[r4,#9]
000034  0781              LSLS     r1,r0,#30
000036  d508              BPL      |L9.74|
;;;526                    (t->parent.flag & RT_TIMER_FLAG_ACTIVATED))
000038  07c1              LSLS     r1,r0,#31
00003a  d006              BEQ      |L9.74|
;;;527                {
;;;528                    /* start it */
;;;529                    t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
00003c  0840              LSRS     r0,r0,#1
00003e  0040              LSLS     r0,r0,#1
000040  7260              STRB     r0,[r4,#9]
;;;530                    rt_timer_start(t);
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       rt_timer_start
000048  e002              B        |L9.80|
                  |L9.74|
;;;531                }
;;;532                else
;;;533                {
;;;534                    /* stop timer */
;;;535                    t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
00004a  0840              LSRS     r0,r0,#1
00004c  0040              LSLS     r0,r0,#1
00004e  7260              STRB     r0,[r4,#9]
                  |L9.80|
000050  4804              LDR      r0,|L9.100|
000052  f7fffffe          BL       rt_list_isempty
000056  2800              CMP      r0,#0                 ;501
000058  d0da              BEQ      |L9.16|
                  |L9.90|
;;;536                }
;;;537            }
;;;538            else
;;;539                break;
;;;540        }
;;;541    
;;;542        /* enable interrupt */
;;;543        rt_hw_interrupt_enable(level);
00005a  4630              MOV      r0,r6
00005c  f7fffffe          BL       rt_hw_interrupt_enable
;;;544    
;;;545        RT_DEBUG_LOG(RT_DEBUG_TIMER, ("timer check leave\n"));
;;;546    }
000060  bd70              POP      {r4-r6,pc}
;;;547    
                          ENDP

000062  0000              DCW      0x0000
                  |L9.100|
                          DCD      ||.data||+0x4
                  |L9.104|
                          DCD      0x7fffffff

                          AREA ||i.rt_timer_control||, CODE, READONLY, ALIGN=1

                  rt_timer_control PROC
;;;453     */
;;;454    rt_err_t rt_timer_control(rt_timer_t timer, rt_uint8_t cmd, void *arg)
000000  2900              CMP      r1,#0
;;;455    {
000002  d009              BEQ      |L10.24|
;;;456        /* timer check */
;;;457        RT_ASSERT(timer != RT_NULL);
;;;458    
;;;459        switch (cmd)
000004  2901              CMP      r1,#1
000006  d004              BEQ      |L10.18|
000008  2902              CMP      r1,#2
00000a  d008              BEQ      |L10.30|
00000c  2903              CMP      r1,#3
00000e  d10e              BNE      |L10.46|
000010  e009              B        |L10.38|
                  |L10.18|
;;;460        {
;;;461        case RT_TIMER_CTRL_GET_TIME:
;;;462            *(rt_tick_t *)arg = timer->init_tick;
000012  6a40              LDR      r0,[r0,#0x24]
;;;463            break;
000014  6010              STR      r0,[r2,#0]
000016  e00a              B        |L10.46|
                  |L10.24|
;;;464    
;;;465        case RT_TIMER_CTRL_SET_TIME:
;;;466            timer->init_tick = *(rt_tick_t *)arg;
000018  6811              LDR      r1,[r2,#0]
;;;467            break;
00001a  6241              STR      r1,[r0,#0x24]
00001c  e007              B        |L10.46|
                  |L10.30|
;;;468    
;;;469        case RT_TIMER_CTRL_SET_ONESHOT:
;;;470            timer->parent.flag &= ~RT_TIMER_FLAG_PERIODIC;
00001e  7a41              LDRB     r1,[r0,#9]
000020  22fd              MOVS     r2,#0xfd
000022  4011              ANDS     r1,r1,r2
;;;471            break;
000024  e002              B        |L10.44|
                  |L10.38|
;;;472    
;;;473        case RT_TIMER_CTRL_SET_PERIODIC:
;;;474            timer->parent.flag |= RT_TIMER_FLAG_PERIODIC;
000026  7a41              LDRB     r1,[r0,#9]
000028  2202              MOVS     r2,#2
00002a  4311              ORRS     r1,r1,r2
                  |L10.44|
00002c  7241              STRB     r1,[r0,#9]            ;470
                  |L10.46|
;;;475            break;
;;;476        }
;;;477    
;;;478        return RT_EOK;
00002e  2000              MOVS     r0,#0
;;;479    }
000030  4770              BX       lr
;;;480    RTM_EXPORT(rt_timer_control);
                          ENDP


                          AREA ||i.rt_timer_create||, CODE, READONLY, ALIGN=1

                  rt_timer_create PROC
;;;236     */
;;;237    rt_timer_t rt_timer_create(const char *name,
000000  b5ff              PUSH     {r0-r7,lr}
;;;238                               void (*timeout)(void *parameter),
;;;239                               void       *parameter,
;;;240                               rt_tick_t   time,
;;;241                               rt_uint8_t  flag)
;;;242    {
000002  b081              SUB      sp,sp,#4
;;;243        struct rt_timer *timer;
;;;244    
;;;245        /* allocate a object */
;;;246        timer = (struct rt_timer *)rt_object_allocate(RT_Object_Class_Timer, name);
000004  4601              MOV      r1,r0
000006  461e              MOV      r6,r3                 ;242
000008  4617              MOV      r7,r2                 ;242
00000a  2008              MOVS     r0,#8
00000c  9d0a              LDR      r5,[sp,#0x28]
00000e  f7fffffe          BL       rt_object_allocate
000012  0004              MOVS     r4,r0
;;;247        if (timer == RT_NULL)
000014  d008              BEQ      |L11.40|
;;;248        {
;;;249            return RT_NULL;
;;;250        }
;;;251    
;;;252        _rt_timer_init(timer, timeout, parameter, time, flag);
000016  4633              MOV      r3,r6
000018  463a              MOV      r2,r7
00001a  9500              STR      r5,[sp,#0]
00001c  9902              LDR      r1,[sp,#8]
00001e  f7fffffe          BL       _rt_timer_init
;;;253    
;;;254        return timer;
000022  4620              MOV      r0,r4
                  |L11.36|
;;;255    }
000024  b005              ADD      sp,sp,#0x14
000026  bdf0              POP      {r4-r7,pc}
                  |L11.40|
000028  2000              MOVS     r0,#0                 ;249
00002a  e7fb              B        |L11.36|
;;;256    RTM_EXPORT(rt_timer_create);
                          ENDP


                          AREA ||i.rt_timer_delete||, CODE, READONLY, ALIGN=1

                  rt_timer_delete PROC
;;;264     */
;;;265    rt_err_t rt_timer_delete(rt_timer_t timer)
000000  b570              PUSH     {r4-r6,lr}
;;;266    {
000002  4605              MOV      r5,r0
;;;267        register rt_base_t level;
;;;268    
;;;269        /* timer check */
;;;270        RT_ASSERT(timer != RT_NULL);
;;;271    
;;;272        /* disable interrupt */
;;;273        level = rt_hw_interrupt_disable();
000004  f7fffffe          BL       rt_hw_interrupt_disable
000008  4604              MOV      r4,r0
;;;274    
;;;275        _rt_timer_remove(timer);
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       _rt_timer_remove
;;;276    
;;;277        /* enable interrupt */
;;;278        rt_hw_interrupt_enable(level);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       rt_hw_interrupt_enable
;;;279    
;;;280        rt_object_delete((rt_object_t)timer);
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       rt_object_delete
;;;281    
;;;282        return -RT_EOK;
00001c  2000              MOVS     r0,#0
;;;283    }
00001e  bd70              POP      {r4-r6,pc}
;;;284    RTM_EXPORT(rt_timer_delete);
                          ENDP


                          AREA ||i.rt_timer_detach||, CODE, READONLY, ALIGN=1

                  rt_timer_detach PROC
;;;203     */
;;;204    rt_err_t rt_timer_detach(rt_timer_t timer)
000000  b570              PUSH     {r4-r6,lr}
;;;205    {
000002  4605              MOV      r5,r0
;;;206        register rt_base_t level;
;;;207    
;;;208        /* timer check */
;;;209        RT_ASSERT(timer != RT_NULL);
;;;210    
;;;211        /* disable interrupt */
;;;212        level = rt_hw_interrupt_disable();
000004  f7fffffe          BL       rt_hw_interrupt_disable
000008  4604              MOV      r4,r0
;;;213    
;;;214        _rt_timer_remove(timer);
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       _rt_timer_remove
;;;215    
;;;216        /* enable interrupt */
;;;217        rt_hw_interrupt_enable(level);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       rt_hw_interrupt_enable
;;;218    
;;;219        rt_object_detach((rt_object_t)timer);
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       rt_object_detach
;;;220    
;;;221        return -RT_EOK;
00001c  2000              MOVS     r0,#0
;;;222    }
00001e  bd70              POP      {r4-r6,pc}
;;;223    RTM_EXPORT(rt_timer_detach);
                          ENDP


                          AREA ||i.rt_timer_init||, CODE, READONLY, ALIGN=1

                  rt_timer_init PROC
;;;179     */
;;;180    void rt_timer_init(rt_timer_t  timer,
000000  b5ff              PUSH     {r0-r7,lr}
;;;181                       const char *name,
;;;182                       void (*timeout)(void *parameter),
;;;183                       void       *parameter,
;;;184                       rt_tick_t   time,
;;;185                       rt_uint8_t  flag)
;;;186    {
000002  b081              SUB      sp,sp,#4
;;;187        /* timer check */
;;;188        RT_ASSERT(timer != RT_NULL);
;;;189    
;;;190        /* timer object initialization */
;;;191        rt_object_init((rt_object_t)timer, RT_Object_Class_Timer, name);
000004  460a              MOV      r2,r1
000006  461f              MOV      r7,r3                 ;186
000008  4606              MOV      r6,r0                 ;186
00000a  2108              MOVS     r1,#8
00000c  9d0b              LDR      r5,[sp,#0x2c]
00000e  9c0a              LDR      r4,[sp,#0x28]
000010  f7fffffe          BL       rt_object_init
;;;192    
;;;193        _rt_timer_init(timer, timeout, parameter, time, flag);
000014  4623              MOV      r3,r4
000016  463a              MOV      r2,r7
000018  9500              STR      r5,[sp,#0]
00001a  4630              MOV      r0,r6
00001c  9903              LDR      r1,[sp,#0xc]
00001e  f7fffffe          BL       _rt_timer_init
;;;194    }
000022  b005              ADD      sp,sp,#0x14
000024  bdf0              POP      {r4-r7,pc}
;;;195    RTM_EXPORT(rt_timer_init);
                          ENDP


                          AREA ||i.rt_timer_list_next_timeout||, CODE, READONLY, ALIGN=1

                  rt_timer_list_next_timeout PROC
;;;109    /* the fist timer always in the last row */
;;;110    static rt_tick_t rt_timer_list_next_timeout(rt_list_t timer_list[])
000000  b510              PUSH     {r4,lr}
;;;111    {
000002  4604              MOV      r4,r0
;;;112        struct rt_timer *timer;
;;;113    
;;;114        if (rt_list_isempty(&timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1]))
000004  f7fffffe          BL       rt_list_isempty
000008  2800              CMP      r0,#0
00000a  d002              BEQ      |L15.18|
;;;115            return RT_TICK_MAX;
00000c  2000              MOVS     r0,#0
00000e  43c0              MVNS     r0,r0
;;;116    
;;;117        timer = rt_list_entry(timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next,
;;;118                              struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);
;;;119    
;;;120        return timer->timeout_tick;
;;;121    }
000010  bd10              POP      {r4,pc}
                  |L15.18|
000012  6820              LDR      r0,[r4,#0]            ;120
000014  6940              LDR      r0,[r0,#0x14]         ;120
000016  bd10              POP      {r4,pc}
;;;122    
                          ENDP


                          AREA ||i.rt_timer_next_timeout_tick||, CODE, READONLY, ALIGN=2

                  rt_timer_next_timeout_tick PROC
;;;552     */
;;;553    rt_tick_t rt_timer_next_timeout_tick(void)
000000  b510              PUSH     {r4,lr}
;;;554    {
;;;555        return rt_timer_list_next_timeout(rt_timer_list);
000002  4802              LDR      r0,|L16.12|
000004  f7fffffe          BL       rt_timer_list_next_timeout
;;;556    }
000008  bd10              POP      {r4,pc}
;;;557    
                          ENDP

00000a  0000              DCW      0x0000
                  |L16.12|
                          DCD      ||.data||+0x4

                          AREA ||i.rt_timer_start||, CODE, READONLY, ALIGN=2

                  rt_timer_start PROC
;;;293     */
;;;294    rt_err_t rt_timer_start(rt_timer_t timer)
000000  b5fe              PUSH     {r1-r7,lr}
;;;295    {
000002  4604              MOV      r4,r0
;;;296        unsigned int row_lvl;
;;;297        rt_list_t *timer_list;
;;;298        register rt_base_t level;
;;;299        rt_list_t *row_head[RT_TIMER_SKIP_LIST_LEVEL];
;;;300        unsigned int tst_nr;
;;;301        static unsigned int random_nr;
;;;302    
;;;303        /* timer check */
;;;304        RT_ASSERT(timer != RT_NULL);
;;;305    
;;;306    	/* stop timer firstly */
;;;307    	level = rt_hw_interrupt_disable();
000004  f7fffffe          BL       rt_hw_interrupt_disable
000008  4605              MOV      r5,r0
;;;308    	/* remove timer from list */
;;;309        _rt_timer_remove(timer);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       _rt_timer_remove
;;;310        /* change status of timer */
;;;311        timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
000010  7a60              LDRB     r0,[r4,#9]
000012  0840              LSRS     r0,r0,#1
000014  0040              LSLS     r0,r0,#1
000016  7260              STRB     r0,[r4,#9]
;;;312        rt_hw_interrupt_enable(level);
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       rt_hw_interrupt_enable
;;;313    
;;;314        RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(timer->parent)));
;;;315    
;;;316        /*
;;;317         * get timeout tick,
;;;318         * the max timeout tick shall not great than RT_TICK_MAX/2
;;;319         */
;;;320        RT_ASSERT(timer->init_tick < RT_TICK_MAX / 2);
;;;321        timer->timeout_tick = rt_tick_get() + timer->init_tick;
00001e  f7fffffe          BL       rt_tick_get
000022  6a61              LDR      r1,[r4,#0x24]
000024  1840              ADDS     r0,r0,r1
;;;322    
;;;323        /* disable interrupt */
;;;324        level = rt_hw_interrupt_disable();
000026  62a0              STR      r0,[r4,#0x28]
000028  f7fffffe          BL       rt_hw_interrupt_disable
;;;325    
;;;326    #ifdef RT_USING_TIMER_SOFT
;;;327        if (timer->parent.flag & RT_TIMER_FLAG_SOFT_TIMER)
00002c  9001              STR      r0,[sp,#4]
00002e  7a60              LDRB     r0,[r4,#9]
000030  0740              LSLS     r0,r0,#29
000032  d501              BPL      |L17.56|
;;;328        {
;;;329            /* insert timer to soft timer list */
;;;330            timer_list = rt_soft_timer_list;
000034  4e21              LDR      r6,|L17.188|
000036  e001              B        |L17.60|
                  |L17.56|
;;;331        }
;;;332        else
;;;333    #endif
;;;334        {
;;;335            /* insert timer to system timer list */
;;;336            timer_list = rt_timer_list;
000038  4e20              LDR      r6,|L17.188|
00003a  3e08              SUBS     r6,r6,#8
                  |L17.60|
;;;337        }
;;;338    
;;;339        row_head[0]  = &timer_list[0];
;;;340        for (row_lvl = 0; row_lvl < RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
00003c  2200              MOVS     r2,#0
00003e  466f              MOV      r7,sp                 ;299
000040  9600              STR      r6,[sp,#0]
000042  e00c              B        |L17.94|
                  |L17.68|
;;;341        {
;;;342            for (;row_head[row_lvl] != timer_list[row_lvl].prev;
;;;343                 row_head[row_lvl]  = row_head[row_lvl]->next)
;;;344            {
;;;345                struct rt_timer *t;
;;;346                rt_list_t *p = row_head[row_lvl]->next;
000044  6805              LDR      r5,[r0,#0]
;;;347    
;;;348                /* fix up the entry pointer */
;;;349                t = rt_list_entry(p, struct rt_timer, row[row_lvl]);
000046  1aeb              SUBS     r3,r5,r3
000048  46ac              MOV      r12,r5                ;346
;;;350    
;;;351                /* If we have two timers that timeout at the same time, it's
;;;352                 * preferred that the timer inserted early get called early.
;;;353                 * So insert the new timer to the end the the some-timeout timer
;;;354                 * list.
;;;355                 */
;;;356                if ((t->timeout_tick - timer->timeout_tick) == 0)
00004a  695b              LDR      r3,[r3,#0x14]
00004c  6aa5              LDR      r5,[r4,#0x28]
00004e  42ab              CMP      r3,r5
000050  d003              BEQ      |L17.90|
;;;357                {
;;;358                    continue;
;;;359                }
;;;360                else if ((t->timeout_tick - timer->timeout_tick) < RT_TICK_MAX / 2)
000052  1b5b              SUBS     r3,r3,r5
000054  4d1a              LDR      r5,|L17.192|
000056  42ab              CMP      r3,r5
000058  d308              BCC      |L17.108|
                  |L17.90|
00005a  4660              MOV      r0,r12
00005c  5078              STR      r0,[r7,r1]            ;343
                  |L17.94|
00005e  00d3              LSLS     r3,r2,#3              ;342
000060  0091              LSLS     r1,r2,#2              ;342
000062  199d              ADDS     r5,r3,r6              ;342
000064  5878              LDR      r0,[r7,r1]            ;342
000066  686d              LDR      r5,[r5,#4]            ;342
000068  42a8              CMP      r0,r5                 ;342
00006a  d1eb              BNE      |L17.68|
                  |L17.108|
;;;361                {
;;;362                    break;
;;;363                }
;;;364            }
;;;365            if (row_lvl != RT_TIMER_SKIP_LIST_LEVEL - 1)
00006c  2a00              CMP      r2,#0
00006e  d002              BEQ      |L17.118|
;;;366                row_head[row_lvl+1] = row_head[row_lvl]+1;
000070  19c9              ADDS     r1,r1,r7
000072  3008              ADDS     r0,r0,#8
000074  6048              STR      r0,[r1,#4]
                  |L17.118|
000076  1c52              ADDS     r2,r2,#1
000078  d0f1              BEQ      |L17.94|
;;;367        }
;;;368    
;;;369        /* Interestingly, this super simple timer insert counter works very very
;;;370         * well on distributing the list height uniformly. By means of "very very
;;;371         * well", I mean it beats the randomness of timer->timeout_tick very easily
;;;372         * (actually, the timeout_tick is not random and easy to be attacked). */
;;;373        random_nr++;
00007a  4810              LDR      r0,|L17.188|
00007c  380c              SUBS     r0,r0,#0xc
00007e  6801              LDR      r1,[r0,#0]  ; random_nr
000080  1c49              ADDS     r1,r1,#1
;;;374        tst_nr = random_nr;
;;;375    
;;;376        rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL-1],
000082  6001              STR      r1,[r0,#0]  ; random_nr
000084  4621              MOV      r1,r4
000086  3114              ADDS     r1,r1,#0x14
000088  9800              LDR      r0,[sp,#0]
00008a  f7fffffe          BL       rt_list_insert_after
;;;377                             &(timer->row[RT_TIMER_SKIP_LIST_LEVEL-1]));
;;;378        for (row_lvl = 2; row_lvl <= RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
;;;379        {
;;;380            if (!(tst_nr & RT_TIMER_SKIP_LIST_MASK))
;;;381                rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL - row_lvl],
;;;382                                     &(timer->row[RT_TIMER_SKIP_LIST_LEVEL - row_lvl]));
;;;383            else
;;;384                break;
;;;385            /* Shift over the bits we have tested. Works well with 1 bit and 2
;;;386             * bits. */
;;;387            tst_nr >>= (RT_TIMER_SKIP_LIST_MASK+1)>>1;
;;;388        }
;;;389    
;;;390        timer->parent.flag |= RT_TIMER_FLAG_ACTIVATED;
00008e  7a60              LDRB     r0,[r4,#9]
000090  2101              MOVS     r1,#1
000092  4308              ORRS     r0,r0,r1
000094  7260              STRB     r0,[r4,#9]
;;;391    
;;;392        /* enable interrupt */
;;;393        rt_hw_interrupt_enable(level);
000096  9801              LDR      r0,[sp,#4]
000098  f7fffffe          BL       rt_hw_interrupt_enable
;;;394    
;;;395    #ifdef RT_USING_TIMER_SOFT
;;;396        if (timer->parent.flag & RT_TIMER_FLAG_SOFT_TIMER)
00009c  7a60              LDRB     r0,[r4,#9]
00009e  0740              LSLS     r0,r0,#29
0000a0  d509              BPL      |L17.182|
;;;397        {
;;;398            /* check whether timer thread is ready */
;;;399            if (timer_thread.stat != RT_THREAD_READY)
0000a2  4808              LDR      r0,|L17.196|
0000a4  7d00              LDRB     r0,[r0,#0x14]  ; timer_thread
0000a6  2801              CMP      r0,#1
0000a8  d005              BEQ      |L17.182|
;;;400            {
;;;401                /* resume timer thread to check soft timer */
;;;402                rt_thread_resume(&timer_thread);
0000aa  4806              LDR      r0,|L17.196|
0000ac  3820              SUBS     r0,r0,#0x20
0000ae  f7fffffe          BL       rt_thread_resume
;;;403                rt_schedule();
0000b2  f7fffffe          BL       rt_schedule
                  |L17.182|
;;;404            }
;;;405        }
;;;406    #endif
;;;407    
;;;408        return -RT_EOK;
0000b6  2000              MOVS     r0,#0
;;;409    }
0000b8  bdfe              POP      {r1-r7,pc}
;;;410    RTM_EXPORT(rt_timer_start);
                          ENDP

0000ba  0000              DCW      0x0000
                  |L17.188|
                          DCD      ||.data||+0xc
                  |L17.192|
                          DCD      0x7fffffff
                  |L17.196|
                          DCD      ||.bss||+0x20

                          AREA ||i.rt_timer_stop||, CODE, READONLY, ALIGN=1

                  rt_timer_stop PROC
;;;418     */
;;;419    rt_err_t rt_timer_stop(rt_timer_t timer)
000000  b570              PUSH     {r4-r6,lr}
;;;420    {
000002  4604              MOV      r4,r0
;;;421        register rt_base_t level;
;;;422    
;;;423        /* timer check */
;;;424        RT_ASSERT(timer != RT_NULL);
;;;425        if (!(timer->parent.flag & RT_TIMER_FLAG_ACTIVATED))
000004  7a40              LDRB     r0,[r0,#9]
000006  07c0              LSLS     r0,r0,#31
000008  d00e              BEQ      |L18.40|
;;;426            return -RT_ERROR;
;;;427    
;;;428        RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(timer->parent)));
;;;429    
;;;430        /* disable interrupt */
;;;431        level = rt_hw_interrupt_disable();
00000a  f7fffffe          BL       rt_hw_interrupt_disable
00000e  4605              MOV      r5,r0
;;;432    
;;;433        _rt_timer_remove(timer);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       _rt_timer_remove
;;;434    
;;;435        /* enable interrupt */
;;;436        rt_hw_interrupt_enable(level);
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       rt_hw_interrupt_enable
;;;437    
;;;438        /* change stat */
;;;439        timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
00001c  7a60              LDRB     r0,[r4,#9]
00001e  0840              LSRS     r0,r0,#1
000020  0040              LSLS     r0,r0,#1
000022  7260              STRB     r0,[r4,#9]
;;;440    
;;;441        return RT_EOK;
000024  2000              MOVS     r0,#0
;;;442    }
000026  bd70              POP      {r4-r6,pc}
                  |L18.40|
000028  2000              MOVS     r0,#0                 ;426
00002a  43c0              MVNS     r0,r0                 ;426
00002c  bd70              POP      {r4-r6,pc}
;;;443    RTM_EXPORT(rt_timer_stop);
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  timer_thread
                          %        128
                  timer_thread_stack
                          %        512

                          AREA ||.data||, DATA, ALIGN=2

                  random_nr
                          DCD      0x00000000
                  rt_timer_list
                          %        8
                  rt_soft_timer_list
                          %        8
