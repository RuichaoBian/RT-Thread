; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\timer_1.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\timer_1.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I.\Libraries\Device\Nuvoton -I..\..\components\finsh -I.\Libraries\CMSIS\Include -I.\Libraries\StdDriver\inc -I..\..\include -I.\APP -I.\Drivers -I..\..\components\drivers\include -I..\nuvoton_nuc240 -I.\Libraries\Device\Nuvoton\NUC230_240\Include -I..\..\include -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=521 --omf_browse=.\objects\timer_1.crf ..\..\src\timer.c]
                          THUMB

                          AREA ||i._rt_timer_init||, CODE, READONLY, ALIGN=1

                  _rt_timer_init PROC
;;;81     
;;;82     static void _rt_timer_init(rt_timer_t timer,
000000  b510              PUSH     {r4,lr}
;;;83                                void (*timeout)(void *parameter),
;;;84                                void      *parameter,
;;;85                                rt_tick_t  time,
;;;86                                rt_uint8_t flag)
;;;87     {
;;;88         int i;
;;;89     
;;;90         /* set flag */
;;;91         timer->parent.flag  = flag;
;;;92     
;;;93         /* set deactivated */
;;;94         timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
000002  9c02              LDR      r4,[sp,#8]
000004  0864              LSRS     r4,r4,#1
000006  0064              LSLS     r4,r4,#1
000008  7244              STRB     r4,[r0,#9]
;;;95     
;;;96         timer->timeout_func = timeout;
;;;97         timer->parameter    = parameter;
;;;98     
;;;99         timer->timeout_tick = 0;
00000a  6202              STR      r2,[r0,#0x20]
00000c  61c1              STR      r1,[r0,#0x1c]
00000e  2100              MOVS     r1,#0
;;;100        timer->init_tick    = time;
000010  6243              STR      r3,[r0,#0x24]
000012  6281              STR      r1,[r0,#0x28]
                  |L1.20|
;;;101    
;;;102        /* initialize timer list */
;;;103        for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
;;;104        {
;;;105            rt_list_init(&(timer->row[i]));
000014  00ca              LSLS     r2,r1,#3
000016  1812              ADDS     r2,r2,r0
000018  3214              ADDS     r2,r2,#0x14
00001a  6052              STR      r2,[r2,#4]
00001c  1c49              ADDS     r1,r1,#1
00001e  6012              STR      r2,[r2,#0]
000020  2901              CMP      r1,#1                 ;103
000022  dbf7              BLT      |L1.20|
;;;106        }
;;;107    }
000024  bd10              POP      {r4,pc}
;;;108    
                          ENDP


                          AREA ||i._rt_timer_remove||, CODE, READONLY, ALIGN=1

                  _rt_timer_remove PROC
;;;122    
;;;123    rt_inline void _rt_timer_remove(rt_timer_t timer)
000000  b510              PUSH     {r4,lr}
;;;124    {
;;;125        int i;
;;;126    
;;;127        for (i = 0; i < RT_TIMER_SKIP_LIST_LEVEL; i++)
000002  2200              MOVS     r2,#0
                  |L2.4|
;;;128        {
;;;129            rt_list_remove(&timer->row[i]);
000004  00d1              LSLS     r1,r2,#3
000006  1809              ADDS     r1,r1,r0
000008  3114              ADDS     r1,r1,#0x14
00000a  c918              LDM      r1!,{r3,r4}
00000c  3908              SUBS     r1,r1,#8
00000e  605c              STR      r4,[r3,#4]
000010  c918              LDM      r1!,{r3,r4}
000012  3908              SUBS     r1,r1,#8
000014  6023              STR      r3,[r4,#0]
000016  6049              STR      r1,[r1,#4]
000018  1c52              ADDS     r2,r2,#1
00001a  6009              STR      r1,[r1,#0]
00001c  2a01              CMP      r2,#1                 ;127
00001e  dbf1              BLT      |L2.4|
;;;130        }
;;;131    }
000020  bd10              POP      {r4,pc}
;;;132    
                          ENDP


                          AREA ||i.rt_list_insert_after||, CODE, READONLY, ALIGN=1

                  rt_list_insert_after PROC
;;;61      */
;;;62     rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
000000  6802              LDR      r2,[r0,#0]
;;;63     {
;;;64         l->next->prev = n;
;;;65         n->next = l->next;
000002  6051              STR      r1,[r2,#4]
000004  6802              LDR      r2,[r0,#0]
;;;66     
;;;67         l->next = n;
000006  600a              STR      r2,[r1,#0]
;;;68         n->prev = l;
000008  6001              STR      r1,[r0,#0]
00000a  6048              STR      r0,[r1,#4]
;;;69     }
00000c  4770              BX       lr
;;;70     
                          ENDP


                          AREA ||i.rt_list_isempty||, CODE, READONLY, ALIGN=1

                  rt_list_isempty PROC
;;;101     */
;;;102    rt_inline int rt_list_isempty(const rt_list_t *l)
000000  6801              LDR      r1,[r0,#0]
;;;103    {
;;;104        return l->next == l;
000002  4281              CMP      r1,r0
000004  d101              BNE      |L4.10|
000006  2001              MOVS     r0,#1
;;;105    }
000008  4770              BX       lr
                  |L4.10|
00000a  2000              MOVS     r0,#0                 ;104
00000c  4770              BX       lr
;;;106    
                          ENDP


                          AREA ||i.rt_system_timer_init||, CODE, READONLY, ALIGN=2

                  rt_system_timer_init PROC
;;;670     */
;;;671    void rt_system_timer_init(void)
000000  4a04              LDR      r2,|L5.20|
;;;672    {
;;;673        int i;
;;;674    
;;;675        for (i = 0; i < sizeof(rt_timer_list)/sizeof(rt_timer_list[0]); i++)
000002  2000              MOVS     r0,#0
                  |L5.4|
;;;676        {
;;;677            rt_list_init(rt_timer_list+i);
000004  00c1              LSLS     r1,r0,#3
000006  1889              ADDS     r1,r1,r2
000008  6049              STR      r1,[r1,#4]
00000a  6009              STR      r1,[r1,#0]
00000c  1c40              ADDS     r0,r0,#1
00000e  d0f9              BEQ      |L5.4|
;;;678        }
;;;679    }
000010  4770              BX       lr
;;;680    
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      ||.data||+0x4

                          AREA ||i.rt_system_timer_thread_init||, CODE, READONLY, ALIGN=1

                  rt_system_timer_thread_init PROC
;;;685     */
;;;686    void rt_system_timer_thread_init(void)
000000  4770              BX       lr
;;;687    {
;;;688    #ifdef RT_USING_TIMER_SOFT
;;;689        int i;
;;;690    
;;;691        for (i = 0;
;;;692             i < sizeof(rt_soft_timer_list)/sizeof(rt_soft_timer_list[0]);
;;;693             i++)
;;;694        {
;;;695            rt_list_init(rt_soft_timer_list+i);
;;;696        }
;;;697    
;;;698        /* start software timer thread */
;;;699        rt_thread_init(&timer_thread,
;;;700                       "timer",
;;;701                       rt_thread_timer_entry,
;;;702                       RT_NULL,
;;;703                       &timer_thread_stack[0],
;;;704                       sizeof(timer_thread_stack),
;;;705                       RT_TIMER_THREAD_PRIO,
;;;706                       10);
;;;707    
;;;708        /* startup */
;;;709        rt_thread_startup(&timer_thread);
;;;710    #endif
;;;711    }
;;;712    
                          ENDP


                          AREA ||i.rt_timer_check||, CODE, READONLY, ALIGN=2

                  rt_timer_check PROC
;;;487     */
;;;488    void rt_timer_check(void)
000000  b570              PUSH     {r4-r6,lr}
;;;489    {
;;;490        struct rt_timer *t;
;;;491        rt_tick_t current_tick;
;;;492        register rt_base_t level;
;;;493    
;;;494        RT_DEBUG_LOG(RT_DEBUG_TIMER, ("timer check enter\n"));
;;;495    
;;;496        current_tick = rt_tick_get();
000002  f7fffffe          BL       rt_tick_get
000006  4605              MOV      r5,r0
;;;497    
;;;498        /* disable interrupt */
;;;499        level = rt_hw_interrupt_disable();
000008  f7fffffe          BL       rt_hw_interrupt_disable
00000c  4606              MOV      r6,r0
;;;500    
;;;501        while (!rt_list_isempty(&rt_timer_list[RT_TIMER_SKIP_LIST_LEVEL-1]))
00000e  e01f              B        |L7.80|
                  |L7.16|
;;;502        {
;;;503            t = rt_list_entry(rt_timer_list[RT_TIMER_SKIP_LIST_LEVEL - 1].next,
000010  4814              LDR      r0,|L7.100|
;;;504                              struct rt_timer, row[RT_TIMER_SKIP_LIST_LEVEL - 1]);
;;;505    
;;;506            /*
;;;507             * It supposes that the new tick shall less than the half duration of
;;;508             * tick max.
;;;509             */
;;;510            if ((current_tick - t->timeout_tick) < RT_TICK_MAX/2)
000012  4915              LDR      r1,|L7.104|
000014  6804              LDR      r4,[r0,#0]  ; rt_timer_list
000016  6960              LDR      r0,[r4,#0x14]
000018  3c14              SUBS     r4,r4,#0x14
00001a  1a28              SUBS     r0,r5,r0
00001c  4288              CMP      r0,r1
00001e  d21c              BCS      |L7.90|
;;;511            {
;;;512                RT_OBJECT_HOOK_CALL(rt_timer_timeout_hook, (t));
;;;513    
;;;514                /* remove timer from timer list firstly */
;;;515                _rt_timer_remove(t);
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       _rt_timer_remove
;;;516    
;;;517                /* call timeout function */
;;;518                t->timeout_func(t->parameter);
000026  69e1              LDR      r1,[r4,#0x1c]
000028  6a20              LDR      r0,[r4,#0x20]
00002a  4788              BLX      r1
;;;519    
;;;520                /* re-get tick */
;;;521                current_tick = rt_tick_get();
00002c  f7fffffe          BL       rt_tick_get
000030  4605              MOV      r5,r0
;;;522    
;;;523                RT_DEBUG_LOG(RT_DEBUG_TIMER, ("current tick: %d\n", current_tick));
;;;524    
;;;525                if ((t->parent.flag & RT_TIMER_FLAG_PERIODIC) &&
000032  7a60              LDRB     r0,[r4,#9]
000034  0781              LSLS     r1,r0,#30
000036  d508              BPL      |L7.74|
;;;526                    (t->parent.flag & RT_TIMER_FLAG_ACTIVATED))
000038  07c1              LSLS     r1,r0,#31
00003a  d006              BEQ      |L7.74|
;;;527                {
;;;528                    /* start it */
;;;529                    t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
00003c  0840              LSRS     r0,r0,#1
00003e  0040              LSLS     r0,r0,#1
000040  7260              STRB     r0,[r4,#9]
;;;530                    rt_timer_start(t);
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       rt_timer_start
000048  e002              B        |L7.80|
                  |L7.74|
;;;531                }
;;;532                else
;;;533                {
;;;534                    /* stop timer */
;;;535                    t->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
00004a  0840              LSRS     r0,r0,#1
00004c  0040              LSLS     r0,r0,#1
00004e  7260              STRB     r0,[r4,#9]
                  |L7.80|
000050  4804              LDR      r0,|L7.100|
000052  f7fffffe          BL       rt_list_isempty
000056  2800              CMP      r0,#0                 ;501
000058  d0da              BEQ      |L7.16|
                  |L7.90|
;;;536                }
;;;537            }
;;;538            else
;;;539                break;
;;;540        }
;;;541    
;;;542        /* enable interrupt */
;;;543        rt_hw_interrupt_enable(level);
00005a  4630              MOV      r0,r6
00005c  f7fffffe          BL       rt_hw_interrupt_enable
;;;544    
;;;545        RT_DEBUG_LOG(RT_DEBUG_TIMER, ("timer check leave\n"));
;;;546    }
000060  bd70              POP      {r4-r6,pc}
;;;547    
                          ENDP

000062  0000              DCW      0x0000
                  |L7.100|
                          DCD      ||.data||+0x4
                  |L7.104|
                          DCD      0x7fffffff

                          AREA ||i.rt_timer_control||, CODE, READONLY, ALIGN=1

                  rt_timer_control PROC
;;;453     */
;;;454    rt_err_t rt_timer_control(rt_timer_t timer, rt_uint8_t cmd, void *arg)
000000  2900              CMP      r1,#0
;;;455    {
000002  d009              BEQ      |L8.24|
;;;456        /* timer check */
;;;457        RT_ASSERT(timer != RT_NULL);
;;;458    
;;;459        switch (cmd)
000004  2901              CMP      r1,#1
000006  d004              BEQ      |L8.18|
000008  2902              CMP      r1,#2
00000a  d008              BEQ      |L8.30|
00000c  2903              CMP      r1,#3
00000e  d10e              BNE      |L8.46|
000010  e009              B        |L8.38|
                  |L8.18|
;;;460        {
;;;461        case RT_TIMER_CTRL_GET_TIME:
;;;462            *(rt_tick_t *)arg = timer->init_tick;
000012  6a40              LDR      r0,[r0,#0x24]
;;;463            break;
000014  6010              STR      r0,[r2,#0]
000016  e00a              B        |L8.46|
                  |L8.24|
;;;464    
;;;465        case RT_TIMER_CTRL_SET_TIME:
;;;466            timer->init_tick = *(rt_tick_t *)arg;
000018  6811              LDR      r1,[r2,#0]
;;;467            break;
00001a  6241              STR      r1,[r0,#0x24]
00001c  e007              B        |L8.46|
                  |L8.30|
;;;468    
;;;469        case RT_TIMER_CTRL_SET_ONESHOT:
;;;470            timer->parent.flag &= ~RT_TIMER_FLAG_PERIODIC;
00001e  7a41              LDRB     r1,[r0,#9]
000020  22fd              MOVS     r2,#0xfd
000022  4011              ANDS     r1,r1,r2
;;;471            break;
000024  e002              B        |L8.44|
                  |L8.38|
;;;472    
;;;473        case RT_TIMER_CTRL_SET_PERIODIC:
;;;474            timer->parent.flag |= RT_TIMER_FLAG_PERIODIC;
000026  7a41              LDRB     r1,[r0,#9]
000028  2202              MOVS     r2,#2
00002a  4311              ORRS     r1,r1,r2
                  |L8.44|
00002c  7241              STRB     r1,[r0,#9]            ;470
                  |L8.46|
;;;475            break;
;;;476        }
;;;477    
;;;478        return RT_EOK;
00002e  2000              MOVS     r0,#0
;;;479    }
000030  4770              BX       lr
;;;480    RTM_EXPORT(rt_timer_control);
                          ENDP


                          AREA ||i.rt_timer_create||, CODE, READONLY, ALIGN=1

                  rt_timer_create PROC
;;;236     */
;;;237    rt_timer_t rt_timer_create(const char *name,
000000  b5ff              PUSH     {r0-r7,lr}
;;;238                               void (*timeout)(void *parameter),
;;;239                               void       *parameter,
;;;240                               rt_tick_t   time,
;;;241                               rt_uint8_t  flag)
;;;242    {
000002  b081              SUB      sp,sp,#4
;;;243        struct rt_timer *timer;
;;;244    
;;;245        /* allocate a object */
;;;246        timer = (struct rt_timer *)rt_object_allocate(RT_Object_Class_Timer, name);
000004  4601              MOV      r1,r0
000006  461e              MOV      r6,r3                 ;242
000008  4617              MOV      r7,r2                 ;242
00000a  2008              MOVS     r0,#8
00000c  9d0a              LDR      r5,[sp,#0x28]
00000e  f7fffffe          BL       rt_object_allocate
000012  0004              MOVS     r4,r0
;;;247        if (timer == RT_NULL)
000014  d008              BEQ      |L9.40|
;;;248        {
;;;249            return RT_NULL;
;;;250        }
;;;251    
;;;252        _rt_timer_init(timer, timeout, parameter, time, flag);
000016  4633              MOV      r3,r6
000018  463a              MOV      r2,r7
00001a  9500              STR      r5,[sp,#0]
00001c  9902              LDR      r1,[sp,#8]
00001e  f7fffffe          BL       _rt_timer_init
;;;253    
;;;254        return timer;
000022  4620              MOV      r0,r4
                  |L9.36|
;;;255    }
000024  b005              ADD      sp,sp,#0x14
000026  bdf0              POP      {r4-r7,pc}
                  |L9.40|
000028  2000              MOVS     r0,#0                 ;249
00002a  e7fb              B        |L9.36|
;;;256    RTM_EXPORT(rt_timer_create);
                          ENDP


                          AREA ||i.rt_timer_delete||, CODE, READONLY, ALIGN=1

                  rt_timer_delete PROC
;;;264     */
;;;265    rt_err_t rt_timer_delete(rt_timer_t timer)
000000  b570              PUSH     {r4-r6,lr}
;;;266    {
000002  4605              MOV      r5,r0
;;;267        register rt_base_t level;
;;;268    
;;;269        /* timer check */
;;;270        RT_ASSERT(timer != RT_NULL);
;;;271    
;;;272        /* disable interrupt */
;;;273        level = rt_hw_interrupt_disable();
000004  f7fffffe          BL       rt_hw_interrupt_disable
000008  4604              MOV      r4,r0
;;;274    
;;;275        _rt_timer_remove(timer);
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       _rt_timer_remove
;;;276    
;;;277        /* enable interrupt */
;;;278        rt_hw_interrupt_enable(level);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       rt_hw_interrupt_enable
;;;279    
;;;280        rt_object_delete((rt_object_t)timer);
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       rt_object_delete
;;;281    
;;;282        return -RT_EOK;
00001c  2000              MOVS     r0,#0
;;;283    }
00001e  bd70              POP      {r4-r6,pc}
;;;284    RTM_EXPORT(rt_timer_delete);
                          ENDP


                          AREA ||i.rt_timer_detach||, CODE, READONLY, ALIGN=1

                  rt_timer_detach PROC
;;;203     */
;;;204    rt_err_t rt_timer_detach(rt_timer_t timer)
000000  b570              PUSH     {r4-r6,lr}
;;;205    {
000002  4605              MOV      r5,r0
;;;206        register rt_base_t level;
;;;207    
;;;208        /* timer check */
;;;209        RT_ASSERT(timer != RT_NULL);
;;;210    
;;;211        /* disable interrupt */
;;;212        level = rt_hw_interrupt_disable();
000004  f7fffffe          BL       rt_hw_interrupt_disable
000008  4604              MOV      r4,r0
;;;213    
;;;214        _rt_timer_remove(timer);
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       _rt_timer_remove
;;;215    
;;;216        /* enable interrupt */
;;;217        rt_hw_interrupt_enable(level);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       rt_hw_interrupt_enable
;;;218    
;;;219        rt_object_detach((rt_object_t)timer);
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       rt_object_detach
;;;220    
;;;221        return -RT_EOK;
00001c  2000              MOVS     r0,#0
;;;222    }
00001e  bd70              POP      {r4-r6,pc}
;;;223    RTM_EXPORT(rt_timer_detach);
                          ENDP


                          AREA ||i.rt_timer_init||, CODE, READONLY, ALIGN=1

                  rt_timer_init PROC
;;;179     */
;;;180    void rt_timer_init(rt_timer_t  timer,
000000  b5ff              PUSH     {r0-r7,lr}
;;;181                       const char *name,
;;;182                       void (*timeout)(void *parameter),
;;;183                       void       *parameter,
;;;184                       rt_tick_t   time,
;;;185                       rt_uint8_t  flag)
;;;186    {
000002  b081              SUB      sp,sp,#4
;;;187        /* timer check */
;;;188        RT_ASSERT(timer != RT_NULL);
;;;189    
;;;190        /* timer object initialization */
;;;191        rt_object_init((rt_object_t)timer, RT_Object_Class_Timer, name);
000004  460a              MOV      r2,r1
000006  461f              MOV      r7,r3                 ;186
000008  4606              MOV      r6,r0                 ;186
00000a  2108              MOVS     r1,#8
00000c  9d0b              LDR      r5,[sp,#0x2c]
00000e  9c0a              LDR      r4,[sp,#0x28]
000010  f7fffffe          BL       rt_object_init
;;;192    
;;;193        _rt_timer_init(timer, timeout, parameter, time, flag);
000014  4623              MOV      r3,r4
000016  463a              MOV      r2,r7
000018  9500              STR      r5,[sp,#0]
00001a  4630              MOV      r0,r6
00001c  9903              LDR      r1,[sp,#0xc]
00001e  f7fffffe          BL       _rt_timer_init
;;;194    }
000022  b005              ADD      sp,sp,#0x14
000024  bdf0              POP      {r4-r7,pc}
;;;195    RTM_EXPORT(rt_timer_init);
                          ENDP


                          AREA ||i.rt_timer_next_timeout_tick||, CODE, READONLY, ALIGN=2

                  rt_timer_next_timeout_tick PROC
;;;552     */
;;;553    rt_tick_t rt_timer_next_timeout_tick(void)
000000  b510              PUSH     {r4,lr}
;;;554    {
;;;555        return rt_timer_list_next_timeout(rt_timer_list);
000002  4c06              LDR      r4,|L13.28|
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       rt_list_isempty
00000a  2800              CMP      r0,#0
00000c  d002              BEQ      |L13.20|
00000e  2000              MOVS     r0,#0
000010  43c0              MVNS     r0,r0
;;;556    }
000012  bd10              POP      {r4,pc}
                  |L13.20|
000014  6820              LDR      r0,[r4,#0]
000016  6940              LDR      r0,[r0,#0x14]
000018  bd10              POP      {r4,pc}
;;;557    
                          ENDP

00001a  0000              DCW      0x0000
                  |L13.28|
                          DCD      ||.data||+0x4

                          AREA ||i.rt_timer_start||, CODE, READONLY, ALIGN=2

                  rt_timer_start PROC
;;;293     */
;;;294    rt_err_t rt_timer_start(rt_timer_t timer)
000000  b5fe              PUSH     {r1-r7,lr}
;;;295    {
000002  4604              MOV      r4,r0
;;;296        unsigned int row_lvl;
;;;297        rt_list_t *timer_list;
;;;298        register rt_base_t level;
;;;299        rt_list_t *row_head[RT_TIMER_SKIP_LIST_LEVEL];
;;;300        unsigned int tst_nr;
;;;301        static unsigned int random_nr;
;;;302    
;;;303        /* timer check */
;;;304        RT_ASSERT(timer != RT_NULL);
;;;305    
;;;306    	/* stop timer firstly */
;;;307    	level = rt_hw_interrupt_disable();
000004  f7fffffe          BL       rt_hw_interrupt_disable
000008  4605              MOV      r5,r0
;;;308    	/* remove timer from list */
;;;309        _rt_timer_remove(timer);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       _rt_timer_remove
;;;310        /* change status of timer */
;;;311        timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
000010  7a60              LDRB     r0,[r4,#9]
000012  0840              LSRS     r0,r0,#1
000014  0040              LSLS     r0,r0,#1
000016  7260              STRB     r0,[r4,#9]
;;;312        rt_hw_interrupt_enable(level);
000018  4628              MOV      r0,r5
00001a  f7fffffe          BL       rt_hw_interrupt_enable
;;;313    
;;;314        RT_OBJECT_HOOK_CALL(rt_object_take_hook, (&(timer->parent)));
;;;315    
;;;316        /*
;;;317         * get timeout tick,
;;;318         * the max timeout tick shall not great than RT_TICK_MAX/2
;;;319         */
;;;320        RT_ASSERT(timer->init_tick < RT_TICK_MAX / 2);
;;;321        timer->timeout_tick = rt_tick_get() + timer->init_tick;
00001e  f7fffffe          BL       rt_tick_get
000022  6a61              LDR      r1,[r4,#0x24]
000024  1840              ADDS     r0,r0,r1
;;;322    
;;;323        /* disable interrupt */
;;;324        level = rt_hw_interrupt_disable();
000026  62a0              STR      r0,[r4,#0x28]
000028  f7fffffe          BL       rt_hw_interrupt_disable
;;;325    
;;;326    #ifdef RT_USING_TIMER_SOFT
;;;327        if (timer->parent.flag & RT_TIMER_FLAG_SOFT_TIMER)
;;;328        {
;;;329            /* insert timer to soft timer list */
;;;330            timer_list = rt_soft_timer_list;
;;;331        }
;;;332        else
;;;333    #endif
;;;334        {
;;;335            /* insert timer to system timer list */
;;;336            timer_list = rt_timer_list;
00002c  9001              STR      r0,[sp,#4]
00002e  4819              LDR      r0,|L14.148|
;;;337        }
;;;338    
;;;339        row_head[0]  = &timer_list[0];
;;;340        for (row_lvl = 0; row_lvl < RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
000030  2200              MOVS     r2,#0
000032  4684              MOV      r12,r0                ;336
000034  466e              MOV      r6,sp                 ;299
000036  9000              STR      r0,[sp,#0]
000038  e00a              B        |L14.80|
                  |L14.58|
;;;341        {
;;;342            for (;row_head[row_lvl] != timer_list[row_lvl].prev;
;;;343                 row_head[row_lvl]  = row_head[row_lvl]->next)
;;;344            {
;;;345                struct rt_timer *t;
;;;346                rt_list_t *p = row_head[row_lvl]->next;
;;;347    
;;;348                /* fix up the entry pointer */
;;;349                t = rt_list_entry(p, struct rt_timer, row[row_lvl]);
00003a  6807              LDR      r7,[r0,#0]
;;;350    
;;;351                /* If we have two timers that timeout at the same time, it's
;;;352                 * preferred that the timer inserted early get called early.
;;;353                 * So insert the new timer to the end the the some-timeout timer
;;;354                 * list.
;;;355                 */
;;;356                if ((t->timeout_tick - timer->timeout_tick) == 0)
00003c  6aa5              LDR      r5,[r4,#0x28]
00003e  1afb              SUBS     r3,r7,r3              ;349
000040  695b              LDR      r3,[r3,#0x14]
000042  42ab              CMP      r3,r5
000044  d003              BEQ      |L14.78|
;;;357                {
;;;358                    continue;
;;;359                }
;;;360                else if ((t->timeout_tick - timer->timeout_tick) < RT_TICK_MAX / 2)
000046  1b5b              SUBS     r3,r3,r5
000048  4d13              LDR      r5,|L14.152|
00004a  42ab              CMP      r3,r5
00004c  d308              BCC      |L14.96|
                  |L14.78|
00004e  5077              STR      r7,[r6,r1]            ;343
                  |L14.80|
000050  00d3              LSLS     r3,r2,#3              ;342
000052  4665              MOV      r5,r12                ;342
000054  0091              LSLS     r1,r2,#2              ;342
000056  195d              ADDS     r5,r3,r5              ;342
000058  5870              LDR      r0,[r6,r1]            ;342
00005a  686d              LDR      r5,[r5,#4]            ;342
00005c  42a8              CMP      r0,r5                 ;342
00005e  d1ec              BNE      |L14.58|
                  |L14.96|
;;;361                {
;;;362                    break;
;;;363                }
;;;364            }
;;;365            if (row_lvl != RT_TIMER_SKIP_LIST_LEVEL - 1)
000060  2a00              CMP      r2,#0
000062  d002              BEQ      |L14.106|
;;;366                row_head[row_lvl+1] = row_head[row_lvl]+1;
000064  1989              ADDS     r1,r1,r6
000066  3008              ADDS     r0,r0,#8
000068  6048              STR      r0,[r1,#4]
                  |L14.106|
00006a  1c52              ADDS     r2,r2,#1
00006c  d0f0              BEQ      |L14.80|
;;;367        }
;;;368    
;;;369        /* Interestingly, this super simple timer insert counter works very very
;;;370         * well on distributing the list height uniformly. By means of "very very
;;;371         * well", I mean it beats the randomness of timer->timeout_tick very easily
;;;372         * (actually, the timeout_tick is not random and easy to be attacked). */
;;;373        random_nr++;
00006e  4909              LDR      r1,|L14.148|
000070  1f09              SUBS     r1,r1,#4
000072  6808              LDR      r0,[r1,#0]  ; random_nr
000074  1c40              ADDS     r0,r0,#1
;;;374        tst_nr = random_nr;
;;;375    
;;;376        rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL-1],
000076  6008              STR      r0,[r1,#0]  ; random_nr
000078  4621              MOV      r1,r4
00007a  3114              ADDS     r1,r1,#0x14
00007c  9800              LDR      r0,[sp,#0]
00007e  f7fffffe          BL       rt_list_insert_after
;;;377                             &(timer->row[RT_TIMER_SKIP_LIST_LEVEL-1]));
;;;378        for (row_lvl = 2; row_lvl <= RT_TIMER_SKIP_LIST_LEVEL; row_lvl++)
;;;379        {
;;;380            if (!(tst_nr & RT_TIMER_SKIP_LIST_MASK))
;;;381                rt_list_insert_after(row_head[RT_TIMER_SKIP_LIST_LEVEL - row_lvl],
;;;382                                     &(timer->row[RT_TIMER_SKIP_LIST_LEVEL - row_lvl]));
;;;383            else
;;;384                break;
;;;385            /* Shift over the bits we have tested. Works well with 1 bit and 2
;;;386             * bits. */
;;;387            tst_nr >>= (RT_TIMER_SKIP_LIST_MASK+1)>>1;
;;;388        }
;;;389    
;;;390        timer->parent.flag |= RT_TIMER_FLAG_ACTIVATED;
000082  7a60              LDRB     r0,[r4,#9]
000084  2101              MOVS     r1,#1
000086  4308              ORRS     r0,r0,r1
000088  7260              STRB     r0,[r4,#9]
;;;391    
;;;392        /* enable interrupt */
;;;393        rt_hw_interrupt_enable(level);
00008a  9801              LDR      r0,[sp,#4]
00008c  f7fffffe          BL       rt_hw_interrupt_enable
;;;394    
;;;395    #ifdef RT_USING_TIMER_SOFT
;;;396        if (timer->parent.flag & RT_TIMER_FLAG_SOFT_TIMER)
;;;397        {
;;;398            /* check whether timer thread is ready */
;;;399            if (timer_thread.stat != RT_THREAD_READY)
;;;400            {
;;;401                /* resume timer thread to check soft timer */
;;;402                rt_thread_resume(&timer_thread);
;;;403                rt_schedule();
;;;404            }
;;;405        }
;;;406    #endif
;;;407    
;;;408        return -RT_EOK;
000090  2000              MOVS     r0,#0
;;;409    }
000092  bdfe              POP      {r1-r7,pc}
;;;410    RTM_EXPORT(rt_timer_start);
                          ENDP

                  |L14.148|
                          DCD      ||.data||+0x4
                  |L14.152|
                          DCD      0x7fffffff

                          AREA ||i.rt_timer_stop||, CODE, READONLY, ALIGN=1

                  rt_timer_stop PROC
;;;418     */
;;;419    rt_err_t rt_timer_stop(rt_timer_t timer)
000000  b570              PUSH     {r4-r6,lr}
;;;420    {
000002  4604              MOV      r4,r0
;;;421        register rt_base_t level;
;;;422    
;;;423        /* timer check */
;;;424        RT_ASSERT(timer != RT_NULL);
;;;425        if (!(timer->parent.flag & RT_TIMER_FLAG_ACTIVATED))
000004  7a40              LDRB     r0,[r0,#9]
000006  07c0              LSLS     r0,r0,#31
000008  d00e              BEQ      |L15.40|
;;;426            return -RT_ERROR;
;;;427    
;;;428        RT_OBJECT_HOOK_CALL(rt_object_put_hook, (&(timer->parent)));
;;;429    
;;;430        /* disable interrupt */
;;;431        level = rt_hw_interrupt_disable();
00000a  f7fffffe          BL       rt_hw_interrupt_disable
00000e  4605              MOV      r5,r0
;;;432    
;;;433        _rt_timer_remove(timer);
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       _rt_timer_remove
;;;434    
;;;435        /* enable interrupt */
;;;436        rt_hw_interrupt_enable(level);
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       rt_hw_interrupt_enable
;;;437    
;;;438        /* change stat */
;;;439        timer->parent.flag &= ~RT_TIMER_FLAG_ACTIVATED;
00001c  7a60              LDRB     r0,[r4,#9]
00001e  0840              LSRS     r0,r0,#1
000020  0040              LSLS     r0,r0,#1
000022  7260              STRB     r0,[r4,#9]
;;;440    
;;;441        return RT_EOK;
000024  2000              MOVS     r0,#0
;;;442    }
000026  bd70              POP      {r4-r6,pc}
                  |L15.40|
000028  2000              MOVS     r0,#0                 ;426
00002a  43c0              MVNS     r0,r0                 ;426
00002c  bd70              POP      {r4-r6,pc}
;;;443    RTM_EXPORT(rt_timer_stop);
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  random_nr
                          DCD      0x00000000
                  rt_timer_list
                          %        8
