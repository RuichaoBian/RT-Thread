; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\object.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\object.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I.\Libraries\Device\Nuvoton -I..\..\components\finsh -I.\Libraries\CMSIS\Include -I.\Libraries\StdDriver\inc -I..\..\include -I.\APP -I.\Drivers -I..\..\components\drivers\include -I..\..\components\drivers\include\drivers -I..\nuvoton_nuc240 -I.\Libraries\Device\Nuvoton\NUC230_240\Include -I..\..\include -I..\..\components\drivers\usb\usbdevice\class -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=521 --omf_browse=.\objects\object.crf ..\..\src\object.c]
                          THUMB

                          AREA ||i.rt_list_insert_after||, CODE, READONLY, ALIGN=1

                  rt_list_insert_after PROC
;;;61      */
;;;62     rt_inline void rt_list_insert_after(rt_list_t *l, rt_list_t *n)
000000  6802              LDR      r2,[r0,#0]
;;;63     {
;;;64         l->next->prev = n;
;;;65         n->next = l->next;
000002  6051              STR      r1,[r2,#4]
000004  6802              LDR      r2,[r0,#0]
;;;66     
;;;67         l->next = n;
000006  600a              STR      r2,[r1,#0]
;;;68         n->prev = l;
000008  6001              STR      r1,[r0,#0]
00000a  6048              STR      r0,[r1,#4]
;;;69     }
00000c  4770              BX       lr
;;;70     
                          ENDP


                          AREA ||i.rt_list_remove||, CODE, READONLY, ALIGN=1

                  rt_list_remove PROC
;;;90      */
;;;91     rt_inline void rt_list_remove(rt_list_t *n)
000000  c806              LDM      r0!,{r1,r2}
;;;92     {
;;;93         n->next->prev = n->prev;
000002  3808              SUBS     r0,r0,#8
000004  604a              STR      r2,[r1,#4]
000006  c806              LDM      r0!,{r1,r2}
;;;94         n->prev->next = n->next;
000008  3808              SUBS     r0,r0,#8
;;;95     
;;;96         n->next = n->prev = n;
00000a  6011              STR      r1,[r2,#0]
00000c  6040              STR      r0,[r0,#4]
00000e  6000              STR      r0,[r0,#0]
;;;97     }
000010  4770              BX       lr
;;;98     
                          ENDP


                          AREA ||i.rt_object_allocate||, CODE, READONLY, ALIGN=2

                  rt_object_allocate PROC
;;;273     */
;;;274    rt_object_t rt_object_allocate(enum rt_object_class_type type, const char *name)
000000  b5f8              PUSH     {r3-r7,lr}
;;;275    {
000002  460f              MOV      r7,r1
000004  4606              MOV      r6,r0
;;;276        struct rt_object *object;
;;;277        register rt_base_t temp;
;;;278        struct rt_object_information *information;
;;;279    
;;;280        RT_DEBUG_NOT_IN_INTERRUPT;
;;;281    
;;;282    #ifdef RT_USING_MODULE
;;;283        /*
;;;284         * get module object information,
;;;285         * module object should be managed by kernel object container
;;;286         */
;;;287        information = (rt_module_self() != RT_NULL && (type != RT_Object_Class_Module)) ?
;;;288                      &rt_module_self()->module_object[type] : &rt_object_container[type];
;;;289    #else
;;;290        /* get object information */
;;;291        information = &rt_object_container[type];
000006  490f              LDR      r1,|L3.68|
000008  0100              LSLS     r0,r0,#4
00000a  1845              ADDS     r5,r0,r1
;;;292    #endif
;;;293    
;;;294        object = (struct rt_object *)RT_KERNEL_MALLOC(information->object_size);
00000c  68e8              LDR      r0,[r5,#0xc]
00000e  f7fffffe          BL       rt_malloc
000012  0004              MOVS     r4,r0
;;;295        if (object == RT_NULL)
000014  d014              BEQ      |L3.64|
;;;296        {
;;;297            /* no memory can be allocated */
;;;298            return RT_NULL;
;;;299        }
;;;300    
;;;301        /* initialize object's parameters */
;;;302    
;;;303        /* set object type */
;;;304        object->type = type;
000016  7226              STRB     r6,[r4,#8]
;;;305    
;;;306        /* set object flag */
;;;307        object->flag = 0;
000018  2000              MOVS     r0,#0
00001a  7260              STRB     r0,[r4,#9]
;;;308    
;;;309    #ifdef RT_USING_MODULE
;;;310        if (rt_module_self() != RT_NULL)
;;;311        {
;;;312            object->flag |= RT_OBJECT_FLAG_MODULE;
;;;313        }
;;;314        object->module_id = (void *)rt_module_self();
;;;315    #endif
;;;316    
;;;317        /* copy name */
;;;318        rt_strncpy(object->name, name, RT_NAME_MAX);
00001c  2208              MOVS     r2,#8
00001e  4639              MOV      r1,r7
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       rt_strncpy
;;;319    
;;;320        RT_OBJECT_HOOK_CALL(rt_object_attach_hook, (object));
;;;321    
;;;322        /* lock interrupt */
;;;323        temp = rt_hw_interrupt_disable();
000026  f7fffffe          BL       rt_hw_interrupt_disable
00002a  4606              MOV      r6,r0
;;;324    
;;;325        /* insert object into information object list */
;;;326        rt_list_insert_after(&(information->object_list), &(object->list));
00002c  4621              MOV      r1,r4
00002e  310c              ADDS     r1,r1,#0xc
000030  1d28              ADDS     r0,r5,#4
000032  f7fffffe          BL       rt_list_insert_after
;;;327    
;;;328        /* unlock interrupt */
;;;329        rt_hw_interrupt_enable(temp);
000036  4630              MOV      r0,r6
000038  f7fffffe          BL       rt_hw_interrupt_enable
;;;330    
;;;331        /* return object */
;;;332        return object;
00003c  4620              MOV      r0,r4
;;;333    }
00003e  bdf8              POP      {r3-r7,pc}
                  |L3.64|
000040  2000              MOVS     r0,#0                 ;298
000042  bdf8              POP      {r3-r7,pc}
;;;334    
                          ENDP

                  |L3.68|
                          DCD      ||.data||

                          AREA ||i.rt_object_delete||, CODE, READONLY, ALIGN=1

                  rt_object_delete PROC
;;;339     */
;;;340    void rt_object_delete(rt_object_t object)
000000  b570              PUSH     {r4-r6,lr}
;;;341    {
000002  4604              MOV      r4,r0
;;;342        register rt_base_t temp;
;;;343    
;;;344        /* object check */
;;;345        RT_ASSERT(object != RT_NULL);
;;;346        RT_ASSERT(!(object->type & RT_Object_Class_Static));
;;;347    
;;;348        RT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));
;;;349    
;;;350        /* lock interrupt */
;;;351        temp = rt_hw_interrupt_disable();
000004  f7fffffe          BL       rt_hw_interrupt_disable
000008  4605              MOV      r5,r0
;;;352    
;;;353        /* remove from old list */
;;;354        rt_list_remove(&(object->list));
00000a  4620              MOV      r0,r4
00000c  300c              ADDS     r0,r0,#0xc
00000e  f7fffffe          BL       rt_list_remove
;;;355    
;;;356        /* unlock interrupt */
;;;357        rt_hw_interrupt_enable(temp);
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       rt_hw_interrupt_enable
;;;358    
;;;359    #if defined(RT_USING_MODULE) && defined(RT_USING_SLAB)
;;;360        if (object->flag & RT_OBJECT_FLAG_MODULE)
;;;361            rt_module_free((rt_module_t)object->module_id, object);
;;;362        else
;;;363    #endif
;;;364    
;;;365        /* free the memory of object */
;;;366        RT_KERNEL_FREE(object);
000018  4620              MOV      r0,r4
00001a  f7fffffe          BL       rt_free
;;;367    }
00001e  bd70              POP      {r4-r6,pc}
;;;368    #endif
                          ENDP


                          AREA ||i.rt_object_detach||, CODE, READONLY, ALIGN=1

                  rt_object_detach PROC
;;;245     */
;;;246    void rt_object_detach(rt_object_t object)
000000  b570              PUSH     {r4-r6,lr}
;;;247    {
000002  4605              MOV      r5,r0
;;;248        register rt_base_t temp;
;;;249    
;;;250        /* object check */
;;;251        RT_ASSERT(object != RT_NULL);
;;;252    
;;;253        RT_OBJECT_HOOK_CALL(rt_object_detach_hook, (object));
;;;254    
;;;255        /* lock interrupt */
;;;256        temp = rt_hw_interrupt_disable();
000004  f7fffffe          BL       rt_hw_interrupt_disable
000008  4604              MOV      r4,r0
;;;257    
;;;258        /* remove from old list */
;;;259        rt_list_remove(&(object->list));
00000a  4628              MOV      r0,r5
00000c  300c              ADDS     r0,r0,#0xc
00000e  f7fffffe          BL       rt_list_remove
;;;260    
;;;261        /* unlock interrupt */
;;;262        rt_hw_interrupt_enable(temp);
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       rt_hw_interrupt_enable
;;;263    }
000018  bd70              POP      {r4-r6,pc}
;;;264    
                          ENDP


                          AREA ||i.rt_object_find||, CODE, READONLY, ALIGN=2

                  rt_object_find PROC
;;;401     */
;;;402    rt_object_t rt_object_find(const char *name, rt_uint8_t type)
000000  b5f8              PUSH     {r3-r7,lr}
;;;403    {
000002  460c              MOV      r4,r1
000004  0007              MOVS     r7,r0
000006  d001              BEQ      |L6.12|
;;;404        struct rt_object *object = RT_NULL;
;;;405        struct rt_list_node *node = RT_NULL;
;;;406        struct rt_object_information *information = RT_NULL;
;;;407    
;;;408        /* parameter check */
;;;409        if ((name == RT_NULL) || (type > RT_Object_Class_Unknown))
000008  2c09              CMP      r4,#9
00000a  d901              BLS      |L6.16|
                  |L6.12|
;;;410            return RT_NULL;
00000c  2000              MOVS     r0,#0
;;;411    
;;;412        /* which is invoke in interrupt status */
;;;413        RT_DEBUG_NOT_IN_INTERRUPT;
;;;414    
;;;415    #ifdef RT_USING_MODULE
;;;416        /* check whether to find a object inside a module. */
;;;417        {
;;;418            const char *name_ptr;
;;;419            int module_name_length;
;;;420    
;;;421            name_ptr = name;
;;;422            while ((*name_ptr != '\0') && (*name_ptr != '/'))
;;;423                name_ptr ++;
;;;424    
;;;425            if (*name_ptr == '/')
;;;426            {
;;;427                struct rt_module* module = RT_NULL;
;;;428    
;;;429                /* get the name length of module */
;;;430                module_name_length = name_ptr - name;
;;;431    
;;;432                /* enter critical */
;;;433                rt_enter_critical();
;;;434    
;;;435                /* find module */
;;;436                information = &rt_object_container[RT_Object_Class_Module];
;;;437                for (node = information->object_list.next;
;;;438                    node != &(information->object_list);
;;;439                    node  = node->next)
;;;440                {
;;;441                    object = rt_list_entry(node, struct rt_object, list);
;;;442                    if ((rt_strncmp(object->name, name, module_name_length) == 0) &&
;;;443                        (module_name_length == RT_NAME_MAX || object->name[module_name_length] == '\0'))
;;;444                    {
;;;445                        /* get module */
;;;446                        module = (struct rt_module*)object;
;;;447                        break;
;;;448                    }
;;;449                }
;;;450                rt_exit_critical();
;;;451    
;;;452                /* there is no this module inside the system */
;;;453                if (module == RT_NULL) return RT_NULL;
;;;454    
;;;455                /* get the object pool of module */
;;;456                information = &(module->module_object[type]);
;;;457    
;;;458                /* get object name */
;;;459                while ((*name_ptr == '/') && (*name_ptr != '\0')) name_ptr ++;
;;;460                if (*name_ptr == '\0')
;;;461                {
;;;462                    if (type == RT_Object_Class_Module) return object;
;;;463                    return RT_NULL;
;;;464                }
;;;465    
;;;466                /* point to the object name */
;;;467                name = name_ptr;
;;;468            }
;;;469        }
;;;470    #endif
;;;471    
;;;472        /* enter critical */
;;;473        rt_enter_critical();
;;;474    
;;;475        /* try to find object */
;;;476        if (information == RT_NULL) information = &rt_object_container[type];
;;;477        for (node  = information->object_list.next;
;;;478             node != &(information->object_list);
;;;479             node  = node->next)
;;;480        {
;;;481            object = rt_list_entry(node, struct rt_object, list);
;;;482            if (rt_strncmp(object->name, name, RT_NAME_MAX) == 0)
;;;483            {
;;;484                /* leave critical */
;;;485                rt_exit_critical();
;;;486    
;;;487                return object;
;;;488            }
;;;489        }
;;;490    
;;;491        /* leave critical */
;;;492        rt_exit_critical();
;;;493    
;;;494        return RT_NULL;
;;;495    }
00000e  bdf8              POP      {r3-r7,pc}
                  |L6.16|
000010  f7fffffe          BL       rt_enter_critical
000014  490c              LDR      r1,|L6.72|
000016  0120              LSLS     r0,r4,#4              ;476
000018  1846              ADDS     r6,r0,r1              ;476
00001a  6874              LDR      r4,[r6,#4]            ;477
00001c  1d36              ADDS     r6,r6,#4              ;477
00001e  e009              B        |L6.52|
                  |L6.32|
000020  4625              MOV      r5,r4                 ;481
000022  3d0c              SUBS     r5,r5,#0xc            ;481
000024  2208              MOVS     r2,#8                 ;482
000026  4639              MOV      r1,r7                 ;482
000028  4628              MOV      r0,r5                 ;482
00002a  f7fffffe          BL       rt_strncmp
00002e  2800              CMP      r0,#0                 ;482
000030  d005              BEQ      |L6.62|
000032  6824              LDR      r4,[r4,#0]            ;479
                  |L6.52|
000034  42b4              CMP      r4,r6                 ;478
000036  d1f3              BNE      |L6.32|
000038  f7fffffe          BL       rt_exit_critical
00003c  e7e6              B        |L6.12|
                  |L6.62|
00003e  f7fffffe          BL       rt_exit_critical
000042  4628              MOV      r0,r5                 ;487
000044  bdf8              POP      {r3-r7,pc}
;;;496    
                          ENDP

000046  0000              DCW      0x0000
                  |L6.72|
                          DCD      ||.data||

                          AREA ||i.rt_object_get_information||, CODE, READONLY, ALIGN=2

                  rt_object_get_information PROC
;;;189    struct rt_object_information *
;;;190    rt_object_get_information(enum rt_object_class_type type)
000000  4901              LDR      r1,|L7.8|
;;;191    {
;;;192        return &rt_object_container[type];
000002  0100              LSLS     r0,r0,#4
000004  1840              ADDS     r0,r0,r1
;;;193    }
000006  4770              BX       lr
;;;194    RTM_EXPORT(rt_object_get_information);
                          ENDP

                  |L7.8|
                          DCD      ||.data||

                          AREA ||i.rt_object_init||, CODE, READONLY, ALIGN=2

                  rt_object_init PROC
;;;203     */
;;;204    void rt_object_init(struct rt_object         *object,
000000  b570              PUSH     {r4-r6,lr}
;;;205                        enum rt_object_class_type type,
;;;206                        const char               *name)
;;;207    {
000002  4613              MOV      r3,r2
000004  4604              MOV      r4,r0
;;;208        register rt_base_t temp;
;;;209        struct rt_object_information *information;
;;;210    
;;;211    #ifdef RT_USING_MODULE
;;;212        /* get module object information */
;;;213        information = (rt_module_self() != RT_NULL) ?
;;;214            &rt_module_self()->module_object[type] : &rt_object_container[type];
;;;215    #else
;;;216        /* get object information */
;;;217        information = &rt_object_container[type];
000006  4a0b              LDR      r2,|L8.52|
000008  0108              LSLS     r0,r1,#4
00000a  1885              ADDS     r5,r0,r2
;;;218    #endif
;;;219    
;;;220        /* initialize object's parameters */
;;;221    
;;;222        /* set object type to static */
;;;223        object->type = type | RT_Object_Class_Static;
00000c  2080              MOVS     r0,#0x80
00000e  4301              ORRS     r1,r1,r0
000010  7221              STRB     r1,[r4,#8]
;;;224    
;;;225        /* copy name */
;;;226        rt_strncpy(object->name, name, RT_NAME_MAX);
000012  2208              MOVS     r2,#8
000014  4619              MOV      r1,r3
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       rt_strncpy
;;;227    
;;;228        RT_OBJECT_HOOK_CALL(rt_object_attach_hook, (object));
;;;229    
;;;230        /* lock interrupt */
;;;231        temp = rt_hw_interrupt_disable();
00001c  f7fffffe          BL       rt_hw_interrupt_disable
000020  4606              MOV      r6,r0
;;;232    
;;;233        /* insert object into information object list */
;;;234        rt_list_insert_after(&(information->object_list), &(object->list));
000022  4621              MOV      r1,r4
000024  310c              ADDS     r1,r1,#0xc
000026  1d28              ADDS     r0,r5,#4
000028  f7fffffe          BL       rt_list_insert_after
;;;235    
;;;236        /* unlock interrupt */
;;;237        rt_hw_interrupt_enable(temp);
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       rt_hw_interrupt_enable
;;;238    }
000032  bd70              POP      {r4-r6,pc}
;;;239    
                          ENDP

                  |L8.52|
                          DCD      ||.data||

                          AREA ||i.rt_object_is_systemobject||, CODE, READONLY, ALIGN=1

                  rt_object_is_systemobject PROC
;;;378     */
;;;379    rt_bool_t rt_object_is_systemobject(rt_object_t object)
000000  7a00              LDRB     r0,[r0,#8]
;;;380    {
;;;381        /* object check */
;;;382        RT_ASSERT(object != RT_NULL);
;;;383    
;;;384        if (object->type & RT_Object_Class_Static)
000002  0600              LSLS     r0,r0,#24
000004  d501              BPL      |L9.10|
;;;385            return RT_TRUE;
000006  2001              MOVS     r0,#1
;;;386    
;;;387        return RT_FALSE;
;;;388    }
000008  4770              BX       lr
                  |L9.10|
00000a  2000              MOVS     r0,#0                 ;387
00000c  4770              BX       lr
;;;389    
                          ENDP


                          AREA ||i.rt_system_object_init||, CODE, READONLY, ALIGN=1

                  rt_system_object_init PROC
;;;172     */
;;;173    void rt_system_object_init(void)
000000  4770              BX       lr
;;;174    {
;;;175    }
;;;176    
                          ENDP


                          AREA ||.data||, DATA, ALIGN=2

                  rt_object_container
000000  00000000          DCB      0x00,0x00,0x00,0x00
                          DCD      rt_object_container+0x4
                          DCD      rt_object_container+0x4
                          DCD      0x00000080
000010  01000000          DCB      0x01,0x00,0x00,0x00
                          DCD      rt_object_container+0x14
                          DCD      rt_object_container+0x14
                          DCD      0x00000020
000020  02000000          DCB      0x02,0x00,0x00,0x00
                          DCD      rt_object_container+0x24
                          DCD      rt_object_container+0x24
                          DCD      0x00000024
000030  03000000          DCB      0x03,0x00,0x00,0x00
                          DCD      rt_object_container+0x34
                          DCD      rt_object_container+0x34
                          DCD      0x00000020
000040  04000000          DCB      0x04,0x00,0x00,0x00
                          DCD      rt_object_container+0x44
                          DCD      rt_object_container+0x44
                          DCD      0x00000030
000050  05000000          DCB      0x05,0x00,0x00,0x00
                          DCD      rt_object_container+0x54
                          DCD      rt_object_container+0x54
                          DCD      0x00000034
000060  06000000          DCB      0x06,0x00,0x00,0x00
                          DCD      rt_object_container+0x64
                          DCD      rt_object_container+0x64
                          DCD      0x00000038
000070  07000000          DCB      0x07,0x00,0x00,0x00
                          DCD      rt_object_container+0x74
                          DCD      rt_object_container+0x74
                          DCD      0x00000040
000080  08000000          DCB      0x08,0x00,0x00,0x00
                          DCD      rt_object_container+0x84
                          DCD      rt_object_container+0x84
                          DCD      0x0000002c
