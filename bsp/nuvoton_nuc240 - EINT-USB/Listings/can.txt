; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\can.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\can.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I.\Libraries\Device\Nuvoton -I..\..\components\finsh -I.\Libraries\CMSIS\Include -I.\Libraries\StdDriver\inc -I..\..\include -I.\APP -I.\Drivers -I..\..\components\drivers\include -I..\..\components\drivers\include\drivers -I..\nuvoton_nuc240 -I.\Libraries\Device\Nuvoton\NUC230_240\Include -I..\..\include -I..\..\components\drivers\usb\usbdevice\class -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=521 --omf_browse=.\objects\can.crf Libraries\StdDriver\src\can.c]
                          THUMB

                          AREA ||i.CAN_BasicReceiveMsg||, CODE, READONLY, ALIGN=1

                  CAN_BasicReceiveMsg PROC
;;;251      */
;;;252    int32_t CAN_BasicReceiveMsg(CAN_T *tCAN, STR_CANMSG_T* pCanMsg)
000000  b510              PUSH     {r4,lr}
;;;253    {
;;;254    
;;;255        if((tCAN->IF[1].MCON & CAN_IF_MCON_NEWDAT_Msk) == 0)   /* In basic mode, receive data always save in IF2 */
000002  4602              MOV      r2,r0
000004  3280              ADDS     r2,r2,#0x80
000006  6993              LDR      r3,[r2,#0x18]
000008  041b              LSLS     r3,r3,#16
00000a  d401              BMI      |L1.16|
;;;256        {
;;;257            return FALSE;
00000c  2000              MOVS     r0,#0
;;;258        }
;;;259    
;;;260        tCAN->STATUS &= (~CAN_STATUS_RXOK_Msk);
;;;261    
;;;262        tCAN->IF[1].CMASK = CAN_IF_CMASK_ARB_Msk
;;;263                            | CAN_IF_CMASK_CONTROL_Msk
;;;264                            | CAN_IF_CMASK_DATAA_Msk
;;;265                            | CAN_IF_CMASK_DATAB_Msk;
;;;266    
;;;267        if((tCAN->IF[1].ARB2 & CAN_IF_ARB2_XTD_Msk) == 0)
;;;268        {
;;;269            /* standard ID*/
;;;270            pCanMsg->IdType = CAN_STD_ID;
;;;271            pCanMsg->Id = (tCAN->IF[1].ARB2 >> 2) & 0x07FF;
;;;272    
;;;273        }
;;;274        else
;;;275        {
;;;276            /* extended ID*/
;;;277            pCanMsg->IdType = CAN_EXT_ID;
;;;278            pCanMsg->Id  = (tCAN->IF[1].ARB2 & 0x1FFF) << 16;
;;;279            pCanMsg->Id |= (uint32_t)tCAN->IF[1].ARB1;
;;;280        }
;;;281    
;;;282        pCanMsg->FrameType = !((tCAN->IF[1].ARB2 & CAN_IF_ARB2_DIR_Msk) >> CAN_IF_ARB2_DIR_Pos);
;;;283    
;;;284        pCanMsg->DLC     = tCAN->IF[1].MCON & CAN_IF_MCON_DLC_Msk;
;;;285        pCanMsg->Data[0] = tCAN->IF[1].DAT_A1 & CAN_IF_DAT_A1_DATA0_Msk;
;;;286        pCanMsg->Data[1] = (tCAN->IF[1].DAT_A1 & CAN_IF_DAT_A1_DATA1_Msk) >> CAN_IF_DAT_A1_DATA1_Pos;
;;;287        pCanMsg->Data[2] = tCAN->IF[1].DAT_A2 & CAN_IF_DAT_A2_DATA2_Msk;
;;;288        pCanMsg->Data[3] = (tCAN->IF[1].DAT_A2 & CAN_IF_DAT_A2_DATA3_Msk) >> CAN_IF_DAT_A2_DATA3_Pos;
;;;289        pCanMsg->Data[4] = tCAN->IF[1].DAT_B1 & CAN_IF_DAT_B1_DATA4_Msk;
;;;290        pCanMsg->Data[5] = (tCAN->IF[1].DAT_B1 & CAN_IF_DAT_B1_DATA5_Msk) >> CAN_IF_DAT_B1_DATA5_Pos;
;;;291        pCanMsg->Data[6] = tCAN->IF[1].DAT_B2 & CAN_IF_DAT_B2_DATA6_Msk;
;;;292        pCanMsg->Data[7] = (tCAN->IF[1].DAT_B2 & CAN_IF_DAT_B2_DATA7_Msk) >> CAN_IF_DAT_B2_DATA7_Pos;
;;;293    
;;;294        return TRUE;
;;;295    }
00000e  bd10              POP      {r4,pc}
                  |L1.16|
000010  6843              LDR      r3,[r0,#4]            ;260
000012  2410              MOVS     r4,#0x10              ;260
000014  43a3              BICS     r3,r3,r4              ;260
000016  6043              STR      r3,[r0,#4]            ;260
000018  2033              MOVS     r0,#0x33              ;262
00001a  6050              STR      r0,[r2,#4]            ;262
00001c  6950              LDR      r0,[r2,#0x14]         ;267
00001e  0440              LSLS     r0,r0,#17             ;267
000020  d405              BMI      |L1.46|
000022  2000              MOVS     r0,#0                 ;270
000024  6008              STR      r0,[r1,#0]            ;271
000026  6950              LDR      r0,[r2,#0x14]         ;271
000028  04c0              LSLS     r0,r0,#19             ;271
00002a  0d40              LSRS     r0,r0,#21             ;271
00002c  e007              B        |L1.62|
                  |L1.46|
00002e  2001              MOVS     r0,#1                 ;277
000030  6008              STR      r0,[r1,#0]            ;278
000032  6950              LDR      r0,[r2,#0x14]         ;278
000034  04c0              LSLS     r0,r0,#19             ;278
000036  08c0              LSRS     r0,r0,#3              ;278
000038  6088              STR      r0,[r1,#8]            ;279
00003a  6913              LDR      r3,[r2,#0x10]         ;279
00003c  4318              ORRS     r0,r0,r3              ;279
                  |L1.62|
00003e  6088              STR      r0,[r1,#8]            ;282
000040  6950              LDR      r0,[r2,#0x14]         ;282
000042  0480              LSLS     r0,r0,#18             ;282
000044  17c0              ASRS     r0,r0,#31             ;282
000046  1c40              ADDS     r0,r0,#1              ;282
000048  6048              STR      r0,[r1,#4]            ;284
00004a  6990              LDR      r0,[r2,#0x18]         ;284
00004c  0700              LSLS     r0,r0,#28             ;284
00004e  0f00              LSRS     r0,r0,#28             ;284
000050  7308              STRB     r0,[r1,#0xc]          ;284
000052  69d0              LDR      r0,[r2,#0x1c]         ;285
000054  7348              STRB     r0,[r1,#0xd]          ;285
000056  69d0              LDR      r0,[r2,#0x1c]         ;286
000058  0a00              LSRS     r0,r0,#8              ;286
00005a  7388              STRB     r0,[r1,#0xe]          ;286
00005c  6a10              LDR      r0,[r2,#0x20]         ;287
00005e  73c8              STRB     r0,[r1,#0xf]          ;287
000060  6a10              LDR      r0,[r2,#0x20]         ;288
000062  0a00              LSRS     r0,r0,#8              ;288
000064  7408              STRB     r0,[r1,#0x10]         ;288
000066  6a50              LDR      r0,[r2,#0x24]         ;289
000068  7448              STRB     r0,[r1,#0x11]         ;289
00006a  6a50              LDR      r0,[r2,#0x24]         ;290
00006c  0a00              LSRS     r0,r0,#8              ;290
00006e  7488              STRB     r0,[r1,#0x12]         ;290
000070  6a90              LDR      r0,[r2,#0x28]         ;291
000072  74c8              STRB     r0,[r1,#0x13]         ;291
000074  6a90              LDR      r0,[r2,#0x28]         ;292
000076  0a00              LSRS     r0,r0,#8              ;292
000078  7508              STRB     r0,[r1,#0x14]         ;292
00007a  2001              MOVS     r0,#1                 ;294
00007c  bd10              POP      {r4,pc}
;;;296    
                          ENDP


                          AREA ||i.CAN_BasicSendMsg||, CODE, READONLY, ALIGN=2

                  CAN_BasicSendMsg PROC
;;;184      */
;;;185    int32_t CAN_BasicSendMsg(CAN_T *tCAN, STR_CANMSG_T* pCanMsg)
000000  b510              PUSH     {r4,lr}
                  |L2.2|
;;;186    {
;;;187        uint32_t i = 0;
;;;188        while(tCAN->IF[0].CREQ & CAN_IF_CREQ_BUSY_Msk);
000002  6a02              LDR      r2,[r0,#0x20]
000004  0412              LSLS     r2,r2,#16
000006  d4fc              BMI      |L2.2|
;;;189    
;;;190        tCAN->STATUS &= (~CAN_STATUS_TXOK_Msk);
000008  6842              LDR      r2,[r0,#4]
00000a  2308              MOVS     r3,#8
00000c  439a              BICS     r2,r2,r3
00000e  6042              STR      r2,[r0,#4]
;;;191    
;;;192        if(pCanMsg->IdType == CAN_STD_ID)
000010  680a              LDR      r2,[r1,#0]
000012  2a00              CMP      r2,#0
000014  d010              BEQ      |L2.56|
;;;193        {
;;;194            /* standard ID*/
;;;195            tCAN->IF[0].ARB1 = 0;
;;;196            tCAN->IF[0].ARB2 = (((pCanMsg->Id) & 0x7FF) << 2) ;
;;;197        }
;;;198        else
;;;199        {
;;;200            /* extended ID*/
;;;201            tCAN->IF[0].ARB1 = (pCanMsg->Id) & 0xFFFF;
000016  890a              LDRH     r2,[r1,#8]
000018  b292              UXTH     r2,r2
00001a  6302              STR      r2,[r0,#0x30]
;;;202            tCAN->IF[0].ARB2 = ((pCanMsg->Id) & 0x1FFF0000) >> 16  | CAN_IF_ARB2_XTD_Msk;
00001c  688a              LDR      r2,[r1,#8]
00001e  02db              LSLS     r3,r3,#11
000020  00d2              LSLS     r2,r2,#3
000022  0cd2              LSRS     r2,r2,#19
000024  18d2              ADDS     r2,r2,r3
                  |L2.38|
000026  6342              STR      r2,[r0,#0x34]
;;;203    
;;;204        }
;;;205    
;;;206        if(pCanMsg->FrameType)
;;;207            tCAN->IF[0].ARB2 |= CAN_IF_ARB2_DIR_Msk;
000028  2201              MOVS     r2,#1
00002a  684b              LDR      r3,[r1,#4]            ;206
00002c  0352              LSLS     r2,r2,#13
00002e  2b00              CMP      r3,#0                 ;206
;;;208        else
;;;209            tCAN->IF[0].ARB2 &= (~CAN_IF_ARB2_DIR_Msk);
000030  6b43              LDR      r3,[r0,#0x34]
000032  d007              BEQ      |L2.68|
000034  4313              ORRS     r3,r3,r2              ;207
000036  e006              B        |L2.70|
                  |L2.56|
000038  2200              MOVS     r2,#0                 ;195
00003a  6302              STR      r2,[r0,#0x30]         ;195
00003c  890a              LDRH     r2,[r1,#8]            ;196
00003e  0552              LSLS     r2,r2,#21             ;196
000040  0cd2              LSRS     r2,r2,#19             ;196
000042  e7f0              B        |L2.38|
                  |L2.68|
000044  4393              BICS     r3,r3,r2
                  |L2.70|
000046  6343              STR      r3,[r0,#0x34]
;;;210    
;;;211        tCAN->IF[0].MCON = (tCAN->IF[0].MCON & (~CAN_IF_MCON_DLC_Msk)) | pCanMsg->DLC;
000048  6b82              LDR      r2,[r0,#0x38]
00004a  7b0b              LDRB     r3,[r1,#0xc]
00004c  0912              LSRS     r2,r2,#4
00004e  0112              LSLS     r2,r2,#4
000050  431a              ORRS     r2,r2,r3
000052  6382              STR      r2,[r0,#0x38]
;;;212        tCAN->IF[0].DAT_A1 = ((uint16_t)pCanMsg->Data[1] << 8) | pCanMsg->Data[0];
000054  7b8b              LDRB     r3,[r1,#0xe]
000056  7b4c              LDRB     r4,[r1,#0xd]
000058  021b              LSLS     r3,r3,#8
00005a  4323              ORRS     r3,r3,r4
00005c  63c3              STR      r3,[r0,#0x3c]
;;;213        tCAN->IF[0].DAT_A2 = ((uint16_t)pCanMsg->Data[3] << 8) | pCanMsg->Data[2];
00005e  7c0b              LDRB     r3,[r1,#0x10]
000060  7bcc              LDRB     r4,[r1,#0xf]
000062  021b              LSLS     r3,r3,#8
000064  4323              ORRS     r3,r3,r4
000066  6403              STR      r3,[r0,#0x40]
;;;214        tCAN->IF[0].DAT_B1 = ((uint16_t)pCanMsg->Data[5] << 8) | pCanMsg->Data[4];
000068  7c8b              LDRB     r3,[r1,#0x12]
00006a  7c4c              LDRB     r4,[r1,#0x11]
00006c  021a              LSLS     r2,r3,#8
00006e  4322              ORRS     r2,r2,r4
000070  6442              STR      r2,[r0,#0x44]
;;;215        tCAN->IF[0].DAT_B2 = ((uint16_t)pCanMsg->Data[7] << 8) | pCanMsg->Data[6];
000072  7d0a              LDRB     r2,[r1,#0x14]
000074  7ccb              LDRB     r3,[r1,#0x13]
000076  0211              LSLS     r1,r2,#8
000078  4319              ORRS     r1,r1,r3
00007a  6481              STR      r1,[r0,#0x48]
;;;216    
;;;217        /* request transmission*/
;;;218        tCAN->IF[0].CREQ &= (~CAN_IF_CREQ_BUSY_Msk);
00007c  6a02              LDR      r2,[r0,#0x20]
00007e  2101              MOVS     r1,#1
000080  03c9              LSLS     r1,r1,#15
000082  438a              BICS     r2,r2,r1
000084  6202              STR      r2,[r0,#0x20]
;;;219        if(tCAN->IF[0].CREQ & CAN_IF_CREQ_BUSY_Msk)
000086  6a02              LDR      r2,[r0,#0x20]
000088  0412              LSLS     r2,r2,#16
00008a  d40c              BMI      |L2.166|
;;;220        {
;;;221            DEBUG_PRINTF("Cannot clear busy for sending ...\n");
;;;222            return FALSE;
;;;223        }
;;;224    
;;;225        tCAN->IF[0].CREQ |= CAN_IF_CREQ_BUSY_Msk;                          // sending
00008c  6a02              LDR      r2,[r0,#0x20]
00008e  430a              ORRS     r2,r2,r1
000090  6202              STR      r2,[r0,#0x20]
;;;226    
;;;227        for(i = 0; i < 0xFFFFF; i++)
000092  4a07              LDR      r2,|L2.176|
000094  2100              MOVS     r1,#0
                  |L2.150|
;;;228        {
;;;229            if((tCAN->IF[0].CREQ & CAN_IF_CREQ_BUSY_Msk) == 0)
000096  6a03              LDR      r3,[r0,#0x20]
000098  041b              LSLS     r3,r3,#16
00009a  d502              BPL      |L2.162|
00009c  1c49              ADDS     r1,r1,#1
00009e  4291              CMP      r1,r2                 ;227
0000a0  d3f9              BCC      |L2.150|
                  |L2.162|
;;;230                break;
;;;231        }
;;;232    
;;;233        if(i >= 0xFFFFF)
0000a2  4291              CMP      r1,r2
0000a4  d301              BCC      |L2.170|
                  |L2.166|
;;;234        {
;;;235            DEBUG_PRINTF("Cannot send out...\n");
;;;236            return FALSE;
0000a6  2000              MOVS     r0,#0
;;;237        }
;;;238    
;;;239        return TRUE;
;;;240    }
0000a8  bd10              POP      {r4,pc}
                  |L2.170|
0000aa  2001              MOVS     r0,#1                 ;239
0000ac  bd10              POP      {r4,pc}
;;;241    
                          ENDP

0000ae  0000              DCW      0x0000
                  |L2.176|
                          DCD      0x000fffff

                          AREA ||i.CAN_CLR_INT_PENDING_BIT||, CODE, READONLY, ALIGN=1

                  CAN_CLR_INT_PENDING_BIT PROC
;;;779      */
;;;780    void CAN_CLR_INT_PENDING_BIT(CAN_T *tCAN, uint8_t u32MsgNum)
000000  b570              PUSH     {r4-r6,lr}
;;;781    {
;;;782        uint32_t u32MsgIfNum = 0;
000002  2300              MOVS     r3,#0
;;;783        uint32_t u32IFBusyCount = 0;
;;;784    
;;;785        while(u32IFBusyCount < 0x10000000)
;;;786        {
;;;787            if((tCAN->IF[0].CREQ & CAN_IF_CREQ_BUSY_Msk) == 0)
;;;788            {
;;;789                u32MsgIfNum = 0;
;;;790                break;
;;;791            }
;;;792            else if((tCAN->IF[1].CREQ  & CAN_IF_CREQ_BUSY_Msk) == 0)
000004  4604              MOV      r4,r0
000006  3480              ADDS     r4,r4,#0x80
000008  2501              MOVS     r5,#1                 ;785
00000a  461a              MOV      r2,r3                 ;783
00000c  072d              LSLS     r5,r5,#28             ;785
                  |L3.14|
00000e  6a06              LDR      r6,[r0,#0x20]         ;787
000010  0436              LSLS     r6,r6,#16             ;787
000012  d401              BMI      |L3.24|
000014  2300              MOVS     r3,#0                 ;789
000016  e007              B        |L3.40|
                  |L3.24|
000018  6826              LDR      r6,[r4,#0]
00001a  0436              LSLS     r6,r6,#16
00001c  d401              BMI      |L3.34|
;;;793            {
;;;794                u32MsgIfNum = 1;
00001e  2301              MOVS     r3,#1
;;;795                break;
000020  e002              B        |L3.40|
                  |L3.34|
000022  1c52              ADDS     r2,r2,#1
000024  42aa              CMP      r2,r5                 ;785
000026  d3f2              BCC      |L3.14|
                  |L3.40|
;;;796            }
;;;797    
;;;798            u32IFBusyCount++;
;;;799        }
;;;800    
;;;801        tCAN->IF[u32MsgIfNum].CMASK = CAN_IF_CMASK_CLRINTPND_Msk | CAN_IF_CMASK_TXRQSTNEWDAT_Msk;
000028  2460              MOVS     r4,#0x60
00002a  220c              MOVS     r2,#0xc
00002c  4363              MULS     r3,r4,r3
00002e  1818              ADDS     r0,r3,r0
000030  6242              STR      r2,[r0,#0x24]
000032  1c49              ADDS     r1,r1,#1
;;;802        tCAN->IF[u32MsgIfNum].CREQ = 1 + u32MsgNum;
000034  6201              STR      r1,[r0,#0x20]
;;;803    
;;;804    }
000036  bd70              POP      {r4-r6,pc}
;;;805    
                          ENDP


                          AREA ||i.CAN_Close||, CODE, READONLY, ALIGN=1

                  CAN_Close PROC
;;;476      */
;;;477    void CAN_Close(CAN_T *tCAN)
000000  b500              PUSH     {lr}
;;;478    {
;;;479        CAN_DisableInt(tCAN, (CAN_CON_IE_Msk | CAN_CON_SIE_Msk | CAN_CON_EIE_Msk));
000002  210e              MOVS     r1,#0xe
000004  f7fffffe          BL       CAN_DisableInt
;;;480    }
000008  bd00              POP      {pc}
;;;481    
                          ENDP


                          AREA ||i.CAN_DisableInt||, CODE, READONLY, ALIGN=1

                  CAN_DisableInt PROC
;;;632      */
;;;633    void CAN_DisableInt(CAN_T *tCAN, uint32_t u32Mask)
000000  b510              PUSH     {r4,lr}
;;;634    {
000002  460c              MOV      r4,r1
000004  4603              MOV      r3,r0
;;;635        CAN_EnterInitMode(tCAN);
000006  f7fffffe          BL       CAN_EnterInitMode
;;;636    
;;;637        tCAN->CON = tCAN->CON & ~(CAN_CON_IE_Msk | ((u32Mask & CAN_CON_SIE_Msk) ? CAN_CON_SIE_Msk : 0)
00000a  0760              LSLS     r0,r4,#29
00000c  0721              LSLS     r1,r4,#28
00000e  0fc0              LSRS     r0,r0,#31
000010  0fc9              LSRS     r1,r1,#31
000012  0080              LSLS     r0,r0,#2
000014  00c9              LSLS     r1,r1,#3
000016  1c80              ADDS     r0,r0,#2
000018  4308              ORRS     r0,r0,r1
00001a  6819              LDR      r1,[r3,#0]
00001c  4381              BICS     r1,r1,r0
00001e  6019              STR      r1,[r3,#0]
;;;638                                  | ((u32Mask & CAN_CON_EIE_Msk) ? CAN_CON_EIE_Msk : 0));
;;;639    
;;;640        CAN_LeaveInitMode(tCAN);
000020  4618              MOV      r0,r3
000022  f7fffffe          BL       CAN_LeaveInitMode
;;;641    }
000026  bd10              POP      {r4,pc}
;;;642    
                          ENDP


                          AREA ||i.CAN_EnableInt||, CODE, READONLY, ALIGN=1

                  CAN_EnableInt PROC
;;;610      */
;;;611    void CAN_EnableInt(CAN_T *tCAN, uint32_t u32Mask)
000000  b510              PUSH     {r4,lr}
;;;612    {
000002  460b              MOV      r3,r1
000004  4604              MOV      r4,r0
;;;613        CAN_EnterInitMode(tCAN);
000006  f7fffffe          BL       CAN_EnterInitMode
;;;614    
;;;615        tCAN->CON = (tCAN->CON & 0xF1) | ((u32Mask & CAN_CON_IE_Msk) ? CAN_CON_IE_Msk : 0)
00000a  6820              LDR      r0,[r4,#0]
00000c  21f1              MOVS     r1,#0xf1
00000e  4008              ANDS     r0,r0,r1
000010  0799              LSLS     r1,r3,#30
000012  0fc9              LSRS     r1,r1,#31
000014  0049              LSLS     r1,r1,#1
000016  4308              ORRS     r0,r0,r1
000018  0759              LSLS     r1,r3,#29
00001a  0fc9              LSRS     r1,r1,#31
00001c  0089              LSLS     r1,r1,#2
00001e  4308              ORRS     r0,r0,r1
000020  0719              LSLS     r1,r3,#28
000022  0fc9              LSRS     r1,r1,#31
000024  00c9              LSLS     r1,r1,#3
000026  4308              ORRS     r0,r0,r1
000028  6020              STR      r0,[r4,#0]
;;;616                    | ((u32Mask & CAN_CON_SIE_Msk) ? CAN_CON_SIE_Msk : 0)
;;;617                    | ((u32Mask & CAN_CON_EIE_Msk) ? CAN_CON_EIE_Msk : 0);
;;;618    
;;;619    
;;;620        CAN_LeaveInitMode(tCAN);
00002a  4620              MOV      r0,r4
00002c  f7fffffe          BL       CAN_LeaveInitMode
;;;621    }
000030  bd10              POP      {r4,pc}
;;;622    
                          ENDP


                          AREA ||i.CAN_EnterInitMode||, CODE, READONLY, ALIGN=1

                  CAN_EnterInitMode PROC
;;;60       */
;;;61     void CAN_EnterInitMode(CAN_T *tCAN)
000000  6801              LDR      r1,[r0,#0]
;;;62     {
;;;63         tCAN->CON |= CAN_CON_INIT_Msk;
000002  2201              MOVS     r2,#1
000004  4311              ORRS     r1,r1,r2
000006  6001              STR      r1,[r0,#0]
;;;64         tCAN->CON |= CAN_CON_CCE_Msk;
000008  6801              LDR      r1,[r0,#0]
00000a  2240              MOVS     r2,#0x40
00000c  4311              ORRS     r1,r1,r2
00000e  6001              STR      r1,[r0,#0]
;;;65     }
000010  4770              BX       lr
;;;66     
                          ENDP


                          AREA ||i.CAN_EnterTestMode||, CODE, READONLY, ALIGN=1

                  CAN_EnterTestMode PROC
;;;140      */
;;;141    void CAN_EnterTestMode(CAN_T *tCAN, uint8_t u8TestMask)
000000  6802              LDR      r2,[r0,#0]
;;;142    {
;;;143        tCAN->CON |= CAN_CON_TEST_Msk;
000002  2380              MOVS     r3,#0x80
000004  431a              ORRS     r2,r2,r3
000006  6002              STR      r2,[r0,#0]
;;;144        tCAN->TEST = u8TestMask;
000008  6141              STR      r1,[r0,#0x14]
;;;145    }
00000a  4770              BX       lr
;;;146    
                          ENDP


                          AREA ||i.CAN_GetCANBitRate||, CODE, READONLY, ALIGN=2

                  CAN_GetCANBitRate PROC
;;;115      */
;;;116    uint32_t CAN_GetCANBitRate(CAN_T  *tCAN)
000000  b570              PUSH     {r4-r6,lr}
;;;117    {
;;;118        uint8_t u8Tseg1, u8Tseg2;
;;;119        uint32_t u32Bpr;
;;;120    
;;;121        u8Tseg1 = (tCAN->BTIME & CAN_BTIME_TSEG1_Msk) >> CAN_BTIME_TSEG1_Pos;
000002  68c1              LDR      r1,[r0,#0xc]
;;;122        u8Tseg2 = (tCAN->BTIME & CAN_BTIME_TSEG2_Msk) >> CAN_BTIME_TSEG2_Pos;
;;;123        u32Bpr  = (tCAN->BTIME & CAN_BTIME_BRP_Msk) | (tCAN->BRPE << 6);
;;;124    
;;;125        return (SystemCoreClock / (u32Bpr + 1) / (u8Tseg1 + u8Tseg2 + 3));
;;;126    }
000004  0509              LSLS     r1,r1,#20
000006  0f0d              LSRS     r5,r1,#28
000008  68c1              LDR      r1,[r0,#0xc]          ;122
00000a  0449              LSLS     r1,r1,#17
00000c  0f4c              LSRS     r4,r1,#29
00000e  68c1              LDR      r1,[r0,#0xc]          ;123
000010  6980              LDR      r0,[r0,#0x18]         ;123
000012  0689              LSLS     r1,r1,#26             ;123
000014  0e89              LSRS     r1,r1,#26             ;123
000016  0180              LSLS     r0,r0,#6              ;123
000018  4301              ORRS     r1,r1,r0              ;123
00001a  4805              LDR      r0,|L9.48|
00001c  1c49              ADDS     r1,r1,#1              ;125
00001e  6800              LDR      r0,[r0,#0]            ;125  ; SystemCoreClock
000020  f7fffffe          BL       __aeabi_uidivmod
000024  1929              ADDS     r1,r5,r4              ;125
000026  1cc9              ADDS     r1,r1,#3              ;125
000028  f7fffffe          BL       __aeabi_uidivmod
00002c  bd70              POP      {r4-r6,pc}
;;;127    
                          ENDP

00002e  0000              DCW      0x0000
                  |L9.48|
                          DCD      SystemCoreClock

                          AREA ||i.CAN_IsNewDataReceived||, CODE, READONLY, ALIGN=1

                  CAN_IsNewDataReceived PROC
;;;168      */
;;;169    uint32_t CAN_IsNewDataReceived(CAN_T *tCAN, uint8_t u8MsgObj)
000000  30ff              ADDS     r0,r0,#0xff
;;;170    {
;;;171        return (u8MsgObj < 16 ? tCAN->NDAT1 & (1 << u8MsgObj) : tCAN->NDAT2 & (1 << (u8MsgObj - 16)));
000002  2201              MOVS     r2,#1
000004  3001              ADDS     r0,#1
000006  2910              CMP      r1,#0x10
000008  d201              BCS      |L10.14|
00000a  6a00              LDR      r0,[r0,#0x20]
00000c  e001              B        |L10.18|
                  |L10.14|
00000e  6a40              LDR      r0,[r0,#0x24]
000010  3910              SUBS     r1,r1,#0x10
                  |L10.18|
000012  408a              LSLS     r2,r2,r1
000014  4010              ANDS     r0,r0,r2
;;;172    }
000016  4770              BX       lr
;;;173    
                          ENDP


                          AREA ||i.CAN_LeaveInitMode||, CODE, READONLY, ALIGN=1

                  CAN_LeaveInitMode PROC
;;;74       */
;;;75     void CAN_LeaveInitMode(CAN_T *tCAN)
000000  6801              LDR      r1,[r0,#0]
;;;76     {
;;;77         tCAN->CON &= (~(CAN_CON_INIT_Msk | CAN_CON_CCE_Msk));
000002  2241              MOVS     r2,#0x41
000004  4391              BICS     r1,r1,r2
000006  6001              STR      r1,[r0,#0]
                  |L11.8|
;;;78     
;;;79         while(tCAN->CON & CAN_CON_INIT_Msk); /* Check INIT bit is released */
000008  6801              LDR      r1,[r0,#0]
00000a  07c9              LSLS     r1,r1,#31
00000c  d1fc              BNE      |L11.8|
;;;80     }
00000e  4770              BX       lr
;;;81     
                          ENDP


                          AREA ||i.CAN_LeaveTestMode||, CODE, READONLY, ALIGN=1

                  CAN_LeaveTestMode PROC
;;;153      */
;;;154    void CAN_LeaveTestMode(CAN_T *tCAN)
000000  6802              LDR      r2,[r0,#0]
;;;155    {
;;;156        tCAN->CON |= CAN_CON_TEST_Msk;
000002  2180              MOVS     r1,#0x80
000004  430a              ORRS     r2,r2,r1
000006  6002              STR      r2,[r0,#0]
;;;157        tCAN->TEST &= ~(CAN_TEST_LBACK_Msk | CAN_TEST_SILENT_Msk | CAN_TEST_BASIC_Msk);
000008  6942              LDR      r2,[r0,#0x14]
00000a  231c              MOVS     r3,#0x1c
00000c  439a              BICS     r2,r2,r3
00000e  6142              STR      r2,[r0,#0x14]
;;;158        tCAN->CON &= (~CAN_CON_TEST_Msk);
000010  6802              LDR      r2,[r0,#0]
000012  438a              BICS     r2,r2,r1
000014  6002              STR      r2,[r0,#0]
;;;159    }
000016  4770              BX       lr
;;;160    
                          ENDP


                          AREA ||i.CAN_Open||, CODE, READONLY, ALIGN=1

                  CAN_Open PROC
;;;494      */
;;;495    uint32_t CAN_Open(CAN_T *tCAN, uint32_t u32BaudRate, uint32_t u32Mode)
000000  b570              PUSH     {r4-r6,lr}
;;;496    {
000002  4614              MOV      r4,r2
000004  4606              MOV      r6,r0
;;;497        uint32_t u32CurrentBitRate;
;;;498    
;;;499        u32CurrentBitRate = CAN_SetBaudRate(tCAN, u32BaudRate);
000006  f7fffffe          BL       CAN_SetBaudRate
00000a  4605              MOV      r5,r0
;;;500    
;;;501        if(u32Mode == CAN_BASIC_MODE)
00000c  2c01              CMP      r4,#1
00000e  d103              BNE      |L13.24|
;;;502            CAN_EnterTestMode(tCAN, CAN_TEST_BASIC_Msk);
000010  2104              MOVS     r1,#4
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       CAN_EnterTestMode
                  |L13.24|
;;;503    
;;;504        return u32CurrentBitRate;
000018  4628              MOV      r0,r5
;;;505    }
00001a  bd70              POP      {r4-r6,pc}
;;;506    
                          ENDP


                          AREA ||i.CAN_ReadMsgObj||, CODE, READONLY, ALIGN=1

                  CAN_ReadMsgObj PROC
;;;363      */
;;;364    int32_t CAN_ReadMsgObj(CAN_T *tCAN, uint8_t u8MsgObj, uint8_t u8Release, STR_CANMSG_T* pCanMsg)
000000  b570              PUSH     {r4-r6,lr}
;;;365    {
000002  4616              MOV      r6,r2
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
;;;366        if(!CAN_IsNewDataReceived(tCAN, u8MsgObj))
000008  f7fffffe          BL       CAN_IsNewDataReceived
00000c  2800              CMP      r0,#0
00000e  d03c              BEQ      |L14.138|
;;;367        {
;;;368            return FALSE;
;;;369        }
;;;370    
;;;371        tCAN->STATUS &= (~CAN_STATUS_RXOK_Msk);
000010  6860              LDR      r0,[r4,#4]
000012  2110              MOVS     r1,#0x10
000014  4388              BICS     r0,r0,r1
000016  6060              STR      r0,[r4,#4]
;;;372    
;;;373        /* read the message contents*/
;;;374        tCAN->IF[1].CMASK = CAN_IF_CMASK_MASK_Msk
000018  2e00              CMP      r6,#0
00001a  d001              BEQ      |L14.32|
;;;375                            | CAN_IF_CMASK_ARB_Msk
;;;376                            | CAN_IF_CMASK_CONTROL_Msk
;;;377                            | CAN_IF_CMASK_CLRINTPND_Msk
;;;378                            | (u8Release ? CAN_IF_CMASK_TXRQSTNEWDAT_Msk : 0)
00001c  2004              MOVS     r0,#4
00001e  e000              B        |L14.34|
                  |L14.32|
000020  2000              MOVS     r0,#0
                  |L14.34|
000022  2103              MOVS     r1,#3
000024  3078              ADDS     r0,r0,#0x78
000026  4308              ORRS     r0,r0,r1
000028  3480              ADDS     r4,r4,#0x80
00002a  6060              STR      r0,[r4,#4]
00002c  1c6d              ADDS     r5,r5,#1
;;;379                            | CAN_IF_CMASK_DATAA_Msk
;;;380                            | CAN_IF_CMASK_DATAB_Msk;
;;;381    
;;;382        tCAN->IF[1].CREQ = 1 + u8MsgObj;
00002e  6025              STR      r5,[r4,#0]
                  |L14.48|
;;;383    
;;;384        while(tCAN->IF[1].CREQ & CAN_IF_CREQ_BUSY_Msk)
000030  6820              LDR      r0,[r4,#0]
000032  0400              LSLS     r0,r0,#16
000034  d4fc              BMI      |L14.48|
;;;385        {
;;;386            /*Wait*/
;;;387        }
;;;388    
;;;389        if((tCAN->IF[1].ARB2 & CAN_IF_ARB2_XTD_Msk) == 0)
000036  6960              LDR      r0,[r4,#0x14]
000038  0440              LSLS     r0,r0,#17
00003a  d405              BMI      |L14.72|
;;;390        {
;;;391            /* standard ID*/
;;;392            pCanMsg->IdType = CAN_STD_ID;
00003c  2000              MOVS     r0,#0
;;;393            pCanMsg->Id     = (tCAN->IF[1].ARB2 & CAN_IF_ARB2_ID_Msk) >> 2;
00003e  6018              STR      r0,[r3,#0]
000040  6960              LDR      r0,[r4,#0x14]
;;;394        }
;;;395        else
;;;396        {
;;;397            /* extended ID*/
;;;398            pCanMsg->IdType = CAN_EXT_ID;
;;;399            pCanMsg->Id  = (((tCAN->IF[1].ARB2) & 0x1FFF) << 16) | tCAN->IF[1].ARB1;
;;;400        }
;;;401    
;;;402        pCanMsg->DLC     = tCAN->IF[1].MCON & CAN_IF_MCON_DLC_Msk;
;;;403        pCanMsg->Data[0] = tCAN->IF[1].DAT_A1 & CAN_IF_DAT_A1_DATA0_Msk;
;;;404        pCanMsg->Data[1] = (tCAN->IF[1].DAT_A1 & CAN_IF_DAT_A1_DATA1_Msk) >> CAN_IF_DAT_A1_DATA1_Pos;
;;;405        pCanMsg->Data[2] = tCAN->IF[1].DAT_A2 & CAN_IF_DAT_A2_DATA2_Msk;
;;;406        pCanMsg->Data[3] = (tCAN->IF[1].DAT_A2 & CAN_IF_DAT_A2_DATA3_Msk) >> CAN_IF_DAT_A2_DATA3_Pos;
;;;407        pCanMsg->Data[4] = tCAN->IF[1].DAT_B1 & CAN_IF_DAT_B1_DATA4_Msk;
;;;408        pCanMsg->Data[5] = (tCAN->IF[1].DAT_B1 & CAN_IF_DAT_B1_DATA5_Msk) >> CAN_IF_DAT_B1_DATA5_Pos;
;;;409        pCanMsg->Data[6] = tCAN->IF[1].DAT_B2 & CAN_IF_DAT_B2_DATA6_Msk;
;;;410        pCanMsg->Data[7] = (tCAN->IF[1].DAT_B2 & CAN_IF_DAT_B2_DATA7_Msk) >> CAN_IF_DAT_B2_DATA7_Pos;
;;;411    
;;;412        return TRUE;
000042  04c0              LSLS     r0,r0,#19
000044  0d40              LSRS     r0,r0,#21
000046  e006              B        |L14.86|
                  |L14.72|
000048  2001              MOVS     r0,#1                 ;398
00004a  6018              STR      r0,[r3,#0]            ;399
00004c  6960              LDR      r0,[r4,#0x14]         ;399
00004e  6921              LDR      r1,[r4,#0x10]         ;399
000050  04c0              LSLS     r0,r0,#19             ;399
000052  08c0              LSRS     r0,r0,#3              ;399
000054  4308              ORRS     r0,r0,r1              ;399
                  |L14.86|
000056  6098              STR      r0,[r3,#8]            ;402
000058  69a0              LDR      r0,[r4,#0x18]         ;402
00005a  0700              LSLS     r0,r0,#28             ;402
00005c  0f00              LSRS     r0,r0,#28             ;402
00005e  7318              STRB     r0,[r3,#0xc]          ;402
000060  69e0              LDR      r0,[r4,#0x1c]         ;403
000062  7358              STRB     r0,[r3,#0xd]          ;403
000064  69e0              LDR      r0,[r4,#0x1c]         ;404
000066  0a00              LSRS     r0,r0,#8              ;404
000068  7398              STRB     r0,[r3,#0xe]          ;404
00006a  6a20              LDR      r0,[r4,#0x20]         ;405
00006c  73d8              STRB     r0,[r3,#0xf]          ;405
00006e  6a20              LDR      r0,[r4,#0x20]         ;406
000070  0a00              LSRS     r0,r0,#8              ;406
000072  7418              STRB     r0,[r3,#0x10]         ;406
000074  6a60              LDR      r0,[r4,#0x24]         ;407
000076  7458              STRB     r0,[r3,#0x11]         ;407
000078  6a60              LDR      r0,[r4,#0x24]         ;408
00007a  0a00              LSRS     r0,r0,#8              ;408
00007c  7498              STRB     r0,[r3,#0x12]         ;408
00007e  6aa0              LDR      r0,[r4,#0x28]         ;409
000080  74d8              STRB     r0,[r3,#0x13]         ;409
000082  6aa0              LDR      r0,[r4,#0x28]         ;410
000084  0a00              LSRS     r0,r0,#8              ;410
000086  7518              STRB     r0,[r3,#0x14]         ;410
000088  2001              MOVS     r0,#1
                  |L14.138|
;;;413    }
00008a  bd70              POP      {r4-r6,pc}
;;;414    
                          ENDP


                          AREA ||i.CAN_Receive||, CODE, READONLY, ALIGN=1

                  CAN_Receive PROC
;;;758      */
;;;759    int32_t CAN_Receive(CAN_T *tCAN, uint32_t u32MsgNum , STR_CANMSG_T* pCanMsg)
000000  b500              PUSH     {lr}
;;;760    {
;;;761        if((tCAN->CON & CAN_CON_TEST_Msk) && (tCAN->TEST & CAN_TEST_BASIC_Msk))
000002  6803              LDR      r3,[r0,#0]
000004  061b              LSLS     r3,r3,#24
000006  d506              BPL      |L15.22|
000008  6943              LDR      r3,[r0,#0x14]
00000a  075b              LSLS     r3,r3,#29
00000c  d503              BPL      |L15.22|
;;;762        {
;;;763            return (CAN_BasicReceiveMsg(tCAN, pCanMsg));
00000e  4611              MOV      r1,r2
000010  f7fffffe          BL       CAN_BasicReceiveMsg
;;;764        }
;;;765        else
;;;766        {
;;;767            return CAN_ReadMsgObj(tCAN, u32MsgNum, TRUE, pCanMsg);
;;;768        }
;;;769    }
000014  bd00              POP      {pc}
                  |L15.22|
000016  4613              MOV      r3,r2                 ;767
000018  b2c9              UXTB     r1,r1                 ;767
00001a  2201              MOVS     r2,#1                 ;767
00001c  f7fffffe          BL       CAN_ReadMsgObj
000020  bd00              POP      {pc}
;;;770    
                          ENDP


                          AREA ||i.CAN_SetBaudRate||, CODE, READONLY, ALIGN=2

                  CAN_SetBaudRate PROC
;;;427      */
;;;428    uint32_t CAN_SetBaudRate(CAN_T *tCAN, uint32_t u32BaudRate)
000000  b5f8              PUSH     {r3-r7,lr}
;;;429    {
000002  460c              MOV      r4,r1
000004  4606              MOV      r6,r0
;;;430        uint8_t u8Tseg1, u8Tseg2;
;;;431        uint32_t u32Brp;
;;;432        uint32_t u32Value;
;;;433    
;;;434        CAN_EnterInitMode(tCAN);
000006  f7fffffe          BL       CAN_EnterInitMode
;;;435    
;;;436        SystemCoreClockUpdate();
00000a  f7fffffe          BL       SystemCoreClockUpdate
;;;437    
;;;438        u32Value = SystemCoreClock / u32BaudRate;
00000e  4821              LDR      r0,|L16.148|
000010  4621              MOV      r1,r4
000012  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000014  f7fffffe          BL       __aeabi_uidivmod
;;;439        u8Tseg1 = 3;
000018  2503              MOVS     r5,#3
00001a  4607              MOV      r7,r0                 ;438
;;;440        u8Tseg2 = 2;
00001c  2402              MOVS     r4,#2
                  |L16.30|
;;;441        while(1)
;;;442        {
;;;443            if(((u32Value % (u8Tseg1 + u8Tseg2 + 3)) == 0) | (u8Tseg1 >= 15))
00001e  1929              ADDS     r1,r5,r4
000020  4638              MOV      r0,r7
000022  1cc9              ADDS     r1,r1,#3
000024  f7fffffe          BL       __aeabi_uidivmod
000028  2900              CMP      r1,#0
00002a  d004              BEQ      |L16.54|
00002c  2000              MOVS     r0,#0
                  |L16.46|
00002e  2d0f              CMP      r5,#0xf
000030  d303              BCC      |L16.58|
000032  2101              MOVS     r1,#1
000034  e002              B        |L16.60|
                  |L16.54|
000036  2001              MOVS     r0,#1
000038  e7f9              B        |L16.46|
                  |L16.58|
00003a  2100              MOVS     r1,#0
                  |L16.60|
00003c  4308              ORRS     r0,r0,r1
00003e  d10d              BNE      |L16.92|
000040  1c6d              ADDS     r5,r5,#1
;;;444                break;
;;;445    
;;;446            u8Tseg1++;
000042  b2ed              UXTB     r5,r5
;;;447    
;;;448            if((u32Value % (u8Tseg1 + u8Tseg2 + 3)) == 0)
000044  1929              ADDS     r1,r5,r4
000046  4638              MOV      r0,r7
000048  1cc9              ADDS     r1,r1,#3
00004a  f7fffffe          BL       __aeabi_uidivmod
00004e  2900              CMP      r1,#0
000050  d004              BEQ      |L16.92|
;;;449                break;
;;;450    
;;;451            if(u8Tseg2 < 7)
000052  2c07              CMP      r4,#7
000054  d2e3              BCS      |L16.30|
000056  1c64              ADDS     r4,r4,#1
;;;452                u8Tseg2++;
000058  b2e4              UXTB     r4,r4
00005a  e7e0              B        |L16.30|
                  |L16.92|
;;;453        }
;;;454    
;;;455        u32Brp  = SystemCoreClock / (u32BaudRate) / (u8Tseg1 + u8Tseg2 + 3) - 1;
00005c  1929              ADDS     r1,r5,r4
00005e  4638              MOV      r0,r7                 ;452
000060  1cc9              ADDS     r1,r1,#3
000062  f7fffffe          BL       __aeabi_uidivmod
;;;456    
;;;457        u32Value = ((uint32_t)u8Tseg2 << CAN_BTIME_TSEG2_Pos) | ((uint32_t)u8Tseg1 << CAN_BTIME_TSEG1_Pos) |
000066  0321              LSLS     r1,r4,#12
000068  022a              LSLS     r2,r5,#8
00006a  4311              ORRS     r1,r1,r2
00006c  1e40              SUBS     r0,r0,#1
00006e  0682              LSLS     r2,r0,#26
000070  0e92              LSRS     r2,r2,#26
000072  4311              ORRS     r1,r1,r2
000074  68f2              LDR      r2,[r6,#0xc]
000076  23c0              MOVS     r3,#0xc0
000078  401a              ANDS     r2,r2,r3
00007a  4311              ORRS     r1,r1,r2
;;;458                   (u32Brp & CAN_BTIME_BRP_Msk) | (tCAN->BTIME & CAN_BTIME_SJW_Msk);
;;;459        tCAN->BTIME = u32Value;
00007c  60f1              STR      r1,[r6,#0xc]
;;;460        tCAN->BRPE     = (u32Brp >> 6) & 0x0F;
00007e  0580              LSLS     r0,r0,#22
000080  0f00              LSRS     r0,r0,#28
000082  61b0              STR      r0,[r6,#0x18]
;;;461    
;;;462        CAN_LeaveInitMode(tCAN);
000084  4630              MOV      r0,r6
000086  f7fffffe          BL       CAN_LeaveInitMode
;;;463    
;;;464        return (CAN_GetCANBitRate(tCAN));
00008a  4630              MOV      r0,r6
00008c  f7fffffe          BL       CAN_GetCANBitRate
;;;465    
;;;466    }
000090  bdf8              POP      {r3-r7,pc}
;;;467    
                          ENDP

000092  0000              DCW      0x0000
                  |L16.148|
                          DCD      SystemCoreClock

                          AREA ||i.CAN_SetMultiRxMsg||, CODE, READONLY, ALIGN=1

                  CAN_SetMultiRxMsg PROC
;;;690      */
;;;691    int32_t CAN_SetMultiRxMsg(CAN_T *tCAN, uint32_t u32MsgNum , uint32_t u32MsgCount, uint32_t u32IDType, uint32_t u32ID)
000000  b5ff              PUSH     {r0-r7,lr}
;;;692    {
;;;693        uint32_t i = 0;
;;;694        uint32_t u32TimeOutCount;
;;;695        uint32_t u32EOB_Flag = 0;
000002  2000              MOVS     r0,#0
000004  b083              SUB      sp,sp,#0xc            ;692
000006  460e              MOV      r6,r1                 ;692
;;;696    
;;;697        for(i = 1; i < u32MsgCount; i++)
000008  2401              MOVS     r4,#1
00000a  9001              STR      r0,[sp,#4]            ;692
00000c  e014              B        |L17.56|
                  |L17.14|
;;;698        {
;;;699            u32TimeOutCount = 0;
;;;700    
;;;701            u32MsgNum += (i - 1);
00000e  1936              ADDS     r6,r6,r4
000010  2500              MOVS     r5,#0                 ;699
000012  1e76              SUBS     r6,r6,#1
;;;702    
;;;703            if(i == u32MsgCount) u32EOB_Flag = 1;
000014  4284              CMP      r4,r0
000016  d001              BEQ      |L17.28|
;;;704    
;;;705            while(CAN_SetRxMsgObj(tCAN, u32MsgNum, u32IDType, u32ID, u32EOB_Flag) == FALSE)
;;;706            {
;;;707                u32TimeOutCount++;
;;;708    
;;;709                if(u32TimeOutCount >= 0x10000000) return FALSE;
000018  9801              LDR      r0,[sp,#4]
00001a  e001              B        |L17.32|
                  |L17.28|
00001c  2001              MOVS     r0,#1                 ;703
00001e  9001              STR      r0,[sp,#4]            ;703
                  |L17.32|
000020  b2c7              UXTB     r7,r0                 ;705
                  |L17.34|
000022  9806              LDR      r0,[sp,#0x18]         ;705
000024  9700              STR      r7,[sp,#0]            ;705
000026  b2c2              UXTB     r2,r0                 ;705
000028  b2f1              UXTB     r1,r6                 ;705
00002a  9b0c              LDR      r3,[sp,#0x30]         ;705
00002c  9803              LDR      r0,[sp,#0xc]          ;705
00002e  f7fffffe          BL       CAN_SetRxMsgObj
000032  2800              CMP      r0,#0                 ;705
000034  d006              BEQ      |L17.68|
000036  1c64              ADDS     r4,r4,#1              ;705
                  |L17.56|
000038  9805              LDR      r0,[sp,#0x14]         ;697
00003a  4284              CMP      r4,r0                 ;697
00003c  d3e7              BCC      |L17.14|
;;;710            }
;;;711        }
;;;712    
;;;713        return TRUE;
00003e  2001              MOVS     r0,#1
                  |L17.64|
;;;714    }
000040  b007              ADD      sp,sp,#0x1c
000042  bdf0              POP      {r4-r7,pc}
                  |L17.68|
000044  2001              MOVS     r0,#1                 ;709
000046  0700              LSLS     r0,r0,#28             ;709
000048  1c6d              ADDS     r5,r5,#1              ;709
00004a  4285              CMP      r5,r0                 ;709
00004c  d3e9              BCC      |L17.34|
00004e  2000              MOVS     r0,#0                 ;709
000050  e7f6              B        |L17.64|
;;;715    
                          ENDP


                          AREA ||i.CAN_SetRxMsg||, CODE, READONLY, ALIGN=1

                  CAN_SetRxMsg PROC
;;;659      */
;;;660    int32_t CAN_SetRxMsg(CAN_T *tCAN, uint32_t u32MsgNum , uint32_t u32IDType, uint32_t u32ID)
000000  b5ff              PUSH     {r0-r7,lr}
;;;661    {
;;;662        uint32_t u32TimeOutCount = 0;
000002  2400              MOVS     r4,#0
;;;663    
;;;664        while(CAN_SetRxMsgObj(tCAN, u32MsgNum, u32IDType, u32ID, TRUE) == FALSE)
;;;665        {
;;;666            u32TimeOutCount++;
;;;667    
;;;668            if(u32TimeOutCount >= 0x10000000) return FALSE;
000004  2701              MOVS     r7,#1
000006  b081              SUB      sp,sp,#4              ;661
000008  4615              MOV      r5,r2                 ;661
00000a  460e              MOV      r6,r1                 ;661
00000c  073f              LSLS     r7,r7,#28
00000e  e005              B        |L18.28|
                  |L18.16|
000010  1c64              ADDS     r4,r4,#1              ;661
000012  42bc              CMP      r4,r7
000014  d302              BCC      |L18.28|
000016  2000              MOVS     r0,#0
                  |L18.24|
;;;669        }
;;;670    
;;;671        return TRUE;
;;;672    }
000018  b005              ADD      sp,sp,#0x14
00001a  bdf0              POP      {r4-r7,pc}
                  |L18.28|
00001c  2001              MOVS     r0,#1                 ;664
00001e  9000              STR      r0,[sp,#0]            ;664
000020  b2ea              UXTB     r2,r5                 ;664
000022  b2f1              UXTB     r1,r6                 ;664
000024  9b04              LDR      r3,[sp,#0x10]         ;664
000026  9801              LDR      r0,[sp,#4]            ;664
000028  f7fffffe          BL       CAN_SetRxMsgObj
00002c  2800              CMP      r0,#0                 ;664
00002e  d0ef              BEQ      |L18.16|
000030  2001              MOVS     r0,#1                 ;671
000032  e7f1              B        |L18.24|
;;;673    
                          ENDP


                          AREA ||i.CAN_SetRxMsgObj||, CODE, READONLY, ALIGN=1

                  CAN_SetRxMsgObj PROC
;;;312      */
;;;313    int32_t CAN_SetRxMsgObj(CAN_T  *tCAN, uint8_t u8MsgObj, uint8_t u8idType, uint32_t u32id, uint8_t u8singleOrFifoLast)
000000  b5f8              PUSH     {r3-r7,lr}
;;;314    {
000002  461c              MOV      r4,r3
000004  4616              MOV      r6,r2
000006  460d              MOV      r5,r1
000008  4607              MOV      r7,r0
;;;315        uint8_t u8MsgIfNum = 0;
;;;316    
;;;317        if((u8MsgIfNum = GetFreeIF(tCAN)) == 2)                         /* Check Free Interface for configure */
00000a  f7fffffe          BL       GetFreeIF
00000e  b2c0              UXTB     r0,r0
000010  2802              CMP      r0,#2
000012  d01b              BEQ      |L19.76|
;;;318        {
;;;319            return FALSE;
;;;320        }
;;;321        /* Command Setting */
;;;322        tCAN->IF[u8MsgIfNum].CMASK = CAN_IF_CMASK_WRRD_Msk | CAN_IF_CMASK_MASK_Msk | CAN_IF_CMASK_ARB_Msk |
000014  2260              MOVS     r2,#0x60
000016  21f3              MOVS     r1,#0xf3
000018  4350              MULS     r0,r2,r0
00001a  19c0              ADDS     r0,r0,r7
00001c  6241              STR      r1,[r0,#0x24]
00001e  2100              MOVS     r1,#0
;;;323                                     CAN_IF_CMASK_CONTROL_Msk | CAN_IF_CMASK_DATAA_Msk | CAN_IF_CMASK_DATAB_Msk;
;;;324    
;;;325        if(u8idType == CAN_STD_ID)    /* According STD/EXT ID format,Configure Mask and Arbitration register */
000020  2e00              CMP      r6,#0
000022  d015              BEQ      |L19.80|
;;;326        {
;;;327            tCAN->IF[u8MsgIfNum].ARB1 = 0;
;;;328            tCAN->IF[u8MsgIfNum].ARB2 = CAN_IF_ARB2_MSGVAL_Msk | (u32id & 0x7FF) << 2;
;;;329        }
;;;330        else
;;;331        {
;;;332            tCAN->IF[u8MsgIfNum].ARB1 = u32id & 0xFFFF;
000024  b2a2              UXTH     r2,r4
000026  6302              STR      r2,[r0,#0x30]
;;;333            tCAN->IF[u8MsgIfNum].ARB2 = CAN_IF_ARB2_MSGVAL_Msk | CAN_IF_ARB2_XTD_Msk | (u32id & 0x1FFF0000) >> 16;
000028  00e2              LSLS     r2,r4,#3
00002a  0cd2              LSRS     r2,r2,#19
00002c  2303              MOVS     r3,#3
00002e  039b              LSLS     r3,r3,#14
                  |L19.48|
000030  18d2              ADDS     r2,r2,r3
000032  6342              STR      r2,[r0,#0x34]
;;;334        }
;;;335    
;;;336        tCAN->IF[u8MsgIfNum].MCON |= CAN_IF_MCON_UMASK_Msk | CAN_IF_MCON_RXIE_Msk;
000034  6b82              LDR      r2,[r0,#0x38]
000036  2305              MOVS     r3,#5
000038  029b              LSLS     r3,r3,#10
00003a  431a              ORRS     r2,r2,r3
00003c  6382              STR      r2,[r0,#0x38]
;;;337        if(u8singleOrFifoLast)
00003e  9b06              LDR      r3,[sp,#0x18]
;;;338            tCAN->IF[u8MsgIfNum].MCON |= CAN_IF_MCON_EOB_Msk;
000040  2280              MOVS     r2,#0x80
000042  2b00              CMP      r3,#0                 ;337
;;;339        else
;;;340            tCAN->IF[u8MsgIfNum].MCON &= (~CAN_IF_MCON_EOB_Msk);
000044  6b83              LDR      r3,[r0,#0x38]
000046  d009              BEQ      |L19.92|
000048  4313              ORRS     r3,r3,r2              ;338
00004a  e008              B        |L19.94|
                  |L19.76|
00004c  2000              MOVS     r0,#0                 ;319
;;;341    
;;;342        tCAN->IF[u8MsgIfNum].DAT_A1  = 0;
;;;343        tCAN->IF[u8MsgIfNum].DAT_A2  = 0;
;;;344        tCAN->IF[u8MsgIfNum].DAT_B1  = 0;
;;;345        tCAN->IF[u8MsgIfNum].DAT_B2  = 0;
;;;346    
;;;347        tCAN->IF[u8MsgIfNum].CREQ = 1 + u8MsgObj;
;;;348    
;;;349        return TRUE;
;;;350    }
00004e  bdf8              POP      {r3-r7,pc}
                  |L19.80|
000050  6301              STR      r1,[r0,#0x30]         ;327
000052  0562              LSLS     r2,r4,#21             ;328
000054  0cd2              LSRS     r2,r2,#19             ;328
000056  2301              MOVS     r3,#1                 ;328
000058  03db              LSLS     r3,r3,#15             ;328
00005a  e7e9              B        |L19.48|
                  |L19.92|
00005c  4393              BICS     r3,r3,r2              ;340
                  |L19.94|
00005e  6383              STR      r3,[r0,#0x38]         ;340
000060  63c1              STR      r1,[r0,#0x3c]         ;342
000062  6401              STR      r1,[r0,#0x40]         ;343
000064  6441              STR      r1,[r0,#0x44]         ;344
000066  6481              STR      r1,[r0,#0x48]         ;345
000068  1c6d              ADDS     r5,r5,#1              ;345
00006a  6205              STR      r5,[r0,#0x20]         ;347
00006c  2001              MOVS     r0,#1                 ;349
00006e  bdf8              POP      {r3-r7,pc}
;;;351    
                          ENDP


                          AREA ||i.CAN_SetTxMsg||, CODE, READONLY, ALIGN=1

                  CAN_SetTxMsg PROC
;;;519      */
;;;520    int32_t CAN_SetTxMsg(CAN_T *tCAN, uint32_t u32MsgNum , STR_CANMSG_T* pCanMsg)
000000  b5f7              PUSH     {r0-r2,r4-r7,lr}
;;;521    {
;;;522        uint8_t u8MsgIfNum = 0;
;;;523        uint32_t i = 0;
000002  2500              MOVS     r5,#0
;;;524    
;;;525        while((u8MsgIfNum = GetFreeIF(tCAN)) == 2)
;;;526        {
;;;527            i++;
;;;528            if(i > 0x10000000)
000004  2601              MOVS     r6,#1
000006  4614              MOV      r4,r2                 ;521
000008  4607              MOV      r7,r0                 ;521
00000a  0736              LSLS     r6,r6,#28
00000c  e004              B        |L20.24|
                  |L20.14|
00000e  1c6d              ADDS     r5,r5,#1              ;521
000010  42b5              CMP      r5,r6
000012  d901              BLS      |L20.24|
;;;529                return FALSE;
000014  2000              MOVS     r0,#0
;;;530        }
;;;531    
;;;532        /* update the contents needed for transmission*/
;;;533        tCAN->IF[u8MsgIfNum].CMASK = 0xF3;  /* CAN_CMASK_WRRD_Msk | CAN_CMASK_MASK_Msk | CAN_CMASK_ARB_Msk
;;;534                                             | CAN_CMASK_CONTROL_Msk | CAN_CMASK_DATAA_Msk  | CAN_CMASK_DATAB_Msk ; */
;;;535    
;;;536        if(pCanMsg->IdType == CAN_STD_ID)
;;;537        {
;;;538            /* standard ID*/
;;;539            tCAN->IF[u8MsgIfNum].ARB1 = 0;
;;;540            tCAN->IF[u8MsgIfNum].ARB2 = (((pCanMsg->Id) & 0x7FF) << 2) | CAN_IF_ARB2_DIR_Msk | CAN_IF_ARB2_MSGVAL_Msk;
;;;541        }
;;;542        else
;;;543        {
;;;544            /* extended ID*/
;;;545            tCAN->IF[u8MsgIfNum].ARB1 = (pCanMsg->Id) & 0xFFFF;
;;;546            tCAN->IF[u8MsgIfNum].ARB2 = ((pCanMsg->Id) & 0x1FFF0000) >> 16 | CAN_IF_ARB2_DIR_Msk
;;;547                                        | CAN_IF_ARB2_XTD_Msk | CAN_IF_ARB2_MSGVAL_Msk;
;;;548        }
;;;549    
;;;550        if(pCanMsg->FrameType)
;;;551            tCAN->IF[u8MsgIfNum].ARB2 |=   CAN_IF_ARB2_DIR_Msk;
;;;552        else
;;;553            tCAN->IF[u8MsgIfNum].ARB2 &= (~CAN_IF_ARB2_DIR_Msk);
;;;554    
;;;555        tCAN->IF[u8MsgIfNum].DAT_A1 = ((uint16_t)pCanMsg->Data[1] << 8) | pCanMsg->Data[0];
;;;556        tCAN->IF[u8MsgIfNum].DAT_A2 = ((uint16_t)pCanMsg->Data[3] << 8) | pCanMsg->Data[2];
;;;557        tCAN->IF[u8MsgIfNum].DAT_B1 = ((uint16_t)pCanMsg->Data[5] << 8) | pCanMsg->Data[4];
;;;558        tCAN->IF[u8MsgIfNum].DAT_B2 = ((uint16_t)pCanMsg->Data[7] << 8) | pCanMsg->Data[6];
;;;559    
;;;560        tCAN->IF[u8MsgIfNum].MCON   =  CAN_IF_MCON_NEWDAT_Msk | pCanMsg->DLC | CAN_IF_MCON_TXIE_Msk | CAN_IF_MCON_EOB_Msk;
;;;561        tCAN->IF[u8MsgIfNum].CREQ   = 1 + u32MsgNum;
;;;562    
;;;563        return TRUE;
;;;564    }
000016  bdfe              POP      {r1-r7,pc}
                  |L20.24|
000018  4638              MOV      r0,r7                 ;525
00001a  f7fffffe          BL       GetFreeIF
00001e  b2c0              UXTB     r0,r0                 ;525
000020  2802              CMP      r0,#2                 ;525
000022  d0f4              BEQ      |L20.14|
000024  2260              MOVS     r2,#0x60              ;533
000026  21f3              MOVS     r1,#0xf3              ;533
000028  4350              MULS     r0,r2,r0              ;533
00002a  19c0              ADDS     r0,r0,r7              ;533
00002c  6241              STR      r1,[r0,#0x24]         ;533
00002e  2101              MOVS     r1,#1                 ;546
000030  6822              LDR      r2,[r4,#0]            ;536
000032  0349              LSLS     r1,r1,#13             ;546
000034  2a00              CMP      r2,#0                 ;536
000036  d010              BEQ      |L20.90|
000038  8922              LDRH     r2,[r4,#8]            ;545
00003a  b292              UXTH     r2,r2                 ;545
00003c  6302              STR      r2,[r0,#0x30]         ;545
00003e  68a2              LDR      r2,[r4,#8]            ;546
000040  2303              MOVS     r3,#3                 ;546
000042  00d2              LSLS     r2,r2,#3              ;546
000044  0cd2              LSRS     r2,r2,#19             ;546
000046  1852              ADDS     r2,r2,r1              ;546
000048  039b              LSLS     r3,r3,#14             ;546
00004a  431a              ORRS     r2,r2,r3              ;546
                  |L20.76|
00004c  6342              STR      r2,[r0,#0x34]         ;546
00004e  6862              LDR      r2,[r4,#4]            ;550
000050  2a00              CMP      r2,#0                 ;550
000052  6b42              LDR      r2,[r0,#0x34]         ;553
000054  d00a              BEQ      |L20.108|
000056  430a              ORRS     r2,r2,r1              ;551
000058  e009              B        |L20.110|
                  |L20.90|
00005a  2200              MOVS     r2,#0                 ;539
00005c  6302              STR      r2,[r0,#0x30]         ;539
00005e  8922              LDRH     r2,[r4,#8]            ;540
000060  2305              MOVS     r3,#5                 ;540
000062  0552              LSLS     r2,r2,#21             ;540
000064  0cd2              LSRS     r2,r2,#19             ;540
000066  035b              LSLS     r3,r3,#13             ;540
000068  18d2              ADDS     r2,r2,r3              ;540
00006a  e7ef              B        |L20.76|
                  |L20.108|
00006c  438a              BICS     r2,r2,r1              ;553
                  |L20.110|
00006e  6342              STR      r2,[r0,#0x34]         ;553
000070  1c61              ADDS     r1,r4,#1              ;555
000072  7ba3              LDRB     r3,[r4,#0xe]          ;555
000074  460a              MOV      r2,r1                 ;555
000076  7b65              LDRB     r5,[r4,#0xd]          ;555
000078  0219              LSLS     r1,r3,#8              ;555
00007a  4329              ORRS     r1,r1,r5              ;555
00007c  63c1              STR      r1,[r0,#0x3c]         ;555
00007e  7c23              LDRB     r3,[r4,#0x10]         ;556
000080  7be5              LDRB     r5,[r4,#0xf]          ;556
000082  021b              LSLS     r3,r3,#8              ;556
000084  432b              ORRS     r3,r3,r5              ;556
000086  6403              STR      r3,[r0,#0x40]         ;556
000088  7c53              LDRB     r3,[r2,#0x11]         ;557
00008a  7c15              LDRB     r5,[r2,#0x10]         ;557
00008c  021a              LSLS     r2,r3,#8              ;557
00008e  432a              ORRS     r2,r2,r5              ;557
000090  6442              STR      r2,[r0,#0x44]         ;557
000092  7d22              LDRB     r2,[r4,#0x14]         ;558
000094  7ce3              LDRB     r3,[r4,#0x13]         ;558
000096  0211              LSLS     r1,r2,#8              ;558
000098  4319              ORRS     r1,r1,r3              ;558
00009a  6481              STR      r1,[r0,#0x48]         ;558
00009c  7b21              LDRB     r1,[r4,#0xc]          ;560
00009e  2201              MOVS     r2,#1                 ;560
0000a0  03d2              LSLS     r2,r2,#15             ;560
0000a2  1889              ADDS     r1,r1,r2              ;560
0000a4  2211              MOVS     r2,#0x11              ;560
0000a6  01d2              LSLS     r2,r2,#7              ;560
0000a8  4311              ORRS     r1,r1,r2              ;560
0000aa  6381              STR      r1,[r0,#0x38]         ;560
0000ac  9901              LDR      r1,[sp,#4]            ;561
0000ae  1c49              ADDS     r1,r1,#1              ;561
0000b0  6201              STR      r1,[r0,#0x20]         ;561
0000b2  2001              MOVS     r0,#1                 ;563
0000b4  bdfe              POP      {r1-r7,pc}
;;;565    
                          ENDP


                          AREA ||i.CAN_Transmit||, CODE, READONLY, ALIGN=1

                  CAN_Transmit PROC
;;;729      */
;;;730    int32_t CAN_Transmit(CAN_T *tCAN, uint32_t u32MsgNum , STR_CANMSG_T* pCanMsg)
000000  b570              PUSH     {r4-r6,lr}
;;;731    {
000002  4604              MOV      r4,r0
;;;732        if((tCAN->CON & CAN_CON_TEST_Msk) && (tCAN->TEST & CAN_TEST_BASIC_Msk))
000004  6800              LDR      r0,[r0,#0]
000006  460d              MOV      r5,r1                 ;731
000008  0600              LSLS     r0,r0,#24
00000a  d507              BPL      |L21.28|
00000c  6960              LDR      r0,[r4,#0x14]
00000e  0740              LSLS     r0,r0,#29
000010  d504              BPL      |L21.28|
;;;733        {
;;;734            return (CAN_BasicSendMsg(tCAN, pCanMsg));
000012  4611              MOV      r1,r2
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       CAN_BasicSendMsg
                  |L21.26|
;;;735        }
;;;736        else
;;;737        {
;;;738            if(CAN_SetTxMsg(tCAN, u32MsgNum, pCanMsg) == FALSE)
;;;739                return FALSE;
;;;740            CAN_TriggerTxMsg(tCAN, u32MsgNum);
;;;741        }
;;;742    
;;;743        return TRUE;
;;;744    }
00001a  bd70              POP      {r4-r6,pc}
                  |L21.28|
00001c  4620              MOV      r0,r4                 ;738
00001e  f7fffffe          BL       CAN_SetTxMsg
000022  2800              CMP      r0,#0                 ;738
000024  d0f9              BEQ      |L21.26|
000026  4629              MOV      r1,r5                 ;740
000028  4620              MOV      r0,r4                 ;740
00002a  f7fffffe          BL       CAN_TriggerTxMsg
00002e  2001              MOVS     r0,#1                 ;743
000030  bd70              POP      {r4-r6,pc}
;;;745    
                          ENDP


                          AREA ||i.CAN_TriggerTxMsg||, CODE, READONLY, ALIGN=1

                  CAN_TriggerTxMsg PROC
;;;575      */
;;;576    int32_t CAN_TriggerTxMsg(CAN_T  *tCAN, uint32_t u32MsgNum)
000000  6842              LDR      r2,[r0,#4]
;;;577    {
;;;578    
;;;579        tCAN->STATUS &= (~CAN_STATUS_TXOK_Msk);
000002  2308              MOVS     r3,#8
000004  439a              BICS     r2,r2,r3
000006  6042              STR      r2,[r0,#4]
;;;580    
;;;581        /* read the message contents*/
;;;582        tCAN->IF[1].CMASK = CAN_IF_CMASK_CLRINTPND_Msk
000008  230c              MOVS     r3,#0xc
00000a  4602              MOV      r2,r0
00000c  3280              ADDS     r2,r2,#0x80
00000e  6053              STR      r3,[r2,#4]
000010  1c49              ADDS     r1,r1,#1
;;;583                            | CAN_IF_CMASK_TXRQSTNEWDAT_Msk;
;;;584    
;;;585        tCAN->IF[1].CREQ = 1 + u32MsgNum;
000012  6011              STR      r1,[r2,#0]
                  |L22.20|
;;;586    
;;;587        while(tCAN->IF[1].CREQ & CAN_IF_CREQ_BUSY_Msk)
000014  6813              LDR      r3,[r2,#0]
000016  041b              LSLS     r3,r3,#16
000018  d4fc              BMI      |L22.20|
;;;588        {
;;;589            /*Wait*/
;;;590        }
;;;591        tCAN->IF[0].CMASK  = CAN_IF_CMASK_WRRD_Msk | CAN_IF_CMASK_TXRQSTNEWDAT_Msk;
00001a  2284              MOVS     r2,#0x84
00001c  6242              STR      r2,[r0,#0x24]
;;;592        tCAN->IF[0].CREQ  = 1 + u32MsgNum;
00001e  6201              STR      r1,[r0,#0x20]
;;;593    
;;;594        return TRUE;
000020  2001              MOVS     r0,#1
;;;595    }
000022  4770              BX       lr
;;;596    
                          ENDP


                          AREA ||i.CAN_WaitMsg||, CODE, READONLY, ALIGN=1

                  CAN_WaitMsg PROC
;;;88       */
;;;89     void CAN_WaitMsg(CAN_T *tCAN)
000000  2100              MOVS     r1,#0
;;;90     {
;;;91         tCAN->STATUS = 0x0; /* clr status */
000002  6041              STR      r1,[r0,#4]
;;;92     
;;;93         while(1)
;;;94         {
;;;95             if(tCAN->IF[1].MCON & CAN_IF_MCON_NEWDAT_Msk)   /* check new data */
000004  4601              MOV      r1,r0
000006  3180              ADDS     r1,r1,#0x80
                  |L23.8|
000008  698a              LDR      r2,[r1,#0x18]
00000a  0412              LSLS     r2,r2,#16
00000c  d402              BMI      |L23.20|
;;;96             {
;;;97                 DEBUG_PRINTF("New Data IN\n");
;;;98                 break;
;;;99             }
;;;100            if(tCAN->STATUS & CAN_STATUS_RXOK_Msk)
00000e  6842              LDR      r2,[r0,#4]
;;;101                DEBUG_PRINTF("Rx OK\n");
;;;102    
;;;103            if(tCAN->STATUS & CAN_STATUS_LEC_Msk)
000010  6842              LDR      r2,[r0,#4]
000012  e7f9              B        |L23.8|
                  |L23.20|
;;;104            {
;;;105                DEBUG_PRINTF("Error\n");
;;;106            }
;;;107        }
;;;108    }
000014  4770              BX       lr
;;;109    
                          ENDP


                          AREA ||i.GetFreeIF||, CODE, READONLY, ALIGN=1

                  GetFreeIF PROC
;;;41       */
;;;42     static uint32_t GetFreeIF(CAN_T  *tCAN)
000000  6a01              LDR      r1,[r0,#0x20]
;;;43     {
;;;44         if((tCAN->IF[0].CREQ & CAN_IF_CREQ_BUSY_Msk) == 0)
000002  0409              LSLS     r1,r1,#16
000004  d401              BMI      |L24.10|
;;;45             return 0;
000006  2000              MOVS     r0,#0
;;;46         else if((tCAN->IF[1].CREQ  & CAN_IF_CREQ_BUSY_Msk) == 0)
;;;47             return 1;
;;;48         else
;;;49             return 2;
;;;50     }
000008  4770              BX       lr
                  |L24.10|
00000a  3080              ADDS     r0,r0,#0x80
00000c  6800              LDR      r0,[r0,#0]            ;46
00000e  0400              LSLS     r0,r0,#16             ;46
000010  d401              BMI      |L24.22|
000012  2001              MOVS     r0,#1                 ;47
000014  4770              BX       lr
                  |L24.22|
000016  2002              MOVS     r0,#2                 ;49
000018  4770              BX       lr
;;;51     
                          ENDP


;*** Start embedded assembler ***

#line 1 "Libraries\\StdDriver\\src\\can.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_can_c_0fdded17____REV16|
#line 118 ".\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___5_can_c_0fdded17____REV16| PROC
#line 119

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_can_c_0fdded17____REVSH|
#line 132
|__asm___5_can_c_0fdded17____REVSH| PROC
#line 133

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
