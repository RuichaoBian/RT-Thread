; generated by Component: ARM Compiler 5.06 update 3 (build 300) Tool: ArmCC [4d35f0]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\objects\idle.o --asm_dir=.\Listings\ --list_dir=.\Listings\ --depend=.\objects\idle.d --cpu=Cortex-M0 --apcs=interwork --diag_suppress=9931 -I.\Libraries\Device\Nuvoton -I..\..\components\finsh -I.\Libraries\CMSIS\Include -I.\Libraries\StdDriver\inc -I..\..\include -I.\APP -I.\Drivers -I..\..\components\drivers\include -I..\..\components\drivers\include\drivers -I..\nuvoton_nuc240 -I.\Libraries\Device\Nuvoton\NUC230_240\Include -I..\..\include -I..\..\components\drivers\usb\usbdevice\class -IC:\Keil_v5\ARM\RV31\INC -IC:\Keil_v5\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=521 --omf_browse=.\objects\idle.crf ..\..\src\idle.c]
                          THUMB

                          AREA ||i._has_defunct_thread||, CODE, READONLY, ALIGN=2

                  _has_defunct_thread PROC
;;;71     /* Return whether there is defunctional thread to be deleted. */
;;;72     rt_inline int _has_defunct_thread(void)
000000  4803              LDR      r0,|L1.16|
;;;73     {
;;;74         /* The rt_list_isempty has prototype of "int rt_list_isempty(const rt_list_t *l)".
;;;75          * So the compiler has a good reason that the rt_thread_defunct list does
;;;76          * not change within rt_thread_idle_excute thus optimize the "while" loop
;;;77          * into a "if".
;;;78          *
;;;79          * So add the volatile qualifier here. */
;;;80         const volatile rt_list_t *l = (const volatile rt_list_t*)&rt_thread_defunct;
;;;81     
;;;82         return l->next != l;
000002  6801              LDR      r1,[r0,#0]
000004  4281              CMP      r1,r0
000006  d001              BEQ      |L1.12|
000008  2001              MOVS     r0,#1
;;;83     }
00000a  4770              BX       lr
                  |L1.12|
00000c  2000              MOVS     r0,#0                 ;82
00000e  4770              BX       lr
;;;84     
                          ENDP

                  |L1.16|
                          DCD      rt_thread_defunct

                          AREA ||i.rt_thread_idle_entry||, CODE, READONLY, ALIGN=1

                  rt_thread_idle_entry PROC
                  |L2.0|
;;;183    
;;;184    static void rt_thread_idle_entry(void *parameter)
000000  f7fffffe          BL       rt_thread_idle_excute
;;;185    {
;;;186        while (1)
;;;187        {
;;;188        #ifdef RT_USING_IDLE_HOOK
;;;189            if (rt_thread_idle_hook != RT_NULL)
;;;190            {
;;;191                rt_thread_idle_hook();
;;;192            }
;;;193        #endif
;;;194    
;;;195            rt_thread_idle_excute();
000004  e7fc              B        |L2.0|
;;;196        }
;;;197    }
;;;198    
                          ENDP


                          AREA ||i.rt_thread_idle_excute||, CODE, READONLY, ALIGN=2

                  rt_thread_idle_excute PROC
;;;89      */
;;;90     void rt_thread_idle_excute(void)
000000  b570              PUSH     {r4-r6,lr}
;;;91     {
;;;92         /* Loop until there is no dead thread. So one call to rt_thread_idle_excute
;;;93          * will do all the cleanups. */
;;;94         while (_has_defunct_thread())
;;;95         {
;;;96             rt_base_t lock;
;;;97             rt_thread_t thread;
;;;98     #ifdef RT_USING_MODULE
;;;99             rt_module_t module = RT_NULL;
;;;100    #endif
;;;101            RT_DEBUG_NOT_IN_INTERRUPT;
;;;102    
;;;103            /* disable interrupt */
;;;104            lock = rt_hw_interrupt_disable();
;;;105    
;;;106            /* re-check whether list is empty */
;;;107            if (_has_defunct_thread())
;;;108            {
;;;109                /* get defunct thread */
;;;110                thread = rt_list_entry(rt_thread_defunct.next,
;;;111                                       struct rt_thread,
;;;112                                       tlist);
;;;113    #ifdef RT_USING_MODULE
;;;114                /* get thread's parent module */
;;;115                module = (rt_module_t)thread->module_id;
;;;116    
;;;117                /* if the thread is module's main thread */
;;;118                if (module != RT_NULL && module->module_thread == thread)
;;;119                {
;;;120                    /* detach module's main thread */
;;;121                    module->module_thread = RT_NULL;
;;;122                }
;;;123    #endif
;;;124                /* remove defunct thread */
;;;125                rt_list_remove(&(thread->tlist));
;;;126                /* invoke thread cleanup */
;;;127                if (thread->cleanup != RT_NULL)
;;;128                    thread->cleanup(thread);
;;;129    
;;;130                /* if it's a system object, not delete it */
;;;131                if (rt_object_is_systemobject((rt_object_t)thread) == RT_TRUE)
;;;132                {
;;;133                    /* enable interrupt */
;;;134                    rt_hw_interrupt_enable(lock);
;;;135    
;;;136                    return;
;;;137                }
;;;138            }
;;;139            else
;;;140            {
;;;141                /* enable interrupt */
;;;142                rt_hw_interrupt_enable(lock);
;;;143    
;;;144                /* may the defunct thread list is removed by others, just return */
;;;145                return;
;;;146            }
;;;147    
;;;148            /* enable interrupt */
;;;149            rt_hw_interrupt_enable(lock);
;;;150    
;;;151    #ifdef RT_USING_HEAP
;;;152    #if defined(RT_USING_MODULE) && defined(RT_USING_SLAB)
;;;153            /* the thread belongs to an application module */
;;;154            if (thread->flags & RT_OBJECT_FLAG_MODULE)
;;;155                rt_module_free((rt_module_t)thread->module_id, thread->stack_addr);
;;;156            else
;;;157    #endif
;;;158            /* release thread's stack */
;;;159            RT_KERNEL_FREE(thread->stack_addr);
;;;160            /* delete thread object */
;;;161            rt_object_delete((rt_object_t)thread);
;;;162    #endif
;;;163    
;;;164    #ifdef RT_USING_MODULE
;;;165            if (module != RT_NULL)
;;;166            {
;;;167                extern rt_err_t rt_module_destroy(rt_module_t module);
;;;168    
;;;169                /* if sub thread list and main thread are all empty */
;;;170                if ((module->module_thread == RT_NULL) &&
;;;171                    rt_list_isempty(&module->module_object[RT_Object_Class_Thread].object_list))
;;;172                {
;;;173                    module->nref --;
;;;174                }
;;;175    
;;;176                /* destroy module */
;;;177                if (module->nref == 0)
;;;178                    rt_module_destroy(module);
;;;179            }
;;;180    #endif
;;;181        }
000002  e025              B        |L3.80|
                  |L3.4|
000004  f7fffffe          BL       rt_hw_interrupt_disable
000008  4605              MOV      r5,r0                 ;104
00000a  f7fffffe          BL       _has_defunct_thread
00000e  2800              CMP      r0,#0                 ;107
000010  d023              BEQ      |L3.90|
000012  4814              LDR      r0,|L3.100|
000014  6801              LDR      r1,[r0,#0]            ;110  ; rt_thread_defunct
000016  460c              MOV      r4,r1                 ;110
000018  c905              LDM      r1!,{r0,r2}           ;110
00001a  3908              SUBS     r1,r1,#8              ;110
00001c  6042              STR      r2,[r0,#4]            ;110
00001e  c905              LDM      r1!,{r0,r2}           ;110
000020  3908              SUBS     r1,r1,#8              ;110
000022  6010              STR      r0,[r2,#0]            ;110
000024  6049              STR      r1,[r1,#4]            ;110
000026  3c14              SUBS     r4,r4,#0x14           ;110
000028  6009              STR      r1,[r1,#0]            ;110
00002a  6fa1              LDR      r1,[r4,#0x78]         ;127
00002c  2900              CMP      r1,#0                 ;127
00002e  d001              BEQ      |L3.52|
000030  4620              MOV      r0,r4                 ;128
000032  4788              BLX      r1                    ;128
                  |L3.52|
000034  4620              MOV      r0,r4                 ;131
000036  f7fffffe          BL       rt_object_is_systemobject
00003a  2801              CMP      r0,#1                 ;131
00003c  d00d              BEQ      |L3.90|
00003e  4628              MOV      r0,r5                 ;149
000040  f7fffffe          BL       rt_hw_interrupt_enable
000044  6aa0              LDR      r0,[r4,#0x28]         ;159
000046  f7fffffe          BL       rt_free
00004a  4620              MOV      r0,r4                 ;161
00004c  f7fffffe          BL       rt_object_delete
                  |L3.80|
000050  f7fffffe          BL       _has_defunct_thread
000054  2800              CMP      r0,#0                 ;94
000056  d1d5              BNE      |L3.4|
;;;182    }
000058  bd70              POP      {r4-r6,pc}
                  |L3.90|
00005a  4628              MOV      r0,r5                 ;142
00005c  f7fffffe          BL       rt_hw_interrupt_enable
000060  bd70              POP      {r4-r6,pc}
;;;183    
                          ENDP

000062  0000              DCW      0x0000
                  |L3.100|
                          DCD      rt_thread_defunct

                          AREA ||i.rt_thread_idle_gethandler||, CODE, READONLY, ALIGN=2

                  rt_thread_idle_gethandler PROC
;;;227     */
;;;228    rt_thread_t rt_thread_idle_gethandler(void)
000000  4800              LDR      r0,|L4.4|
;;;229    {
;;;230        return (rt_thread_t)(&idle);
;;;231    }
000002  4770              BX       lr
                          ENDP

                  |L4.4|
                          DCD      ||.bss||

                          AREA ||i.rt_thread_idle_init||, CODE, READONLY, ALIGN=2

                  rt_thread_idle_init PROC
;;;205     */
;;;206    void rt_thread_idle_init(void)
000000  b51f              PUSH     {r0-r4,lr}
;;;207    {
;;;208        /* initialize thread */
;;;209        rt_thread_init(&idle,
000002  4808              LDR      r0,|L5.36|
000004  2320              MOVS     r3,#0x20
000006  221f              MOVS     r2,#0x1f
000008  2180              MOVS     r1,#0x80
00000a  466c              MOV      r4,sp
00000c  c40f              STM      r4!,{r0-r3}
00000e  2300              MOVS     r3,#0
000010  4a05              LDR      r2,|L5.40|
000012  a106              ADR      r1,|L5.44|
000014  3880              SUBS     r0,r0,#0x80
000016  f7fffffe          BL       rt_thread_init
;;;210                       "tidle",
;;;211                       rt_thread_idle_entry,
;;;212                       RT_NULL,
;;;213                       &rt_thread_stack[0],
;;;214                       sizeof(rt_thread_stack),
;;;215                       RT_THREAD_PRIORITY_MAX - 1,
;;;216                       32);
;;;217    
;;;218        /* startup */
;;;219        rt_thread_startup(&idle);
00001a  4802              LDR      r0,|L5.36|
00001c  3880              SUBS     r0,r0,#0x80
00001e  f7fffffe          BL       rt_thread_startup
;;;220    }
000022  bd1f              POP      {r0-r4,pc}
;;;221    
                          ENDP

                  |L5.36|
                          DCD      ||.bss||+0x80
                  |L5.40|
                          DCD      rt_thread_idle_entry
                  |L5.44|
00002c  7469646c          DCB      "tidle",0
000030  6500    
000032  00                DCB      0
000033  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  idle
                          %        128
                  rt_thread_stack
                          %        128
